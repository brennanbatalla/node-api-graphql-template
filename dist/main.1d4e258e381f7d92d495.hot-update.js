exports.id = "main";
exports.ids = null;
exports.modules = {

/***/ "./node_modules/any-promise/index.js":
/*!*******************************************!*\
  !*** ./node_modules/any-promise/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./register */ "./node_modules/any-promise/register.js")().Promise


/***/ }),

/***/ "./node_modules/any-promise/loader.js":
/*!********************************************!*\
  !*** ./node_modules/any-promise/loader.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";

    // global key for user preferred registration
var REGISTRATION_KEY = '@@any-promise/REGISTRATION',
    // Prior registration (preferred or detected)
    registered = null

/**
 * Registers the given implementation.  An implementation must
 * be registered prior to any call to `require("any-promise")`,
 * typically on application load.
 *
 * If called with no arguments, will return registration in
 * following priority:
 *
 * For Node.js:
 *
 * 1. Previous registration
 * 2. global.Promise if node.js version >= 0.12
 * 3. Auto detected promise based on first sucessful require of
 *    known promise libraries. Note this is a last resort, as the
 *    loaded library is non-deterministic. node.js >= 0.12 will
 *    always use global.Promise over this priority list.
 * 4. Throws error.
 *
 * For Browser:
 *
 * 1. Previous registration
 * 2. window.Promise
 * 3. Throws error.
 *
 * Options:
 *
 * Promise: Desired Promise constructor
 * global: Boolean - Should the registration be cached in a global variable to
 * allow cross dependency/bundle registration?  (default true)
 */
module.exports = function(root, loadImplementation){
  return function register(implementation, opts){
    implementation = implementation || null
    opts = opts || {}
    // global registration unless explicitly  {global: false} in options (default true)
    var registerGlobal = opts.global !== false;

    // load any previous global registration
    if(registered === null && registerGlobal){
      registered = root[REGISTRATION_KEY] || null
    }

    if(registered !== null
        && implementation !== null
        && registered.implementation !== implementation){
      // Throw error if attempting to redefine implementation
      throw new Error('any-promise already defined as "'+registered.implementation+
        '".  You can only register an implementation before the first '+
        ' call to require("any-promise") and an implementation cannot be changed')
    }

    if(registered === null){
      // use provided implementation
      if(implementation !== null && typeof opts.Promise !== 'undefined'){
        registered = {
          Promise: opts.Promise,
          implementation: implementation
        }
      } else {
        // require implementation if implementation is specified but not provided
        registered = loadImplementation(implementation)
      }

      if(registerGlobal){
        // register preference globally in case multiple installations
        root[REGISTRATION_KEY] = registered
      }
    }

    return registered
  }
}


/***/ }),

/***/ "./node_modules/any-promise/register.js":
/*!**********************************************!*\
  !*** ./node_modules/any-promise/register.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./loader */ "./node_modules/any-promise/loader.js")(global, loadImplementation);

/**
 * Node.js version of loadImplementation.
 *
 * Requires the given implementation and returns the registration
 * containing {Promise, implementation}
 *
 * If implementation is undefined or global.Promise, loads it
 * Otherwise uses require
 */
function loadImplementation(implementation){
  var impl = null

  if(shouldPreferGlobalPromise(implementation)){
    // if no implementation or env specified use global.Promise
    impl = {
      Promise: global.Promise,
      implementation: 'global.Promise'
    }
  } else if(implementation){
    // if implementation specified, require it
    var lib = __webpack_require__("./node_modules/any-promise sync recursive")(implementation)
    impl = {
      Promise: lib.Promise || lib,
      implementation: implementation
    }
  } else {
    // try to auto detect implementation. This is non-deterministic
    // and should prefer other branches, but this is our last chance
    // to load something without throwing error
    impl = tryAutoDetect()
  }

  if(impl === null){
    throw new Error('Cannot find any-promise implementation nor'+
      ' global.Promise. You must install polyfill or call'+
      ' require("any-promise/register") with your preferred'+
      ' implementation, e.g. require("any-promise/register/bluebird")'+
      ' on application load prior to any require("any-promise").')
  }

  return impl
}

/**
 * Determines if the global.Promise should be preferred if an implementation
 * has not been registered.
 */
function shouldPreferGlobalPromise(implementation){
  if(implementation){
    return implementation === 'global.Promise'
  } else if(typeof global.Promise !== 'undefined'){
    // Load global promise if implementation not specified
    // Versions < 0.11 did not have global Promise
    // Do not use for version < 0.12 as version 0.11 contained buggy versions
    var version = (/v(\d+)\.(\d+)\.(\d+)/).exec(process.version)
    return !(version && +version[1] == 0 && +version[2] < 12)
  }

  // do not have global.Promise or another implementation was specified
  return false
}

/**
 * Look for common libs as last resort there is no guarantee that
 * this will return a desired implementation or even be deterministic.
 * The priority is also nearly arbitrary. We are only doing this
 * for older versions of Node.js <0.12 that do not have a reasonable
 * global.Promise implementation and we the user has not registered
 * the preference. This preserves the behavior of any-promise <= 0.1
 * and may be deprecated or removed in the future
 */
function tryAutoDetect(){
  var libs = [
      "es6-promise",
      "promise",
      "native-promise-only",
      "bluebird",
      "rsvp",
      "when",
      "q",
      "pinkie",
      "lie",
      "vow"]
  var i = 0, len = libs.length
  for(; i < len; i++){
    try {
      return loadImplementation(libs[i])
    } catch(e){}
  }
  return null
}


/***/ }),

/***/ "./node_modules/any-promise sync recursive":
/*!****************************************!*\
  !*** ./node_modules/any-promise/ sync ***!
  \****************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/any-promise sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/dottie/dottie.js":
/*!***************************************!*\
  !*** ./node_modules/dottie/dottie.js ***!
  \***************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(undefined) {
  var root = this;

  // Weird IE shit, objects do not have hasOwn, but the prototype does...
  var hasOwnProp = Object.prototype.hasOwnProperty;

  var reverseDupArray = function (array) {
    var result = new Array(array.length);
    var index  = array.length;
    var arrayMaxIndex = index - 1;

    while (index--) {
      result[arrayMaxIndex - index] = array[index];
    }

    return result;
  };

  var Dottie = function() {
    var args = Array.prototype.slice.call(arguments);

    if (args.length == 2) {
      return Dottie.find.apply(this, args);
    }
    return Dottie.transform.apply(this, args);
  };

  // Legacy syntax, changed syntax to have get/set be similar in arg order
  Dottie.find = function(path, object) {
    return Dottie.get(object, path);
  };

  // Dottie memoization flag
  Dottie.memoizePath = true;
  var memoized = {};

  // Traverse object according to path, return value if found - Return undefined if destination is unreachable
  Dottie.get = function(object, path, defaultVal) {
    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {
        return defaultVal;
    }

    var names;

    if (typeof path === "string") {
      if (Dottie.memoizePath) {
        if (memoized[path]) {
          names = memoized[path].slice(0);
        } else {
          names = path.split('.').reverse();
          memoized[path] = names.slice(0);
        }
      } else {
        names = path.split('.').reverse();
      }
    } else if (Array.isArray(path)) {
      names = reverseDupArray(path);
    }

    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);

    // Handle cases where accessing a childprop of a null value
    if (object === null && names.length) object = undefined;

    return (object === undefined ? defaultVal : object);
  };

  Dottie.exists = function(object, path) {
    return Dottie.get(object, path) !== undefined;
  };

  // Set nested value
  Dottie.set = function(object, path, value, options) {
    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;

    if (typeof current !== 'object') {
        throw new Error('Parent is not an object.');
    }

    for (var index = 0; index < length; index++) {
      piece = pieces[index];

      // Create namespace (object) where none exists.
      // If `force === true`, bruteforce the path without throwing errors.
      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || (typeof current[piece] !== 'object' && options && options.force === true)) {
        current[piece] = {};
      }

      if (index == (length - 1)) {
        // Set final value
        current[piece] = value;
      } else {
        // We do not overwrite existing path pieces by default
        if (typeof current[piece] !== 'object') {
          throw new Error('Target key "' + piece + '" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');
        }

        // Traverse next in path
        current = current[piece];
      }
    }

    // Is there any case when this is relevant? It's also the last line in the above for-loop
    current[piece] = value;
  };

  // Set default nested value
  Dottie['default'] = function(object, path, value) {
    if (Dottie.get(object, path) === undefined) {
      Dottie.set(object, path, value);
    }
  };

  // Transform unnested object with .-seperated keys into a nested object.
  Dottie.transform = function Dottie$transformfunction(object, options) {
    if (Array.isArray(object)) {
      return object.map(function(o) {
        return Dottie.transform(o, options);
      });
    }

    options = options || {};
    options.delimiter = options.delimiter || '.';

    var pieces
      , piecesLength
      , piece
      , current
      , transformed = {}
      , key
      , keys = Object.keys(object)
      , length = keys.length
      , i;

    for (i = 0; i < length; i++) {
      key = keys[i];

      if (key.indexOf(options.delimiter) !== -1) {
        pieces = key.split(options.delimiter);
        piecesLength = pieces.length;
        current = transformed;

        for (var index = 0; index < piecesLength; index++) {
          piece = pieces[index];
          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {
            current[piece] = {};
          }

          if (index == (piecesLength - 1)) {
            current[piece] = object[key];
          }

          current = current[piece];
          if (current === null) {
            break;
          }
        }
      } else {
        transformed[key] = object[key];
      }
    }

    return transformed;
  };

  Dottie.flatten = function(object, seperator) {
    if (typeof seperator === "undefined") seperator = '.';
    var flattened = {}
      , current
      , nested;

    for (var key in object) {
      if (hasOwnProp.call(object, key)) {
        current = object[key];
        if (Object.prototype.toString.call(current) === "[object Object]") {
          nested = Dottie.flatten(current, seperator);

          for (var _key in nested) {
            flattened[key+seperator+_key] = nested[_key];
          }
        } else {
          flattened[key] = current;
        }
      }
    }

    return flattened;
  };

  Dottie.paths = function(object, prefixes) {
    var paths = [];
    var value;
    var key;

    prefixes = prefixes || [];

    if (typeof object === 'object') {
      for (key in object) {
        value = object[key];

        if (typeof value === 'object' && value !== null) {
          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));
        } else {
          paths.push(prefixes.concat(key).join('.'));
        }
      }
    } else {
      throw new Error('Paths was called with non-object argument.');
    }

    return paths;
  };

  if ( true && module.exports) {
    exports = module.exports = Dottie;
  } else {
    root['Dottie'] = Dottie;
    root['Dot'] = Dottie; //BC

    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Dottie; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "./node_modules/inflection/lib/inflection.js":
/*!***************************************************!*\
  !*** ./node_modules/inflection/lib/inflection.js ***!
  \***************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root, factory ){
  if( true ){
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }else {}
}( this, function (){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    // 'access',
    'accommodation',
    'adulthood',
    'advertising',
    'advice',
    'aggression',
    'aid',
    'air',
    'aircraft',
    'alcohol',
    'anger',
    'applause',
    'arithmetic',
    // 'art',
    'assistance',
    'athletics',
    // 'attention',

    'bacon',
    'baggage',
    // 'ballet',
    // 'beauty',
    'beef',
    // 'beer',
    // 'behavior',
    'biology',
    // 'billiards',
    'blood',
    'botany',
    // 'bowels',
    'bread',
    // 'business',
    'butter',

    'carbon',
    'cardboard',
    'cash',
    'chalk',
    'chaos',
    'chess',
    'crossroads',
    'countryside',

    // 'damage',
    'dancing',
    // 'danger',
    'deer',
    // 'delight',
    // 'dessert',
    'dignity',
    'dirt',
    // 'distribution',
    'dust',

    'economics',
    'education',
    'electricity',
    // 'employment',
    // 'energy',
    'engineering',
    'enjoyment',
    // 'entertainment',
    'envy',
    'equipment',
    'ethics',
    'evidence',
    'evolution',

    // 'failure',
    // 'faith',
    'fame',
    'fiction',
    // 'fish',
    'flour',
    'flu',
    'food',
    // 'freedom',
    // 'fruit',
    'fuel',
    'fun',
    // 'funeral',
    'furniture',

    'gallows',
    'garbage',
    'garlic',
    // 'gas',
    'genetics',
    // 'glass',
    'gold',
    'golf',
    'gossip',
    'grammar',
    // 'grass',
    'gratitude',
    'grief',
    // 'ground',
    'guilt',
    'gymnastics',

    // 'hair',
    'happiness',
    'hardware',
    'harm',
    'hate',
    'hatred',
    'health',
    'heat',
    // 'height',
    'help',
    'homework',
    'honesty',
    'honey',
    'hospitality',
    'housework',
    'humour',
    'hunger',
    'hydrogen',

    'ice',
    'importance',
    'inflation',
    'information',
    // 'injustice',
    'innocence',
    // 'intelligence',
    'iron',
    'irony',

    'jam',
    // 'jealousy',
    // 'jelly',
    'jewelry',
    // 'joy',
    'judo',
    // 'juice',
    // 'justice',

    'karate',
    // 'kindness',
    'knowledge',

    // 'labour',
    'lack',
    // 'land',
    'laughter',
    'lava',
    'leather',
    'leisure',
    'lightning',
    'linguine',
    'linguini',
    'linguistics',
    'literature',
    'litter',
    'livestock',
    'logic',
    'loneliness',
    // 'love',
    'luck',
    'luggage',

    'macaroni',
    'machinery',
    'magic',
    // 'mail',
    'management',
    'mankind',
    'marble',
    'mathematics',
    'mayonnaise',
    'measles',
    // 'meat',
    // 'metal',
    'methane',
    'milk',
    'minus',
    'money',
    // 'moose',
    'mud',
    'music',
    'mumps',

    'nature',
    'news',
    'nitrogen',
    'nonsense',
    'nurture',
    'nutrition',

    'obedience',
    'obesity',
    // 'oil',
    'oxygen',

    // 'paper',
    // 'passion',
    'pasta',
    'patience',
    // 'permission',
    'physics',
    'poetry',
    'pollution',
    'poverty',
    // 'power',
    'pride',
    // 'production',
    // 'progress',
    // 'pronunciation',
    'psychology',
    'publicity',
    'punctuation',

    // 'quality',
    // 'quantity',
    'quartz',

    'racism',
    // 'rain',
    // 'recreation',
    'relaxation',
    'reliability',
    'research',
    'respect',
    'revenge',
    'rice',
    'rubbish',
    'rum',

    'safety',
    // 'salad',
    // 'salt',
    // 'sand',
    // 'satire',
    'scenery',
    'seafood',
    'seaside',
    'series',
    'shame',
    'sheep',
    'shopping',
    // 'silence',
    'sleep',
    // 'slang'
    'smoke',
    'smoking',
    'snow',
    'soap',
    'software',
    'soil',
    // 'sorrow',
    // 'soup',
    'spaghetti',
    // 'speed',
    'species',
    // 'spelling',
    // 'sport',
    'steam',
    // 'strength',
    'stuff',
    'stupidity',
    // 'success',
    // 'sugar',
    'sunshine',
    'symmetry',

    // 'tea',
    'tennis',
    'thirst',
    'thunder',
    'timber',
    // 'time',
    // 'toast',
    // 'tolerance',
    // 'trade',
    'traffic',
    'transportation',
    // 'travel',
    'trust',

    // 'understanding',
    'underwear',
    'unemployment',
    'unity',
    // 'usage',

    'validity',
    'veal',
    'vegetation',
    'vegetarianism',
    'vengeance',
    'violence',
    // 'vision',
    'vitality',

    'warmth',
    // 'water',
    'wealth',
    'weather',
    // 'weight',
    'welfare',
    'wheat',
    // 'whiskey',
    // 'width',
    'wildlife',
    // 'wine',
    'wisdom',
    // 'wood',
    // 'wool',
    // 'work',

    // 'yeast',
    'yoga',

    'zinc',
    'zoology'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */

  var regex = {
    plural : {
      men       : new RegExp( '^(m|wom)en$'                    , 'gi' ),
      people    : new RegExp( '(pe)ople$'                      , 'gi' ),
      children  : new RegExp( '(child)ren$'                    , 'gi' ),
      tia       : new RegExp( '([ti])a$'                       , 'gi' ),
      analyses  : new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ),
      hives     : new RegExp( '(hi|ti)ves$'                    , 'gi' ),
      curves    : new RegExp( '(curve)s$'                      , 'gi' ),
      lrves     : new RegExp( '([lr])ves$'                     , 'gi' ),
      aves      : new RegExp( '([a])ves$'                      , 'gi' ),
      foves     : new RegExp( '([^fo])ves$'                    , 'gi' ),
      movies    : new RegExp( '(m)ovies$'                      , 'gi' ),
      aeiouyies : new RegExp( '([^aeiouy]|qu)ies$'             , 'gi' ),
      series    : new RegExp( '(s)eries$'                      , 'gi' ),
      xes       : new RegExp( '(x|ch|ss|sh)es$'                , 'gi' ),
      mice      : new RegExp( '([m|l])ice$'                    , 'gi' ),
      buses     : new RegExp( '(bus)es$'                       , 'gi' ),
      oes       : new RegExp( '(o)es$'                         , 'gi' ),
      shoes     : new RegExp( '(shoe)s$'                       , 'gi' ),
      crises    : new RegExp( '(cris|ax|test)es$'              , 'gi' ),
      octopi    : new RegExp( '(octop|vir)i$'                  , 'gi' ),
      aliases   : new RegExp( '(alias|canvas|status|campus)es$', 'gi' ),
      summonses : new RegExp( '^(summons)es$'                  , 'gi' ),
      oxen      : new RegExp( '^(ox)en'                        , 'gi' ),
      matrices  : new RegExp( '(matr)ices$'                    , 'gi' ),
      vertices  : new RegExp( '(vert|ind)ices$'                , 'gi' ),
      feet      : new RegExp( '^feet$'                         , 'gi' ),
      teeth     : new RegExp( '^teeth$'                        , 'gi' ),
      geese     : new RegExp( '^geese$'                        , 'gi' ),
      quizzes   : new RegExp( '(quiz)zes$'                     , 'gi' ),
      whereases : new RegExp( '^(whereas)es$'                  , 'gi' ),
      criteria  : new RegExp( '^(criteri)a$'                   , 'gi' ),
      genera    : new RegExp( '^genera$'                       , 'gi' ),
      ss        : new RegExp( 'ss$'                            , 'gi' ),
      s         : new RegExp( 's$'                             , 'gi' )
    },

    singular : {
      man       : new RegExp( '^(m|wom)an$'                  , 'gi' ),
      person    : new RegExp( '(pe)rson$'                    , 'gi' ),
      child     : new RegExp( '(child)$'                     , 'gi' ),
      ox        : new RegExp( '^(ox)$'                       , 'gi' ),
      axis      : new RegExp( '(ax|test)is$'                 , 'gi' ),
      octopus   : new RegExp( '(octop|vir)us$'               , 'gi' ),
      alias     : new RegExp( '(alias|status|canvas|campus)$', 'gi' ),
      summons   : new RegExp( '^(summons)$'                  , 'gi' ),
      bus       : new RegExp( '(bu)s$'                       , 'gi' ),
      buffalo   : new RegExp( '(buffal|tomat|potat)o$'       , 'gi' ),
      tium      : new RegExp( '([ti])um$'                    , 'gi' ),
      sis       : new RegExp( 'sis$'                         , 'gi' ),
      ffe       : new RegExp( '(?:([^f])fe|([lr])f)$'        , 'gi' ),
      hive      : new RegExp( '(hi|ti)ve$'                   , 'gi' ),
      aeiouyy   : new RegExp( '([^aeiouy]|qu)y$'             , 'gi' ),
      x         : new RegExp( '(x|ch|ss|sh)$'                , 'gi' ),
      matrix    : new RegExp( '(matr)ix$'                    , 'gi' ),
      vertex    : new RegExp( '(vert|ind)ex$'                , 'gi' ),
      mouse     : new RegExp( '([m|l])ouse$'                 , 'gi' ),
      foot      : new RegExp( '^foot$'                       , 'gi' ),
      tooth     : new RegExp( '^tooth$'                      , 'gi' ),
      goose     : new RegExp( '^goose$'                      , 'gi' ),
      quiz      : new RegExp( '(quiz)$'                      , 'gi' ),
      whereas   : new RegExp( '^(whereas)$'                  , 'gi' ),
      criterion : new RegExp( '^(criteri)on$'                , 'gi' ),
      genus     : new RegExp( '^genus$'                      , 'gi' ),
      s         : new RegExp( 's$'                           , 'gi' ),
      common    : new RegExp( '$'                            , 'gi' )
    }
  };

  var plural_rules = [

    // do not replace if its already a plural word
    [ regex.plural.men       ],
    [ regex.plural.people    ],
    [ regex.plural.children  ],
    [ regex.plural.tia       ],
    [ regex.plural.analyses  ],
    [ regex.plural.hives     ],
    [ regex.plural.curves    ],
    [ regex.plural.lrves     ],
    [ regex.plural.foves     ],
    [ regex.plural.aeiouyies ],
    [ regex.plural.series    ],
    [ regex.plural.movies    ],
    [ regex.plural.xes       ],
    [ regex.plural.mice      ],
    [ regex.plural.buses     ],
    [ regex.plural.oes       ],
    [ regex.plural.shoes     ],
    [ regex.plural.crises    ],
    [ regex.plural.octopi    ],
    [ regex.plural.aliases   ],
    [ regex.plural.summonses ],
    [ regex.plural.oxen      ],
    [ regex.plural.matrices  ],
    [ regex.plural.feet      ],
    [ regex.plural.teeth     ],
    [ regex.plural.geese     ],
    [ regex.plural.quizzes   ],
    [ regex.plural.whereases ],
    [ regex.plural.criteria  ],
    [ regex.plural.genera    ],

    // original rule
    [ regex.singular.man      , '$1en' ],
    [ regex.singular.person   , '$1ople' ],
    [ regex.singular.child    , '$1ren' ],
    [ regex.singular.ox       , '$1en' ],
    [ regex.singular.axis     , '$1es' ],
    [ regex.singular.octopus  , '$1i' ],
    [ regex.singular.alias    , '$1es' ],
    [ regex.singular.summons  , '$1es' ],
    [ regex.singular.bus      , '$1ses' ],
    [ regex.singular.buffalo  , '$1oes' ],
    [ regex.singular.tium     , '$1a' ],
    [ regex.singular.sis      , 'ses' ],
    [ regex.singular.ffe      , '$1$2ves' ],
    [ regex.singular.hive     , '$1ves' ],
    [ regex.singular.aeiouyy  , '$1ies' ],
    [ regex.singular.matrix   , '$1ices' ],
    [ regex.singular.vertex   , '$1ices' ],
    [ regex.singular.x        , '$1es' ],
    [ regex.singular.mouse    , '$1ice' ],
    [ regex.singular.foot     , 'feet' ],
    [ regex.singular.tooth    , 'teeth' ],
    [ regex.singular.goose    , 'geese' ],
    [ regex.singular.quiz     , '$1zes' ],
    [ regex.singular.whereas  , '$1es' ],
    [ regex.singular.criterion, '$1a' ],
    [ regex.singular.genus    , 'genera' ],

    [ regex.singular.s     , 's' ],
    [ regex.singular.common, 's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ regex.singular.man     ],
    [ regex.singular.person  ],
    [ regex.singular.child   ],
    [ regex.singular.ox      ],
    [ regex.singular.axis    ],
    [ regex.singular.octopus ],
    [ regex.singular.alias   ],
    [ regex.singular.summons ],
    [ regex.singular.bus     ],
    [ regex.singular.buffalo ],
    [ regex.singular.tium    ],
    [ regex.singular.sis     ],
    [ regex.singular.ffe     ],
    [ regex.singular.hive    ],
    [ regex.singular.aeiouyy ],
    [ regex.singular.x       ],
    [ regex.singular.matrix  ],
    [ regex.singular.mouse   ],
    [ regex.singular.foot    ],
    [ regex.singular.tooth   ],
    [ regex.singular.goose   ],
    [ regex.singular.quiz    ],
    [ regex.singular.whereas ],
    [ regex.singular.criterion ],
    [ regex.singular.genus ],

    // original rule
    [ regex.plural.men      , '$1an' ],
    [ regex.plural.people   , '$1rson' ],
    [ regex.plural.children , '$1' ],
    [ regex.plural.genera   , 'genus'],
    [ regex.plural.criteria , '$1on'],
    [ regex.plural.tia      , '$1um' ],
    [ regex.plural.analyses , '$1$2sis' ],
    [ regex.plural.hives    , '$1ve' ],
    [ regex.plural.curves   , '$1' ],
    [ regex.plural.lrves    , '$1f' ],
    [ regex.plural.aves     , '$1ve' ],
    [ regex.plural.foves    , '$1fe' ],
    [ regex.plural.movies   , '$1ovie' ],
    [ regex.plural.aeiouyies, '$1y' ],
    [ regex.plural.series   , '$1eries' ],
    [ regex.plural.xes      , '$1' ],
    [ regex.plural.mice     , '$1ouse' ],
    [ regex.plural.buses    , '$1' ],
    [ regex.plural.oes      , '$1' ],
    [ regex.plural.shoes    , '$1' ],
    [ regex.plural.crises   , '$1is' ],
    [ regex.plural.octopi   , '$1us' ],
    [ regex.plural.aliases  , '$1' ],
    [ regex.plural.summonses, '$1' ],
    [ regex.plural.oxen     , '$1' ],
    [ regex.plural.matrices , '$1ix' ],
    [ regex.plural.vertices , '$1ex' ],
    [ regex.plural.feet     , 'foot' ],
    [ regex.plural.teeth    , 'tooth' ],
    [ regex.plural.geese    , 'goose' ],
    [ regex.plural.quizzes  , '$1' ],
    [ regex.plural.whereases, '$1' ],

    [ regex.plural.ss, 'ss' ],
    [ regex.plural.s , '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function ( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} from_index Starts checking from this position in the Array.(optional)
   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function ( arr, item, from_index, compare_func ){
      if( !from_index ){
        from_index = -1;
      }

      var index = -1;
      var i     = from_index;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },


  /**
   * This function will pluralize or singularlize a String appropriately based on an integer value
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Number} count The number to base pluralization off of.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} English language nouns are returned in the plural or singular form based on the count.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.inflect( 'people' 1 ); // === 'person'
   *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
   *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
   *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
   *     inflection.inflect( 'person', 2 ); // === 'people'
   *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
   *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
   *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
   */
    inflect : function ( str, count, singular, plural ){
      count = parseInt( count, 10 );

      if( isNaN( count )) return str;

      if( count === 0 || count > 1 ){
        return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
      }else{
        return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
      }
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, low_first_letter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = low_first_letter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, all_upper_case ){
      if( all_upper_case && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function ( str, low_first_letter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !low_first_letter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function replaces underscores with dashes in the string.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underscores with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ' );
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function ( str, drop_id_ubar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( inflector.hasOwnProperty( method )){
          str = inflector[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.12.0';

  return inflector;
}));


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/retry-as-promised/index.js":
/*!*************************************************!*\
  !*** ./node_modules/retry-as-promised/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Promise = __webpack_require__(/*! any-promise */ "./node_modules/any-promise/index.js");
var util = __webpack_require__(/*! util */ "util");
var format = util.format;

function TimeoutError(message, err) {
  Error.call(this);
  Error.captureStackTrace(this, TimeoutError);
  this.name = 'TimeoutError';
  this.message = message;
  this.previous = err;
}

util.inherits(TimeoutError, Error);

function matches(match, err) {
  if (match === true) return true;
  if (typeof match === 'function') {
    try {
      if (err instanceof match) return true;
    } catch (_) {
      return !!match(err);
    }
  }
  if (match === err.toString()) return true;
  if (match === err.message) return true;
  return match instanceof RegExp
    && (match.test(err.message) || match.test(err.toString()));
}

module.exports = function retryAsPromised(callback, options) {
  if (!callback || !options) {
    throw new Error(
      'retry-as-promised must be passed a callback and a options set or a number'
    );
  }

  if (typeof options === 'number') {
    options = {
      max: options
    };
  }

  // Super cheap clone
  options = {
    $current: options.$current || 1,
    max: options.max,
    timeout: options.timeout || undefined,
    match: options.match || [],
    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,
    backoffExponent: options.backoffExponent || 1.1,
    report: options.report || function () {},
    name: options.name || callback.name || 'unknown'
  };

  if (!Array.isArray(options.match)) options.match = [options.match];
  options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);

  return new Promise(function(resolve, reject) {
    var timeout, backoffTimeout, lastError;

    if (options.timeout) {
      timeout = setTimeout(function() {
        if (backoffTimeout) clearTimeout(backoffTimeout);
        reject(new TimeoutError(options.name + ' timed out', lastError));
      }, options.timeout);
    }

    Promise.resolve(callback({ current: options.$current }))
      .then(resolve)
      .then(function() {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);
      })
      .catch(function(err) {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);

        lastError = err;
        options.report((err && err.toString()) || err, options);

        // Should not retry if max has been reached
        var shouldRetry = options.$current < options.max;
        if (!shouldRetry) return reject(err);
        shouldRetry = options.match.length === 0 || options.match.some(function (match) {
          return matches(match, err)
        });
        if (!shouldRetry) return reject(err);

        var retryDelay = Math.pow(
          options.backoffBase,
          Math.pow(options.backoffExponent, options.$current - 1)
        );

        // Do some accounting
        options.$current++;
        options.report(format('Retrying %s (%s)', options.name, options.$current), options);

        if (retryDelay) {
          // Use backoff function to ease retry rate
          options.report(format('Delaying retry of %s by %s', options.name, retryDelay), options);
          backoffTimeout = setTimeout(function() {
            retryAsPromised(callback, options)
              .then(resolve)
              .catch(reject);
          }, retryDelay);
        } else {
          retryAsPromised(callback, options)
            .then(resolve)
            .catch(reject);
        }
      });
  });
};

module.exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "lru-cache")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js")
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js"),
  compareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").rcompareIdentifiers,
  parse: __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js"),
  valid: __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js"),
  clean: __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js"),
  inc: __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js"),
  diff: __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js"),
  major: __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js"),
  minor: __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js"),
  patch: __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js"),
  prerelease: __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js"),
  compare: __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js"),
  rcompare: __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js"),
  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js"),
  compareBuild: __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js"),
  sort: __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js"),
  rsort: __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js"),
  gt: __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js"),
  lt: __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js"),
  eq: __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js"),
  neq: __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js"),
  gte: __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js"),
  lte: __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js"),
  cmp: __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js"),
  coerce: __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js"),
  Comparator: __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js"),
  Range: __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js"),
  satisfies: __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js"),
  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js"),
  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js"),
  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js"),
  minVersion: __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js"),
  validRange: __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js"),
  outside: __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js"),
  gtr: __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js"),
  ltr: __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js"),
  intersects: __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js"),
  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js"),
  subset: __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js"),
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js")
const {ANY} = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/sequelize-pool/lib/AggregateError.js":
/*!***********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/AggregateError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregateError = void 0;
class AggregateError extends Error {
    constructor(errors) {
        super();
        this.errors = errors;
        this.name = 'AggregateError';
    }
    toString() {
        const message = `AggregateError of:\n${this.errors
            .map((error) => error === this
            ? '[Circular AggregateError]'
            : error instanceof AggregateError
                ? String(error).replace(/\n$/, '').replace(/^/gm, '  ')
                : String(error).replace(/^/gm, '    ').substring(2))
            .join('\n')}\n`;
        return message;
    }
}
exports.AggregateError = AggregateError;
//# sourceMappingURL=AggregateError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Deferred.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Deferred.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
const TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = resolve;
        });
    }
    registerTimeout(timeoutInMillis, callback) {
        if (this._timeout)
            return;
        this._timeout = setTimeout(() => {
            callback();
            this.reject(new TimeoutError_1.TimeoutError('Operation timeout'));
        }, timeoutInMillis);
    }
    _clearTimeout() {
        if (!this._timeout)
            return;
        clearTimeout(this._timeout);
    }
    resolve(value) {
        this._clearTimeout();
        this._resolve(value);
    }
    reject(error) {
        this._clearTimeout();
        this._reject(error);
    }
    promise() {
        return this._promise;
    }
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Pool.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Pool.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pool = void 0;
const Deferred_1 = __webpack_require__(/*! ./Deferred */ "./node_modules/sequelize-pool/lib/Deferred.js");
const AggregateError_1 = __webpack_require__(/*! ./AggregateError */ "./node_modules/sequelize-pool/lib/AggregateError.js");
class Pool {
    constructor(factory) {
        this.log = false;
        if (!factory.create) {
            throw new Error('create function is required');
        }
        if (!factory.destroy) {
            throw new Error('destroy function is required');
        }
        if (!factory.validate) {
            throw new Error('validate function is required');
        }
        if (typeof factory.min !== 'number' ||
            factory.min < 0 ||
            factory.min !== Math.round(factory.min)) {
            throw new Error('min must be an integer >= 0');
        }
        if (typeof factory.max !== 'number' ||
            factory.max <= 0 ||
            factory.max !== Math.round(factory.max)) {
            throw new Error('max must be an integer > 0');
        }
        if (factory.min > factory.max) {
            throw new Error('max is smaller than min');
        }
        if (factory.maxUses !== undefined &&
            (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {
            throw new Error('maxUses must be an integer >= 0');
        }
        this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;
        this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;
        this.reapIntervalMillis = factory.reapIntervalMillis || 1000;
        this.maxUsesPerResource = factory.maxUses || Infinity;
        this.log = factory.log || false;
        this._factory = factory;
        this._count = 0;
        this._draining = false;
        this._pendingAcquires = [];
        this._inUseObjects = [];
        this._availableObjects = [];
        this._removeIdleScheduled = false;
    }
    get size() {
        return this._count;
    }
    get name() {
        return this._factory.name;
    }
    get available() {
        return this._availableObjects.length;
    }
    get using() {
        return this._inUseObjects.length;
    }
    get waiting() {
        return this._pendingAcquires.length;
    }
    get maxSize() {
        return this._factory.max;
    }
    get minSize() {
        return this._factory.min;
    }
    _log(message, level) {
        if (typeof this.log === 'function') {
            this.log(message, level);
        }
        else if (this.log) {
            console.log(`${level.toUpperCase()} pool ${this.name || ''} - ${message}`);
        }
    }
    _removeIdle() {
        const toRemove = [];
        const now = Date.now();
        let i;
        let available = this._availableObjects.length;
        const maxRemovable = this.size - this.minSize;
        let timeout;
        this._removeIdleScheduled = false;
        for (i = 0; i < available && maxRemovable > toRemove.length; i++) {
            timeout = this._availableObjects[i].timeout;
            if (now >= timeout) {
                this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');
                toRemove.push(this._availableObjects[i].resource);
            }
        }
        toRemove.forEach(this.destroy, this);
        available = this._availableObjects.length;
        if (available > 0) {
            this._log('this._availableObjects.length=' + available, 'verbose');
            this._scheduleRemoveIdle();
        }
        else {
            this._log('removeIdle() all objects removed', 'verbose');
        }
    }
    _scheduleRemoveIdle() {
        if (!this._removeIdleScheduled) {
            this._removeIdleScheduled = true;
            this._removeIdleTimer = setTimeout(() => {
                this._removeIdle();
            }, this.reapIntervalMillis);
        }
    }
    _dispense() {
        let wrappedResource = null;
        const waitingCount = this._pendingAcquires.length;
        this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, 'info');
        if (waitingCount < 1) {
            return;
        }
        while (this._availableObjects.length > 0) {
            this._log('dispense() - reusing obj', 'verbose');
            wrappedResource = this._availableObjects[this._availableObjects.length - 1];
            if (!this._factory.validate(wrappedResource.resource)) {
                this.destroy(wrappedResource.resource);
                continue;
            }
            this._availableObjects.pop();
            this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);
            const deferred = this._pendingAcquires.shift();
            return deferred.resolve(wrappedResource.resource);
        }
        if (this.size < this.maxSize) {
            this._createResource();
        }
    }
    _createResource() {
        this._count += 1;
        this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`, 'verbose');
        this._factory
            .create()
            .then((resource) => {
            const deferred = this._pendingAcquires.shift();
            if (deferred) {
                this._addResourceToInUseObjects(resource, 0);
                deferred.resolve(resource);
            }
            else {
                this._addResourceToAvailableObjects(resource, 0);
            }
        })
            .catch((error) => {
            const deferred = this._pendingAcquires.shift();
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            if (deferred) {
                deferred.reject(error);
            }
            process.nextTick(() => {
                this._dispense();
            });
        });
    }
    _addResourceToAvailableObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
            timeout: Date.now() + this.idleTimeoutMillis,
        };
        this._availableObjects.push(wrappedResource);
        this._dispense();
        this._scheduleRemoveIdle();
    }
    _addResourceToInUseObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
        };
        this._inUseObjects.push(wrappedResource);
    }
    _ensureMinimum() {
        let i, diff;
        if (!this._draining && this.size < this.minSize) {
            diff = this.minSize - this.size;
            for (i = 0; i < diff; i++) {
                this._createResource();
            }
        }
    }
    acquire() {
        if (this._draining) {
            return Promise.reject(new Error('pool is draining and cannot accept work'));
        }
        const deferred = new Deferred_1.Deferred();
        deferred.registerTimeout(this.acquireTimeoutMillis, () => {
            this._pendingAcquires = this._pendingAcquires.filter((pending) => pending !== deferred);
        });
        this._pendingAcquires.push(deferred);
        this._dispense();
        return deferred.promise();
    }
    release(resource) {
        if (this._availableObjects.some((resourceWithTimeout) => resourceWithTimeout.resource === resource)) {
            this._log('release called twice for the same resource: ' + new Error().stack, 'error');
            return;
        }
        const index = this._inUseObjects.findIndex((wrappedResource) => wrappedResource.resource === resource);
        if (index < 0) {
            this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');
            return;
        }
        const wrappedResource = this._inUseObjects[index];
        wrappedResource.useCount += 1;
        if (wrappedResource.useCount >= this.maxUsesPerResource) {
            this._log('release() destroying obj - useCount:' +
                wrappedResource.useCount +
                ' maxUsesPerResource:' +
                this.maxUsesPerResource, 'verbose');
            this.destroy(wrappedResource.resource);
            this._dispense();
        }
        else {
            this._inUseObjects.splice(index, 1);
            this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);
        }
    }
    destroy(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const available = this._availableObjects.length;
            const using = this._inUseObjects.length;
            this._availableObjects = this._availableObjects.filter((object) => object.resource !== resource);
            this._inUseObjects = this._inUseObjects.filter((object) => object.resource !== resource);
            if (available === this._availableObjects.length &&
                using === this._inUseObjects.length) {
                this._ensureMinimum();
                return;
            }
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            try {
                yield this._factory.destroy(resource);
            }
            finally {
                this._ensureMinimum();
            }
        });
    }
    drain() {
        this._log('draining', 'info');
        this._draining = true;
        const check = (callback) => {
            if (this._pendingAcquires.length > 0) {
                this._dispense();
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            if (this._availableObjects.length !== this._count) {
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            callback();
        };
        return new Promise((resolve) => check(resolve));
    }
    destroyAllNow() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log('force destroying all objects', 'info');
            this._removeIdleScheduled = false;
            clearTimeout(this._removeIdleTimer);
            const resources = this._availableObjects.map((resource) => resource.resource);
            const errors = [];
            for (const resource of resources) {
                try {
                    yield this.destroy(resource);
                }
                catch (ex) {
                    this._log('Error destroying resource: ' + ex.stack, 'error');
                    errors.push(ex);
                }
            }
            if (errors.length > 0) {
                throw new AggregateError_1.AggregateError(errors);
            }
        });
    }
}
exports.Pool = Pool;
//# sourceMappingURL=Pool.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/TimeoutError.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/TimeoutError.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = void 0;
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
Object.defineProperty(exports, "TimeoutError", ({ enumerable: true, get: function () { return TimeoutError_1.TimeoutError; } }));
var Pool_1 = __webpack_require__(/*! ./Pool */ "./node_modules/sequelize-pool/lib/Pool.js");
Object.defineProperty(exports, "Pool", ({ enumerable: true, get: function () { return Pool_1.Pool; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferAlias = void 0;
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
/**
 * Pre conform includes, so that "as" value can be inferred from source
 */
function inferAlias(options, source) {
    options = Object.assign({}, options);
    if (!options.include) {
        return options;
    }
    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
        options.include = [options.include];
    }
    else if (!options.include.length) {
        delete options.include;
        return options;
    }
    // convert all included elements to { model: Model } form
    options.include = options.include.map((include) => {
        include = inferAliasForInclude(include, source);
        return include;
    });
    return options;
}
exports.inferAlias = inferAlias;
/**
 * Pre conform include, so that alias ("as") value can be inferred from source class
 */
function inferAliasForInclude(include, source) {
    const hasModelOptionWithoutAsOption = !!(include.model && !include.as);
    const hasIncludeOptions = !!include.include;
    const isConstructorFn = include instanceof Function;
    if (isConstructorFn || hasModelOptionWithoutAsOption) {
        if (isConstructorFn) {
            include = { model: include };
        }
        const targetPrototype = source.prototype || source;
        const relatedClass = include.model;
        const associations = association_service_1.getAssociationsByRelation(targetPrototype, relatedClass);
        if (associations.length > 0) {
            if (associations.length > 1) {
                throw new Error(`Alias cannot be inferred: "${source.name}" has multiple ` +
                    `relations with "${include.model.name}"`);
            }
            include.as = associations[0].getAs();
        }
    }
    if (!isConstructorFn && hasIncludeOptions) {
        include = inferAlias(include, include.model);
    }
    return include;
}
//# sourceMappingURL=alias-inference-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToManyAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToManyAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsToMany;
    }
    getSequelizeOptions(model, sequelize) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        const throughOptions = this.getThroughOptions(sequelize);
        const throughModel = typeof throughOptions === 'object' && typeof throughOptions.model !== "string" ? throughOptions.model : undefined;
        options.through = throughOptions;
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, throughModel, this.options.foreignKey);
        options.otherKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, throughModel, this.options.otherKey);
        return options;
    }
    getThroughOptions(sequelize) {
        const through = this.options.through;
        const throughModel = typeof through === 'object' ? through.model : through;
        const throughOptions = typeof through === 'object' ? Object.assign({}, through) : {};
        if (typeof throughModel === 'function') {
            const throughModelClass = sequelize.model(throughModel());
            if (!throughModelClass.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(throughModelClass, 'Association cannot be resolved.');
            }
            throughOptions.model = throughModelClass;
        }
        else {
            return throughModel;
        }
        return throughOptions;
    }
}
exports.BelongsToManyAssociation = BelongsToManyAssociation;
//# sourceMappingURL=belongs-to-many-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=belongs-to-many-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToMany = void 0;
const belongs_to_many_association_1 = __webpack_require__(/*! ./belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsToMany(associatedClassGetter, throughOrOptions, foreignKey, otherKey) {
    return (target, propertyName) => {
        let options = { foreignKey, otherKey };
        if (typeof throughOrOptions === 'string' ||
            typeof throughOrOptions === 'function') {
            options.through = throughOrOptions;
        }
        else {
            options = Object.assign({}, throughOrOptions);
        }
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_many_association_1.BelongsToManyAssociation(associatedClassGetter, options));
    };
}
exports.BelongsToMany = BelongsToMany;
//# sourceMappingURL=belongs-to-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsTo;
    }
    getSequelizeOptions(model) {
        const associatedClass = this.getAssociatedClass();
        const foreignKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, model, this.options.foreignKey);
        return Object.assign(Object.assign({}, this.options), { foreignKey });
    }
}
exports.BelongsToAssociation = BelongsToAssociation;
//# sourceMappingURL=belongs-to-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsTo = void 0;
const belongs_to_association_1 = __webpack_require__(/*! ./belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsTo(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_association_1.BelongsToAssociation(associatedClassGetter, options));
    };
}
exports.BelongsTo = BelongsTo;
//# sourceMappingURL=belongs-to.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getForeignKeys = exports.addForeignKey = exports.getForeignKeyOptions = void 0;
const FOREIGN_KEYS_KEY = 'sequelize:foreignKeys';
function getForeignKeyOptions(relatedClass, classWithForeignKey, foreignKey) {
    let foreignKeyOptions = {};
    if (typeof foreignKey === 'string') {
        foreignKeyOptions.name = foreignKey;
    }
    else if (foreignKey && typeof foreignKey === 'object') {
        foreignKeyOptions = Object.assign({}, foreignKey);
    }
    if (!foreignKeyOptions.name && classWithForeignKey) {
        const foreignKeys = getForeignKeys(classWithForeignKey.prototype) || [];
        for (const key of foreignKeys) {
            if (key.relatedClassGetter() === relatedClass ||
                relatedClass.prototype instanceof key.relatedClassGetter()) {
                foreignKeyOptions.name = key.foreignKey;
                break;
            }
        }
    }
    if (!foreignKeyOptions.name) {
        throw new Error(`Foreign key for "${relatedClass.name}" is missing ` +
            `on "${classWithForeignKey.name}".`);
    }
    return foreignKeyOptions;
}
exports.getForeignKeyOptions = getForeignKeyOptions;
/**
 * Adds foreign key meta data for specified class
 */
function addForeignKey(target, relatedClassGetter, foreignKey) {
    let foreignKeys = getForeignKeys(target);
    if (!foreignKeys) {
        foreignKeys = [];
    }
    foreignKeys.push({
        relatedClassGetter,
        foreignKey,
    });
    setForeignKeys(target, foreignKeys);
}
exports.addForeignKey = addForeignKey;
/**
 * Returns foreign key meta data from specified class
 */
function getForeignKeys(target) {
    const foreignKeys = Reflect.getMetadata(FOREIGN_KEYS_KEY, target);
    if (foreignKeys) {
        return [...foreignKeys];
    }
}
exports.getForeignKeys = getForeignKeys;
/**
 * Sets foreign key meta data
 */
function setForeignKeys(target, foreignKeys) {
    Reflect.defineMetadata(FOREIGN_KEYS_KEY, foreignKeys, target);
}
//# sourceMappingURL=foreign-key-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForeignKey = void 0;
const foreign_key_service_1 = __webpack_require__(/*! ./foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
function ForeignKey(relatedClassGetter) {
    return (target, propertyName) => {
        foreign_key_service_1.addForeignKey(target, relatedClassGetter, propertyName);
    };
}
exports.ForeignKey = ForeignKey;
//# sourceMappingURL=foreign-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-association.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
class HasAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options, association) {
        super(associatedClassGetter, options);
        this.options = options;
        this.association = association;
    }
    getAssociation() {
        return this.association;
    }
    getSequelizeOptions(model) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, associatedClass, options.foreignKey);
        return options;
    }
}
exports.HasAssociation = HasAssociation;
//# sourceMappingURL=has-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-many.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasMany = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasMany(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasMany));
    };
}
exports.HasMany = HasMany;
//# sourceMappingURL=has-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-one.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasOne = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasOne(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasOne));
    };
}
exports.HasOne = HasOne;
//# sourceMappingURL=has-one.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association-service.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAssociationsByRelation = exports.setAssociations = exports.getAssociations = exports.addAssociation = exports.getPreparedAssociationOptions = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const ASSOCIATIONS_KEY = 'sequelize:associations';
// tslint:disable:max-line-length
function getPreparedAssociationOptions(optionsOrForeignKey) {
    let options = {};
    if (optionsOrForeignKey) {
        if (typeof optionsOrForeignKey === 'string') {
            options.foreignKey = optionsOrForeignKey;
        }
        else {
            options = Object.assign({}, optionsOrForeignKey);
        }
    }
    return options;
}
exports.getPreparedAssociationOptions = getPreparedAssociationOptions;
/**
 * Stores association meta data for specified class
 */
function addAssociation(target, association) {
    let associations = getAssociations(target);
    if (!associations) {
        associations = [];
    }
    associations.push(association);
    setAssociations(target, associations);
}
exports.addAssociation = addAssociation;
/**
 * Returns association meta data from specified class
 */
function getAssociations(target) {
    const associations = Reflect.getMetadata(ASSOCIATIONS_KEY, target);
    if (associations) {
        return [...associations];
    }
}
exports.getAssociations = getAssociations;
function setAssociations(target, associations) {
    Reflect.defineMetadata(ASSOCIATIONS_KEY, associations, target);
}
exports.setAssociations = setAssociations;
function getAssociationsByRelation(target, relatedClass) {
    const associations = getAssociations(target);
    return (associations || []).filter(association => {
        const _relatedClass = association.getAssociatedClass();
        return (_relatedClass.prototype === relatedClass.prototype ||
            relatedClass.prototype instanceof _relatedClass);
    });
}
exports.getAssociationsByRelation = getAssociationsByRelation;
//# sourceMappingURL=association-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Association = void 0;
var Association;
(function (Association) {
    Association["BelongsToMany"] = "belongsToMany";
    Association["BelongsTo"] = "belongsTo";
    Association["HasMany"] = "hasMany";
    Association["HasOne"] = "hasOne";
})(Association = exports.Association || (exports.Association = {}));
//# sourceMappingURL=association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/base-association.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAssociation = void 0;
class BaseAssociation {
    constructor(associatedClassGetter, options) {
        this.associatedClassGetter = associatedClassGetter;
        this.options = options;
    }
    getAssociatedClass() {
        return this.associatedClassGetter();
    }
    getAs() {
        return this.options.as;
    }
}
exports.BaseAssociation = BaseAssociation;
//# sourceMappingURL=base-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=union-association-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/through/through-options.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=through-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkCreate', args);
}
exports.AfterBulkCreate = AfterBulkCreate;
//# sourceMappingURL=after-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkDestroy', args);
}
exports.AfterBulkDestroy = AfterBulkDestroy;
//# sourceMappingURL=after-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkRestore', args);
}
exports.AfterBulkRestore = AfterBulkRestore;
//# sourceMappingURL=after-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkSync', args);
}
exports.AfterBulkSync = AfterBulkSync;
//# sourceMappingURL=after-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkUpdate', args);
}
exports.AfterBulkUpdate = AfterBulkUpdate;
//# sourceMappingURL=after-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkCreate', args);
}
exports.BeforeBulkCreate = BeforeBulkCreate;
//# sourceMappingURL=before-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkDestroy', args);
}
exports.BeforeBulkDestroy = BeforeBulkDestroy;
//# sourceMappingURL=before-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkRestore', args);
}
exports.BeforeBulkRestore = BeforeBulkRestore;
//# sourceMappingURL=before-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkSync', args);
}
exports.BeforeBulkSync = BeforeBulkSync;
//# sourceMappingURL=before-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkUpdate', args);
}
exports.BeforeBulkUpdate = BeforeBulkUpdate;
//# sourceMappingURL=before-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=hook-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setHooks = exports.getHooks = exports.addHook = exports.implementHookDecorator = exports.installHooks = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const HOOKS_KEY = 'sequelize:hooks';
/**
 * Installs hooks on the specified models
 */
function installHooks(models) {
    models.forEach(model => {
        const hooks = getHooks(model);
        if (hooks) {
            hooks.forEach(hook => {
                installHook(model, hook);
            });
        }
    });
}
exports.installHooks = installHooks;
/**
 * Implementation for hook decorator functions. These are polymorphic. When
 * called with a single argument (IHookOptions) they return a decorator
 * factory function. When called with multiple arguments, they add the hook
 * to the models metadata.
 */
function implementHookDecorator(hookType, args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => addHook(target, hookType, propertyName, options);
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        addHook(target, hookType, propertyName);
    }
}
exports.implementHookDecorator = implementHookDecorator;
/**
 * Adds hook meta data for specified model
 * @throws if applied to a non-static method
 * @throws if the hook method name is reserved
 */
function addHook(target, hookType, methodName, options = {}) {
    if (typeof target !== 'function') {
        throw new Error(`Hook method '${methodName}' is not a static method. ` +
            `Only static methods can be used for hooks`);
    }
    // make sure the hook name doesnt conflict with Sequelizes existing methods
    if (methodName === hookType) {
        throw new Error(`Hook method cannot be named '${methodName}'. That name is ` +
            `reserved by Sequelize`);
    }
    const hooks = getHooks(target) || [];
    hooks.push({
        hookType,
        methodName,
        options
    });
    setHooks(target, hooks);
}
exports.addHook = addHook;
/**
 * Install a hook
 */
function installHook(model, hook) {
    if (hook.options && hook.options.name) {
        model.addHook(hook.hookType, hook.options.name, model[hook.methodName]);
        return;
    }
    model.addHook(hook.hookType, model[hook.methodName]);
}
/**
 * Returns hooks meta data from specified class
 */
function getHooks(target) {
    const hooks = Reflect.getMetadata(HOOKS_KEY, target);
    if (hooks) {
        return [...hooks];
    }
}
exports.getHooks = getHooks;
/**
 * Saves hooks meta data for the specified class
 */
function setHooks(target, hooks) {
    Reflect.defineMetadata(HOOKS_KEY, hooks, target);
}
exports.setHooks = setHooks;
//# sourceMappingURL=hooks-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationFailed = void 0;
const hooks_service_1 = __webpack_require__(/*! ./hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function ValidationFailed(...args) {
    return hooks_service_1.implementHookDecorator('validationFailed', args);
}
exports.ValidationFailed = ValidationFailed;
//# sourceMappingURL=validation-failed.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterConnect(...args) {
    return hooks_service_1.implementHookDecorator('afterConnect', args);
}
exports.AfterConnect = AfterConnect;
//# sourceMappingURL=after-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterCreate', args);
}
exports.AfterCreate = AfterCreate;
//# sourceMappingURL=after-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDefine(...args) {
    return hooks_service_1.implementHookDecorator('afterDefine', args);
}
exports.AfterDefine = AfterDefine;
//# sourceMappingURL=after-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterDestroy', args);
}
exports.AfterDestroy = AfterDestroy;
//# sourceMappingURL=after-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterFind(...args) {
    return hooks_service_1.implementHookDecorator('afterFind', args);
}
exports.AfterFind = AfterFind;
//# sourceMappingURL=after-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterInit(...args) {
    return hooks_service_1.implementHookDecorator('afterInit', args);
}
exports.AfterInit = AfterInit;
//# sourceMappingURL=after-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterRestore', args);
}
exports.AfterRestore = AfterRestore;
//# sourceMappingURL=after-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSave(...args) {
    return hooks_service_1.implementHookDecorator('afterSave', args);
}
exports.AfterSave = AfterSave;
//# sourceMappingURL=after-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSync(...args) {
    return hooks_service_1.implementHookDecorator('afterSync', args);
}
exports.AfterSync = AfterSync;
//# sourceMappingURL=after-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterUpdate', args);
}
exports.AfterUpdate = AfterUpdate;
//# sourceMappingURL=after-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpsert(...args) {
    return hooks_service_1.implementHookDecorator('afterUpsert', args);
}
exports.AfterUpsert = AfterUpsert;
//# sourceMappingURL=after-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterValidate(...args) {
    return hooks_service_1.implementHookDecorator('afterValidate', args);
}
exports.AfterValidate = AfterValidate;
//# sourceMappingURL=after-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeConnect(...args) {
    return hooks_service_1.implementHookDecorator('beforeConnect', args);
}
exports.BeforeConnect = BeforeConnect;
//# sourceMappingURL=before-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCount = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCount(...args) {
    return hooks_service_1.implementHookDecorator('beforeCount', args);
}
exports.BeforeCount = BeforeCount;
//# sourceMappingURL=before-count.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeCreate', args);
}
exports.BeforeCreate = BeforeCreate;
//# sourceMappingURL=before-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDefine(...args) {
    return hooks_service_1.implementHookDecorator('beforeDefine', args);
}
exports.BeforeDefine = BeforeDefine;
//# sourceMappingURL=before-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeDestroy', args);
}
exports.BeforeDestroy = BeforeDestroy;
//# sourceMappingURL=before-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterExpandIncludeAll = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterExpandIncludeAll(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterExpandIncludeAll', args);
}
exports.BeforeFindAfterExpandIncludeAll = BeforeFindAfterExpandIncludeAll;
//# sourceMappingURL=before-find-after-expand-include-all.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterOptions = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterOptions(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterOptions', args);
}
exports.BeforeFindAfterOptions = BeforeFindAfterOptions;
//# sourceMappingURL=before-find-after-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFind(...args) {
    return hooks_service_1.implementHookDecorator('beforeFind', args);
}
exports.BeforeFind = BeforeFind;
//# sourceMappingURL=before-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeInit(...args) {
    return hooks_service_1.implementHookDecorator('beforeInit', args);
}
exports.BeforeInit = BeforeInit;
//# sourceMappingURL=before-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeRestore', args);
}
exports.BeforeRestore = BeforeRestore;
//# sourceMappingURL=before-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSave(...args) {
    return hooks_service_1.implementHookDecorator('beforeSave', args);
}
exports.BeforeSave = BeforeSave;
//# sourceMappingURL=before-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeSync', args);
}
exports.BeforeSync = BeforeSync;
//# sourceMappingURL=before-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpdate', args);
}
exports.BeforeUpdate = BeforeUpdate;
//# sourceMappingURL=before-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpsert(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpsert', args);
}
exports.BeforeUpsert = BeforeUpsert;
//# sourceMappingURL=before-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeValidate(...args) {
    return hooks_service_1.implementHookDecorator('beforeValidate', args);
}
exports.BeforeValidate = BeforeValidate;
//# sourceMappingURL=before-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-options */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/foreign-key/foreign-key */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-one */ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-many */ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-action-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/union-association-options */ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/through/through-options */ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-create */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-define */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-find */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-init */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-save */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-update */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-count */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-create */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-define */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-expand-include-all */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-options */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-init */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-save */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-update */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hook-options */ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/validation-failed */ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/allow-null */ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/comment */ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/default */ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/unique */ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/auto-increment */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/primary-key */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/created-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/deleted-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/updated-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column */ "./node_modules/sequelize-typescript/dist/model/column/column.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-count-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-get-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-class-getter */ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table */ "./node_modules/sequelize-typescript/dist/model/table/table.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table-options */ "./node_modules/sequelize-typescript/dist/model/table/table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/create-index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/default-scope */ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-table-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scopes */ "./node_modules/sequelize-typescript/dist/scopes/scopes.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-options */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/validation-only/db-dialect-dummy */ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/repository/repository */ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/contains */ "./node_modules/sequelize-typescript/dist/validation/contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/equals */ "./node_modules/sequelize-typescript/dist/validation/equals.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is */ "./node_modules/sequelize-typescript/dist/validation/is.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-after */ "./node_modules/sequelize-typescript/dist/validation/is-after.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alpha */ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alphanumeric */ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-before */ "./node_modules/sequelize-typescript/dist/validation/is-before.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-credit-card */ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-date */ "./node_modules/sequelize-typescript/dist/validation/is-date.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-decimal */ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-email */ "./node_modules/sequelize-typescript/dist/validation/is-email.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-float */ "./node_modules/sequelize-typescript/dist/validation/is-float.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-in */ "./node_modules/sequelize-typescript/dist/validation/is-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-int */ "./node_modules/sequelize-typescript/dist/validation/is-int.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip */ "./node_modules/sequelize-typescript/dist/validation/is-ip.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v4 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-array */ "./node_modules/sequelize-typescript/dist/validation/is-array.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v6 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-lowercase */ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-null */ "./node_modules/sequelize-typescript/dist/validation/is-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-numeric */ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uppercase */ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-url */ "./node_modules/sequelize-typescript/dist/validation/is-url.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uuid */ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/length */ "./node_modules/sequelize-typescript/dist/validation/length.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/max */ "./node_modules/sequelize-typescript/dist/validation/max.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/min */ "./node_modules/sequelize-typescript/dist/validation/min.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not */ "./node_modules/sequelize-typescript/dist/validation/not.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-contains */ "./node_modules/sequelize-typescript/dist/validation/not-contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-empty */ "./node_modules/sequelize-typescript/dist/validation/not-empty.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-in */ "./node_modules/sequelize-typescript/dist/validation/not-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-null */ "./node_modules/sequelize-typescript/dist/validation/not-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validate */ "./node_modules/sequelize-typescript/dist/validation/validate.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validator */ "./node_modules/sequelize-typescript/dist/validation/validator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/attribute-service.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addAttributeOptions = exports.addAttribute = exports.setAttributes = exports.getAttributes = void 0;
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const ATTRIBUTES_KEY = 'sequelize:attributes';
/**
 * Returns model attributes from class by restoring this
 * information from reflect metadata
 */
function getAttributes(target) {
    const attributes = Reflect.getMetadata(ATTRIBUTES_KEY, target);
    if (attributes) {
        return Object
            .keys(attributes)
            .reduce((copy, key) => {
            copy[key] = Object.assign({}, attributes[key]);
            return copy;
        }, {});
    }
}
exports.getAttributes = getAttributes;
/**
 * Sets attributes
 */
function setAttributes(target, attributes) {
    Reflect.defineMetadata(ATTRIBUTES_KEY, Object.assign({}, attributes), target);
}
exports.setAttributes = setAttributes;
/**
 * Adds model attribute by specified property name and
 * sequelize attribute options and stores this information
 * through reflect metadata
 */
function addAttribute(target, name, options) {
    let attributes = getAttributes(target);
    if (!attributes) {
        attributes = {};
    }
    attributes[name] = Object.assign({}, options);
    setAttributes(target, attributes);
}
exports.addAttribute = addAttribute;
/**
 * Adds attribute options for specific attribute
 */
function addAttributeOptions(target, propertyName, options) {
    const attributes = getAttributes(target);
    if (!attributes || !attributes[propertyName]) {
        throw new Error(`@Column annotation is missing for "${propertyName}" of class "${target.constructor.name}"` +
            ` or annotation order is wrong.`);
    }
    attributes[propertyName] = object_1.deepAssign(attributes[propertyName], options);
    setAttributes(target, attributes);
}
exports.addAttributeOptions = addAttributeOptions;
//# sourceMappingURL=attribute-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllowNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function AllowNull(...args) {
    if (args.length === 1) {
        const allowNull = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, { allowNull });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            allowNull: true
        });
    }
}
exports.AllowNull = AllowNull;
//# sourceMappingURL=allow-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comment = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified comment value for the annotated field
 */
function Comment(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            comment: value
        });
    };
}
exports.Comment = Comment;
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/default.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified default value for the annotated field
 */
function Default(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            defaultValue: value
        });
    };
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unique = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Unique(...args) {
    if (args.length === 1) {
        const [options] = args;
        return (_target, _propertyName) => {
            annotate(_target, _propertyName, options);
        };
    }
    const [target, propertyName] = args;
    annotate(target, propertyName);
}
exports.Unique = Unique;
function annotate(target, propertyName, option = true) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        unique: option,
    });
}
//# sourceMappingURL=unique.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Column = void 0;
const attribute_service_1 = __webpack_require__(/*! ./attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Column(...args) {
    // In case of no specified options, we infer the
    // sequelize data type by the type of the property
    if (args.length >= 2) {
        const target = args[0];
        const propertyName = args[1];
        const propertyDescriptor = args[2];
        annotate(target, propertyName, propertyDescriptor);
        return;
    }
    return (target, propertyName, propertyDescriptor) => {
        annotate(target, propertyName, propertyDescriptor, args[0]);
    };
}
exports.Column = Column;
function annotate(target, propertyName, propertyDescriptor, optionsOrDataType = {}) {
    let options;
    if (data_type_service_1.isDataType(optionsOrDataType)) {
        options = {
            type: optionsOrDataType
        };
    }
    else {
        options = Object.assign({}, optionsOrDataType);
        if (!options.type) {
            options.type = model_service_1.getSequelizeTypeByDesignType(target, propertyName);
        }
    }
    if (propertyDescriptor) {
        if (propertyDescriptor.get) {
            options.get = propertyDescriptor.get;
        }
        if (propertyDescriptor.set) {
            options.set = propertyDescriptor.set;
        }
    }
    attribute_service_1.addAttribute(target, propertyName, options);
}
//# sourceMappingURL=column.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoIncrement = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets auto increment true for annotated field
 */
function AutoIncrement(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        autoIncrement: true
    });
}
exports.AutoIncrement = AutoIncrement;
//# sourceMappingURL=auto-increment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimaryKey = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets primary key option true for annotated property.
 */
function PrimaryKey(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        primaryKey: true
    });
}
exports.PrimaryKey = PrimaryKey;
//# sourceMappingURL=primary-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function CreatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        createdAt: propertyName,
        timestamps: true
    });
}
exports.CreatedAt = CreatedAt;
//# sourceMappingURL=created-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function DeletedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        deletedAt: propertyName,
        timestamps: true,
        paranoid: true
    });
}
exports.DeletedAt = DeletedAt;
//# sourceMappingURL=deleted-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function UpdatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        updatedAt: propertyName,
        timestamps: true
    });
}
exports.UpdatedAt = UpdatedAt;
//# sourceMappingURL=updated-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIndexDecorator = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function createIndexDecorator(options = {}) {
    let indexId;
    return ((...args) => {
        if (args.length >= 2) {
            const [target, propertyName] = args;
            const fieldOptions = { name: propertyName };
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
            return;
        }
        return (target, propertyName) => {
            const fieldOptions = Object.assign({ name: propertyName }, args[0]);
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
        };
    });
}
exports.createIndexDecorator = createIndexDecorator;
//# sourceMappingURL=create-index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-decorator.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.annotateModelWithIndex = exports.Index = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function Index(...args) {
    if (args.length >= 2) {
        const [target, propertyName] = args;
        annotateModelWithIndex(target, propertyName);
        return;
    }
    return (target, propertyName) => {
        annotateModelWithIndex(target, propertyName, args[0]);
    };
}
exports.Index = Index;
function annotateModelWithIndex(target, propertyName, optionsOrName = {}, indexId) {
    let indexOptions;
    let fieldOptions;
    if (typeof optionsOrName === 'string') {
        indexOptions = { name: optionsOrName };
        fieldOptions = { name: propertyName };
    }
    else {
        const { length, order, collate } = optionsOrName, rest = __rest(optionsOrName, ["length", "order", "collate"]);
        indexOptions = rest;
        fieldOptions = {
            name: propertyName,
            length,
            order,
            collate,
        };
    }
    return index_service_1.addFieldToIndex(target, fieldOptions, indexOptions, indexId);
}
exports.annotateModelWithIndex = annotateModelWithIndex;
//# sourceMappingURL=index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-service.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-service.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addFieldToIndex = exports.setIndexes = exports.getIndexes = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const INDEXES_KEY = 'sequelize:indexes';
/**
 * Returns model indexes from class by restoring this
 * information from reflect metadata
 */
function getIndexes(target) {
    const { named = {}, unnamed = [] } = Reflect.getMetadata(INDEXES_KEY, target) || {};
    return { named: Object.assign({}, named), unnamed: [...unnamed] };
}
exports.getIndexes = getIndexes;
/**
 * Sets indexes
 */
function setIndexes(target, indexes) {
    Reflect.defineMetadata(INDEXES_KEY, indexes, target);
}
exports.setIndexes = setIndexes;
/**
 * Adds field to index by sequelize index and index field options,
 * and stores this information through reflect metadata. Returns index ID.
 */
function addFieldToIndex(target, fieldOptions, indexOptions, indexId) {
    const indexes = getIndexes(target);
    const chosenId = typeof indexId !== 'undefined'
        ? indexId
        : indexOptions.name || indexes.unnamed.length;
    const indexStore = typeof chosenId === 'string'
        ? indexes.named
        : indexes.unnamed;
    if (!indexStore[chosenId])
        indexStore[chosenId] = Object.assign({}, indexOptions);
    const index = indexStore[chosenId];
    if (!index.fields)
        index.fields = [];
    index.fields.push(fieldOptions);
    setIndexes(target, indexes);
    return chosenId;
}
exports.addFieldToIndex = addFieldToIndex;
//# sourceMappingURL=index-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-action-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-count-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-get-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/model.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INFER_ALIAS_MAP = exports.Model = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const string_1 = __webpack_require__(/*! ../../shared/string */ "./node_modules/sequelize-typescript/dist/shared/string.js");
const alias_inference_service_1 = __webpack_require__(/*! ../../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
class Model extends sequelize_1.Model {
    constructor(values, options) {
        if (!new.target.isInitialized) {
            throw new model_not_initialized_error_1.ModelNotInitializedError(new.target, `${new.target.name} cannot be instantiated.`);
        }
        super(values, alias_inference_service_1.inferAlias(options, new.target));
    }
    static init(attributes, options) {
        this.isInitialized = true;
        // @ts-ignore
        return super.init(attributes, options);
    }
    /**
     * Adds relation between specified instances and source instance
     */
    $add(propertyKey, instances, options) {
        return this['add' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Sets relation between specified instances and source instance
     * (replaces old relations)
     */
    $set(propertyKey, instances, options) {
        return this['set' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Returns related instance (specified by propertyKey) of source instance
     */
    $get(propertyKey, options) {
        return this['get' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Counts related instances (specified by propertyKey) of source instance
     */
    $count(propertyKey, options) {
        return this['count' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Creates instances and relate them to source instance
     */
    $create(propertyKey, values, options) {
        return this['create' + string_1.capitalize(propertyKey)](values, options);
    }
    /**
     * Checks if specified instances is related to source instance
     */
    $has(propertyKey, instances, options) {
        return this['has' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Removes specified instances from source instance
     */
    $remove(propertyKey, instances, options) {
        return this['remove' + string_1.capitalize(propertyKey)](instances, options);
    }
    reload(options) {
        return super.reload(alias_inference_service_1.inferAlias(options, this));
    }
}
exports.Model = Model;
Model.isInitialized = false;
/**
 * Indicates which static methods of Model has to be proxied,
 * to prepare include option to automatically resolve alias;
 * The index represents the index of the options of the
 * corresponding method parameter
 */
exports.INFER_ALIAS_MAP = {
    bulkBuild: 1,
    build: 1,
    create: 1,
    aggregate: 2,
    all: 0,
    find: 0,
    findAll: 0,
    findAndCount: 0,
    findAndCountAll: 0,
    findById: 1,
    findByPrimary: 1,
    findCreateFind: 0,
    findOne: 0,
    findOrBuild: 0,
    findOrCreate: 0,
    findOrInitialize: 0,
    reload: 0,
};
const staticModelFunctionProperties = object_1.getAllPropertyNames(sequelize_1.Model)
    .filter(key => !isForbiddenMember(key) &&
    isFunctionMember(key, sequelize_1.Model) &&
    !isPrivateMember(key));
function isFunctionMember(propertyKey, target) {
    return typeof target[propertyKey] === 'function';
}
function isForbiddenMember(propertyKey) {
    const FORBIDDEN_KEYS = ['name', 'constructor', 'length', 'prototype', 'caller', 'arguments', 'apply',
        'queryInterface', 'queryGenerator', 'init', 'replaceHookAliases', 'refreshAttributes', 'inspect'];
    return FORBIDDEN_KEYS.indexOf(propertyKey) !== -1;
}
function isPrivateMember(propertyKey) {
    return (propertyKey.charAt(0) === '_');
}
function addThrowNotInitializedProxy() {
    staticModelFunctionProperties
        .forEach(key => {
        const superFn = Model[key];
        Model[key] = function (...args) {
            if (!this.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(this, `Member "${key}" cannot be called.`);
            }
            return superFn.call(this, ...args);
        };
    });
}
function addInferAliasOverrides() {
    Object
        .keys(exports.INFER_ALIAS_MAP)
        .forEach(key => {
        const optionIndex = exports.INFER_ALIAS_MAP[key];
        const superFn = Model[key];
        Model[key] = function (...args) {
            args[optionIndex] = alias_inference_service_1.inferAlias(args[optionIndex], this);
            return superFn.call(this, ...args);
        };
    });
}
addThrowNotInitializedProxy();
addInferAliasOverrides();
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=model-class-getter.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelNotInitializedError = void 0;
class ModelNotInitializedError extends Error {
    constructor(modelClass, additionalMessage) {
        super();
        this.message = `Model not initialized: ${additionalMessage} "${modelClass.name}" ` +
            `needs to be added to a Sequelize instance.`;
    }
}
exports.ModelNotInitializedError = ModelNotInitializedError;
//# sourceMappingURL=model-not-initialized-error.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModelGetter = exports.getSequelizeTypeByDesignType = exports.addOptions = exports.setOptions = exports.getOptions = exports.getModelName = exports.setModelName = void 0;
const model_1 = __webpack_require__(/*! ../model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const MODEL_NAME_KEY = 'sequelize:modelName';
const OPTIONS_KEY = 'sequelize:options';
/**
 * Sets model name from class by storing this
 * information through reflect metadata
 */
function setModelName(target, modelName) {
    Reflect.defineMetadata(MODEL_NAME_KEY, modelName, target);
}
exports.setModelName = setModelName;
/**
 * Returns model name from class by restoring this
 * information from reflect metadata
 */
function getModelName(target) {
    return Reflect.getMetadata(MODEL_NAME_KEY, target);
}
exports.getModelName = getModelName;
/**
 * Returns sequelize define options from class prototype
 * by restoring this information from reflect metadata
 */
function getOptions(target) {
    const options = Reflect.getMetadata(OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
}
exports.getOptions = getOptions;
/**
 * Sets seuqlize define options to class prototype
 */
function setOptions(target, options) {
    Reflect.defineMetadata(OPTIONS_KEY, Object.assign({}, options), target);
}
exports.setOptions = setOptions;
/**
 * Adds options be assigning new options to old one
 */
function addOptions(target, options) {
    let _options = getOptions(target);
    if (!_options) {
        _options = {};
    }
    setOptions(target, Object.assign(Object.assign(Object.assign({}, _options), options), { validate: Object.assign(Object.assign({}, (_options.validate || {})), (options.validate || {})) }));
}
exports.addOptions = addOptions;
/**
 * Maps design types to sequelize data types;
 * @throws if design type cannot be automatically mapped to
 * a sequelize data type
 */
function getSequelizeTypeByDesignType(target, propertyName) {
    const type = Reflect.getMetadata('design:type', target, propertyName);
    const dataType = data_type_service_1.inferDataType(type);
    if (dataType) {
        return dataType;
    }
    throw new Error(`Specified type of property '${propertyName}'
            cannot be automatically resolved to a sequelize data type. Please
            define the data type manually`);
}
exports.getSequelizeTypeByDesignType = getSequelizeTypeByDesignType;
/**
 * Resolves all model getters of specified options object
 * recursively.
 * So that {model: () => Person} will be converted to
 * {model: Person}
 */
function resolveModelGetter(options) {
    const maybeModelGetter = value => typeof value === 'function' && value.length === 0;
    const isModel = value => value && value.prototype && value.prototype instanceof model_1.Model;
    const isOptionObjectOrArray = value => value && typeof value === 'object';
    return Object
        .keys(options)
        .reduce((acc, key) => {
        const value = options[key];
        if (maybeModelGetter(value)) {
            const maybeModel = value();
            if (isModel(maybeModel)) {
                acc[key] = maybeModel;
            }
        }
        else if (isOptionObjectOrArray(value)) {
            acc[key] = resolveModelGetter(value);
        }
        return acc;
    }, Array.isArray(options) ? [...options] : Object.assign({}, options));
}
exports.resolveModelGetter = resolveModelGetter;
//# sourceMappingURL=model-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = void 0;
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Table(arg) {
    if (typeof arg === 'function') {
        annotate(arg);
    }
    else {
        const options = Object.assign({}, arg);
        return (target) => annotate(target, options);
    }
}
exports.Table = Table;
function annotate(target, options = {}) {
    model_service_1.setModelName(target.prototype, options.modelName || target.name);
    model_service_1.addOptions(target.prototype, options);
}
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/default-scope.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultScope = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining default Model scope
 */
function DefaultScope(scopeOrSsopeGetter) {
    return (target) => {
        if (typeof scopeOrSsopeGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, { getDefaultScope: scopeOrSsopeGetter });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, { defaultScope: scopeOrSsopeGetter });
        }
    };
}
exports.DefaultScope = DefaultScope;
//# sourceMappingURL=default-scope.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-options.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-service.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getScopeOptions = exports.addScopeOptions = exports.resolvesDeprecatedScopes = exports.setScopeOptionsGetters = exports.getScopeOptionsGetters = exports.addScopeOptionsGetter = exports.resolveScope = exports.resolveScopes = void 0;
const object_1 = __webpack_require__(/*! ../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const alias_inference_service_1 = __webpack_require__(/*! ../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const SCOPES_KEY = 'sequelize:scopes';
const SCOPES_OPTIONS_KEY = 'sequelize:scopes-options';
/**
 * Resolves scopes and adds them to the specified models
 */
function resolveScopes(models) {
    models.forEach(model => {
        exports.resolvesDeprecatedScopes(model);
        const { getDefaultScope, getScopes } = exports.getScopeOptionsGetters(model.prototype);
        let options = {};
        if (getDefaultScope) {
            options = Object.assign(Object.assign({}, options), { defaultScope: getDefaultScope() });
        }
        if (getScopes) {
            options = Object.assign(Object.assign({}, options), getScopes());
        }
        Object
            .keys(options)
            .forEach(key => exports.resolveScope(key, model, options[key]));
    });
}
exports.resolveScopes = resolveScopes;
const resolveScope = (scopeName, model, options) => {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(options, model);
    }
    model.addScope(scopeName, options, { override: true });
};
exports.resolveScope = resolveScope;
const addScopeOptionsGetter = (target, options) => {
    const currentOptions = exports.getScopeOptionsGetters(target) || {};
    exports.setScopeOptionsGetters(target, Object.assign(Object.assign({}, currentOptions), options));
};
exports.addScopeOptionsGetter = addScopeOptionsGetter;
const getScopeOptionsGetters = (target) => {
    const options = Reflect.getMetadata(SCOPES_OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
    return {};
};
exports.getScopeOptionsGetters = getScopeOptionsGetters;
const setScopeOptionsGetters = (target, options) => {
    Reflect.defineMetadata(SCOPES_OPTIONS_KEY, options, target);
};
exports.setScopeOptionsGetters = setScopeOptionsGetters;
/**
 * @deprecated
 */
const resolvesDeprecatedScopes = (model) => {
    const options = getScopeOptions(model.prototype) || {};
    Object
        .keys(options)
        .forEach(key => resolveDeprecatedScope(key, model, options[key]));
};
exports.resolvesDeprecatedScopes = resolvesDeprecatedScopes;
/**
 * Adds scope option meta data for specified prototype
 * @deprecated
 */
function addScopeOptions(target, options) {
    const _options = getScopeOptions(target) || {};
    setScopeOptions(target, object_1.deepAssign({}, _options, options));
}
exports.addScopeOptions = addScopeOptions;
/**
 * Returns scope option meta data from specified target
 * @deprecated
 */
function getScopeOptions(target) {
    const options = Reflect.getMetadata(SCOPES_KEY, target);
    if (options) {
        return object_1.deepAssign({}, options);
    }
}
exports.getScopeOptions = getScopeOptions;
/**
 * @deprecated
 */
function resolveDeprecatedScope(scopeName, model, options) {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(model_service_1.resolveModelGetter(options), model);
    }
    model.addScope(scopeName, options, { override: true });
}
/**
 * Set scope option meta data for specified prototype
 * @deprecated
 */
function setScopeOptions(target, options) {
    Reflect.defineMetadata(SCOPES_KEY, options, target);
}
//# sourceMappingURL=scope-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scopes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scopes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scopes = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining Model scopes
 */
function Scopes(scopesOrScopesGetter) {
    return (target) => {
        if (typeof scopesOrScopesGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, {
                getScopes: scopesOrScopesGetter,
            });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, scopesOrScopesGetter);
        }
    };
}
exports.Scopes = Scopes;
//# sourceMappingURL=scopes.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferDataType = exports.isDataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
/*
 * Checks if specified value is a sequelize data type (ABSTRACT, STRING...)
 */
function isDataType(value) {
    return typeof value === 'string' ||
        (typeof value === 'function' && value({}) instanceof sequelize_1.DataTypes.ABSTRACT) ||
        value instanceof sequelize_1.DataTypes.ABSTRACT;
}
exports.isDataType = isDataType;
/**
 * Infers sequelize data type by design type
 */
function inferDataType(designType) {
    switch (designType) {
        case String:
            return sequelize_1.DataTypes.STRING;
        case BigInt:
            return sequelize_1.DataTypes.BIGINT;
        case Number:
            return sequelize_1.DataTypes.INTEGER;
        case Boolean:
            return sequelize_1.DataTypes.BOOLEAN;
        case Date:
            return sequelize_1.DataTypes.DATE;
        case Buffer:
            return sequelize_1.DataTypes.BLOB;
        default:
            return void 0;
    }
}
exports.inferDataType = inferDataType;
//# sourceMappingURL=data-type-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
exports.DataType = sequelize_1.DataTypes;
//# sourceMappingURL=data-type.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=repository.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=sequelize-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getModels = exports.prepareArgs = exports.prepareOptions = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const glob = __webpack_require__(/*! glob */ "glob");
const array_1 = __webpack_require__(/*! ../../shared/array */ "./node_modules/sequelize-typescript/dist/shared/array.js");
/**
 * Prepares sequelize config passed to original sequelize constructor
 */
function prepareOptions(options) {
    if (options.validateOnly) {
        return getValidationOnlyOptions(options);
    }
    return Object.assign({}, options);
}
exports.prepareOptions = prepareOptions;
function prepareArgs(...args) {
    const lastArg = args[args.length - 1];
    const options = lastArg && typeof lastArg === 'object'
        ? prepareOptions(lastArg) : undefined;
    if (options) {
        args[args.length - 1] = options;
    }
    return { preparedArgs: args, options };
}
exports.prepareArgs = prepareArgs;
function getValidationOnlyOptions(options) {
    return Object.assign(Object.assign({}, options), { dialect: 'sqlite', dialectModulePath: __dirname + '/../validation-only/db-dialect-dummy' });
}
/**
 * Determines models from value
 */
function getModels(arg, modelMatch) {
    const hasSupportedExtension = path => ['.ts', '.js'].indexOf(path_1.extname(path)) !== -1;
    if (arg && typeof arg[0] === 'string') {
        return arg.reduce((models, dir) => {
            if (!glob.hasMagic(dir) && !hasSupportedExtension(dir))
                dir = path_1.join(dir, '/*');
            const _models = glob
                .sync(dir)
                .filter(isImportable)
                .map(getFullfilepathWithoutExtension)
                .filter(array_1.uniqueFilter)
                .map(fullPath => {
                const module = __webpack_require__("./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive")(fullPath);
                const fileName = path_1.basename(fullPath);
                const matchedMemberKey = Object.keys(module).find(m => modelMatch(fileName, m));
                const matchedMember = matchedMemberKey ? module[matchedMemberKey] : undefined;
                if (!matchedMember && !module.default) {
                    throw new Error(`No default export defined for file "${fileName}" or ` +
                        `export does not satisfy filename.`);
                }
                return matchedMember || module.default;
            });
            models.push(..._models);
            return models;
        }, []);
    }
    return arg;
}
exports.getModels = getModels;
/**
 * Checks if specified filename is importable or not;
 * Which means that, it needs to have a specific file extension
 */
function isImportable(file) {
    const filePart = file.slice(-3);
    return filePart === '.js' || (filePart === '.ts' && file.slice(-5) !== '.d.ts');
}
/**
 * Return the value of the full path with filename, without extension
 */
function getFullfilepathWithoutExtension(file) {
    const parsedFile = path_1.parse(file);
    return path_1.join(parsedFile.dir, parsedFile.name);
}
//# sourceMappingURL=sequelize-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sequelize = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const sequelize_service_1 = __webpack_require__(/*! ./sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js");
const model_service_1 = __webpack_require__(/*! ../../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const scope_service_1 = __webpack_require__(/*! ../../scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
const hooks_service_1 = __webpack_require__(/*! ../../hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
const association_service_1 = __webpack_require__(/*! ../../associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const attribute_service_1 = __webpack_require__(/*! ../../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const index_service_1 = __webpack_require__(/*! ../../model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
class Sequelize extends sequelize_1.Sequelize {
    constructor(...args) {
        const { preparedArgs, options } = sequelize_service_1.prepareArgs(...args);
        super(...preparedArgs);
        if (options) {
            this.repositoryMode = !!options.repositoryMode;
            if (options.models)
                this.addModels(options.models);
            if (options.modelPaths)
                this.addModels(options.modelPaths);
        }
        else {
            this.repositoryMode = false;
        }
    }
    model(model) {
        if (typeof model !== 'string') {
            return super.model(model_service_1.getModelName(model.prototype));
        }
        return super.model(model);
    }
    addModels(arg, modelMatch) {
        const defaultModelMatch = (filename, member) => filename === member;
        const models = sequelize_service_1.getModels(arg, modelMatch || this.options.modelMatch || defaultModelMatch);
        const definedModels = this.defineModels(models);
        this.associateModels(definedModels);
        scope_service_1.resolveScopes(definedModels);
        hooks_service_1.installHooks(definedModels);
    }
    getRepository(modelClass) {
        return this.model(modelClass);
    }
    associateModels(models) {
        models.forEach(model => {
            const associations = association_service_1.getAssociations(model.prototype);
            if (!associations)
                return;
            associations.forEach(association => {
                const options = association.getSequelizeOptions(model, this);
                const associatedClass = this.model(association.getAssociatedClass());
                if (!associatedClass.isInitialized) {
                    throw new model_not_initialized_error_1.ModelNotInitializedError(associatedClass, `Association between ${associatedClass.name} and ${model.name} cannot be resolved.`);
                }
                model[association.getAssociation()](associatedClass, options);
            });
        });
    }
    defineModels(models) {
        return models.map(model => {
            const modelName = model_service_1.getModelName(model.prototype);
            const attributes = attribute_service_1.getAttributes(model.prototype);
            const indexes = index_service_1.getIndexes(model.prototype);
            const modelOptions = model_service_1.getOptions(model.prototype);
            if (!modelOptions)
                throw new Error(`@Table annotation is missing on class "${model['name']}"`);
            const indexArray = Object.keys(indexes.named)
                .map(key => indexes.named[key])
                .concat(indexes.unnamed);
            const initOptions = Object.assign(Object.assign(Object.assign({}, (indexArray.length > 0 && { indexes: indexArray })), modelOptions), { modelName, sequelize: this });
            const definedModel = this.repositoryMode
                ? this.createRepositoryModel(model)
                : model;
            definedModel.init(attributes, initOptions);
            return definedModel;
        });
    }
    createRepositoryModel(modelClass) {
        return class extends modelClass {
        };
    }
}
exports.Sequelize = Sequelize;
//# sourceMappingURL=sequelize.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/ sync ***!
  \**************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Dummy database file, which gets required by sequelize, to
 * make validation of models possible without using the
 * actual ORM or any database connection.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verbose = void 0;
function verbose() {
    return {};
}
exports.verbose = verbose;
//# sourceMappingURL=db-dialect-dummy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueFilter = exports.unique = void 0;
/**
 * Removes duplicates from specified array
 */
function unique(arr) {
    return arr.filter(exports.uniqueFilter);
}
exports.unique = unique;
/**
 * Returns true for items, that only exists once on an array
 */
const uniqueFilter = (item, index, arr) => arr.indexOf(item) === index;
exports.uniqueFilter = uniqueFilter;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/object.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllPropertyNames = exports.cloneRegExp = exports.deepAssign = void 0;
function deepAssign(target, ...sources) {
    sources.forEach(source => {
        Object
            .getOwnPropertyNames(source)
            .forEach(key => assign(key, target, source));
        /* istanbul ignore next */
        if (Object.getOwnPropertySymbols) {
            Object
                .getOwnPropertySymbols(source)
                .forEach(key => assign(key, target, source));
        }
    });
    return target;
    function assign(key, _target, _source) {
        const sourceValue = _source[key];
        if (sourceValue !== void 0) {
            let targetValue = _target[key];
            if (Array.isArray(sourceValue)) {
                if (!Array.isArray(targetValue)) {
                    targetValue = [];
                }
                const length = targetValue.length;
                sourceValue.forEach((_, index) => assign(length + index, targetValue, sourceValue));
            }
            else if (typeof sourceValue === 'object') {
                if (sourceValue instanceof RegExp) {
                    targetValue = cloneRegExp(sourceValue);
                }
                else if (sourceValue instanceof Date) {
                    targetValue = new Date(sourceValue);
                }
                else if (sourceValue === null) {
                    targetValue = null;
                }
                else {
                    if (!targetValue) {
                        targetValue = Object.create(sourceValue.constructor.prototype);
                    }
                    deepAssign(targetValue, sourceValue);
                }
            }
            else {
                targetValue = sourceValue;
            }
            _target[key] = targetValue;
        }
    }
}
exports.deepAssign = deepAssign;
/**
 * I clone the given RegExp object, and ensure that the given flags exist on
 * the clone. The injectFlags parameter is purely additive - it cannot remove
 * flags that already exist on the
 *
 * @param input RegExp - I am the regular expression object being cloned.
 * @param injectFlags String( Optional ) - I am the flags to enforce on the clone.
 * @source https://www.bennadel.com/blog/2664-cloning-regexp-regular-expression-objects-in-javascript.htm
 */
function cloneRegExp(input, injectFlags) {
    const pattern = input.source;
    let flags = "";
    // Make sure the parameter is a defined string - it will make the conditional
    // logic easier to read.
    injectFlags = (injectFlags || "");
    // Test for global.
    if (input.global || (/g/i).test(injectFlags)) {
        flags += "g";
    }
    // Test for ignoreCase.
    if (input.ignoreCase || (/i/i).test(injectFlags)) {
        flags += "i";
    }
    // Test for multiline.
    if (input.multiline || (/m/i).test(injectFlags)) {
        flags += "m";
    }
    // Return a clone with the additive flags.
    return (new RegExp(pattern, flags));
}
exports.cloneRegExp = cloneRegExp;
function getAllPropertyNames(obj) {
    const names = [];
    const exists = {};
    do {
        names.push.apply(names, Object.getOwnPropertyNames(obj));
        obj = Object.getPrototypeOf(obj);
    } while (obj !== Object.prototype);
    return names.filter(name => {
        const isValid = !exists[name] && name !== 'constructor';
        exists[name] = true;
        return isValid;
    });
}
exports.getAllPropertyNames = getAllPropertyNames;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/string.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.capitalize = void 0;
/**
 * Capitalize specified string value
 */
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.substr(1, value.length);
}
exports.capitalize = capitalize;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/contains.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/contains.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Contains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Force specific substrings
 */
function Contains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            contains: value
        }
    });
}
exports.Contains = Contains;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/equals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/equals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Equals = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow a specific value
 */
function Equals(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            equals: value
        }
    });
}
exports.Equals = Equals;
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-after.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-after.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAfter = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings after a specific date
 */
function IsAfter(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAfter: date
        }
    });
}
exports.IsAfter = IsAfter;
//# sourceMappingURL=is-after.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alpha.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlpha = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow letters
 */
function IsAlpha(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlpha: true
        }
    });
}
exports.IsAlpha = IsAlpha;
//# sourceMappingURL=is-alpha.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlphanumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow alphanumeric characters, so "_abc" will fail
 */
function IsAlphanumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlphanumeric: true
        }
    });
}
exports.IsAlphanumeric = IsAlphanumeric;
//# sourceMappingURL=is-alphanumeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-array.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsArray = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow arrays
 */
function IsArray(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isArray: true
        }
    });
}
exports.IsArray = IsArray;
//# sourceMappingURL=is-array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-before.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-before.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsBefore = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings before a specific date
 */
function IsBefore(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isBefore: date
        }
    });
}
exports.IsBefore = IsBefore;
//# sourceMappingURL=is-before.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-credit-card.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsCreditCard = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check for valid credit card numbers
 */
function IsCreditCard(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isCreditCard: true
        }
    });
}
exports.IsCreditCard = IsCreditCard;
//# sourceMappingURL=is-credit-card.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-date.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-date.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings
 */
function IsDate(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDate: true
        }
    });
}
exports.IsDate = IsDate;
//# sourceMappingURL=is-date.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-decimal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDecimal = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for any numbers
 */
function IsDecimal(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDecimal: true
        }
    });
}
exports.IsDecimal = IsDecimal;
//# sourceMappingURL=is-decimal.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-email.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-email.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsEmail = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for email format (foo@bar.com)
 */
function IsEmail(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isEmail: true
        }
    });
}
exports.IsEmail = IsEmail;
//# sourceMappingURL=is-email.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-float.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-float.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsFloat = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid floating point numbers
 */
function IsFloat(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isFloat: true
        }
    });
}
exports.IsFloat = IsFloat;
//# sourceMappingURL=is-float.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-in.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-in.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is one of these
 */
function IsIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIn: arg
        }
    });
}
exports.IsIn = IsIn;
//# sourceMappingURL=is-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-int.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-int.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsInt = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid integers
 */
function IsInt(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isInt: true
        }
    });
}
exports.IsInt = IsInt;
//# sourceMappingURL=is-int.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv4 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1)
 */
function IsIPv4(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv4: true
        }
    });
}
exports.IsIPv4 = IsIPv4;
//# sourceMappingURL=is-ip-v4.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv6 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv6 format
 */
function IsIPv6(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv6: true
        }
    });
}
exports.IsIPv6 = IsIPv6;
//# sourceMappingURL=is-ip-v6.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIP = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1) or IPv6 format
 */
function IsIP(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIP: true
        }
    });
}
exports.IsIP = IsIP;
//# sourceMappingURL=is-ip.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-lowercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsLowercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for lowercase
 */
function IsLowercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isLowercase: true
        }
    });
}
exports.IsLowercase = IsLowercase;
//# sourceMappingURL=is-lowercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-null.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-null.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allows null
 */
function IsNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNull: true
        }
    });
}
exports.IsNull = IsNull;
//# sourceMappingURL=is-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-numeric.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow numbers
 */
function IsNumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNumeric: true
        }
    });
}
exports.IsNumeric = IsNumeric;
//# sourceMappingURL=is-numeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uppercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUppercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for uppercase
 */
function IsUppercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUppercase: true
        }
    });
}
exports.IsUppercase = IsUppercase;
//# sourceMappingURL=is-uppercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUrl = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for url format (http://foo.com)
 */
function IsUrl(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUrl: true
        }
    });
}
exports.IsUrl = IsUrl;
//# sourceMappingURL=is-url.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uuid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUUID = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/*
 * Only allow uuids.
 * Version's regular expressions:
 * https://github.com/chriso/validator.js/blob/b59133b1727b6af355b403a9a97a19226cceb34b/lib/isUUID.js#L14-L19.
 */
function IsUUID(version) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUUID: version
        }
    });
}
exports.IsUUID = IsUUID;
//# sourceMappingURL=is-uuid.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Is = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Is(...args) {
    const options = {};
    const argIsFunction = typeof args[0] === 'function';
    if (argIsFunction || (typeof args[0] === 'string' && typeof args[1] === 'function')) {
        let validator;
        let name;
        if (argIsFunction) {
            validator = args[0];
            name = validator.name;
            if (!name)
                throw new Error(`Passed validator function must have a name`);
        }
        else {
            name = args[0];
            validator = args[1];
        }
        options[`is${name.charAt(0).toUpperCase() + name.substr(1, name.length)}`] = validator;
    }
    else {
        options.is = args[0];
    }
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Is = Is;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/length.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Length = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values with length between min and max
 */
function Length({ msg, min, max }) {
    let options;
    const length = [min || 0, max];
    options = msg ? { args: length, msg: msg } : length;
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            len: options
        }
    });
}
exports.Length = Length;
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/max.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/max.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Max = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values <= limit
 */
function Max(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            max: limit
        }
    });
}
exports.Max = Max;
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/min.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/min.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Min = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values >= limit
 */
function Min(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            min: limit
        }
    });
}
exports.Min = Min;
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-contains.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-contains.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotContains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Don't allow specific substrings
 */
function NotContains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notContains: value
        }
    });
}
exports.NotContains = NotContains;
//# sourceMappingURL=not-contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-empty.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-empty.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotEmpty = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function NotEmpty(...args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: options,
            }
        });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: true
            }
        });
    }
}
exports.NotEmpty = NotEmpty;
//# sourceMappingURL=not-empty.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-in.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-in.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is not one of these
 */
function NotIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notIn: arg
        }
    });
}
exports.NotIn = NotIn;
//# sourceMappingURL=not-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-null.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-null.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Won't allow null
 */
function NotNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notNull: true
        }
    });
}
exports.NotNull = NotNull;
//# sourceMappingURL=not-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Not = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will not allow values, that match the string regex or real regex
 */
function Not(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            not: arg
        }
    });
}
exports.Not = Not;
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets validation options for annotated field
 */
function Validate(options) {
    options = Object.assign({}, options);
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Validate = Validate;
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = void 0;
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const Validator = (target, propertyName, descriptor) => {
    model_service_1.addOptions(target, {
        validate: {
            [propertyName]: descriptor.value
        }
    });
};
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "./node_modules/sequelize/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sequelize/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
  * The entry point.
  *
  * @module Sequelize
  */
module.exports = __webpack_require__(/*! ./lib/sequelize */ "./node_modules/sequelize/lib/sequelize.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/base.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { AssociationError } = __webpack_require__(/*! ./../errors */ "./node_modules/sequelize/lib/errors/index.js");

/**
 * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).
 *
 * * hasOne - adds a foreign key to the target and singular association mixins to the source.
 * * belongsTo - add a foreign key and singular association mixins to the source.
 * * hasMany - adds a foreign key to target and plural association mixins to the source.
 * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.
 *
 * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.
 *
 * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.
 *
 * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.
 *
 * ```js
 * User.hasMany(Picture)
 * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })
 *
 * user.getPictures() // gets you all pictures
 * user.getProfilePicture() // gets you only the profile picture
 *
 * User.findAll({
 *   where: ...,
 *   include: [
 *     { model: Picture }, // load all pictures
 *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture.
 *     // Notice that the spelling must be the exact same as the one in the association
 *   ]
 * })
 * ```
 * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,
 * equivalent to those passed to `sequelize.define`.
 *
 * ```js
 * User.hasMany(Picture, { foreignKey: 'uid' })
 * ```
 *
 * The foreign key column in Picture will now be called `uid` instead of the default `userId`.
 *
 * ```js
 * User.hasMany(Picture, {
 *   foreignKey: {
 *     name: 'uid',
 *     allowNull: false
 *   }
 * })
 * ```
 *
 * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).
 *
 * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:
 *
 * ```js
 * user.getPictures({
 *   where: {
 *     format: 'jpg'
 *   }
 * })
 * ```
 *
 * There are several ways to update and add new associations. Continuing with our example of users and pictures:
 * ```js
 * user.addPicture(p) // Add a single picture
 * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted
 * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations
 * ```
 *
 * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:
 *
 * ```js
 * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture
 * ```
 *
 * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.
 *
 * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.
 */
class Association {
  constructor(source, target, options = {}) {
    /**
     * @type {Model}
     */
    this.source = source;

    /**
     * @type {Model}
     */
    this.target = target;

    this.options = options;
    this.scope = options.scope;
    this.isSelfAssociation = this.source === this.target;
    this.as = options.as;

    /**
     * The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`
     *
     * @type {string}
     */
    this.associationType = '';

    if (source.hasAlias(options.as)) {
      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. ` +
      'Aliased associations must have unique aliases.'
      );
    }
  }

  /**
   * Normalize input
   *
   * @param {Array|string} input it may be array or single obj, instance or primary key
   *
   * @private
   * @returns {Array} built objects
   */
  toInstanceArray(input) {
    if (!Array.isArray(input)) {
      input = [input];
    }

    return input.map(element => {
      if (element instanceof this.target) return element;

      const tmpInstance = {};
      tmpInstance[this.target.primaryKeyAttribute] = element;

      return this.target.build(tmpInstance, { isNewRecord: false });
    });
  }

  [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.as;
  }
}

module.exports = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const AssociationError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").AssociationError;
const EmptyResultError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").EmptyResultError;
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * Many-to-many association with a join table.
 *
 * When the join table has additional attributes, these can be passed in the options object:
 *
 * ```js
 * UserProject = sequelize.define('user_project', {
 *   role: Sequelize.STRING
 * });
 * User.belongsToMany(Project, { through: UserProject });
 * Project.belongsToMany(User, { through: UserProject });
 * // through is required!
 *
 * user.addProject(project, { through: { role: 'manager' }});
 * ```
 *
 * All methods allow you to pass either a persisted instance, its primary key, or a mixture:
 *
 * ```js
 * const project = await Project.create({ id: 11 });
 * await user.addProjects([project, 12]);
 * ```
 *
 * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:
 *
 * ```js
 * p1.UserProjects = {
 *   started: true
 * }
 * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.
 * ```
 *
 * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.
 * ```js
 * const projects = await user.getProjects();
 * const p1 = projects[0];
 * p1.UserProjects.started // Is this project started yet?
 * })
 * ```
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.
 *
 * @see {@link Model.belongsToMany}
 */
class BelongsToMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {
      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);
    }

    if (!this.options.through.model) {
      this.options.through = {
        model: options.through
      };
    }

    this.associationType = 'BelongsToMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.through = { ...this.options.through };
    this.isMultiAssociation = true;
    this.doubleLinked = false;

    if (!this.as && this.isSelfAssociation) {
      throw new AssociationError('\'as\' must be defined for many-to-many self-associations');
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    this.combinedTableName = Utils.combineTableNames(
      this.source.tableName,
      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName
    );

    /*
    * If self association, this is the target association - Unless we find a pairing association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    /*
    * Find paired association (if exists)
    */
    _.each(this.target.associations, association => {
      if (association.associationType !== 'BelongsToMany') return;
      if (association.target !== this.source) return;

      if (this.options.through.model === association.options.through.model) {
        this.paired = association;
        association.paired = this;
      }
    });

    /*
    * Default/generated source/target keys
    */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    if (this.options.targetKey) {
      this.targetKey = this.options.targetKey;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    } else {
      this.targetKeyDefault = true;
      this.targetKey = this.target.primaryKeyAttribute;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    }

    this._createForeignAndOtherKeys();

    if (typeof this.through.model === 'string') {
      if (!this.sequelize.isDefined(this.through.model)) {
        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {
          tableName: this.through.model,
          indexes: [], //we don't want indexes here (as referenced in #2416)
          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)
          validate: {} // Don't propagate model-level validations
        }));
      } else {
        this.through.model = this.sequelize.model(this.through.model);
      }
    }

    Object.assign(this.options, _.pick(this.through.model.options, [
      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'
    ]));

    if (this.paired) {
      let needInjectPaired = false;

      if (this.targetKeyDefault) {
        this.targetKey = this.paired.sourceKey;
        this.targetKeyField = this.paired.sourceKeyField;
        this._createForeignAndOtherKeys();
      }
      if (this.paired.targetKeyDefault) {
        // in this case paired.otherKey depends on paired.targetKey,
        // so cleanup previously wrong generated otherKey
        if (this.paired.targetKey !== this.sourceKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.targetKey = this.sourceKey;
          this.paired.targetKeyField = this.sourceKeyField;
          this.paired._createForeignAndOtherKeys();
          needInjectPaired = true;
        }
      }

      if (this.otherKeyDefault) {
        this.otherKey = this.paired.foreignKey;
      }
      if (this.paired.otherKeyDefault) {
        // If paired otherKey was inferred we should make sure to clean it up
        // before adding a new one that matches the foreignKey
        if (this.paired.otherKey !== this.foreignKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.otherKey = this.foreignKey;
          needInjectPaired = true;
        }
      }

      if (needInjectPaired) {
        this.paired._injectAttributes();
      }
    }

    if (this.through) {
      this.throughModel = this.through.model;
    }

    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;

    this.associationAccessor = this.as;

    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  _createForeignAndOtherKeys() {
    /*
    * Default/generated foreign/other keys
    */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else {
      this.foreignKeyAttribute = {};
      this.foreignKey = this.options.foreignKey || Utils.camelize(
        [
          this.source.options.name.singular,
          this.sourceKey
        ].join('_')
      );
    }

    if (_.isObject(this.options.otherKey)) {
      this.otherKeyAttribute = this.options.otherKey;
      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;
    } else {
      if (!this.options.otherKey) {
        this.otherKeyDefault = true;
      }

      this.otherKeyAttribute = {};
      this.otherKey = this.options.otherKey || Utils.camelize(
        [
          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,
          this.targetKey
        ].join('_')
      );
    }
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    this.identifier = this.foreignKey;
    this.foreignIdentifier = this.otherKey;

    // remove any PKs previously defined by sequelize
    // but ignore any keys that are part of this association (#5865)
    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {
      if (attribute.primaryKey === true && attribute._autoGenerated === true) {
        if (attributeName === this.foreignKey || attributeName === this.otherKey) {
          // this key is still needed as it's part of the association
          // so just set primaryKey to false
          attribute.primaryKey = false;
        }
        else {
          delete this.through.model.rawAttributes[attributeName];
        }
        this.primaryKeyDeleted = true;
      }
    });

    const sourceKey = this.source.rawAttributes[this.sourceKey];
    const sourceKeyType = sourceKey.type;
    const sourceKeyField = this.sourceKeyField;
    const targetKey = this.target.rawAttributes[this.targetKey];
    const targetKeyType = targetKey.type;
    const targetKeyField = this.targetKeyField;
    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };
    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };

    if (this.primaryKeyDeleted === true) {
      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;
    } else if (this.through.unique !== false) {
      let uniqueKey;
      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {
        uniqueKey = this.options.uniqueKey;
      } else {
        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');
      }
      targetAttribute.unique = sourceAttribute.unique = uniqueKey;
    }

    if (!this.through.model.rawAttributes[this.foreignKey]) {
      this.through.model.rawAttributes[this.foreignKey] = {
        _autoGenerated: true
      };
    }

    if (!this.through.model.rawAttributes[this.otherKey]) {
      this.through.model.rawAttributes[this.otherKey] = {
        _autoGenerated: true
      };
    }

    if (this.options.constraints !== false) {
      sourceAttribute.references = {
        model: this.source.getTableName(),
        key: sourceKeyField
      };
      // For the source attribute the passed option is the priority
      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;
      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;

      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';
      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';

      targetAttribute.references = {
        model: this.target.getTableName(),
        key: targetKeyField
      };
      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)
      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;
      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;

      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';
      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';
    }

    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);
    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);

    this.through.model.refreshAttributes();

    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;

    if (this.paired && !this.paired.foreignIdentifierField) {
      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;
    }

    this.toSource = new BelongsTo(this.through.model, this.source, {
      foreignKey: this.foreignKey
    });
    this.manyFromSource = new HasMany(this.source, this.through.model, {
      foreignKey: this.foreignKey
    });
    this.oneFromSource = new HasOne(this.source, this.through.model, {
      foreignKey: this.foreignKey,
      sourceKey: this.sourceKey,
      as: this.through.model.name
    });

    this.toTarget = new BelongsTo(this.through.model, this.target, {
      foreignKey: this.otherKey
    });
    this.manyFromTarget = new HasMany(this.target, this.through.model, {
      foreignKey: this.otherKey
    });
    this.oneFromTarget = new HasOne(this.target, this.through.model, {
      foreignKey: this.otherKey,
      sourceKey: this.targetKey,
      as: this.through.model.name
    });

    if (this.paired && this.paired.otherKeyDefault) {
      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {
        foreignKey: this.paired.otherKey
      });

      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {
        foreignKey: this.paired.otherKey,
        sourceKey: this.paired.targetKey,
        as: this.paired.through.model.name
      });
    }

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @see
   * {@link Model} for a full explanation of options
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   * @param {object} [options.through.where] An optional where clause applied to through model (join table)
   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instance, options) {
    options = Utils.cloneDeep(options) || {};

    const through = this.through;
    let scopeWhere;
    let throughWhere;

    if (this.scope) {
      scopeWhere = { ...this.scope };
    }

    options.where = {
      [Op.and]: [
        scopeWhere,
        options.where
      ]
    };

    if (Object(through.model) === through.model) {
      throughWhere = {};
      throughWhere[this.foreignKey] = instance.get(this.sourceKey);

      if (through.scope) {
        Object.assign(throughWhere, through.scope);
      }

      //If a user pass a where on the options through options, make an "and" with the current throughWhere
      if (options.through && options.through.where) {
        throughWhere = {
          [Op.and]: [throughWhere, options.through.where]
        };
      }

      options.include = options.include || [];
      options.include.push({
        association: this.oneFromTarget,
        attributes: options.joinTableAttributes,
        required: true,
        paranoid: _.get(options.through, 'paranoid', true),
        where: throughWhere
      });
    }

    let model = this.target;
    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        model = model.unscoped();
      } else {
        model = model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      model = model.schema(options.schema, options.schemaDelimiter);
    }

    return model.findAll(options);
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    const sequelize = this.target.sequelize;

    options = Utils.cloneDeep(options);
    options.attributes = [
      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']
    ];
    options.joinTableAttributes = [];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated
   *
   * @param {Model} sourceInstance source instance to check for an association with
   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise<boolean>}
   */
  async has(sourceInstance, instances, options) {
    if (!Array.isArray(instances)) {
      instances = [instances];
    }

    options = {
      raw: true,
      ...options,
      scope: false,
      attributes: [this.targetKey],
      joinTableAttributes: []
    };

    const instancePrimaryKeys = instances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.targetKey]: instance
      };
    });

    options.where = {
      [Op.and]: [
        { [Op.or]: instancePrimaryKeys },
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return _.differenceWith(instancePrimaryKeys, associatedObjects,
      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;
  }

  /**
   * Set the associated models by passing an array of instances or their primary keys.
   * Everything that it not in the passed array will be un-associated.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`
   * @param {object} [options.validate] Run validation for the join model
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async set(sourceInstance, newAssociatedObjects, options) {
    options = options || {};

    const sourceKey = this.sourceKey;
    const targetKey = this.targetKey;
    const identifier = this.identifier;
    const foreignIdentifier = this.foreignIdentifier;

    if (newAssociatedObjects === null) {
      newAssociatedObjects = [];
    } else {
      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);
    }
    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      ...this.through.scope
    };

    const updateAssociations = currentRows => {
      const obsoleteAssociations = [];
      const promises = [];
      const defaultAttributes = options.through || {};

      const unassociatedObjects = newAssociatedObjects.filter(obj =>
        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))
      );

      for (const currentRow of currentRows) {
        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));

        if (!newObj) {
          obsoleteAssociations.push(currentRow);
        } else {
          let throughAttributes = newObj[this.through.model.name];
          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
          if (throughAttributes instanceof this.through.model) {
            throughAttributes = {};
          }

          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).length) {
            promises.push(
              this.through.model.update(attributes, Object.assign(options, {
                where: {
                  [identifier]: sourceInstance.get(sourceKey),
                  [foreignIdentifier]: newObj.get(targetKey)
                }
              }
              ))
            );
          }
        }
      }

      if (obsoleteAssociations.length > 0) {
        promises.push(
          this.through.model.destroy({
            ...options,
            where: {
              [identifier]: sourceInstance.get(sourceKey),
              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),
              ...this.through.scope
            }
          })
        );
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          return {
            ...defaultAttributes,
            ...unassociatedObject[this.through.model.name],
            [identifier]: sourceInstance.get(sourceKey),
            [foreignIdentifier]: unassociatedObject.get(targetKey),
            ...this.through.scope
          };
        });

        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });
      return await updateAssociations(currentRows);
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations([]);
      throw error;
    }
  }

  /**
   * Associate one or several rows with source instance. It will not un-associate any already associated instance
   * that may be missing from `newInstances`.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`
   * @param {object} [options.validate] Run validation for the join model.
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, newInstances, options) {
    // If newInstances is null or undefined, no-op
    if (!newInstances) return Promise.resolve();

    options = { ...options };

    const association = this;
    const sourceKey = association.sourceKey;
    const targetKey = association.targetKey;
    const identifier = association.identifier;
    const foreignIdentifier = association.foreignIdentifier;
    const defaultAttributes = options.through || {};

    newInstances = association.toInstanceArray(newInstances);

    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),
      ...association.through.scope
    };

    const updateAssociations = currentRows => {
      const promises = [];
      const unassociatedObjects = [];
      const changedAssociations = [];
      for (const obj of newInstances) {
        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));

        if (!existingAssociation) {
          unassociatedObjects.push(obj);
        } else {
          const throughAttributes = obj[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {
            changedAssociations.push(obj);
          }
        }
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          const throughAttributes = unassociatedObject[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          attributes[identifier] = sourceInstance.get(sourceKey);
          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);

          Object.assign(attributes, association.through.scope);

          return attributes;
        });

        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      for (const assoc of changedAssociations) {
        let throughAttributes = assoc[association.through.model.name];
        const attributes = { ...defaultAttributes, ...throughAttributes };
        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
        if (throughAttributes instanceof association.through.model) {
          throughAttributes = {};
        }

        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {
          [identifier]: sourceInstance.get(sourceKey),
          [foreignIdentifier]: assoc.get(targetKey)
        } })));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });
      const [associations] = await updateAssociations(currentRows);
      return associations;
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations();
      throw error;
    }
  }

  /**
   * Un-associate one or more instance(s).
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `through.destroy`
   *
   * @returns {Promise}
   */
  remove(sourceInstance, oldAssociatedObjects, options) {
    const association = this;

    options = options || {};

    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);

    const where = {
      [association.identifier]: sourceInstance.get(association.sourceKey),
      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))
    };

    return association.through.model.destroy({ ...options, where });
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model
   * @param {object} [options] Options passed to create and add
   * @param {object} [options.through] Additional attributes for the join table
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options) {
    const association = this;

    options = options || {};
    values = values || {};

    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (association.scope) {
      Object.assign(values, association.scope);
      if (options.fields) {
        options.fields = options.fields.concat(Object.keys(association.scope));
      }
    }

    // Create the related model instance
    const newAssociatedObject = await association.target.create(values, options);

    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));
    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsToMany;
module.exports.BelongsToMany = BelongsToMany;
module.exports.default = BelongsToMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.
 *
 * @see {@link Model.belongsTo}
 */
class BelongsTo extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'BelongsTo';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.as,
          this.target.primaryKeyAttribute
        ].join('_')
      );
    }

    this.identifier = this.foreignKey;
    if (this.source.rawAttributes[this.identifier]) {
      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;
    }

    if (
      this.options.targetKey
      && !this.target.rawAttributes[this.options.targetKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.targetKey}" passed as targetKey, define this attribute on model "${this.target.name}" first`);
    }

    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;
    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;
    this.targetIdentifier = this.targetKey;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the source table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);
    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);

    this.source.refreshAttributes();

    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.
   * @param {string}         [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};
    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.targetKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))
      };
    } else {
      if (this.targetKeyIsPrimary && !options.where) {
        return Target.findByPk(instance.get(this.foreignKey), options);
      }
      where[this.targetKey] = instance.get(this.foreignKey);
      options.limit = null;
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.foreignKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.targetKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options={}] options passed to `this.save`
   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.
   *
   *  @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options = {}) {
    let value = associatedInstance;

    if (associatedInstance instanceof this.target) {
      value = associatedInstance[this.targetKey];
    }

    sourceInstance.set(this.foreignKey, value);

    if (options.save === false) return;

    options = {
      fields: [this.foreignKey],
      allowNull: [this.foreignKey],
      association: true,
      ...options
    };

    // passes the changed field to save, so only that field get updated.
    return await sourceInstance.save(options);
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options={}] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create}  for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    const newAssociatedObject = await this.target.create(values, options);
    await sourceInstance[this.accessors.set](newAssociatedObject, options);

    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsTo;
module.exports.BelongsTo = BelongsTo;
module.exports.default = BelongsTo;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-many.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-many.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-many association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.
 * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.
 *
 * @see {@link Model.hasMany}
 */
class HasMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.isMultiAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.options.through) {
      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');
    }

    /*
    * If self association, this is the target association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    /*
     * Foreign key setup
     */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.source.options.name.singular,
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    /*
     * Source key setup
     */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;

    if (this.source.rawAttributes[this.sourceKey]) {
      this.sourceKeyAttribute = this.sourceKey;
      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    } else {
      this.sourceKeyAttribute = this.source.primaryKeyAttribute;
      this.sourceKeyField = this.source.primaryKeyField;
    }

    // Get singular and plural names
    // try to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.associationAccessor = this.as;
    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m
    const constraintOptions = { ...this.options };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();
    this.source.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findAll}  for a full explanation of options
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instances, options = {}) {
    const where = {};

    let Model = this.target;
    let instance;
    let values;

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    options = { ...options };

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    if (instances) {
      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));

      if (options.limit && instances.length > 1) {
        options.groupedLimit = {
          limit: options.limit,
          on: this, // association
          values
        };

        delete options.limit;
      } else {
        where[this.foreignKey] = {
          [Op.in]: values
        };
        delete options.groupedLimit;
      }
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Model = Model.unscoped();
      } else {
        Model = Model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Model = Model.schema(options.schema, options.schemaDelimiter);
    }

    const results = await Model.findAll(options);
    if (instance) return results;

    const result = {};
    for (const _instance of instances) {
      result[_instance.get(this.sourceKey, { raw: true })] = [];
    }

    for (const _instance of results) {
      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);
    }

    return result;
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model}        instance the source instance
   * @param {object}         [options] find & count options
   * @param {object}         [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    options = Utils.cloneDeep(options);

    options.attributes = [
      [
        this.sequelize.fn(
          'COUNT',
          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)
        ),
        'count'
      ]
    ];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more rows are associated with `this`.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise}
   */
  async has(sourceInstance, targetInstances, options) {
    const where = {};

    if (!Array.isArray(targetInstances)) {
      targetInstances = [targetInstances];
    }

    options = {
      ...options,
      scope: false,
      attributes: [this.target.primaryKeyAttribute],
      raw: true
    };

    where[Op.or] = targetInstances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.target.primaryKeyAttribute]: instance
      };
    });

    options.where = {
      [Op.and]: [
        where,
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return associatedObjects.length === targetInstances.length;
  }

  /**
   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.
   * @param {object} [options] Options passed to `target.findAll` and `update`.
   * @param {object} [options.validate] Run validation for the join model
   *
   * @returns {Promise}
   */
  async set(sourceInstance, targetInstances, options) {
    if (targetInstances === null) {
      targetInstances = [];
    } else {
      targetInstances = this.toInstanceArray(targetInstances);
    }

    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });
    const promises = [];
    const obsoleteAssociations = oldAssociations.filter(old =>
      !targetInstances.find(obj =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    const unassociatedObjects = targetInstances.filter(obj =>
      !oldAssociations.find(old =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    let updateWhere;
    let update;

    if (obsoleteAssociations.length > 0) {
      update = {};
      update[this.foreignKey] = null;

      updateWhere = {
        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>
          associatedObject[this.target.primaryKeyAttribute]
        )
      };


      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    if (unassociatedObjects.length > 0) {
      updateWhere = {};

      update = {};
      update[this.foreignKey] = sourceInstance.get(this.sourceKey);

      Object.assign(update, this.scope);
      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>
        unassociatedObject[this.target.primaryKeyAttribute]
      );

      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    await Promise.all(promises);

    return sourceInstance;
  }

  /**
   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,
   * or a mixed array of Model / string / numbers to associate multiple rows.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `target.update`.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, targetInstances, options = {}) {
    if (!targetInstances) return Promise.resolve();


    targetInstances = this.toInstanceArray(targetInstances);

    const update = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      ...this.scope
    };

    const where = {
      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>
        unassociatedObject.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return sourceInstance;
  }

  /**
   * Un-associate one or several target rows.
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `target.update`
   *
   * @returns {Promise}
   */
  async remove(sourceInstance, targetInstances, options = {}) {
    const update = {
      [this.foreignKey]: null
    };

    targetInstances = this.toInstanceArray(targetInstances);

    const where = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>
        targetInstance.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return this;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model instance
   * @param {object} [options] Options passed to `target.create`
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options = {}) {
    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (values === undefined) {
      values = {};
    }

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) options.fields.push(attribute);
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKey);
    if (options.fields) options.fields.push(this.foreignKey);
    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = HasMany;
module.exports.HasMany = HasMany;
module.exports.default = HasMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-one.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-one.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.
 * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.
 *
 * @see {@link Model.hasOne}
 */
class HasOne extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasOne';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          Utils.singularize(this.options.as || this.source.name),
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (
      this.options.sourceKey
      && !this.source.rawAttributes[this.options.sourceKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.sourceKey}" passed as sourceKey, define this attribute on model "${this.source.name}" first`);
    }

    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the target table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};

    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.foreignKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.sourceKey))
      };
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey);
    }

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.sourceKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.foreignKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options] Options passed to getAssociation and `target.save`
   *
   * @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options) {
    options = { ...options, scope: false };

    const oldInstance = await sourceInstance[this.accessors.get](options);
    // TODO Use equals method once #5605 is resolved
    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>
      oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)
    );

    if (oldInstance && !alreadyAssociated) {
      oldInstance[this.foreignKey] = null;

      await oldInstance.save({
        ...options,
        fields: [this.foreignKey],
        allowNull: [this.foreignKey],
        association: true
      });
    }
    if (associatedInstance && !alreadyAssociated) {
      if (!(associatedInstance instanceof this.target)) {
        const tmpInstance = {};
        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;
        associatedInstance = this.target.build(tmpInstance, {
          isNewRecord: false
        });
      }

      Object.assign(associatedInstance, this.scope);
      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));

      return associatedInstance.save(options);
    }

    return null;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create} for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) {
          options.fields.push(attribute);
        }
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);
    if (options.fields) {
      options.fields.push(this.foreignKey);
    }

    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = HasOne;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function checkNamingCollision(association) {
  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {
    throw new Error(
      `Naming collision between attribute '${association.as}'` +
      ` and association '${association.as}' on model ${association.source.name}` +
      '. To remedy this, change either foreignKey or as in your association definition'
    );
  }
}
exports.checkNamingCollision = checkNamingCollision;

function addForeignKeyConstraints(newAttribute, source, target, options, key) {
  // FK constraints are opt-in: users must either set `foreignKeyConstraints`
  // on the association, or request an `onDelete` or `onUpdate` behavior

  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {
    // Find primary keys: composite keys not supported with this approach
    const primaryKeys = Object.keys(source.primaryKeys)
      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);

    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {
      newAttribute.references = {
        model: source.getTableName(),
        key: key || primaryKeys[0]
      };

      newAttribute.onDelete = options.onDelete;
      newAttribute.onUpdate = options.onUpdate;
    }
  }
}
exports.addForeignKeyConstraints = addForeignKeyConstraints;

/**
 * Mixin (inject) association methods to model prototype
 *
 * @private
 *
 * @param {object} association instance
 * @param {object} obj Model prototype
 * @param {Array} methods Method names to inject
 * @param {object} aliases Mapping between model and association method names
 *
 */
function mixinMethods(association, obj, methods, aliases) {
  aliases = aliases || {};

  for (const method of methods) {
    // don't override custom methods
    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {
      const realMethod = aliases[method] || method;

      obj[association.accessors[method]] = function() {
        return association[realMethod](this, ...Array.from(arguments));
      };
    }
  }
}
exports.mixinMethods = mixinMethods;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");

Association.BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
Association.HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
Association.HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
Association.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");

module.exports = Association;
module.exports.default = Association;
module.exports.Association = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/mixin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");

function isModel(model, sequelize) {
  return model
    && model.prototype
    && model.prototype instanceof sequelize.Sequelize.Model;
}

const Mixin = {
  hasMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    Object.assign(options, _.omit(source.options, ['hooks']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);
    }

    // the id is in the foreign table or in a connecting table
    const association = new HasMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);
    }

    return association;
  },

  belongsToMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;
    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;
    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);
    }
    // the id is in the foreign table or in a connecting table
    const association = new BelongsToMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);
    }

    return association;
  },

  getAssociations(target) {
    return Object.values(this.associations).filter(association => association.target.name === target.name);
  },

  getAssociationForAlias(target, alias) {
    // Two associations cannot have the same alias, so we can use find instead of filter
    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;
  }
};

// The logic for hasOne and belongsTo is exactly the same
function singleLinked(Type) {
  return function(target, options = {}) {
    // eslint-disable-next-line no-invalid-this
    const source = this;
    if (!isModel(target, source.sequelize)) {
      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);
    }


    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    if (options.useHooks) {
      source.runHooks('beforeAssociate', { source, target, type: Type }, options);
    }
    // the id is in the foreign table
    const association = new Type(source, target, Object.assign(options, source.options));
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);
    }

    return association;
  };
}

Mixin.hasOne = singleLinked(HasOne);
Mixin.belongsTo = singleLinked(BelongsTo);

module.exports = Mixin;
module.exports.Mixin = Mixin;
module.exports.default = Mixin;


/***/ }),

/***/ "./node_modules/sequelize/lib/data-types.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/data-types.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const moment = __webpack_require__(/*! moment */ "moment");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const warnings = {};
const { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js");
const { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js");

class ABSTRACT {
  toString(options) {
    return this.toSql(options);
  }
  toSql() {
    return this.key;
  }
  stringify(value, options) {
    if (this._stringify) {
      return this._stringify(value, options);
    }
    return value;
  }
  bindParam(value, options) {
    if (this._bindParam) {
      return this._bindParam(value, options);
    }
    return options.bindParam(this.stringify(value, options));
  }
  static toString() {
    return this.name;
  }
  static warn(link, text) {
    if (!warnings[text]) {
      warnings[text] = true;
      logger.warn(`${text} \n>> Check: ${link}`);
    }
  }
  static extend(oldType) {
    return new this(oldType.options);
  }
}

ABSTRACT.prototype.dialectTypes = '';

/**
 * STRING A variable length string
 */
class STRING extends ABSTRACT {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super();
    const options = typeof length === 'object' && length || { length, binary };
    this.options = options;
    this._binary = options.binary;
    this._length = options.length || 255;
  }
  toSql() {
    return joinSQLFragments([
      `VARCHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
  validate(value) {
    if (Object.prototype.toString.call(value) !== '[object String]') {
      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {
        return true;
      }
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }

  get BINARY() {
    this._binary = true;
    this.options.binary = true;
    return this;
  }

  static get BINARY() {
    return new this().BINARY;
  }
}

/**
 * CHAR A fixed length string
 */
class CHAR extends STRING {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super(typeof length === 'object' && length || { length, binary });
  }
  toSql() {
    return joinSQLFragments([
      `CHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
}

/**
 * Unlimited length TEXT column
 */
class TEXT extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYTEXT';
      case 'medium':
        return 'MEDIUMTEXT';
      case 'long':
        return 'LONGTEXT';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * An unlimited length case-insensitive text column.
 * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).
 * Only available in Postgres and SQLite.
 *
 */
class CITEXT extends ABSTRACT {
  toSql() {
    return 'CITEXT';
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * Base number type which is used to build other types
 */
class NUMBER extends ABSTRACT {
  /**
   * @param {object} options type options
   * @param {string|number} [options.length] length of type, like `INT(4)`
   * @param {boolean} [options.zerofill] Is zero filled?
   * @param {boolean} [options.unsigned] Is unsigned?
   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`
   * @param {string|number} [options.precision] defines precision for decimal type
   * @param {string|number} [options.scale] defines scale for decimal type
   */
  constructor(options = {}) {
    super();
    if (typeof options === 'number') {
      options = {
        length: options
      };
    }
    this.options = options;
    this._length = options.length;
    this._zerofill = options.zerofill;
    this._decimals = options.decimals;
    this._precision = options.precision;
    this._scale = options.scale;
    this._unsigned = options.unsigned;
  }
  toSql() {
    let result = this.key;
    if (this._length) {
      result += `(${this._length}`;
      if (typeof this._decimals === 'number') {
        result += `,${this._decimals}`;
      }
      result += ')';
    }
    if (this._unsigned) {
      result += ' UNSIGNED';
    }
    if (this._zerofill) {
      result += ' ZEROFILL';
    }
    return result;
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
  _stringify(number) {
    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {
      return number;
    }
    if (typeof number.toString === 'function') {
      return number.toString();
    }
    return number;
  }

  get UNSIGNED() {
    this._unsigned = true;
    this.options.unsigned = true;
    return this;
  }

  get ZEROFILL() {
    this._zerofill = true;
    this.options.zerofill = true;
    return this;
  }

  static get UNSIGNED() {
    return new this().UNSIGNED;
  }

  static get ZEROFILL() {
    return new this().ZEROFILL;
  }
}

/**
 * A 32 bit integer
 */
class INTEGER extends NUMBER {
  validate(value) {
    if (!Validator.isInt(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
}

/**
 * A 8 bit integer
 */
class TINYINT extends INTEGER {
}

/**
 * A 16 bit integer
 */
class SMALLINT extends INTEGER {
}

/**
 * A 24 bit integer
 */
class MEDIUMINT extends INTEGER {
}

/**
 * A 64 bit integer
 */
class BIGINT extends INTEGER {
}

/**
 * Floating point number (4-byte precision).
 */
class FLOAT extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `FLOAT(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));
    }
    return true;
  }
}

/**
 * Floating point number (4-byte precision).
 */
class REAL extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `REAL(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Floating point number (8-byte precision).
 */
class DOUBLE extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`
   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Decimal type, variable precision, take length as specified by user
 */
class DECIMAL extends NUMBER {
  /**
   * @param {string|number} [precision] defines precision
   * @param {string|number} [scale] defines scale
   */
  constructor(precision, scale) {
    super(typeof precision === 'object' && precision || { precision, scale });
  }
  toSql() {
    if (this._precision || this._scale) {
      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;
    }
    return 'DECIMAL';
  }
  validate(value) {
    if (!Validator.isDecimal(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));
    }
    return true;
  }
}

// TODO: Create intermediate class
const protoExtensions = {
  escape: false,
  _value(value) {
    if (isNaN(value)) {
      return 'NaN';
    }
    if (!isFinite(value)) {
      const sign = value < 0 ? '-' : '';
      return `${sign}Infinity`;
    }

    return value;
  },
  _stringify(value) {
    return `'${this._value(value)}'`;
  },
  _bindParam(value, options) {
    return options.bindParam(this._value(value));
  }
};

for (const floating of [FLOAT, DOUBLE, REAL]) {
  Object.assign(floating.prototype, protoExtensions);
}

/**
 * A boolean / tinyint column, depending on dialect
 */
class BOOLEAN extends ABSTRACT {
  toSql() {
    return 'TINYINT(1)';
  }
  validate(value) {
    if (!Validator.isBoolean(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));
    }
    return true;
  }
  _sanitize(value) {
    if (value !== null && value !== undefined) {
      if (Buffer.isBuffer(value) && value.length === 1) {
        // Bit fields are returned as buffers
        value = value[0];
      }
      const type = typeof value;
      if (type === 'string') {
        // Only take action on valid boolean strings.
        return value === 'true' ? true : value === 'false' ? false : value;
      }
      if (type === 'number') {
        // Only take action on valid boolean integers.
        return value === 1 ? true : value === 0 ? false : value;
      }
    }
    return value;
  }
}


BOOLEAN.parse = BOOLEAN.prototype._sanitize;

/**
 * A time column
 *
 */
class TIME extends ABSTRACT {
  toSql() {
    return 'TIME';
  }
}

/**
 * Date column with timezone, default is UTC
 */
class DATE extends ABSTRACT {
  /**
   * @param {string|number} [length] precision to allow storing milliseconds
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    return 'DATETIME';
  }
  validate(value) {
    if (!Validator.isDate(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));
    }
    return true;
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {
      return new Date(value);
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value &&
      (value === originalValue ||
        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
  _applyTimezone(date, options) {
    if (options.timezone) {
      if (momentTz.tz.zone(options.timezone)) {
        return momentTz(date).tz(options.timezone);
      }
      return date = moment(date).utcOffset(options.timezone);
    }
    return momentTz(date);
  }
  _stringify(date, options) {
    date = this._applyTimezone(date, options);
    // Z here means current timezone, _not_ UTC
    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');
  }
}

/**
 * A date only column (no timestamp)
 */
class DATEONLY extends ABSTRACT {
  toSql() {
    return 'DATE';
  }
  _stringify(date) {
    return moment(date).format('YYYY-MM-DD');
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !!value) {
      return moment(value).format('YYYY-MM-DD');
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value && originalValue === value) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
}

/**
 * A key / value store column. Only available in Postgres.
 */
class HSTORE extends ABSTRACT {
  validate(value) {
    if (!_.isPlainObject(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));
    }
    return true;
  }
}

/**
 * A JSON string column. Available in MySQL, Postgres and SQLite
 */
class JSONTYPE extends ABSTRACT {
  validate() {
    return true;
  }
  _stringify(value) {
    return JSON.stringify(value);
  }
}

/**
 * A binary storage JSON column. Only available in Postgres.
 */
class JSONB extends JSONTYPE {
}

/**
 * A default value of the current timestamp
 */
class NOW extends ABSTRACT {
}

/**
 * Binary storage
 */
class BLOB extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYBLOB';
      case 'medium':
        return 'MEDIUMBLOB';
      case 'long':
        return 'LONGBLOB';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));
    }
    return true;
  }
  _stringify(value) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    const hex = value.toString('hex');
    return this._hexify(hex);
  }
  _hexify(hex) {
    return `X'${hex}'`;
  }
  _bindParam(value, options) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    return options.bindParam(value);
  }
}


BLOB.prototype.escape = false;

/**
 * Range types are data types representing a range of values of some element type (called the range's subtype).
 * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details
 */
class RANGE extends ABSTRACT {
  /**
   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)
   */
  constructor(subtype) {
    super();
    const options = _.isPlainObject(subtype) ? subtype : { subtype };
    if (!options.subtype)
      options.subtype = new INTEGER();
    if (typeof options.subtype === 'function') {
      options.subtype = new options.subtype();
    }
    this._subtype = options.subtype.key;
    this.options = options;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));
    }
    if (value.length !== 2) {
      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');
    }
    return true;
  }
}

/**
 * A column storing a unique universal identifier.
 * Use with `UUIDV1` or `UUIDV4` for default values.
 */
class UUID extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v1 standard
 */
class UUIDV1 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v4 standard
 */
class UUIDV4 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));
    }
    return true;
  }
}

/**
 * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.
 *
 * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments
 * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.
 * Return type is mostly useful for setups that rely on types like GraphQL.
 *
 * @example <caption>Checking password length before hashing it</caption>
 * sequelize.define('user', {
 *   password_hash: DataTypes.STRING,
 *   password: {
 *     type: DataTypes.VIRTUAL,
 *     set: function (val) {
 *        // Remember to set the data value, otherwise it won't be validated
 *        this.setDataValue('password', val);
 *        this.setDataValue('password_hash', this.salt + val);
 *      },
 *      validate: {
 *         isLongEnough: function (val) {
 *           if (val.length < 7) {
 *             throw new Error("Please choose a longer password")
 *          }
 *       }
 *     }
 *   }
 * })
 *
 * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.
 *
 * @example <caption>Virtual with dependency fields</caption>
 * {
 *   active: {
 *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),
 *     get: function() {
 *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)
 *     }
 *   }
 * }
 *
 */
class VIRTUAL extends ABSTRACT {
  /**
   * @param {ABSTRACT} [ReturnType] return type for virtual type
   * @param {Array} [fields] array of fields this virtual type is dependent on
   */
  constructor(ReturnType, fields) {
    super();
    if (typeof ReturnType === 'function')
      ReturnType = new ReturnType();
    this.returnType = ReturnType;
    this.fields = fields;
  }
}

/**
 * An enumeration, Postgres Only
 *
 * @example
 * DataTypes.ENUM('value', 'another value')
 * DataTypes.ENUM(['value', 'another value'])
 * DataTypes.ENUM({
 *   values: ['value', 'another value']
 * })
 */
class ENUM extends ABSTRACT {
  /**
   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values
   */
  constructor(...args) {
    super();
    const value = args[0];
    const options = typeof value === 'object' && !Array.isArray(value) && value || {
      values: args.reduce((result, element) => {
        return result.concat(Array.isArray(element) ? element : [element]);
      }, [])
    };
    this.values = options.values;
    this.options = options;
  }
  validate(value) {
    if (!this.values.includes(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));
    }
    return true;
  }
}

/**
 * An array of `type`. Only available in Postgres.
 *
 * @example
 * DataTypes.ARRAY(DataTypes.DECIMAL)
 */
class ARRAY extends ABSTRACT {
  /**
   * @param {ABSTRACT} type type of array values
   */
  constructor(type) {
    super();
    const options = _.isPlainObject(type) ? type : { type };
    this.options = options;
    this.type = typeof options.type === 'function' ? new options.type() : options.type;
  }
  toSql() {
    return `${this.type.toSql()}[]`;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));
    }
    return true;
  }
  static is(obj, type) {
    return obj instanceof ARRAY && obj.type instanceof type;
  }
}

/**
 * A column storing Geometry information.
 * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.
 *
 * GeoJSON is accepted as input and returned as output.
 *
 * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.
 * In MySQL it is parsed using the function `GeomFromText`.
 *
 * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:
 *
 * @example <caption>Defining a Geometry type attribute</caption>
 * DataTypes.GEOMETRY
 * DataTypes.GEOMETRY('POINT')
 * DataTypes.GEOMETRY('POINT', 4326)
 *
 * @example <caption>Create a new point</caption>
 * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};
 *
 * User.create({username: 'username', geometry: point });
 *
 * @example <caption>Create a new linestring</caption>
 * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };
 *
 * User.create({username: 'username', geometry: line });
 *
 * @example <caption>Create a new polygon</caption>
 * const polygon = { type: 'Polygon', coordinates: [
 *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
 *                   [100.0, 1.0], [100.0, 0.0] ]
 *                 ]};
 *
 * User.create({username: 'username', geometry: polygon });
 *
 * @example <caption>Create a new point with a custom SRID</caption>
 * const point = {
 *   type: 'Point',
 *   coordinates: [39.807222,-76.984722],
 *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }
 * };
 *
 * User.create({username: 'username', geometry: point })
 *
 *
 * @see {@link DataTypes.GEOGRAPHY}
 */
class GEOMETRY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geometry data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}

GEOMETRY.prototype.escape = false;

/**
 * A geography datatype represents two dimensional spacial objects in an elliptic coord system.
 *
 * __The difference from geometry and geography type:__
 *
 * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.
 * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),
 * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.
 *
 * __What is best to use? It depends:__
 *
 * When choosing between the geometry and geography type for data storage, you should consider what youll be using it for.
 * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.
 * Although the new geography data type can cover the globe, the geometry type is far from obsolete.
 * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools
 *
 * @example <caption>Defining a Geography type attribute</caption>
 * DataTypes.GEOGRAPHY
 * DataTypes.GEOGRAPHY('POINT')
 * DataTypes.GEOGRAPHY('POINT', 4326)
 */
class GEOGRAPHY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geography data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}


GEOGRAPHY.prototype.escape = false;

/**
 * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.
 *
 * Only available for Postgres
 */
class CIDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIPRange(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));
    }
    return true;
  }
}

/**
 * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes
 *
 * Only available for Postgres
 */
class INET extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIP(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));
    }
    return true;
  }
}

/**
 * The MACADDR type stores MAC addresses. Takes 6 bytes
 *
 * Only available for Postgres
 *
 */
class MACADDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));
    }
    return true;
  }
}

/**
 * The TSVECTOR type stores text search vectors.
 *
 * Only available for Postgres
 *
 */
class TSVECTOR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:
 * ```js
 * sequelize.define('model', {
 *   column: DataTypes.INTEGER
 * })
 * ```
 * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean
 * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.
 *
 * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`
 *
 * Some data types have special properties that can be accessed in order to change the data type.
 * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.
 * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.
 *
 * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`
 * * The `CHAR` and `STRING` types expose the `BINARY` property
 *
 * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for
 * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: DataTypes.UUIDV1,
 *     primaryKey: true
 *   }
 * })
 * ```
 * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished
 * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value
 * from a function.
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: function() {
 *       return generateMyId()
 *     },
 *     primaryKey: true
 *   }
 * })
 * ```
 */
const DataTypes = module.exports = {
  ABSTRACT,
  STRING,
  CHAR,
  TEXT,
  NUMBER,
  TINYINT,
  SMALLINT,
  MEDIUMINT,
  INTEGER,
  BIGINT,
  FLOAT,
  TIME,
  DATE,
  DATEONLY,
  BOOLEAN,
  NOW,
  BLOB,
  DECIMAL,
  NUMERIC: DECIMAL,
  UUID,
  UUIDV1,
  UUIDV4,
  HSTORE,
  JSON: JSONTYPE,
  JSONB,
  VIRTUAL,
  ARRAY,
  ENUM,
  RANGE,
  REAL,
  'DOUBLE PRECISION': DOUBLE,
  DOUBLE,
  GEOMETRY,
  GEOGRAPHY,
  CIDR,
  INET,
  MACADDR,
  CITEXT,
  TSVECTOR
};

_.each(DataTypes, (dataType, name) => {
  // guard for aliases
  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {
    dataType.types = {};
    dataType.key = dataType.prototype.key = name;
  }
});

const dialectMap = {};
dialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ "./node_modules/sequelize/lib/dialects/postgres/data-types.js")(DataTypes);
dialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ "./node_modules/sequelize/lib/dialects/mysql/data-types.js")(DataTypes);
dialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js")(DataTypes);
dialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js")(DataTypes);
dialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ "./node_modules/sequelize/lib/dialects/mssql/data-types.js")(DataTypes);

const dialectList = Object.values(dialectMap);

for (const dataTypes of dialectList) {
  _.each(dataTypes, (DataType, key) => {
    if (!DataType.key) {
      DataType.key = DataType.prototype.key = key;
    }
  });
}

// Wrap all data types to not require `new`
for (const dataTypes of [DataTypes, ...dialectList]) {
  _.each(dataTypes, (DataType, key) => {
    dataTypes[key] = classToInvokable(DataType);
  });
}

Object.assign(DataTypes, dialectMap);


/***/ }),

/***/ "./node_modules/sequelize/lib/deferrable.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/deferrable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { classToInvokable } = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");

class ABSTRACT {
  static toString(...args) {
    return new this().toString(...args);
  }

  toString(...args) {
    return this.toSql(...args);
  }

  toSql() {
    throw new Error('toSql implementation missing');
  }
}

class INITIALLY_DEFERRED extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY DEFERRED';
  }
}

class INITIALLY_IMMEDIATE extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY IMMEDIATE';
  }
}

class NOT extends ABSTRACT {
  toSql() {
    return 'NOT DEFERRABLE';
  }
}

class SET_DEFERRED extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setDeferredQuery(this.constraints);
  }
}

class SET_IMMEDIATE extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setImmediateQuery(this.constraints);
  }
}

/**
 * A collection of properties related to deferrable constraints. It can be used to
 * make foreign key constraints deferrable and to set the constraints within a
 * transaction. This is only supported in PostgreSQL.
 *
 * The foreign keys can be configured like this. It will create a foreign key
 * that will check the constraints immediately when the data was inserted.
 *
 * ```js
 * sequelize.define('Model', {
 *   foreign_id: {
 *     type: Sequelize.INTEGER,
 *     references: {
 *       model: OtherModel,
 *       key: 'id',
 *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE
 *     }
 *   }
 * });
 * ```
 *
 * The constraints can be configured in a transaction like this. It will
 * trigger a query once the transaction has been started and set the constraints
 * to be checked at the very end of the transaction.
 *
 * ```js
 * sequelize.transaction({
 *   deferrable: Sequelize.Deferrable.SET_DEFERRED
 * });
 * ```
 *
 * @property INITIALLY_DEFERRED    Use when declaring a constraint. Allow and enable by default this constraint's checks to be deferred at the end of transactions.
 * @property INITIALLY_IMMEDIATE   Use when declaring a constraint. Allow the constraint's checks to be deferred at the end of transactions.
 * @property NOT                   Use when declaring a constraint. Set the constraint to not deferred. This is the default in PostgreSQL and makes it impossible to dynamically defer the constraints within a transaction.
 * @property SET_DEFERRED          Use when declaring a transaction. Defer the deferrable checks involved in this transaction at commit.
 * @property SET_IMMEDIATE         Use when declaring a transaction. Execute the deferrable checks involved in this transaction immediately.
 */

const Deferrable = {
  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),
  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),
  NOT: classToInvokable(NOT),
  SET_DEFERRED: classToInvokable(SET_DEFERRED),
  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)
};

module.exports = Deferrable;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ "./node_modules/sequelize-pool/lib/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const errors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const debug = logger.debugContext('pool');

/**
 * Abstract Connection Manager
 *
 * Connection manager which handles pooling & replication.
 * Uses sequelize-pool for pooling
 *
 * @private
 */
class ConnectionManager {
  constructor(dialect, sequelize) {
    const config = _.cloneDeep(sequelize.config);

    this.sequelize = sequelize;
    this.config = config;
    this.dialect = dialect;
    this.versionPromise = null;
    this.dialectName = this.sequelize.options.dialect;

    if (config.pool === false) {
      throw new Error('Support for pool:false was removed in v4.0');
    }

    config.pool = _.defaults(config.pool || {}, {
      max: 5,
      min: 0,
      idle: 10000,
      acquire: 60000,
      evict: 1000,
      validate: this._validate.bind(this)
    });

    this.initPools();
  }

  refreshTypeParser(dataTypes) {
    _.each(dataTypes, dataType => {
      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {
        if (dataType.types[this.dialectName]) {
          this._refreshTypeParser(dataType);
        } else {
          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);
        }
      }
    });
  }

  /**
   * Try to load dialect module from various configured options.
   * Priority goes like dialectModulePath > dialectModule > require(default)
   *
   * @param {string} moduleName Name of dialect module to lookup
   *
   * @private
   * @returns {object}
   */
  _loadDialectModule(moduleName) {
    try {
      if (this.sequelize.config.dialectModulePath) {
        return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(this.sequelize.config.dialectModulePath);
      }
      if (this.sequelize.config.dialectModule) {
        return this.sequelize.config.dialectModule;
      }
      return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(moduleName);

    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        if (this.sequelize.config.dialectModulePath) {
          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);
        }
        throw new Error(`Please install ${moduleName} package manually`);
      }

      throw err;
    }
  }

  /**
   * Handler which executes on process exit or connection manager shutdown
   *
   * @private
   * @returns {Promise}
   */
  async _onProcessExit() {
    if (!this.pool) {
      return;
    }

    await this.pool.drain();
    debug('connection drain due to process exit');

    return await this.pool.destroyAllNow();
  }

  /**
   * Drain the pool and close it permanently
   *
   * @returns {Promise}
   */
  async close() {
    // Mark close of pool
    this.getConnection = async function getConnection() {
      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');
    };

    return await this._onProcessExit();
  }

  /**
   * Initialize connection pool. By default pool autostart is set to false, so no connection will be
   * be created unless `pool.acquire` is called.
   */
  initPools() {
    const config = this.config;

    if (!config.replication) {
      this.pool = new Pool({
        name: 'sequelize',
        create: () => this._connect(config),
        destroy: async connection => {
          const result = await this._disconnect(connection);
          debug('connection destroy');
          return result;
        },
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      });

      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);

      return;
    }

    if (!Array.isArray(config.replication.read)) {
      config.replication.read = [config.replication.read];
    }

    // Map main connection config
    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));

    // Apply defaults to each read config
    config.replication.read = config.replication.read.map(readConfig =>
      _.defaults(readConfig, _.omit(this.config, 'replication'))
    );

    // custom pooling for replication (original author @janmeier)
    let reads = 0;
    this.pool = {
      release: client => {
        if (client.queryType === 'read') {
          this.pool.read.release(client);
        } else {
          this.pool.write.release(client);
        }
      },
      acquire: (queryType, useMaster) => {
        useMaster = useMaster === undefined ? false : useMaster;
        if (queryType === 'SELECT' && !useMaster) {
          return this.pool.read.acquire();
        }
        return this.pool.write.acquire();
      },
      destroy: connection => {
        this.pool[connection.queryType].destroy(connection);
        debug('connection destroy');
      },
      destroyAllNow: async () => {
        await Promise.all([
          this.pool.read.destroyAllNow(),
          this.pool.write.destroyAllNow()
        ]);

        debug('all connections destroyed');
      },
      drain: async () => Promise.all([
        this.pool.write.drain(),
        this.pool.read.drain()
      ]),
      read: new Pool({
        name: 'sequelize:read',
        create: async () => {
          // round robin config
          const nextRead = reads++ % config.replication.read.length;
          const connection = await this._connect(config.replication.read[nextRead]);
          connection.queryType = 'read';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      }),
      write: new Pool({
        name: 'sequelize:write',
        create: async () => {
          const connection = await this._connect(config.replication.write);
          connection.queryType = 'write';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      })
    };

    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);
  }

  /**
   * Get connection from pool. It sets database version if it's not already set.
   * Call pool.acquire to get a connection
   *
   * @param {object}   [options]                 Pool options
   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`
   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from
   *
   * @returns {Promise<Connection>}
   */
  async getConnection(options) {
    options = options || {};

    if (this.sequelize.options.databaseVersion === 0) {
      if (!this.versionPromise) {
        this.versionPromise = (async () => {
          try {
            const connection = await this._connect(this.config.replication.write || this.config);
            const _options = {};

            _options.transaction = { connection }; // Cheat .query to use our private connection
            _options.logging = () => {};
            _options.logging.__testLoggingFn = true;

            //connection might have set databaseVersion value at initialization,
            //avoiding a useless round trip
            if (this.sequelize.options.databaseVersion === 0) {
              const version = await this.sequelize.databaseVersion(_options);
              const parsedVersion = _.get(semver.coerce(version), 'version') || version;
              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)
                ? parsedVersion
                : this.dialect.defaultVersion;
            }

            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {
              deprecations.unsupportedEngine();
              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);
            }

            this.versionPromise = null;
            return await this._disconnect(connection);
          } catch (err) {
            this.versionPromise = null;
            throw err;
          }
        })();
      }
      await this.versionPromise;
    }

    let result;

    try {
      result = await this.pool.acquire(options.type, options.useMaster);
    } catch (error) {
      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);
      throw error;
    }

    debug('connection acquired');

    return result;
  }

  /**
   * Release a pooled connection so it can be utilized by other connection requests
   *
   * @param {Connection} connection
   *
   * @returns {Promise}
   */
  async releaseConnection(connection) {
    this.pool.release(connection);
    debug('connection released');
  }

  /**
   * Call dialect library to get connection
   *
   * @param {*} config Connection config
   * @private
   * @returns {Promise<Connection>}
   */
  async _connect(config) {
    await this.sequelize.runHooks('beforeConnect', config);
    const connection = await this.dialect.connectionManager.connect(config);
    await this.sequelize.runHooks('afterConnect', connection, config);
    return connection;
  }

  /**
   * Call dialect library to disconnect a connection
   *
   * @param {Connection} connection
   * @private
   * @returns {Promise}
   */
  async _disconnect(connection) {
    await this.sequelize.runHooks('beforeDisconnect', connection);
    await this.dialect.connectionManager.disconnect(connection);
    return this.sequelize.runHooks('afterDisconnect', connection);
  }

  /**
   * Determine if a connection is still valid or not
   *
   * @param {Connection} connection
   *
   * @returns {boolean}
   */
  _validate(connection) {
    if (!this.dialect.connectionManager.validate) {
      return true;
    }

    return this.dialect.connectionManager.validate(connection);
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class AbstractDialect {}

AbstractDialect.prototype.supports = {
  'DEFAULT': true,
  'DEFAULT VALUES': false,
  'VALUES ()': false,
  'LIMIT ON UPDATE': false,
  'ORDER NULLS': false,
  'UNION': true,
  'UNION ALL': true,
  'RIGHT JOIN': true,

  /* does the dialect support returning values for inserted/updated fields */
  returnValues: false,

  /* features specific to autoIncrement values */
  autoIncrement: {
    /* does the dialect require modification of insert queries when inserting auto increment fields */
    identityInsert: false,

    /* does the dialect support inserting default/null values for autoincrement fields */
    defaultValue: true,

    /* does the dialect support updating autoincrement fields */
    update: true
  },
  /* Do we need to say DEFAULT for bulk insert */
  bulkDefault: false,
  schemas: false,
  transactions: true,
  settingIsolationLevelDuringTransaction: true,
  transactionOptions: {
    type: false
  },
  migrations: true,
  upserts: true,
  inserts: {
    ignoreDuplicates: '', /* dialect specific words for INSERT IGNORE or DO NOTHING */
    updateOnDuplicate: false, /* whether dialect supports ON DUPLICATE KEY UPDATE */
    onConflictDoNothing: '' /* dialect specific words for ON CONFLICT DO NOTHING */
  },
  constraints: {
    restrict: true,
    addConstraint: true,
    dropConstraint: true,
    unique: true,
    default: false,
    check: true,
    foreignKey: true,
    primaryKey: true
  },
  index: {
    collate: true,
    length: false,
    parser: false,
    concurrently: false,
    type: false,
    using: true,
    functionBased: false,
    operator: false
  },
  joinTableDependent: true,
  groupedLimit: true,
  indexViaAlter: false,
  JSON: false,
  deferrableConstraints: false
};

module.exports = AbstractDialect;
module.exports.AbstractDialect = AbstractDialect;
module.exports.default = AbstractDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Model = __webpack_require__(/*! ../../model */ "./node_modules/sequelize/lib/model.js");
const Association = __webpack_require__(/*! ../../associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const HasMany = __webpack_require__(/*! ../../associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const sequelizeError = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const IndexHints = __webpack_require__(/*! ../../index-hints */ "./node_modules/sequelize/lib/index-hints.js");

const QuoteHelper = __webpack_require__(/*! ./query-generator/helpers/quote */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js");

/**
 * Abstract Query Generator
 *
 * @private
 */
class QueryGenerator {
  constructor(options) {
    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');
    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');

    this.sequelize = options.sequelize;
    this.options = options.sequelize.options;

    // dialect name
    this.dialect = options._dialect.name;
    this._dialect = options._dialect;
  }

  extractTableDetails(tableName, options) {
    options = options || {};
    tableName = tableName || {};
    return {
      schema: tableName.schema || options.schema || 'public',
      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
      delimiter: tableName.delimiter || options.delimiter || '.'
    };
  }

  addSchema(param) {
    if (!param._schema) return param.tableName || param;
    const self = this;
    return {
      tableName: param.tableName || param,
      table: param.tableName || param,
      name: param.name || param,
      schema: param._schema,
      delimiter: param._schemaDelimiter || '.',
      toString() {
        return self.quoteTable(this);
      }
    };
  }

  dropSchema(tableName, options) {
    return this.dropTableQuery(tableName, options);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `DESCRIBE ${table};`;
  }

  dropTableQuery(tableName) {
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;
  }

  renameTableQuery(before, after) {
    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;
  }

  /**
   * Returns an insert into command
   *
   * @param {string} table
   * @param {object} valueHash       attribute value pairs
   * @param {object} modelAttributes
   * @param {object} [options]
   *
   * @private
   */
  insertQuery(table, valueHash, modelAttributes, options) {
    options = options || {};
    _.defaults(options, this.options);

    const modelAttributeMap = {};
    const bind = [];
    const fields = [];
    const returningModelAttributes = [];
    const values = [];
    const quotedTable = this.quoteTable(table);
    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;
    let query;
    let valueQuery = '';
    let emptyQuery = '';
    let outputFragment = '';
    let returningFragment = '';
    let identityWrapperRequired = false;
    let tmpTable = ''; //tmpTable declaration for trigger

    if (modelAttributes) {
      _.each(modelAttributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    if (this._dialect.supports['DEFAULT VALUES']) {
      emptyQuery += ' DEFAULT VALUES';
    } else if (this._dialect.supports['VALUES ()']) {
      emptyQuery += ' VALUES ()';
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(modelAttributes, options);

      returningModelAttributes.push(...returnValues.returnFields);
      returningFragment = returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';
    }

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    if (this._dialect.supports.EXCEPTION && options.exception) {
      // Not currently supported with bind parameters (requires output of multiple queries)
      options.bindParam = false;
    }

    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
    for (const key in valueHash) {
      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {
        const value = valueHash[key];
        fields.push(this.quoteIdentifier(key));

        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {
          if (!this._dialect.supports.autoIncrement.defaultValue) {
            fields.splice(-1, 1);
          } else if (this._dialect.supports.DEFAULT) {
            values.push('DEFAULT');
          } else {
            values.push(this.escape(null));
          }
        } else {
          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
            identityWrapperRequired = true;
          }

          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));
          } else {
            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));
          }
        }
      }
    }

    let onDuplicateKeyUpdate = '';

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else {
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const replacements = {
      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',
      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',
      attributes: fields.join(','),
      output: outputFragment,
      values: values.join(','),
      tmpTable
    };

    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;
    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;

    // Mostly for internal use, so we expect the user to know what he's doing!
    // pg_temp functions are private per connection, so we never risk this function interfering with another one.
    if (this._dialect.supports.EXCEPTION && options.exception) {
      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';

      if (returningModelAttributes.length === 0) {
        returningModelAttributes.push('*');
      }

      const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;
      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;

      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';
      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;
    } else {
      valueQuery += returningFragment;
      emptyQuery += returningFragment;
    }

    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;
    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;
    }

    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }

    return result;
  }

  /**
   * Returns an insert into command for multiple values.
   *
   * @param {string} tableName
   * @param {object} fieldValueHashes
   * @param {object} options
   * @param {object} fieldMappedAttributes
   *
   * @private
   */
  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
    options = options || {};
    fieldMappedAttributes = fieldMappedAttributes || {};

    const tuples = [];
    const serials = {};
    const allAttributes = [];
    let onDuplicateKeyUpdate = '';

    for (const fieldValueHash of fieldValueHashes) {
      _.forOwn(fieldValueHash, (value, key) => {
        if (!allAttributes.includes(key)) {
          allAttributes.push(key);
        }
        if (
          fieldMappedAttributes[key]
          && fieldMappedAttributes[key].autoIncrement === true
        ) {
          serials[key] = true;
        }
      });
    }

    for (const fieldValueHash of fieldValueHashes) {
      const values = allAttributes.map(key => {
        if (
          this._dialect.supports.bulkDefault
          && serials[key] === true
        ) {
          return fieldValueHash[key] || 'DEFAULT';
        }

        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });
      });

      tuples.push(`(${values.join(',')})`);
    }

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else { // mysql / maria
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';
    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';
    let returning = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);

      returning += returnValues.returningFragment;
    }

    return Utils.joinSQLFragments([
      'INSERT',
      ignoreDuplicates,
      'INTO',
      this.quoteTable(tableName),
      `(${attributes})`,
      'VALUES',
      tuples.join(','),
      onDuplicateKeyUpdate,
      onConflictDoNothing,
      returning,
      ';'
    ]);
  }

  /**
   * Returns an update query
   *
   * @param {string} tableName
   * @param {object} attrValueHash
   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} options
   * @param {object} attributes
   *
   * @private
   */
  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const values = [];
    const bind = [];
    const modelAttributeMap = {};
    let outputFragment = '';
    let tmpTable = ''; // tmpTable declaration for trigger
    let suffix = '';

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;

    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {
      if (this.dialect !== 'mssql') {
        suffix = ` LIMIT ${this.escape(options.limit)} `;
      }
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      suffix += returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';

      // ensure that the return output is properly mapped to model fields.
      if (!this._dialect.supports.returnValues.output && options.returning) {
        options.mapToModel = true;
      }
    }

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      if (modelAttributeMap && modelAttributeMap[key] &&
        modelAttributeMap[key].autoIncrement === true &&
        !this._dialect.supports.autoIncrement.update) {
        // not allowed to update identity column
        continue;
      }

      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    const whereOptions = { ...options, bindParam };

    if (values.length === 0) {
      return '';
    }

    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();
    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }
    return result;
  }

  /**
   * Returns an update query using arithmetic operator
   *
   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')
   * @param {string} tableName                   Name of the table
   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs
   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs
   * @param {object} options
   *
   * @private
   */
  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = options || {};
    _.defaults(options, { returning: true });

    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);

    let outputFragment = '';
    let returningFragment = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(null, options);

      outputFragment = returnValues.outputFragment;
      returningFragment = returnValues.returningFragment;
    }

    const updateSetSqlFragments = [];
    for (const field in incrementAmountsByField) {
      const incrementAmount = incrementAmountsByField[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedAmount = this.escape(incrementAmount);
      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);
    }
    for (const field in extraAttributesToBeUpdated) {
      const newValue = extraAttributesToBeUpdated[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedValue = this.escape(newValue);
      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);
    }

    return Utils.joinSQLFragments([
      'UPDATE',
      this.quoteTable(tableName),
      'SET',
      updateSetSqlFragments.join(','),
      outputFragment,
      this.whereQuery(where),
      returningFragment
    ]);
  }

  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
        - using
        - operator
        - concurrently: Pass CONCURRENT so other operations run while the index is created
      - rawTablename, the name of the table, without schema. Used to create the name of the index
   @private
  */
  addIndexQuery(tableName, attributes, options, rawTablename) {
    options = options || {};

    if (!Array.isArray(attributes)) {
      options = attributes;
      attributes = undefined;
    } else {
      options.fields = attributes;
    }

    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && typeof options.prefix === 'string') {
      options.prefix = options.prefix.replace(/\./g, '_');
      options.prefix = options.prefix.replace(/("|')/g, '');
    }

    const fieldsSql = options.fields.map(field => {
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (typeof field === 'string') {
        field = {
          name: field
        };
      }
      let result = '';

      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${util.inspect(field)}`);
      }

      result += this.quoteIdentifier(field.name);

      if (this._dialect.supports.index.collate && field.collate) {
        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;
      }

      if (this._dialect.supports.index.operator) {
        const operator = field.operator || options.operator;
        if (operator) {
          result += ` ${operator}`;
        }
      }

      if (this._dialect.supports.index.length && field.length) {
        result += `(${field.length})`;
      }

      if (field.order) {
        result += ` ${field.order}`;
      }

      return result;
    });

    if (!options.name) {
      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)
      // All calls that go through sequelize should already have a name
      options = Utils.nameIndex(options, options.prefix);
    }

    options = Model._conformIndex(options);

    if (!this._dialect.supports.index.type) {
      delete options.type;
    }

    if (options.where) {
      options.where = this.whereQuery(options.where);
    }

    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;
    let ind;
    if (this._dialect.supports.indexViaAlter) {
      ind = [
        'ALTER TABLE',
        tableName,
        concurrently,
        'ADD'
      ];
    } else {
      ind = ['CREATE'];
    }

    ind = ind.concat(
      options.unique ? 'UNIQUE' : '',
      options.type, 'INDEX',
      !this._dialect.supports.indexViaAlter ? concurrently : undefined,
      this.quoteIdentifiers(options.name),
      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',
      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,
      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',
      `(${fieldsSql.join(', ')})`,
      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,
      this._dialect.supports.index.where && options.where ? options.where : undefined
    );

    return _.compact(ind).join(' ');
  }

  addConstraintQuery(tableName, options) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'ADD',
      this.getConstraintSnippet(tableName, options || {}),
      ';'
    ]);
  }

  getConstraintSnippet(tableName, options) {
    let constraintSnippet, constraintName;

    const fieldsSql = options.fields.map(field => {
      if (typeof field === 'string') {
        return this.quoteIdentifier(field);
      }
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${field}`);
      }

      return this.quoteIdentifier(field.name);
    });

    const fieldsSqlQuotedString = fieldsSql.join(', ');
    const fieldsSqlString = fieldsSql.join('_');

    switch (options.type.toUpperCase()) {
      case 'UNIQUE':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);
        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;
        break;
      case 'CHECK':
        options.where = this.whereItemsQuery(options.where);
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);
        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;
        break;
      case 'DEFAULT':
        if (options.defaultValue === undefined) {
          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');
        }

        if (this._dialect.name !== 'mssql') {
          throw new Error('Default constraints are supported only for MSSQL dialect.');
        }

        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);
        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;
        break;
      case 'PRIMARY KEY':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);
        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;
        break;
      case 'FOREIGN KEY':
        const references = options.references;
        if (!references || !references.table || !(references.field || references.fields)) {
          throw new Error('references object with table and field must be specified');
        }
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);
        const quotedReferences =
          typeof references.field !== 'undefined'
            ? this.quoteIdentifier(references.field)
            : references.fields.map(f => this.quoteIdentifier(f)).join(', ');
        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;
        constraintSnippet = `CONSTRAINT ${constraintName} `;
        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;
        if (options.onUpdate) {
          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;
        }
        if (options.onDelete) {
          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;
        }
        break;
      default: throw new Error(`${options.type} is invalid.`);
    }

    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {
      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;
    }

    return constraintSnippet;
  }

  removeConstraintQuery(tableName, constraintName) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'DROP CONSTRAINT',
      this.quoteIdentifiers(constraintName)
    ]);
  }

  /*
    Quote an object based on its type. This is a more general version of quoteIdentifiers
    Strings: should proxy to quoteIdentifiers
    Arrays:
      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]
        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an
        association object, or the name of an association.
      * Zero or more models can be included in the array and are used to trace a path through the tree of
        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL
        and quotes it.
      * If a single string is appended to end of array, it is quoted.
        If two strings appended, the 1st string is quoted, the 2nd string unquoted.
    Objects:
      * If raw is set, that value should be returned verbatim, without quoting
      * If fn is set, the string should start with the value of fn, starting paren, followed by
        the values of cols (which is assumed to be an array), quoted and joined with ', ',
        unless they are themselves objects
      * If direction is set, should be prepended

    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could
    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)
   @private
  */
  quote(collection, parent, connector) {
    // init
    const validOrderOptions = [
      'ASC',
      'DESC',
      'ASC NULLS LAST',
      'DESC NULLS LAST',
      'ASC NULLS FIRST',
      'DESC NULLS FIRST',
      'NULLS FIRST',
      'NULLS LAST'
    ];

    // default
    connector = connector || '.';

    // just quote as identifiers if string
    if (typeof collection === 'string') {
      return this.quoteIdentifiers(collection);
    }
    if (Array.isArray(collection)) {
      // iterate through the collection and mutate objects into associations
      collection.forEach((item, index) => {
        const previous = collection[index - 1];
        let previousAssociation;
        let previousModel;

        // set the previous as the parent when previous is undefined or the target of the association
        if (!previous && parent !== undefined) {
          previousModel = parent;
        } else if (previous && previous instanceof Association) {
          previousAssociation = previous;
          previousModel = previous.target;
        }

        // if the previous item is a model, then attempt getting an association
        if (previousModel && previousModel.prototype instanceof Model) {
          let model;
          let as;

          if (typeof item === 'function' && item.prototype instanceof Model) {
            // set
            model = item;
          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {
            // set
            model = item.model;
            as = item.as;
          }

          if (model) {
            // set the as to either the through name or the model name
            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {
              // get from previous association
              item = new Association(previousModel, model, {
                as: model.name
              });
            } else {
              // get association from previous model
              item = previousModel.getAssociationForAlias(model, as);

              // attempt to use the model name if the item is still null
              if (!item) {
                item = previousModel.getAssociationForAlias(model, model.name);
              }
            }

            // make sure we have an association
            if (!(item instanceof Association)) {
              throw new Error(util.format('Unable to find a valid association for model, \'%s\'', model.name));
            }
          }
        }

        if (typeof item === 'string') {
          // get order index
          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());

          // see if this is an order
          if (index > 0 && orderIndex !== -1) {
            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);
          } else if (previousModel && previousModel.prototype instanceof Model) {
            // only go down this path if we have preivous model and check only once
            if (previousModel.associations !== undefined && previousModel.associations[item]) {
              // convert the item to an association
              item = previousModel.associations[item];
            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {
              // convert the item attribute from its alias
              item = previousModel.rawAttributes[item].field;
            } else if (
              item.includes('.')
              && previousModel.rawAttributes !== undefined
            ) {
              const itemSplit = item.split('.');

              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {
                // just quote identifiers for now
                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);

                // get path
                const path = itemSplit.slice(1);

                // extract path
                item = this.jsonPathExtractionQuery(identifier, path);

                // literal because we don't want to append the model name when string
                item = this.sequelize.literal(item);
              }
            }
          }
        }

        collection[index] = item;
      }, this);

      // loop through array, adding table names of models to quoted
      const collectionLength = collection.length;
      const tableNames = [];
      let item;
      let i = 0;

      for (i = 0; i < collectionLength - 1; i++) {
        item = collection[i];
        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {
          break;
        } else if (item instanceof Association) {
          tableNames[i] = item.as;
        }
      }

      // start building sql
      let sql = '';

      if (i > 0) {
        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;
      } else if (typeof collection[0] === 'string' && parent) {
        sql += `${this.quoteIdentifier(parent.name)}.`;
      }

      // loop through everything past i and append to the sql
      collection.slice(i).forEach(collectionItem => {
        sql += this.quote(collectionItem, parent, connector);
      }, this);

      return sql;
    }
    if (collection._modelAttribute) {
      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;
    }
    if (collection instanceof Utils.SequelizeMethod) {
      return this.handleSequelizeMethod(collection);
    }
    if (_.isPlainObject(collection) && collection.raw) {
      // simple objects with raw is no longer supported
      throw new Error('The `{raw: "..."}` syntax is no longer supported.  Use `sequelize.literal` instead.');
    }
    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);
  }

  /**
   * Split a list of identifiers by "." and quote each part
   *
   * @param {string} identifier
   * @param {boolean} force
   *
   * @returns {string}
   */
  quoteIdentifier(identifier, force) {
    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {
      force,
      quoteIdentifiers: this.options.quoteIdentifiers
    });
  }

  quoteIdentifiers(identifiers) {
    if (identifiers.includes('.')) {
      identifiers = identifiers.split('.');

      const head = identifiers.slice(0, identifiers.length - 1).join('->');
      const tail = identifiers[identifiers.length - 1];

      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;
    }

    return this.quoteIdentifier(identifiers);
  }

  quoteAttribute(attribute, model) {
    if (model && attribute in model.rawAttributes) {
      return this.quoteIdentifier(attribute);
    }
    return this.quoteIdentifiers(attribute);
  }

  /**
   * Quote table name with optional alias and schema attribution
   *
   * @param {string|object}  param table string or object
   * @param {string|boolean} alias alias name
   *
   * @returns {string}
   */
  quoteTable(param, alias) {
    let table = '';

    if (alias === true) {
      alias = param.as || param.name || param;
    }

    if (_.isObject(param)) {
      if (this._dialect.supports.schemas) {
        if (param.schema) {
          table += `${this.quoteIdentifier(param.schema)}.`;
        }

        table += this.quoteIdentifier(param.tableName);
      } else {
        if (param.schema) {
          table += param.schema + (param.delimiter || '.');
        }

        table += param.tableName;
        table = this.quoteIdentifier(table);
      }
    } else {
      table = this.quoteIdentifier(param);
    }

    if (alias) {
      table += ` AS ${this.quoteIdentifier(alias)}`;
    }

    return table;
  }

  /*
    Escape a value (e.g. a string, number or date)
    @private
  */
  escape(value, field, options) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(value);
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.stringify) {
          // Users shouldn't have to worry about these args - just give them a function that takes a single arg
          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);

          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });

          if (field.type.escape === false) {
            // The data-type already did the required escaping
            return value;
          }
        }
      }
    }
    return SqlString.escape(value, this.options.timezone, this.dialect);
  }

  bindParam(bind) {
    return value => {
      bind.push(value);
      return `$${bind.length}`;
    };
  }

  /*
    Returns a bind parameter representation of a value (e.g. a string, number or date)
    @private
  */
  format(value, field, options, bindParam) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.bindParam) {
          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });
        }
      }
    }

    return bindParam(value);
  }

  /*
    Validate a value against a field specification
    @private
  */
  validate(value, field, options) {
    if (this.typeValidation && field.type.validate && value) {
      try {
        if (options.isList && Array.isArray(value)) {
          for (const item of value) {
            field.type.validate(item, options);
          }
        } else {
          field.type.validate(value, options);
        }
      } catch (error) {
        if (error instanceof sequelizeError.ValidationError) {
          error.errors.push(new sequelizeError.ValidationErrorItem(
            error.message,
            'Validation error',
            field.fieldName,
            value,
            null,
            `${field.type.key} validator`
          ));
        }

        throw error;
      }
    }
  }

  isIdentifierQuoted(identifier) {
    return QuoteHelper.isIdentifierQuoted(identifier);
  }

  /**
   * Generates an SQL query that extract JSON property of given path.
   *
   * @param   {string}               column  The JSON column
   * @param   {string|Array<string>} [path]  The path to extract (optional)
   * @returns {string}                       The generated sql query
   * @private
   */
  jsonPathExtractionQuery(column, path) {
    let paths = _.toPath(path);
    let pathStr;
    const quotedColumn = this.isIdentifierQuoted(column)
      ? column
      : this.quoteIdentifier(column);

    switch (this.dialect) {
      case 'mysql':
      case 'mariadb':
      case 'sqlite':
        /**
         * Non digit sub paths need to be quoted as ECMAScript identifiers
         * https://bugs.mysql.com/bug.php?id=81896
         */
        if (this.dialect === 'mysql') {
          paths = paths.map(subPath => {
            return /\D/.test(subPath)
              ? Utils.addTicks(subPath, '"')
              : subPath;
          });
        }

        pathStr = this.escape(['$']
          .concat(paths)
          .join('.')
          .replace(/\.(\d+)(?:(?=\.)|$)/g, (__, digit) => `[${digit}]`));

        if (this.dialect === 'sqlite') {
          return `json_extract(${quotedColumn},${pathStr})`;
        }

        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;

      case 'postgres':
        pathStr = this.escape(`{${paths.join(',')}}`);
        return `(${quotedColumn}#>>${pathStr})`;

      default:
        throw new Error(`Unsupported ${this.dialect} for JSON operations`);
    }
  }

  /*
    Returns a query for selecting elements in the table <tableName>.
    Options:
      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
      - order -> e.g. 'id DESC'
      - group
      - limit -> The maximum count you want to get.
      - offset -> An offset value to start from. Only useable with limit!
   @private
  */
  selectQuery(tableName, options, model) {
    options = options || {};
    const limit = options.limit;
    const mainQueryItems = [];
    const subQueryItems = [];
    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;
    const attributes = {
      main: options.attributes && options.attributes.slice(),
      subQuery: null
    };
    const mainTable = {
      name: tableName,
      quotedName: null,
      as: null,
      model
    };
    const topLevelInfo = {
      names: mainTable,
      options,
      subQuery
    };
    let mainJoinQueries = [];
    let subJoinQueries = [];
    let query;

    // Aliases can be passed through subqueries and we don't want to reset them
    if (this.options.minifyAliases && !options.aliasesMapping) {
      options.aliasesMapping = new Map();
      options.aliasesByTable = {};
      options.includeAliases = new Map();
    }

    // resolve table name options
    if (options.tableAs) {
      mainTable.as = this.quoteIdentifier(options.tableAs);
    } else if (!Array.isArray(mainTable.name) && mainTable.model) {
      mainTable.as = this.quoteIdentifier(mainTable.model.name);
    }

    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {
      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);
    }).join(', ');

    if (subQuery && attributes.main) {
      for (const keyAtt of mainTable.model.primaryKeyAttributes) {
        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field
        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {
          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);
        }
      }
    }

    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);
    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);

    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery
    if (subQuery || options.groupedLimit) {
      // We need primary keys
      attributes.subQuery = attributes.main;
      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];
    }

    if (options.include) {
      for (const include of options.include) {
        if (include.separate) {
          continue;
        }
        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);

        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

        if (joinQueries.attributes.main.length > 0) {
          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));
        }
        if (joinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));
        }
      }
    }

    if (subQuery) {
      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));
      subQueryItems.push(subJoinQueries.join(''));
    } else {
      if (options.groupedLimit) {
        if (!mainTable.as) {
          mainTable.as = mainTable.quotedName;
        }
        const where = { ...options.where };
        let groupedLimitOrder,
          whereKey,
          include,
          groupedTableName = mainTable.as;

        if (typeof options.groupedLimit.on === 'string') {
          whereKey = options.groupedLimit.on;
        } else if (options.groupedLimit.on instanceof HasMany) {
          whereKey = options.groupedLimit.on.foreignKeyField;
        }

        if (options.groupedLimit.on instanceof BelongsToMany) {
          // BTM includes needs to join the through table on to check ID
          groupedTableName = options.groupedLimit.on.manyFromSource.as;
          const groupedLimitOptions = Model._validateIncludedElements({
            include: [{
              association: options.groupedLimit.on.manyFromSource,
              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot
              required: true,
              where: {
                [Op.placeholder]: true,
                ...options.groupedLimit.through && options.groupedLimit.through.where
              }
            }],
            model
          });

          // Make sure attributes from the join table are mapped back to models
          options.hasJoin = true;
          options.hasMultiAssociation = true;
          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);
          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
          include = groupedLimitOptions.include;

          if (Array.isArray(options.order)) {
            // We need to make sure the order by attributes are available to the parent query
            options.order.forEach((order, i) => {
              if (Array.isArray(order)) {
                order = order[0];
              }

              let alias = `subquery_order_${i}`;
              options.attributes.push([order, alias]);

              // We don't want to prepend model name when we alias the attributes, so quote them here
              alias = this.sequelize.literal(this.quote(alias));

              if (Array.isArray(options.order[i])) {
                options.order[i][0] = alias;
              } else {
                options.order[i] = alias;
              }
            });
            groupedLimitOrder = options.order;
          }
        } else {
          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed
          groupedLimitOrder = options.order;
          delete options.order;
          where[Op.placeholder] = true;
        }

        // Caching the base query and splicing the where part into it is consistently > twice
        // as fast than generating from scratch each time for values.length >= 5
        const baseQuery = `SELECT * FROM (${this.selectQuery(
          tableName,
          {
            attributes: options.attributes,
            offset: options.offset,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            aliasesMapping: options.aliasesMapping,
            aliasesByTable: options.aliasesByTable,
            where,
            include,
            model
          },
          model
        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias
        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });
        const splicePos = baseQuery.indexOf(placeHolder);

        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${
          options.groupedLimit.values.map(value => {
            let groupWhere;
            if (whereKey) {
              groupWhere = {
                [whereKey]: value
              };
            }
            if (include) {
              groupWhere = {
                [options.groupedLimit.on.foreignIdentifierField]: value
              };
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
          }).join(
            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '
          )
        })`, mainTable.as));
      } else {
        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));
      }

      mainQueryItems.push(mainJoinQueries.join(''));
    }

    // Add WHERE to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {
      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);
      if (options.where) {
        if (subQuery) {
          subQueryItems.push(` WHERE ${options.where}`);
        } else {
          mainQueryItems.push(` WHERE ${options.where}`);
          // Walk the main query to update all selects
          mainQueryItems.forEach((value, key) => {
            if (value.startsWith('SELECT')) {
              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);
            }
          });
        }
      }
    }

    // Add GROUP BY to sub or main query
    if (options.group) {
      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);

      if (subQuery && options.group) {
        subQueryItems.push(` GROUP BY ${options.group}`);
      } else if (options.group) {
        mainQueryItems.push(` GROUP BY ${options.group}`);
      }
    }

    // Add HAVING to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'having')) {
      options.having = this.getWhereConditions(options.having, tableName, model, options, false);
      if (options.having) {
        if (subQuery) {
          subQueryItems.push(` HAVING ${options.having}`);
        } else {
          mainQueryItems.push(` HAVING ${options.having}`);
        }
      }
    }

    // Add ORDER to sub or main query
    if (options.order) {
      const orders = this.getQueryOrders(options, model, subQuery);
      if (orders.mainQueryOrder.length) {
        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);
      }
      if (orders.subQueryOrder.length) {
        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);
      }
    }

    // Add LIMIT, OFFSET to sub or main query
    const limitOrder = this.addLimitAndOffset(options, mainTable.model);
    if (limitOrder && !options.groupedLimit) {
      if (subQuery) {
        subQueryItems.push(limitOrder);
      } else {
        mainQueryItems.push(limitOrder);
      }
    }

    if (subQuery) {
      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });
      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;
    } else {
      query = mainQueryItems.join('');
    }

    if (options.lock && this._dialect.supports.lock) {
      let lock = options.lock;
      if (typeof options.lock === 'object') {
        lock = options.lock.level;
      }
      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {
        query += ` FOR ${lock}`;
      } else if (lock === 'SHARE') {
        query += ` ${this._dialect.supports.forShare}`;
      } else {
        query += ' FOR UPDATE';
      }
      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {
        query += ` OF ${this.quoteTable(options.lock.of.name)}`;
      }
      if (this._dialect.supports.skipLocked && options.skipLocked) {
        query += ' SKIP LOCKED';
      }
    }

    return `${query};`;
  }

  aliasGrouping(field, model, tableName, options) {
    const src = Array.isArray(field) ? field[0] : field;

    return this.quote(this._getAliasForField(tableName, src, options) || src, model);
  }

  escapeAttributes(attributes, options, mainTableAs) {
    return attributes && attributes.map(attr => {
      let addTable = true;

      if (attr instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(attr);
      }
      if (Array.isArray(attr)) {
        if (attr.length !== 2) {
          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);
        }
        attr = attr.slice();

        if (attr[0] instanceof Utils.SequelizeMethod) {
          attr[0] = this.handleSequelizeMethod(attr[0]);
          addTable = false;
        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {
          attr[0] = this.quoteIdentifier(attr[0]);
        } else {
          deprecations.noRawAttributes();
        }
        let alias = attr[1];

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, mainTableAs, options);
        }

        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');
      } else {
        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('"')
          ? this.quoteAttribute(attr, options.model)
          : this.escape(attr);
      }
      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {
        attr = `${mainTableAs}.${attr}`;
      }

      return attr;
    });
  }

  generateInclude(include, parentTableName, topLevelInfo) {
    const joinQueries = {
      mainQuery: [],
      subQuery: []
    };
    const mainChildIncludes = [];
    const subChildIncludes = [];
    let requiredMismatch = false;
    const includeAs = {
      internalAs: include.as,
      externalAs: include.as
    };
    const attributes = {
      main: [],
      subQuery: []
    };
    let joinQuery;

    topLevelInfo.options.keysEscaped = true;

    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {
      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;
      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;
    }

    // includeIgnoreAttributes is used by aggregate functions
    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      include.model._expandAttributes(include);
      Utils.mapFinderOptions(include, include.model);

      const includeAttributes = include.attributes.map(attr => {
        let attrAs = attr;
        let verbatim = false;

        if (Array.isArray(attr) && attr.length === 2) {
          if (attr[0] instanceof Utils.SequelizeMethod && (
            attr[0] instanceof Utils.Literal ||
            attr[0] instanceof Utils.Cast ||
            attr[0] instanceof Utils.Fn
          )) {
            verbatim = true;
          }

          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);

          attrAs = attr[1];
          attr = attr[0];
        }
        if (attr instanceof Utils.Literal) {
          return attr.val; // We trust the user to rename the field correctly
        }
        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {
          throw new Error(
            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +
            'This means the attribute will not be added to the returned instance'
          );
        }

        let prefix;
        if (verbatim === true) {
          prefix = attr;
        } else if (/#>>|->>/.test(attr)) {
          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\(|\)/g, '')})`;
        } else if (/json_extract\(/.test(attr)) {
          prefix = attr.replace(/json_extract\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);
        } else {
          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;
        }
        let alias = `${includeAs.externalAs}.${attrAs}`;

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);
        }

        return Utils.joinSQLFragments([
          prefix,
          'AS',
          this.quoteIdentifier(alias, true)
        ]);
      });
      if (include.subQuery && topLevelInfo.subQuery) {
        for (const attr of includeAttributes) {
          attributes.subQuery.push(attr);
        }
      } else {
        for (const attr of includeAttributes) {
          attributes.main.push(attr);
        }
      }
    }

    //through
    if (include.through) {
      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);
    } else {
      this._generateSubQueryFilter(include, includeAs, topLevelInfo);
      joinQuery = this.generateJoin(include, topLevelInfo);
    }

    // handle possible new attributes created in join
    if (joinQuery.attributes.main.length > 0) {
      attributes.main = attributes.main.concat(joinQuery.attributes.main);
    }

    if (joinQuery.attributes.subQuery.length > 0) {
      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);
    }

    if (include.include) {
      for (const childInclude of include.include) {
        if (childInclude.separate || childInclude._pseudo) {
          continue;
        }

        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);

        if (include.required === false && childInclude.required === true) {
          requiredMismatch = true;
        }
        // if the child is a sub query we just give it to the
        if (childInclude.subQuery && topLevelInfo.subQuery) {
          subChildIncludes.push(childJoinQueries.subQuery);
        }
        if (childJoinQueries.mainQuery) {
          mainChildIncludes.push(childJoinQueries.mainQuery);
        }
        if (childJoinQueries.attributes.main.length > 0) {
          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);
        }
        if (childJoinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);
        }
      }
    }

    if (include.subQuery && topLevelInfo.subQuery) {
      if (requiredMismatch && subChildIncludes.length > 0) {
        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (subChildIncludes.length > 0) {
          joinQueries.subQuery.push(subChildIncludes.join(''));
        }
      }
      joinQueries.mainQuery.push(mainChildIncludes.join(''));
    } else {
      if (requiredMismatch && mainChildIncludes.length > 0) {
        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (mainChildIncludes.length > 0) {
          joinQueries.mainQuery.push(mainChildIncludes.join(''));
        }
      }
      joinQueries.subQuery.push(subChildIncludes.join(''));
    }

    return {
      mainQuery: joinQueries.mainQuery.join(''),
      subQuery: joinQueries.subQuery.join(''),
      attributes
    };
  }

  _getMinifiedAlias(alias, tableName, options) {
    // We do not want to re-alias in case of a subquery
    if (options.aliasesByTable[`${tableName}${alias}`]) {
      return options.aliasesByTable[`${tableName}${alias}`];
    }

    // Do not alias custom suquery_orders
    if (alias.match(/subquery_order_[0-9]/)) {
      return alias;
    }

    const minifiedAlias = `_${options.aliasesMapping.size}`;

    options.aliasesMapping.set(minifiedAlias, alias);
    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;

    return minifiedAlias;
  }

  _getAliasForField(tableName, field, options) {
    if (this.options.minifyAliases) {
      if (options.aliasesByTable[`${tableName}${field}`]) {
        return options.aliasesByTable[`${tableName}${field}`];
      }
    }
    return null;
  }

  generateJoin(include, topLevelInfo) {
    const association = include.association;
    const parent = include.parent;
    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    let $parent;
    let joinWhere;
    /* Attributes for the left side */
    const left = association.source;
    const attrLeft = association instanceof BelongsTo ?
      association.identifier :
      association.sourceKeyAttribute || left.primaryKeyAttribute;
    const fieldLeft = association instanceof BelongsTo ?
      association.identifierField :
      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;
    let asLeft;
    /* Attributes for the right side */
    const right = include.model;
    const tableRight = right.getTableName();
    const fieldRight = association instanceof BelongsTo ?
      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :
      association.identifierField;
    let asRight = include.as;

    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {
      if (asLeft) {
        asLeft = `${$parent.as}->${asLeft}`;
      } else {
        asLeft = $parent.as;
      }
    }

    if (!asLeft) asLeft = parent.as || parent.model.name;
    else asRight = `${asLeft}->${asRight}`;

    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;
    const subqueryAttributes = [];

    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {
      if (parentIsTop) {
        // The main model attributes is not aliased to a prefix
        const tableName = this.quoteTable(parent.as || parent.model.name);

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;

        if (topLevelInfo.subQuery) {
          subqueryAttributes.push(`${tableName}.${this.quoteIdentifier(fieldLeft)}`);
        }
      } else {
        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);
      }
    }

    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;

    if (include.on) {
      joinOn = this.whereItemsQuery(include.on, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
    }

    if (include.where) {
      joinWhere = this.whereItemsQuery(include.where, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
      if (joinWhere) {
        if (include.or) {
          joinOn += ` OR ${joinWhere}`;
        } else {
          joinOn += ` AND ${joinWhere}`;
        }
      }
    }

    if (this.options.minifyAliases && asRight.length > 63) {
      const alias = `%${topLevelInfo.options.includeAliases.size}`;

      topLevelInfo.options.includeAliases.set(alias, asRight);
    }

    return {
      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',
      body: this.quoteTable(tableRight, asRight),
      condition: joinOn,
      attributes: {
        main: [],
        subQuery: subqueryAttributes
      }
    };
  }

  /**
   * Returns the SQL fragments to handle returning the attributes from an insert/update query.
   *
   * @param  {object} modelAttributes An object with the model attributes.
   * @param  {object} options         An object with options.
   *
   * @private
   */
  generateReturnValues(modelAttributes, options) {
    const returnFields = [];
    const returnTypes = [];
    let outputFragment = '';
    let returningFragment = '';
    let tmpTable = '';

    if (Array.isArray(options.returning)) {
      returnFields.push(...options.returning.map(field => this.quoteIdentifier(field)));
    } else if (modelAttributes) {
      _.each(modelAttributes, attribute => {
        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {
          returnFields.push(this.quoteIdentifier(attribute.field));
          returnTypes.push(attribute.type);
        }
      });
    }

    if (_.isEmpty(returnFields)) {
      returnFields.push('*');
    }

    if (this._dialect.supports.returnValues.returning) {
      returningFragment = ` RETURNING ${returnFields.join(',')}`;
    } else if (this._dialect.supports.returnValues.output) {
      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(',')}`;

      //To capture output rows when there is a trigger on MSSQL DB
      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);

        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;
        outputFragment += ' INTO @tmp';
        returningFragment = '; SELECT * FROM @tmp';
      }
    }

    return { outputFragment, returnFields, returningFragment, tmpTable };
  }

  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {
    const through = include.through;
    const throughTable = through.model.getTableName();
    const throughAs = `${includeAs.internalAs}->${through.as}`;
    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;
    const throughAttributes = through.attributes.map(attr => {
      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;

      if (this.options.minifyAliases) {
        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);
      }

      return Utils.joinSQLFragments([
        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,
        'AS',
        this.quoteIdentifier(alias)
      ]);
    });
    const association = include.association;
    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    const tableSource = parentTableName;
    const identSource = association.identifierField;
    const tableTarget = includeAs.internalAs;
    const identTarget = association.foreignIdentifierField;
    const attrTarget = association.targetKeyField;

    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';
    let joinBody;
    let joinCondition;
    const attributes = {
      main: [],
      subQuery: []
    };
    let attrSource = association.sourceKey;
    let sourceJoinOn;
    let targetJoinOn;
    let throughWhere;
    let targetWhere;

    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)
      for (const attr of throughAttributes) {
        attributes.main.push(attr);
      }
    }

    // Figure out if we need to use field or attribute
    if (!topLevelInfo.subQuery) {
      attrSource = association.sourceKeyField;
    }
    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {
      attrSource = association.sourceKeyField;
    }

    // Filter statement for left side of through
    // Used by both join and subquery where
    // If parent include was in a subquery need to join on the aliased attribute
    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;

      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;
    } else {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;

      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;
    }
    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;

    // Filter statement for right side of through
    // Used by both join and subquery where
    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;
    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;

    if (through.where) {
      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);
    }

    if (this._dialect.supports.joinTableDependent) {
      // Generate a wrapped join so that the through table join can be dependent on the target join
      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;
      if (throughWhere) {
        joinBody += ` AND ${throughWhere}`;
      }
      joinBody += ')';
      joinCondition = sourceJoinOn;
    } else {
      // Generate join SQL for left side of through
      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;
      joinCondition = targetJoinOn;
      if (throughWhere) {
        joinCondition += ` AND ${throughWhere}`;
      }
    }

    if (include.where || include.through.where) {
      if (include.where) {
        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);
        if (targetWhere) {
          joinCondition += ` AND ${targetWhere}`;
        }
      }
    }

    this._generateSubQueryFilter(include, includeAs, topLevelInfo);

    return {
      join: joinType,
      body: joinBody,
      condition: joinCondition,
      attributes
    };
  }

  /*
   * Generates subQueryFilter - a select nested in the where clause of the subQuery.
   * For a given include a query is generated that contains all the way from the subQuery
   * table to the include table plus everything that's in required transitive closure of the
   * given include.
   */
  _generateSubQueryFilter(include, includeAs, topLevelInfo) {
    if (!topLevelInfo.subQuery || !include.subQueryFilter) {
      return;
    }

    if (!topLevelInfo.options.where) {
      topLevelInfo.options.where = {};
    }
    let parent = include;
    let child = include;
    let nestedIncludes = this._getRequiredClosure(include).include;
    let query;

    while ((parent = parent.parent)) { // eslint-disable-line
      if (parent.parent && !parent.required) {
        return; // only generate subQueryFilter if all the parents of this include are required
      }

      if (parent.subQueryFilter) {
        // the include is already handled as this parent has the include on its required closure
        // skip to prevent duplicate subQueryFilter
        return;
      }

      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];
      child = parent;
    }

    const topInclude = nestedIncludes[0];
    const topParent = topInclude.parent;
    const topAssociation = topInclude.association;
    topInclude.association = undefined;

    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
      query = this.selectQuery(topInclude.through.model.getTableName(), {
        attributes: [topInclude.through.model.primaryKeyField],
        include: Model._validateIncludedElements({
          model: topInclude.through.model,
          include: [{
            association: topAssociation.toTarget,
            required: true,
            where: topInclude.where,
            include: topInclude.include
          }]
        }).include,
        model: topInclude.through.model,
        where: {
          [Op.and]: [
            this.sequelize.literal([
              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,
              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`
            ].join(' = ')),
            topInclude.through.where
          ]
        },
        limit: 1,
        includeIgnoreAttributes: false
      }, topInclude.through.model);
    } else {
      const isBelongsTo = topAssociation.associationType === 'BelongsTo';
      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;
      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;

      const join = [
        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,
        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`
      ].join(' = ');

      query = this.selectQuery(topInclude.model.getTableName(), {
        attributes: [targetField],
        include: Model._validateIncludedElements(topInclude).include,
        model: topInclude.model,
        where: {
          [Op.and]: [
            topInclude.where,
            { [Op.join]: this.sequelize.literal(join) }
          ]
        },
        limit: 1,
        tableAs: topInclude.as,
        includeIgnoreAttributes: false
      }, topInclude.model);
    }

    if (!topLevelInfo.options.where[Op.and]) {
      topLevelInfo.options.where[Op.and] = [];
    }

    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([
      '(',
      query.replace(/;$/, ''),
      ')',
      'IS NOT NULL'
    ].join(' '));
  }

  /*
   * For a given include hierarchy creates a copy of it where only the required includes
   * are preserved.
   */
  _getRequiredClosure(include) {
    const copy = { ...include, attributes: [], include: [] };

    if (Array.isArray(include.include)) {
      copy.include = include.include
        .filter(i => i.required)
        .map(inc => this._getRequiredClosure(inc));
    }

    return copy;
  }

  getQueryOrders(options, model, subQuery) {
    const mainQueryOrder = [];
    const subQueryOrder = [];

    if (Array.isArray(options.order)) {
      for (let order of options.order) {

        // wrap if not array
        if (!Array.isArray(order)) {
          order = [order];
        }

        if (
          subQuery
          && Array.isArray(order)
          && order[0]
          && !(order[0] instanceof Association)
          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)
          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)
          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])
        ) {
          subQueryOrder.push(this.quote(order, model, '->'));
        }

        if (subQuery) {
          // Handle case where sub-query renames attribute we want to order by,
          // see https://github.com/sequelize/sequelize/issues/8739
          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);
          if (subQueryAttribute) {
            const modelName = this.quoteIdentifier(model.name);

            order[0] = new Utils.Col(this._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);
          }
        }

        mainQueryOrder.push(this.quote(order, model, '->'));
      }
    } else if (options.order instanceof Utils.SequelizeMethod) {
      const sql = this.quote(options.order, model, '->');
      if (subQuery) {
        subQueryOrder.push(sql);
      }
      mainQueryOrder.push(sql);
    } else {
      throw new Error('Order must be type of array or instance of a valid sequelize method.');
    }

    return { mainQueryOrder, subQueryOrder };
  }

  _throwOnEmptyAttributes(attributes, extraInfo = {}) {
    if (attributes.length > 0) return;
    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';
    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';
    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;
    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;

    if (mainTableAs) {
      fragment += ` AS ${mainTableAs}`;
    }

    if (options.indexHints && this._dialect.supports.indexHints) {
      for (const hint of options.indexHints) {
        if (IndexHints[hint.type]) {
          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;
        }
      }
    }

    return fragment;
  }

  /**
   * Returns an SQL fragment for adding result constraints.
   *
   * @param  {object} options An object with selectQuery options.
   * @returns {string}         The generated sql query.
   * @private
   */
  addLimitAndOffset(options) {
    let fragment = '';

    /* eslint-disable */
    if (options.offset != null && options.limit == null) {
      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;
    } else if (options.limit != null) {
      if (options.offset != null) {
        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);
      } else {
        fragment += ' LIMIT ' + this.escape(options.limit);
      }
    }
    /* eslint-enable */

    return fragment;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    let result;

    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {
      smth.comparator = this.OperatorMap[smth.comparator];
    }

    if (smth instanceof Utils.Where) {
      let value = smth.logic;
      let key;

      if (smth.attribute instanceof Utils.SequelizeMethod) {
        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
      } else {
        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;
      }

      if (value && value instanceof Utils.SequelizeMethod) {
        value = this.getWhereConditions(value, tableName, factory, options, prepend);

        if (value === 'NULL') {
          if (smth.comparator === '=') {
            smth.comparator = 'IS';
          }
          if (smth.comparator === '!=') {
            smth.comparator = 'IS NOT';
          }
        }

        return [key, value].join(` ${smth.comparator} `);
      }
      if (_.isPlainObject(value)) {
        return this.whereItemQuery(smth.attribute, value, {
          model: factory
        });
      }
      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {
        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;
      } else if (typeof value === 'boolean') {
        value = this.booleanValue(value);
      } else {
        value = this.escape(value);
      }

      if (value === 'NULL') {
        if (smth.comparator === '=') {
          smth.comparator = 'IS';
        }
        if (smth.comparator === '!=') {
          smth.comparator = 'IS NOT';
        }
      }

      return [key, value].join(` ${smth.comparator} `);
    }
    if (smth instanceof Utils.Literal) {
      return smth.val;
    }
    if (smth instanceof Utils.Cast) {
      if (smth.val instanceof Utils.SequelizeMethod) {
        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
      } else if (_.isPlainObject(smth.val)) {
        result = this.whereItemsQuery(smth.val);
      } else {
        result = this.escape(smth.val);
      }

      return `CAST(${result} AS ${smth.type.toUpperCase()})`;
    }
    if (smth instanceof Utils.Fn) {
      return `${smth.fn}(${
        smth.args.map(arg => {
          if (arg instanceof Utils.SequelizeMethod) {
            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);
          }
          if (_.isPlainObject(arg)) {
            return this.whereItemsQuery(arg);
          }
          return this.escape(typeof arg === 'string' ? arg.replace('$', '$$$') : arg);
        }).join(', ')
      })`;
    }
    if (smth instanceof Utils.Col) {
      if (Array.isArray(smth.col) && !factory) {
        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');
      }
      if (smth.col.startsWith('*')) {
        return '*';
      }
      return this.quote(smth.col, factory);
    }
    return smth.toString(this, factory);
  }

  whereQuery(where, options) {
    const query = this.whereItemsQuery(where, options);
    if (query && query.length) {
      return `WHERE ${query}`;
    }
    return '';
  }

  whereItemsQuery(where, options, binding) {
    if (
      where === null ||
      where === undefined ||
      Utils.getComplexSize(where) === 0
    ) {
      // NO OP
      return '';
    }

    if (typeof where === 'string') {
      throw new Error('Support for `{where: \'raw query\'}` has been removed.');
    }

    const items = [];

    binding = binding || 'AND';
    if (binding[0] !== ' ') binding = ` ${binding} `;

    if (_.isPlainObject(where)) {
      Utils.getComplexKeys(where).forEach(prop => {
        const item = where[prop];
        items.push(this.whereItemQuery(prop, item, options));
      });
    } else {
      items.push(this.whereItemQuery(undefined, where, options));
    }

    return items.length && items.filter(item => item && item.length).join(binding) || '';
  }

  whereItemQuery(key, value, options = {}) {
    if (value === undefined) {
      throw new Error(`WHERE parameter "${key}" has invalid "undefined" value`);
    }

    if (typeof key === 'string' && key.includes('.') && options.model) {
      const keyParts = key.split('.');
      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {
        const tmp = {};
        const field = options.model.rawAttributes[keyParts[0]];
        _.set(tmp, keyParts.slice(1), value);
        return this.whereItemQuery(field.field || keyParts[0], tmp, { field, ...options });
      }
    }

    const field = this._findField(key, options);
    const fieldType = field && field.type || options.type;

    const isPlainObject = _.isPlainObject(value);
    const isArray = !isPlainObject && Array.isArray(value);
    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;
    if (isPlainObject) {
      value = this._replaceAliases(value);
    }
    const valueKeys = isPlainObject && Utils.getComplexKeys(value);

    if (key === undefined) {
      if (typeof value === 'string') {
        return value;
      }

      if (isPlainObject && valueKeys.length === 1) {
        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);
      }
    }

    if (value === null) {
      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);
    }

    if (!value) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {
      return this.handleSequelizeMethod(value);
    }

    // Convert where: [] to Op.and if possible, else treat as literal/replacements
    if (key === undefined && isArray) {
      if (Utils.canTreatArrayAsAnd(value)) {
        key = Op.and;
      } else {
        throw new Error('Support for literal replacements in the `where` object has been removed.');
      }
    }

    if (key === Op.or || key === Op.and || key === Op.not) {
      return this._whereGroupBind(key, value, options);
    }


    if (value[Op.or]) {
      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);
    }

    if (value[Op.and]) {
      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);
    }

    if (isArray && fieldType instanceof DataTypes.ARRAY) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {
      return this._whereJSON(key, value, options);
    }
    // If multiple keys we combine the different logic conditions
    if (isPlainObject && valueKeys.length > 1) {
      return this._whereBind(this.OperatorMap[Op.and], key, value, options);
    }

    if (isArray) {
      return this._whereParseSingleValueObject(key, field, Op.in, value, options);
    }
    if (isPlainObject) {
      if (this.OperatorMap[valueKeys[0]]) {
        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);
      }
      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);
    }

    if (key === Op.placeholder) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
  }

  _findField(key, options) {
    if (options.field) {
      return options.field;
    }

    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {
      return options.model.rawAttributes[key];
    }

    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {
      return options.model.fieldRawAttributesMap[key];
    }
  }

  // OR/AND/NOT grouping logic
  _whereGroupBind(key, value, options) {
    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];
    const outerBinding = key === Op.not ? 'NOT ' : '';

    if (Array.isArray(value)) {
      value = value.map(item => {
        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);
        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {
          itemQuery = `(${itemQuery})`;
        }
        return itemQuery;
      }).filter(item => item && item.length);

      value = value.length && value.join(binding);
    } else {
      value = this.whereItemsQuery(value, options, binding);
    }
    // Op.or: [] should return no data.
    // Op.not of no restriction should also return no data
    if ((key === Op.or || key === Op.not) && !value) {
      return '0 = 1';
    }

    return value ? `${outerBinding}(${value})` : undefined;
  }

  _whereBind(binding, key, value, options) {
    if (_.isPlainObject(value)) {
      value = Utils.getComplexKeys(value).map(prop => {
        const item = value[prop];
        return this.whereItemQuery(key, { [prop]: item }, options);
      });
    } else {
      value = value.map(item => this.whereItemQuery(key, item, options));
    }

    value = value.filter(item => item && item.length);

    return value.length ? `(${value.join(binding)})` : undefined;
  }

  _whereJSON(key, value, options) {
    const items = [];
    let baseKey = this.quoteIdentifier(key);
    if (options.prefix) {
      if (options.prefix instanceof Utils.Literal) {
        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;
      } else {
        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;
      }
    }

    Utils.getOperators(value).forEach(op => {
      const where = {
        [op]: value[op]
      };
      items.push(this.whereItemQuery(key, where, { ...options, json: false }));
    });

    _.forOwn(value, (item, prop) => {
      this._traverseJSON(items, baseKey, prop, item, [prop]);
    });

    const result = items.join(this.OperatorMap[Op.and]);
    return items.length > 1 ? `(${result})` : result;
  }

  _traverseJSON(items, baseKey, prop, item, path) {
    let cast;

    if (path[path.length - 1].includes('::')) {
      const tmp = path[path.length - 1].split('::');
      cast = tmp[1];
      path[path.length - 1] = tmp[0];
    }

    const pathKey = this.jsonPathExtractionQuery(baseKey, path);

    if (_.isPlainObject(item)) {
      Utils.getOperators(item).forEach(op => {
        const value = this._toJSONValue(item[op]);
        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));
      });
      _.forOwn(item, (value, itemProp) => {
        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));
      });

      return;
    }

    item = this._toJSONValue(item);
    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));
  }

  _toJSONValue(value) {
    return value;
  }

  _castKey(key, value, cast, json) {
    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);
    if (cast) {
      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));
    }

    return new Utils.Literal(key);
  }

  _getJsonCast(value) {
    if (typeof value === 'number') {
      return 'double precision';
    }
    if (value instanceof Date) {
      return 'timestamptz';
    }
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    return;
  }

  _joinKeyValue(key, value, comparator, prefix) {
    if (!key) {
      return value;
    }
    if (comparator === undefined) {
      throw new Error(`${key} and ${value} has no comparator`);
    }
    key = this._getSafeKey(key, prefix);
    return [key, value].join(` ${comparator} `);
  }

  _getSafeKey(key, prefix) {
    if (key instanceof Utils.SequelizeMethod) {
      key = this.handleSequelizeMethod(key);
      return this._prefixKey(this.handleSequelizeMethod(key), prefix);
    }

    if (Utils.isColString(key)) {
      key = key.substr(1, key.length - 2).split('.');

      if (key.length > 2) {
        key = [
          // join the tables by -> to match out internal namings
          key.slice(0, -1).join('->'),
          key[key.length - 1]
        ];
      }

      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');
    }

    return this._prefixKey(this.quoteIdentifier(key), prefix);
  }

  _prefixKey(key, prefix) {
    if (prefix) {
      if (prefix instanceof Utils.Literal) {
        return [this.handleSequelizeMethod(prefix), key].join('.');
      }

      return [this.quoteTable(prefix), key].join('.');
    }

    return key;
  }

  _whereParseSingleValueObject(key, field, prop, value, options) {
    if (prop === Op.not) {
      if (Array.isArray(value)) {
        prop = Op.notIn;
      } else if (value !== null && value !== true && value !== false) {
        prop = Op.ne;
      }
    }

    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];

    switch (prop) {
      case Op.in:
      case Op.notIn:
        if (value instanceof Utils.Literal) {
          return this._joinKeyValue(key, value.val, comparator, options.prefix);
        }

        if (value.length) {
          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);
        }

        if (comparator === this.OperatorMap[Op.in]) {
          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);
        }

        return '';
      case Op.any:
      case Op.all:
        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;
        if (value[Op.values]) {
          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);
        }

        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);
      case Op.between:
      case Op.notBetween:
        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);
      case Op.raw:
        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');
      case Op.col:
        comparator = this.OperatorMap[Op.eq];
        value = value.split('.');

        if (value.length > 2) {
          value = [
            // join the tables by -> to match out internal namings
            value.slice(0, -1).join('->'),
            value[value.length - 1]
          ];
        }

        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);
      case Op.startsWith:
      case Op.endsWith:
      case Op.substring:
        comparator = this.OperatorMap[Op.like];

        if (value instanceof Utils.Literal) {
          value = value.val;
        }

        let pattern = `${value}%`;

        if (prop === Op.endsWith) pattern = `%${value}`;
        if (prop === Op.substring) pattern = `%${value}%`;

        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);
    }

    const escapeOptions = {
      acceptStrings: comparator.includes(this.OperatorMap[Op.like])
    };

    if (_.isPlainObject(value)) {
      if (value[Op.col]) {
        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);
      }
      if (value[Op.any]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);
      }
      if (value[Op.all]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);
      }
    }

    if (value === null && comparator === this.OperatorMap[Op.eq]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);
    }
    if (value === null && comparator === this.OperatorMap[Op.ne]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);
    }

    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);
  }

  /*
    Takes something and transforms it into values of a where condition.
   @private
  */
  getWhereConditions(smth, tableName, factory, options, prepend) {
    const where = {};

    if (Array.isArray(tableName)) {
      tableName = tableName[0];
      if (Array.isArray(tableName)) {
        tableName = tableName[1];
      }
    }

    options = options || {};

    if (prepend === undefined) {
      prepend = true;
    }

    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls
      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }
    if (_.isPlainObject(smth)) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName,
        type: options.type
      });
    }
    if (typeof smth === 'number') {
      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];

      if (primaryKeys.length > 0) {
        // Since we're just a number, assume only the first key
        primaryKeys = primaryKeys[0];
      } else {
        primaryKeys = 'id';
      }

      where[primaryKeys] = smth;

      return this.whereItemsQuery(where, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (typeof smth === 'string') {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (Buffer.isBuffer(smth)) {
      return this.escape(smth);
    }
    if (Array.isArray(smth)) {
      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';
      if (Utils.canTreatArrayAsAnd(smth)) {
        const _smth = { [Op.and]: smth };
        return this.getWhereConditions(_smth, tableName, factory, options, prepend);
      }
      throw new Error('Support for literal replacements in the `where` object has been removed.');
    }
    if (smth === null) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }

    return '1=1';
  }

  // A recursive parser for nested where conditions
  parseConditionObject(conditions, path) {
    path = path || [];
    return _.reduce(conditions, (result, value, key) => {
      if (_.isObject(value)) {
        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects
      }
      result.push({ path: path.concat(key), value });
      return result;
    }, []);
  }

  booleanValue(value) {
    return value;
  }
}

Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js"));
Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js"));

module.exports = QueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Quote helpers implement quote ability for all dialects.
 * These are basic block of query building
 *
 * Its better to implement all dialect implementation together here. Which will allow
 * even abstract generator to use them by just specifying dialect type.
 *
 * Defining these helpers in each query dialect will leave
 * code in dual dependency of abstract <-> specific dialect
 */



const Utils = __webpack_require__(/*! ../../../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * list of reserved words in PostgreSQL 10
 * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html
 *
 * @private
 */
const postgresReservedWords = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');

/**
 *
 * @param {string}  dialect         Dialect name
 * @param {string}  identifier      Identifier to quote
 * @param {object}  [options]
 * @param {boolean} [options.force=false]
 * @param {boolean} [options.quoteIdentifiers=true]
 *
 * @returns {string}
 * @private
 */
function quoteIdentifier(dialect, identifier, options) {
  if (identifier === '*') return identifier;

  options = Utils.defaults(options || {}, {
    force: false,
    quoteIdentifiers: true
  });

  switch (dialect) {
    case 'sqlite':
    case 'mariadb':
    case 'mysql':
      return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');

    case 'postgres':
      const rawIdentifier = Utils.removeTicks(identifier, '"');

      if (
        options.force !== true &&
        options.quoteIdentifiers === false &&
        !identifier.includes('.') &&
        !identifier.includes('->') &&
        !postgresReservedWords.includes(rawIdentifier.toLowerCase())
      ) {
        // In Postgres, if tables or attributes are created double-quoted,
        // they are also case sensitive. If they contain any uppercase
        // characters, they must always be double-quoted. This makes it
        // impossible to write queries in portable SQL if tables are created in
        // this way. Hence, we strip quotes if we don't want case sensitivity.
        return rawIdentifier;
      }
      return Utils.addTicks(rawIdentifier, '"');
    case 'mssql':
      return `[${identifier.replace(/[[\]']+/g, '')}]`;

    default:
      throw new Error(`Dialect "${dialect}" is not supported`);
  }
}
module.exports.quoteIdentifier = quoteIdentifier;

/**
 * Test if a give string is already quoted
 *
 * @param {string} identifier
 *
 * @returns {boolean}
 * @private
 */
function isIdentifierQuoted(identifier) {
  return /^\s*(?:([`"'])(?:(?!\1).|\1{2})*\1\.?)+\s*$/i.test(identifier);
}
module.exports.isIdentifierQuoted = isIdentifierQuoted;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Op = __webpack_require__(/*! ../../../operators */ "./node_modules/sequelize/lib/operators.js");
const Utils = __webpack_require__(/*! ../../../utils */ "./node_modules/sequelize/lib/utils.js");

const OperatorHelpers = {
  OperatorMap: {
    [Op.eq]: '=',
    [Op.ne]: '!=',
    [Op.gte]: '>=',
    [Op.gt]: '>',
    [Op.lte]: '<=',
    [Op.lt]: '<',
    [Op.not]: 'IS NOT',
    [Op.is]: 'IS',
    [Op.in]: 'IN',
    [Op.notIn]: 'NOT IN',
    [Op.like]: 'LIKE',
    [Op.notLike]: 'NOT LIKE',
    [Op.iLike]: 'ILIKE',
    [Op.notILike]: 'NOT ILIKE',
    [Op.startsWith]: 'LIKE',
    [Op.endsWith]: 'LIKE',
    [Op.substring]: 'LIKE',
    [Op.regexp]: '~',
    [Op.notRegexp]: '!~',
    [Op.iRegexp]: '~*',
    [Op.notIRegexp]: '!~*',
    [Op.between]: 'BETWEEN',
    [Op.notBetween]: 'NOT BETWEEN',
    [Op.overlap]: '&&',
    [Op.contains]: '@>',
    [Op.contained]: '<@',
    [Op.adjacent]: '-|-',
    [Op.strictLeft]: '<<',
    [Op.strictRight]: '>>',
    [Op.noExtendRight]: '&<',
    [Op.noExtendLeft]: '&>',
    [Op.any]: 'ANY',
    [Op.all]: 'ALL',
    [Op.and]: ' AND ',
    [Op.or]: ' OR ',
    [Op.col]: 'COL',
    [Op.placeholder]: '$$PLACEHOLDER$$',
    [Op.match]: '@@'
  },

  OperatorsAliasMap: {},

  setOperatorsAliases(aliases) {
    if (!aliases || _.isEmpty(aliases)) {
      this.OperatorsAliasMap = false;
    } else {
      this.OperatorsAliasMap = { ...aliases };
    }
  },

  _replaceAliases(orig) {
    const obj = {};
    if (!this.OperatorsAliasMap) {
      return orig;
    }

    Utils.getOperators(orig).forEach(op => {
      const item = orig[op];
      if (_.isPlainObject(item)) {
        obj[op] = this._replaceAliases(item);
      } else {
        obj[op] = item;
      }
    });

    _.forOwn(orig, (item, prop) => {
      prop = this.OperatorsAliasMap[prop] || prop;
      if (_.isPlainObject(item)) {
        item = this._replaceAliases(item);
      }
      obj[prop] = item;
    });
    return obj;
  }
};

module.exports = OperatorHelpers;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const TransactionQueries = {
  /**
   * Returns a query that sets the transaction isolation level.
   *
   * @param  {string} value   The isolation level.
   * @param  {object} options An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  setIsolationLevelQuery(value, options) {
    if (options.parent) {
      return;
    }

    return `SET TRANSACTION ISOLATION LEVEL ${value};`;
  },

  generateTransactionId() {
    return uuidv4();
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'START TRANSACTION;';
  },

  deferConstraintsQuery() {},

  setConstraintQuery() {},
  setDeferredQuery() {},
  setImmediateQuery() {},

  /**
   * Returns a query that commits a transaction.
   *
   * @param  {Transaction} transaction An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT;';
  },

  /**
   * Returns a query that rollbacks a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'ROLLBACK;';
  }
};

module.exports = TransactionQueries;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk to all databases
 */
class QueryInterface {
  constructor(sequelize, queryGenerator) {
    this.sequelize = sequelize;
    this.queryGenerator = queryGenerator;
  }

  /**
   * Create a database
   *
   * @param {string} database  Database name to create
   * @param {object} [options] Query options
   * @param {string} [options.charset] Database default character set, MYSQL only
   * @param {string} [options.collate] Database default collation
   * @param {string} [options.encoding] Database default character set, PostgreSQL only
   * @param {string} [options.ctype] Database character classification, PostgreSQL only
   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only
   *
   * @returns {Promise}
   */
  async createDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.createDatabaseQuery(database, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a database
   *
   * @param {string} database  Database name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.dropDatabaseQuery(database);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Create a schema
   *
   * @param {string} schema    Schema name to create
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.createSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a schema
   *
   * @param {string} schema    Schema name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.dropSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    options = options || {};

    if (!this.queryGenerator._dialect.supports.schemas) {
      return this.sequelize.drop(options);
    }
    const schemas = await this.showAllSchemas(options);
    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));
  }

  /**
   * Show all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise<Array>}
   */
  async showAllSchemas(options) {
    options = {
      ...options,
      raw: true,
      type: this.sequelize.QueryTypes.SELECT
    };

    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);

    const schemaNames = await this.sequelize.query(showSchemasSql, options);

    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));
  }

  /**
   * Return database version
   *
   * @param {object}    [options]      Query options
   * @param {QueryType} [options.type] Query type
   *
   * @returns {Promise}
   * @private
   */
  async databaseVersion(options) {
    return await this.sequelize.query(
      this.queryGenerator.versionQuery(),
      { ...options, type: QueryTypes.VERSION }
    );
  }

  /**
   * Create a table with given set of attributes
   *
   * ```js
   * queryInterface.createTable(
   *   'nameOfTheNewTable',
   *   {
   *     id: {
   *       type: Sequelize.INTEGER,
   *       primaryKey: true,
   *       autoIncrement: true
   *     },
   *     createdAt: {
   *       type: Sequelize.DATE
   *     },
   *     updatedAt: {
   *       type: Sequelize.DATE
   *     },
   *     attr1: Sequelize.STRING,
   *     attr2: Sequelize.INTEGER,
   *     attr3: {
   *       type: Sequelize.BOOLEAN,
   *       defaultValue: false,
   *       allowNull: false
   *     },
   *     //foreign key usage
   *     attr4: {
   *       type: Sequelize.INTEGER,
   *       references: {
   *         model: 'another_table_name',
   *         key: 'id'
   *       },
   *       onUpdate: 'cascade',
   *       onDelete: 'cascade'
   *     }
   *   },
   *   {
   *     engine: 'MYISAM',    // default: 'InnoDB'
   *     charset: 'latin1',   // default: null
   *     schema: 'public',    // default: public, PostgreSQL only.
   *     comment: 'my table', // comment for table
   *     collate: 'latin1_danish_ci' // collation, MYSQL only
   *   }
   * )
   * ```
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of table attributes to create
   * @param {object} [options] create table and query options
   * @param {Model}  [model] model class
   *
   * @returns {Promise}
   */
  async createTable(tableName, attributes, options, model) {
    let sql = '';

    options = { ...options };

    if (options && options.uniqueKeys) {
      _.forOwn(options.uniqueKeys, uniqueKey => {
        if (uniqueKey.customIndex === undefined) {
          uniqueKey.customIndex = true;
        }
      });
    }

    if (model) {
      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;
    }

    attributes = _.mapValues(
      attributes,
      attribute => this.sequelize.normalizeAttribute(attribute)
    );

    // Postgres requires special SQL commands for ENUM/ENUM[]
    await this.ensureEnums(tableName, attributes, options, model);

    if (
      !tableName.schema &&
      (options.schema || !!model && model._schema)
    ) {
      tableName = this.queryGenerator.addSchema({
        tableName,
        _schema: !!model && model._schema || options.schema
      });
    }

    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });
    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);

    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a table from database
   *
   * @param {string} tableName Table name to drop
   * @param {object} options   Query options
   *
   * @returns {Promise}
   */
  async dropTable(tableName, options) {
    // if we're forcing we should be cascading unless explicitly stated otherwise
    options = { ...options };
    options.cascade = options.cascade || options.force || false;

    const sql = this.queryGenerator.dropTableQuery(tableName, options);

    await this.sequelize.query(sql, options);
  }

  async _dropAllTables(tableNames, skip, options) {
    for (const tableName of tableNames) {
      // if tableName is not in the Array of tables names then don't drop it
      if (!skip.includes(tableName.tableName || tableName)) {
        await this.dropTable(tableName, { ...options, cascade: true } );
      }
    }
  }

  /**
   * Drop all tables from database
   *
   * @param {object} [options] query options
   * @param {Array}  [options.skip] List of table to skip
   *
   * @returns {Promise}
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);

    for (const tableName of tableNames) {
      let normalizedTableName = tableName;
      if (_.isObject(tableName)) {
        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;
      }

      for (const foreignKey of foreignKeys[normalizedTableName]) {
        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));
      }
    }
    await this._dropAllTables(tableNames, skip, options);
  }

  /**
   * Rename a table
   *
   * @param {string} before    Current name of table
   * @param {string} after     New name from table
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async renameTable(before, after, options) {
    options = options || {};
    const sql = this.queryGenerator.renameTableQuery(before, after);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Get all tables in current database
   *
   * @param {object}    [options] Query options
   * @param {boolean}   [options.raw=true] Run query in raw mode
   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showAllTables(options) {
    options = {
      ...options,
      raw: true,
      type: QueryTypes.SHOWTABLES
    };

    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);
    const tableNames = await this.sequelize.query(showTablesSql, options);
    return _.flatten(tableNames);
  }

  /**
   * Describe a table structure
   *
   * This method returns an array of hashes containing information about all attributes in the table.
   *
   * ```js
   * {
   *    name: {
   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!
   *      allowNull:    true,
   *      defaultValue: null
   *    },
   *    isBetaMember: {
   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!
   *      allowNull:    false,
   *      defaultValue: false
   *    }
   * }
   * ```
   *
   * @param {string} tableName table name
   * @param {object} [options] Query options
   *
   * @returns {Promise<object>}
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }

  /**
   * Add a new column to a table
   *
   * ```js
   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {
   *    after: 'columnB' // after option is only supported by MySQL
   * });
   * ```
   *
   * @param {string} table     Table to add column to
   * @param {string} key       Column name
   * @param {object} attribute Attribute definition
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async addColumn(table, key, attribute, options) {
    if (!table || !key || !attribute) {
      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');
    }

    options = options || {};
    attribute = this.sequelize.normalizeAttribute(attribute);
    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);
  }

  /**
   * Remove a column from a table
   *
   * @param {string} tableName      Table to remove column from
   * @param {string} attributeName  Column name to remove
   * @param {object} [options]      Query options
   */
  async removeColumn(tableName, attributeName, options) {
    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);
  }

  normalizeAttribute(dataTypeOrOptions) {
    let attribute;
    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {
      attribute = { type: dataTypeOrOptions, allowNull: true };
    } else {
      attribute = dataTypeOrOptions;
    }

    return this.sequelize.normalizeAttribute(attribute);
  }

  /**
   * Change a column definition
   *
   * @param {string} tableName          Table name to change from
   * @param {string} attributeName      Column name
   * @param {object} dataTypeOrOptions  Attribute definition for new column
   * @param {object} [options]          Query options
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const query = this.queryGenerator.attributesToSQL({
      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)
    }, {
      context: 'changeColumn',
      table: tableName
    });
    const sql = this.queryGenerator.changeColumnQuery(tableName, query);

    return this.sequelize.query(sql, options);
  }

  /**
   * Rejects if the table doesn't have the specified column, otherwise returns the column description.
   *
   * @param {string} tableName
   * @param {string} columnName
   * @param {object} options
   * @private
   */
  async assertTableHasColumn(tableName, columnName, options) {
    const description = await this.describeTable(tableName, options);
    if (description[columnName]) {
      return description;
    }
    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);
  }

  /**
   * Rename a column
   *
   * @param {string} tableName        Table name whose column to rename
   * @param {string} attrNameBefore   Current column name
   * @param {string} attrNameAfter    New column name
   * @param {object} [options]        Query option
   *
   * @returns {Promise}
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];

    const _options = {};

    _options[attrNameAfter] = {
      attribute: attrNameAfter,
      type: data.type,
      allowNull: data.allowNull,
      defaultValue: data.defaultValue
    };

    // fix: a not-null column cannot have null as default value
    if (data.defaultValue === null && !data.allowNull) {
      delete _options[attrNameAfter].defaultValue;
    }

    const sql = this.queryGenerator.renameColumnQuery(
      tableName,
      attrNameBefore,
      this.queryGenerator.attributesToSQL(_options)
    );
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add an index to a column
   *
   * @param {string|object}  tableName Table name to add index on, can be a object with schema
   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on
   * @param {object}  options          indexes options
   * @param {Array}   options.fields   List of attributes to add index on
   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created
   * @param {boolean} [options.unique] Create a unique index
   * @param {string}  [options.using]  Useful for GIN indexes
   * @param {string}  [options.operator] Index operator
   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL
   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>
   * @param {object}  [options.where]  Where condition on index, for partial indexes
   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity
   *
   * @returns {Promise}
   */
  async addIndex(tableName, attributes, options, rawTablename) {
    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)
    if (!Array.isArray(attributes)) {
      rawTablename = options;
      options = attributes;
      attributes = options.fields;
    }

    if (!rawTablename) {
      // Map for backwards compat
      rawTablename = tableName;
    }

    options = Utils.cloneDeep(options);
    options.fields = attributes;
    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);
    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });
  }

  /**
   * Show indexes on a table
   *
   * @param {string} tableName table name
   * @param {object} [options]   Query options
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showIndex(tableName, options) {
    const sql = this.queryGenerator.showIndexesQuery(tableName, options);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });
  }


  /**
   * Returns all foreign key constraints of requested tables
   *
   * @param {string[]} tableNames table names
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async getForeignKeysForTables(tableNames, options) {
    if (tableNames.length === 0) {
      return {};
    }

    options = { ...options, type: QueryTypes.FOREIGNKEYS };

    const results = await Promise.all(tableNames.map(tableName =>
      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));

    const result = {};

    tableNames.forEach((tableName, i) => {
      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      result[tableName] = Array.isArray(results[i])
        ? results[i].map(r => r.constraint_name)
        : [results[i] && results[i].constraint_name];

      result[tableName] = result[tableName].filter(_.identity);
    });

    return result;
  }

  /**
   * Get foreign key references details for the table
   *
   * Those details contains constraintSchema, constraintName, constraintCatalog
   * tableCatalog, tableSchema, tableName, columnName,
   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.
   * Remind: constraint informations won't return if it's sqlite.
   *
   * @param {string} tableName table name
   * @param {object} [options]  Query options
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };
    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);
    return this.sequelize.query(query, queryOptions);
  }

  /**
   * Remove an already existing index from a table
   *
   * @param {string} tableName                    Table name to drop index from
   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index
   * @param {object} [options]                    Query options
   *
   * @returns {Promise}
   */
  async removeIndex(tableName, indexNameOrAttributes, options) {
    options = options || {};
    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add a constraint to a table
   *
   * Available constraints:
   * - UNIQUE
   * - DEFAULT (MSSQL only)
   * - CHECK (MySQL - Ignored by the database engine )
   * - FOREIGN KEY
   * - PRIMARY KEY
   *
   * @example <caption>UNIQUE</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['email'],
   *   type: 'unique',
   *   name: 'custom_unique_constraint_name'
   * });
   *
   * @example <caption>CHECK</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['roles'],
   *   type: 'check',
   *   where: {
   *      roles: ['user', 'admin', 'moderator', 'guest']
   *   }
   * });
   *
   * @example <caption>Default - MSSQL only</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['roles'],
   *    type: 'default',
   *    defaultValue: 'guest'
   * });
   *
   * @example <caption>Primary Key</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['username'],
   *    type: 'primary key',
   *    name: 'custom_primary_constraint_name'
   * });
   *
   * @example <caption>Foreign Key</caption>
   * queryInterface.addConstraint('Posts', {
   *   fields: ['username'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     field: 'target_column_name'
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @example <caption>Composite Foreign Key</caption>
   * queryInterface.addConstraint('TableName', {
   *   fields: ['source_column_name', 'other_source_column_name'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     fields: ['target_column_name', 'other_target_column_name']
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @param {string} tableName                   Table name where you want to add a constraint
   * @param {object} options                     An object to define the constraint name, type etc
   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)
   * @param {Array}  options.fields              Array of column names to apply the constraint over
   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names
   * @param {string} [options.defaultValue]      The value for the default constraint
   * @param {object} [options.where]             Where clause/expression for the CHECK constraint
   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint
   * @param {string} [options.references.table]  Target table name
   * @param {string} [options.references.field]  Target column name
   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.
   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only
   *
   * @returns {Promise}
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.addConstraintQuery(tableName, options);
    return await this.sequelize.query(sql, options);
  }

  async showConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });
  }

  /**
   * Remove a constraint from a table
   *
   * @param {string} tableName       Table name to drop constraint from
   * @param {string} constraintName  Constraint name
   * @param {object} options         Query options
   */
  async removeConstraint(tableName, constraintName, options) {
    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);
  }

  async insert(instance, tableName, values, options) {
    options = Utils.cloneDeep(options);
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;
    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);

    options.type = QueryTypes.INSERT;
    options.instance = instance;

    const results = await this.sequelize.query(sql, options);
    if (instance) results[0].isNewRecord = false;

    return results;
  }

  /**
   * Upsert
   *
   * @param {string} tableName    table to upsert on
   * @param {object} insertValues values to be inserted, mapped to field name
   * @param {object} updateValues values to be updated, mapped to field name
   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails
   * @param {object} options      query options
   *
   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    const model = options.model;
    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);
    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length >= 1).map(c => c.fields);
    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length >= 1).map(c => c.fields);

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);
    options.upsertKeys = [];

    // For fields in updateValues, try to find a constraint or unique index
    // that includes given field. Only first matching upsert key is used.
    for (const field of options.updateOnDuplicate) {
      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));
      if (uniqueKey) {
        options.upsertKeys = uniqueKey;
        break;
      }

      const indexKey = indexKeys.find(fields => fields.includes(field));
      if (indexKey) {
        options.upsertKeys = indexKey;
        break;
      }
    }

    // Always use PK, if no constraint available OR update data contains PK
    if (
      options.upsertKeys.length === 0
      || _.intersection(options.updateOnDuplicate, primaryKeys).length
    ) {
      options.upsertKeys = primaryKeys;
    }

    options.upsertKeys = _.uniq(options.upsertKeys);

    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Insert multiple records into a table
   *
   * @example
   * queryInterface.bulkInsert('roles', [{
   *    label: 'user',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }, {
   *    label: 'admin',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }]);
   *
   * @param {string} tableName   Table name to insert record to
   * @param {Array}  records     List of records to insert
   * @param {object} options     Various options, please see Model.bulkCreate options
   * @param {object} attributes  Various attributes mapped by field name
   *
   * @returns {Promise}
   */
  async bulkInsert(tableName, records, options, attributes) {
    options = { ...options };
    options.type = QueryTypes.INSERT;

    const results = await this.sequelize.query(
      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),
      options
    );

    return results[0];
  }

  async update(instance, tableName, values, identifier, options) {
    options = { ...options };
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);

    options.type = QueryTypes.UPDATE;

    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Update multiple records of a table
   *
   * @example
   * queryInterface.bulkUpdate('roles', {
   *     label: 'admin',
   *   }, {
   *     userType: 3,
   *   },
   * );
   *
   * @param {string} tableName     Table name to update
   * @param {object} values        Values to be inserted, mapped to field name
   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions
   * @param {object} [options]     Various options, please see Model.bulkCreate options
   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect
   *
   * @returns {Promise}
   */
  async bulkUpdate(tableName, values, identifier, options, attributes) {
    options = Utils.cloneDeep(options);
    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);
    const table = _.isObject(tableName) ? tableName : { tableName };
    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });

    options.type = QueryTypes.BULKUPDATE;
    options.model = model;
    return await this.sequelize.query(sql, options);
  }

  async delete(instance, tableName, identifier, options) {
    const cascades = [];
    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);

    options = { ...options };

    // Check for a restrict field
    if (!!instance.constructor && !!instance.constructor.associations) {
      const keys = Object.keys(instance.constructor.associations);
      const length = keys.length;
      let association;

      for (let i = 0; i < length; i++) {
        association = instance.constructor.associations[keys[i]];
        if (association.options && association.options.onDelete &&
          association.options.onDelete.toLowerCase() === 'cascade' &&
          association.options.useHooks === true) {
          cascades.push(association.accessors.get);
        }
      }
    }

    for (const cascade of cascades) {
      let instances = await instance[cascade](options);
      // Check for hasOne relationship with non-existing associate ("has zero")
      if (!instances) continue;
      if (!Array.isArray(instances)) instances = [instances];
      for (const _instance of instances) await _instance.destroy(options);
    }
    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Delete multiple records from a table
   *
   * @param {string}  tableName            table name from where to delete records
   * @param {object}  where                where conditions to find records to delete
   * @param {object}  [options]            options
   * @param {boolean} [options.truncate]   Use truncate table command
   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param {Model}   [model]              Model
   *
   * @returns {Promise}
   */
  async bulkDelete(tableName, where, options, model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { limit: null });

    if (options.truncate === true) {
      return this.sequelize.query(
        this.queryGenerator.truncateTableQuery(tableName, options),
        options
      );
    }

    if (typeof identifier === 'object') where = Utils.cloneDeep(where);

    return await this.sequelize.query(
      this.queryGenerator.deleteQuery(tableName, where, options, model),
      options
    );
  }

  async select(model, tableName, optionsArg) {
    const options = { ...optionsArg, type: QueryTypes.SELECT, model };

    return await this.sequelize.query(
      this.queryGenerator.selectQuery(tableName, options, model),
      options
    );
  }

  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async rawSelect(tableName, options, attributeSelector, Model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT
    });

    const sql = this.queryGenerator.selectQuery(tableName, options, Model);

    if (attributeSelector === undefined) {
      throw new Error('Please pass an attribute selector!');
    }

    const data = await this.sequelize.query(sql, options);
    if (!options.plain) {
      return data;
    }

    const result = data ? data[attributeSelector] : null;

    if (!options || !options.dataType) {
      return result;
    }

    const dataType = options.dataType;

    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {
      if (result !== null) {
        return parseFloat(result);
      }
    }
    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {
      return parseInt(result, 10);
    }
    if (dataType instanceof DataTypes.DATE) {
      if (result !== null && !(result instanceof Date)) {
        return new Date(result);
      }
    }
    return result;
  }

  async createTrigger(
    tableName,
    triggerName,
    timingType,
    fireOnArray,
    functionName,
    functionParams,
    optionsArray,
    options
  ) {
    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);
    options = options || {};
    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async dropTrigger(tableName, triggerName, options) {
    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {
    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Create an SQL function
   *
   * @example
   * queryInterface.createFunction(
   *   'someFunction',
   *   [
   *     {type: 'integer', name: 'param', direction: 'IN'}
   *   ],
   *   'integer',
   *   'plpgsql',
   *   'RETURN param + 1;',
   *   [
   *     'IMMUTABLE',
   *     'LEAKPROOF'
   *   ],
   *   {
   *    variables:
   *      [
   *        {type: 'integer', name: 'myVar', default: 100}
   *      ],
   *      force: true
   *   };
   * );
   *
   * @param {string}  functionName  Name of SQL function to create
   * @param {Array}   params        List of parameters declared for SQL function
   * @param {string}  returnType    SQL type of function returned value
   * @param {string}  language      The name of the language that the function is implemented in
   * @param {string}  body          Source code of function
   * @param {Array}   optionsArray  Extra-options for creation
   * @param {object}  [options]     query options
   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false
   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.
   *
   * @returns {Promise}
   */
  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Drop an SQL function
   *
   * @example
   * queryInterface.dropFunction(
   *   'someFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ]
   * );
   *
   * @param {string} functionName Name of SQL function to drop
   * @param {Array}  params       List of parameters declared for SQL function
   * @param {object} [options]    query options
   *
   * @returns {Promise}
   */
  async dropFunction(functionName, params, options) {
    const sql = this.queryGenerator.dropFunction(functionName, params);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Rename an SQL function
   *
   * @example
   * queryInterface.renameFunction(
   *   'fooFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ],
   *   'barFunction'
   * );
   *
   * @param {string} oldFunctionName  Current name of function
   * @param {Array}  params           List of parameters declared for SQL function
   * @param {string} newFunctionName  New name of function
   * @param {object} [options]        query options
   *
   * @returns {Promise}
   */
  async renameFunction(oldFunctionName, params, newFunctionName, options) {
    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  // Helper methods useful for querying

  /**
   * @private
   */
  ensureEnums() {
    // noop by default
  }

  async setIsolationLevel(transaction, value, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to set isolation level for a transaction without transaction object!');
    }

    if (transaction.parent || !value) {
      // Not possible to set a separate isolation level for savepoints
      return;
    }

    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.setIsolationLevelQuery(value, {
      parent: transaction.parent
    });

    if (!sql) return;

    return await this.sequelize.query(sql, options);
  }

  async startTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to start a transaction without transaction object!');
    }

    options = { ...options, transaction: transaction.parent || transaction };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.startTransactionQuery(transaction);

    return await this.sequelize.query(sql, options);
  }

  async deferConstraints(transaction, options) {
    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.deferConstraintsQuery(options);

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async commitTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to commit a transaction without transaction object!');
    }
    if (transaction.parent) {
      // Savepoints cannot be committed
      return;
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };

    const sql = this.queryGenerator.commitTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'commit';

    return await promise;
  }

  async rollbackTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to rollback a transaction without transaction object!');
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'rollback';

    return await promise;
  }
}

exports.QueryInterface = QueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Dot = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const uuid = __webpack_require__(/*! uuid */ "uuid").v4;

class AbstractQuery {

  constructor(connection, sequelize, options) {
    this.uuid = uuid();
    this.connection = connection;
    this.instance = options.instance;
    this.model = options.model;
    this.sequelize = sequelize;
    this.options = {
      plain: false,
      raw: false,
      // eslint-disable-next-line no-console
      logging: console.log,
      ...options
    };
    this.checkLoggingOption();
  }

  /**
   * rewrite query with parameters
   *
   * Examples:
   *
   *   query.formatBindParameters('select $1 as foo', ['fooval']);
   *
   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });
   *
   * Options
   *   skipUnescape: bool, skip unescaping $$
   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available
   *
   * @param {string} sql
   * @param {object|Array} values
   * @param {string} dialect
   * @param {Function} [replacementFunc]
   * @param {object} [options]
   * @private
   */
  static formatBindParameters(sql, values, dialect, replacementFunc, options) {
    if (!values) {
      return [sql, []];
    }

    options = options || {};
    if (typeof replacementFunc !== 'function') {
      options = replacementFunc || {};
      replacementFunc = undefined;
    }

    if (!replacementFunc) {
      if (options.skipValueReplace) {
        replacementFunc = (match, key, values) => {
          if (values[key] !== undefined) {
            return match;
          }
          return undefined;
        };
      } else {
        replacementFunc = (match, key, values, timeZone, dialect) => {
          if (values[key] !== undefined) {
            return SqlString.escape(values[key], timeZone, dialect);
          }
          return undefined;
        };
      }
    } else if (options.skipValueReplace) {
      const origReplacementFunc = replacementFunc;
      replacementFunc = (match, key, values, timeZone, dialect, options) => {
        if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {
          return match;
        }
        return undefined;
      };
    }

    const timeZone = null;
    const list = Array.isArray(values);
    sql = sql.replace(/\B\$(\$|\w+)/g, (match, key) => {
      if ('$' === key) {
        return options.skipUnescape ? match : key;
      }

      let replVal;
      if (list) {
        if (key.match(/^[1-9]\d*$/)) {
          key = key - 1;
          replVal = replacementFunc(match, key, values, timeZone, dialect, options);
        }
      } else if (!key.match(/^\d*$/)) {
        replVal = replacementFunc(match, key, values, timeZone, dialect, options);
      }
      if (replVal === undefined) {
        throw new Error(`Named bind parameter "${match}" has no value in the given object.`);
      }
      return replVal;
    });
    return [sql, []];
  }

  /**
   * Execute the passed sql query.
   *
   * Examples:
   *
   *     query.run('SELECT 1')
   *
   * @private
   */
  run() {
    throw new Error('The run method wasn\'t overwritten!');
  }

  /**
   * Check the logging option of the instance and print deprecation warnings.
   *
   * @private
   */
  checkLoggingOption() {
    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }
  }

  /**
   * Get the attributes of an insert query, which contains the just inserted id.
   *
   * @returns {string} The field name.
   * @private
   */
  getInsertIdField() {
    return 'insertId';
  }

  getUniqueConstraintErrorMessage(field) {
    let message = field ? `${field} must be unique` : 'Must be unique';

    if (field && this.model) {
      for (const key of Object.keys(this.model.uniqueKeys)) {
        if (this.model.uniqueKeys[key].fields.includes(field.replace(/"/g, ''))) {
          if (this.model.uniqueKeys[key].msg) {
            message = this.model.uniqueKeys[key].msg;
          }
        }
      }
    }
    return message;
  }

  isRawQuery() {
    return this.options.type === QueryTypes.RAW;
  }

  isVersionQuery() {
    return this.options.type === QueryTypes.VERSION;
  }

  isUpsertQuery() {
    return this.options.type === QueryTypes.UPSERT;
  }

  isInsertQuery(results, metaData) {
    let result = true;

    if (this.options.type === QueryTypes.INSERT) {
      return true;
    }

    // is insert query if sql contains insert into
    result = result && this.sql.toLowerCase().startsWith('insert into');

    // is insert query if no results are passed or if the result has the inserted id
    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));

    // is insert query if no metadata are passed or if the metadata has the inserted id
    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));

    return result;
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;

      id = id || results && results[this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];

      this.instance[autoIncrementAttribute] = id;
    }
  }

  isShowTablesQuery() {
    return this.options.type === QueryTypes.SHOWTABLES;
  }

  handleShowTablesQuery(results) {
    return _.flatten(results.map(resultSet => Object.values(resultSet)));
  }

  isShowIndexesQuery() {
    return this.options.type === QueryTypes.SHOWINDEXES;
  }

  isShowConstraintsQuery() {
    return this.options.type === QueryTypes.SHOWCONSTRAINTS;
  }

  isDescribeQuery() {
    return this.options.type === QueryTypes.DESCRIBE;
  }

  isSelectQuery() {
    return this.options.type === QueryTypes.SELECT;
  }

  isBulkUpdateQuery() {
    return this.options.type === QueryTypes.BULKUPDATE;
  }

  isBulkDeleteQuery() {
    return this.options.type === QueryTypes.BULKDELETE;
  }

  isForeignKeysQuery() {
    return this.options.type === QueryTypes.FOREIGNKEYS;
  }

  isUpdateQuery() {
    return this.options.type === QueryTypes.UPDATE;
  }

  handleSelectQuery(results) {
    let result = null;

    // Map raw fields to names if a mapping is provided
    if (this.options.fieldMap) {
      const fieldMap = this.options.fieldMap;
      results = results.map(result => _.reduce(fieldMap, (result, name, field) => {
        if (result[field] !== undefined && name !== field) {
          result[name] = result[field];
          delete result[field];
        }
        return result;
      }, result));
    }

    // Raw queries
    if (this.options.raw) {
      result = results.map(result => {
        let o = {};

        for (const key in result) {
          if (Object.prototype.hasOwnProperty.call(result, key)) {
            o[key] = result[key];
          }
        }

        if (this.options.nest) {
          o = Dot.transform(o);
        }

        return o;
      });
    // Queries with include
    } else if (this.options.hasJoin === true) {
      results = AbstractQuery._groupJoinData(results, {
        model: this.model,
        includeMap: this.options.includeMap,
        includeNames: this.options.includeNames
      }, {
        checkExisting: this.options.hasMultiAssociation
      });

      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        include: this.options.include,
        includeNames: this.options.includeNames,
        includeMap: this.options.includeMap,
        includeValidated: true,
        attributes: this.options.originalAttributes || this.options.attributes,
        raw: true
      });
    // Regular queries
    } else {
      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        raw: true,
        attributes: this.options.originalAttributes || this.options.attributes
      });
    }

    // return the first real model instance if options.plain is set (e.g. Model.find)
    if (this.options.plain) {
      result = result.length === 0 ? null : result[0];
    }
    return result;
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith('show');
    result = result || this.sql.toLowerCase().startsWith('describe');

    return result;
  }

  isCallQuery() {
    return this.sql.toLowerCase().startsWith('call');
  }

  /**
   * @param {string} sql
   * @param {Function} debugContext
   * @param {Array|object} parameters
   * @protected
   * @returns {Function} A function to call after the query was completed.
   */
  _logQuery(sql, debugContext, parameters) {
    const { connection, options } = this;
    const benchmark = this.sequelize.options.benchmark || options.benchmark;
    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;
    const startTime = Date.now();
    let logParameter = '';

    if (logQueryParameters && parameters) {
      const delimiter = sql.endsWith(';') ? '' : ';';
      let paramStr;
      if (Array.isArray(parameters)) {
        paramStr = parameters.map(p=>JSON.stringify(p)).join(', ');
      } else {
        paramStr = JSON.stringify(parameters);
      }
      logParameter = `${delimiter} ${paramStr}`;
    }
    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;
    const msg = `Executing ${fmt}`;
    debugContext(msg);
    if (!benchmark) {
      this.sequelize.log(`Executing ${fmt}`, options);
    }
    return () => {
      const afterMsg = `Executed ${fmt}`;
      debugContext(afterMsg);
      if (benchmark) {
        this.sequelize.log(afterMsg, Date.now() - startTime, options);
      }
    };
  }

  /**
   * The function takes the result of the query execution and groups
   * the associated data by the callee.
   *
   * Example:
   *   groupJoinData([
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 1 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 2 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 3 }
   *     }
   *   ])
   *
   * Result:
   *   Something like this:
   *
   *   [
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: [
   *         { foo: 'bar', id: 1 },
   *         { foo: 'bar', id: 2 },
   *         { foo: 'bar', id: 3 }
   *       ]
   *     }
   *   ]
   *
   * @param {Array} rows
   * @param {object} includeOptions
   * @param {object} options
   * @private
   */
  static _groupJoinData(rows, includeOptions, options) {

    /*
     * Assumptions
     * ID is not necessarily the first field
     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)
     * Parent keys will be seen before any include/child keys
     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)
     */

    /*
     * Author (MH) comment: This code is an unreadable mess, but it's performant.
     * groupJoinData is a performance critical function so we prioritize perf over readability.
     */
    if (!rows.length) {
      return [];
    }

    // Generic looping
    let i;
    let length;
    let $i;
    let $length;
    // Row specific looping
    let rowsI;
    let row;
    const rowsLength = rows.length;
    // Key specific looping
    let keys;
    let key;
    let keyI;
    let keyLength;
    let prevKey;
    let values;
    let topValues;
    let topExists;
    const checkExisting = options.checkExisting;
    // If we don't have to deduplicate we can pre-allocate the resulting array
    let itemHash;
    let parentHash;
    let topHash;
    const results = checkExisting ? [] : new Array(rowsLength);
    const resultMap = {};
    const includeMap = {};
    // Result variables for the respective functions
    let $keyPrefix;
    let $keyPrefixString;
    let $prevKeyPrefixString; // eslint-disable-line
    let $prevKeyPrefix;
    let $lastKeyPrefix;
    let $current;
    let $parent;
    // Map each key to an include option
    let previousPiece;
    const buildIncludeMap = piece => {
      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {
        includeMap[key] = $current = $current.includeMap[piece];
        if (previousPiece) {
          previousPiece = `${previousPiece}.${piece}`;
        } else {
          previousPiece = piece;
        }
        includeMap[previousPiece] = $current;
      }
    };
    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')
    const keyPrefixStringMemo = {};
    const keyPrefixString = (key, memo) => {
      if (!Object.prototype.hasOwnProperty.call(memo, key)) {
        memo[key] = key.substr(0, key.lastIndexOf('.'));
      }
      return memo[key];
    };
    // Removes the prefix from a key ('id' for 'User.Results.id')
    const removeKeyPrefixMemo = {};
    const removeKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {
        const index = key.lastIndexOf('.');
        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);
      }
      return removeKeyPrefixMemo[key];
    };
    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')
    const keyPrefixMemo = {};
    const keyPrefix = key => {
      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values
      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {
        const prefixString = keyPrefixString(key, keyPrefixStringMemo);
        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {
          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];
        }
        keyPrefixMemo[key] = keyPrefixMemo[prefixString];
      }
      return keyPrefixMemo[key];
    };
    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')
    const lastKeyPrefixMemo = {};
    const lastKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {
        const prefix = keyPrefix(key);
        const length = prefix.length;

        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];
      }
      return lastKeyPrefixMemo[key];
    };
    const getUniqueKeyAttributes = model => {
      let uniqueKeyAttributes = _.chain(model.uniqueKeys);
      uniqueKeyAttributes = uniqueKeyAttributes
        .result(`${uniqueKeyAttributes.findKey()}.fields`)
        .map(field => _.findKey(model.attributes, chr => chr.field === field))
        .value();

      return uniqueKeyAttributes;
    };
    const stringify = obj => obj instanceof Buffer ? obj.toString('hex') : obj;
    let primaryKeyAttributes;
    let uniqueKeyAttributes;
    let prefix;

    for (rowsI = 0; rowsI < rowsLength; rowsI++) {
      row = rows[rowsI];

      // Keys are the same for all rows, so only need to compute them on the first row
      if (rowsI === 0) {
        keys = Object.keys(row);
        keyLength = keys.length;
      }

      if (checkExisting) {
        topExists = false;

        // Compute top level hash key (this is usually just the primary key values)
        $length = includeOptions.model.primaryKeyAttributes.length;
        topHash = '';
        if ($length === 1) {
          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);
        }
        else if ($length > 1) {
          for ($i = 0; $i < $length; $i++) {
            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);
          }
        }
        else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {
          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);
          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
            topHash += row[uniqueKeyAttributes[$i]];
          }
        }
      }

      topValues = values = {};
      $prevKeyPrefix = undefined;
      for (keyI = 0; keyI < keyLength; keyI++) {
        key = keys[keyI];

        // The string prefix isn't actualy needed
        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix
        // TODO: Find a better way?
        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);
        $keyPrefix = keyPrefix(key);

        // On the first row we compute the includeMap
        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {
          if (!$keyPrefix.length) {
            includeMap[key] = includeMap[''] = includeOptions;
          } else {
            $current = includeOptions;
            previousPiece = undefined;
            $keyPrefix.forEach(buildIncludeMap);
          }
        }
        // End of key set
        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {
          if (checkExisting) {
            // Compute hash key for this set instance
            // TODO: Optimize
            length = $prevKeyPrefix.length;
            $parent = null;
            parentHash = null;

            if (length) {
              for (i = 0; i < length; i++) {
                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                $length = primaryKeyAttributes.length;
                itemHash = prefix;
                if ($length === 1) {
                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
                }
                else if ($length > 1) {
                  for ($i = 0; $i < $length; $i++) {
                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
                  }
                }
                else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
                  }
                }
                if (!parentHash) {
                  parentHash = topHash;
                }

                itemHash = parentHash + itemHash;
                $parent = prefix;
                if (i < length - 1) {
                  parentHash = itemHash;
                }
              }
            } else {
              itemHash = topHash;
            }

            if (itemHash === topHash) {
              if (!resultMap[itemHash]) {
                resultMap[itemHash] = values;
              } else {
                topExists = true;
              }
            } else if (!resultMap[itemHash]) {
              $parent = resultMap[parentHash];
              $lastKeyPrefix = lastKeyPrefix(prevKey);

              if (includeMap[prevKey].association.isSingleAssociation) {
                if ($parent) {
                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                }
              } else {
                if (!$parent[$lastKeyPrefix]) {
                  $parent[$lastKeyPrefix] = [];
                }
                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
              }
            }

            // Reset values
            values = {};
          } else {
            // If checkExisting is false it's because there's only 1:1 associations in this query
            // However we still need to map onto the appropriate parent
            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop
            $current = topValues;
            length = $keyPrefix.length;
            if (length) {
              for (i = 0; i < length; i++) {
                if (i === length - 1) {
                  values = $current[$keyPrefix[i]] = {};
                }
                $current = $current[$keyPrefix[i]] || {};
              }
            }
          }
        }

        // End of iteration, set value and set prev values (for next iteration)
        values[removeKeyPrefix(key)] = row[key];
        prevKey = key;
        $prevKeyPrefix = $keyPrefix;
        $prevKeyPrefixString = $keyPrefixString;
      }

      if (checkExisting) {
        length = $prevKeyPrefix.length;
        $parent = null;
        parentHash = null;

        if (length) {
          for (i = 0; i < length; i++) {
            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
            $length = primaryKeyAttributes.length;
            itemHash = prefix;
            if ($length === 1) {
              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
            }
            else if ($length > 0) {
              for ($i = 0; $i < $length; $i++) {
                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
              }
            }
            else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
              }
            }
            if (!parentHash) {
              parentHash = topHash;
            }

            itemHash = parentHash + itemHash;
            $parent = prefix;
            if (i < length - 1) {
              parentHash = itemHash;
            }
          }
        } else {
          itemHash = topHash;
        }

        if (itemHash === topHash) {
          if (!resultMap[itemHash]) {
            resultMap[itemHash] = values;
          } else {
            topExists = true;
          }
        } else if (!resultMap[itemHash]) {
          $parent = resultMap[parentHash];
          $lastKeyPrefix = lastKeyPrefix(prevKey);

          if (includeMap[prevKey].association.isSingleAssociation) {
            if ($parent) {
              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
            }
          } else {
            if (!$parent[$lastKeyPrefix]) {
              $parent[$lastKeyPrefix] = [];
            }
            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
          }
        }
        if (!topExists) {
          results.push(topValues);
        }
      } else {
        results[rowsI] = topValues;
      }
    }

    return results;
  }
}

module.exports = AbstractQuery;
module.exports.AbstractQuery = AbstractQuery;
module.exports.default = AbstractQuery;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract sync recursive":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/ sync ***!
  \************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize/lib/dialects/abstract sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mariadb');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mariadb');

/**
 * MariaDB Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MariaDB specific connections
 * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mariadb');
    this.refreshTypeParser(DataTypes);
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  /**
   * Connect with MariaDB database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    // Named timezone is not supported in mariadb, convert to offset
    let tzOffset = this.sequelize.options.timezone;
    tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')
      : tzOffset;

    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      password: config.password,
      database: config.database,
      timezone: tzOffset,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      foundRows: false,
      ...config.dialectOptions
    };

    if (!this.sequelize.config.keepDefaultTimezone) {
      // set timezone for this connection
      if (connectionConfig.initSql) {
        if (!Array.isArray(
          connectionConfig.initSql)) {
          connectionConfig.initSql = [connectionConfig.initSql];
        }
        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);
      } else {
        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;
      }
    }

    try {
      const connection = await this.lib.createConnection(connectionConfig);
      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });
      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
        case 'ENETUNREACH':
        case 'EADDRNOTAVAIL':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (!connection.isValid()) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }
    return await connection.end();
  }

  validate(connection) {
    return connection && connection.isValid();
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");

module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';

  /**
   * types: [buffer_type, ...]
   *
   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types
   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js
   */

  BaseTypes.DATE.types.mariadb = ['DATETIME'];
  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];
  BaseTypes.CHAR.types.mariadb = ['STRING'];
  BaseTypes.TEXT.types.mariadb = ['BLOB'];
  BaseTypes.TINYINT.types.mariadb = ['TINY'];
  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];
  BaseTypes.INTEGER.types.mariadb = ['LONG'];
  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];
  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];
  BaseTypes.TIME.types.mariadb = ['TIME'];
  BaseTypes.DATEONLY.types.mariadb = ['DATE'];
  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];
  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mariadb = false;
  BaseTypes.ENUM.types.mariadb = false;
  BaseTypes.REAL.types.mariadb = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];
  BaseTypes.JSON.types.mariadb = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      return date.format('YYYY-MM-DD HH:mm:ss.SSS');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
      }
      else {
        this.sqlType = this.type;
      }
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value
        : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mariadb/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js");
const { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;

class MariadbDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MariadbDialect.prototype.supports = _.merge(
  _.cloneDeep(AbstractDialect.prototype.supports), {
    'VALUES ()': true,
    'LIMIT ON UPDATE': true,
    lock: true,
    forShare: 'LOCK IN SHARE MODE',
    settingIsolationLevelDuringTransaction: false,
    schemas: true,
    inserts: {
      ignoreDuplicates: ' IGNORE',
      updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
    },
    index: {
      collate: false,
      length: true,
      parser: true,
      type: true,
      using: 1
    },
    constraints: {
      dropConstraint: false,
      check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: true,
    JSON: true,
    REGEXP: true
  });

MariadbDialect.prototype.defaultVersion = '10.1.44';
MariadbDialect.prototype.Query = Query;
MariadbDialect.prototype.QueryGenerator = QueryGenerator;
MariadbDialect.prototype.DataTypes = DataTypes;
MariadbDialect.prototype.name = 'mariadb';
MariadbDialect.prototype.TICK_CHAR = '`';
MariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;
MariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;

module.exports = MariadbDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const Utils = __webpack_require__(/*! ./../../utils */ "./node_modules/sequelize/lib/utils.js");

class MariaDBQueryGenerator extends MySQLQueryGenerator {
  createSchema(schema, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE SCHEMA IF NOT EXISTS',
      this.quoteIdentifier(schema),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;
  }

  showSchemasQuery(options) {
    const schemasToSkip = [
      '\'MYSQL\'',
      '\'INFORMATION_SCHEMA\'',
      '\'PERFORMANCE_SCHEMA\''
    ];
    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {
      for (const schemaName of options.skip) {
        schemasToSkip.push(this.escape(schemaName));
      }
    }
    return Utils.joinSQLFragments([
      'SELECT SCHEMA_NAME as schema_name',
      'FROM INFORMATION_SCHEMA.SCHEMATA',
      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(', ')})`,
      ';'
    ]);
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\')';
    }
    return `${query};`;
  }
}

module.exports = MariaDBQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mariadb');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      results = await connection.query(this.sql, parameters);
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MariaDB automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MariaDB automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          // ONLY TRUE IF @auto_increment_increment is set to 1 !!
          // Doesn't work with GALERA => each node will reserve increment (x for first server, x+1 for next node...)
          const startId = data[this.getInsertIdField()];
          result = new Array(data.affectedRows);
          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;
          for (let i = 0; i < data.affectedRows; i++) {
            result[i] = { [pkField]: startId + i };
          }
          return [result, data.affectedRows];
        }

        return [data[this.getInsertIdField()], data.affectedRows];
      }
    }

    if (this.isSelectQuery()) {
      this.handleJsonSelectQuery(data);
      return this.handleSelectQuery(data);
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isRawQuery()) {
      const meta = data.meta;
      delete data.meta;
      return [data, meta];
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        result[_result.Field] = {
          type: _result.Type.toLowerCase().startsWith('enum') ? _result.Type.replace(/^enum/i,
            'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }

    return result;
  }

  handleJsonSelectQuery(rows) {
    if (!this.model || !this.model.fieldRawAttributesMap) {
      return;
    }
    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {
      const modelField = this.model.fieldRawAttributesMap[_field];
      if (modelField.type instanceof DataTypes.JSON) {
        // Value is returned as String, not JSON
        rows = rows.map(row => {
          row[modelField.fieldName] = row[modelField.fieldName] ? JSON.parse(
            row[modelField.fieldName]) : null;
          if (DataTypes.JSON.parse) {
            return DataTypes.JSON.parse(modelField, this.sequelize.options,
              row[modelField.fieldName]);
          }
          return row;
        });
      }
    }
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MariaDB Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    switch (err.errno) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(
          /Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?\s.*$/);

        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: err.errno === ER_ROW_IS_REFERENCED ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => ({
      tableName: resultSet.TABLE_NAME,
      schema: resultSet.TABLE_SCHEMA
    }));
  }

  handleShowIndexesQuery(data) {

    let currItem;
    const result = [];

    data.forEach(item => {
      if (!currItem || currItem.name !== item.Key_name) {
        currItem = {
          primary: item.Key_name === 'PRIMARY',
          fields: [],
          name: item.Key_name,
          tableName: item.Table,
          unique: item.Non_unique !== 1,
          type: item.Index_type
        };
        result.push(currItem);
      }

      currItem.fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
    });

    return result;
  }
}

module.exports = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ../../errors/base-error */ "./node_modules/sequelize/lib/errors/base-error.js");
const ConnectionError = __webpack_require__(/*! ../../errors/connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is closed while an operation is in progress
 */
class AsyncQueueError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAsyncQueueError';
  }
}

exports.AsyncQueueError = AsyncQueueError;

class AsyncQueue {
  constructor() {
    this.previous = Promise.resolve();
    this.closed = false;
    this.rejectCurrent = () => {};
  }
  close() {
    this.closed = true;
    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));
  }
  enqueue(asyncFunction) {
    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).
    // However, this ensures that this.previous will never be a rejected promise so the queue will
    // always keep going, while still communicating rejection from asyncFunction to the user.
    return new Promise((resolve, reject) => {
      this.previous = this.previous.then(
        () => {
          this.rejectCurrent = reject;
          if (this.closed) {
            return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));
          }
          return asyncFunction().then(resolve, reject);
        }
      );
    });
  }
}

exports.default = AsyncQueue;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const AsyncQueue = __webpack_require__(/*! ./async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").default;
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const debug = logger.debugContext('connection:mssql');
const debugTedious = logger.debugContext('connection:mssql:tedious');

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 1433;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('tedious');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async connect(config) {
    const connectionConfig = {
      server: config.host,
      authentication: {
        type: 'default',
        options: {
          userName: config.username || undefined,
          password: config.password || undefined
        }
      },
      options: {
        port: parseInt(config.port, 10),
        database: config.database,
        trustServerCertificate: true
      }
    };

    if (config.dialectOptions) {
      // only set port if no instance name was provided
      if (
        config.dialectOptions.options &&
        config.dialectOptions.options.instanceName
      ) {
        delete connectionConfig.options.port;
      }

      if (config.dialectOptions.authentication) {
        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);
      }

      Object.assign(connectionConfig.options, config.dialectOptions.options);
    }

    try {
      return await new Promise((resolve, reject) => {
        const connection = new this.lib.Connection(connectionConfig);
        if (connection.state === connection.STATE.INITIALIZED) {
          connection.connect();
        }
        connection.queue = new AsyncQueue();
        connection.lib = this.lib;

        const connectHandler = error => {
          connection.removeListener('end', endHandler);
          connection.removeListener('error', errorHandler);

          if (error) return reject(error);

          debug('connection acquired');
          resolve(connection);
        };

        const endHandler = () => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', errorHandler);
          reject(new Error('Connection was closed by remote server'));
        };

        const errorHandler = error => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('end', endHandler);
          reject(error);
        };

        connection.once('error', errorHandler);
        connection.once('end', endHandler);
        connection.once('connect', connectHandler);

        /*
         * Permanently attach this event before connection is even acquired
         * tedious sometime emits error even after connect(with error).
         *
         * If we dont attach this even that unexpected error event will crash node process
         *
         * E.g. connectTimeout is set higher than requestTimeout
         */
        connection.on('error', error => {
          switch (error.code) {
            case 'ESOCKET':
            case 'ECONNRESET':
              this.pool.destroy(connection);
          }
        });

        if (config.dialectOptions && config.dialectOptions.debug) {
          connection.on('debug', debugTedious.log.bind(debugTedious));
        }
      });
    } catch (error) {
      if (!error.code) {
        throw new sequelizeErrors.ConnectionError(error);
      }

      switch (error.code) {
        case 'ESOCKET':
          if (error.message.includes('connect EHOSTUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect ENETUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect EADDRNOTAVAIL')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('getaddrinfo ENOTFOUND')) {
            throw new sequelizeErrors.HostNotFoundError(error);
          }
          if (error.message.includes('connect ECONNREFUSED')) {
            throw new sequelizeErrors.ConnectionRefusedError(error);
          }
          throw new sequelizeErrors.ConnectionError(error);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ELOGIN':
          throw new sequelizeErrors.AccessDeniedError(error);
        case 'EINVAL':
          throw new sequelizeErrors.InvalidConnectionError(error);
        default:
          throw new sequelizeErrors.ConnectionError(error);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect a connection that is already disconnected
    if (connection.closed) {
      return;
    }

    connection.queue.close();

    return new Promise(resolve => {
      connection.on('end', resolve);
      connection.close();
      debug('connection closed');
    });
  }

  validate(connection) {
    return connection && connection.loggedIn;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const moment = __webpack_require__(/*! moment */ "moment");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');

  /**
   * Removes unsupported MSSQL options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types: [hex, ...]
   *
   * @see hex here https://github.com/tediousjs/tedious/blob/master/src/data-type.ts
   */

  BaseTypes.DATE.types.mssql = [43];
  BaseTypes.STRING.types.mssql = [231, 173];
  BaseTypes.CHAR.types.mssql = [175];
  BaseTypes.TEXT.types.mssql = false;
  // https://msdn.microsoft.com/en-us/library/ms187745(v=sql.110).aspx
  BaseTypes.TINYINT.types.mssql = [30];
  BaseTypes.SMALLINT.types.mssql = [34];
  BaseTypes.MEDIUMINT.types.mssql = false;
  BaseTypes.INTEGER.types.mssql = [38];
  BaseTypes.BIGINT.types.mssql = false;
  BaseTypes.FLOAT.types.mssql = [109];
  BaseTypes.TIME.types.mssql = [41];
  BaseTypes.DATEONLY.types.mssql = [40];
  BaseTypes.BOOLEAN.types.mssql = [104];
  BaseTypes.BLOB.types.mssql = [165];
  BaseTypes.DECIMAL.types.mssql = [106];
  BaseTypes.UUID.types.mssql = false;
  BaseTypes.ENUM.types.mssql = false;
  BaseTypes.REAL.types.mssql = [109];
  BaseTypes.DOUBLE.types.mssql = [109];
  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported
  BaseTypes.GEOMETRY.types.mssql = false;

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');
          return 'VARBINARY(256)';
        }
        warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');
      }
      return 'VARBINARY(MAX)';
    }
    _hexify(hex) {
      return `0x${hex}`;
    }
  }


  class STRING extends BaseTypes.STRING {
    toSql() {
      if (!this._binary) {
        return `NVARCHAR(${this._length})`;
      }
      return `BINARY(${this._length})`;
    }
    _stringify(value, options) {
      if (this._binary) {
        return BLOB.prototype._stringify(value);
      }
      return options.escape(value);
    }
    _bindParam(value, options) {
      return options.bindParam(this._binary ? Buffer.from(value) : value);
    }
  }

  STRING.prototype.escape = false;

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.
      // Using unicode is just future proof
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');
          return 'NVARCHAR(256)';
        }
        warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');
      }
      return 'NVARCHAR(MAX)';
    }
  }

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BIT';
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36)';
    }
  }

  class NOW extends BaseTypes.NOW {
    toSql() {
      return 'GETDATE()';
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'DATETIMEOFFSET';
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return moment(value).format('YYYY-MM-DD');
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class REAL extends BaseTypes.REAL {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does not support any options for real
      if (this._length || this.options.length || this._unsigned || this._zerofill) {
        warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._unsigned = undefined;
        this._zerofill = undefined;
      }
    }
  }
  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does only support lengths as option.
      // Values between 1-24 result in 7 digits precision (4 bytes storage size)
      // Values between 25-53 result in 15 digits precision (8 bytes storage size)
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
      }
      if (this._unsigned) {
        warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'VARCHAR(255)';
    }
  }

  return {
    BLOB,
    BOOLEAN,
    ENUM,
    STRING,
    UUID,
    DATE,
    DATEONLY,
    NOW,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    REAL,
    FLOAT,
    TEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mssql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js");

class MssqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);
  }
}

MssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': true,
  'DEFAULT VALUES': true,
  'LIMIT ON UPDATE': true,
  'ORDER NULLS': false,
  lock: false,
  transactions: true,
  migrations: false,
  returnValues: {
    output: true
  },
  schemas: true,
  autoIncrement: {
    identityInsert: true,
    defaultValue: false,
    update: false
  },
  constraints: {
    restrict: false,
    default: true
  },
  index: {
    collate: false,
    length: false,
    parser: false,
    type: true,
    using: false,
    where: true
  },
  NUMERIC: true,
  tmpTableTrigger: true
});

MssqlDialect.prototype.defaultVersion = '12.0.2000'; // SQL Server 2014 Express
MssqlDialect.prototype.Query = Query;
MssqlDialect.prototype.name = 'mssql';
MssqlDialect.prototype.TICK_CHAR = '"';
MssqlDialect.prototype.TICK_CHAR_LEFT = '[';
MssqlDialect.prototype.TICK_CHAR_RIGHT = ']';
MssqlDialect.prototype.DataTypes = DataTypes;

module.exports = MssqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const TableHints = __webpack_require__(/*! ../../table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const randomBytes = __webpack_require__(/*! crypto */ "crypto").randomBytes;
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");

/* istanbul ignore next */
const throwMethodUndefined = function(methodName) {
  throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};

class MSSQLQueryGenerator extends AbstractQueryGenerator {
  createDatabaseQuery(databaseName, options) {
    options = { collate: null, ...options };

    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';

    return [
      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'CREATE DATABASE', this.quoteIdentifier(databaseName),
      `${collation};`,
      'END;'
    ].join(' ');
  }

  dropDatabaseQuery(databaseName) {
    return [
      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',
      'END;'
    ].join(' ');
  }

  createSchema(schema) {
    return [
      'IF NOT EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', wrapSingleQuote(schema), ')',
      'BEGIN',
      "EXEC sp_executesql N'CREATE SCHEMA",
      this.quoteIdentifier(schema),
      ";'",
      'END;'
    ].join(' ');
  }

  dropSchema(schema) {
    // Mimics Postgres CASCADE, will drop objects belonging to the schema
    const quotedSchema = wrapSingleQuote(schema);
    return [
      'IF EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', quotedSchema, ')',
      'BEGIN',
      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',
      'DECLARE @cascade TABLE (',
      'id INT NOT NULL IDENTITY PRIMARY KEY,',
      'ms_sql NVARCHAR(2000) NOT NULL );',
      'INSERT INTO @cascade ( ms_sql )',
      "SELECT CASE WHEN o.type IN ('F','PK')",
      "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'",
      "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END",
      'FROM sys.objects o',
      'JOIN sys.schemas s on o.schema_id = s.schema_id',
      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',
      "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ", quotedSchema,
      'ORDER BY o.type ASC;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'WHILE @id IS NOT NULL',
      'BEGIN',
      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',
      'BEGIN CATCH BREAK; THROW; END CATCH;',
      'DELETE FROM @cascade WHERE id = @id;',
      'SELECT @id = NULL, @ms_sql = NULL;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'END',
      "EXEC sp_executesql N'DROP SCHEMA", this.quoteIdentifier(schema), ";'",
      'END;'
    ].join(' ');
  }

  showSchemasQuery() {
    return [
      'SELECT "name" as "schema_name" FROM sys.schemas as s',
      'WHERE "s"."name" NOT IN (',
      "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'",
      ')', 'AND', '"s"."name" NOT LIKE', "'db_%'"
    ].join(' ');
  }

  versionQuery() {
    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch
    return [
      'DECLARE @ms_ver NVARCHAR(20);',
      "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));",
      "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"
    ].join(' ');
  }

  createTableQuery(tableName, attributes, options) {
    const primaryKeys = [],
      foreignKeys = {},
      attributesClauseParts = [];

    let commentStr = '';

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        let dataType = attributes[attr];
        let match;

        if (dataType.includes('COMMENT ')) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace('COMMENT', '').trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          // remove comment related substring from dataType
          dataType = commentMatch[1];
        }

        if (dataType.includes('PRIMARY KEY')) {
          primaryKeys.push(attr);

          if (dataType.includes('REFERENCES')) {
            // MSSQL doesn't support inline REFERENCES declarations: move to the end
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
          }
        } else if (dataType.includes('REFERENCES')) {
          // MSSQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }

    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClauseParts.push(`CONSTRAINT ${
            this.quoteIdentifier(indexName)
          } UNIQUE (${
            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')
          })`);
        }
      });
    }

    if (pkString.length > 0) {
      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
      }
    }

    const quotedTableName = this.quoteTable(tableName);

    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,
      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,
      ';',
      commentStr
    ]);
  }

  describeTableQuery(tableName, schema) {
    let sql = [
      'SELECT',
      "c.COLUMN_NAME AS 'Name',",
      "c.DATA_TYPE AS 'Type',",
      "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',",
      "c.IS_NULLABLE as 'IsNull',",
      "COLUMN_DEFAULT AS 'Default',",
      "pk.CONSTRAINT_TYPE AS 'Constraint',",
      "COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',",
      "CAST(prop.value AS NVARCHAR) AS 'Comment'",
      'FROM',
      'INFORMATION_SCHEMA.TABLES t',
      'INNER JOIN',
      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',
      'cu.column_name, tc.CONSTRAINT_TYPE ',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',
      'and tc.constraint_name=cu.constraint_name ',
      'and tc.CONSTRAINT_TYPE=\'PRIMARY KEY\') pk ',
      'ON pk.table_schema=c.table_schema ',
      'AND pk.table_name=c.table_name ',
      'AND pk.column_name=c.column_name ',
      'INNER JOIN sys.columns AS sc',
      "ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name",
      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',
      'AND prop.minor_id = sc.column_id',
      "AND prop.name = 'MS_Description'",
      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)
    ].join(' ');

    if (schema) {
      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;
    }

    return sql;
  }

  renameTableQuery(before, after) {
    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;
  }

  showTablesQuery() {
    return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';";
  }

  dropTableQuery(tableName) {
    const quoteTbl = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,
      'DROP TABLE',
      quoteTbl,
      ';'
    ]);
  }

  addColumnQuery(table, key, dataType) {
    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery
    //        but instead we need to pass the key along as the field here
    dataType.field = key;
    let commentStr = '';

    if (dataType.comment && _.isString(dataType.comment)) {
      commentStr = this.commentTemplate(dataType.comment, table, key);
      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key
      // is present. This is needed for createTable statement where that part is extracted with regex.
      // Here we can intercept the object and remove comment property since we have the original object.
      delete dataType['comment'];
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, { context: 'addColumn' }),
      ';',
      commentStr
    ]);
  }

  commentTemplate(comment, table, column) {
    return ' EXEC sp_addextendedproperty ' +
        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +
        '@level0type = N\'Schema\', @level0name = \'dbo\', ' +
        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +
        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP COLUMN',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [],
      constraintString = [];
    let commentString = '';

    for (const attributeName in attributes) {
      const quotedAttrName = this.quoteIdentifier(attributeName);
      let definition = attributes[attributeName];
      if (definition.includes('COMMENT ')) {
        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
        const commentText = commentMatch[2].replace('COMMENT', '').trim();
        commentString += this.commentTemplate(commentText, tableName, attributeName);
        // remove comment related substring from dataType
        definition = commentMatch[1];
      }
      if (definition.includes('REFERENCES')) {
        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);
      } else {
        attrString.push(`${quotedAttrName} ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';',
      commentString
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const newName = Object.keys(attributes)[0];
    return Utils.joinSQLFragments([
      'EXEC sp_rename',
      `'${this.quoteTable(tableName)}.${attrBefore}',`,
      `'${newName}',`,
      "'COLUMN'",
      ';'
    ]);
  }

  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    const quotedTable = this.quoteTable(tableName);
    options = options || {};
    attributes = attributes || {};

    const tuples = [];
    const allAttributes = [];
    const allQueries = [];

    let needIdentityInsertWrapper = false,
      outputFragment = '';

    if (options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      outputFragment = returnValues.outputFragment;
    }

    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;

    attrValueHashes.forEach(attrValueHash => {
      // special case for empty objects with primary keys
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
        allQueries.push(emptyQuery);
        return;
      }

      // normal case
      _.forOwn(attrValueHash, (value, key) => {
        if (value !== null && attributes[key] && attributes[key].autoIncrement) {
          needIdentityInsertWrapper = true;
        }

        if (!allAttributes.includes(key)) {
          if (value === null && attributes[key] && attributes[key].autoIncrement)
            return;

          allAttributes.push(key);
        }
      });
    });

    if (allAttributes.length > 0) {
      attrValueHashes.forEach(attrValueHash => {
        tuples.push(`(${
          allAttributes.map(key =>
            this.escape(attrValueHash[key])).join(',')
        })`);
      });

      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);
    }
    const commands = [];
    let offset = 0;
    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;
    while (offset < Math.max(tuples.length, 1)) {
      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');
      if (needIdentityInsertWrapper) {
        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;
      }
      commands.push(generatedQuery);
      offset += batch;
    }
    return commands.join(';');
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    if (options.limit) {
      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;
      sql.query = sql.query.replace('UPDATE', updateArgs);
    }
    return sql;
  }

  upsertQuery(tableName, insertValues, updateValues, where, model) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysAttrs = [];
    const identityAttrs = [];
    const uniqueAttrs = [];
    const tableNameQuoted = this.quoteTable(tableName);
    let needIdentityInsertWrapper = false;

    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed
    for (const key in model.rawAttributes) {
      if (model.rawAttributes[key].primaryKey) {
        primaryKeysAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].unique) {
        uniqueAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].autoIncrement) {
        identityAttrs.push(model.rawAttributes[key].field || key);
      }
    }

    //Add unique indexes defined by indexes option to uniqueAttrs
    for (const index of model._indexes) {
      if (index.unique && index.fields) {
        for (const field of index.fields) {
          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;
          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {
            uniqueAttrs.push(fieldName);
          }
        }
      }
    }

    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');
    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table
    let joinCondition;

    //IDENTITY_INSERT Condition
    identityAttrs.forEach(key => {
      if (updateValues[key] && updateValues[key] !== null) {
        needIdentityInsertWrapper = true;
        /*
         * IDENTITY_INSERT Column Cannot be updated, only inserted
         * http://stackoverflow.com/a/30176254/2254360
         */
      }
    });

    //Filter NULL Clauses
    const clauses = where[Op.or].filter(clause => {
      let valid = true;
      /*
       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row
       */
      for (const key in clause) {
        if (typeof clause[key] === 'undefined' || clause[key] == null) {
          valid = false;
          break;
        }
      }
      return valid;
    });

    /*
     * Generate ON condition using PK(s).
     * If not, generate using UK(s). Else throw error
     */
    const getJoinSnippet = array => {
      return array.map(key => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };

    if (clauses.length === 0) {
      throw new Error('Primary Key or Unique key should be passed to upsert query');
    } else {
      // Search for primary key attribute in clauses -- Model can have two separate unique keys
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.includes(keys[0])) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');
      }
    }

    // Remove the IDENTITY_INSERT Column from update
    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))
      .map(key => {
        const value = this.escape(updateValues[key]);
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${value}`;
      }).join(', ');

    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    const whereClause = this.getWhereConditions(where, null, model, options);

    return Utils.joinSQLFragments([
      'DELETE',
      options.limit && `TOP(${this.escape(options.limit)})`,
      'FROM',
      table,
      whereClause && `WHERE ${whereClause}`,
      ';',
      'SELECT @@ROWCOUNT AS AFFECTEDROWS',
      ';'
    ]);
  }

  showIndexesQuery(tableName) {
    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;
  }

  showConstraintsQuery(tableName) {
    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
  }

  attributeToSQL(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    // handle self referential constraints
    if (attribute.references) {

      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
        this.sequelize.log('MSSQL does not support self referencial constraints, '
          + 'we will remove it but we recommend restructuring your query');
        attribute.onDelete = '';
        attribute.onUpdate = '';
      }
    }

    let template;

    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;

      // enums are a special case
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {
        return this.escape(value);
      }).join(', ') }))`;
      return template;
    }
    template = attribute.type.toString();

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ' NULL';
    }

    if (attribute.autoIncrement) {
      template += ' IDENTITY(1,1)';
    }

    // Blobs/texts cannot have a defaultValue
    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&
        Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.references) {
      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      template += ` COMMENT ${attribute.comment}`;
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {},
      existingConstraints = [];
    let key,
      attribute;

    for (key in attributes) {
      attribute = attributes[key];

      if (attribute.references) {
        if (existingConstraints.includes(attribute.references.model.toString())) {
          // no cascading constraints to a table more than once
          attribute.onDelete = '';
          attribute.onUpdate = '';
        } else {
          existingConstraints.push(attribute.references.model.toString());

          // NOTE: this really just disables cascading updates for all
          //       definitions. Can be made more robust to support the
          //       few cases where MSSQL actually supports them
          attribute.onUpdate = '';
        }

      }

      if (key && !attribute.field) attribute.field = key;
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  createTrigger() {
    throwMethodUndefined('createTrigger');
  }

  dropTrigger() {
    throwMethodUndefined('dropTrigger');
  }

  renameTrigger() {
    throwMethodUndefined('renameTrigger');
  }

  createFunction() {
    throwMethodUndefined('createFunction');
  }

  dropFunction() {
    throwMethodUndefined('dropFunction');
  }

  renameFunction() {
    throwMethodUndefined('renameFunction');
  }

  /**
   * Generate common SQL prefix for ForeignKeysQuery.
   *
   * @param {string} catalogName
   * @returns {string}
   */
  _getForeignKeysQueryPrefix(catalogName) {
    return `${'SELECT ' +
        'constraint_name = OBJ.NAME, ' +
        'constraintName = OBJ.NAME, '}${
      catalogName ? `constraintCatalog = '${catalogName}', ` : ''
    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +
        'tableName = TB.NAME, ' +
        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${
          catalogName ? `tableCatalog = '${catalogName}', ` : ''
        }columnName = COL.NAME, ` +
        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${
          catalogName ? `referencedCatalog = '${catalogName}', ` : ''
        }referencedTableName = RTB.NAME, ` +
        'referencedColumnName = RCOL.NAME ' +
      'FROM sys.foreign_key_columns FKC ' +
        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +
        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +
        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +
        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +
        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * @param {string|object} table
   * @param {string} catalogName database name
   * @returns {string}
   */
  getForeignKeysQuery(table, catalogName) {
    const tableName = table.tableName || table;
    let sql = `${this._getForeignKeysQueryPrefix(catalogName)
    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;

    if (table.schema) {
      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
    }
    return sql;
  }

  getForeignKeyQuery(table, attributeName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      this._getForeignKeysQueryPrefix(),
      'WHERE',
      `TB.NAME =${wrapSingleQuote(tableName)}`,
      'AND',
      `COL.NAME =${wrapSingleQuote(attributeName)}`,
      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`
    ]);
  }

  getPrimaryKeyConstraintQuery(table, attributeName) {
    const tableName = wrapSingleQuote(table.tableName || table);
    return Utils.joinSQLFragments([
      'SELECT K.TABLE_NAME AS tableName,',
      'K.COLUMN_NAME AS columnName,',
      'K.CONSTRAINT_NAME AS constraintName',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',
      'ON C.TABLE_NAME = K.TABLE_NAME',
      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',
      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',
      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',
      'WHERE C.CONSTRAINT_TYPE = \'PRIMARY KEY\'',
      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
      `AND K.TABLE_NAME = ${tableName}`,
      ';'
    ]);
  }

  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(foreignKey)
    ]);
  }

  getDefaultConstraintQuery(tableName, attributeName) {
    const quotedTable = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      'SELECT name FROM sys.default_constraints',
      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,
      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,
      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,
      ';'
    ]);
  }

  dropConstraintQuery(tableName, constraintName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP CONSTRAINT',
      this.quoteIdentifier(constraintName),
      ';'
    ]);
  }

  setIsolationLevelQuery() {

  }

  generateTransactionId() {
    return randomBytes(10).toString('hex');
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'BEGIN TRANSACTION;';
  }

  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT TRANSACTION;';
  }

  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'ROLLBACK TRANSACTION;';
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    const dbVersion = this.sequelize.options.databaseVersion;
    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');

    if (isSQLServer2008 && options.offset) {
      // For earlier versions of SQL server, we need to nest several queries
      // in order to emulate the OFFSET behavior.
      //
      // 1. The outermost query selects all items from the inner query block.
      //    This is due to a limitation in SQL server with the use of computed
      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.
      // 2. The next query handles the LIMIT and OFFSET behavior by getting
      //    the TOP N rows of the query where the row number is > OFFSET
      // 3. The innermost query is the actual set we want information from

      const offset = options.offset || 0;
      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
      let orders = { mainQueryOrder: [] };
      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }

      if (orders.mainQueryOrder.length === 0) {
        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
      }

      const tmpTable = mainTableAs || 'OffsetTable';

      return Utils.joinSQLFragments([
        'SELECT TOP 100 PERCENT',
        attributes.join(', '),
        'FROM (',
        [
          'SELECT',
          options.limit && `TOP ${options.limit}`,
          '* FROM (',
          [
            'SELECT ROW_NUMBER() OVER (',
            [
              'ORDER BY',
              orders.mainQueryOrder.join(', ')
            ],
            `) as row_num, * FROM ${tables} AS ${tmpTable}`,
            where && `WHERE ${where}`
          ],
          `) AS ${tmpTable} WHERE row_num > ${offset}`
        ],
        `) AS ${tmpTable}`
      ]);
    }

    return Utils.joinSQLFragments([
      'SELECT',
      isSQLServer2008 && options.limit && `TOP ${options.limit}`,
      attributes.join(', '),
      `FROM ${tables}`,
      mainTableAs && `AS ${mainTableAs}`,
      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`
    ]);
  }

  addLimitAndOffset(options, model) {
    // Skip handling of limit and offset as postfixes for older SQL Server versions
    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {
      return '';
    }

    const offset = options.offset || 0;
    const isSubQuery = options.subQuery === undefined
      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation
      : options.subQuery;

    let fragment = '';
    let orders = {};

    if (options.order) {
      orders = this.getQueryOrders(options, model, isSubQuery);
    }

    if (options.limit || options.offset) {
      if (!options.order || !options.order.length || options.include && !orders.subQueryOrder.length) {
        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;
        if (!options.order || !options.order.length) {
          fragment += ` ORDER BY ${tablePkFragment}`;
        } else {
          const orderFieldNames = _.map(options.order, order => order[0]);
          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);

          if (!primaryKeyFieldAlreadyPresent) {
            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';
            fragment += tablePkFragment;
          }
        }
      }

      if (options.offset || options.limit) {
        fragment += ` OFFSET ${this.escape(offset)} ROWS`;
      }

      if (options.limit) {
        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
      }
    }

    return fragment;
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}

module.exports = MSSQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");

/**
 * The interface that Sequelize uses to talk with MSSQL database
 */
class MSSqlQueryInterface extends QueryInterface {
  /**
  * A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.
  *
  * @override
  */
  async removeColumn(tableName, attributeName, options) {
    options = { raw: true, ...options || {} };

    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);
    const [results0] = await this.sequelize.query(findConstraintSql, options);
    if (results0.length) {
      // No default constraint found -- we can cleanly remove the column
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);
    const [results] = await this.sequelize.query(findForeignKeySql, options);
    if (results.length) {
      // No foreign key constraints found, so we can remove the column
      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);
      await this.sequelize.query(dropForeignKeySql, options);
    }
    //Check if the current column is a primaryKey
    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);
    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);
    if (result.length) {
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);
    return this.sequelize.query(removeSql, options);
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    const model = options.model;
    const wheres = [];

    options = { ...options };

    if (!Utils.isWhereEmpty(where)) {
      wheres.push(where);
    }

    // Lets combine unique keys and indexes into one
    let indexes = Object.values(model.uniqueKeys).map(item => item.fields);
    indexes = indexes.concat(Object.values(model._indexes).filter(item => item.unique).map(item => item.fields));

    const attributes = Object.keys(insertValues);
    for (const index of indexes) {
      if (_.intersection(attributes, index).length === index.length) {
        where = {};
        for (const field of index) {
          where[field] = insertValues[field];
        }
        wheres.push(where);
      }
    }

    where = { [Op.or]: wheres };

    options.type = QueryTypes.UPSERT;
    options.raw = true;

    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
    return await this.sequelize.query(sql, options);
  }
}

exports.MSSqlQueryInterface = MSSqlQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:mssql');

function getScale(aNum) {
  if (!Number.isFinite(aNum)) return 0;
  let e = 1;
  while (Math.round(aNum * e) / e !== aNum) e *= 10;
  return Math.log10(e);
}

class Query extends AbstractQuery {
  getInsertIdField() {
    return 'id';
  }

  getSQLTypeFromJsType(value, TYPES) {
    const paramType = { type: TYPES.VarChar, typeOptions: {} };
    paramType.type = TYPES.NVarChar;
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        if (value >= -2147483648 && value <= 2147483647) {
          paramType.type = TYPES.Int;
        } else {
          paramType.type = TYPES.BigInt;
        }
      } else {
        paramType.type = TYPES.Numeric;
        //Default to a reasonable numeric precision/scale pending more sophisticated logic
        paramType.typeOptions = { precision: 30, scale: getScale(value) };
      }
    } else if (typeof value === 'boolean') {
      paramType.type = TYPES.Bit;
    }
    if (Buffer.isBuffer(value)) {
      paramType.type = TYPES.VarBinary;
    }
    return paramType;
  }

  async _run(connection, sql, parameters) {
    this.sql = sql;
    const { options } = this;

    const complete = this._logQuery(sql, debug, parameters);

    const query = new Promise((resolve, reject) => {
      // TRANSACTION SUPPORT
      if (sql.startsWith('BEGIN TRANSACTION')) {
        return connection.beginTransaction(error => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);
      }
      if (sql.startsWith('COMMIT TRANSACTION')) {
        return connection.commitTransaction(error => error ? reject(error) : resolve([]));
      }
      if (sql.startsWith('ROLLBACK TRANSACTION')) {
        return connection.rollbackTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }
      if (sql.startsWith('SAVE TRANSACTION')) {
        return connection.saveTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }

      const rows = [];
      const request = new connection.lib.Request(sql, (err, rowCount) => err ? reject(err) : resolve([rows, rowCount]));

      if (parameters) {
        _.forOwn(parameters, (value, key) => {
          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);
          request.addParameter(key, paramType.type, value, paramType.typeOptions);
        });
      }

      request.on('row', columns => {
        rows.push(columns);
      });

      connection.execSql(request);
    });

    let rows, rowCount;

    try {
      [rows, rowCount] = await query;
    } catch (err) {
      err.sql = sql;
      err.parameters = parameters;

      throw this.formatError(err);
    }

    complete();

    if (Array.isArray(rows)) {
      rows = rows.map(columns => {
        const row = {};
        for (const column of columns) {
          const typeid = column.metadata.type.id;
          const parse = parserStore.get(typeid);
          let value = column.value;

          if (value !== null & !!parse) {
            value = parse(value);
          }
          row[column.metadata.colName] = value;
        }
        return row;
      });
    }

    return this.formatResults(rows, rowCount);
  }

  run(sql, parameters) {
    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters));
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = {};
    const replacementFunc = (match, key, values) => {
      if (values[key] !== undefined) {
        bindParam[key] = values[key];
        return `@${key}`;
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];

    return [sql, bindParam];
  }

  /**
   * High level function that handles the results of a query execution.
   *
   * @param {Array} data - The result of the query execution.
   * @param {number} rowCount
   * @private
   * @example
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   */
  formatResults(data, rowCount) {
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);
      return [this.instance || data, rowCount];
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      const result = {};
      for (const _result of data) {
        if (_result.Default) {
          _result.Default = _result.Default.replace("('", '').replace("')", '').replace(/'/g, '');
        }

        result[_result.Name] = {
          type: _result.Type.toUpperCase(),
          allowNull: _result.IsNull === 'YES' ? true : false,
          defaultValue: _result.Default,
          primaryKey: _result.Constraint === 'PRIMARY KEY',
          autoIncrement: _result.IsIdentity === 1,
          comment: _result.Comment
        };

        if (
          result[_result.Name].type.includes('CHAR')
          && _result.Length
        ) {
          if (_result.Length === -1) {
            result[_result.Name].type += '(MAX)';
          } else {
            result[_result.Name].type += `(${_result.Length})`;
          }
        }
      }
      return result;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery()) {
      if (this.options.returning) {
        return this.handleSelectQuery(data);
      }

      return rowCount;
    }
    if (this.isBulkDeleteQuery()) {
      return data[0] ? data[0].AFFECTEDROWS : 0;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      this.handleInsertQuery(data);
      return [this.instance || data, data[0].$action === 'INSERT'];
    }
    if (this.isUpdateQuery()) {
      return [this.instance || data, rowCount];
    }
    if (this.isShowConstraintsQuery()) {
      return this.handleShowConstraintsQuery(data);
    }
    if (this.isRawQuery()) {
      return [data, rowCount];
    }
    return data;
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => {
      return {
        tableName: resultSet.TABLE_NAME,
        schema: resultSet.TABLE_SCHEMA
      };
    });
  }

  handleShowConstraintsQuery(data) {
    //Convert snake_case keys to camelCase as it's generated by stored procedure
    return data.slice(1).map(result => {
      const constraint = {};
      for (const key in result) {
        constraint[_.camelCase(key)] = result[key];
      }
      return constraint;
    });
  }

  formatError(err) {
    let match;

    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \((.*)\).)?/);
    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);
    if (match && match.length > 1) {
      let fields = {};
      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];
      let message = 'Validation error';

      if (uniqueKey && !!uniqueKey.msg) {
        message = uniqueKey.msg;
      }
      if (match[3]) {
        const values = match[3].split(',').map(part => part.trim());
        if (uniqueKey) {
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[match[1]] = match[3];
        }
      }

      const errors = [];
      _.forOwn(fields, (value, field) => {
        errors.push(new sequelizeErrors.ValidationErrorItem(
          this.getUniqueConstraintErrorMessage(field),
          'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
          field,
          value,
          this.instance,
          'not_unique'
        ));
      });

      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
    }

    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||
      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./) ||
      err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./);
    if (match && match.length > 0) {
      return new sequelizeErrors.ForeignKeyConstraintError({
        fields: null,
        index: match[1],
        parent: err
      });
    }

    match = err.message.match(/Could not drop constraint. See previous errors./);
    if (match && match.length > 0) {
      let constraint = err.sql.match(/(?:constraint|index) \[(.+?)\]/i);
      constraint = constraint ? constraint[1] : undefined;
      let table = err.sql.match(/table \[(.+?)\]/i);
      table = table ? table[1] : undefined;

      return new sequelizeErrors.UnknownConstraintError({
        message: match[1],
        constraint,
        table,
        parent: err
      });
    }

    return new sequelizeErrors.DatabaseError(err);
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith("select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'");
    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');
    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');

    return result;
  }

  isShowIndexesQuery() {
    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.index_name in acc)) {
        acc[item.index_name] = item;
        item.fields = [];
      }

      item.index_keys.split(',').forEach(column => {
        let columnName = column.trim();
        if (columnName.includes('(-)')) {
          columnName = columnName.replace('(-)', '');
        }

        acc[item.index_name].fields.push({
          attribute: columnName,
          length: undefined,
          order: column.includes('(-)') ? 'DESC' : 'ASC',
          collate: undefined
        });
      });
      delete item.index_keys;
      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.index_name.toLowerCase().startsWith('pk'),
      fields: item.fields,
      name: item.index_name,
      tableName: undefined,
      unique: item.index_description.toLowerCase().includes('unique'),
      type: undefined
    }));
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;
      let autoIncrementAttributeAlias = null;

      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) &&
        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)
        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;

      id = id || results && results[0][this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];
      id = id || results && results[0][autoIncrementAttribute];
      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];

      this.instance[autoIncrementAttribute] = id;

      if (this.instance.dataValues) {
        for (const key in results[0]) {
          if (Object.prototype.hasOwnProperty.call(results[0], key)) {
            const record = results[0][key];
  
            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);
  
            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }
      
    }
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mysql');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mysql');
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * MySQL Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MySQL specific connections
 * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mysql2');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  /**
   * Connect with MySQL database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      flags: '-FOUND_ROWS',
      password: config.password,
      database: config.database,
      timezone: this.sequelize.options.timezone,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      ...config.dialectOptions
    };

    try {
      const connection = await new Promise((resolve, reject) => {
        const connection = this.lib.createConnection(connectionConfig);

        const errorHandler = e => {
          // clean up connect & error event if there is error
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', connectHandler);
          reject(e);
        };

        const connectHandler = () => {
          // clean up error event if connected
          connection.removeListener('error', errorHandler);
          resolve(connection);
        };

        // don't use connection.once for error event handling here
        // mysql2 emit error two times in case handshake was failed
        // first error is protocol_lost and second is timeout
        // if we will use `once.error` node process will crash on 2nd error emit
        connection.on('error', errorHandler);
        connection.once('connect', connectHandler);
      });

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });

      if (!this.sequelize.config.keepDefaultTimezone) {
        // set timezone for this connection
        // but named timezone are not directly supported in mysql, so get its offset first
        let tzOffset = this.sequelize.options.timezone;
        tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;
        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();
      }

      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (connection._closing) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return connection
      && !connection._fatalError
      && !connection._protocolError
      && !connection._closing
      && !connection.stream.destroyed;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';

  /**
   * types: [buffer_type, ...]
   *
   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html
   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js
   */

  BaseTypes.DATE.types.mysql = ['DATETIME'];
  BaseTypes.STRING.types.mysql = ['VAR_STRING'];
  BaseTypes.CHAR.types.mysql = ['STRING'];
  BaseTypes.TEXT.types.mysql = ['BLOB'];
  BaseTypes.TINYINT.types.mysql = ['TINY'];
  BaseTypes.SMALLINT.types.mysql = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mysql = ['INT24'];
  BaseTypes.INTEGER.types.mysql = ['LONG'];
  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];
  BaseTypes.FLOAT.types.mysql = ['FLOAT'];
  BaseTypes.TIME.types.mysql = ['TIME'];
  BaseTypes.DATEONLY.types.mysql = ['DATE'];
  BaseTypes.BOOLEAN.types.mysql = ['TINY'];
  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mysql = false;
  BaseTypes.ENUM.types.mysql = false;
  BaseTypes.REAL.types.mysql = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];
  BaseTypes.JSON.types.mysql = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      // Fractional DATETIMEs only supported on MySQL 5.6.4+
      if (this._length) {
        return date.format('YYYY-MM-DD HH:mm:ss.SSS');
      }
      return date.format('YYYY-MM-DD HH:mm:ss');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }
  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
        return;
      }
      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {
        this.sqlType = this.type;
        return;
      }
      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(', ')}`);
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mysql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");

class MysqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'VALUES ()': true,
  'LIMIT ON UPDATE': true,
  lock: true,
  forShare: 'LOCK IN SHARE MODE',
  settingIsolationLevelDuringTransaction: false,
  inserts: {
    ignoreDuplicates: ' IGNORE',
    updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
  },
  index: {
    collate: false,
    length: true,
    parser: true,
    type: true,
    using: 1
  },
  constraints: {
    dropConstraint: false,
    check: false
  },
  indexViaAlter: true,
  indexHints: true,
  NUMERIC: true,
  GEOMETRY: true,
  JSON: true,
  REGEXP: true
});

MysqlDialect.prototype.defaultVersion = '5.7.0';
MysqlDialect.prototype.Query = Query;
MysqlDialect.prototype.QueryGenerator = QueryGenerator;
MysqlDialect.prototype.DataTypes = DataTypes;
MysqlDialect.prototype.name = 'mysql';
MysqlDialect.prototype.TICK_CHAR = '`';
MysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;
MysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;

module.exports = MysqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const util = __webpack_require__(/*! util */ "util");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");


const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
const FOREIGN_KEY_FIELDS = [
  'CONSTRAINT_NAME as constraint_name',
  'CONSTRAINT_NAME as constraintName',
  'CONSTRAINT_SCHEMA as constraintSchema',
  'CONSTRAINT_SCHEMA as constraintCatalog',
  'TABLE_NAME as tableName',
  'TABLE_SCHEMA as tableSchema',
  'TABLE_SCHEMA as tableCatalog',
  'COLUMN_NAME as columnName',
  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',
  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',
  'REFERENCED_TABLE_NAME as referencedTableName',
  'REFERENCED_COLUMN_NAME as referencedColumnName'
].join(',');

const typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);

class MySQLQueryGenerator extends AbstractQueryGenerator {
  constructor(options) {
    super(options);

    this.OperatorMap = {
      ...this.OperatorMap,
      [Op.regexp]: 'REGEXP',
      [Op.notRegexp]: 'NOT REGEXP'
    };
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE DATABASE IF NOT EXISTS',
      this.quoteIdentifier(databaseName),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;
  }

  createSchema() {
    return 'SHOW TABLES';
  }

  showSchemasQuery() {
    return 'SHOW TABLES';
  }

  versionQuery() {
    return 'SELECT VERSION() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = {
      engine: 'InnoDB',
      charset: null,
      rowFormat: null,
      ...options
    };

    const primaryKeys = [];
    const foreignKeys = {};
    const attrStr = [];

    for (const attr in attributes) {
      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
      const dataType = attributes[attr];
      let match;

      if (dataType.includes('PRIMARY KEY')) {
        primaryKeys.push(attr);

        if (dataType.includes('REFERENCES')) {
          // MySQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
        }
      } else if (dataType.includes('REFERENCES')) {
        // MySQL doesn't support inline REFERENCES declarations: move to the end
        match = dataType.match(/^(.+) (REFERENCES.*)$/);
        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
        foreignKeys[attr] = match[2];
      } else {
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attributesClause = attrStr.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }

    return Utils.joinSQLFragments([
      'CREATE TABLE IF NOT EXISTS',
      table,
      `(${attributesClause})`,
      `ENGINE=${options.engine}`,
      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,
      options.charset && `DEFAULT CHARSET=${options.charset}`,
      options.collate && `COLLATE ${options.collate}`,
      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,
      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,
      ';'
    ]);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `SHOW FULL COLUMNS FROM ${table};`;
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\', \'SYS\')';
    }
    return `${query};`;
  }

  addColumnQuery(table, key, dataType) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, {
        context: 'addColumn',
        tableName: table,
        foreignKey: key
      }),
      ';'
    ]);
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [];
    const constraintString = [];

    for (const attributeName in attributes) {
      let definition = attributes[attributeName];
      if (definition.includes('REFERENCES')) {
        const attrName = this.quoteIdentifier(attributeName);
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);
      } else {
        attrString.push(`\`${attributeName}\` \`${attributeName}\` ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `CHANGE ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';'
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const attrString = [];

    for (const attrName in attributes) {
      const definition = attributes[attrName];
      attrString.push(`\`${attrBefore}\` \`${attrName}\` ${definition}`);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'CHANGE',
      attrString.join(', '),
      ';'
    ]);
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the sqlite json functions
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    } else if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      } else if (smth.json && /boolean/i.test(smth.type)) {
        // true or false cannot be casted as booleans within a JSON structure
        smth.type = 'char';
      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {
        smth.type = 'decimal';
      } else if (/text/i.test(smth.type)) {
        smth.type = 'char';
      }
    }

    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
  }

  _toJSONValue(value) {
    // true/false are stored as strings in mysql
    if (typeof value === 'boolean') {
      return value.toString();
    }
    // null is stored as a string in mysql
    if (value === null) {
      return 'null';
    }
    return value;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    let limit = '';
    let query = `DELETE FROM ${this.quoteTable(tableName)}`;

    if (options.limit) {
      limit = ` LIMIT ${this.escape(options.limit)}`;
    }

    where = this.getWhereConditions(where, null, model, options);

    if (where) {
      query += ` WHERE ${where}`;
    }

    return query + limit;
  }

  showIndexesQuery(tableName, options) {
    return Utils.joinSQLFragments([
      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,
      options && options.database && `FROM \`${options.database}\``
    ]);
  }

  showConstraintsQuery(table, constraintName) {
    const tableName = table.tableName || table;
    const schemaName = table.schema;

    return Utils.joinSQLFragments([
      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',
      'CONSTRAINT_NAME AS constraintName,',
      'CONSTRAINT_SCHEMA AS constraintSchema,',
      'CONSTRAINT_TYPE AS constraintType,',
      'TABLE_NAME AS tableName,',
      'TABLE_SCHEMA AS tableSchema',
      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',
      `WHERE table_name='${tableName}'`,
      constraintName && `AND constraint_name = '${constraintName}'`,
      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,
      ';'
    ]);
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return Utils.joinSQLFragments([
      'DROP INDEX',
      this.quoteIdentifier(indexName),
      'ON',
      this.quoteTable(tableName)
    ]);
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });
    let template = attributeString;

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      template += ' auto_increment';
    }

    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value
    if (!typeWithoutDefault.has(attributeString)
      && attribute.type._binary !== true
      && Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.comment) {
      template += ` COMMENT ${this.escape(attribute.comment)}`;
    }

    if (attribute.first) {
      template += ' FIRST';
    }
    if (attribute.after) {
      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
    }

    if (attribute.references) {
      if (options && options.context === 'addColumn' && options.foreignKey) {
        const attrName = this.quoteIdentifier(options.foreignKey);
        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);

        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
      }

      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   * @private
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = JSON_FUNCTION_REGEX.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {object} table  The table.
   * @param  {string} schemaName The name of the schema.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(table, schemaName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,
      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,
      'AND REFERENCED_TABLE_NAME IS NOT NULL',
      ';'
    ]);
  }

  /**
   * Generates an SQL query that returns the foreign key constraint of a given column.
   *
   * @param  {object} table  The table.
   * @param  {string} columnName The name of the column.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeyQuery(table, columnName) {
    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';
    const quotedTableName = wrapSingleQuote(table.tableName || table);
    const quotedColumnName = wrapSingleQuote(columnName);

    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',
      'WHERE (',
      [
        `REFERENCED_TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`
      ],
      ') OR (',
      [
        `TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND COLUMN_NAME = ${quotedColumnName}`,
        'AND REFERENCED_TABLE_NAME IS NOT NULL'
      ],
      ')'
    ]);
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP FOREIGN KEY',
      this.quoteIdentifier(foreignKey),
      ';'
    ]);
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(identifier, '\'');
}

module.exports = MySQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk with MySQL/MariaDB database
 */
class MySQLQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.
   *
   * @override
   */
  async removeColumn(tableName, columnName, options) {
    options = options || {};

    const [results] = await this.sequelize.query(
      this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, columnName),
      { raw: true, ...options }
    );

    //Exclude primary key constraint
    if (results.length && results[0].constraint_name !== 'PRIMARY') {
      await Promise.all(results.map(constraint => this.sequelize.query(
        this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name),
        { raw: true, ...options }
      )));
    }

    return await this.sequelize.query(
      this.queryGenerator.removeColumnQuery(tableName, columnName),
      { raw: true, ...options }
    );
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);

    const model = options.model;
    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(
      tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, constraintName);

    const constraints = await this.sequelize.query(sql, { ...options,
      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS });

    const constraint = constraints[0];
    let query;
    if (!constraint || !constraint.constraintType) {
      throw new sequelizeErrors.UnknownConstraintError(
        {
          message: `Constraint ${constraintName} on table ${tableName} does not exist`,
          constraint: constraintName,
          table: tableName
        });
    }

    if (constraint.constraintType === 'FOREIGN KEY') {
      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);
    } else {
      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);
    }

    return await this.sequelize.query(query, options);
  }
}

exports.MySQLQueryInterface = MySQLQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mysql');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      if (parameters && parameters.length) {
        results = await new Promise((resolve, reject) => {
          connection
            .execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      } else {
        results = await new Promise((resolve, reject) => {
          connection
            .query({ sql }, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      }
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MySQL automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MySQL automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          data.constructor.name === 'ResultSetHeader'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = data[this.getInsertIdField()];
          result = [];
          for (let i = startId; i < startId + data.affectedRows; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = data[this.getInsertIdField()];
        }
      }
    }

    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        const enumRegex = /^enum/i;
        result[_result.Field] = {
          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isRawQuery()) {
      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta
      return [data, data];
    }

    return result;
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MySQL Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    const errCode = err.errno || err.code;

    switch (errCode) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?$/);
        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.Key_name in acc)) {
        acc[item.Key_name] = item;
        item.fields = [];
      }

      acc[item.Key_name].fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
      delete item.column_name;

      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.Key_name === 'PRIMARY',
      fields: item.fields,
      name: item.Key_name,
      tableName: item.Table,
      unique: item.Non_unique !== 1,
      type: item.Index_type
    }));
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/parserStore.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/parserStore.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


const stores = new Map();

module.exports = dialect => {
  if (!stores.has(dialect)) {
    stores.set(dialect, new Map());
  }

  return {
    clear() {
      stores.get(dialect).clear();
    },
    refresh(dataType) {
      for (const type of dataType.types[dialect]) {
        stores.get(dialect).set(type, dataType.parse);
      }
    },
    get(type) {
      return stores.get(dialect).get(type);
    }
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:pg');
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 5432;
    super(dialect, sequelize);

    const pgLib = this._loadDialectModule('pg');
    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;

    this._clearDynamicOIDs();
    this._clearTypeParser();
    this.refreshTypeParser(dataTypes.postgres);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    const arrayParserBuilder = parser => {
      return value => this.lib.types.arrayParser.create(value, parser).parse();
    };
    const rangeParserBuilder = parser => {
      return value => dataType.parse(value, { parser });
    };

    // Set range parsers
    if (dataType.key.toLowerCase() === 'range') {
      for (const name in this.nameOidMap) {
        const entry = this.nameOidMap[name];
        if (! entry.rangeOid) continue;

        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));
        const arrayRangeParser = arrayParserBuilder(rangeParser);

        this.oidParserMap.set(entry.rangeOid, rangeParser);
        if (! entry.arrayRangeOid) continue;
        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);
      }
      return;
    }

    // Create parsers for normal or enum data types
    const parser = value => dataType.parse(value);
    const arrayParser = arrayParserBuilder(parser);

    // Set enum parsers
    if (dataType.key.toLowerCase() === 'enum') {
      this.enumOids.oids.forEach(oid => {
        this.oidParserMap.set(oid, parser);
      });
      this.enumOids.arrayOids.forEach(arrayOid => {
        this.oidParserMap.set(arrayOid, arrayParser);
      });
      return;
    }

    // Set parsers for normal data types
    dataType.types.postgres.forEach(name => {
      if (! this.nameOidMap[name]) return;
      this.oidParserMap.set(this.nameOidMap[name].oid, parser);

      if (! this.nameOidMap[name].arrayOid) return;
      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);
    });
  }

  _clearTypeParser() {
    this.oidParserMap = new Map();
  }

  getTypeParser(oid, ...args) {
    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);

    return this.lib.types.getTypeParser(oid, ...args);
  }

  async connect(config) {
    config.user = config.username;
    const connectionConfig = _.pick(config, [
      'user', 'password', 'host', 'database', 'port'
    ]);

    connectionConfig.types = {
      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)
    };

    if (config.dialectOptions) {
      _.merge(connectionConfig,
        _.pick(config.dialectOptions, [
        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]
          'application_name',
          // choose the SSL mode with the PGSSLMODE environment variable
          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]
          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]
          'ssl',
          // In addition to the values accepted by the corresponding server,
          // you can use "auto" to determine the right encoding from the
          // current locale in the client (LC_CTYPE environment variable on Unix systems)
          'client_encoding',
          // !! DO NOT SET THIS TO TRUE !!
          // (unless you know what you're doing)
          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]
          'binary',
          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.
          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md
          'keepAlive',
          // Times out queries after a set time in milliseconds. Added in pg v7.3
          'statement_timeout',
          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10
          'idle_in_transaction_session_timeout'
        ]));
    }

    const connection = await new Promise((resolve, reject) => {
      let responded = false;

      const connection = new this.lib.Client(connectionConfig);

      const parameterHandler = message => {
        switch (message.parameterName) {
          case 'server_version':
            if (this.sequelize.options.databaseVersion === 0) {
              const version = semver.coerce(message.parameterValue).version;
              this.sequelize.options.databaseVersion = semver.valid(version)
                ? version
                : this.dialect.defaultVersion;
            }
            break;
          case 'standard_conforming_strings':
            connection['standard_conforming_strings'] = message.parameterValue;
            break;
        }
      };

      const endHandler = () => {
        debug('connection timeout');
        if (!responded) {
          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));
        }
      };

      // If we didn't ever hear from the client.connect() callback the connection timeout
      // node-postgres does not treat this as an error since no active query was ever emitted
      connection.once('end', endHandler);

      if (!this.sequelize.config.native) {
        // Receive various server parameters for further configuration
        connection.connection.on('parameterStatus', parameterHandler);
      }

      connection.connect(err => {
        responded = true;

        if (!this.sequelize.config.native) {
          // remove parameter handler
          connection.connection.removeListener('parameterStatus', parameterHandler);
        }

        if (err) {
          if (err.code) {
            switch (err.code) {
              case 'ECONNREFUSED':
                reject(new sequelizeErrors.ConnectionRefusedError(err));
                break;
              case 'ENOTFOUND':
                reject(new sequelizeErrors.HostNotFoundError(err));
                break;
              case 'EHOSTUNREACH':
                reject(new sequelizeErrors.HostNotReachableError(err));
                break;
              case 'EINVAL':
                reject(new sequelizeErrors.InvalidConnectionError(err));
                break;
              default:
                reject(new sequelizeErrors.ConnectionError(err));
                break;
            }
          } else {
            reject(new sequelizeErrors.ConnectionError(err));
          }
        } else {
          debug('connection acquired');
          connection.removeListener('end', endHandler);
          resolve(connection);
        }
      });
    });

    let query = '';

    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {
      // Disable escape characters in strings
      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)
      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS
      query += 'SET standard_conforming_strings=on;';
    }

    if (this.sequelize.options.clientMinMessages !== false) {
      query += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`;
    }

    if (!this.sequelize.config.keepDefaultTimezone) {
      const isZone = !!moment.tz.zone(this.sequelize.options.timezone);
      if (isZone) {
        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;
      } else {
        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;
      }
    }

    if (query) {
      await connection.query(query);
    }
    if (Object.keys(this.nameOidMap).length === 0 &&
      this.enumOids.oids.length === 0 &&
      this.enumOids.arrayOids.length === 0) {
      await this._refreshDynamicOIDs(connection);
    }
    // Don't let a Postgres restart (or error) to take down the whole app
    connection.on('error', error => {
      connection._invalid = true;
      debug(`connection error ${error.code || error.message}`);
      this.pool.destroy(connection);
    });

    return connection;
  }

  async disconnect(connection) {
    if (connection._ending) {
      debug('connection tried to disconnect but was already at ENDING state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return !connection._invalid && !connection._ending;
  }

  async _refreshDynamicOIDs(connection) {
    const databaseVersion = this.sequelize.options.databaseVersion;
    const supportedVersion = '8.3.0';

    // Check for supported version
    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {
      return;
    }

    const results = await (connection || this.sequelize).query(
      'WITH ranges AS (' +
      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +
      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +
      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +
      ')' +
      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +
      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +
      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +
      ' WHERE (pg_type.typtype IN(\'b\', \'e\'));'
    );

    let result = Array.isArray(results) ? results.pop() : results;

    // When searchPath is prepended then two statements are executed and the result is
    // an array of those two statements. First one is the SET search_path and second is
    // the SELECT query result.
    if (Array.isArray(result)) {
      if (result[0].command === 'SET') {
        result = result.pop();
      }
    }

    const newNameOidMap = {};
    const newEnumOids = { oids: [], arrayOids: [] };

    for (const row of result.rows) {
      // Mapping enums, handled separatedly
      if (row.typtype === 'e') {
        newEnumOids.oids.push(row.oid);
        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);
        continue;
      }

      // Mapping base types and their arrays
      newNameOidMap[row.typname] = { oid: row.oid };
      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;

      // Mapping ranges(of base types) and their arrays
      if (row.rngtypid) {
        newNameOidMap[row.typname].rangeOid = row.rngtypid;
        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;
      }
    }

    // Replace all OID mappings. Avoids temporary empty OID mappings.
    this.nameOidMap = newNameOidMap;
    this.enumOids = newEnumOids;

    this.refreshTypeParser(dataTypes.postgres);
  }

  _clearDynamicOIDs() {
    this.nameOidMap = {};
    this.enumOids = { oids: [], arrayOids: [] };
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');

  /**
   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types:
   * {
   *   oids: [oid],
   *   array_oids: [oid]
   * }
   *
   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go
   */

  BaseTypes.UUID.types.postgres = ['uuid'];
  BaseTypes.CIDR.types.postgres = ['cidr'];
  BaseTypes.INET.types.postgres = ['inet'];
  BaseTypes.MACADDR.types.postgres = ['macaddr'];
  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];
  BaseTypes.JSON.types.postgres = ['json'];
  BaseTypes.JSONB.types.postgres = ['jsonb'];
  BaseTypes.TIME.types.postgres = ['time'];

  class DATEONLY extends BaseTypes.DATEONLY {
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return super._sanitize(value);
      }
      return value;
    }
    static parse(value) {
      if (value === 'infinity') {
        return Infinity;
      }
      if (value === '-infinity') {
        return -Infinity;
      }
      return value;
    }
  }

  BaseTypes.DATEONLY.types.postgres = ['date'];

  class DECIMAL extends BaseTypes.DECIMAL {
    static parse(value) {
      return value;
    }
  }

  // numeric
  BaseTypes.DECIMAL.types.postgres = ['numeric'];

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.STRING.types.postgres = ['varchar'];

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  BaseTypes.TEXT.types.postgres = ['text'];

  class CITEXT extends BaseTypes.CITEXT {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.CITEXT.types.postgres = ['citext'];

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BOOLEAN';
    }
    _sanitize(value) {
      if (value !== null && value !== undefined) {
        if (Buffer.isBuffer(value) && value.length === 1) {
          // Bit fields are returned as buffers
          value = value[0];
        }
        if (typeof value === 'string') {
          // Only take action on valid boolean strings.
          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;
        }
        if (typeof value === 'number') {
          // Only take action on valid boolean integers.
          return value === 1 ? true : value === 0 ? false : value;
        }
      }
      return value;
    }
  }

  BOOLEAN.parse = BOOLEAN.prototype._sanitize;

  BaseTypes.BOOLEAN.types.postgres = ['bool'];

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'TIMESTAMP WITH TIME ZONE';
    }
    validate(value) {
      if (value !== Infinity && value !== -Infinity) {
        return super.validate(value);
      }
      return true;
    }
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return new Date(value);
      }
      return value;
    }
  }

  BaseTypes.DATE.types.postgres = ['timestamptz'];

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.TINYINT.types.postgres = ['int2'];

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.SMALLINT.types.postgres = ['int2'];

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  INTEGER.parse = function parse(value) {
    return parseInt(value, 10);
  };

  // int4
  BaseTypes.INTEGER.types.postgres = ['int4'];

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int8
  BaseTypes.BIGINT.types.postgres = ['int8'];

  class REAL extends BaseTypes.REAL {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float4
  BaseTypes.REAL.types.postgres = ['float4'];

  class DOUBLE extends BaseTypes.DOUBLE {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float8
  BaseTypes.DOUBLE.types.postgres = ['float8'];

  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // POSTGRES does only support lengths as parameter.
      // Values between 1-24 result in REAL
      // Values between 25-53 result in DOUBLE PRECISION
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._decimals = undefined;
      }
      if (this._unsigned) {
        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  delete FLOAT.parse; // Float has no separate type in PG

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');
        this._length = undefined;
      }
      return 'BYTEA';
    }
    _hexify(hex) {
      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html
      return `E'\\\\x${hex}'`;
    }
  }

  BaseTypes.BLOB.types.postgres = ['bytea'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    toSql() {
      let result = this.key;
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    _bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOMETRY.types.postgres = ['geometry'];


  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {
    toSql() {
      let result = 'GEOGRAPHY';
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];

  let hstore;

  class HSTORE extends BaseTypes.HSTORE {
    constructor() {
      super();
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
    }
    _value(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.stringify(value);
    }
    _stringify(value) {
      return `'${this._value(value)}'`;
    }
    _bindParam(value, options) {
      return options.bindParam(this._value(value));
    }
    static parse(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.parse(value);
    }
  }

  HSTORE.prototype.escape = false;

  BaseTypes.HSTORE.types.postgres = ['hstore'];

  class RANGE extends BaseTypes.RANGE {
    _value(values, options) {
      if (!Array.isArray(values)) {
        return this.options.subtype.stringify(values, options);
      }
      const valueInclusivity = [true, false];
      const valuesStringified = values.map((value, index) => {
        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {
          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {
            valueInclusivity[index] = value.inclusive;
          }
          value = value.value;
        }
        if (value === null || value === -Infinity || value === Infinity) {
          // Pass through "unbounded" bounds unchanged
          return value;
        }
        if (this.options.subtype.stringify) {
          return this.options.subtype.stringify(value, options);
        }
        return options.escape(value);
      });
      // Array.map does not preserve extra array properties
      valuesStringified.inclusive = valueInclusivity;
      return range.stringify(valuesStringified);
    }
    _stringify(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `'${value}'::${this.toCastType()}`;
      }
      return `'${value}'`;
    }
    _bindParam(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `${options.bindParam(value)}::${this.toCastType()}`;
      }
      return options.bindParam(value);
    }
    toSql() {
      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];
    }
    toCastType() {
      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];
    }
    static parse(value, options = { parser: val => val }) {
      return range.parse(value, options.parser);
    }
  }
  const range = __webpack_require__(/*! ./range */ "./node_modules/sequelize/lib/dialects/postgres/range.js");

  RANGE.prototype.escape = false;

  BaseTypes.RANGE.types.postgres = {
    subtypes: {
      integer: 'int4range',
      decimal: 'numrange',
      date: 'tstzrange',
      dateonly: 'daterange',
      bigint: 'int8range'
    },
    castTypes: {
      integer: 'int4',
      decimal: 'numeric',
      date: 'timestamptz',
      dateonly: 'date',
      bigint: 'int8'
    }
  };

  // TODO: Why are base types being manipulated??
  BaseTypes.ARRAY.prototype.escape = false;
  BaseTypes.ARRAY.prototype._value = function _value(values, options) {
    return values.map(value => {
      if (options && options.bindParam && this.type && this.type._value) {
        return this.type._value(value, options);
      }
      if (this.type && this.type.stringify) {
        value = this.type.stringify(value, options);

        if (this.type.escape === false) {
          return value;
        }
      }
      return options.escape(value);
    }, this);
  };
  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {
    let str = `ARRAY[${this._value(values, options).join(',')}]`;

    if (this.type) {
      const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
      let castKey = this.toSql();

      if (this.type instanceof BaseTypes.ENUM) {
        castKey = `${Utils.addTicks(
          Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName),
          '"'
        ) }[]`;
      }

      str += `::${castKey}`;
    }

    return str;
  };
  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {
    return options.bindParam(this._value(values, options));
  };

  class ENUM extends BaseTypes.ENUM {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.ENUM.types.postgres = [null];

  return {
    DECIMAL,
    BLOB,
    STRING,
    CHAR,
    TEXT,
    CITEXT,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    BOOLEAN,
    DATE,
    DATEONLY,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    FLOAT,
    GEOMETRY,
    GEOGRAPHY,
    HSTORE,
    RANGE,
    ENUM
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const hstore = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'pg-hstore'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))({ sanitize: true });

function stringify(data) {
  if (data === null) return null;
  return hstore.stringify(data);
}
exports.stringify = stringify;

function parse(value) {
  if (value === null) return null;
  return hstore.parse(value);
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/postgres/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").postgres;
const { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js");

class PostgresDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);
  }
}

PostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT VALUES': true,
  'EXCEPTION': true,
  'ON DUPLICATE KEY': false,
  'ORDER NULLS': true,
  returnValues: {
    returning: true
  },
  bulkDefault: true,
  schemas: true,
  lock: true,
  lockOf: true,
  lockKey: true,
  lockOuterJoinFailure: true,
  skipLocked: true,
  forShare: 'FOR SHARE',
  index: {
    concurrently: true,
    using: 2,
    where: true,
    functionBased: true,
    operator: true
  },
  inserts: {
    onConflictDoNothing: ' ON CONFLICT DO NOTHING',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  NUMERIC: true,
  ARRAY: true,
  RANGE: true,
  GEOMETRY: true,
  REGEXP: true,
  GEOGRAPHY: true,
  JSON: true,
  JSONB: true,
  HSTORE: true,
  TSVECTOR: true,
  deferrableConstraints: true,
  searchPath: true
});

PostgresDialect.prototype.defaultVersion = '9.5.0';
PostgresDialect.prototype.Query = Query;
PostgresDialect.prototype.DataTypes = DataTypes;
PostgresDialect.prototype.name = 'postgres';
PostgresDialect.prototype.TICK_CHAR = '"';
PostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;
PostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;

module.exports = PostgresDialect;
module.exports.default = PostgresDialect;
module.exports.PostgresDialect = PostgresDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const util = __webpack_require__(/*! util */ "util");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class PostgresQueryGenerator extends AbstractQueryGenerator {
  setSearchPath(searchPath) {
    return `SET search_path to ${searchPath};`;
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      encoding: null,
      collate: null,
      ...options
    };

    const values = {
      database: this.quoteTable(databaseName),
      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',
      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',
      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',
      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''
    };

    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
  }

  createSchema(schema) {
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);

    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {
      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;
    }

    return `CREATE SCHEMA ${schema};`;
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;
  }

  showSchemasQuery() {
    return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
  }

  versionQuery() {
    return 'SHOW SERVER_VERSION';
  }

  createTableQuery(tableName, attributes, options) {
    options = { ...options };

    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);
    const attrStr = [];
    let comments = '';
    let columnComments = '';

    const quotedTable = this.quoteTable(tableName);

    if (options.comment && typeof options.comment === 'string') {
      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
    }

    for (const attr in attributes) {
      const quotedAttr = this.quoteIdentifier(attr);
      const i = attributes[attr].indexOf('COMMENT ');
      if (i !== -1) {
        // Move comment to a separate query
        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
        attributes[attr] = attributes[attr].substring(0, i);
      }

      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
      attrStr.push(`${quotedAttr} ${dataType}`);
    }


    let attributesClause = attrStr.join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    const pks = _.reduce(attributes, (acc, attribute, key) => {
      if (attribute.includes('PRIMARY KEY')) {
        acc.push(this.quoteIdentifier(key));
      }
      return acc;
    }, []).join(',');

    if (pks.length > 0) {
      attributesClause += `, PRIMARY KEY (${pks})`;
    }

    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;
  }

  dropTableQuery(tableName, options) {
    options = options || {};
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;
  }

  showTablesQuery() {
    return "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';";
  }

  describeTableQuery(tableName, schema) {
    if (!schema) schema = 'public';

    return 'SELECT ' +
      'pk.constraint_type as "Constraint",' +
      'c.column_name as "Field", ' +
      'c.column_default as "Default",' +
      'c.is_nullable as "Null", ' +
      '(CASE WHEN c.udt_name = \'hstore\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \'(\' || c.character_maximum_length || \')\' ELSE \'\' END) as "Type", ' +
      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", ' +
      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" ' +
      'FROM information_schema.columns c ' +
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +
      'cu.column_name, tc.constraint_type ' +
      'FROM information_schema.TABLE_CONSTRAINTS tc ' +
      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +
      'and tc.constraint_name=cu.constraint_name ' +
      'and tc.constraint_type=\'PRIMARY KEY\') pk ' +
      'ON pk.table_schema=c.table_schema ' +
      'AND pk.table_name=c.table_name ' +
      'AND pk.column_name=c.column_name ' +
      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://www.postgresql.org/docs/current/static/functions-json.html
    const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
    const jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = jsonOperatorRegex.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the postgres json syntax
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    }
    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, attribute) {
    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });
    const dataType = attribute.type || attribute;
    const definition = this.dataTypeMapping(table, key, dbDataType);
    const quotedKey = this.quoteIdentifier(key);
    const quotedTable = this.quoteTable(this.extractTableDetails(table));

    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;

    if (dataType instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType) + query;
    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType.type) + query;
    }

    return query;
  }

  removeColumnQuery(tableName, attributeName) {
    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
    const quotedAttributeName = this.quoteIdentifier(attributeName);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
  }

  changeColumnQuery(tableName, attributes) {
    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
    const sql = [];
    for (const attributeName in attributes) {
      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
      let attrSql = '';

      if (definition.includes('NOT NULL')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);

        definition = definition.replace('NOT NULL', '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
      }

      if (definition.includes('DEFAULT')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);

        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
      }

      if (attributes[attributeName].startsWith('ENUM(')) {
        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
        definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, { schema: false }));
        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
      }

      if (definition.match(/UNIQUE;*$/)) {
        definition = definition.replace(/UNIQUE;*$/, '');
        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');
      }

      if (definition.includes('REFERENCES')) {
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');
      } else {
        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
      }

      sql.push(attrSql);
    }

    return sql.join('');
  }

  renameColumnQuery(tableName, attrBefore, attributes) {

    const attrString = [];

    for (const attributeName in attributes) {
      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
    }

    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;
  }

  fn(fnName, tableName, parameters, body, returns, language) {
    fnName = fnName || 'testfunc';
    language = language || 'plpgsql';
    returns = returns ? `RETURNS ${returns}` : '';
    parameters = parameters || '';

    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `TRUNCATE ${this.quoteTable(tableName)}`,
      options.restartIdentity ? ' RESTART IDENTITY' : '',
      options.cascade ? ' CASCADE' : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    let whereClause = this.getWhereConditions(where, null, model, options);
    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';
    let primaryKeys = '';
    let primaryKeysSelection = '';

    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }

    if (options.limit) {
      if (!model) {
        throw new Error('Cannot LIMIT delete without a model.');
      }

      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');

      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
      primaryKeysSelection = pks;

      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
    }
    return `DELETE FROM ${table}${whereClause}`;
  }

  showIndexesQuery(tableName) {
    let schemaJoin = '';
    let schemaWhere = '';
    if (typeof tableName !== 'string') {
      schemaJoin = ', pg_namespace s';
      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;
      tableName = tableName.tableName;
    }

    // This is ARCANE!
    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +
      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +
      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +
      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +
      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +
      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';
  }

  showConstraintsQuery(tableName) {
    //Postgres converts camelCased alias to lowercase unless quoted
    return [
      'SELECT constraint_catalog AS "constraintCatalog",',
      'constraint_schema AS "constraintSchema",',
      'constraint_name AS "constraintName",',
      'table_catalog AS "tableCatalog",',
      'table_schema AS "tableSchema",',
      'table_name AS "tableName",',
      'constraint_type AS "constraintType",',
      'is_deferrable AS "isDeferrable",',
      'initially_deferred AS "initiallyDeferred"',
      'from INFORMATION_SCHEMA.table_constraints',
      `WHERE table_name='${tableName}';`
    ].join(' ');
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;
  }

  addLimitAndOffset(options) {
    let fragment = '';
    /* eslint-disable */
    if (options.limit != null) {
      fragment += ' LIMIT ' + this.escape(options.limit);
    }
    if (options.offset != null) {
      fragment += ' OFFSET ' + this.escape(options.offset);
    }
    /* eslint-enable */

    return fragment;
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    let type;
    if (
      attribute.type instanceof DataTypes.ENUM ||
      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM
    ) {
      const enumType = attribute.type.type || attribute.type;
      let values = attribute.values;

      if (enumType.values && !attribute.values) {
        values = enumType.values;
      }

      if (Array.isArray(values) && values.length > 0) {
        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;

        if (attribute.type instanceof DataTypes.ARRAY) {
          type += '[]';
        }

      } else {
        throw new Error("Values for ENUM haven't been defined.");
      }
    }

    if (!type) {
      type = attribute.type;
    }

    let sql = type.toString();

    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {
      sql += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      if (attribute.autoIncrementIdentity) {
        sql += ' GENERATED BY DEFAULT AS IDENTITY';
      } else {
        sql += ' SERIAL';
      }
    }

    if (Utils.defaultValueSchemable(attribute.defaultValue)) {
      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
    }

    if (attribute.unique === true) {
      sql += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      sql += ' PRIMARY KEY';
    }

    if (attribute.references) {
      let referencesTable = this.quoteTable(attribute.references.model);
      let schema;

      if (options.schema) {
        schema = options.schema;
      } else if (
        (!attribute.references.model || typeof attribute.references.model == 'string')
        && options.table
        && options.table.schema
      ) {
        schema = options.table.schema;
      }

      if (schema) {
        referencesTable = this.quoteTable(this.addSchema({
          tableName: referencesTable,
          _schema: schema
        }));
      }

      let referencesKey;

      if (attribute.references.key) {
        referencesKey = this.quoteIdentifiers(attribute.references.key);
      } else {
        referencesKey = this.quoteIdentifier('id');
      }

      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

      if (attribute.onDelete) {
        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }

      if (attribute.references.deferrable) {
        sql += ` ${attribute.references.deferrable.toString(this)}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {
        const quotedAttr = this.quoteIdentifier(options.key);
        const escapedCommentText = this.escape(attribute.comment);
        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
      } else {
        // for createTable event which does it's own parsing
        // TODO: centralize creation of comment statements here
        sql += ` COMMENT ${attribute.comment}`;
      }
    }

    return sql;
  }

  deferConstraintsQuery(options) {
    return options.deferrable.toString(this);
  }

  setConstraintQuery(columns, type) {
    let columnFragment = 'ALL';

    if (columns) {
      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');
    }

    return `SET CONSTRAINTS ${columnFragment} ${type}`;
  }

  setDeferredQuery(columns) {
    return this.setConstraintQuery(columns, 'DEFERRED');
  }

  setImmediateQuery(columns) {
    return this.setConstraintQuery(columns, 'IMMEDIATE');
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });
    }

    return result;
  }

  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
    const decodedEventType = this.decodeTriggerEventType(eventType);
    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);
    const expandedOptions = this.expandOptions(optionsArray);
    const paramList = this._expandFunctionParamList(functionParams);

    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${
      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;
  }

  dropTrigger(tableName, triggerName) {
    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;
  }

  renameTrigger(tableName, oldTriggerName, newTriggerName) {
    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;
  }

  createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');

    const paramList = this._expandFunctionParamList(params);
    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';
    const expandedOptionsArray = this.expandOptions(optionsArray);

    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';

    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;
  }

  dropFunction(functionName, params) {
    if (!functionName) throw new Error('requires functionName');
    // RESTRICT is (currently, as of 9.2) default but we'll be explicit
    const paramList = this._expandFunctionParamList(params);
    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;
  }

  renameFunction(oldFunctionName, params, newFunctionName) {
    const paramList = this._expandFunctionParamList(params);
    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;
  }

  pgEscapeAndQuote(val) {
    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), "'"));
  }

  _expandFunctionParamList(params) {
    if (params === undefined || !Array.isArray(params)) {
      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');
    }

    const paramList = [];
    params.forEach(curParam => {
      const paramDef = [];
      if (curParam.type) {
        if (curParam.direction) { paramDef.push(curParam.direction); }
        if (curParam.name) { paramDef.push(curParam.name); }
        paramDef.push(curParam.type);
      } else {
        throw new Error('function or trigger used with a parameter without any type');
      }

      const joined = paramDef.join(' ');
      if (joined) paramList.push(joined);

    });

    return paramList.join(', ');
  }

  _expandFunctionVariableList(variables) {
    if (!Array.isArray(variables)) {
      throw new Error('_expandFunctionVariableList: function variables must be an array');
    }
    const variableDefinitions = [];
    variables.forEach(variable => {
      if (!variable.name || !variable.type) {
        throw new Error('function variable must have a name and type');
      }
      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;
      if (variable.default) {
        variableDefinition += ` := ${variable.default}`;
      }
      variableDefinition += ';';
      variableDefinitions.push(variableDefinition);
    });
    return variableDefinitions.join(' ');
  }

  expandOptions(options) {
    return options === undefined || _.isEmpty(options) ?
      '' : options.join(' ');
  }

  decodeTriggerEventType(eventSpecifier) {
    const EVENT_DECODER = {
      'after': 'AFTER',
      'before': 'BEFORE',
      'instead_of': 'INSTEAD OF',
      'after_constraint': 'AFTER'
    };

    if (!EVENT_DECODER[eventSpecifier]) {
      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);
    }

    return EVENT_DECODER[eventSpecifier];
  }

  triggerEventTypeIsConstraint(eventSpecifier) {
    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';
  }

  expandTriggerEventSpec(fireOnSpec) {
    if (_.isEmpty(fireOnSpec)) {
      throw new Error('no table change events specified to trigger on');
    }

    return _.map(fireOnSpec, (fireValue, fireKey) => {
      const EVENT_MAP = {
        'insert': 'INSERT',
        'update': 'UPDATE',
        'delete': 'DELETE',
        'truncate': 'TRUNCATE'
      };

      if (!EVENT_MAP[fireValue]) {
        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);
      }

      let eventSpec = EVENT_MAP[fireValue];
      if (eventSpec === 'UPDATE') {
        if (Array.isArray(fireValue) && fireValue.length > 0) {
          eventSpec += ` OF ${fireValue.join(', ')}`;
        }
      }

      return eventSpec;
    }).join(' OR ');
  }

  pgEnumName(tableName, attr, options) {
    options = options || {};

    const tableDetails = this.extractTableDetails(tableName, options);
    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '"');

    // pgListEnums requires the enum name only, without the schema
    if (options.schema !== false && tableDetails.schema) {
      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
    }

    return enumName;
  }

  pgListEnums(tableName, attrName, options) {
    let enumName = '';
    const tableDetails = this.extractTableDetails(tableName, options);

    if (tableDetails.tableName && attrName) {
      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/"/g, "'")}`;
    }

    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +
      'JOIN pg_enum e ON t.oid = e.enumtypid ' +
      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +
      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;
  }

  pgEnum(tableName, attr, dataType, options) {
    const enumName = this.pgEnumName(tableName, attr, options);
    let values;

    if (dataType.values) {
      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;
    } else {
      values = dataType.toString().match(/^ENUM\(.+\)/)[0];
    }

    let sql = `CREATE TYPE ${enumName} AS ${values};`;
    if (!!options && options.force === true) {
      sql = this.pgEnumDrop(tableName, attr) + sql;
    }
    return sql;
  }

  pgEnumAdd(tableName, attr, value, options) {
    const enumName = this.pgEnumName(tableName, attr);
    let sql = `ALTER TYPE ${enumName} ADD VALUE `;

    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {
      sql += 'IF NOT EXISTS ';
    }
    sql += this.escape(value);

    if (options.before) {
      sql += ` BEFORE ${this.escape(options.before)}`;
    } else if (options.after) {
      sql += ` AFTER ${this.escape(options.after)}`;
    }

    return sql;
  }

  pgEnumDrop(tableName, attr, enumName) {
    enumName = enumName || this.pgEnumName(tableName, attr);
    return `DROP TYPE IF EXISTS ${enumName}; `;
  }

  fromArray(text) {
    text = text.replace(/^{/, '').replace(/}$/, '');
    let matches = text.match(/("(?:\\.|[^"\\\\])*"|[^,]*)(?:\s*,\s*|\s*$)/ig);

    if (matches.length < 1) {
      return [];
    }

    matches = matches.map(m => m.replace(/",$/, '').replace(/,$/, '').replace(/(^"|"$)/g, ''));

    return matches.slice(0, -1);
  }

  dataTypeMapping(tableName, attr, dataType) {
    if (dataType.includes('PRIMARY KEY')) {
      dataType = dataType.replace('PRIMARY KEY', '');
    }

    if (dataType.includes('SERIAL')) {
      if (dataType.includes('BIGINT')) {
        dataType = dataType.replace('SERIAL', 'BIGSERIAL');
        dataType = dataType.replace('BIGINT', '');
      } else if (dataType.includes('SMALLINT')) {
        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');
        dataType = dataType.replace('SMALLINT', '');
      } else {
        dataType = dataType.replace('INTEGER', '');
      }
      dataType = dataType.replace('NOT NULL', '');
    }

    if (dataType.startsWith('ENUM(')) {
      dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
    }

    return dataType;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +
      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;
  }

  /**
   * Generate common SQL prefix for getForeignKeyReferencesQuery.
   *
   * @returns {string}
   */
  _getForeignKeyReferencesQueryPrefix() {
    return 'SELECT ' +
      'DISTINCT tc.constraint_name as constraint_name, ' +
      'tc.constraint_schema as constraint_schema, ' +
      'tc.constraint_catalog as constraint_catalog, ' +
      'tc.table_name as table_name,' +
      'tc.table_schema as table_schema,' +
      'tc.table_catalog as table_catalog,' +
      'kcu.column_name as column_name,' +
      'ccu.table_schema  AS referenced_table_schema,' +
      'ccu.table_catalog  AS referenced_table_catalog,' +
      'ccu.table_name  AS referenced_table_name,' +
      'ccu.column_name AS referenced_column_name ' +
      'FROM information_schema.table_constraints AS tc ' +
      'JOIN information_schema.key_column_usage AS kcu ' +
      'ON tc.constraint_name = kcu.constraint_name ' +
      'JOIN information_schema.constraint_column_usage AS ccu ' +
      'ON ccu.constraint_name = tc.constraint_name ';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.
   *
   * @param {string} tableName
   * @param {string} catalogName
   * @param {string} schemaName
   */
  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${
      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''
    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;
  }

  getForeignKeyReferenceQuery(table, columnName) {
    const tableName = table.tableName || table;
    const schema = table.schema;
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${
      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;
  }
}

module.exports = PostgresQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * The interface that Sequelize uses to talk with Postgres database
 */
class PostgresQueryInterface extends QueryInterface {
  /**
   * Ensure enum and their values.
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of normalized table attributes
   * @param {object} [options]
   * @param {Model}  [model]
   *
   * @protected
   */
  async ensureEnums(tableName, attributes, options, model) {
    const keys = Object.keys(attributes);
    const keyLen = keys.length;

    let sql = '';
    let promises = [];
    let i = 0;

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
        promises.push(this.sequelize.query(
          sql,
          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }
        ));
      }
    }

    const results = await Promise.all(promises);
    promises = [];
    let enumIdx = 0;

    // This little function allows us to re-use the same code that prepends or appends new value to enum array
    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {
      const valueOptions = { ...options };
      valueOptions.before = null;
      valueOptions.after = null;

      switch (position) {
        case 'after':
          valueOptions.after = relativeValue;
          break;
        case 'before':
        default:
          valueOptions.before = relativeValue;
          break;
      }

      promises.splice(spliceStart, 0, () => {
        return this.sequelize.query(this.queryGenerator.pgEnumAdd(
          tableName, field, value, valueOptions
        ), valueOptions);
      });
    };

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;
      const enumType = type.type || type;
      const field = attribute.field || keys[i];

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        // If the enum type doesn't exist then create it
        if (!results[enumIdx]) {
          promises.push(() => {
            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });
          });
        } else if (!!results[enumIdx] && !!model) {
          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);
          const vals = enumType.values;

          // Going through already existing values allows us to make queries that depend on those values
          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values
          // Then we append the rest of new values AFTER the latest already existing value
          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]
          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]
          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]
          let lastOldEnumValue;
          let rightestPosition = -1;
          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {
            const enumVal = enumVals[oldIndex];
            const newIdx = vals.indexOf(enumVal);
            lastOldEnumValue = enumVal;

            if (newIdx === -1) {
              continue;
            }

            const newValuesBefore = vals.slice(0, newIdx);
            const promisesLength = promises.length;
            // we go in reverse order so we could stop when we meet old value
            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {
              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {
                break;
              }

              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);
            }

            // we detect the most 'right' position of old value in new enum array so we can append new values to it
            if (newIdx > rightestPosition) {
              rightestPosition = newIdx;
            }
          }

          if (lastOldEnumValue && rightestPosition < vals.length - 1) {
            const remainingEnumValues = vals.slice(rightestPosition + 1);
            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {
              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');
            }
          }

          enumIdx++;
        }
      }
    }

    const result = await promises
      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());

    // If ENUM processed, then refresh OIDs
    if (promises.length) {
      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();
    }
    return result;
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };

    // postgres needs some special treatment as those field names returned are all lowercase
    // in order to keep same result with other dialects.
    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);
    const result = await this.sequelize.query(query, queryOptions);
    return result.map(Utils.camelizeObjectKeys);
  }

  /**
   * Drop specified enum from database (Postgres only)
   *
   * @param {string} [enumName]  Enum name to drop
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropEnum(enumName, options) {
    options = options || {};

    return this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),
      { ...options, raw: true }
    );
  }

  /**
   * Drop all enums from database (Postgres only)
   *
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropAllEnums(options) {
    options = options || {};

    const enums = await this.pgListEnums(null, options);

    return await Promise.all(enums.map(result => this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),
      { ...options, raw: true }
    )));
  }

  /**
   * List all enums (Postgres only)
   *
   * @param {string} [tableName]  Table whose enum to list
   * @param {object} [options]    Query options
   *
   * @returns {Promise}
   */
  async pgListEnums(tableName, options) {
    options = options || {};
    const sql = this.queryGenerator.pgListEnums(tableName);
    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });
  }

  /**
   * Since postgres has a special case for enums, we should drop the related
   * enum type within the table and attribute
   *
   * @override
   */
  async dropTable(tableName, options) {
    await super.dropTable(tableName, options);
    const promises = [];
    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });

    if (!instanceTable) {
      // Do nothing when model is not available
      return;
    }

    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;

    const keys = Object.keys(instanceTable.rawAttributes);
    const keyLen = keys.length;

    for (let i = 0; i < keyLen; i++) {
      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {
        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);
        options.supportsSearchPath = false;
        promises.push(this.sequelize.query(sql, { ...options, raw: true }));
      }
    }

    await Promise.all(promises);
  }
}

exports.PostgresQueryInterface = PostgresQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:pg');


class Query extends AbstractQuery {
  /**
   * Rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    const stringReplaceFunc = value => typeof value === 'string' ? value.replace(/\0/g, '\\0') : value;

    let bindParam;
    if (Array.isArray(values)) {
      bindParam = values.map(stringReplaceFunc);
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = [];
      let i = 0;
      const seen = {};
      const replacementFunc = (match, key, values) => {
        if (seen[key] !== undefined) {
          return seen[key];
        }
        if (values[key] !== undefined) {
          i = i + 1;
          bindParam.push(stringReplaceFunc(values[key]));
          seen[key] = `$${i}`;
          return `$${i}`;
        }
        return undefined;
      };
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    }
    return [sql, bindParam];
  }

  async run(sql, parameters) {
    const { connection } = this;

    if (!_.isEmpty(this.options.searchPath)) {
      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;
    }

    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {
      _.toPairs(this.options.includeAliases)
        // Sorting to replace the longest aliases first to prevent alias collision
        .sort((a, b) => b[1].length - a[1].length)
        .forEach(([alias, original]) => {
          const reg = new RegExp(_.escapeRegExp(original), 'g');

          sql = sql.replace(reg, alias);
        });
    }

    this.sql = sql;

    const query = parameters && parameters.length
      ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result)))
      : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));

    const complete = this._logQuery(sql, debug, parameters);

    let queryResult;

    try {
      queryResult = await query;
    } catch (err) {
      // set the client so that it will be reaped if the connection resets while executing
      if (err.code === 'ECONNRESET') {
        connection._invalid = true;
      }

      err.sql = sql;
      err.parameters = parameters;
      throw this.formatError(err);
    }

    complete();

    let rows = Array.isArray(queryResult)
      ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), [])
      : queryResult.rows;
    const rowCount = Array.isArray(queryResult)
      ? queryResult.reduce(
        (count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count,
        0
      )
      : queryResult.rowCount || 0;

    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {
      rows = rows
        .map(row => _.toPairs(row)
          .reduce((acc, [key, value]) => {
            const mapping = this.options.aliasesMapping.get(key);
            acc[mapping || key] = value;
            return acc;
          }, {})
        );
    }

    const isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');
    const isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');

    if (isRelNameQuery) {
      return rows.map(row => ({
        name: row.relname,
        tableName: row.relname.split('_')[0]
      }));
    }
    if (isTableNameQuery) {
      return rows.map(row => Object.values(row));
    }

    if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {
      if (rows[0].sequelize_caught_exception !== null) {
        throw this.formatError({
          sql,
          parameters,
          code: '23505',
          detail: rows[0].sequelize_caught_exception
        });
      }
      for (const row of rows) {
        delete row.sequelize_caught_exception;
      }
    }

    if (this.isShowIndexesQuery()) {
      for (const row of rows) {
        const attributes = /ON .*? (?:USING .*?\s)?\(([^]*)\)/gi.exec(row.definition)[1].split(',');

        // Map column index in table to column name
        const columns = _.zipObject(
          row.column_indexes,
          this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names)
        );
        delete row.column_indexes;
        delete row.column_names;

        let field;
        let attribute;

        // Indkey is the order of attributes in the index, specified by a string of attribute indexes
        row.fields = row.indkey.split(' ').map((indKey, index) => {
          field = columns[indKey];
          // for functional indices indKey = 0
          if (!field) {
            return null;
          }
          attribute = attributes[index];
          return {
            attribute: field,
            collate: attribute.match(/COLLATE "(.*?)"/) ? /COLLATE "(.*?)"/.exec(attribute)[1] : undefined,
            order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,
            length: undefined
          };
        }).filter(n => n !== null);
        delete row.columns;
      }
      return rows;
    }
    if (this.isForeignKeysQuery()) {
      const result = [];
      for (const row of rows) {
        let defParts;
        if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \((.+)\) REFERENCES (.+)\((.+)\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {
          row.id = row.constraint_name;
          row.table = defParts[2];
          row.from = defParts[1];
          row.to = defParts[3];
          let i;
          for (i = 5; i <= 8; i += 3) {
            if (/(UPDATE|DELETE)/.test(defParts[i])) {
              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];
            }
          }
        }
        result.push(row);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      let result = rows;
      // Postgres will treat tables as case-insensitive, so fix the case
      // of the returned values to match attributes
      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {
          m[k.toLowerCase()] = k;
          return m;
        }, {});
        result = rows.map(row => {
          return _.mapKeys(row, (value, key) => {
            const targetAttr = attrsMap[key];
            if (typeof targetAttr === 'string' && targetAttr !== key) {
              return targetAttr;
            }
            return key;
          });
        });
      }
      return this.handleSelectQuery(result);
    }
    if (QueryTypes.DESCRIBE === this.options.type) {
      const result = {};

      for (const row of rows) {
        result[row.Field] = {
          type: row.Type.toUpperCase(),
          allowNull: row.Null === 'YES',
          defaultValue: row.Default,
          comment: row.Comment,
          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],
          primaryKey: row.Constraint === 'PRIMARY KEY'
        };

        if (result[row.Field].type === 'BOOLEAN') {
          result[row.Field].defaultValue = { 'false': false, 'true': true }[result[row.Field].defaultValue];

          if (result[row.Field].defaultValue === undefined) {
            result[row.Field].defaultValue = null;
          }
        }

        if (typeof result[row.Field].defaultValue === 'string') {
          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');

          if (result[row.Field].defaultValue.includes('::')) {
            const split = result[row.Field].defaultValue.split('::');
            if (split[1].toLowerCase() !== 'regclass)') {
              result[row.Field].defaultValue = split[0];
            }
          }
        }
      }

      return result;
    }
    if (this.isVersionQuery()) {
      return rows[0].server_version;
    }
    if (this.isShowOrDescribeQuery()) {
      return rows;
    }
    if (QueryTypes.BULKUPDATE === this.options.type) {
      if (!this.options.returning) {
        return parseInt(rowCount, 10);
      }
      return this.handleSelectQuery(rows);
    }
    if (QueryTypes.BULKDELETE === this.options.type) {
      return parseInt(rowCount, 10);
    }
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        for (const key in rows[0]) {
          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {
            const record = rows[0][key];

            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }

      if (this.isUpsertQuery()) {
        return [
          this.instance,
          null
        ];
      }

      return [
        this.instance || rows && (this.options.plain && rows[0] || rows) || undefined,
        rowCount
      ];
    }
    if (this.isRawQuery()) {
      return [rows, queryResult];
    }
    return rows;
  }

  formatError(err) {
    let match;
    let table;
    let index;
    let fields;
    let errors;
    let message;

    const code = err.code || err.sqlState;
    const errMessage = err.message || err.messagePrimary;
    const errDetail = err.detail || err.messageDetail;

    switch (code) {
      case '23503':
        index = errMessage.match(/violates foreign key constraint "(.+?)"/);
        index = index ? index[1] : undefined;
        table = errMessage.match(/on table "(.+?)"/);
        table = table ? table[1] : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({ message: errMessage, fields: null, index, table, parent: err });
      case '23505':
        // there are multiple different formats of error messages for this error code
        // this regex should check at least two
        if (errDetail && (match = errDetail.replace(/"/g, '').match(/Key \((.*?)\)=\((.*?)\)/))) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
          errors = [];
          message = 'Validation error';

          _.forOwn(fields, (value, field) => {
            errors.push(new sequelizeErrors.ValidationErrorItem(
              this.getUniqueConstraintErrorMessage(field),
              'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
              field,
              value,
              this.instance,
              'not_unique'
            ));
          });

          if (this.model && this.model.uniqueKeys) {
            _.forOwn(this.model.uniqueKeys, constraint => {
              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {
                message = constraint.msg;
                return false;
              }
            });
          }

          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
        }

        return new sequelizeErrors.UniqueConstraintError({
          message: errMessage,
          parent: err
        });

      case '23P01':
        match = errDetail.match(/Key \((.*?)\)=\((.*?)\)/);

        if (match) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
        }
        message = 'Exclusion constraint error';

        return new sequelizeErrors.ExclusionConstraintError({
          message,
          constraint: err.constraint,
          fields,
          table: err.table,
          parent: err
        });

      case '42704':
        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {
          message = 'Unknown constraint error';
          index = errMessage.match(/(?:constraint|index) "(.+?)"/i);
          index = index ? index[1] : undefined;
          table = errMessage.match(/relation "(.+?)"/i);
          table = table ? table[1] : undefined;

          throw new sequelizeErrors.UnknownConstraintError({
            message,
            constraint: index,
            fields,
            table,
            parent: err
          });
        }
      // falls through
      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  isForeignKeysQuery() {
    return /SELECT conname as constraint_name, pg_catalog\.pg_get_constraintdef\(r\.oid, true\) as condef FROM pg_catalog\.pg_constraint r WHERE r\.conrelid = \(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\) AND r\.contype = 'f' ORDER BY 1;/.test(this.sql);
  }

  getInsertIdField() {
    return 'id';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/range.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

function stringifyRangeBound(bound) {
  if (bound === null) {
    return '' ;
  }
  if (bound === Infinity || bound === -Infinity) {
    return bound.toString().toLowerCase();
  }
  return JSON.stringify(bound);
}

function parseRangeBound(bound, parseType) {
  if (!bound) {
    return null;
  }
  if (bound === 'infinity') {
    return Infinity;
  }
  if (bound === '-infinity') {
    return -Infinity;
  }
  return parseType(bound);

}

function stringify(data) {
  if (data === null) return null;

  if (!Array.isArray(data)) throw new Error('range must be an array');
  if (!data.length) return 'empty';
  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');

  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {
    if (data.inclusive === false) data.inclusive = [false, false];
    else if (!data.inclusive) data.inclusive = [true, false];
    else if (data.inclusive === true) data.inclusive = [true, true];
  } else {
    data.inclusive = [true, false];
  }

  _.each(data, (value, index) => {
    if (_.isObject(value)) {
      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;
      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;
    }
  });

  const lowerBound = stringifyRangeBound(data[0]);
  const upperBound = stringifyRangeBound(data[1]);

  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;
}
exports.stringify = stringify;

function parse(value, parser) {
  if (value === null) return null;
  if (value === 'empty') {
    return [];
  }

  let result = value
    .substring(1, value.length - 1)
    .split(',', 2);

  if (result.length !== 2) return value;

  result = result.map((item, index) => {
    return {
      value: parseRangeBound(item, parser),
      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'
    };
  });

  return result;
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:sqlite');
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    super(dialect, sequelize);

    // We attempt to parse file location from a connection uri
    // but we shouldn't match sequelize default host.
    if (this.sequelize.options.host === 'localhost') {
      delete this.sequelize.options.host;
    }

    this.connections = {};
    this.lib = this._loadDialectModule('sqlite3');
    this.refreshTypeParser(dataTypes);
  }

  async _onProcessExit() {
    await Promise.all(
      Object.getOwnPropertyNames(this.connections)
        .map(connection => promisify(callback => this.connections[connection].close(callback))())
    );
    return super._onProcessExit.call(this);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async getConnection(options) {
    options = options || {};
    options.uuid = options.uuid || 'default';
    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';
    options.inMemory = options.storage === ':memory:' ? 1 : 0;

    const dialectOptions = this.sequelize.options.dialectOptions;
    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;

    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;

    if (this.connections[options.inMemory || options.uuid]) {
      return this.connections[options.inMemory || options.uuid];
    }

    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {
      // automatic path provision for `options.storage`
      fs.mkdirSync(path.dirname(options.storage), { recursive: true });
    }

    const connection = await new Promise((resolve, reject) => {
      this.connections[options.inMemory || options.uuid] = new this.lib.Database(
        options.storage,
        options.readWriteMode,
        err => {
          if (err) return reject(new sequelizeErrors.ConnectionError(err));
          debug(`connection acquired ${options.uuid}`);
          resolve(this.connections[options.inMemory || options.uuid]);
        }
      );
    });

    if (this.sequelize.config.password) {
      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher
      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);
    }
    if (this.sequelize.options.foreignKeys !== false) {
      // Make it possible to define and use foreign key constraints unless
      // explicitly disallowed. It's still opt-in per relation
      connection.run('PRAGMA FOREIGN_KEYS=ON');
    }

    return connection;
  }

  releaseConnection(connection, force) {
    if (connection.filename === ':memory:' && force !== true) return;

    if (connection.uuid) {
      connection.close();
      debug(`connection released ${connection.uuid}`);
      delete this.connections[connection.uuid];
    }
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');

  /**
   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._zerofill || dataType._unsigned) {
      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * @see https://sqlite.org/datatype3.html
   */

  BaseTypes.DATE.types.sqlite = ['DATETIME'];
  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];
  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];
  BaseTypes.TEXT.types.sqlite = ['TEXT'];
  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];
  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];
  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];
  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];
  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];
  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];
  BaseTypes.TIME.types.sqlite = ['TIME'];
  BaseTypes.DATEONLY.types.sqlite = ['DATE'];
  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];
  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];
  BaseTypes.UUID.types.sqlite = ['UUID'];
  BaseTypes.ENUM.types.sqlite = false;
  BaseTypes.REAL.types.sqlite = ['REAL'];
  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];
  BaseTypes.GEOMETRY.types.sqlite = false;
  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];

  class JSONTYPE extends BaseTypes.JSON {
    static parse(data) {
      return JSON.parse(data);
    }
  }

  class DATE extends BaseTypes.DATE {
    static parse(date, options) {
      if (!date.includes('+')) {
        // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set
        return new Date(date + options.timezone);
      }
      return new Date(date); // We already have a timezone stored in the string
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(date) {
      return date;
    }
  }

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return `VARCHAR BINARY(${this._length})`;
      }
      return super.toSql(this);
    }
  }

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  class CITEXT extends BaseTypes.CITEXT {
    toSql() {
      return 'TEXT COLLATE NOCASE';
    }
  }

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return `CHAR BINARY(${this._length})`;
      }
      return super.toSql();
    }
  }

  class NUMBER extends BaseTypes.NUMBER {
    toSql() {
      let result = this.key;
      if (this._unsigned) {
        result += ' UNSIGNED';
      }
      if (this._zerofill) {
        result += ' ZEROFILL';
      }
      if (this._length) {
        result += `(${this._length}`;
        if (typeof this._decimals === 'number') {
          result += `,${this._decimals}`;
        }
        result += ')';
      }
      return result;
    }
  }

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class MEDIUMINT extends BaseTypes.MEDIUMINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class FLOAT extends BaseTypes.FLOAT {
  }

  class DOUBLE extends BaseTypes.DOUBLE {
  }

  class REAL extends BaseTypes.REAL { }

  function parseFloating(value) {
    if (typeof value !== 'string') {
      return value;
    }
    if (value === 'NaN') {
      return NaN;
    }
    if (value === 'Infinity') {
      return Infinity;
    }
    if (value === '-Infinity') {
      return -Infinity;
    }
  }
  for (const floating of [FLOAT, DOUBLE, REAL]) {
    floating.parse = parseFloating;
  }


  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {
    num.prototype.toSql = NUMBER.prototype.toSql;
  }

  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'TEXT';
    }
  }

  return {
    DATE,
    DATEONLY,
    STRING,
    CHAR,
    NUMBER,
    FLOAT,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    TINYINT,
    SMALLINT,
    MEDIUMINT,
    INTEGER,
    BIGINT,
    TEXT,
    ENUM,
    JSON: JSONTYPE,
    CITEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/sqlite/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js");

class SqliteDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });

    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);
  }
}

SqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': false,
  'DEFAULT VALUES': true,
  'UNION ALL': false,
  'RIGHT JOIN': false,
  inserts: {
    ignoreDuplicates: ' OR IGNORE',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  index: {
    using: false,
    where: true,
    functionBased: true
  },
  transactionOptions: {
    type: true
  },
  constraints: {
    addConstraint: false,
    dropConstraint: false
  },
  joinTableDependent: false,
  groupedLimit: false,
  JSON: true
});

SqliteDialect.prototype.defaultVersion = '3.8.0';
SqliteDialect.prototype.Query = Query;
SqliteDialect.prototype.DataTypes = DataTypes;
SqliteDialect.prototype.name = 'sqlite';
SqliteDialect.prototype.TICK_CHAR = '`';
SqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;
SqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;

module.exports = SqliteDialect;
module.exports.SqliteDialect = SqliteDialect;
module.exports.default = SqliteDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");

class SQLiteQueryGenerator extends MySqlQueryGenerator {
  createSchema() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  showSchemasQuery() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  versionQuery() {
    return 'SELECT sqlite_version() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = options || {};

    const primaryKeys = [];
    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;
    const attrArray = [];

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        const dataType = attributes[attr];
        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');

        let dataTypeString = dataType;
        if (dataType.includes('PRIMARY KEY')) {
          if (dataType.includes('INT')) {
            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)
            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';

            if (dataType.includes(' REFERENCES')) {
              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));
            }
          }

          if (needsMultiplePrimaryKeys) {
            primaryKeys.push(attr);
            if (dataType.includes('NOT NULL')) {
              dataTypeString = dataType.replace(' PRIMARY KEY', '');
            } else {
              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');
            }
          }
        }
        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attrStr = attrArray.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attrStr += `, PRIMARY KEY (${pkString})`;
    }

    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;
    return this.replaceBooleanDefaults(sql);
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://sqlite.org/json1.html
    const jsonFunctionRegex = /^\s*(json(?:_[a-z]+){0,2})\([^)]*\)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  //sqlite can't cast to datetime so we need to convert date values to their ISO strings
  _toJSONValue(value) {
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (Array.isArray(value) && value[0] instanceof Date) {
      return value.map(val => val.toISOString());
    }
    return value;
  }


  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }

    if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      }
    }

    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, dataType) {
    const attributes = {};
    attributes[key] = dataType;
    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });
    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;

    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;

    return this.replaceBooleanDefaults(sql);
  }

  showTablesQuery() {
    return 'SELECT name FROM `sqlite_master` WHERE type=\'table\' and name!=\'sqlite_sequence\';';
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const modelAttributeMap = {};
    const values = [];
    const bind = [];
    const bindParam = options.bindParam || this.bindParam(bind);

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    let query;
    const whereOptions = { ...options, bindParam };

    if (options.limit) {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;
    } else {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;
    }

    return { query, bind };
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `DELETE FROM ${this.quoteTable(tableName)}`,
      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), "'")};` : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    _.defaults(options, this.options);

    let whereClause = this.getWhereConditions(where, null, model, options);

    if (whereClause) {
      whereClause = `WHERE ${whereClause}`;
    }

    if (options.limit) {
      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;
    }

    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;
  }

  attributesToSQL(attributes) {
    const result = {};
    for (const name in attributes) {
      const dataType = attributes[name];
      const fieldName = dataType.field || name;

      if (_.isObject(dataType)) {
        let sql = dataType.type.toString();

        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {
          sql += ' NOT NULL';
        }

        if (Utils.defaultValueSchemable(dataType.defaultValue)) {
          // TODO thoroughly check that DataTypes.NOW will properly
          // get populated on all databases as DEFAULT value
          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP
          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;
        }

        if (dataType.unique === true) {
          sql += ' UNIQUE';
        }

        if (dataType.primaryKey) {
          sql += ' PRIMARY KEY';

          if (dataType.autoIncrement) {
            sql += ' AUTOINCREMENT';
          }
        }

        if (dataType.references) {
          const referencesTable = this.quoteTable(dataType.references.model);

          let referencesKey;
          if (dataType.references.key) {
            referencesKey = this.quoteIdentifier(dataType.references.key);
          } else {
            referencesKey = this.quoteIdentifier('id');
          }

          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

          if (dataType.onDelete) {
            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;
          }

          if (dataType.onUpdate) {
            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;
          }

        }

        result[fieldName] = sql;
      } else {
        result[fieldName] = dataType;
      }
    }

    return result;
  }

  showIndexesQuery(tableName) {
    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;
  }

  showConstraintsQuery(tableName, constraintName) {
    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;

    if (constraintName) {
      sql += ` AND sql LIKE '%${constraintName}%'`;
    }

    return `${sql};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = {
      _schema: schema,
      _schemaDelimiter: schemaDelimiter,
      tableName
    };
    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;
  }

  describeCreateTableQuery(tableName) {
    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;
  }

  removeColumnQuery(tableName, attributes) {

    attributes = this.attributesToSQL(attributes);

    let backupTableName;
    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary table cannot work for foreign keys.
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  _alterConstraintQuery(tableName, attributes, createTableSql) {
    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }
    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    return `${createTableSql
      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)
      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '"')}`, `CREATE TABLE ${quotedBackupTableName}`)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};`
      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;
  }

  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {

    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNamesImport = Object.keys(attributes).map(attr =>
      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)
    ).join(', ');
    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;
    }

    return `BEGIN ${transaction.options.type} TRANSACTION;`;
  }

  setIsolationLevelQuery(value) {
    switch (value) {
      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';
      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
        return 'PRAGMA read_uncommitted = ON;';
      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
        return 'PRAGMA read_uncommitted = OFF;';
      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
        return '-- SQLite\'s default isolation level is SERIALIZABLE. Nothing to do.';
      default:
        throw new Error(`Unknown isolation level: ${value}`);
    }
  }

  replaceBooleanDefaults(sql) {
    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return `PRAGMA foreign_key_list(${tableName})`;
  }
}

module.exports = SQLiteQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const { cloneDeep } = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

/**
 * The interface that Sequelize uses to talk with SQLite database
 */
class SQLiteQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes SQLite's inability to remove columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but without the obsolete column.
   *
   * @override
   */
  async removeColumn(tableName, attributeName, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    delete fields[attributeName];

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to change columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a modified version of the respective column.
   *
   * @override
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to rename columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a renamed version of the respective column.
   *
   * @override
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);

    fields[attrNameAfter] = { ...fields[attrNameBefore] };
    delete fields[attrNameBefore];

    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    let createTableSql;

    const constraints = await this.showConstraint(tableName, constraintName);
    // sqlite can't show only one constraint, so we find here the one to remove
    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);

    if (!constraint) {
      throw new sequelizeErrors.UnknownConstraintError({
        message: `Constraint ${constraintName} on table ${tableName} does not exist`,
        constraint: constraintName,
        table: tableName
      });
    }
    createTableSql = constraint.sql;
    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;

    if (constraint.constraintType === 'FOREIGN KEY') {
      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);
      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));
      const referenceTableKeys = constraint.referenceTableKeys.join(', ');
      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;
      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;
      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;
    }

    createTableSql = createTableSql.replace(constraintSnippet, '');
    createTableSql += ';';

    const fields = await this.describeTable(tableName, options);

    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = cloneDeep(options);

    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);

    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options, type: QueryTypes.SELECT, raw: true });
    let sql = constraints[0].sql;
    const index = sql.length - 1;
    //Replace ending ')' with constraint snippet - Simulates String.replaceAt
    //http://stackoverflow.com/questions/1431094
    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;

    const fields = await this.describeTable(tableName, options);
    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const database = this.sequelize.config.database;
    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);
    const result = await this.sequelize.query(query, options);
    return result.map(row => ({
      tableName,
      columnName: row.from,
      referencedTableName: row.table,
      referencedColumnName: row.to,
      tableCatalog: database,
      referencedTableCatalog: database
    }));
  }

  /**
   * @override
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);
    await this._dropAllTables(tableNames, skip, options);
    await this.sequelize.query('PRAGMA foreign_keys = ON', options);
  }

  /**
   * @override
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };
    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      const indexes = await this.sequelize.query(sqlIndexes, options);
      for (const prop in data) {
        data[prop].unique = false;
      }
      for (const index of indexes) {
        for (const field of index.fields) {
          if (index.unique !== undefined) {
            data[field.attribute].unique = index.unique;
          }
        }
      }

      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);
      for (const foreignKey of foreignKeys) {
        data[foreignKey.columnName].references = {
          model: foreignKey.referencedTableName,
          key: foreignKey.referencedColumnName
        };
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }
}

exports.SQLiteQueryInterface = SQLiteQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:sqlite');


class Query extends AbstractQuery {
  getInsertIdField() {
    return 'lastID';
  }

  /**
   * rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    let bindParam;
    if (Array.isArray(values)) {
      bindParam = {};
      values.forEach((v, i) => {
        bindParam[`$${i + 1}`] = v;
      });
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = {};
      if (typeof values === 'object') {
        for (const k of Object.keys(values)) {
          bindParam[`$${k}`] = values[k];
        }
      }
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    }
    return [sql, bindParam];
  }

  _collectModels(include, prefix) {
    const ret = {};

    if (include) {
      for (const _include of include) {
        let key;
        if (!prefix) {
          key = _include.as;
        } else {
          key = `${prefix}.${_include.as}`;
        }
        ret[key] = _include.model;

        if (_include.include) {
          _.merge(ret, this._collectModels(_include.include, key));
        }
      }
    }

    return ret;
  }

  _handleQueryResponse(metaData, columnTypes, err, results) {
    if (err) {
      err.sql = this.sql;
      throw this.formatError(err);
    }
    let result = this.instance;

    // add the inserted row id to the instance
    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
      this.handleInsertQuery(results, metaData);
      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          metaData.constructor.name === 'Statement'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
          result = [];
          for (let i = startId; i < startId + metaData.changes; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = metaData[this.getInsertIdField()];
        }
      }
    }

    if (this.isShowTablesQuery()) {
      return results.map(row => row.name);
    }
    if (this.isShowConstraintsQuery()) {
      result = results;
      if (results && results[0] && results[0].sql) {
        result = this.parseConstraintsFromSql(results[0].sql);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      if (this.options.raw) {
        return this.handleSelectQuery(results);
      }
      // This is a map of prefix strings to models, e.g. user.projects -> Project model
      const prefixes = this._collectModels(this.options.include);

      results = results.map(result => {
        return _.mapValues(result, (value, name) => {
          let model;
          if (name.includes('.')) {
            const lastind = name.lastIndexOf('.');

            model = prefixes[name.substr(0, lastind)];

            name = name.substr(lastind + 1);
          } else {
            model = this.options.model;
          }

          const tableName = model.getTableName().toString().replace(/`/g, '');
          const tableTypes = columnTypes[tableName] || {};

          if (tableTypes && !(name in tableTypes)) {
            // The column is aliased
            _.forOwn(model.rawAttributes, (attribute, key) => {
              if (name === key && attribute.field) {
                name = attribute.field;
                return false;
              }
            });
          }

          return Object.prototype.hasOwnProperty.call(tableTypes, name)
            ? this.applyParsers(tableTypes[name], value)
            : value;
        });
      });

      return this.handleSelectQuery(results);
    }
    if (this.isShowOrDescribeQuery()) {
      return results;
    }
    if (this.sql.includes('PRAGMA INDEX_LIST')) {
      return this.handleShowIndexesQuery(results);
    }
    if (this.sql.includes('PRAGMA INDEX_INFO')) {
      return results;
    }
    if (this.sql.includes('PRAGMA TABLE_INFO')) {
      // this is the sqlite way of getting the metadata of a table
      result = {};

      let defaultValue;
      for (const _result of results) {
        if (_result.dflt_value === null) {
          // Column schema omits any "DEFAULT ..."
          defaultValue = undefined;
        } else if (_result.dflt_value === 'NULL') {
          // Column schema is a "DEFAULT NULL"
          defaultValue = null;
        } else {
          defaultValue = _result.dflt_value;
        }

        result[_result.name] = {
          type: _result.type,
          allowNull: _result.notnull === 0,
          defaultValue,
          primaryKey: _result.pk !== 0
        };

        if (result[_result.name].type === 'TINYINT(1)') {
          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];
        }

        if (typeof result[_result.name].defaultValue === 'string') {
          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');
        }
      }
      return result;
    }
    if (this.sql.includes('PRAGMA foreign_keys;')) {
      return results[0];
    }
    if (this.sql.includes('PRAGMA foreign_keys')) {
      return results;
    }
    if (this.sql.includes('PRAGMA foreign_key_list')) {
      return results;
    }
    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {
      return metaData.changes;
    }
    if (this.options.type === QueryTypes.VERSION) {
      return results[0].version;
    }
    if (this.options.type === QueryTypes.RAW) {
      return [results, metaData];
    }
    if (this.isUpsertQuery()) {
      return [result, null];
    }
    if (this.isUpdateQuery() || this.isInsertQuery()) {
      return [result, metaData.changes];
    }
    return result;
  }

  async run(sql, parameters) {
    const conn = this.connection;
    this.sql = sql;
    const method = this.getDatabaseMethod();
    const complete = this._logQuery(sql, debug, parameters);

    return new Promise((resolve, reject) => conn.serialize(async () => {
      const columnTypes = {};
      const executeSql = () => {
        if (sql.startsWith('-- ')) {
          return resolve();
        }
        const query = this;
        // cannot use arrow function here because the function is bound to the statement
        function afterExecute(executionError, results) {
          try {
            complete();
            // `this` is passed from sqlite, we have no control over this.
            // eslint-disable-next-line no-invalid-this
            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));
            return;
          } catch (error) {
            reject(error);
          }
        }

        if (!parameters) parameters = [];
        conn[method](sql, parameters, afterExecute);

        return null;
      };

      if (this.getDatabaseMethod() === 'all') {
        let tableNames = [];
        if (this.options && this.options.tableNames) {
          tableNames = this.options.tableNames;
        } else if (/FROM `(.*?)`/i.exec(this.sql)) {
          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);
        }

        // If we already have the metadata for the table, there's no need to ask for it again
        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');

        if (!tableNames.length) {
          return executeSql();
        }
        await Promise.all(tableNames.map(tableName =>
          new Promise(resolve => {
            tableName = tableName.replace(/`/g, '');
            columnTypes[tableName] = {};

            conn.all(`PRAGMA table_info(\`${tableName}\`)`, (err, results) => {
              if (!err) {
                for (const result of results) {
                  columnTypes[tableName][result.name] = result.type;
                }
              }
              resolve();
            });
          })));
      }
      return executeSql();
    }));
  }

  parseConstraintsFromSql(sql) {
    let constraints = sql.split('CONSTRAINT ');
    let referenceTableName, referenceTableKeys, updateAction, deleteAction;
    constraints.splice(0, 1);
    constraints = constraints.map(constraintSql => {
      //Parse foreign key snippets
      if (constraintSql.includes('REFERENCES')) {
        //Parse out the constraint condition form sql string
        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);

        if (updateAction) {
          updateAction = updateAction[1];
        }

        if (deleteAction) {
          deleteAction = deleteAction[1];
        }

        const referencesRegex = /REFERENCES.+\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/;
        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');
        referenceTableName = Utils.removeTicks(referenceConditions[1]);
        let columnNames = referenceConditions[2];
        columnNames = columnNames.replace(/\(|\)/g, '').split(', ');
        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));
      }

      const constraintCondition = constraintSql.match(/\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/)[0];
      constraintSql = constraintSql.replace(/\(.+\)/, '');
      const constraint = constraintSql.split(' ');

      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {
        constraint[1] += ' KEY';
      }

      return {
        constraintName: Utils.removeTicks(constraint[0]),
        constraintType: constraint[1],
        updateAction,
        deleteAction,
        sql: sql.replace(/"/g, '`'), //Sqlite returns double quotes for table name
        constraintCondition,
        referenceTableName,
        referenceTableKeys
      };
    });

    return constraints;
  }

  applyParsers(type, value) {
    if (type.includes('(')) {
      // Remove the length part
      type = type.substr(0, type.indexOf('('));
    }
    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');
    type = type.trim().toUpperCase();
    const parse = parserStore.get(type);

    if (value !== null && parse) {
      return parse(value, { timezone: this.sequelize.options.timezone });
    }
    return value;
  }

  formatError(err) {

    switch (err.code) {
      case 'SQLITE_CONSTRAINT': {
        if (err.message.includes('FOREIGN KEY constraint failed')) {
          return new sequelizeErrors.ForeignKeyConstraintError({
            parent: err
          });
        }

        let fields = [];

        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique
        let match = err.message.match(/columns (.*?) are/);
        if (match !== null && match.length >= 2) {
          fields = match[1].split(', ');
        } else {

          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y
          match = err.message.match(/UNIQUE constraint failed: (.*)/);
          if (match !== null && match.length >= 2) {
            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);
          }
        }

        const errors = [];
        let message = 'Validation error';

        for (const field of fields) {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            this.instance && this.instance[field],
            this.instance,
            'not_unique'
          ));
        }

        if (this.model) {
          _.forOwn(this.model.uniqueKeys, constraint => {
            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {
              message = constraint.msg;
              return false;
            }
          });
        }

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }
      case 'SQLITE_BUSY':
        return new sequelizeErrors.TimeoutError(err);

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  async handleShowIndexesQuery(data) {
    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!
    return Promise.all(data.reverse().map(async item => {
      item.fields = [];
      item.primary = false;
      item.unique = !!item.unique;
      item.constraintName = item.name;
      const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
      for (const column of columns) {
        item.fields[column.seqno] = {
          attribute: column.name,
          length: undefined,
          order: undefined
        };
      }

      return item;
    }));
  }

  getDatabaseMethod() {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
      return 'run';
    }
    return 'all';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/aggregate-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A wrapper for multiple Errors
 *
 * @param {Error[]} [errors] Array of errors
 *
 * @property errors {Error[]}
 */
class AggregateError extends BaseError {
  constructor(errors) {
    super();
    this.errors = errors;
    this.name = 'AggregateError';
  }

  toString() {
    const message = `AggregateError of:\n${
      this.errors.map(error =>
        error === this
          ? '[Circular AggregateError]'
          : error instanceof AggregateError
            ? String(error).replace(/\n$/, '').replace(/^/mg, '  ')
            : String(error).replace(/^/mg, '    ').substring(2)
        
      ).join('\n')
    }\n`;
    return message;
  }
}

module.exports = AggregateError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/association-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/association-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an association is improperly constructed (see message for details)
 */
class AssociationError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAssociationError';
  }
}

module.exports = AssociationError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/base-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/base-error.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.
 * All sequelize errors inherit from the base JS error object.
 *
 * This means that errors can be accessed using `Sequelize.ValidationError`
 * The Base Error all Sequelize Errors inherit from.
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'SequelizeBaseError';
  }
}

module.exports = BaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when bulk operation fails, it represent per record level error.
 * Used with AggregateError
 *
 * @param {Error}  error   Error for a given record/instance
 * @param {object} record  DAO instance that error belongs to
 */
class BulkRecordError extends BaseError {
  constructor(error, record) {
    super(error.message);
    this.name = 'SequelizeBulkRecordError';
    this.errors = error;
    this.record = record;
  }
}

module.exports = BulkRecordError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all connection related errors.
 */
class ConnectionError extends BaseError {
  constructor(parent) {
    super(parent ? parent.message : '');
    this.name = 'SequelizeConnectionError';
    /**
     * The connection specific error which triggered this one
     *
     * @type {Error}
     */
    this.parent = parent;
    this.original = parent;
  }
}

module.exports = ConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused due to insufficient privileges
 */
class AccessDeniedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeAccessDeniedError';
  }
}

module.exports = AccessDeniedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when connection is not acquired due to timeout
 */
class ConnectionAcquireTimeoutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionAcquireTimeoutError';
  }
}

module.exports = ConnectionAcquireTimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused
 */
class ConnectionRefusedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionRefusedError';
  }
}

module.exports = ConnectionRefusedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database times out
 */
class ConnectionTimedOutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionTimedOutError';
  }
}

module.exports = ConnectionTimedOutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not found
 */
class HostNotFoundError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotFoundError';
  }
}

module.exports = HostNotFoundError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not reachable
 */
class HostNotReachableError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotReachableError';
  }
}

module.exports = HostNotReachableError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has invalid values for any of the connection parameters
 */
class InvalidConnectionError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeInvalidConnectionError';
  }
}

module.exports = InvalidConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all database related errors.
 */
class DatabaseError extends BaseError {
  constructor(parent) {
    super(parent.message);
    this.name = 'SequelizeDatabaseError';
    /**
     * @type {Error}
     */
    this.parent = parent;
    /**
     * @type {Error}
     */
    this.original = parent;
    /**
     * The SQL that triggered the error
     *
     * @type {string}
     */
    this.sql = parent.sql;
    /**
     * The parameters for the sql that triggered the error
     *
     * @type {Array<any>}
     */
    this.parameters = parent.parameters;
  }
}

module.exports = DatabaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when an exclusion constraint is violated in the database
 */
class ExclusionConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeExclusionConstraintError';

    this.message = options.message || options.parent.message || '';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = ExclusionConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a foreign key constraint is violated in the database
 */
class ForeignKeyConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeForeignKeyConstraintError';

    this.message = options.message || options.parent.message || 'Database Error';
    this.fields = options.fields;
    this.table = options.table;
    this.value = options.value;
    this.index = options.index;
    this.reltype = options.reltype;
  }
}

module.exports = ForeignKeyConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a database query times out because of a deadlock
 */
class TimeoutError extends DatabaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeTimeoutError';
  }
}

module.exports = TimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when constraint name is not found in the database
 */
class UnknownConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeUnknownConstraintError';

    this.message = options.message || 'The specified constraint does not exist';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = UnknownConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an include statement is improperly constructed (see message for details)
 */
class EagerLoadingError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEagerLoadingError';
  }
}

module.exports = EagerLoadingError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/empty-result-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)
 */
class EmptyResultError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEmptyResultError';
  }
}

module.exports = EmptyResultError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

exports.AggregateError = __webpack_require__(/*! ./aggregate-error */ "./node_modules/sequelize/lib/errors/aggregate-error.js");
exports.AsyncQueueError = __webpack_require__(/*! ../dialects/mssql/async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").AsyncQueueError;
exports.AssociationError = __webpack_require__(/*! ./association-error */ "./node_modules/sequelize/lib/errors/association-error.js");
exports.BulkRecordError = __webpack_require__(/*! ./bulk-record-error */ "./node_modules/sequelize/lib/errors/bulk-record-error.js");
exports.ConnectionError = __webpack_require__(/*! ./connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");
exports.DatabaseError = __webpack_require__(/*! ./database-error */ "./node_modules/sequelize/lib/errors/database-error.js");
exports.EagerLoadingError = __webpack_require__(/*! ./eager-loading-error */ "./node_modules/sequelize/lib/errors/eager-loading-error.js");
exports.EmptyResultError = __webpack_require__(/*! ./empty-result-error */ "./node_modules/sequelize/lib/errors/empty-result-error.js");
exports.InstanceError = __webpack_require__(/*! ./instance-error */ "./node_modules/sequelize/lib/errors/instance-error.js");
exports.OptimisticLockError = __webpack_require__(/*! ./optimistic-lock-error */ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js");
exports.QueryError = __webpack_require__(/*! ./query-error */ "./node_modules/sequelize/lib/errors/query-error.js");
exports.SequelizeScopeError = __webpack_require__(/*! ./sequelize-scope-error */ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js");
exports.ValidationError = __webpack_require__(/*! ./validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");
exports.ValidationErrorItem = exports.ValidationError.ValidationErrorItem;

exports.AccessDeniedError = __webpack_require__(/*! ./connection/access-denied-error */ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js");
exports.ConnectionAcquireTimeoutError = __webpack_require__(/*! ./connection/connection-acquire-timeout-error */ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js");
exports.ConnectionRefusedError = __webpack_require__(/*! ./connection/connection-refused-error */ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js");
exports.ConnectionTimedOutError = __webpack_require__(/*! ./connection/connection-timed-out-error */ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js");
exports.HostNotFoundError = __webpack_require__(/*! ./connection/host-not-found-error */ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js");
exports.HostNotReachableError = __webpack_require__(/*! ./connection/host-not-reachable-error */ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js");
exports.InvalidConnectionError = __webpack_require__(/*! ./connection/invalid-connection-error */ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js");

exports.ExclusionConstraintError = __webpack_require__(/*! ./database/exclusion-constraint-error */ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js");
exports.ForeignKeyConstraintError = __webpack_require__(/*! ./database/foreign-key-constraint-error */ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js");
exports.TimeoutError = __webpack_require__(/*! ./database/timeout-error */ "./node_modules/sequelize/lib/errors/database/timeout-error.js");
exports.UnknownConstraintError = __webpack_require__(/*! ./database/unknown-constraint-error */ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js");

exports.UniqueConstraintError = __webpack_require__(/*! ./validation/unique-constraint-error */ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/instance-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/instance-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a some problem occurred with Instance methods (see message for details)
 */
class InstanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeInstanceError';
  }
}

module.exports = InstanceError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when attempting to update a stale model instance
 */
class OptimisticLockError extends BaseError {
  constructor(options) {
    options = options || {};
    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;
    super(options.message);
    this.name = 'SequelizeOptimisticLockError';
    /**
     * The name of the model on which the update was attempted
     *
     * @type {string}
     */
    this.modelName = options.modelName;
    /**
     * The values of the attempted update
     *
     * @type {object}
     */
    this.values = options.values;
    /**
     *
     * @type {object}
     */
    this.where = options.where;
  }
}

module.exports = OptimisticLockError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/query-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/query-error.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a query is passed invalid options (see message for details)
 */
class QueryError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeQueryError';
  }
}

module.exports = QueryError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Scope Error. Thrown when the sequelize cannot query the specified scope.
 */
class SequelizeScopeError extends BaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeScopeError';
  }
}

module.exports = SequelizeScopeError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,
 * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.
 *
 * @param {string} message Error message
 * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors
 *
 * @property errors {ValidationErrorItems[]}
 */
class ValidationError extends BaseError {
  constructor(message, errors) {
    super(message);
    this.name = 'SequelizeValidationError';
    this.message = 'Validation Error';
    /**
     *
     * @type {ValidationErrorItem[]}
     */
    this.errors = errors || [];

    // Use provided error message if available...
    if (message) {
      this.message = message;

      // ... otherwise create a concatenated message out of existing errors.
    } else if (this.errors.length > 0 && this.errors[0].message) {
      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\n');
    }
  }

  /**
   * Gets all validation error items for the path / field specified.
   *
   * @param {string} path The path to be checked for error items
   *
   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path
   */
  get(path) {
    return this.errors.reduce((reduced, error) => {
      if (error.path === path) {
        reduced.push(error);
      }
      return reduced;
    }, []);
  }
}

/**
 * Validation Error Item
 * Instances of this class are included in the `ValidationError.errors` property.
 */
class ValidationErrorItem {
  /**
   * Creates a new ValidationError item. Instances of this class are included in the `ValidationError.errors` property.
   *
   * @param {string} [message] An error message
   * @param {string} [type] The type/origin of the validation error
   * @param {string} [path] The field that triggered the validation error
   * @param {string} [value] The value that generated the error
   * @param {Model} [instance] the DAO instance that caused the validation error
   * @param {string} [validatorKey] a validation "key", used for identification
   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
   * @param {Array} [fnArgs] parameters used with the BUILT-IN validator function, if applicable
   */
  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {
    /**
     * An error message
     *
     * @type {string} message
     */
    this.message = message || '';

    /**
     * The type/origin of the validation error
     *
     * @type {string | null}
     */
    this.type = null;

    /**
     * The field that triggered the validation error
     *
     * @type {string | null}
     */
    this.path = path || null;

    /**
     * The value that generated the error
     *
     * @type {string | null}
     */
    this.value = value !== undefined ? value : null;

    this.origin = null;

    /**
     * The DAO instance that caused the validation error
     *
     * @type {Model | null}
     */
    this.instance = instance || null;

    /**
     * A validation "key", used for identification
     *
     * @type {string | null}
     */
    this.validatorKey = validatorKey || null;

    /**
     * Property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
     *
     * @type {string | null}
     */
    this.validatorName = fnName || null;

    /**
     * Parameters used with the BUILT-IN validator function, if applicable
     *
     * @type {Array}
     */
    this.validatorArgs = fnArgs || [];

    if (type) {
      if (ValidationErrorItem.Origins[ type ]) {
        this.origin = type;
      } else {
        const lowercaseType = `${type}`.toLowerCase().trim();
        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];

        if (realType && ValidationErrorItem.Origins[ realType ]) {
          this.origin = realType;
          this.type = type;
        }
      }
    }

    // This doesn't need captureStackTrace because it's not a subclass of Error
  }

  /**
   * return a lowercase, trimmed string "key" that identifies the validator.
   *
   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property
   *
   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is "namespace",
   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins
   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,
   *                                            defaults to "." (fullstop). only used and validated if useTypeAsNS is TRUE.
   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.
   * @returns  {string}
   *
   * @private
   */
  getValidatorKey(useTypeAsNS, NSSeparator) {
    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;
    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;

    const type = this.origin;
    const key = this.validatorKey || this.validatorName;
    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];

    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {
      throw new Error('Invalid namespace separator given, must be a non-empty string');
    }

    if (!(typeof key === 'string' && key.length)) {
      return '';
    }

    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();
  }
}

/**
 * An enum that defines valid ValidationErrorItem `origin` values
 *
 * @type {object}
 * @property CORE       {string}  specifies errors that originate from the sequelize "core"
 * @property DB         {string}  specifies validation errors that originate from the storage engine
 * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute
 */
ValidationErrorItem.Origins = {
  CORE: 'CORE',
  DB: 'DB',
  FUNCTION: 'FUNCTION'
};

/**
 * An object that is used internally by the `ValidationErrorItem` class
 * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to
 * our new `origin` values.
 *
 * @type {object}
 */
ValidationErrorItem.TypeStringMap = {
  'notnull violation': 'CORE',
  'string violation': 'CORE',
  'unique violation': 'DB',
  'validation error': 'FUNCTION'
};

module.exports = ValidationError;
module.exports.ValidationErrorItem = ValidationErrorItem;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ValidationError = __webpack_require__(/*! ./../validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");

/**
 * Thrown when a unique constraint is violated in the database
 */
class UniqueConstraintError extends ValidationError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };
    options.message = options.message || options.parent.message || 'Validation Error';
    options.errors = options.errors || {};
    super(options.message, options.errors);

    this.name = 'SequelizeUniqueConstraintError';
    this.errors = options.errors;
    this.fields = options.fields;
    this.parent = options.parent;
    this.original = options.parent;
    this.sql = options.parent.sql;
  }
}

module.exports = UniqueConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('hooks');

const hookTypes = {
  beforeValidate: { params: 2 },
  afterValidate: { params: 2 },
  validationFailed: { params: 3 },
  beforeCreate: { params: 2 },
  afterCreate: { params: 2 },
  beforeDestroy: { params: 2 },
  afterDestroy: { params: 2 },
  beforeRestore: { params: 2 },
  afterRestore: { params: 2 },
  beforeUpdate: { params: 2 },
  afterUpdate: { params: 2 },
  beforeSave: { params: 2, proxies: ['beforeUpdate', 'beforeCreate'] },
  afterSave: { params: 2, proxies: ['afterUpdate', 'afterCreate'] },
  beforeUpsert: { params: 2 },
  afterUpsert: { params: 2 },
  beforeBulkCreate: { params: 2 },
  afterBulkCreate: { params: 2 },
  beforeBulkDestroy: { params: 1 },
  afterBulkDestroy: { params: 1 },
  beforeBulkRestore: { params: 1 },
  afterBulkRestore: { params: 1 },
  beforeBulkUpdate: { params: 1 },
  afterBulkUpdate: { params: 1 },
  beforeFind: { params: 1 },
  beforeFindAfterExpandIncludeAll: { params: 1 },
  beforeFindAfterOptions: { params: 1 },
  afterFind: { params: 2 },
  beforeCount: { params: 1 },
  beforeDefine: { params: 2, sync: true, noModel: true },
  afterDefine: { params: 1, sync: true, noModel: true },
  beforeInit: { params: 2, sync: true, noModel: true },
  afterInit: { params: 1, sync: true, noModel: true },
  beforeAssociate: { params: 2, sync: true },
  afterAssociate: { params: 2, sync: true },
  beforeConnect: { params: 1, noModel: true },
  afterConnect: { params: 2, noModel: true },
  beforeDisconnect: { params: 1, noModel: true },
  afterDisconnect: { params: 1, noModel: true },
  beforeSync: { params: 1 },
  afterSync: { params: 1 },
  beforeBulkSync: { params: 1 },
  afterBulkSync: { params: 1 },
  beforeQuery: { params: 2 },
  afterQuery: { params: 2 }
};
exports.hooks = hookTypes;


/**
 * get array of current hook and its proxies combined
 *
 * @param {string} hookType any hook type @see {@link hookTypes}
 *
 * @private
 */
const getProxiedHooks = hookType =>
  hookTypes[hookType].proxies
    ? hookTypes[hookType].proxies.concat(hookType)
    : [hookType]
;

function getHooks(hooked, hookType) {
  return (hooked.options.hooks || {})[hookType] || [];
}

const Hooks = {
  /**
   * Process user supplied hooks definition
   *
   * @param {object} hooks hooks definition
   *
   * @private
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  _setupHooks(hooks) {
    this.options.hooks = {};
    _.map(hooks || {}, (hooksArray, hookName) => {
      if (!Array.isArray(hooksArray)) hooksArray = [hooksArray];
      hooksArray.forEach(hookFn => this.addHook(hookName, hookFn));
    });
  },

  async runHooks(hooks, ...hookArgs) {
    if (!hooks) throw new Error('runHooks requires at least 1 argument');

    let hookType;

    if (typeof hooks === 'string') {
      hookType = hooks;
      hooks = getHooks(this, hookType);

      if (this.sequelize) {
        hooks = hooks.concat(getHooks(this.sequelize, hookType));
      }
    }

    if (!Array.isArray(hooks)) {
      hooks = [hooks];
    }

    // synchronous hooks
    if (hookTypes[hookType] && hookTypes[hookType].sync) {
      for (let hook of hooks) {
        if (typeof hook === 'object') {
          hook = hook.fn;
        }

        debug(`running hook(sync) ${hookType}`);
        hook.apply(this, hookArgs);
      }
      return;
    }

    // asynchronous hooks (default)
    for (let hook of hooks) {
      if (typeof hook === 'object') {
        hook = hook.fn;
      }

      debug(`running hook ${hookType}`);
      await hook.apply(this, hookArgs);
    }
  },

  /**
   * Add a hook to the model
   *
   * @param {string}          hookType hook name @see {@link hookTypes}
   * @param {string|Function} [name] Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.
   * @param {Function}        fn The hook function
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  addHook(hookType, name, fn) {
    if (typeof name === 'function') {
      fn = name;
      name = null;
    }

    debug(`adding hook ${hookType}`);
    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    hookType.forEach(type => {
      const hooks = getHooks(this, type);
      hooks.push(name ? { name, fn } : fn);
      this.options.hooks[type] = hooks;
    });

    return this;
  },

  /**
   * Remove hook from the model
   *
   * @param {string} hookType @see {@link hookTypes}
   * @param {string|Function} name name of hook or function reference which was attached
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  removeHook(hookType, name) {
    const isReference = typeof name === 'function' ? true : false;

    if (!this.hasHook(hookType)) {
      return this;
    }

    debug(`removing hook ${hookType}`);

    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    for (const type of hookType) {
      this.options.hooks[type] = this.options.hooks[type].filter(hook => {
        if (isReference && typeof hook === 'function') {
          return hook !== name; // check if same method
        }
        if (!isReference && typeof hook === 'object') {
          return hook.name !== name;
        }
        return true;
      });
    }

    return this;
  },

  /**
   * Check whether the mode has any hooks of this type
   *
   * @param {string} hookType @see {@link hookTypes}
   *
   * @alias hasHooks
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  hasHook(hookType) {
    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;
  }
};
Hooks.hasHooks = Hooks.hasHook;


function applyTo(target, isModel = false) {
  _.mixin(target, Hooks);

  for (const hook of Object.keys(hookTypes)) {
    if (isModel && hookTypes[hook].noModel) {
      continue;
    }
    target[hook] = function(name, callback) {
      return this.addHook(hook, name, callback);
    };
  }
}
exports.applyTo = applyTo;

/**
 * A hook that is run before validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run when validation fails
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options, error. Error is the
 * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.
 * @name validationFailed
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name afterCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeSave
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeUpsert
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the result of upsert(), options
 * @name afterUpsert
 * @memberof Sequelize.Model
 */

/**
  * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with attributes, options
  * @name afterSave
  * @memberof Sequelize.Model
  */

/**
 * A hook that is run before destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name beforeBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name afterBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name afterBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterExpandIncludeAll
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after all option parsing is complete
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterOptions
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance(s), options
 * @name afterFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a count query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeCount
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run after a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with factory
 * @name afterDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run before Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config, options
 * @name beforeInit
 * @memberof Sequelize
 */

/**
 * A hook that is run after Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with sequelize
 * @name afterInit
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config passed to connection
 * @name beforeConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object and the config passed to connection
 * @name afterConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name beforeDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name afterDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name beforeSync
 * @memberof Sequelize
 */

/**
 * A hook that is run after Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name afterSync
 * @memberof Sequelize
 */

/**
  * A hook that is run before sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name beforeBulkSync
  * @memberof Sequelize
  */

/**
  * A hook that is run after sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name afterBulkSync
  * @memberof Sequelize
  */


/***/ }),

/***/ "./node_modules/sequelize/lib/index-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/index-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of index hints to be used in mysql for querying with index hints
 *
 * @property USE
 * @property FORCE
 * @property IGNORE
 */
const IndexHints = module.exports = { // eslint-disable-line
  USE: 'USE',
  FORCE: 'FORCE',
  IGNORE: 'IGNORE'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/instance-validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/instance-validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const sequelizeError = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * Instance Validator.
 *
 * @param {Instance} modelInstance The model instance.
 * @param {object} options A dictionary with options.
 *
 * @private
 */
class InstanceValidator {
  constructor(modelInstance, options) {
    options = {
      // assign defined and default options
      hooks: true,
      ...options
    };

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } else {
      options.skip = options.skip || [];
    }

    this.options = options;

    this.modelInstance = modelInstance;

    /**
     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
     *
     * @name validator
     * @private
     */
    this.validator = validator;

    /**
     *  All errors will be stored here from the validations.
     *
     * @type {Array} Will contain keys that correspond to attributes which will
     *   be Arrays of Errors.
     * @private
     */
    this.errors = [];

    /**
     * @type {boolean} Indicates if validations are in progress
     * @private
     */
    this.inProgress = false;
  }

  /**
   * The main entry point for the Validation module, invoke to start the dance.
   *
   * @returns {Promise}
   * @private
   */
  async _validate() {
    if (this.inProgress) throw new Error('Validations already in progress.');

    this.inProgress = true;

    await Promise.all([
      this._perAttributeValidators(),
      this._customValidators()
    ]);

    if (this.errors.length) {
      throw new sequelizeError.ValidationError(null, this.errors);
    }
  }

  /**
   * Invoke the Validation sequence and run validation hooks if defined
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async validate() {
    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());
  }

  /**
   * Invoke the Validation sequence and run hooks
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async _validateAndRunHooks() {
    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
    await runHooks('beforeValidate', this.modelInstance, this.options);

    try {
      await this._validate();
    } catch (error) {
      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);
      throw newError || error;
    }

    await runHooks('afterValidate', this.modelInstance, this.options);
    return this.modelInstance;
  }

  /**
   * Will run all the validators defined per attribute (built-in validators and custom validators)
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _perAttributeValidators() {
    // promisify all attribute invocations
    const validators = [];

    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
      if (this.options.skip.includes(field)) {
        return;
      }

      const value = this.modelInstance.dataValues[field];

      if (value instanceof Utils.SequelizeMethod) {
        return;
      }

      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
        // perform validations based on schema
        this._validateSchema(rawAttribute, field, value);
      }

      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));
      }
    });

    return await Promise.all(validators);
  }

  /**
   * Will run all the custom validators defined in the model's options.
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _customValidators() {
    const validators = [];
    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {
      if (this.options.skip.includes(validatorType)) {
        return;
      }

      const valprom = this._invokeCustomValidator(validator, validatorType)
        // errors are handled in settling, stub this
        .catch(() => {});

      validators.push(valprom);
    });

    return await Promise.all(validators);
  }

  /**
   * Validate a single attribute with all the defined built-in validators and custom validators.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {string} field The field name.
   * @param {boolean} allowNull Whether or not the schema allows null values
   *
   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.
   */
  async _singleAttrValidate(value, field, allowNull) {
    // If value is null and allowNull is false, no validators should run (see #9143)
    if ((value === null || value === undefined) && !allowNull) {
      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.
      return;
    }

    // Promisify each validator
    const validators = [];
    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {

      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {
        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
        if (typeof test === 'object' && test !== null && test.msg) {
          test = {
            msg: test.msg
          };
        } else if (test === true) {
          test = {};
        }
      }

      // Custom validators should always run, except if value is null and allowNull is false (see #9143)
      if (typeof test === 'function') {
        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));
        return;
      }

      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).
      if (value === null || value === undefined) {
        return;
      }

      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);
      // errors are handled in settling, stub this
      validatorPromise.catch(() => {});
      validators.push(validatorPromise);
    });

    return Promise
      .all(validators.map(validator => validator.catch(rejection => {
        const isBuiltIn = !!rejection.validatorName;
        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
      })));
  }

  /**
   * Prepare and invoke a custom validator.
   *
   * @private
   *
   * @param {Function} validator The custom validator.
   * @param {string} validatorType the custom validator type (name).
   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute
   * @param {*} optValue value for attribute
   * @param {string} optField field for attribute
   *
   * @returns {Promise} A promise.
   */
  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {
    let isAsync = false;

    const validatorArity = validator.length;
    // check if validator is async and requires a callback
    let asyncArity = 1;
    let errorKey = validatorType;
    let invokeArgs;
    if (optAttrDefined) {
      asyncArity = 2;
      invokeArgs = optValue;
      errorKey = optField;
    }
    if (validatorArity === asyncArity) {
      isAsync = true;
    }

    if (isAsync) {
      try {
        if (optAttrDefined) {
          return await promisify(validator.bind(this.modelInstance, invokeArgs))();
        }
        return await promisify(validator.bind(this.modelInstance))();
      } catch (e) {
        return this._pushError(false, errorKey, e, optValue, validatorType);
      }
    }

    try {
      return await validator.call(this.modelInstance, invokeArgs);
    } catch (e) {
      return this._pushError(false, errorKey, e, optValue, validatorType);
    }
  }

  /**
   * Prepare and invoke a build-in validator.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated
   *
   * @returns {object} An object with specific keys to invoke the validator.
   */
  async _invokeBuiltinValidator(value, test, validatorType, field) {
    // Cast value as string to pass new Validator.js string requirement
    const valueString = String(value);
    // check if Validator knows that kind of validation test
    if (typeof validator[validatorType] !== 'function') {
      throw new Error(`Invalid validator function: ${validatorType}`);
    }

    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

    if (!validator[validatorType](valueString, ...validatorArgs)) {
      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });
    }
  }

  /**
   * Will extract arguments for the validator.
   *
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated.
   *
   * @private
   */
  _extractValidatorArgs(test, validatorType, field) {
    let validatorArgs = test.args || test;
    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

    if (!Array.isArray(validatorArgs)) {
      if (validatorType === 'isImmutable') {
        validatorArgs = [validatorArgs, field, this.modelInstance];
      } else if (isLocalizedValidator || validatorType === 'isIP') {
        validatorArgs = [];
      } else {
        validatorArgs = [validatorArgs];
      }
    } else {
      validatorArgs = validatorArgs.slice(0);
    }
    return validatorArgs;
  }

  /**
   * Will validate a single field against its schema definition (isnull).
   *
   * @param {object} rawAttribute As defined in the Schema.
   * @param {string} field The field name.
   * @param {*} value anything.
   *
   * @private
   */
  _validateSchema(rawAttribute, field, value) {
    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);
      if (!association || !this.modelInstance.get(association.associationAccessor)) {
        const validators = this.modelInstance.validators[field];
        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

        this.errors.push(new sequelizeError.ValidationErrorItem(
          errMsg,
          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'is_null'
        ));
      }
    }

    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
        this.errors.push(new sequelizeError.ValidationErrorItem(
          `${field} cannot be an array or an object`,
          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'not_a_string'
        ));
      }
    }
  }

  /**
   * Signs all errors retaining the original.
   *
   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.
   * @param {string}        errorKey    - name of invalid attribute.
   * @param {Error|string}  rawError    - The original error.
   * @param {string|number} value       - The data that triggered the error.
   * @param {string}        fnName      - Name of the validator, if any
   * @param {Array}         fnArgs      - Arguments for the validator [function], if any
   *
   * @private
   */
  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
    const message = rawError.message || rawError || 'Validation error';
    const error = new sequelizeError.ValidationErrorItem(
      message,
      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey,
      value,
      this.modelInstance,
      fnName,
      isBuiltin ? fnName : undefined,
      isBuiltin ? fnArgs : undefined
    );

    error[InstanceValidator.RAW_KEY_NAME] = rawError;

    this.errors.push(error);
  }
}
/**
 * The error key for arguments as passed by custom validators
 *
 * @type {string}
 * @private
 */
InstanceValidator.RAW_KEY_NAME = 'original';

module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator;


/***/ }),

/***/ "./node_modules/sequelize/lib/model-manager.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize/lib/model-manager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Toposort = __webpack_require__(/*! toposort-class */ "./node_modules/toposort-class/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class ModelManager {
  constructor(sequelize) {
    this.models = [];
    this.sequelize = sequelize;
  }

  addModel(model) {
    this.models.push(model);
    this.sequelize.models[model.name] = model;

    return model;
  }

  removeModel(modelToRemove) {
    this.models = this.models.filter(model => model.name !== modelToRemove.name);

    delete this.sequelize.models[modelToRemove.name];
  }

  getModel(against, options) {
    options = _.defaults(options || {}, {
      attribute: 'name'
    });

    return this.models.find(model => model[options.attribute] === against);
  }

  get all() {
    return this.models;
  }

  /**
   * Iterate over Models in an order suitable for e.g. creating tables.
   * Will take foreign key constraints into account so that dependencies are visited before dependents.
   *
   * @param {Function} iterator method to execute on each model
   * @param {object} [options] iterator options
   * @private
   */
  forEachModel(iterator, options) {
    const models = {};
    const sorter = new Toposort();
    let sorted;
    let dep;

    options = _.defaults(options || {}, {
      reverse: true
    });

    for (const model of this.models) {
      let deps = [];
      let tableName = model.getTableName();

      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      models[tableName] = model;

      for (const attrName in model.rawAttributes) {
        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
          const attribute = model.rawAttributes[attrName];

          if (attribute.references) {
            dep = attribute.references.model;

            if (_.isObject(dep)) {
              dep = `${dep.schema}.${dep.tableName}`;
            }

            deps.push(dep);
          }
        }
      }

      deps = deps.filter(dep => tableName !== dep);

      sorter.add(tableName, deps);
    }

    sorted = sorter.sort();
    if (options.reverse) {
      sorted = sorted.reverse();
    }
    for (const name of sorted) {
      iterator(models[name], name);
    }
  }
}

module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports.default = ModelManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/model.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Dottie = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const InstanceValidator = __webpack_require__(/*! ./instance-validator */ "./node_modules/sequelize/lib/instance-validator.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Association = __webpack_require__(/*! ./associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const HasMany = __webpack_require__(/*! ./associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const associationsMixin = __webpack_require__(/*! ./associations/mixin */ "./node_modules/sequelize/lib/associations/mixin.js");
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");


// This list will quickly become dated, but failing to maintain this list just means
// we won't throw a warning when we should. At least most common cases will forever be covered
// so we stop throwing erroneous warnings when we shouldn't.
const validQueryKeywords = new Set(['where', 'attributes', 'paranoid', 'include', 'order', 'limit', 'offset',
  'transaction', 'lock', 'raw', 'logging', 'benchmark', 'having', 'searchPath', 'rejectOnEmpty', 'plain',
  'scope', 'group', 'through', 'defaults', 'distinct', 'primary', 'exception', 'type', 'hooks', 'force',
  'name']);

// List of attributes that should not be implicitly passed into subqueries/includes.
const nonCascadingOptions = ['include', 'attributes', 'originalAttributes', 'order', 'where', 'limit', 'offset', 'plain', 'group', 'having'];

/**
 * A Model represents a table in the database. Instances of this class represent a database row.
 *
 * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.
 * By default, the values from dataValues can also be accessed directly from the Instance, that is:
 * ```js
 * instance.field
 * // is the same as
 * instance.get('field')
 * // is the same as
 * instance.getDataValue('field')
 * ```
 * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.
 * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.
 *
 * @see
   * {@link Sequelize#define} for more information about getters and setters
 * @mixes Hooks
 */
class Model {
  static get queryInterface() {
    return this.sequelize.getQueryInterface();
  }

  static get queryGenerator() {
    return this.queryInterface.queryGenerator;
  }

  /**
   * A reference to the sequelize instance
   *
   * @see
   * {@link Sequelize}
   *
   * @property sequelize
   *
   * @returns {Sequelize}
   */
  get sequelize() {
    return this.constructor.sequelize;
  }

  /**
   * Builds a new model instance.
   *
   * @param {object}  [values={}] an object of key value pairs
   * @param {object}  [options] instance construction options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this a new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   */
  constructor(values = {}, options = {}) {
    options = {
      isNewRecord: true,
      _schema: this.constructor._schema,
      _schemaDelimiter: this.constructor._schemaDelimiter,
      ...options
    };

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    if (!options.includeValidated) {
      this.constructor._conformIncludes(options, this.constructor);
      if (options.include) {
        this.constructor._expandIncludeAll(options);
        this.constructor._validateIncludedElements(options);
      }
    }

    this.dataValues = {};
    this._previousDataValues = {};
    this._changed = new Set();
    this._options = options || {};

    /**
     * Returns true if this instance has not yet been persisted to the database
     *
     * @property isNewRecord
     * @returns {boolean}
     */
    this.isNewRecord = options.isNewRecord;

    this._initValues(values, options);
  }

  _initValues(values, options) {
    let defaults;
    let key;

    values = { ...values };

    if (options.isNewRecord) {
      defaults = {};

      if (this.constructor._hasDefaultValues) {
        defaults = _.mapValues(this.constructor._defaultValues, valueFn => {
          const value = valueFn();
          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);
        });
      }

      // set id to null if not passed as value, a newly created dao has no id
      // removing this breaks bulkCreate
      // do after default values since it might have UUID as a default value
      if (this.constructor.primaryKeyAttributes.length) {
        this.constructor.primaryKeyAttributes.forEach(primaryKeyAttribute => {
          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {
            defaults[primaryKeyAttribute] = null;
          }
        });
      }

      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {
        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.createdAt];
      }

      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {
        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.updatedAt];
      }

      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {
        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.deletedAt];
      }

      for (key in defaults) {
        if (values[key] === undefined) {
          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });
          delete values[key];
        }
      }
    }

    this.set(values, options);
  }

  // validateIncludedElements should have been called before this method
  static _paranoidClause(model, options = {}) {
    // Apply on each include
    // This should be handled before handling where conditions because of logic with returns
    // otherwise this code will never run on includes of a already conditionable where
    if (options.include) {
      for (const include of options.include) {
        this._paranoidClause(include.model, include);
      }
    }

    // apply paranoid when groupedLimit is used
    if (_.get(options, 'groupedLimit.on.options.paranoid')) {
      const throughModel = _.get(options, 'groupedLimit.on.through.model');
      if (throughModel) {
        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);
      }
    }

    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {
      // This model is not paranoid, nothing to do here;
      return options;
    }

    const deletedAtCol = model._timestampAttributes.deletedAt;
    const deletedAtAttribute = model.rawAttributes[deletedAtCol];
    const deletedAtObject = {};

    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    deletedAtDefaultValue = deletedAtDefaultValue || {
      [Op.eq]: null
    };

    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;

    if (Utils.isWhereEmpty(options.where)) {
      options.where = deletedAtObject;
    } else {
      options.where = { [Op.and]: [deletedAtObject, options.where] };
    }

    return options;
  }

  static _addDefaultAttributes() {
    const tail = {};
    let head = {};

    // Add id if no primary key was manually added to definition
    // Can't use this.primaryKeys here, since this function is called before PKs are identified
    if (!_.some(this.rawAttributes, 'primaryKey')) {
      if ('id' in this.rawAttributes) {
        // Something is fishy here!
        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);
      }

      head = {
        id: {
          type: new DataTypes.INTEGER(),
          allowNull: false,
          primaryKey: true,
          autoIncrement: true,
          _autoGenerated: true
        }
      };
    }

    if (this._timestampAttributes.createdAt) {
      tail[this._timestampAttributes.createdAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.updatedAt) {
      tail[this._timestampAttributes.updatedAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.deletedAt) {
      tail[this._timestampAttributes.deletedAt] = {
        type: DataTypes.DATE,
        _autoGenerated: true
      };
    }

    if (this._versionAttribute) {
      tail[this._versionAttribute] = {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 0,
        _autoGenerated: true
      };
    }

    const newRawAttributes = {
      ...head,
      ...this.rawAttributes
    };
    _.each(tail, (value, attr) => {
      if (newRawAttributes[attr] === undefined) {
        newRawAttributes[attr] = value;
      }
    });

    this.rawAttributes = newRawAttributes;

    if (!Object.keys(this.primaryKeys).length) {
      this.primaryKeys.id = this.rawAttributes.id;
    }
  }

  static _findAutoIncrementAttribute() {
    this.autoIncrementAttribute = null;

    for (const name in this.rawAttributes) {
      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {
        const definition = this.rawAttributes[name];
        if (definition && definition.autoIncrement) {
          if (this.autoIncrementAttribute) {
            throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');
          }
          this.autoIncrementAttribute = name;
        }
      }
    }
  }

  static _conformIncludes(options, self) {
    if (!options.include) return;

    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
      options.include = [options.include];
    } else if (!options.include.length) {
      delete options.include;
      return;
    }

    // convert all included elements to { model: Model } form
    options.include = options.include.map(include => this._conformInclude(include, self));
  }

  static _transformStringAssociation(include, self) {
    if (self && typeof include === 'string') {
      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {
        throw new Error(`Association with alias "${include}" does not exist on ${self.name}`);
      }
      return self.associations[include];
    }
    return include;
  }

  static _conformInclude(include, self) {
    if (include) {
      let model;

      if (include._pseudo) return include;

      include = this._transformStringAssociation(include, self);

      if (include instanceof Association) {
        if (self && include.target.name === self.name) {
          model = include.source;
        } else {
          model = include.target;
        }

        return { model, association: include, as: include.as };
      }

      if (include.prototype && include.prototype instanceof Model) {
        return { model: include };
      }

      if (_.isPlainObject(include)) {
        if (include.association) {
          include.association = this._transformStringAssociation(include.association, self);

          if (self && include.association.target.name === self.name) {
            model = include.association.source;
          } else {
            model = include.association.target;
          }

          if (!include.model) include.model = model;
          if (!include.as) include.as = include.association.as;

          this._conformIncludes(include, model);
          return include;
        }

        if (include.model) {
          this._conformIncludes(include, include.model);
          return include;
        }

        if (include.all) {
          this._conformIncludes(include);
          return include;
        }
      }
    }

    throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');
  }

  static _expandIncludeAllElement(includes, include) {
    // check 'all' attribute provided is valid
    let all = include.all;
    delete include.all;

    if (all !== true) {
      if (!Array.isArray(all)) {
        all = [all];
      }

      const validTypes = {
        BelongsTo: true,
        HasOne: true,
        HasMany: true,
        One: ['BelongsTo', 'HasOne'],
        Has: ['HasOne', 'HasMany'],
        Many: ['HasMany']
      };

      for (let i = 0; i < all.length; i++) {
        const type = all[i];
        if (type === 'All') {
          all = true;
          break;
        }

        const types = validTypes[type];
        if (!types) {
          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);
        }

        if (types !== true) {
          // replace type placeholder e.g. 'One' with its constituent types e.g. 'HasOne', 'BelongsTo'
          all.splice(i, 1);
          i--;
          for (let j = 0; j < types.length; j++) {
            if (!all.includes(types[j])) {
              all.unshift(types[j]);
              i++;
            }
          }
        }
      }
    }

    // add all associations of types specified to includes
    const nested = include.nested;
    if (nested) {
      delete include.nested;

      if (!include.include) {
        include.include = [];
      } else if (!Array.isArray(include.include)) {
        include.include = [include.include];
      }
    }

    const used = [];
    (function addAllIncludes(parent, includes) {
      _.forEach(parent.associations, association => {
        if (all !== true && !all.includes(association.associationType)) {
          return;
        }

        // check if model already included, and skip if so
        const model = association.target;
        const as = association.options.as;

        const predicate = { model };
        if (as) {
          // We only add 'as' to the predicate if it actually exists
          predicate.as = as;
        }

        if (_.some(includes, predicate)) {
          return;
        }

        // skip if recursing over a model already nested
        if (nested && used.includes(model)) {
          return;
        }
        used.push(parent);

        // include this model
        const thisInclude = Utils.cloneDeep(include);
        thisInclude.model = model;
        if (as) {
          thisInclude.as = as;
        }
        includes.push(thisInclude);

        // run recursively if nested
        if (nested) {
          addAllIncludes(model, thisInclude.include);
          if (thisInclude.include.length === 0) delete thisInclude.include;
        }
      });
      used.pop();
    })(this, includes);
  }

  static _validateIncludedElements(options, tableNames) {
    if (!options.model) options.model = this;

    tableNames = tableNames || {};
    options.includeNames = [];
    options.includeMap = {};

    /* Legacy */
    options.hasSingleAssociation = false;
    options.hasMultiAssociation = false;

    if (!options.parent) {
      options.topModel = options.model;
      options.topLimit = options.limit;
    }

    options.include = options.include.map(include => {
      include = this._conformInclude(include);
      include.parent = options;
      include.topLimit = options.topLimit;

      this._validateIncludedElement.call(options.model, include, tableNames, options);

      if (include.duplicating === undefined) {
        include.duplicating = include.association.isMultiAssociation;
      }

      include.hasDuplicating = include.hasDuplicating || include.duplicating;
      include.hasRequired = include.hasRequired || include.required;

      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;
      options.hasRequired = options.hasRequired || include.required;

      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;
      return include;
    });

    for (const include of options.include) {
      include.hasParentWhere = options.hasParentWhere || !!options.where;
      include.hasParentRequired = options.hasParentRequired || !!options.required;

      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {
        if (include.duplicating) {
          include.subQuery = false;
          include.subQueryFilter = include.hasRequired;
        } else {
          include.subQuery = include.hasRequired;
          include.subQueryFilter = false;
        }
      } else {
        include.subQuery = include.subQuery || false;
        if (include.duplicating) {
          include.subQueryFilter = include.subQuery;
          include.subQuery = false;
        } else {
          include.subQueryFilter = false;
          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;
        }
      }

      options.includeMap[include.as] = include;
      options.includeNames.push(include.as);

      // Set top level options
      if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {
        if (include.subQuery) {
          options.subQuery = include.subQuery;
        } else if (include.hasDuplicating) {
          options.subQuery = true;
        }
      }

      /* Legacy */
      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;
      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;

      if (include.association.isMultiAssociation || include.hasMultiAssociation) {
        options.hasMultiAssociation = true;
      }
      if (include.association.isSingleAssociation || include.hasSingleAssociation) {
        options.hasSingleAssociation = true;
      }
    }

    if (options.topModel === options.model && options.subQuery === undefined) {
      options.subQuery = false;
    }
    return options;
  }

  static _validateIncludedElement(include, tableNames, options) {
    tableNames[include.model.getTableName()] = true;

    if (include.attributes && !options.raw) {
      include.model._expandAttributes(include);

      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);

      include = Utils.mapFinderOptions(include, include.model);

      if (include.attributes.length) {
        _.each(include.model.primaryKeys, (attr, key) => {
          // Include the primary key if it's not already included - take into account that the pk might be aliased (due to a .field prop)
          if (!include.attributes.some(includeAttr => {
            if (attr.field !== key) {
              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;
            }
            return includeAttr === key;
          })) {
            include.attributes.unshift(key);
          }
        });
      }
    } else {
      include = Utils.mapFinderOptions(include, include.model);
    }

    // pseudo include just needed the attribute logic, return
    if (include._pseudo) {
      if (!include.attributes) {
        include.attributes = Object.keys(include.model.tableAttributes);
      }
      return Utils.mapFinderOptions(include, include.model);
    }

    // check if the current Model is actually associated with the passed Model - or it's a pseudo include
    const association = include.association || this._getIncludedAssociation(include.model, include.as);

    include.association = association;
    include.as = association.as;

    // If through, we create a pseudo child include, to ease our parsing later on
    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {
      if (!include.include) include.include = [];
      const through = include.association.through;

      include.through = _.defaults(include.through || {}, {
        model: through.model,
        as: through.model.name,
        association: {
          isSingleAssociation: true
        },
        _pseudo: true,
        parent: include
      });


      if (through.scope) {
        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;
      }

      include.include.push(include.through);
      tableNames[through.tableName] = true;
    }

    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source
    let model;
    if (include.model.scoped === true) {
      // If the passed model is already scoped, keep that
      model = include.model;
    } else {
      // Otherwise use the model that was originally passed to the association
      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;
    }

    model._injectScope(include);

    // This check should happen after injecting the scope, since the scope may contain a .attributes
    if (!include.attributes) {
      include.attributes = Object.keys(include.model.tableAttributes);
    }

    include = Utils.mapFinderOptions(include, include.model);

    if (include.required === undefined) {
      include.required = !!include.where;
    }

    if (include.association.scope) {
      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;
    }

    if (include.limit && include.separate === undefined) {
      include.separate = true;
    }

    if (include.separate === true) {
      if (!(include.association instanceof HasMany)) {
        throw new Error('Only HasMany associations support include.separate');
      }

      include.duplicating = false;

      if (
        options.attributes
        && options.attributes.length
        && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)
      ) {
        options.attributes.push(association.sourceKey);
      }

      if (
        include.attributes
        && include.attributes.length
        && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)
      ) {
        include.attributes.push(association.foreignKey);
      }
    }

    // Validate child includes
    if (Object.prototype.hasOwnProperty.call(include, 'include')) {
      this._validateIncludedElements.call(include.model, include, tableNames);
    }

    return include;
  }

  static _getIncludedAssociation(targetModel, targetAlias) {
    const associations = this.getAssociations(targetModel);
    let association = null;
    if (associations.length === 0) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);
    }
    if (associations.length === 1) {
      association = this.getAssociationForAlias(targetModel, targetAlias);
      if (association) {
        return association;
      }
      if (targetAlias) {
        const existingAliases = this.getAssociations(targetModel).map(association => association.as);
        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
          `You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(', ')}).`);
      }
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
        'You must use the \'as\' keyword to specify the alias within your include statement.');
    }
    association = this.getAssociationForAlias(targetModel, targetAlias);
    if (!association) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. ` +
        'To identify the correct association, you must use the \'as\' keyword to specify the alias of the association you want to include.');
    }
    return association;
  }


  static _expandIncludeAll(options) {
    const includes = options.include;
    if (!includes) {
      return;
    }

    for (let index = 0; index < includes.length; index++) {
      const include = includes[index];

      if (include.all) {
        includes.splice(index, 1);
        index--;

        this._expandIncludeAllElement(includes, include);
      }
    }

    includes.forEach(include => {
      this._expandIncludeAll.call(include.model, include);
    });
  }

  static _conformIndex(index) {
    if (!index.fields) {
      throw new Error('Missing "fields" property for index definition');
    }

    index = _.defaults(index, {
      type: '',
      parser: null
    });

    if (index.type && index.type.toLowerCase() === 'unique') {
      index.unique = true;
      delete index.type;
    }

    return index;
  }


  static _uniqIncludes(options) {
    if (!options.include) return;

    options.include = _(options.include)
      .groupBy(include => `${include.model && include.model.name}-${include.as}`)
      .map(includes => this._assignOptions(...includes))
      .value();
  }

  static _baseMerge(...args) {
    _.assignWith(...args);
    this._conformIncludes(args[0], this);
    this._uniqIncludes(args[0]);
    return args[0];
  }

  static _mergeFunction(objValue, srcValue, key) {
    if (Array.isArray(objValue) && Array.isArray(srcValue)) {
      return _.union(objValue, srcValue);
    }
    if (key === 'where' || key === 'having') {
      if (srcValue instanceof Utils.SequelizeMethod) {
        srcValue = { [Op.and]: srcValue };
      }
      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
        return Object.assign(objValue, srcValue);
      }
    } else if (key === 'attributes' && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
      return _.assignWith(objValue, srcValue, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
          return _.union(objValue, srcValue);
        }
      });
    }
    // If we have a possible object/array to clone, we try it.
    // Otherwise, we return the original value when it's not undefined,
    // or the resulting object in that case.
    if (srcValue) {
      return Utils.cloneDeep(srcValue, true);
    }
    return srcValue === undefined ? objValue : srcValue;
  }

  static _assignOptions(...args) {
    return this._baseMerge(...args, this._mergeFunction);
  }

  static _defaultsOptions(target, opts) {
    return this._baseMerge(target, opts, (srcValue, objValue, key) => {
      return this._mergeFunction(objValue, srcValue, key);
    });
  }

  /**
   * Initialize a model, representing a table in the DB, with attributes and options.
   *
   * The table columns are defined by the hash that is given as the first argument.
   * Each attribute of the hash represents a column.
   *
   * @example
   * Project.init({
   *   columnA: {
   *     type: Sequelize.BOOLEAN,
   *     validate: {
   *       is: ['[a-z]','i'],        // will only allow letters
   *       max: 23,                  // only allow values <= 23
   *       isIn: {
   *         args: [['en', 'zh']],
   *         msg: "Must be English or Chinese"
   *       }
   *     },
   *     field: 'column_a'
   *     // Other attributes here
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * }, {sequelize})
   *
   * sequelize.models.modelName // The model will now be available in models under the class name
   *
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @see
   * <a href="/master/manual/model-basics.html">Hooks</a> guide
   *
   * @see
   * <a href="/master/manual/validations-and-constraints.html"/>Validations & Constraints</a> guide
   *
   * @param {object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:
   * @param {string|DataTypes|object} attributes.column The description of a database column
   * @param {string|DataTypes}        attributes.column.type A string or a data type
   * @param {boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.
   * @param {any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)
   * @param {string|boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index
   * @param {boolean}                 [attributes.column.primaryKey=false] If true, this attribute will be marked as primary key
   * @param {string}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database
   * @param {boolean}                 [attributes.column.autoIncrement=false] If true, this column will be set to auto increment
   * @param {boolean}                 [attributes.column.autoIncrementIdentity=false] If true, combined with autoIncrement=true, will use Postgres `GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL`. Postgres 10+ only.
   * @param {string}                  [attributes.column.comment=null] Comment for this column
   * @param {string|Model}            [attributes.column.references=null] An object with reference configurations
   * @param {string|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string
   * @param {string}                  [attributes.column.references.key='id'] The column of the foreign table that this column references
   * @param {string}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {string}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.
   * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.
   * @param {object}                  [attributes.column.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field and the instance itself as the `this` binding, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation; if it is async, the callback should be called with the error text.
   * @param {object}                  options These options are merged with the default define options provided to the Sequelize constructor
   * @param {object}                  options.sequelize Define the sequelize instance to attach to the new Model. Throw error if none is provided.
   * @param {string}                  [options.modelName] Set name of the model. By default its same as Class name.
   * @param {object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll
   * @param {object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them
   * @param {boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved
   * @param {boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.
   * @param {boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work
   * @param {boolean}                 [options.underscored=false] Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set `field` option
   * @param {boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized
   * @param {object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.
   * @param {string}                  [options.name.singular=Utils.singularize(modelName)] Singular name for model
   * @param {string}                  [options.name.plural=Utils.pluralize(modelName)] Plural name for model
   * @param {Array<object>}           [options.indexes] indexes definitions
   * @param {string}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated
   * @param {string}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`
   * @param {string}                  [options.indexes[].using] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.
   * @param {string}                  [options.indexes[].operator] Specify index operator.
   * @param {boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`
   * @param {boolean}                 [options.indexes[].concurrently=false] PostgresSQL will build the index without taking any write locks. Postgres only
   * @param {Array<string|object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)
   * @param {string|boolean}          [options.createdAt] Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.updatedAt] Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.deletedAt] Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim
   * @param {string}                  [options.schema='public'] schema
   * @param {string}                  [options.engine] Specify engine for model's table
   * @param {string}                  [options.charset] Specify charset for model's table
   * @param {string}                  [options.comment] Specify comment for model's table
   * @param {string}                  [options.collate] Specify collation for model's table
   * @param {string}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.
   * @param {object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, beforeSave, afterDestroy, afterUpdate, afterBulkCreate, afterSave, afterBulkDestroy and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.
   * @param {object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.
   *
   * @returns {Model}
   */
  static init(attributes, options = {}) {
    if (!options.sequelize) {
      throw new Error('No Sequelize instance passed');
    }

    this.sequelize = options.sequelize;

    const globalOptions = this.sequelize.options;

    options = Utils.merge(_.cloneDeep(globalOptions.define), options);

    if (!options.modelName) {
      options.modelName = this.name;
    }

    options = Utils.merge({
      name: {
        plural: Utils.pluralize(options.modelName),
        singular: Utils.singularize(options.modelName)
      },
      indexes: [],
      omitNull: globalOptions.omitNull,
      schema: globalOptions.schema
    }, options);

    this.sequelize.runHooks('beforeDefine', attributes, options);

    if (options.modelName !== this.name) {
      Object.defineProperty(this, 'name', { value: options.modelName });
    }
    delete options.modelName;

    this.options = {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      ...options
    };

    // if you call "define" multiple times for the same modelName, do not clutter the factory
    if (this.sequelize.isDefined(this.name)) {
      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));
    }

    this.associations = {};
    this._setupHooks(options.hooks);

    this.underscored = this.options.underscored;

    if (!this.options.tableName) {
      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);
    } else {
      this.tableName = this.options.tableName;
    }

    this._schema = this.options.schema;
    this._schemaDelimiter = this.options.schemaDelimiter;

    // error check options
    _.each(options.validate, (validator, validatorType) => {
      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {
        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);
      }

      if (typeof validator !== 'function') {
        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);
      }
    });

    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {
      attribute = this.sequelize.normalizeAttribute(attribute);

      if (attribute.type === undefined) {
        throw new Error(`Unrecognized datatype for attribute "${this.name}.${name}"`);
      }

      if (attribute.allowNull !== false && _.get(attribute, 'validate.notNull')) {
        throw new Error(`Invalid definition for "${this.name}.${name}", "notNull" validator is only allowed with "allowNull:false"`);
      }

      if (_.get(attribute, 'references.model.prototype') instanceof Model) {
        attribute.references.model = attribute.references.model.getTableName();
      }

      return attribute;
    });

    const tableName = this.getTableName();
    this._indexes = this.options.indexes
      .map(index => Utils.nameIndex(this._conformIndex(index), tableName));

    this.primaryKeys = {};
    this._readOnlyAttributes = new Set();
    this._timestampAttributes = {};

    // setup names of timestamp attributes
    if (this.options.timestamps) {
      for (const key of ['createdAt', 'updatedAt', 'deletedAt']) {
        if (!['undefined', 'string', 'boolean'].includes(typeof this.options[key])) {
          throw new Error(`Value for "${key}" option must be a string or a boolean, got ${typeof this.options[key]}`);
        }
        if (this.options[key] === '') {
          throw new Error(`Value for "${key}" option cannot be an empty string`);
        }
      }

      if (this.options.createdAt !== false) {
        this._timestampAttributes.createdAt =
          typeof this.options.createdAt === 'string' ? this.options.createdAt : 'createdAt';
        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);
      }
      if (this.options.updatedAt !== false) {
        this._timestampAttributes.updatedAt =
          typeof this.options.updatedAt === 'string' ? this.options.updatedAt : 'updatedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);
      }
      if (this.options.paranoid && this.options.deletedAt !== false) {
        this._timestampAttributes.deletedAt =
          typeof this.options.deletedAt === 'string' ? this.options.deletedAt : 'deletedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);
      }
    }

    // setup name for version attribute
    if (this.options.version) {
      this._versionAttribute = typeof this.options.version === 'string' ? this.options.version : 'version';
      this._readOnlyAttributes.add(this._versionAttribute);
    }

    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;

    // Add head and tail default attributes (id, timestamps)
    this._addDefaultAttributes();
    this.refreshAttributes();
    this._findAutoIncrementAttribute();

    this._scope = this.options.defaultScope;
    this._scopeNames = ['defaultScope'];

    this.sequelize.modelManager.addModel(this);
    this.sequelize.runHooks('afterDefine', this);

    return this;
  }

  static refreshAttributes() {
    const attributeManipulation = {};

    this.prototype._customGetters = {};
    this.prototype._customSetters = {};

    ['get', 'set'].forEach(type => {
      const opt = `${type}terMethods`;
      const funcs = { ...this.options[opt] };
      const _custom = type === 'get' ? this.prototype._customGetters : this.prototype._customSetters;

      _.each(funcs, (method, attribute) => {
        _custom[attribute] = method;

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(this.rawAttributes, (options, attribute) => {
        if (Object.prototype.hasOwnProperty.call(options, type)) {
          _custom[attribute] = options[type];
        }

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(funcs, (fct, name) => {
        if (!attributeManipulation[name]) {
          attributeManipulation[name] = {
            configurable: true
          };
        }
        attributeManipulation[name][type] = fct;
      });
    });

    this._dataTypeChanges = {};
    this._dataTypeSanitizers = {};

    this._hasBooleanAttributes = false;
    this._hasDateAttributes = false;
    this._jsonAttributes = new Set();
    this._virtualAttributes = new Set();
    this._defaultValues = {};
    this.prototype.validators = {};

    this.fieldRawAttributesMap = {};

    this.primaryKeys = {};
    this.uniqueKeys = {};

    _.each(this.rawAttributes, (definition, name) => {
      definition.type = this.sequelize.normalizeDataType(definition.type);

      definition.Model = this;
      definition.fieldName = name;
      definition._modelAttribute = true;

      if (definition.field === undefined) {
        definition.field = Utils.underscoredIf(name, this.underscored);
      }

      if (definition.primaryKey === true) {
        this.primaryKeys[name] = definition;
      }

      this.fieldRawAttributesMap[definition.field] = definition;

      if (definition.type._sanitize) {
        this._dataTypeSanitizers[name] = definition.type._sanitize;
      }

      if (definition.type._isChanged) {
        this._dataTypeChanges[name] = definition.type._isChanged;
      }

      if (definition.type instanceof DataTypes.BOOLEAN) {
        this._hasBooleanAttributes = true;
      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {
        this._hasDateAttributes = true;
      } else if (definition.type instanceof DataTypes.JSON) {
        this._jsonAttributes.add(name);
      } else if (definition.type instanceof DataTypes.VIRTUAL) {
        this._virtualAttributes.add(name);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'defaultValue')) {
        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'unique') && definition.unique) {
        let idxName;
        if (
          typeof definition.unique === 'object' &&
          Object.prototype.hasOwnProperty.call(definition.unique, 'name')
        ) {
          idxName = definition.unique.name;
        } else if (typeof definition.unique === 'string') {
          idxName = definition.unique;
        } else {
          idxName = `${this.tableName}_${name}_unique`;
        }

        const idx = this.uniqueKeys[idxName] || { fields: [] };

        idx.fields.push(definition.field);
        idx.msg = idx.msg || definition.unique.msg || null;
        idx.name = idxName || false;
        idx.column = name;
        idx.customIndex = definition.unique !== true;

        this.uniqueKeys[idxName] = idx;
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'validate')) {
        this.prototype.validators[name] = definition.validate;
      }

      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {
        this._indexes.push(
          Utils.nameIndex(
            this._conformIndex({
              fields: [definition.field || name],
              using: 'gin'
            }),
            this.getTableName()
          )
        );

        delete definition.index;
      }
    });

    // Create a map of field to attribute names
    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {
      if (key !== value.fieldName) {
        map[key] = value.fieldName;
      }
      return map;
    }, {});

    this._hasJsonAttributes = !!this._jsonAttributes.size;

    this._hasVirtualAttributes = !!this._virtualAttributes.size;

    this._hasDefaultValues = !_.isEmpty(this._defaultValues);

    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));

    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;
    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;

    for (const key of Object.keys(attributeManipulation)) {
      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {
        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);
        continue;
      }
      Object.defineProperty(this.prototype, key, attributeManipulation[key]);
    }

    this.prototype.rawAttributes = this.rawAttributes;
    this.prototype._isAttribute = key => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);

    // Primary key convenience constiables
    this.primaryKeyAttributes = Object.keys(this.primaryKeys);
    this.primaryKeyAttribute = this.primaryKeyAttributes[0];
    if (this.primaryKeyAttribute) {
      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
    }

    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;
    this._isPrimaryKey = key => this.primaryKeyAttributes.includes(key);
  }

  /**
   * Remove attribute from model definition
   *
   * @param {string} attribute name of attribute to remove
   */
  static removeAttribute(attribute) {
    delete this.rawAttributes[attribute];
    this.refreshAttributes();
  }

  /**
   * Sync this Model to the DB, that is create the table.
   *
   * @param {object} [options] sync options
   *
   * @see
   * {@link Sequelize#sync} for options
   *
   * @returns {Promise<Model>}
   */
  static async sync(options) {
    options = { ...this.options, ...options };
    options.hooks = options.hooks === undefined ? true : !!options.hooks;

    const attributes = this.tableAttributes;
    const rawAttributes = this.fieldRawAttributesMap;

    if (options.hooks) {
      await this.runHooks('beforeSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }

    const tableName = this.getTableName(options);

    await this.queryInterface.createTable(tableName, attributes, options, this);

    if (options.alter) {
      const tableInfos = await Promise.all([
        this.queryInterface.describeTable(tableName, options),
        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)
      ]);
      const columns = tableInfos[0];
      // Use for alter foreign keys
      const foreignKeyReferences = tableInfos[1];
      const removedConstraints = {};

      for (const columnName in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, columnName)) continue;
        if (!columns[columnName] && !columns[attributes[columnName].field]) {
          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);
        }
      }

      if (options.alter === true || typeof options.alter === 'object' && options.alter.drop !== false) {
        for (const columnName in columns) {
          if (!Object.prototype.hasOwnProperty.call(columns, columnName)) continue;
          const currentAttribute = rawAttributes[columnName];
          if (!currentAttribute) {
            await this.queryInterface.removeColumn(tableName, columnName, options);
            continue;
          }
          if (currentAttribute.primaryKey) continue;
          // Check foreign keys. If it's a foreign key, it should remove constraint first.
          const references = currentAttribute.references;
          if (currentAttribute.references) {
            const database = this.sequelize.config.database;
            const schema = this.sequelize.config.schema;
            // Find existed foreign keys
            for (const foreignKeyReference of foreignKeyReferences) {
              const constraintName = foreignKeyReference.constraintName;
              if (!!constraintName
                && foreignKeyReference.tableCatalog === database
                && (schema ? foreignKeyReference.tableSchema === schema : true)
                && foreignKeyReference.referencedTableName === references.model
                && foreignKeyReference.referencedColumnName === references.key
                && (schema ? foreignKeyReference.referencedTableSchema === schema : true)
                && !removedConstraints[constraintName]) {
                // Remove constraint on foreign keys.
                await this.queryInterface.removeConstraint(tableName, constraintName, options);
                removedConstraints[constraintName] = true;
              }
            }
          }
          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);
        }
      }
    }
    let indexes = await this.queryInterface.showIndex(tableName, options);
    indexes = this._indexes.filter(item1 =>
      !indexes.some(item2 => item1.name === item2.name)
    ).sort((index1, index2) => {
      if (this.sequelize.options.dialect === 'postgres') {
      // move concurrent indexes to the bottom to avoid weird deadlocks
        if (index1.concurrently === true) return 1;
        if (index2.concurrently === true) return -1;
      }

      return 0;
    });

    for (const index of indexes) {
      await this.queryInterface.addIndex(tableName, { ...options, ...index });
    }

    if (options.hooks) {
      await this.runHooks('afterSync', options);
    }

    return this;
  }

  /**
   * Drop the table represented by this Model
   *
   * @param {object}   [options] drop options
   * @param {boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres
   * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise}
   */
  static async drop(options) {
    return await this.queryInterface.dropTable(this.getTableName(options), options);
  }

  static async dropSchema(schema) {
    return await this.queryInterface.dropSchema(schema);
  }

  /**
   * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `"schema"."tableName"`,
   * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.
   *
   * This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important
   * to call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.
   *
   * If a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call
   * for the model.
   *
   * @param {string}   schema The name of the schema
   * @param {object}   [options] schema options
   * @param {string}   [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @see
   * {@link Sequelize#define} for more information about setting a default schema.
   *
   * @returns {Model}
   */
  static schema(schema, options) {

    const clone = class extends this {};
    Object.defineProperty(clone, 'name', { value: this.name });

    clone._schema = schema;

    if (options) {
      if (typeof options === 'string') {
        clone._schemaDelimiter = options;
      } else if (options.schemaDelimiter) {
        clone._schemaDelimiter = options.schemaDelimiter;
      }
    }

    return clone;
  }

  /**
   * Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema,
   * or an object with `tableName`, `schema` and `delimiter` properties.
   *
   * @returns {string|object}
   */
  static getTableName() {
    return this.queryGenerator.addSchema(this);
  }

  /**
   * Get un-scoped model
   *
   * @returns {Model}
   */
  static unscoped() {
    return this.scope();
  }

  /**
   * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.
   *
   * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.
   *
   * @param {string}          name The name of the scope. Use `defaultScope` to override the default scope
   * @param {object|Function} scope scope or options
   * @param {object}          [options] scope options
   * @param {boolean}         [options.override=false] override old scope if already defined
   */
  static addScope(name, scope, options) {
    options = { override: false, ...options };

    if ((name === 'defaultScope' && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {
      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);
    }

    if (name === 'defaultScope') {
      this.options.defaultScope = this._scope = scope;
    } else {
      this.options.scopes[name] = scope;
    }
  }

  /**
   * Apply a scope created in `define` to the model.
   *
   * @example <caption>how to create scopes</caption>
   * const Model = sequelize.define('model', attributes, {
   *   defaultScope: {
   *     where: {
   *       username: 'dan'
   *     },
   *     limit: 12
   *   },
   *   scopes: {
   *     isALie: {
   *       where: {
   *         stuff: 'cake'
   *       }
   *     },
   *     complexFunction: function(email, accessLevel) {
   *       return {
   *         where: {
   *           email: {
   *             [Op.like]: email
   *           },
   *           access_level {
   *             [Op.gte]: accessLevel
   *           }
   *         }
   *       }
   *     }
   *   }
   * })
   *
   * # As you have defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:
   *
   * Model.findAll() // WHERE username = 'dan'
   * Model.findAll({ where: { age: { [Op.gt]: 12 } } }) // WHERE age > 12 AND username = 'dan'
   *
   * @example <caption>To invoke scope functions you can do</caption>
   * Model.scope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()
   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42
   *
   * @param {?Array|object|string} [option] The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.
   *
   * @returns {Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.
   */
  static scope(option) {
    const self = class extends this {};
    let scope;
    let scopeName;

    Object.defineProperty(self, 'name', { value: this.name });

    self._scope = {};
    self._scopeNames = [];
    self.scoped = true;

    if (!option) {
      return self;
    }

    const options = _.flatten(arguments);

    for (const option of options) {
      scope = null;
      scopeName = null;

      if (_.isPlainObject(option)) {
        if (option.method) {
          if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {
            scopeName = option.method[0];
            scope = self.options.scopes[scopeName].apply(self, option.method.slice(1));
          }
          else if (self.options.scopes[option.method]) {
            scopeName = option.method;
            scope = self.options.scopes[scopeName].apply(self);
          }
        } else {
          scope = option;
        }
      } else if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {
        scope = self.options.defaultScope;
      } else {
        scopeName = option;
        scope = self.options.scopes[scopeName];
        if (typeof scope === 'function') {
          scope = scope();
        }
      }

      if (scope) {
        this._conformIncludes(scope, this);
        // clone scope so it doesn't get modified
        this._assignOptions(self._scope, Utils.cloneDeep(scope));
        self._scopeNames.push(scopeName ? scopeName : 'defaultScope');
      } else {
        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);
      }
    }

    return self;
  }

  /**
   * Search for multiple instances.
   *
   * @example <caption>Simple search using AND and =</caption>
   * Model.findAll({
   *   where: {
   *     attr1: 42,
   *     attr2: 'cake'
   *   }
   * })
   *
   * # WHERE attr1 = 42 AND attr2 = 'cake'
   *
   * @example <caption>Using greater than, less than etc.</caption>
   * const {gt, lte, ne, in: opIn} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     attr1: {
   *       [gt]: 50
   *     },
   *     attr2: {
   *       [lte]: 45
   *     },
   *     attr3: {
   *       [opIn]: [1,2,3]
   *     },
   *     attr4: {
   *       [ne]: 5
   *     }
   *   }
   * })
   *
   * # WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5
   *
   * @example <caption>Queries using OR</caption>
   * const {or, and, gt, lt} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     name: 'a project',
   *     [or]: [
   *       {id: [1, 2, 3]},
   *       {
   *         [and]: [
   *           {id: {[gt]: 10}},
   *           {id: {[lt]: 100}}
   *         ]
   *       }
   *     ]
   *   }
   * });
   *
   * # WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));
   *
   * @see
   * {@link Operators} for possible operators
   * __Alias__: _all_
   *
   * The promise is resolved with an array of Model instances if the query succeeds._
   *
   * @param  {object}                                                    [options] A hash of options to describe the scope of the search
   * @param  {object}                                                    [options.where] A hash of attributes to describe your search. See above for examples.
   * @param  {Array<string>|object}                                      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance
   * @param  {Array<string>}                                             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`
   * @param  {Array<string>}                                             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`
   * @param  {boolean}                                                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.
   * @param  {Array<object|Model|string>}                                [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).
   * @param  {Model}                                                     [options.include[].model] The model you want to eagerly load
   * @param  {string}                                                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural
   * @param  {Association}                                               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)
   * @param  {object}                                                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`
   * @param  {boolean}                                                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.
   * @param  {object}                                                    [options.include[].on] Supply your own ON condition for the join.
   * @param  {Array<string>}                                             [options.include[].attributes] A list of attributes to select from the child model
   * @param  {boolean}                                                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.
   * @param  {boolean}                                                   [options.include[].right] If true, converts to a right join if dialect support it. Ignored if `include.required` is true.
   * @param  {boolean}                                                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations
   * @param  {number}                                                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true
   * @param  {string}                                                    [options.include[].through.as] The alias for the join model, in case you want to give it a different name than the default one.
   * @param  {object}                                                    [options.include[].through.where] Filter on the join model for belongsToMany relations
   * @param  {Array}                                                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations
   * @param  {Array<object|Model|string>}                                [options.include[].include] Load further nested related models
   * @param  {boolean}                                                   [options.include[].duplicating] Mark the include as duplicating, will prevent a subquery from being used.
   * @param  {Array|Sequelize.fn|Sequelize.col|Sequelize.literal}        [options.order] Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.
   * @param  {number}                                                    [options.limit] Limit for result
   * @param  {number}                                                    [options.offset] Offset for result
   * @param  {Transaction}                                               [options.transaction] Transaction to run query under
   * @param  {string|object}                                             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.
   * @param  {boolean}                                                   [options.skipLocked] Skip locked rows. Only supported in Postgres.
   * @param  {boolean}                                                   [options.raw] Return raw result. See sequelize.query for more information.
   * @param  {Function}                                                  [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param  {boolean}                                                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {object}                                                    [options.having] Having options
   * @param  {string}                                                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Error}                                             [options.rejectOnEmpty=false] Throws an error when no records found
   *
   * @see
   * {@link Sequelize#query}
   *
   * @returns {Promise<Array<Model>>}
   */
  static async findAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new sequelizeErrors.QueryError('The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    if (options !== undefined && options.attributes) {
      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {
        throw new sequelizeErrors.QueryError('The attributes option must be an array of column names or an object');
      }
    }

    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));

    const tableNames = {};

    tableNames[this.getTableName(options)] = true;
    options = Utils.cloneDeep(options);

    _.defaults(options, { hooks: true });

    // set rejectOnEmpty option, defaults to model options
    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, 'rejectOnEmpty')
      ? options.rejectOnEmpty
      : this.options.rejectOnEmpty;

    this._injectScope(options);

    if (options.hooks) {
      await this.runHooks('beforeFind', options);
    }
    this._conformIncludes(options, this);
    this._expandAttributes(options);
    this._expandIncludeAll(options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterExpandIncludeAll', options);
    }
    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);

    if (options.include) {
      options.hasJoin = true;

      this._validateIncludedElements(options, tableNames);

      // If we're not raw, we have to make sure we include the primary key for de-duplication
      if (
        options.attributes
        && !options.raw
        && this.primaryKeyAttribute
        && !options.attributes.includes(this.primaryKeyAttribute)
        && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)
      ) {
        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);
      }
    }

    if (!options.attributes) {
      options.attributes = Object.keys(this.rawAttributes);
      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
    }

    // whereCollection is used for non-primary key updates
    this.options.whereCollection = options.where || null;

    Utils.mapFinderOptions(options, this);

    options = this._paranoidClause(this, options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterOptions', options);
    }
    const selectOptions = { ...options, tableNames: Object.keys(tableNames) };
    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);
    if (options.hooks) {
      await this.runHooks('afterFind', results, options);
    }

    //rejectOnEmpty mode
    if (_.isEmpty(results) && options.rejectOnEmpty) {
      if (typeof options.rejectOnEmpty === 'function') {
        throw new options.rejectOnEmpty();
      }
      if (typeof options.rejectOnEmpty === 'object') {
        throw options.rejectOnEmpty;
      }
      throw new sequelizeErrors.EmptyResultError();
    }

    return await Model._findSeparate(results, options);
  }

  static warnOnInvalidOptions(options, validColumnNames) {
    if (!_.isPlainObject(options)) {
      return;
    }

    const unrecognizedOptions = Object.keys(options).filter(k => !validQueryKeywords.has(k));
    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);
    if (!options.where && unexpectedModelAttributes.length > 0) {
      logger.warn(`Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);
    }
  }

  static _injectDependentVirtualAttributes(attributes) {
    if (!this._hasVirtualAttributes) return attributes;
    if (!attributes || !Array.isArray(attributes)) return attributes;

    for (const attribute of attributes) {
      if (
        this._virtualAttributes.has(attribute)
        && this.rawAttributes[attribute].type.fields
      ) {
        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);
      }
    }

    attributes = _.uniq(attributes);

    return attributes;
  }

  static async _findSeparate(results, options) {
    if (!options.include || options.raw || !results) return results;

    const original = results;
    if (options.plain) results = [results];

    if (!results.length) return original;

    await Promise.all(options.include.map(async include => {
      if (!include.separate) {
        return await Model._findSeparate(
          results.reduce((memo, result) => {
            let associations = result.get(include.association.as);

            // Might be an empty belongsTo relation
            if (!associations) return memo;

            // Force array so we can concat no matter if it's 1:1 or :M
            if (!Array.isArray(associations)) associations = [associations];

            for (let i = 0, len = associations.length; i !== len; ++i) {
              memo.push(associations[i]);
            }
            return memo;
          }, []),
          {

            ..._.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'offset', 'plain', 'scope'),
            include: include.include || []
          }
        );
      }

      const map = await include.association.get(results, {

        ..._.omit(options, nonCascadingOptions),
        ..._.omit(include, ['parent', 'association', 'as', 'originalAttributes'])
      });

      for (const result of results) {
        result.set(
          include.association.as,
          map[result.get(include.association.sourceKey)],
          { raw: true }
        );
      }
    }));

    return original;
  }

  /**
   * Search for a single instance by its primary key._
   *
   * @param  {number|string|Buffer}      param The value of the desired instance's primary key.
   * @param  {object}                    [options] find options
   * @param  {Transaction}               [options.transaction] Transaction to run query under
   * @param  {string}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll}           for a full explanation of options, Note that options.where is not supported.
   *
   * @returns {Promise<Model>}
   */
  static async findByPk(param, options) {
    // return Promise resolved with null if no arguments are passed
    if ([null, undefined].includes(param)) {
      return null;
    }

    options = Utils.cloneDeep(options) || {};

    if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {
      options.where = {
        [this.primaryKeyAttribute]: param
      };
    } else {
      throw new Error(`Argument passed to findByPk is invalid: ${param}`);
    }

    // Bypass a possible overloaded findOne
    return await this.findOne(options);
  }

  /**
   * Search for a single instance. Returns the first instance found, or null if none can be found.
   *
   * @param  {object}       [options] A hash of options to describe the scope of the search
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {string}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll} for an explanation of options
   *
   * @returns {Promise<Model|null>}
   */
  static async findOne(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value');
    }
    options = Utils.cloneDeep(options);

    if (options.limit === undefined) {
      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter(c => c.fields.length === 1).map('column').value();

      // Don't add limit if querying directly on the pk or a unique column
      if (!options.where || !_.some(options.where, (value, key) =>
        (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) &&
          (Utils.isPrimitive(value) || Buffer.isBuffer(value))
      )) {
        options.limit = 1;
      }
    }

    // Bypass a possible overloaded findAll.
    return await this.findAll(_.defaults(options, {
      plain: true
    }));
  }

  /**
   * Run an aggregation method on the specified field
   *
   * @param {string}          attribute The attribute to aggregate over. Can be a field name or *
   * @param {string}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.
   * @param {object}          [options] Query options. See sequelize.query for full options
   * @param {object}          [options.where] A hash of search attributes.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {DataTypes|string} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.
   * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over
   * @param {Transaction}     [options.transaction] Transaction to run query under
   * @param {boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`
   *
   * @returns {Promise<DataTypes|object>} Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.
   */
  static async aggregate(attribute, aggregateFunction, options) {
    options = Utils.cloneDeep(options);

    // We need to preserve attributes here as the `injectScope` call would inject non aggregate columns.
    const prevAttributes = options.attributes;
    this._injectScope(options);
    options.attributes = prevAttributes;
    this._conformIncludes(options, this);

    if (options.include) {
      this._expandIncludeAll(options);
      this._validateIncludedElements(options);
    }

    const attrOptions = this.rawAttributes[attribute];
    const field = attrOptions && attrOptions.field || attribute;
    let aggregateColumn = this.sequelize.col(field);

    if (options.distinct) {
      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);
    }

    let { group } = options;
    if (Array.isArray(group) && Array.isArray(group[0])) {
      noDoubleNestedGroup();
      group = _.flatten(group);
    }
    options.attributes = _.unionBy(
      options.attributes,
      group,
      [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]],
      a => Array.isArray(a) ? a[1] : a
    );

    if (!options.dataType) {
      if (attrOptions) {
        options.dataType = attrOptions.type;
      } else {
        // Use FLOAT as fallback
        options.dataType = new DataTypes.FLOAT();
      }
    } else {
      options.dataType = this.sequelize.normalizeDataType(options.dataType);
    }

    Utils.mapOptionFieldNames(options, this);
    options = this._paranoidClause(this, options);

    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);
    if (value === null) {
      return 0;
    }
    return value;
  }

  /**
   * Count the number of records matching the provided where clause.
   *
   * If you provide an `include` option, the number of matching associations will be counted instead.
   *
   * @param {object}        [options] options
   * @param {object}        [options.where] A hash of search attributes.
   * @param {object}        [options.include] Include options. See `find` for details
   * @param {boolean}       [options.paranoid=true] Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled
   * @param {boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key or on options.col.
   * @param {string}        [options.col] Column on which COUNT() should be applied
   * @param {Array}         [options.attributes] Used in conjunction with `group`
   * @param {Array}         [options.group] For creating complex counts. Will return multiple rows as needed.
   * @param {Transaction}   [options.transaction] Transaction to run query under
   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<number>}
   */
  static async count(options) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { hooks: true });
    options.raw = true;
    if (options.hooks) {
      await this.runHooks('beforeCount', options);
    }
    let col = options.col || '*';
    if (options.include) {
      col = `${this.name}.${options.col || this.primaryKeyField}`;
    }
    if (options.distinct && col === '*') {
      col = this.primaryKeyField;
    }
    options.plain = !options.group;
    options.dataType = new DataTypes.INTEGER();
    options.includeIgnoreAttributes = false;

    // No limit, offset or order for the options max be given to count()
    // Set them to null to prevent scopes setting those values
    options.limit = null;
    options.offset = null;
    options.order = null;

    return await this.aggregate(col, 'count', options);
  }

  /**
   * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging
   *
   * @example
   * const result = await Model.findAndCountAll({
   *   where: ...,
   *   limit: 12,
   *   offset: 12
   * });
   *
   * # In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.
   *
   * # When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.
   *
   * # Suppose you want to find all users who have a profile attached:
   *
   * User.findAndCountAll({
   *   include: [
   *      { model: Profile, required: true}
   *   ],
   *   limit: 3
   * });
   *
   * # Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted
   *
   * @param {object} [options] See findAll options
   *
   * @see
   * {@link Model.findAll} for a specification of find and query options
   * @see
   * {@link Model.count} for a specification of count options
   *
   * @returns {Promise<{count: number, rows: Model[]}>}
   */
  static async findAndCountAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    const countOptions = Utils.cloneDeep(options);

    if (countOptions.attributes) {
      countOptions.attributes = undefined;
    }

    const [count, rows] = await Promise.all([
      this.count(countOptions),
      this.findAll(options)
    ]);

    return {
      count,
      rows: count === 0 ? [] : rows
    };
  }

  /**
   * Find the maximum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async max(field, options) {
    return await this.aggregate(field, 'max', options);
  }

  /**
   * Find the minimum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async min(field, options) {
    return await this.aggregate(field, 'min', options);
  }

  /**
   * Find the sum of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<number>}
   */
  static async sum(field, options) {
    return await this.aggregate(field, 'sum', options);
  }

  /**
   * Builds a new model instance.
   *
   * @param {object|Array} values An object of key value pairs or an array of such. If an array, the function will return an array of instances.
   * @param {object}  [options] Instance build options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   *
   * @returns {Model|Array<Model>}
   */
  static build(values, options) {
    if (Array.isArray(values)) {
      return this.bulkBuild(values, options);
    }

    return new this(values, options);
  }

  static bulkBuild(valueSets, options) {
    options = { isNewRecord: true, ...options };

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    return valueSets.map(values => this.build(values, options));
  }

  /**
   * Builds a new model instance and calls save on it.
   *
   * @see
   * {@link Model.build}
   * @see
   * {@link Model.save}
   *
   * @param  {object}         values                       Hash of data values to create new record with
   * @param  {object}         [options]                    Build and query options
   * @param  {boolean}        [options.raw=false]          If set to true, values will ignore field and virtual setters.
   * @param  {boolean}        [options.isNewRecord=true]   Is this new record
   * @param  {Array}          [options.include]            An array of include options - Used to build prefetched/included model instances. See `set`
   * @param  {string[]}       [options.fields]             An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param  {boolean}        [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {boolean}        [options.validate=true]      If false, validations won't be run.
   * @param  {boolean}        [options.hooks=true]         Run before and after create / update + validate hooks
   * @param  {Function}       [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]    Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]        Transaction to run query under
   * @param  {string}         [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Array}  [options.returning=true]     Appends RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   *
   * @returns {Promise<Model>}
   *
   */
  static async create(values, options) {
    options = Utils.cloneDeep(options || {});

    return await this.build(values, {
      isNewRecord: true,
      attributes: options.fields,
      include: options.include,
      raw: options.raw,
      silent: options.silent
    }).save(options);
  }

  /**
   * Find a row that matches the query, or build (but don't save) the row if none is found.
   * The successful result of the promise will be (instance, built)
   *
   * @param {object}   options find options
   * @param {object}   options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}   [options.defaults] Default values to use if building a new instance
   * @param {object}   [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrBuild(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrBuild. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    let values;

    let instance = await this.findOne(options);
    if (instance === null) {
      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      instance = this.build(values, options);

      return [instance, true];
    }

    return [instance, false];
  }

  /**
   * Find a row that matches the query, or build and save the row if none is found
   * The successful result of the promise will be (instance, created)
   *
   * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.
   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.
   * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object}      options find and create options
   * @param {object}      options.where where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}      [options.defaults] Default values to use if creating a new instance
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrCreate(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrCreate. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    options = { ...options };

    if (options.defaults) {
      const defaults = Object.keys(options.defaults);
      const unknownDefaults = defaults.filter(name => !this.rawAttributes[name]);

      if (unknownDefaults.length) {
        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);
      }
    }

    if (options.transaction === undefined && this.sequelize.constructor._cls) {
      const t = this.sequelize.constructor._cls.get('transaction');
      if (t) {
        options.transaction = t;
      }
    }

    const internalTransaction = !options.transaction;
    let values;
    let transaction;

    try {
      const t = await this.sequelize.transaction(options);
      transaction = t;
      options.transaction = t;

      const found = await this.findOne(Utils.defaults({ transaction }, options));
      if (found !== null) {
        return [found, false];
      }

      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      options.exception = true;
      options.returning = true;

      try {
        const created = await this.create(values, options);
        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {
          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation
          throw new sequelizeErrors.UniqueConstraintError();
        }

        return [created, true];
      } catch (err) {
        if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
        const flattenedWhere = Utils.flattenObjectDeep(options.where);
        const flattenedWhereKeys = Object.keys(flattenedWhere).map(name => _.last(name.split('.')));
        const whereFields = flattenedWhereKeys.map(name => _.get(this.rawAttributes, `${name}.field`, name));
        const defaultFields = options.defaults && Object.keys(options.defaults)
          .filter(name => this.rawAttributes[name])
          .map(name => this.rawAttributes[name].field || name);

        const errFieldKeys = Object.keys(err.fields);
        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);
        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {
          throw err;
        }

        if (errFieldsWhereIntersects) {
          _.each(err.fields, (value, key) => {
            const name = this.fieldRawAttributesMap[key].fieldName;
            if (value.toString() !== options.where[name].toString()) {
              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);
            }
          });
        }

        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!
        const otherCreated = await this.findOne(Utils.defaults({
          transaction: internalTransaction ? null : transaction
        }, options));

        // Sanity check, ideally we caught this at the defaultFeilds/err.fields check
        // But if we didn't and instance is null, we will throw
        if (otherCreated === null) throw err;

        return [otherCreated, false];
      }
    } finally {
      if (internalTransaction && transaction) {
        await transaction.commit();
      }
    }
  }

  /**
   * A more performant findOrCreate that will not work under a transaction (at least not in postgres)
   * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object} options find options
   * @param {object} options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object} [options.defaults] Default values to use if creating a new instance
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findCreateFind(options) {
    if (!options || !options.where) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findCreateFind.'
      );
    }

    let values = { ...options.defaults };
    if (_.isPlainObject(options.where)) {
      values = Utils.defaults(values, options.where);
    }


    const found = await this.findOne(options);
    if (found) return [found, false];

    try {
      const created = await this.create(values, options);
      return [created, true];
    } catch (err) {
      if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
      const foundAgain = await this.findOne(options);
      return [foundAgain, false];
    }
  }

  /**
   * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.
   *
   * **Implementation details:**
   *
   * * MySQL - Implemented with ON DUPLICATE KEY UPDATE`
   * * PostgreSQL - Implemented with ON CONFLICT DO UPDATE. If update data contains PK field, then PK is selected as the default conflict key. Otherwise first unique constraint/index will be selected, which can satisfy conflict key requirements.
   * * SQLite - Implemented with ON CONFLICT DO UPDATE
   * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`
   *
   * **Note** that Postgres/SQLite returns null for created, no matter if the row was created or updated
   *
   * @param  {object}       values                                        hash of values to upsert
   * @param  {object}       [options]                                     upsert options
   * @param  {boolean}      [options.validate=true]                       Run validations before the row is inserted
   * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all changed fields
   * @param  {boolean}      [options.hooks=true]                          Run before / after upsert hooks?
   * @param  {boolean}      [options.returning=true]                      If true, fetches back auto generated values
   * @param  {Transaction}  [options.transaction]                         Transaction to run query under
   * @param  {Function}     [options.logging=false]                       A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]                     Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {string}       [options.searchPath=DEFAULT]                  An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<[Model, boolean | null]>} returns an array with two elements, the first being the new record and the second being `true` if it was just created or `false` if it already existed (except on Postgres and SQLite, which can't detect this and will always return `null` instead of a boolean).
   */
  static async upsert(values, options) {
    options = {
      hooks: true,
      returning: true,
      validate: true,
      ...Utils.cloneDeep(options)
    };

    const createdAtAttr = this._timestampAttributes.createdAt;
    const updatedAtAttr = this._timestampAttributes.updatedAt;
    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;
    const instance = this.build(values);

    options.model = this;
    options.instance = instance;

    const changed = Array.from(instance._changed);
    if (!options.fields) {
      options.fields = changed;
    }

    if (options.validate) {
      await instance.validate(options);
    }
    // Map field names
    const updatedDataValues = _.pick(instance.dataValues, changed);
    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);
    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);
    const now = Utils.now(this.sequelize.options.dialect);

    // Attach createdAt
    if (createdAtAttr && !updateValues[createdAtAttr]) {
      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;
      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;
    }
    if (updatedAtAttr && !insertValues[updatedAtAttr]) {
      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;
    }

    // Build adds a null value for the primary key, if none was given by the user.
    // We need to remove that because of some Postgres technicalities.
    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {
      delete insertValues[this.primaryKeyField];
      delete updateValues[this.primaryKeyField];
    }

    if (options.hooks) {
      await this.runHooks('beforeUpsert', values, options);
    }
    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);

    const [record] = result;
    record.isNewRecord = false;

    if (options.hooks) {
      await this.runHooks('afterUpsert', result, options);
      return result;
    }
    return result;
  }

  /**
   * Create and insert multiple instances in bulk.
   *
   * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL
   * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.
   * To obtain Instances for the newly created values, you will need to query for them again.
   *
   * If validation fails, the promise is rejected with an array-like AggregateError
   *
   * @param  {Array}          records                          List of objects (key/value pairs) to create instances from
   * @param  {object}         [options]                        Bulk create options
   * @param  {Array}          [options.fields]                 Fields to insert (defaults to all fields)
   * @param  {boolean}        [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]             Run before / after bulk create hooks?
   * @param  {boolean}        [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.
   * @param  {boolean}        [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres < 9.5)
   * @param  {Array}          [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite >= 3.24.0 & Postgres >= 9.5). By default, all fields are updated.
   * @param  {Transaction}    [options.transaction]            Transaction to run query under
   * @param  {Function}       [options.logging=false]          A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]        Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {boolean|Array}  [options.returning=false]        If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {string}         [options.searchPath=DEFAULT]     An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Array<Model>>}
   */
  static async bulkCreate(records, options = {}) {
    if (!records.length) {
      return [];
    }

    const dialect = this.sequelize.options.dialect;
    const now = Utils.now(this.sequelize.options.dialect);

    options.model = this;

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    const instances = records.map(values => this.build(values, { isNewRecord: true, include: options.include }));

    const recursiveBulkCreate = async (instances, options) => {
      options = {
        validate: false,
        hooks: true,
        individualHooks: false,
        ignoreDuplicates: false,
        ...options
      };

      if (options.returning === undefined) {
        if (options.association) {
          options.returning = false;
        } else {
          options.returning = true;
        }
      }

      if (options.ignoreDuplicates && ['mssql'].includes(dialect)) {
        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);
      }
      if (options.updateOnDuplicate && (dialect !== 'mysql' && dialect !== 'mariadb' && dialect !== 'sqlite' && dialect !== 'postgres')) {
        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);
      }

      const model = options.model;

      options.fields = options.fields || Object.keys(model.rawAttributes);
      const createdAtAttr = model._timestampAttributes.createdAt;
      const updatedAtAttr = model._timestampAttributes.updatedAt;

      if (options.updateOnDuplicate !== undefined) {
        if (Array.isArray(options.updateOnDuplicate) && options.updateOnDuplicate.length) {
          options.updateOnDuplicate = _.intersection(
            _.without(Object.keys(model.tableAttributes), createdAtAttr),
            options.updateOnDuplicate
          );
        } else {
          throw new Error('updateOnDuplicate option only supports non-empty array.');
        }
      }

      // Run before hook
      if (options.hooks) {
        await model.runHooks('beforeBulkCreate', instances, options);
      }
      // Validate
      if (options.validate) {
        const errors = [];
        const validateOptions = { ...options };
        validateOptions.hooks = options.individualHooks;

        await Promise.all(instances.map(async instance => {
          try {
            await instance.validate(validateOptions);
          } catch (err) {
            errors.push(new sequelizeErrors.BulkRecordError(err, instance));
          }
        }));

        delete options.skip;
        if (errors.length) {
          throw new sequelizeErrors.AggregateError(errors);
        }
      }
      if (options.individualHooks) {
        await Promise.all(instances.map(async instance => {
          const individualOptions = {
            ...options,
            validate: false,
            hooks: true
          };
          delete individualOptions.fields;
          delete individualOptions.individualHooks;
          delete individualOptions.ignoreDuplicates;

          await instance.save(individualOptions);
        }));
      } else {
        if (options.include && options.include.length) {
          await Promise.all(options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
            const associationInstances = [];
            const associationInstanceIndexToInstanceMap = [];

            for (const instance of instances) {
              const associationInstance = instance.get(include.as);
              if (associationInstance) {
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }

            if (!associationInstances.length) {
              return;
            }

            const includeOptions = _(Utils.cloneDeep(include))
              .omit(['association'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();

            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              await include.association.set(instance, associationInstance, { save: false, logging: options.logging });
            }
          }));
        }

        // Create all in one query
        // Recreate records from instances to represent any changes made in hooks or validation
        records = instances.map(instance => {
          const values = instance.dataValues;

          // set createdAt/updatedAt attributes
          if (createdAtAttr && !values[createdAtAttr]) {
            values[createdAtAttr] = now;
            if (!options.fields.includes(createdAtAttr)) {
              options.fields.push(createdAtAttr);
            }
          }
          if (updatedAtAttr && !values[updatedAtAttr]) {
            values[updatedAtAttr] = now;
            if (!options.fields.includes(updatedAtAttr)) {
              options.fields.push(updatedAtAttr);
            }
          }

          const out = Utils.mapValueFieldNames(values, options.fields, model);
          for (const key of model._virtualAttributes) {
            delete out[key];
          }
          return out;
        });

        // Map attributes to fields for serial identification
        const fieldMappedAttributes = {};
        for (const attr in model.tableAttributes) {
          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];
        }

        // Map updateOnDuplicate attributes to fields
        if (options.updateOnDuplicate) {
          options.updateOnDuplicate = options.updateOnDuplicate.map(attr => model.rawAttributes[attr].field || attr);
          // Get primary keys for postgres to enable updateOnDuplicate
          options.upsertKeys = _.chain(model.primaryKeys).values().map('field').value();
          if (Object.keys(model.uniqueKeys).length > 0) {
            options.upsertKeys = _.chain(model.uniqueKeys).values().filter(c => c.fields.length >= 1).map(c => c.fields).reduce(c => c[0]).value();
          }
        }

        // Map returning attributes to fields
        if (options.returning && Array.isArray(options.returning)) {
          options.returning = options.returning.map(attr => _.get(model.rawAttributes[attr], 'field', attr));
        }

        const results = await model.queryInterface.bulkInsert(model.getTableName(options), records, options, fieldMappedAttributes);
        if (Array.isArray(results)) {
          results.forEach((result, i) => {
            const instance = instances[i];

            for (const key in result) {
              if (!instance || key === model.primaryKeyAttribute &&
                instance.get(model.primaryKeyAttribute) &&
                ['mysql', 'mariadb', 'sqlite'].includes(dialect)) {
                // The query.js for these DBs is blind, it autoincrements the
                // primarykey value, even if it was set manually. Also, it can
                // return more results than instances, bug?.
                continue;
              }
              if (Object.prototype.hasOwnProperty.call(result, key)) {
                const record = result[key];

                const attr = _.find(model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

                instance.dataValues[attr && attr.fieldName || key] = record;
              }
            }
          });
        }
      }

      if (options.include && options.include.length) {
        await Promise.all(options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          const associationInstances = [];
          const associationInstanceIndexToInstanceMap = [];

          for (const instance of instances) {
            let associated = instance.get(include.as);
            if (!Array.isArray(associated)) associated = [associated];

            for (const associationInstance of associated) {
              if (associationInstance) {
                if (!(include.association instanceof BelongsToMany)) {
                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
                  Object.assign(associationInstance, include.association.scope);
                }
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }
          }

          if (!associationInstances.length) {
            return;
          }

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging
            }).value();

          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
          if (include.association instanceof BelongsToMany) {
            const valueSets = [];

            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              const values = {
                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };
              if (associationInstance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof associationInstance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values[attr] = associationInstance[include.association.through.model.name][attr];
                }
              }

              valueSets.push(values);
            }

            const throughOptions = _(Utils.cloneDeep(include))
              .omit(['association', 'attributes'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();
            throughOptions.model = include.association.throughModel;
            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);

            await recursiveBulkCreate(throughInstances, throughOptions);
          }
        }));
      }

      // map fields back to attributes
      instances.forEach(instance => {
        for (const attr in model.rawAttributes) {
          if (model.rawAttributes[attr].field &&
              instance.dataValues[model.rawAttributes[attr].field] !== undefined &&
              model.rawAttributes[attr].field !== attr
          ) {
            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];
            delete instance.dataValues[model.rawAttributes[attr].field];
          }
          instance._previousDataValues[attr] = instance.dataValues[attr];
          instance.changed(attr, false);
        }
        instance.isNewRecord = false;
      });

      // Run after hook
      if (options.hooks) {
        await model.runHooks('afterBulkCreate', instances, options);
      }

      return instances;
    };

    return await recursiveBulkCreate(instances, options);
  }

  /**
   * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).
   *
   * @param {object}           [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.cascade = false] Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean}          [options.restartIdentity=false] Automatically restart sequences owned by columns of the truncated table.
   * @param {Transaction}      [options.transaction] Transaction to run query under
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @param {boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   *
   * @see
   * {@link Model.destroy} for more information
   */
  static async truncate(options) {
    options = Utils.cloneDeep(options) || {};
    options.truncate = true;
    return await this.destroy(options);
  }

  /**
   * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.
   *
   * @param  {object}       options                         destroy options
   * @param  {object}       [options.where]                 Filter the destroy
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row
   * @param  {number}       [options.limit]                 How many rows to delete
   * @param  {boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)
   * @param  {boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored
   * @param  {boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param  {boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise<number>} The number of destroyed rows
   */
  static async destroy(options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);

    if (!options || !(options.where || options.truncate)) {
      throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');
    }

    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {
      throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');
    }

    options = _.defaults(options, {
      hooks: true,
      individualHooks: false,
      force: false,
      cascade: false,
      restartIdentity: false
    });

    options.type = QueryTypes.BULKDELETE;

    Utils.mapOptionFieldNames(options, this);
    options.model = this;


    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkDestroy', options);
    }
    let instances;
    // Get daos and run beforeDestroy hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });

      await Promise.all(instances.map(instance => this.runHooks('beforeDestroy', instance, options)));
    }
    let result;
    // Run delete query (or update if paranoid)
    if (this._timestampAttributes.deletedAt && !options.force) {
      // Set query type appropriately when running soft delete
      options.type = QueryTypes.BULKUPDATE;

      const attrValueHash = {};
      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];
      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;
      const where = {
        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null
      };


      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);
      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);
    } else {
      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);
    }
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterDestroy', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkDestroy', options);
    }
    return result;
  }

  /**
   * Restore multiple instances if `paranoid` is enabled.
   *
   * @param  {object}       options                         restore options
   * @param  {object}       [options.where]                 Filter the restore
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk restore hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row
   * @param  {number}       [options.limit]                 How many rows to undelete (only for mysql)
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}  [options.transaction]           Transaction to run query under
   *
   * @returns {Promise}
   */
  static async restore(options) {
    if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      individualHooks: false,
      ...options
    };

    options.type = QueryTypes.RAW;
    options.model = this;

    Utils.mapOptionFieldNames(options, this);

    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkRestore', options);
    }

    let instances;
    // Get daos and run beforeRestore hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });

      await Promise.all(instances.map(instance => this.runHooks('beforeRestore', instance, options)));
    }
    // Run undelete query
    const attrValueHash = {};
    const deletedAtCol = this._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
    options.omitNull = false;
    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterRestore', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkRestore', options);
    }
    return result;
  }

  /**
   * Update multiple instances that match the where options.
   *
   * @param  {object}         values                          hash of values to update
   * @param  {object}         options                         update options
   * @param  {object}         options.where                   Options to describe the scope of the search.
   * @param  {boolean}        [options.paranoid=true]         If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if `options.paranoid` is true for the model.
   * @param  {Array}          [options.fields]                Fields to update (defaults to all fields)
   * @param  {boolean}        [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]            Run before / after bulk update hooks?
   * @param  {boolean}        [options.sideEffects=true]      Whether or not to update the side effects of any virtual setters.
   * @param  {boolean}        [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks
   * @param  {boolean|Array}  [options.returning=false]       If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {number}         [options.limit]                 How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)
   * @param  {Function}       [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]           Transaction to run query under
   * @param  {boolean}        [options.silent=false]          If true, the updatedAt timestamp will not be updated.
   *
   * @returns {Promise<Array<number,number>>}  The promise returns an array with one or two elements. The first element is always the number
   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true).
   *
   */
  static async update(values, options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = this._paranoidClause(this, _.defaults(options, {
      validate: true,
      hooks: true,
      individualHooks: false,
      returning: false,
      force: false,
      sideEffects: true
    }));

    options.type = QueryTypes.BULKUPDATE;

    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    // Remove values that are not in the options.fields
    if (options.fields && options.fields instanceof Array) {
      for (const key of Object.keys(values)) {
        if (!options.fields.includes(key)) {
          delete values[key];
        }
      }
    } else {
      const updatedAtAttr = this._timestampAttributes.updatedAt;
      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));
      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {
        options.fields.push(updatedAtAttr);
      }
    }

    if (this._timestampAttributes.updatedAt && !options.silent) {
      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);
    }

    options.model = this;

    let valuesUse;
    // Validate
    if (options.validate) {
      const build = this.build(values);
      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });

      if (options.sideEffects) {
        Object.assign(values, _.pick(build.get(), build.changed()));
        options.fields = _.union(options.fields, Object.keys(values));
      }

      // We want to skip validations for all other fields
      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));
      const attributes = await build.validate(options);
      options.skip = undefined;
      if (attributes && attributes.dataValues) {
        values = _.pick(attributes.dataValues, Object.keys(values));
      }
    }
    // Run before hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('beforeBulkUpdate', options);
      values = options.attributes;
      delete options.attributes;
    }

    valuesUse = values;

    // Get instances and run beforeUpdate hook on each record individually
    let instances;
    let updateDoneRowByRow = false;
    if (options.individualHooks) {
      instances = await this.findAll({
        where: options.where,
        transaction: options.transaction,
        logging: options.logging,
        benchmark: options.benchmark,
        paranoid: options.paranoid
      });

      if (instances.length) {
        // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly
        // i.e. whether they change values for each record in the same way
        let changedValues;
        let different = false;

        instances = await Promise.all(instances.map(async instance => {
          // Record updates in instances dataValues
          Object.assign(instance.dataValues, values);
          // Set the changed fields on the instance
          _.forIn(valuesUse, (newValue, attr) => {
            if (newValue !== instance._previousDataValues[attr]) {
              instance.setDataValue(attr, newValue);
            }
          });

          // Run beforeUpdate hook
          await this.runHooks('beforeUpdate', instance, options);
          if (!different) {
            const thisChangedValues = {};
            _.forIn(instance.dataValues, (newValue, attr) => {
              if (newValue !== instance._previousDataValues[attr]) {
                thisChangedValues[attr] = newValue;
              }
            });

            if (!changedValues) {
              changedValues = thisChangedValues;
            } else {
              different = !_.isEqual(changedValues, thisChangedValues);
            }
          }

          return instance;
        }));

        if (!different) {
          const keys = Object.keys(changedValues);
          // Hooks do not change values or change them uniformly
          if (keys.length) {
            // Hooks change values - record changes in valuesUse so they are executed
            valuesUse = changedValues;
            options.fields = _.union(options.fields, keys);
          }
        } else {
          instances = await Promise.all(instances.map(async instance => {
            const individualOptions = {
              ...options,
              hooks: false,
              validate: false
            };
            delete individualOptions.individualHooks;

            return instance.save(individualOptions);
          }));
          updateDoneRowByRow = true;
        }
      }
    }
    let result;
    if (updateDoneRowByRow) {
      result = [instances.length, instances];
    } else if (_.isEmpty(valuesUse)
       || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {
      // only updatedAt is being passed, then skip update
      result = [0];
    } else {
      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);
      options = Utils.mapOptionFieldNames(options, this);
      options.hasTrigger = this.options ? this.options.hasTrigger : false;

      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);
      if (options.returning) {
        result = [affectedRows.length, affectedRows];
        instances = affectedRows;
      } else {
        result = [affectedRows];
      }
    }

    if (options.individualHooks) {
      await Promise.all(instances.map(instance => this.runHooks('afterUpdate', instance, options)));
      result[1] = instances;
    }
    // Run after hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('afterBulkUpdate', options);
      delete options.attributes;
    }
    return result;
  }

  /**
   * Run a describe query on the table.
   *
   * @param {string} [schema] schema name to search table in
   * @param {object} [options] query options
   *
   * @returns {Promise} hash of attributes and their types
   */
  static async describe(schema, options) {
    return await this.queryInterface.describeTable(this.tableName, { schema: schema || this._schema || undefined, ...options });
  }

  static _getDefaultTimestamp(attr) {
    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {
      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);
    }
    return undefined;
  }

  static _expandAttributes(options) {
    if (!_.isPlainObject(options.attributes)) {
      return;
    }
    let attributes = Object.keys(this.rawAttributes);

    if (options.attributes.exclude) {
      attributes = attributes.filter(elem => !options.attributes.exclude.includes(elem));
    }

    if (options.attributes.include) {
      attributes = attributes.concat(options.attributes.include);
    }

    options.attributes = attributes;
  }

  // Inject _scope into options.
  static _injectScope(options) {
    const scope = Utils.cloneDeep(this._scope);
    this._defaultsOptions(options, scope);
  }

  static [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.name;
  }

  static hasAlias(alias) {
    return Object.prototype.hasOwnProperty.call(this.associations, alias);
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ``` SET column = column + X WHERE foo = 'bar' ``` query. To get the correct value after an increment into the Instance you should do a reload.
   *
   * @example <caption>increment number by 1</caption>
   * Model.increment('number', { where: { foo: 'bar' });
   *
   * @example <caption>increment number and count by 2</caption>
   * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>increment answer by 42, and decrement tries by 1</caption>
   * // `by` is ignored, as each column has its own value
   * Model.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @see
   * {@link Model#reload}
   *
   * @param  {string|Array|object}  fields                       If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param  {object}               options                      increment options
   * @param  {object}               options.where                conditions hash
   * @param  {number}               [options.by=1]               The number to increment by
   * @param  {boolean}              [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {Function}             [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {Transaction}          [options.transaction]        Transaction to run query under
   * @param  {string}               [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async increment(fields, options) {
    options = options || {};
    if (typeof fields === 'string') fields = [fields];
    if (Array.isArray(fields)) {
      fields = fields.map(f => {
        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {
          return this.rawAttributes[f].field;
        }
        return f;
      });
    }

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = Utils.defaults({}, options, {
      by: 1,
      where: {},
      increment: true
    });
    const isSubtraction = !options.increment;

    Utils.mapOptionFieldNames(options, this);

    const where = { ...options.where };

    // A plain object whose keys are the fields to be incremented and whose values are
    // the amounts to be incremented by.
    let incrementAmountsByField = {};
    if (Array.isArray(fields)) {
      incrementAmountsByField = {};
      for (const field of fields) {
        incrementAmountsByField[field] = options.by;
      }
    } else {
      // If the `fields` argument is not an array, then we assume it already has the
      // form necessary to be placed directly in the `incrementAmountsByField` variable.
      incrementAmountsByField = fields;
    }

    // If optimistic locking is enabled, we can take advantage that this is an
    // increment/decrement operation and send it here as well. We put `-1` for
    // decrementing because it will be subtracted, getting `-(-1)` which is `+1`
    if (this._versionAttribute) {
      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;
    }

    const extraAttributesToBeUpdated = {};

    const updatedAtAttr = this._timestampAttributes.updatedAt;
    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {
      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);
    }

    const tableName = this.getTableName(options);
    let affectedRows;
    if (isSubtraction) {
      affectedRows = await this.queryInterface.decrement(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    } else {
      affectedRows = await this.queryInterface.increment(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    }

    if (options.returning) {
      return [affectedRows, affectedRows.length];
    }

    return [affectedRows];
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance you should do a reload.
   *
   * @example <caption>decrement number by 1</caption>
   * Model.decrement('number', { where: { foo: 'bar' });
   *
   * @example <caption>decrement number and count by 2</caption>
   * Model.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>decrement answer by 42, and decrement tries by -1</caption>
   * // `by` is ignored, since each column has its own value
   * Model.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} options decrement options, similar to increment
   *
   * @see
   * {@link Model.increment}
   * @see
   * {@link Model#reload}
   * @since 4.36.0
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  static _optionsMustContainWhere(options) {
    assert(options && options.where, 'Missing where attribute in the options parameter');
    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod,
      'Expected plain object, array or sequelize method in the options.where parameter');
  }

  /**
   * Get an object representing the query for this instance, use with `options.where`
   *
   * @param {boolean} [checkVersion=false] include version attribute in where hash
   *
   * @returns {object}
   */
  where(checkVersion) {
    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {
      result[attribute] = this.get(attribute, { raw: true });
      return result;
    }, {});

    if (_.size(where) === 0) {
      return this.constructor.options.whereCollection;
    }
    const versionAttr = this.constructor._versionAttribute;
    if (checkVersion && versionAttr) {
      where[versionAttr] = this.get(versionAttr, { raw: true });
    }
    return Utils.mapWhereFieldNames(where, this.constructor);
  }

  toString() {
    return `[object SequelizeInstance:${this.constructor.name}]`;
  }

  /**
   * Get the value of the underlying data value
   *
   * @param {string} key key to look in instance data store
   *
   * @returns {any}
   */
  getDataValue(key) {
    return this.dataValues[key];
  }

  /**
   * Update the underlying data value
   *
   * @param {string} key key to set in instance data store
   * @param {any} value new value for given key
   *
   */
  setDataValue(key, value) {
    const originalValue = this._previousDataValues[key];

    if (!_.isEqual(value, originalValue)) {
      this.changed(key, true);
    }

    this.dataValues[key] = value;
  }

  /**
   * If no key is given, returns all values of the instance, also invoking virtual getters.
   *
   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.
   *
   * @param {string}  [key] key to get value of
   * @param {object}  [options] get options
   * @param {boolean} [options.plain=false] If set to true, included instances will be returned as plain objects
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   *
   * @returns {object|any}
   */
  get(key, options) {
    if (options === undefined && typeof key === 'object') {
      options = key;
      key = undefined;
    }

    options = options || {};

    if (key) {
      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {
        return this._customGetters[key].call(this, key, options);
      }

      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {
        if (Array.isArray(this.dataValues[key])) {
          return this.dataValues[key].map(instance => instance.get(options));
        }
        if (this.dataValues[key] instanceof Model) {
          return this.dataValues[key].get(options);
        }
        return this.dataValues[key];
      }

      return this.dataValues[key];
    }

    if (
      this._hasCustomGetters
      || options.plain && this._options.include
      || options.clone
    ) {
      const values = {};
      let _key;

      if (this._hasCustomGetters) {
        for (_key in this._customGetters) {
          if (
            this._options.attributes
            && !this._options.attributes.includes(_key)
          ) {
            continue;
          }

          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {
            values[_key] = this.get(_key, options);
          }
        }
      }

      for (_key in this.dataValues) {
        if (
          !Object.prototype.hasOwnProperty.call(values, _key)
          && Object.prototype.hasOwnProperty.call(this.dataValues, _key)
        ) {
          values[_key] = this.get(_key, options);
        }
      }

      return values;
    }

    return this.dataValues;
  }

  /**
   * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).
   * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function
   * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.
   *
   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be
   * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.
   *
   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).
   *
   * Set can also be used to build instances for associations, if you have values for those.
   * When using set with associations you need to make sure the property key matches the alias of the association
   * while also making sure that the proper include options have been set (from .build() or .findOne())
   *
   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.
   *
   * @see
   * {@link Model.findAll} for more information about includes
   *
   * @param {string|object} key key to set, it can be string or object. When string it will set that key, for object it will loop over all object properties nd set them.
   * @param {any} value value to set
   * @param {object} [options] set options
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   * @param {boolean} [options.reset=false] Clear all previously set data values
   *
   * @returns {Model}
   */
  set(key, value, options) {
    let values;
    let originalValue;

    if (typeof key === 'object' && key !== null) {
      values = key;
      options = value || {};

      if (options.reset) {
        this.dataValues = {};
        for (const key in values) {
          this.changed(key, false);
        }
      }

      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object
      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {
        if (Object.keys(this.dataValues).length) {
          Object.assign(this.dataValues, values);
        } else {
          this.dataValues = values;
        }
        // If raw, .changed() shouldn't be true
        this._previousDataValues = { ...this.dataValues };
      } else {
        // Loop and call set
        if (options.attributes) {
          const setKeys = data => {
            for (const k of data) {
              if (values[k] === undefined) {
                continue;
              }
              this.set(k, values[k], options);
            }
          };
          setKeys(options.attributes);
          if (this.constructor._hasVirtualAttributes) {
            setKeys(this.constructor._virtualAttributes);
          }
          if (this._options.includeNames) {
            setKeys(this._options.includeNames);
          }
        } else {
          for (const key in values) {
            this.set(key, values[key], options);
          }
        }

        if (options.raw) {
          // If raw, .changed() shouldn't be true
          this._previousDataValues = { ...this.dataValues };
        }
      }
      return this;
    }
    if (!options)
      options = {};
    if (!options.raw) {
      originalValue = this.dataValues[key];
    }

    // If not raw, and there's a custom setter
    if (!options.raw && this._customSetters[key]) {
      this._customSetters[key].call(this, value, key);
      // custom setter should have changed value, get that changed value
      // TODO: v5 make setters return new value instead of changing internal store
      const newValue = this.dataValues[key];
      if (!_.isEqual(newValue, originalValue)) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }
    } else {
      // Check if we have included models, and if this key matches the include model names/aliases
      if (this._options && this._options.include && this._options.includeNames.includes(key)) {
        // Pass it on to the include handler
        this._setInclude(key, value, options);
        return this;
      }
      // Bunch of stuff we won't do when it's raw
      if (!options.raw) {
        // If attribute is not in model definition, return
        if (!this._isAttribute(key)) {
          if (key.includes('.') && this.constructor._jsonAttributes.has(key.split('.')[0])) {
            const previousNestedValue = Dottie.get(this.dataValues, key);
            if (!_.isEqual(previousNestedValue, value)) {
              Dottie.set(this.dataValues, key, value);
              this.changed(key.split('.')[0], true);
            }
          }
          return this;
        }

        // If attempting to set primary key and primary key is already defined, return
        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {
          return this;
        }

        // If attempting to set read only attributes, return
        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {
          return this;
        }
      }

      // If there's a data type sanitizer
      if (
        !(value instanceof Utils.SequelizeMethod)
        && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)
      ) {
        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);
      }

      // Set when the value has changed and not raw
      if (
        !options.raw &&
        (
          // True when sequelize method
          (value instanceof Utils.SequelizeMethod ||
          // Check for data type type comparators
          !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || // Check default
          !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))
        )
      ) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }

      // set data value
      this.dataValues[key] = value;
    }
    return this;
  }

  setAttributes(updates) {
    return this.set(updates);
  }

  /**
   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.
   *
   * If changed is called without an argument, it will return an array of keys that have changed.
   *
   * If changed is called without an argument and no keys have changed, it will return `false`.
   *
   * Please note that this function will return `false` when a property from a nested (for example JSON) property
   * was edited manually, you must call `changed('key', true)` manually in these cases.
   * Writing an entirely new object (eg. deep cloned) will be detected.
   *
   * @example
   * ```
   * const mdl = await MyModel.findOne();
   * mdl.myJsonField.a = 1;
   * console.log(mdl.changed()) => false
   * mdl.save(); // this will not save anything
   * mdl.changed('myJsonField', true);
   * console.log(mdl.changed()) => ['myJsonField']
   * mdl.save(); // will save
   * ```
   *
   * @param {string} [key] key to check or change status of
   * @param {any} [value] value to set
   *
   * @returns {boolean|Array}
   */
  changed(key, value) {
    if (key === undefined) {
      if (this._changed.size > 0) {
        return Array.from(this._changed);
      }
      return false;
    }
    if (value === true) {
      this._changed.add(key);
      return this;
    }
    if (value === false) {
      this._changed.delete(key);
      return this;
    }
    return this._changed.has(key);
  }

  /**
   * Returns the previous value for key from `_previousDataValues`.
   *
   * If called without a key, returns the previous values for all values which have changed
   *
   * @param {string} [key] key to get previous value of
   *
   * @returns {any|Array<any>}
   */
  previous(key) {
    if (key) {
      return this._previousDataValues[key];
    }

    return _.pickBy(this._previousDataValues, (value, key) => this.changed(key));
  }

  _setInclude(key, value, options) {
    if (!Array.isArray(value)) value = [value];
    if (value[0] instanceof Model) {
      value = value.map(instance => instance.dataValues);
    }

    const include = this._options.includeMap[key];
    const association = include.association;
    const accessor = key;
    const primaryKeyAttribute = include.model.primaryKeyAttribute;
    const childOptions = {
      isNewRecord: this.isNewRecord,
      include: include.include,
      includeNames: include.includeNames,
      includeMap: include.includeMap,
      includeValidated: true,
      raw: options.raw,
      attributes: include.originalAttributes
    };
    let isEmpty;

    if (include.originalAttributes === undefined || include.originalAttributes.length) {
      if (association.isSingleAssociation) {
        if (Array.isArray(value)) {
          value = value[0];
        }
        isEmpty = value && value[primaryKeyAttribute] === null || value === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);
      } else {
        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);
      }
    }
  }

  /**
   * Validates this instance, and if the validation passes, persists it to the database.
   *
   * Returns a Promise that resolves to the saved instance (or rejects with a `Sequelize.ValidationError`, which will have a property for each of the fields for which the validation failed, with the error message for that field).
   *
   * This method is optimized to perform an UPDATE only into the fields that changed. If nothing has changed, no SQL query will be performed.
   *
   * This method is not aware of eager loaded associations. In other words, if some other model instance (child) was eager loaded with this instance (parent), and you change something in the child, calling `save()` will simply ignore the change that happened on the child.
   *
   * @param {object}      [options] save options
   * @param {string[]}    [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {boolean}     [options.validate=true] If false, validations won't be run.
   * @param {boolean}     [options.hooks=true] Run before and after create / update + validate hooks
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   */
  async save(options) {
    if (arguments.length > 1) {
      throw new Error('The second argument was removed in favor of the options object.');
    }

    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      hooks: true,
      validate: true
    });

    if (!options.fields) {
      if (this.isNewRecord) {
        options.fields = Object.keys(this.constructor.rawAttributes);
      } else {
        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));
      }

      options.defaultFields = options.fields;
    }

    if (options.returning === undefined) {
      if (options.association) {
        options.returning = false;
      } else if (this.isNewRecord) {
        options.returning = true;
      }
    }

    const primaryKeyName = this.constructor.primaryKeyAttribute;
    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];
    const createdAtAttr = this.constructor._timestampAttributes.createdAt;
    const versionAttr = this.constructor._versionAttribute;
    const hook = this.isNewRecord ? 'Create' : 'Update';
    const wasNewRecord = this.isNewRecord;
    const now = Utils.now(this.sequelize.options.dialect);
    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;

    if (updatedAtAttr && options.fields.length >= 1 && !options.fields.includes(updatedAtAttr)) {
      options.fields.push(updatedAtAttr);
    }
    if (versionAttr && options.fields.length >= 1 && !options.fields.includes(versionAttr)) {
      options.fields.push(versionAttr);
    }

    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {
      // UpdateAtAttr might have been added as a result of Object.keys(Model.rawAttributes). In that case we have to remove it again
      _.remove(options.fields, val => val === updatedAtAttr);
      updatedAtAttr = false;
    }

    if (this.isNewRecord === true) {
      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {
        options.fields.push(createdAtAttr);
      }

      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {
        options.fields.unshift(primaryKeyName);
      }
    }

    if (this.isNewRecord === false) {
      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === undefined) {
        throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');
      }
    }

    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {
      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;
    }

    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {
      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;
    }

    // Validate
    if (options.validate) {
      await this.validate(options);
    }
    // Run before hook
    if (options.hooks) {
      const beforeHookValues = _.pick(this.dataValues, options.fields);
      let ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values
      let hookChanged;
      let afterHookValues;

      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {
        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);
      }

      await this.constructor.runHooks(`before${hook}`, this, options);
      if (options.defaultFields && !this.isNewRecord) {
        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));

        hookChanged = [];
        for (const key of Object.keys(afterHookValues)) {
          if (afterHookValues[key] !== beforeHookValues[key]) {
            hookChanged.push(key);
          }
        }

        options.fields = _.uniq(options.fields.concat(hookChanged));
      }

      if (hookChanged) {
        if (options.validate) {
          // Validate again

          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);
          await this.validate(options);
          delete options.skip;
        }
      }
    }
    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(this._options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
        const instance = this.get(include.as);
        if (!instance) return;

        const includeOptions = _(Utils.cloneDeep(include))
          .omit(['association'])
          .defaults({
            transaction: options.transaction,
            logging: options.logging,
            parentRecord: this
          }).value();

        await instance.save(includeOptions);

        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });
      }));
    }
    const realFields = options.fields.filter(field => !this.constructor._virtualAttributes.has(field));
    if (!realFields.length) return this;
    if (!this.changed() && !this.isNewRecord) return this;

    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], 'field') || versionAttr;
    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);
    let query = null;
    let args = [];
    let where;

    if (this.isNewRecord) {
      query = 'insert';
      args = [this, this.constructor.getTableName(options), values, options];
    } else {
      where = this.where(true);
      if (versionAttr) {
        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;
      }
      query = 'update';
      args = [this, this.constructor.getTableName(options), values, where, options];
    }

    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);
    if (versionAttr) {
      // Check to see that a row was updated, otherwise it's an optimistic locking error.
      if (rowsUpdated < 1) {
        throw new sequelizeErrors.OptimisticLockError({
          modelName: this.constructor.name,
          values,
          where
        });
      } else {
        result.dataValues[versionAttr] = values[versionFieldName];
      }
    }

    // Transfer database generated values (defaults, autoincrement, etc)
    for (const attr of Object.keys(this.constructor.rawAttributes)) {
      if (this.constructor.rawAttributes[attr].field &&
          values[this.constructor.rawAttributes[attr].field] !== undefined &&
          this.constructor.rawAttributes[attr].field !== attr
      ) {
        values[attr] = values[this.constructor.rawAttributes[attr].field];
        delete values[this.constructor.rawAttributes[attr].field];
      }
    }
    Object.assign(values, result.dataValues);

    Object.assign(result.dataValues, values);
    if (wasNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(
        this._options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          let instances = this.get(include.as);

          if (!instances) return;
          if (!Array.isArray(instances)) instances = [instances];

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging,
              parentRecord: this
            }).value();

          // Instances will be updated in place so we can safely treat HasOne like a HasMany
          await Promise.all(instances.map(async instance => {
            if (include.association instanceof BelongsToMany) {
              await instance.save(includeOptions);
              const values0 = {
                [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };

              if (instance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof instance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values0[attr] = instance[include.association.through.model.name][attr];
                }
              }

              await include.association.throughModel.create(values0, includeOptions);
            } else {
              instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
              Object.assign(instance, include.association.scope);
              await instance.save(includeOptions);
            }
          }));
        })
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks(`after${hook}`, result, options);
    }
    for (const field of options.fields) {
      result._previousDataValues[field] = result.dataValues[field];
      this.changed(field, false);
    }
    this.isNewRecord = false;

    return result;
  }

  /**
   * Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.
   * This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,
   * all references to the Instance are updated with the new data and no new objects are created.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} [options] Options that are passed on to `Model.find`
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   *
   * @returns {Promise<Model>}
   */
  async reload(options) {
    options = Utils.defaults({
      where: this.where()
    }, options, {
      include: this._options.include || undefined
    });

    const reloaded = await this.constructor.findOne(options);
    if (!reloaded) {
      throw new sequelizeErrors.InstanceError(
        'Instance could not be reloaded because it does not exist anymore (find call returned null)'
      );
    }
    // update the internal options of the instance
    this._options = reloaded._options;
    // re-set instance values
    this.set(reloaded.dataValues, {
      raw: true,
      reset:  true && !options.attributes
    });

    return this;
  }

  /**
  * Validate the attributes of this instance according to validation rules set in the model definition.
  *
  * The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.
  *
  * @param {object} [options] Options that are passed to the validator
  * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated
  * @param {Array} [options.fields] An array of strings. Only the properties that are in this array will be validated
  * @param {boolean} [options.hooks=true] Run before and after validate hooks
  *
  * @returns {Promise}
  */
  async validate(options) {
    return new InstanceValidator(this, options).validate();
  }

  /**
   * This is the same as calling `set` and then calling `save` but it only saves the
   * exact values passed to it, making it more atomic and safer.
   *
   * @see
   * {@link Model#set}
   * @see
   * {@link Model#save}
   *
   * @param {object} values See `set`
   * @param {object} options See `save`
   *
   * @returns {Promise<Model>}
   */
  async update(values, options) {
    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    const changedBefore = this.changed() || [];

    options = options || {};
    if (Array.isArray(options)) options = { fields: options };

    options = Utils.cloneDeep(options);
    const setOptions = Utils.cloneDeep(options);
    setOptions.attributes = options.fields;
    this.set(values, setOptions);

    // Now we need to figure out which fields were actually affected by the setter.
    const sideEffects = _.without(this.changed(), ...changedBefore);
    const fields = _.union(Object.keys(values), sideEffects);

    if (!options.fields) {
      options.fields = _.intersection(fields, this.changed());
      options.defaultFields = options.fields;
    }

    return await this.save(options);
  }

  /**
   * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.
   *
   * @param {object}      [options={}] destroy options
   * @param {boolean}     [options.force=false] If set to true, paranoid models will actually be deleted
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   */
  async destroy(options) {
    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeDestroy', this, options);
    }
    const where = this.where(true);

    let result;
    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {
      const attributeName = this.constructor._timestampAttributes.deletedAt;
      const attribute = this.constructor.rawAttributes[attributeName];
      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')
        ? attribute.defaultValue
        : null;
      const currentValue = this.getDataValue(attributeName);
      const undefinedOrNull = currentValue == null && defaultValue == null;
      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {
        // only update timestamp if it wasn't already set
        this.setDataValue(attributeName, new Date());
      }

      result = await this.save({ ...options, hooks: false });
    } else {
      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, { type: QueryTypes.DELETE, limit: null, ...options });
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterDestroy', this, options);
    }
    return result;
  }

  /**
   * Helper method to determine if a instance is "soft deleted".  This is
   * particularly useful if the implementer renamed the `deletedAt` attribute
   * to something different.  This method requires `paranoid` to be enabled.
   *
   * @returns {boolean}
   */
  isSoftDeleted() {
    if (!this.constructor._timestampAttributes.deletedAt) {
      throw new Error('Model is not paranoid');
    }

    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];
    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;
    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;
    const isSet = deletedAt !== defaultValue;

    return isSet;
  }

  /**
   * Restore the row corresponding to this instance. Only available for paranoid models.
   *
   * @param {object}      [options={}] restore options
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise}
   */
  async restore(options) {
    if (!this.constructor._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeRestore', this, options);
    }
    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    this.setDataValue(deletedAtCol, deletedAtDefaultValue);
    const result = await this.save({ ...options, hooks: false, omitNull: false });
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterRestore', this, options);
      return result;
    }
    return result;
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ```sql
   * SET column = column + X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.increment('number') // increment number by 1
   *
   * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2
   *
   * // increment answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.increment({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} [options] options
   * @param {number} [options.by=1] The number to increment by
   * @param {boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   * @since 4.0.0
   */
  async increment(fields, options) {
    const identifier = this.where();

    options = Utils.cloneDeep(options);
    options.where = { ...options.where, ...identifier };
    options.instance = this;

    await this.constructor.increment(fields, options);

    return this;
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql
   * SET column = column - X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.decrement('number') // decrement number by 1
   *
   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2
   *
   * // decrement answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.decrement({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   * @param {string|Array|object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given
   * @param {object}      [options] decrement options
   * @param {number}      [options.by=1] The number to decrement by
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise}
   */
  async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  /**
   * Check whether this and `other` Instance refer to the same row
   *
   * @param {Model} other Other instance to compare against
   *
   * @returns {boolean}
   */
  equals(other) {
    if (!other || !other.constructor) {
      return false;
    }

    if (!(other instanceof this.constructor)) {
      return false;
    }

    return this.constructor.primaryKeyAttributes.every(attribute => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));
  }

  /**
   * Check if this is equal to one of `others` by calling equals
   *
   * @param {Array<Model>} others An array of instances to check against
   *
   * @returns {boolean}
   */
  equalsOneOf(others) {
    return others.some(other => this.equals(other));
  }

  setValidators(attribute, validators) {
    this.validators[attribute] = validators;
  }

  /**
   * Convert the instance to a JSON representation.
   * Proxies to calling `get` with no keys.
   * This means get all values gotten from the DB, and apply all custom getters.
   *
   * @see
   * {@link Model#get}
   *
   * @returns {object}
   */
  toJSON() {
    return _.cloneDeep(
      this.get({
        plain: true
      })
    );
  }

  /**
   * Creates a 1:m association between this (the source) and the provided target.
   * The foreign key is added on the target.
   *
   * @param {Model}               target Target model
   * @param {object}              [options] hasMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string|object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}              [options.onUpdate='CASCADE'] Set `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {HasMany}
   *
   * @example
   * User.hasMany(Profile) // This will add userId to the profile table
   */
  static hasMany(target, options) {} // eslint-disable-line

  /**
   * Create an N:M association with a join table. Defining `through` is required.
   *
   * @param {Model}               target Target model
   * @param {object}              options belongsToMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {Model|string|object} options.through The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.
   * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.
   * @param {object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)
   * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)
   * @param {string|object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string|object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m
   * @param {string}              [options.onUpdate='CASCADE'] Sets `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsToMany}
   *
   * @example
   * // Automagically generated join model
   * User.belongsToMany(Project, { through: 'UserProjects' })
   * Project.belongsToMany(User, { through: 'UserProjects' })
   *
   * // Join model with additional attributes
   * const UserProjects = sequelize.define('UserProjects', {
   *   started: Sequelize.BOOLEAN
   * })
   * User.belongsToMany(Project, { through: UserProjects })
   * Project.belongsToMany(User, { through: UserProjects })
   */
  static belongsToMany(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the target.
   *
   * @param {Model}           target Target model
   * @param {object}          [options] hasOne association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}          [options.sourceKey] The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   * @param {string}          [options.uniqueKey] The custom name for unique constraint.
   *
   * @returns {HasOne}
   *
   * @example
   * User.hasOne(Profile) // This will add userId to the profile table
   */
  static hasOne(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the source.
   *
   * @param {Model}           target The target model
   * @param {object}          [options] belongsTo association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {string}          [options.targetKey] The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsTo}
   *
   * @example
   * Profile.belongsTo(User) // This will add userId to the profile table
   */
  static belongsTo(target, options) {} // eslint-disable-line
}

Object.assign(Model, associationsMixin);
Hooks.applyTo(Model, true);

module.exports = Model;


/***/ }),

/***/ "./node_modules/sequelize/lib/operators.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/operators.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * Operator symbols to be used when querying data
 *
 * @see {@link Model#where}
 *
 * @property eq
 * @property ne
 * @property gte
 * @property gt
 * @property lte
 * @property lt
 * @property not
 * @property is
 * @property in
 * @property notIn
 * @property like
 * @property notLike
 * @property iLike
 * @property notILike
 * @property startsWith
 * @property endsWith
 * @property substring
 * @property regexp
 * @property notRegexp
 * @property iRegexp
 * @property notIRegexp
 * @property between
 * @property notBetween
 * @property overlap
 * @property contains
 * @property contained
 * @property adjacent
 * @property strictLeft
 * @property strictRight
 * @property noExtendRight
 * @property noExtendLeft
 * @property and
 * @property or
 * @property any
 * @property all
 * @property values
 * @property col
 * @property placeholder
 * @property join
 */
const Op = {
  eq: Symbol.for('eq'),
  ne: Symbol.for('ne'),
  gte: Symbol.for('gte'),
  gt: Symbol.for('gt'),
  lte: Symbol.for('lte'),
  lt: Symbol.for('lt'),
  not: Symbol.for('not'),
  is: Symbol.for('is'),
  in: Symbol.for('in'),
  notIn: Symbol.for('notIn'),
  like: Symbol.for('like'),
  notLike: Symbol.for('notLike'),
  iLike: Symbol.for('iLike'),
  notILike: Symbol.for('notILike'),
  startsWith: Symbol.for('startsWith'),
  endsWith: Symbol.for('endsWith'),
  substring: Symbol.for('substring'),
  regexp: Symbol.for('regexp'),
  notRegexp: Symbol.for('notRegexp'),
  iRegexp: Symbol.for('iRegexp'),
  notIRegexp: Symbol.for('notIRegexp'),
  between: Symbol.for('between'),
  notBetween: Symbol.for('notBetween'),
  overlap: Symbol.for('overlap'),
  contains: Symbol.for('contains'),
  contained: Symbol.for('contained'),
  adjacent: Symbol.for('adjacent'),
  strictLeft: Symbol.for('strictLeft'),
  strictRight: Symbol.for('strictRight'),
  noExtendRight: Symbol.for('noExtendRight'),
  noExtendLeft: Symbol.for('noExtendLeft'),
  and: Symbol.for('and'),
  or: Symbol.for('or'),
  any: Symbol.for('any'),
  all: Symbol.for('all'),
  values: Symbol.for('values'),
  col: Symbol.for('col'),
  placeholder: Symbol.for('placeholder'),
  join: Symbol.for('join'),
  match: Symbol.for('match')
};

module.exports = Op;


/***/ }),

/***/ "./node_modules/sequelize/lib/query-types.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/query-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of query types used by `sequelize.query`
 *
 * @see {@link Sequelize#query}
 *
 * @property SELECT
 * @property INSERT
 * @property UPDATE
 * @property BULKUPDATE
 * @property BULKDELETE
 * @property DELETE
 * @property UPSERT
 * @property VERSION
 * @property SHOWTABLES
 * @property SHOWINDEXES
 * @property DESCRIBE
 * @property RAW
 * @property FOREIGNKEYS
 * @property SHOWCONSTRAINTS
 */
const QueryTypes = module.exports = { // eslint-disable-line
  SELECT: 'SELECT',
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  BULKUPDATE: 'BULKUPDATE',
  BULKDELETE: 'BULKDELETE',
  DELETE: 'DELETE',
  UPSERT: 'UPSERT',
  VERSION: 'VERSION',
  SHOWTABLES: 'SHOWTABLES',
  SHOWINDEXES: 'SHOWINDEXES',
  DESCRIBE: 'DESCRIBE',
  RAW: 'RAW',
  FOREIGNKEYS: 'FOREIGNKEYS',
  SHOWCONSTRAINTS: 'SHOWCONSTRAINTS'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/sequelize.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/sequelize.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const retry = __webpack_require__(/*! retry-as-promised */ "./node_modules/retry-as-promised/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const Model = __webpack_require__(/*! ./model */ "./node_modules/sequelize/lib/model.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Deferrable = __webpack_require__(/*! ./deferrable */ "./node_modules/sequelize/lib/deferrable.js");
const ModelManager = __webpack_require__(/*! ./model-manager */ "./node_modules/sequelize/lib/model-manager.js");
const Transaction = __webpack_require__(/*! ./transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const TableHints = __webpack_require__(/*! ./table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const IndexHints = __webpack_require__(/*! ./index-hints */ "./node_modules/sequelize/lib/index-hints.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const Association = __webpack_require__(/*! ./associations/index */ "./node_modules/sequelize/lib/associations/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const deprecations = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");

/**
 * This is the main class, the entry point to sequelize.
 */
class Sequelize {
  /**
   * Instantiate sequelize with name of database, username and password.
   *
   * @example
   * // without password / with blank password
   * const sequelize = new Sequelize('database', 'username', null, {
   *   dialect: 'mysql'
   * })
   *
   * // with password and options
   * const sequelize = new Sequelize('my_database', 'john', 'doe', {
   *   dialect: 'postgres'
   * })
   *
   * // with database, username, and password in the options object
   * const sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });
   *
   * // with uri
   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})
   *
   * // option examples
   * const sequelize = new Sequelize('database', 'username', 'password', {
   *   // the sql dialect of the database
   *   // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'
   *   dialect: 'mysql',
   *
   *   // custom host; default: localhost
   *   host: 'my.server.tld',
   *   // for postgres, you can also specify an absolute path to a directory
   *   // containing a UNIX socket to connect over
   *   // host: '/sockets/psql_sockets'.
   *
   *   // custom port; default: dialect default
   *   port: 12345,
   *
   *   // custom protocol; default: 'tcp'
   *   // postgres only, useful for Heroku
   *   protocol: null,
   *
   *   // disable logging or provide a custom logging function; default: console.log
   *   logging: false,
   *
   *   // you can also pass any dialect options to the underlying dialect library
   *   // - default is empty
   *   // - currently supported: 'mysql', 'postgres', 'mssql'
   *   dialectOptions: {
   *     socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',
   *     supportBigNumbers: true,
   *     bigNumberStrings: true
   *   },
   *
   *   // the storage engine for sqlite
   *   // - default ':memory:'
   *   storage: 'path/to/database.sqlite',
   *
   *   // disable inserting undefined values as NULL
   *   // - default: false
   *   omitNull: true,
   *
   *   // a flag for using a native library or not.
   *   // in the case of 'pg' -- set this to true will allow SSL support
   *   // - default: false
   *   native: true,
   *
   *   // Specify options, which are used when sequelize.define is called.
   *   // The following example:
   *   //   define: { timestamps: false }
   *   // is basically the same as:
   *   //   Model.init(attributes, { timestamps: false });
   *   //   sequelize.define(name, attributes, { timestamps: false });
   *   // so defining the timestamps for each model will be not necessary
   *   define: {
   *     underscored: false,
   *     freezeTableName: false,
   *     charset: 'utf8',
   *     dialectOptions: {
   *       collate: 'utf8_general_ci'
   *     },
   *     timestamps: true
   *   },
   *
   *   // similar for sync: you can define this to always force sync for models
   *   sync: { force: true },
   *
   *   // pool configuration used to pool database connections
   *   pool: {
   *     max: 5,
   *     idle: 30000,
   *     acquire: 60000,
   *   },
   *
   *   // isolation level of each transaction
   *   // defaults to dialect default
   *   isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
   * })
   *
   * @param {string}   [database] The name of the database
   * @param {string}   [username=null] The username which is used to authenticate against the database.
   * @param {string}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.
   * @param {object}   [options={}] An object with options.
   * @param {string}   [options.host='localhost'] The host of the relational database.
   * @param {number}   [options.port=] The port of the relational database.
   * @param {string}   [options.username=null] The username which is used to authenticate against the database.
   * @param {string}   [options.password=null] The password which is used to authenticate against the database.
   * @param {string}   [options.database=null] The name of the database
   * @param {string}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.
   * @param {string}   [options.dialectModule=null] If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require("pg.js")' here
   * @param {string}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here
   * @param {object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library
   * @param {string}   [options.storage] Only used by sqlite. Defaults to ':memory:'
   * @param {string}   [options.protocol='tcp'] The protocol of the relational database.
   * @param {object}   [options.define={}] Default options for model definitions. See {@link Model.init}.
   * @param {object}   [options.query={}] Default options for sequelize.query
   * @param {string}   [options.schema=null] A schema to use
   * @param {object}   [options.set={}] Default options for sequelize.set
   * @param {object}   [options.sync={}] Default options for sequelize.sync
   * @param {string}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.
   * @param {string|boolean} [options.clientMinMessages='warning'] The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default.
   * @param {boolean}  [options.standardConformingStrings=true] The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something. Function may receive multiple parameters but only first one is printed by `console.log`. To print all values use `(...msg) => console.log(msg)`
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {boolean}  [options.omitNull=false] A flag that defines if null values should be passed as values to CREATE/UPDATE SQL queries or not.
   * @param {boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   * @param {boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`
   * @param {object}   [options.pool] sequelize connection pool configuration
   * @param {number}   [options.pool.max=5] Maximum number of connection in pool
   * @param {number}   [options.pool.min=0] Minimum number of connection in pool
   * @param {number}   [options.pool.idle=10000] The maximum time, in milliseconds, that a connection can be idle before being released.
   * @param {number}   [options.pool.acquire=60000] The maximum time, in milliseconds, that pool will try to get connection before throwing error
   * @param {number}   [options.pool.evict=1000] The time interval, in milliseconds, after which sequelize-pool will remove idle connections.
   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected
   * @param {number}   [options.pool.maxUses=Infinity] The number of times a connection can be used before discarding it for a replacement, [`used for eventual cluster rebalancing`](https://github.com/sequelize/sequelize-pool).
   * @param {boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {string}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.
   * @param {object}   [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {number}   [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.
   * @param {boolean}  [options.typeValidation=false] Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.
   * @param {object}   [options.operatorsAliases] String based operator alias. Pass object to limit set of aliased operators.
   * @param {object}   [options.hooks] An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here.
   * @param {boolean}  [options.minifyAliases=false] A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)
   * @param {boolean}  [options.logQueryParameters=false] A flag that defines if show bind parameters in log.
   */
  constructor(database, username, password, options) {
    let config;

    if (arguments.length === 1 && typeof database === 'object') {
      // new Sequelize({ ... options })
      options = database;
      config = _.pick(options, 'host', 'port', 'database', 'username', 'password');
    } else if (arguments.length === 1 && typeof database === 'string' || arguments.length === 2 && typeof username === 'object') {
      // new Sequelize(URI, { ... options })

      config = {};
      options = username || {};

      const urlParts = url.parse(arguments[0], true);

      options.dialect = urlParts.protocol.replace(/:$/, '');
      options.host = urlParts.hostname;

      if (options.dialect === 'sqlite' && urlParts.pathname && !urlParts.pathname.startsWith('/:memory')) {
        const storagePath = path.join(options.host, urlParts.pathname);
        options.storage = path.resolve(options.storage || storagePath);
      }

      if (urlParts.pathname) {
        config.database = urlParts.pathname.replace(/^\//, '');
      }

      if (urlParts.port) {
        options.port = urlParts.port;
      }

      if (urlParts.auth) {
        const authParts = urlParts.auth.split(':');

        config.username = authParts[0];

        if (authParts.length > 1)
          config.password = authParts.slice(1).join(':');
      }

      if (urlParts.query) {
        // Allow host query argument to override the url host.
        // Enables specifying domain socket hosts which cannot be specified via the typical
        // host part of a url.
        if (urlParts.query.host) {
          options.host = urlParts.query.host;
        }

        if (options.dialectOptions) {
          Object.assign(options.dialectOptions, urlParts.query);
        } else {
          options.dialectOptions = urlParts.query;
          if (urlParts.query.options) {
            try {
              const o = JSON.parse(urlParts.query.options);
              options.dialectOptions.options = o;
            } catch (e) {
              // Nothing to do, string is not a valid JSON
              // an thus does not need any further processing
            }
          }
        }
      }
    } else {
      // new Sequelize(database, username, password, { ... options })
      options = options || {};
      config = { database, username, password };
    }

    Sequelize.runHooks('beforeInit', config, options);

    this.options = {
      dialect: null,
      dialectModule: null,
      dialectModulePath: null,
      host: 'localhost',
      protocol: 'tcp',
      define: {},
      query: {},
      sync: {},
      timezone: '+00:00',
      clientMinMessages: 'warning',
      standardConformingStrings: true,
      // eslint-disable-next-line no-console
      logging: console.log,
      omitNull: false,
      native: false,
      replication: false,
      ssl: undefined,
      pool: {},
      quoteIdentifiers: true,
      hooks: {},
      retry: {
        max: 5,
        match: [
          'SQLITE_BUSY: database is locked'
        ]
      },
      transactionType: Transaction.TYPES.DEFERRED,
      isolationLevel: null,
      databaseVersion: 0,
      typeValidation: false,
      benchmark: false,
      minifyAliases: false,
      logQueryParameters: false,
      ...options
    };

    if (!this.options.dialect) {
      throw new Error('Dialect needs to be explicitly supplied as of v4.0.0');
    }

    if (this.options.dialect === 'postgresql') {
      this.options.dialect = 'postgres';
    }

    if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {
      throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');
    }

    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }

    this._setupHooks(options.hooks);

    this.config = {
      database: config.database || this.options.database,
      username: config.username || this.options.username,
      password: config.password || this.options.password || null,
      host: config.host || this.options.host,
      port: config.port || this.options.port,
      pool: this.options.pool,
      protocol: this.options.protocol,
      native: this.options.native,
      ssl: this.options.ssl,
      replication: this.options.replication,
      dialectModule: this.options.dialectModule,
      dialectModulePath: this.options.dialectModulePath,
      keepDefaultTimezone: this.options.keepDefaultTimezone,
      dialectOptions: this.options.dialectOptions
    };

    let Dialect;
    // Requiring the dialect in a switch-case to keep the
    // require calls static. (Browserify fix)
    switch (this.getDialect()) {
      case 'mariadb':
        Dialect = __webpack_require__(/*! ./dialects/mariadb */ "./node_modules/sequelize/lib/dialects/mariadb/index.js");
        break;
      case 'mssql':
        Dialect = __webpack_require__(/*! ./dialects/mssql */ "./node_modules/sequelize/lib/dialects/mssql/index.js");
        break;
      case 'mysql':
        Dialect = __webpack_require__(/*! ./dialects/mysql */ "./node_modules/sequelize/lib/dialects/mysql/index.js");
        break;
      case 'postgres':
        Dialect = __webpack_require__(/*! ./dialects/postgres */ "./node_modules/sequelize/lib/dialects/postgres/index.js");
        break;
      case 'sqlite':
        Dialect = __webpack_require__(/*! ./dialects/sqlite */ "./node_modules/sequelize/lib/dialects/sqlite/index.js");
        break;
      default:
        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, postgres, and sqlite.`);
    }

    this.dialect = new Dialect(this);
    this.dialect.queryGenerator.typeValidation = options.typeValidation;

    if (_.isPlainObject(this.options.operatorsAliases)) {
      deprecations.noStringOperators();
      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);
    } else if (typeof this.options.operatorsAliases === 'boolean') {
      deprecations.noBoolOperatorAliases();
    }

    this.queryInterface = this.dialect.queryInterface;

    /**
     * Models are stored here under the name given to `sequelize.define`
     */
    this.models = {};
    this.modelManager = new ModelManager(this);
    this.connectionManager = this.dialect.connectionManager;

    Sequelize.runHooks('afterInit', this);
  }

  /**
   * Refresh data types and parsers.
   *
   * @private
   */
  refreshTypes() {
    this.connectionManager.refreshTypeParser(DataTypes);
  }

  /**
   * Returns the specified dialect.
   *
   * @returns {string} The specified dialect.
   */
  getDialect() {
    return this.options.dialect;
  }

  /**
   * Returns the database name.
   *
   * @returns {string} The database name.
   */
  getDatabaseName() {
    return this.config.database;
  }

  /**
   * Returns an instance of QueryInterface.
   *
   * @returns {QueryInterface} An instance (singleton) of QueryInterface.
   */
  getQueryInterface() {
    return this.queryInterface;
  }

  /**
   * Define a new model, representing a table in the database.
   *
   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column
   *
   * @param {string} modelName The name of the model. The model will be stored in `sequelize.models` under this name
   * @param {object} attributes An object, where each attribute is a column of the table. See {@link Model.init}
   * @param {object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()
   *
   * @see
   * {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @returns {Model} Newly defined model
   *
   * @example
   * sequelize.define('modelName', {
   *   columnA: {
   *       type: Sequelize.BOOLEAN,
   *       validate: {
   *         is: ["[a-z]",'i'],        // will only allow letters
   *         max: 23,                  // only allow values <= 23
   *         isIn: {
   *           args: [['en', 'zh']],
   *           msg: "Must be English or Chinese"
   *         }
   *       },
   *       field: 'column_a'
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * });
   *
   * sequelize.models.modelName // The model will now be available in models under the name given to define
   */
  define(modelName, attributes, options = {}) {
    options.modelName = modelName;
    options.sequelize = this;

    const model = class extends Model {};

    model.init(attributes, options);

    return model;
  }

  /**
   * Fetch a Model which is already defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)
   * @returns {Model} Specified model
   */
  model(modelName) {
    if (!this.isDefined(modelName)) {
      throw new Error(`${modelName} has not been defined`);
    }

    return this.modelManager.getModel(modelName);
  }

  /**
   * Checks whether a model with the given name is defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @returns {boolean} Returns true if model is already defined, otherwise false
   */
  isDefined(modelName) {
    return !!this.modelManager.models.find(model => model.name === modelName);
  }

  /**
   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.
   *
   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.
   *
   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:
   *
   * ```js
   * const [results, metadata] = await sequelize.query('SELECT...'); // Raw query - use array destructuring
   *
   * const results = await sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }); // SELECT query - no destructuring
   * ```
   *
   * @param {string}          sql
   * @param {object}          [options={}] Query options.
   * @param {boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result
   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under
   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   * @param {boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified
   * @param {boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row
   * @param {object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.
   * @param {object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.
   * @param {boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Model}           [options.instance] A sequelize model instance whose Model is to be used to build the query result
   * @param {typeof Model}    [options.model] A sequelize model used to build the returned model instances
   * @param {object}          [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.
   * @param {string}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)
   * @param {boolean}         [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.
   * @param {object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.
   *
   * @returns {Promise}
   *
   * @see {@link Model.build} for more information about instance option.
   */

  async query(sql, options) {
    options = { ...this.options.query, ...options };

    if (options.instance && !options.model) {
      options.model = options.instance.constructor;
    }

    if (!options.instance && !options.model) {
      options.raw = true;
    }

    // map raw fields to model attributes
    if (options.mapToModel) {
      options.fieldMap = _.get(options, 'model.fieldAttributeMap', {});
    }

    options = _.defaults(options, {
      // eslint-disable-next-line no-console
      logging: Object.prototype.hasOwnProperty.call(this.options, 'logging') ? this.options.logging : console.log,
      searchPath: Object.prototype.hasOwnProperty.call(this.options, 'searchPath') ? this.options.searchPath : 'DEFAULT'
    });

    if (!options.type) {
      if (options.model || options.nest || options.plain) {
        options.type = QueryTypes.SELECT;
      } else {
        options.type = QueryTypes.RAW;
      }
    }

    //if dialect doesn't support search_path or dialect option
    //to prepend searchPath is not true delete the searchPath option
    if (
      !this.dialect.supports.searchPath ||
      !this.options.dialectOptions ||
      !this.options.dialectOptions.prependSearchPath ||
      options.supportsSearchPath === false
    ) {
      delete options.searchPath;
    } else if (!options.searchPath) {
      //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)
      //then set to DEFAULT if none is provided
      options.searchPath = 'DEFAULT';
    }

    if (typeof sql === 'object') {
      if (sql.values !== undefined) {
        if (options.replacements !== undefined) {
          throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');
        }
        options.replacements = sql.values;
      }

      if (sql.bind !== undefined) {
        if (options.bind !== undefined) {
          throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');
        }
        options.bind = sql.bind;
      }

      if (sql.query !== undefined) {
        sql = sql.query;
      }
    }

    sql = sql.trim();

    if (options.replacements && options.bind) {
      throw new Error('Both `replacements` and `bind` cannot be set at the same time');
    }

    if (options.replacements) {
      if (Array.isArray(options.replacements)) {
        sql = Utils.format([sql].concat(options.replacements), this.options.dialect);
      } else {
        sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);
      }
    }

    let bindParameters;

    if (options.bind) {
      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);
    }

    const checkTransaction = () => {
      if (options.transaction && options.transaction.finished && !options.completesTransaction) {
        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);
        error.sql = sql;
        throw error;
      }
    };

    const retryOptions = { ...this.options.retry, ...options.retry };

    return retry(async () => {
      if (options.transaction === undefined && Sequelize._cls) {
        options.transaction = Sequelize._cls.get('transaction');
      }

      checkTransaction();

      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));
      const query = new this.dialect.Query(connection, this, options);

      try {
        await this.runHooks('beforeQuery', options, query);
        checkTransaction();
        return await query.run(sql, bindParameters);
      } finally {
        await this.runHooks('afterQuery', options, query);
        if (!options.transaction) {
          await this.connectionManager.releaseConnection(connection);
        }
      }
    }, retryOptions);
  }

  /**
   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.
   * Only works for MySQL.
   *
   * @param {object}        variables Object with multiple variables.
   * @param {object}        [options] query options.
   * @param {Transaction}   [options.transaction] The transaction that the query should be executed under
   *
   * @memberof Sequelize
   *
   * @returns {Promise}
   */
  async set(variables, options) {

    // Prepare options
    options = { ...this.options.set, ...typeof options === 'object' && options };

    if (this.options.dialect !== 'mysql') {
      throw new Error('sequelize.set is only supported for mysql');
    }
    if (!options.transaction || !(options.transaction instanceof Transaction) ) {
      throw new TypeError('options.transaction is required');
    }

    // Override some options, since this isn't a SELECT
    options.raw = true;
    options.plain = true;
    options.type = 'SET';

    // Generate SQL Query
    const query =
      `SET ${
        _.map(variables, (v, k) => `@${k} := ${typeof v === 'string' ? `"${v}"` : v}`).join(', ')}`;

    return await this.query(query, options);
  }

  /**
   * Escape value.
   *
   * @param {string} value string value to escape
   *
   * @returns {string}
   */
  escape(value) {
    return this.dialect.queryGenerator.escape(value);
  }

  /**
   * Create a new database schema.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this command will do nothing.
   *
   * @see
   * {@link Model.schema}
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    return await this.getQueryInterface().createSchema(schema, options);
  }

  /**
   * Show all defined schemas
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this will show all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async showAllSchemas(options) {
    return await this.getQueryInterface().showAllSchemas(options);
  }

  /**
   * Drop a single schema
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this drop a table matching the schema name
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    return await this.getQueryInterface().dropSchema(schema, options);
  }

  /**
   * Drop all schemas.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    return await this.getQueryInterface().dropAllSchemas(options);
  }

  /**
   * Sync all defined models to the DB.
   *
   * @param {object} [options={}] sync options
   * @param {boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table
   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code
   * @param {boolean|Function} [options.logging=console.log] A function that logs sql queries, or false for no logging
   * @param {string} [options.schema='public'] The schema that the tables should be created in. This can be overridden for each table in sequelize.define
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called
   * @param {boolean|object} [options.alter=false] Alters tables to fit models. Provide an object for additional configuration. Not recommended for production use. If not further configured deletes data in columns that were removed or had their type changed in the model.
   * @param {boolean} [options.alter.drop=true] Prevents any drop statements while altering a table when set to `false`
   *
   * @returns {Promise}
   */
  async sync(options) {
    options = {
      ...this.options,
      ...this.options.sync,
      ...options,
      hooks: options ? options.hooks !== false : true
    };

    if (options.match) {
      if (!options.match.test(this.config.database)) {
        throw new Error(`Database "${this.config.database}" does not match sync match parameter "${options.match}"`);
      }
    }

    if (options.hooks) {
      await this.runHooks('beforeBulkSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }
    const models = [];

    // Topologically sort by foreign key constraints to give us an appropriate
    // creation order
    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      } else {
        // DB should throw an SQL error if referencing non-existent table
      }
    });

    // no models defined, just authenticate
    if (!models.length) {
      await this.authenticate(options);
    } else {
      for (const model of models) await model.sync(options);
    }
    if (options.hooks) {
      await this.runHooks('afterBulkSync', options);
    }
    return this;
  }

  /**
   * Truncate all tables defined through the sequelize models.
   * This is done by calling `Model.truncate()` on each model.
   *
   * @param {object} [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @returns {Promise}
   *
   * @see
   * {@link Model.truncate} for more information
   */
  async truncate(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    if (options && options.cascade) {
      for (const model of models) await model.truncate(options);
    } else {
      await Promise.all(models.map(model => model.truncate(options)));
    }
  }

  /**
   * Drop all tables defined through this sequelize instance.
   * This is done by calling Model.drop on each model.
   *
   * @see
   * {@link Model.drop} for options
   *
   * @param {object} [options] The options passed to each call to Model.drop
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async drop(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    for (const model of models) await model.drop(options);
  }

  /**
   * Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.
   *
   * @param {object} [options={}] query options
   *
   * @returns {Promise}
   */
  async authenticate(options) {
    options = {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT,
      ...options
    };

    await this.query('SELECT 1+1 AS result', options);

    return;
  }

  async databaseVersion(options) {
    return await this.getQueryInterface().databaseVersion(options);
  }

  /**
   * Get the fn for random based on the dialect
   *
   * @returns {Sequelize.fn}
   */
  random() {
    const dia = this.getDialect();
    if (dia === 'postgres' || dia === 'sqlite') {
      return this.fn('RANDOM');
    }
    return this.fn('RAND');
  }

  /**
   * Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.
   * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.
   *
   * @see
   * {@link Model.findAll}
   * @see
   * {@link Sequelize.define}
   * @see
   * {@link Sequelize.col}
   *
   * @param {string} fn The function you want to call
   * @param {any} args All further arguments will be passed as arguments to the function
   *
   * @since v2.0.0-dev3
   * @memberof Sequelize
   * @returns {Sequelize.fn}
   *
   * @example <caption>Convert a user's username to upper case</caption>
   * instance.update({
   *   username: sequelize.fn('upper', sequelize.col('username'))
   * });
   */
  static fn(fn, ...args) {
    return new Utils.Fn(fn, args);
  }

  /**
   * Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.
   *
   * @see
   * {@link Sequelize#fn}
   *
   * @param {string} col The name of the column
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.col}
   */
  static col(col) {
    return new Utils.Col(col);
  }

  /**
   * Creates an object representing a call to the cast function.
   *
   * @param {any} val The value to cast
   * @param {string} type The type to cast it to
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.cast}
   */
  static cast(val, type) {
    return new Utils.Cast(val, type);
  }

  /**
   * Creates an object representing a literal, i.e. something that will not be escaped.
   *
   * @param {any} val literal value
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.literal}
   */
  static literal(val) {
    return new Utils.Literal(val);
  }

  /**
   * An AND query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by AND
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.and}
   */
  static and(...args) {
    return { [Op.and]: args };
  }

  /**
   * An OR query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by OR
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.or}
   */
  static or(...args) {
    return { [Op.or]: args };
  }

  /**
   * Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {string|object} conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres/sqlite/mysql json syntax.
   * @param {string|number|boolean} [value] An optional value to compare against. Produces a string of the form "<json path> = '<value>'".
   * @memberof Sequelize
   *
   * @returns {Sequelize.json}
   */
  static json(conditionsOrPath, value) {
    return new Utils.Json(conditionsOrPath, value);
  }

  /**
   * A way of specifying attr = condition.
   *
   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The
   * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)
   *
   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax
   * @param {symbol} [comparator='Op.eq'] operator
   * @param {string|object} logic The condition. Can be both a simply type, or a further condition (`or`, `and`, `.literal` etc.)
   * @since v2.0.0-dev3
   */
  static where(attr, comparator, logic) {
    return new Utils.Where(attr, comparator, logic);
  }

  /**
   * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see {@link Transaction}
   *
   * If you have [CLS](https://github.com/Jeff-Lewis/cls-hooked) enabled, the transaction will automatically be passed to any query that runs within the callback
   *
   * @example
   *
   * try {
   *   const transaction = await sequelize.transaction();
   *   const user = await User.findOne(..., { transaction });
   *   await user.update(..., { transaction });
   *   await transaction.commit();
   * } catch {
   *   await transaction.rollback()
   * }
   *
   * @example <caption>A syntax for automatically committing or rolling back based on the promise chain resolution is also supported</caption>
   *
   * try {
   *   await sequelize.transaction(transaction => { // Note that we pass a callback rather than awaiting the call with no arguments
   *     const user = await User.findOne(..., {transaction});
   *     await user.update(..., {transaction});
   *   });
   *   // Committed
   * } catch(err) {
   *   // Rolled back
   *   console.error(err);
   * }
   * @example <caption>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</caption>
   *
   * const cls = require('cls-hooked');
   * const namespace = cls.createNamespace('....');
   * const Sequelize = require('sequelize');
   * Sequelize.useCLS(namespace);
   *
   * // Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace
   *
   * @param {object}   [options] Transaction options
   * @param {string}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options
   * @param {string}   [options.deferrable] Sets the constraints to be deferred or immediately checked. See `Sequelize.Deferrable`. PostgreSQL Only
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Function} [autoCallback] The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back
   *
   * @returns {Promise}
   */
  async transaction(options, autoCallback) {
    if (typeof options === 'function') {
      autoCallback = options;
      options = undefined;
    }

    const transaction = new Transaction(this, options);

    if (!autoCallback) {
      await transaction.prepareEnvironment(false);
      return transaction;
    }

    // autoCallback provided
    return Sequelize._clsRun(async () => {
      try {
        await transaction.prepareEnvironment();
        const result = await autoCallback(transaction);
        await transaction.commit();
        return await result;
      } catch (err) {
        try {
          if (!transaction.finished) {
            await transaction.rollback();
          } else {
            // release the connection, even if we don't need to rollback
            await transaction.cleanup();
          }
        } catch (err0) {
          // ignore
        }
        throw err;
      }
    });
  }

  /**
   * Use CLS (Continuation Local Storage) with Sequelize. With Continuation
   * Local Storage, all queries within the transaction callback will
   * automatically receive the transaction object.
   *
   * CLS namespace provided is stored as `Sequelize._cls`
   *
   * @param {object} ns CLS namespace
   * @returns {object} Sequelize constructor
   */
  static useCLS(ns) {
    // check `ns` is valid CLS namespace
    if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new Error('Must provide CLS namespace');

    // save namespace as `Sequelize._cls`
    this._cls = ns;

    // return Sequelize for chaining
    return this;
  }

  /**
   * Run function in CLS context.
   * If no CLS context in use, just runs the function normally
   *
   * @private
   * @param {Function} fn Function to run
   * @returns {*} Return value of function
   */
  static _clsRun(fn) {
    const ns = Sequelize._cls;
    if (!ns) return fn();

    let res;
    ns.run(context => res = fn(context));
    return res;
  }

  log(...args) {
    let options;

    const last = _.last(args);

    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, 'logging')) {
      options = last;

      // remove options from set of logged arguments if options.logging is equal to console.log
      // eslint-disable-next-line no-console
      if (options.logging === console.log) {
        args.splice(args.length - 1, 1);
      }
    } else {
      options = this.options;
    }

    if (options.logging) {
      if (options.logging === true) {
        deprecations.noTrueLogging();
        // eslint-disable-next-line no-console
        options.logging = console.log;
      }

      // second argument is sql-timings, when benchmarking option enabled
      // eslint-disable-next-line no-console
      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {
        args = [`${args[0]} Elapsed time: ${args[1]}ms`];
      }

      options.logging(...args);
    }
  }

  /**
   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.
   *
   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want
   * to garbage collect some of them.
   *
   * @returns {Promise}
   */
  close() {
    return this.connectionManager.close();
  }

  normalizeDataType(Type) {
    let type = typeof Type === 'function' ? new Type() : Type;
    const dialectTypes = this.dialect.DataTypes || {};

    if (dialectTypes[type.key]) {
      type = dialectTypes[type.key].extend(type);
    }

    if (type instanceof DataTypes.ARRAY) {
      if (!type.type) {
        throw new Error('ARRAY is missing type definition for its values.');
      }
      if (dialectTypes[type.type.key]) {
        type.type = dialectTypes[type.type.key].extend(type.type);
      }
    }

    return type;
  }

  normalizeAttribute(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = { type: attribute };
    }

    if (!attribute.type) return attribute;

    attribute.type = this.normalizeDataType(attribute.type);

    if (Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')) {
      if (typeof attribute.defaultValue === 'function' && (
        attribute.defaultValue === DataTypes.NOW ||
          attribute.defaultValue === DataTypes.UUIDV1 ||
          attribute.defaultValue === DataTypes.UUIDV4
      )) {
        attribute.defaultValue = new attribute.defaultValue();
      }
    }

    if (attribute.type instanceof DataTypes.ENUM) {
      // The ENUM is a special case where the type is an object containing the values
      if (attribute.values) {
        attribute.type.values = attribute.type.options.values = attribute.values;
      } else {
        attribute.values = attribute.type.values;
      }

      if (!attribute.values.length) {
        throw new Error('Values for ENUM have not been defined.');
      }
    }

    return attribute;
  }
}

// Aliases
Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;

/**
 * Sequelize version number.
 */
Sequelize.version = __webpack_require__(/*! ../package.json */ "./node_modules/sequelize/package.json").version;

Sequelize.options = { hooks: {} };

/**
 * @private
 */
Sequelize.Utils = Utils;

/**
 * Operators symbols to be used for querying data
 *
 * @see  {@link Operators}
 */
Sequelize.Op = Op;

/**
 * Available table hints to be used for querying data in mssql for table hints
 *
 * @see {@link TableHints}
 */
Sequelize.TableHints = TableHints;

/**
 * Available index hints to be used for querying data in mysql for index hints
 *
 * @see {@link IndexHints}
 */
Sequelize.IndexHints = IndexHints;

/**
 * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction
 *
 * @see {@link Transaction}
 * @see {@link Sequelize.transaction}
 */
Sequelize.Transaction = Transaction;

/**
 * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.
 *
 * @see {@link Sequelize}
 */
Sequelize.prototype.Sequelize = Sequelize;

/**
 * Available query types for use with `sequelize.query`
 *
 * @see {@link QueryTypes}
 */
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;

/**
 * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.
 *
 * @see https://github.com/chriso/validator.js
 */
Sequelize.prototype.Validator = Sequelize.Validator = Validator;

Sequelize.Model = Model;

Sequelize.DataTypes = DataTypes;
for (const dataType in DataTypes) {
  Sequelize[dataType] = DataTypes[dataType];
}

/**
 * A reference to the deferrable collection. Use this to access the different deferrable options.
 *
 * @see {@link Transaction.Deferrable}
 * @see {@link Sequelize#transaction}
 */
Sequelize.Deferrable = Deferrable;

/**
 * A reference to the sequelize association class.
 *
 * @see {@link Association}
 */
Sequelize.prototype.Association = Sequelize.Association = Association;

/**
 * Provide alternative version of `inflection` module to be used by `Utils.pluralize` etc.
 *
 * @param {object} _inflection - `inflection` module
 */
Sequelize.useInflection = Utils.useInflection;

/**
 * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models
 * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()
 */
Hooks.applyTo(Sequelize);
Hooks.applyTo(Sequelize.prototype);

/**
 * Expose various errors available
 */

// expose alias to BaseError
Sequelize.Error = sequelizeErrors.BaseError;

for (const error of Object.keys(sequelizeErrors)) {
  Sequelize[error] = sequelizeErrors[error];
}

module.exports = Sequelize;
module.exports.Sequelize = Sequelize;
module.exports.default = Sequelize;


/***/ }),

/***/ "./node_modules/sequelize/lib/sql-string.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/sql-string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const dataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

function arrayToList(array, timeZone, dialect, format) {
  return array.reduce((sql, val, i) => {
    if (i !== 0) {
      sql += ', ';
    }
    if (Array.isArray(val)) {
      sql += `(${arrayToList(val, timeZone, dialect, format)})`;
    } else {
      sql += escape(val, timeZone, dialect, format);
    }
    return sql;
  }, '');
}
exports.arrayToList = arrayToList;

function escape(val, timeZone, dialect, format) {
  let prependN = false;
  if (val === undefined || val === null) {
    return 'NULL';
  }
  switch (typeof val) {
    case 'boolean':
    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0
    // for us. Postgres actually has a boolean type with true/false literals,
    // but sequelize doesn't use it yet.
      if (dialect === 'sqlite' || dialect === 'mssql') {
        return +!!val;
      }
      return (!!val).toString();
    case 'number':
      return val.toString();
    case 'string':
    // In mssql, prepend N to all quoted vals which are originally a string (for
    // unicode compatibility)
      prependN = dialect === 'mssql';
      break;
  }

  if (val instanceof Date) {
    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });
  }

  if (Buffer.isBuffer(val)) {
    if (dataTypes[dialect].BLOB) {
      return dataTypes[dialect].BLOB.prototype.stringify(val);
    }

    return dataTypes.BLOB.prototype.stringify(val);
  }

  if (Array.isArray(val)) {
    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);
    if (dialect === 'postgres' && !format) {
      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });
    }
    return arrayToList(val, timeZone, dialect, format);
  }

  if (!val.replace) {
    throw new Error(`Invalid value ${logger.inspect(val)}`);
  }

  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {
    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS
    // http://stackoverflow.com/q/603572/130598
    val = val.replace(/'/g, "''");

    if (dialect === 'postgres') {
      // null character is not allowed in Postgres
      val = val.replace(/\0/g, '\\0');
    }
  } else {
    // eslint-disable-next-line no-control-regex
    val = val.replace(/[\0\n\r\b\t\\'"\x1a]/g, s => {
      switch (s) {
        case '\0': return '\\0';
        case '\n': return '\\n';
        case '\r': return '\\r';
        case '\b': return '\\b';
        case '\t': return '\\t';
        case '\x1a': return '\\Z';
        default: return `\\${s}`;
      }
    });
  }
  return `${(prependN ? "N'" : "'") + val}'`;
}
exports.escape = escape;

function format(sql, values, timeZone, dialect) {
  values = [].concat(values);

  if (typeof sql !== 'string') {
    throw new Error(`Invalid SQL string provided: ${sql}`);
  }

  return sql.replace(/\?/g, match => {
    if (!values.length) {
      return match;
    }

    return escape(values.shift(), timeZone, dialect, true);
  });
}
exports.format = format;

function formatNamedParameters(sql, values, timeZone, dialect) {
  return sql.replace(/:+(?!\d)(\w+)/g, (value, key) => {
    if ('postgres' === dialect && '::' === value.slice(0, 2)) {
      return value;
    }

    if (values[key] !== undefined) {
      return escape(values[key], timeZone, dialect, true);
    }
    throw new Error(`Named parameter "${value}" has no value in the given object.`);
  });
}
exports.formatNamedParameters = formatNamedParameters;


/***/ }),

/***/ "./node_modules/sequelize/lib/table-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/table-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of table hints to be used in mssql for querying with table hints
 *
 * @property NOLOCK
 * @property READUNCOMMITTED
 * @property UPDLOCK
 * @property REPEATABLEREAD
 * @property SERIALIZABLE
 * @property READCOMMITTED
 * @property TABLOCK
 * @property TABLOCKX
 * @property PAGLOCK
 * @property ROWLOCK
 * @property NOWAIT
 * @property READPAST
 * @property XLOCK
 * @property SNAPSHOT
 * @property NOEXPAND
 */
const TableHints = module.exports = { // eslint-disable-line
  NOLOCK: 'NOLOCK',
  READUNCOMMITTED: 'READUNCOMMITTED',
  UPDLOCK: 'UPDLOCK',
  REPEATABLEREAD: 'REPEATABLEREAD',
  SERIALIZABLE: 'SERIALIZABLE',
  READCOMMITTED: 'READCOMMITTED',
  TABLOCK: 'TABLOCK',
  TABLOCKX: 'TABLOCKX',
  PAGLOCK: 'PAGLOCK',
  ROWLOCK: 'ROWLOCK',
  NOWAIT: 'NOWAIT',
  READPAST: 'READPAST',
  XLOCK: 'XLOCK',
  SNAPSHOT: 'SNAPSHOT',
  NOEXPAND: 'NOEXPAND'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/transaction.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * The transaction object is used to identify a running transaction.
 * It is created by calling `Sequelize.transaction()`.
 * To run a query under a transaction, you should pass the transaction in the options object.
 *
 * @class Transaction
 * @see {@link Sequelize.transaction}
 */
class Transaction {
  /**
   * Creates a new transaction instance
   *
   * @param {Sequelize} sequelize A configured sequelize Instance
   * @param {object} options An object with options
   * @param {string} [options.type] Sets the type of the transaction. Sqlite only
   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.
   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only
   */
  constructor(sequelize, options) {
    this.sequelize = sequelize;
    this.savepoints = [];
    this._afterCommitHooks = [];

    // get dialect specific transaction options
    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;

    this.options = {
      type: sequelize.options.transactionType,
      isolationLevel: sequelize.options.isolationLevel,
      readOnly: false,
      ...options
    };

    this.parent = this.options.transaction;

    if (this.parent) {
      this.id = this.parent.id;
      this.parent.savepoints.push(this);
      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;
    } else {
      this.id = this.name = generateTransactionId();
    }

    delete this.options.transaction;
  }

  /**
   * Commit the transaction
   *
   * @returns {Promise}
   */
  async commit() {
    if (this.finished) {
      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);
    }

    try {
      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);
    } finally {
      this.finished = 'commit';
      this.cleanup();
      for (const hook of this._afterCommitHooks) {
        await hook.apply(this, [this]);
      }
    }
  }

  /**
   * Rollback (abort) the transaction
   *
   * @returns {Promise}
   */
  async rollback() {
    if (this.finished) {
      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);
    }

    if (!this.connection) {
      throw new Error('Transaction cannot be rolled back because it never started');
    }

    try {
      return await this
        .sequelize
        .getQueryInterface()
        .rollbackTransaction(this, this.options);
    } finally {
      this.cleanup();
    }
  }

  /**
   * Called to acquire a connection to use and set the correct options on the connection.
   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.
   *
   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.
   * @returns {Promise}
   */
  async prepareEnvironment(useCLS) {
    let connectionPromise;

    if (useCLS === undefined) {
      useCLS = true;
    }

    if (this.parent) {
      connectionPromise = Promise.resolve(this.parent.connection);
    } else {
      const acquireOptions = { uuid: this.id };
      if (this.options.readOnly) {
        acquireOptions.type = 'SELECT';
      }
      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);
    }

    let result;
    const connection = await connectionPromise;
    this.connection = connection;
    this.connection.uuid = this.id;

    try {
      await this.begin();
      result = await this.setDeferrable();
    } catch (setupErr) {
      try {
        result = await this.rollback();
      } finally {
        throw setupErr; // eslint-disable-line no-unsafe-finally
      }
    }

    if (useCLS && this.sequelize.constructor._cls) {
      this.sequelize.constructor._cls.set('transaction', this);
    }

    return result;
  }

  async setDeferrable() {
    if (this.options.deferrable) {
      return await this
        .sequelize
        .getQueryInterface()
        .deferConstraints(this, this.options);
    }
  }

  async begin() {
    const queryInterface = this.sequelize.getQueryInterface();

    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {
      await queryInterface.startTransaction(this, this.options);
      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);
    }

    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);

    return queryInterface.startTransaction(this, this.options);
  }

  cleanup() {
    // Don't release the connection if there's a parent transaction or
    // if we've already cleaned up
    if (this.parent || this.connection.uuid === undefined) return;

    this._clearCls();
    const res = this.sequelize.connectionManager.releaseConnection(this.connection);
    this.connection.uuid = undefined;
    return res;
  }

  _clearCls() {
    const cls = this.sequelize.constructor._cls;

    if (cls) {
      if (cls.get('transaction') === this) {
        cls.set('transaction', null);
      }
    }
  }

  /**
   * A hook that is run after a transaction is committed
   *
   * @param {Function} fn   A callback function that is called with the committed transaction
   * @name afterCommit
   * @memberof Sequelize.Transaction
   */
  afterCommit(fn) {
    if (!fn || typeof fn !== 'function') {
      throw new Error('"fn" must be a function');
    }
    this._afterCommitHooks.push(fn);
  }

  /**
   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.
   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.
   * Sqlite only.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {
   *      // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property DEFERRED
   * @property IMMEDIATE
   * @property EXCLUSIVE
   */
  static get TYPES() {
    return {
      DEFERRED: 'DEFERRED',
      IMMEDIATE: 'IMMEDIATE',
      EXCLUSIVE: 'EXCLUSIVE'
    };
  }

  /**
   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.
   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {
   *     // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property READ_UNCOMMITTED
   * @property READ_COMMITTED
   * @property REPEATABLE_READ
   * @property SERIALIZABLE
   */
  static get ISOLATION_LEVELS() {
    return {
      READ_UNCOMMITTED: 'READ UNCOMMITTED',
      READ_COMMITTED: 'READ COMMITTED',
      REPEATABLE_READ: 'REPEATABLE READ',
      SERIALIZABLE: 'SERIALIZABLE'
    };
  }


  /**
   * Possible options for row locking. Used in conjunction with `find` calls:
   *
   * @example
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: t1.LOCK...
   * });
   *
   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>
   * UserModel.findAll({
   *   where: ...,
   *   include: [TaskModel, ...],
   *   transaction: t1,
   *   lock: {
   *     level: t1.LOCK...,
   *     of: UserModel
   *   }
   * });
   *
   * # UserModel will be locked but TaskModel won't!
   *
   * @example <caption>You can also skip locked rows:</caption>
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: true,
   *   skipLocked: true
   * });
   * # The query will now return any rows that aren't locked by another transaction
   *
   * @returns {object}
   * @property UPDATE
   * @property SHARE
   * @property KEY_SHARE Postgres 9.3+ only
   * @property NO_KEY_UPDATE Postgres 9.3+ only
   */
  static get LOCK() {
    return {
      UPDATE: 'UPDATE',
      SHARE: 'SHARE',
      KEY_SHARE: 'KEY SHARE',
      NO_KEY_UPDATE: 'NO KEY UPDATE'
    };
  }

  /**
   * Please see {@link Transaction.LOCK}
   */
  get LOCK() {
    return Transaction.LOCK;
  }
}

module.exports = Transaction;
module.exports.Transaction = Transaction;
module.exports.default = Transaction;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const SqlString = __webpack_require__(/*! ./sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ "lodash/_baseIsNative");
const uuidv1 = __webpack_require__(/*! uuid */ "uuid").v1;
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;
const operators = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const operatorsSet = new Set(Object.values(operators));

let inflection = __webpack_require__(/*! inflection */ "./node_modules/inflection/lib/inflection.js");

exports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js").classToInvokable;
exports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js").joinSQLFragments;

function useInflection(_inflection) {
  inflection = _inflection;
}
exports.useInflection = useInflection;

function camelizeIf(str, condition) {
  let result = str;

  if (condition) {
    result = camelize(str);
  }

  return result;
}
exports.camelizeIf = camelizeIf;

function underscoredIf(str, condition) {
  let result = str;

  if (condition) {
    result = underscore(str);
  }

  return result;
}
exports.underscoredIf = underscoredIf;

function isPrimitive(val) {
  const type = typeof val;
  return type === 'string' || type === 'number' || type === 'boolean';
}
exports.isPrimitive = isPrimitive;

// Same concept as _.merge, but don't overwrite properties that have already been assigned
function mergeDefaults(a, b) {
  return _.mergeWith(a, b, (objectValue, sourceValue) => {
    // If it's an object, let _ handle it this time, we will be called again for each property
    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {
      // _.isNative includes a check for core-js and throws an error if present.
      // Depending on _baseIsNative bypasses the core-js check.
      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {
        return sourceValue || objectValue;
      }
      return objectValue;
    }
  });
}
exports.mergeDefaults = mergeDefaults;

// An alternative to _.merge, which doesn't clone its arguments
// Cloning is a bad idea because options arguments may contain references to sequelize
// models - which again reference database libs which don't like to be cloned (in particular pg-native)
function merge() {
  const result = {};

  for (const obj of arguments) {
    _.forOwn(obj, (value, key) => {
      if (value !== undefined) {
        if (!result[key]) {
          result[key] = value;
        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {
          result[key] = merge(result[key], value);
        } else if (Array.isArray(value) && Array.isArray(result[key])) {
          result[key] = value.concat(result[key]);
        } else {
          result[key] = value;
        }
      }
    });
  }

  return result;
}
exports.merge = merge;

function spliceStr(str, index, count, add) {
  return str.slice(0, index) + add + str.slice(index + count);
}
exports.spliceStr = spliceStr;

function camelize(str) {
  return str.trim().replace(/[-_\s]+(.)?/g, (match, c) => c.toUpperCase());
}
exports.camelize = camelize;

function underscore(str) {
  return inflection.underscore(str);
}
exports.underscore = underscore;

function singularize(str) {
  return inflection.singularize(str);
}
exports.singularize = singularize;

function pluralize(str) {
  return inflection.pluralize(str);
}
exports.pluralize = pluralize;

function format(arr, dialect) {
  const timeZone = null;
  // Make a clone of the array beacuse format modifies the passed args
  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);
}
exports.format = format;

function formatNamedParameters(sql, parameters, dialect) {
  const timeZone = null;
  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);
}
exports.formatNamedParameters = formatNamedParameters;

function cloneDeep(obj, onlyPlain) {
  obj = obj || {};
  return _.cloneDeepWith(obj, elem => {
    // Do not try to customize cloning of arrays or POJOs
    if (Array.isArray(elem) || _.isPlainObject(elem)) {
      return undefined;
    }

    // If we specified to clone only plain objects & arrays, we ignore everyhing else
    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances
    if (onlyPlain || typeof elem === 'object') {
      return elem;
    }

    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain
    if (elem && typeof elem.clone === 'function') {
      return elem.clone();
    }
  });
}
exports.cloneDeep = cloneDeep;

/* Expand and normalize finder options */
function mapFinderOptions(options, Model) {
  if (options.attributes && Array.isArray(options.attributes)) {
    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);
    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));
  }

  mapOptionFieldNames(options, Model);

  return options;
}
exports.mapFinderOptions = mapFinderOptions;

/* Used to map field names in attributes and where conditions */
function mapOptionFieldNames(options, Model) {
  if (Array.isArray(options.attributes)) {
    options.attributes = options.attributes.map(attr => {
      // Object lookups will force any variable to strings, we don't want that for special objects etc
      if (typeof attr !== 'string') return attr;
      // Map attributes to aliased syntax attributes
      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {
        return [Model.rawAttributes[attr].field, attr];
      }
      return attr;
    });
  }

  if (options.where && _.isPlainObject(options.where)) {
    options.where = mapWhereFieldNames(options.where, Model);
  }

  return options;
}
exports.mapOptionFieldNames = mapOptionFieldNames;

function mapWhereFieldNames(attributes, Model) {
  if (attributes) {
    getComplexKeys(attributes).forEach(attribute => {
      const rawAttribute = Model.rawAttributes[attribute];

      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {
        attributes[rawAttribute.field] = attributes[attribute];
        delete attributes[attribute];
      }

      if (_.isPlainObject(attributes[attribute])
        && !(rawAttribute && (
          rawAttribute.type instanceof DataTypes.HSTORE
          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields
        attributes[attribute] = mapOptionFieldNames({
          where: attributes[attribute]
        }, Model).where;
      }

      if (Array.isArray(attributes[attribute])) {
        attributes[attribute].forEach((where, index) => {
          if (_.isPlainObject(where)) {
            attributes[attribute][index] = mapWhereFieldNames(where, Model);
          }
        });
      }

    });
  }

  return attributes;
}
exports.mapWhereFieldNames = mapWhereFieldNames;

/* Used to map field names in values */
function mapValueFieldNames(dataValues, fields, Model) {
  const values = {};

  for (const attr of fields) {
    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {
      // Field name mapping
      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {
        values[Model.rawAttributes[attr].field] = dataValues[attr];
      } else {
        values[attr] = dataValues[attr];
      }
    }
  }

  return values;
}
exports.mapValueFieldNames = mapValueFieldNames;

function isColString(value) {
  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';
}
exports.isColString = isColString;

function canTreatArrayAsAnd(arr) {
  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);
}
exports.canTreatArrayAsAnd = canTreatArrayAsAnd;

function combineTableNames(tableName1, tableName2) {
  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;
}
exports.combineTableNames = combineTableNames;

function toDefaultValue(value, dialect) {
  if (typeof value === 'function') {
    const tmp = value();
    if (tmp instanceof DataTypes.ABSTRACT) {
      return tmp.toSql();
    }
    return tmp;
  }
  if (value instanceof DataTypes.UUIDV1) {
    return uuidv1();
  }
  if (value instanceof DataTypes.UUIDV4) {
    return uuidv4();
  }
  if (value instanceof DataTypes.NOW) {
    return now(dialect);
  }
  if (Array.isArray(value)) {
    return value.slice();
  }
  if (_.isPlainObject(value)) {
    return { ...value };
  }
  return value;
}
exports.toDefaultValue = toDefaultValue;

/**
 * Determine if the default value provided exists and can be described
 * in a db schema using the DEFAULT directive.
 *
 * @param  {*} value Any default value.
 * @returns {boolean} yes / no.
 * @private
 */
function defaultValueSchemable(value) {
  if (value === undefined) { return false; }

  // TODO this will be schemable when all supported db
  // have been normalized for this case
  if (value instanceof DataTypes.NOW) { return false; }

  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }

  return typeof value !== 'function';
}
exports.defaultValueSchemable = defaultValueSchemable;

function removeNullValuesFromHash(hash, omitNull, options) {
  let result = hash;

  options = options || {};
  options.allowNull = options.allowNull || [];

  if (omitNull) {
    const _hash = {};

    _.forIn(hash, (val, key) => {
      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {
        _hash[key] = val;
      }
    });

    result = _hash;
  }

  return result;
}
exports.removeNullValuesFromHash = removeNullValuesFromHash;

const dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);

function now(dialect) {
  const d = new Date();
  if (!dialects.has(dialect)) {
    d.setMilliseconds(0);
  }
  return d;
}
exports.now = now;

// Note: Use the `quoteIdentifier()` and `escape()` methods on the
// `QueryInterface` instead for more portable code.

const TICK_CHAR = '`';
exports.TICK_CHAR = TICK_CHAR;

function addTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return tickChar + removeTicks(s, tickChar) + tickChar;
}
exports.addTicks = addTicks;

function removeTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return s.replace(new RegExp(tickChar, 'g'), '');
}
exports.removeTicks = removeTicks;

/**
 * Receives a tree-like object and returns a plain object which depth is 1.
 *
 * - Input:
 *
 *  {
 *    name: 'John',
 *    address: {
 *      street: 'Fake St. 123',
 *      coordinates: {
 *        longitude: 55.6779627,
 *        latitude: 12.5964313
 *      }
 *    }
 *  }
 *
 * - Output:
 *
 *  {
 *    name: 'John',
 *    address.street: 'Fake St. 123',
 *    address.coordinates.latitude: 55.6779627,
 *    address.coordinates.longitude: 12.5964313
 *  }
 *
 * @param {object} value an Object
 * @returns {object} a flattened object
 * @private
 */
function flattenObjectDeep(value) {
  if (!_.isPlainObject(value)) return value;
  const flattenedObj = {};

  function flattenObject(obj, subPath) {
    Object.keys(obj).forEach(key => {
      const pathToProperty = subPath ? `${subPath}.${key}` : key;
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        flattenObject(obj[key], pathToProperty);
      } else {
        flattenedObj[pathToProperty] = _.get(obj, key);
      }
    });
    return flattenedObj;
  }

  return flattenObject(value, undefined);
}
exports.flattenObjectDeep = flattenObjectDeep;

/**
 * Utility functions for representing SQL functions, and columns that should be escaped.
 * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.
 *
 * @private
 */
class SequelizeMethod {}
exports.SequelizeMethod = SequelizeMethod;

class Fn extends SequelizeMethod {
  constructor(fn, args) {
    super();
    this.fn = fn;
    this.args = args;
  }
  clone() {
    return new Fn(this.fn, this.args);
  }
}
exports.Fn = Fn;

class Col extends SequelizeMethod {
  constructor(col, ...args) {
    super();
    if (args.length > 0) {
      col = args;
    }
    this.col = col;
  }
}
exports.Col = Col;

class Cast extends SequelizeMethod {
  constructor(val, type, json) {
    super();
    this.val = val;
    this.type = (type || '').trim();
    this.json = json || false;
  }
}
exports.Cast = Cast;

class Literal extends SequelizeMethod {
  constructor(val) {
    super();
    this.val = val;
  }
}
exports.Literal = Literal;

class Json extends SequelizeMethod {
  constructor(conditionsOrPath, value) {
    super();
    if (_.isObject(conditionsOrPath)) {
      this.conditions = conditionsOrPath;
    } else {
      this.path = conditionsOrPath;
      if (value) {
        this.value = value;
      }
    }
  }
}
exports.Json = Json;

class Where extends SequelizeMethod {
  constructor(attribute, comparator, logic) {
    super();
    if (logic === undefined) {
      logic = comparator;
      comparator = '=';
    }

    this.attribute = attribute;
    this.comparator = comparator;
    this.logic = logic;
  }
}
exports.Where = Where;

//Collection of helper methods to make it easier to work with symbol operators

/**
 * getOperators
 *
 * @param  {object} obj
 * @returns {Array<symbol>} All operators properties of obj
 * @private
 */
function getOperators(obj) {
  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));
}
exports.getOperators = getOperators;

/**
 * getComplexKeys
 *
 * @param  {object} obj
 * @returns {Array<string|symbol>} All keys including operators
 * @private
 */
function getComplexKeys(obj) {
  return getOperators(obj).concat(Object.keys(obj));
}
exports.getComplexKeys = getComplexKeys;

/**
 * getComplexSize
 *
 * @param  {object|Array} obj
 * @returns {number}      Length of object properties including operators if obj is array returns its length
 * @private
 */
function getComplexSize(obj) {
  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;
}
exports.getComplexSize = getComplexSize;

/**
 * Returns true if a where clause is empty, even with Symbols
 *
 * @param  {object} obj
 * @returns {boolean}
 * @private
 */
function isWhereEmpty(obj) {
  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;
}
exports.isWhereEmpty = isWhereEmpty;

/**
 * Returns ENUM name by joining table and column name
 *
 * @param {string} tableName
 * @param {string} columnName
 * @returns {string}
 * @private
 */
function generateEnumName(tableName, columnName) {
  return `enum_${tableName}_${columnName}`;
}
exports.generateEnumName = generateEnumName;

/**
 * Returns an new Object which keys are camelized
 *
 * @param {object} obj
 * @returns {string}
 * @private
 */
function camelizeObjectKeys(obj) {
  const newObj = new Object();
  Object.keys(obj).forEach(key => {
    newObj[camelize(key)] = obj[key];
  });
  return newObj;
}
exports.camelizeObjectKeys = camelizeObjectKeys;

/**
 * Assigns own and inherited enumerable string and symbol keyed properties of source
 * objects to the destination object.
 *
 * https://lodash.com/docs/4.17.4#defaults
 *
 * **Note:** This method mutates `object`.
 *
 * @param {object} object The destination object.
 * @param {...object} [sources] The source objects.
 * @returns {object} Returns `object`.
 * @private
 */
function defaults(object, ...sources) {
  object = Object(object);

  sources.forEach(source => {
    if (source) {
      source = Object(source);

      getComplexKeys(source).forEach(key => {
        const value = object[key];
        if (
          value === undefined ||
            _.eq(value, Object.prototype[key]) &&
            !Object.prototype.hasOwnProperty.call(object, key)

        ) {
          object[key] = source[key];
        }
      });
    }
  });

  return object;
}
exports.defaults = defaults;

/**
 *
 * @param {object} index
 * @param {Array}  index.fields
 * @param {string} [index.name]
 * @param {string|object} tableName
 *
 * @returns {object}
 * @private
 */
function nameIndex(index, tableName) {
  if (tableName.tableName) tableName = tableName.tableName;

  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {
    const fields = index.fields.map(
      field => typeof field === 'string' ? field : field.name || field.attribute
    );
    index.name = underscore(`${tableName}_${fields.join('_')}`);
  }

  return index;
}
exports.nameIndex = nameIndex;

/**
 * Checks if 2 arrays intersect.
 *
 * @param {Array} arr1
 * @param {Array} arr2
 * @private
 */
function intersects(arr1, arr2) {
  return arr1.some(v => arr2.includes(v));
}
exports.intersects = intersects;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Wraps a constructor to not need the `new` keyword using a proxy.
 * Only used for data types.
 *
 * @param {Function} Class The class instance to wrap as invocable.
 * @returns {Proxy} Wrapped class instance.
 * @private
 */
function classToInvokable(Class) {
  return new Proxy(Class, {
    apply(Target, thisArg, args) {
      return new Target(...args);
    },
    construct(Target, args) {
      return new Target(...args);
    },
    get(target, p) {
      return target[p];
    }
  });
}
exports.classToInvokable = classToInvokable;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/deprecations.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/deprecations.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const { deprecate } = __webpack_require__(/*! util */ "util");

const noop = () => {};

exports.noRawAttributes = deprecate(noop, 'Use sequelize.fn / sequelize.literal to construct attributes', 'SEQUELIZE0001');
exports.noTrueLogging = deprecate(noop, 'The logging-option should be either a function or false. Default: console.log', 'SEQUELIZE0002');
exports.noStringOperators = deprecate(noop, 'String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators', 'SEQUELIZE0003');
exports.noBoolOperatorAliases = deprecate(noop, 'A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.', 'SEQUELIZE0004');
exports.noDoubleNestedGroup = deprecate(noop, 'Passing a double nested nested array to `group` is unsupported and will be removed in v6.', 'SEQUELIZE0005');
exports.unsupportedEngine = deprecate(noop, 'This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md', 'SEQUELIZE0006');


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function doesNotWantLeadingSpace(str) {
  return /^[;,)]/.test(str);
}
function doesNotWantTrailingSpace(str) {
  return /\($/.test(str);
}

/**
 * Joins an array of strings with a single space between them,
 * except for:
 * 
 * - Strings starting with ';', ',' and ')', which do not get a leading space.
 * - Strings ending with '(', which do not get a trailing space.
 * 
 * @param {string[]} parts
 * @returns {string}
 * @private
 */
function singleSpaceJoinHelper(parts) {
  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {
    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {
      result += part.trim();
    } else {
      result += ` ${part.trim()}`;
    }
    return {
      skipNextLeadingSpace: doesNotWantTrailingSpace(part),
      result
    };
  }, {
    skipNextLeadingSpace: true,
    result: ''
  }).result;
}

/**
 * Joins an array with a single space, auto trimming when needed.
 * 
 * Certain elements do not get leading/trailing spaces.
 * 
 * @param {any[]} array The array to be joined. Falsy values are skipped. If an
 * element is another array, this function will be called recursively on that array.
 * Otherwise, if a non-string, non-falsy value is present, a TypeError will be thrown.
 * 
 * @returns {string} The joined string.
 * 
 * @private
 */
function joinSQLFragments(array) {
  if (array.length === 0) return '';

  // Skip falsy fragments
  array = array.filter(x => x);

  // Resolve recursive calls
  array = array.map(fragment => {
    if (Array.isArray(fragment)) {
      return joinSQLFragments(fragment);
    }
    return fragment;
  });

  // Ensure strings
  for (const fragment of array) {
    if (fragment && typeof fragment !== 'string') {
      const error = new TypeError(`Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);
      error.args = array;
      error.fragment = fragment;
      throw error;
    }
  }

  // Trim fragments
  array = array.map(x => x.trim());

  // Skip full-whitespace fragments (empty after the above trim)
  array = array.filter(x => x !== '');

  return singleSpaceJoinHelper(array);
}
exports.joinSQLFragments = joinSQLFragments;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/logger.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Sequelize module for debug and deprecation messages.
 * It require a `context` for which messages will be printed.
 *
 * @module logging
 * @private
 */

const debug = __webpack_require__(/*! debug */ "debug");
const util = __webpack_require__(/*! util */ "util");

class Logger {
  constructor(config) {

    this.config = {
      context: 'sequelize',
      debug: true,
      ...config
    };
  }

  warn(message) {
    // eslint-disable-next-line no-console
    console.warn(`(${this.config.context}) Warning: ${message}`);
  }

  inspect(value) {
    return util.inspect(value, false, 3);
  }

  debugContext(name) {
    return debug(`${this.config.context}:${name}`);
  }
}

exports.logger = new Logger();

exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/validator-extras.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/validator-extras.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const validator = _.cloneDeep(__webpack_require__(/*! validator */ "./node_modules/validator/index.js"));
const moment = __webpack_require__(/*! moment */ "moment");

const extensions = {
  extend(name, fn) {
    this[name] = fn;

    return this;
  },
  notEmpty(str) {
    return !str.match(/^[\s\t\r\n]*$/);
  },
  len(str, min, max) {
    return this.isLength(str, min, max);
  },
  isUrl(str) {
    return this.isURL(str);
  },
  isIPv6(str) {
    return this.isIP(str, 6);
  },
  isIPv4(str) {
    return this.isIP(str, 4);
  },
  notIn(str, values) {
    return !this.isIn(str, values);
  },
  regex(str, pattern, modifiers) {
    str += '';
    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {
      pattern = new RegExp(pattern, modifiers);
    }
    return str.match(pattern);
  },
  notRegex(str, pattern, modifiers) {
    return !this.regex(str, pattern, modifiers);
  },
  isDecimal(str) {
    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);
  },
  min(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number >= val;
  },
  max(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number <= val;
  },
  not(str, pattern, modifiers) {
    return this.notRegex(str, pattern, modifiers);
  },
  contains(str, elem) {
    return !!elem && str.includes(elem);
  },
  notContains(str, elem) {
    return !this.contains(str, elem);
  },
  is(str, pattern, modifiers) {
    return this.regex(str, pattern, modifiers);
  }
};
exports.extensions = extensions;

// instance based validators
validator.isImmutable = function(value, validatorArgs, field, modelInstance) {
  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];
};

// extra validators
validator.notNull = function(val) {
  return val !== null && val !== undefined;
};

// https://github.com/chriso/validator.js/blob/6.2.0/validator.js
_.forEach(extensions, (extend, key) => {
  validator[key] = extend;
});

// map isNull to isEmpty
// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125
validator.isNull = validator.isEmpty;

// isDate removed in 7.0.0
// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9
validator.isDate = function(dateString) {
  // avoid http://momentjs.com/guides/#/warnings/js-date/
  // by doing a preliminary check on `dateString`
  const parsed = Date.parse(dateString);
  if (isNaN(parsed)) {
    // fail if we can't parse it
    return false;
  }
  // otherwise convert to ISO 8601 as moment prefers
  // http://momentjs.com/docs/#/parsing/string/
  const date = new Date(parsed);
  return moment(date.toISOString()).isValid();
};

exports.validator = validator;


/***/ }),

/***/ "./node_modules/sequelize/package.json":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"sequelize","description":"Multi dialect ORM for Node.JS","version":"6.6.2","maintainers":["Sascha Depold <sascha@depold.com>","Jan Aagaard Meier <janzeh@gmail.com>","Daniel Durante <me@danieldurante.com>","Mick Hansen <mick.kasper.hansen@gmail.com>","Sushant Dhiman <sushantdhiman@outlook.com>","Pedro Augusto de Paula Barbosa <papb1996@gmail.com>"],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"index.js","types":"types","engines":{"node":">=10.0.0"},"files":["lib","types/index.d.ts","types/lib","types/type-helpers"],"license":"MIT","dependencies":{"debug":"^4.1.1","dottie":"^2.0.0","inflection":"1.12.0","lodash":"^4.17.20","moment":"^2.26.0","moment-timezone":"^0.5.31","retry-as-promised":"^3.2.0","semver":"^7.3.2","sequelize-pool":"^6.0.0","toposort-class":"^1.0.1","uuid":"^8.1.0","validator":"^10.11.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^11.0.0","@commitlint/config-angular":"^11.0.0","@types/node":"^12.12.42","@types/validator":"^10.11.0","acorn":"^8.0.4","chai":"^4.x","chai-as-promised":"^7.x","chai-datetime":"^1.6.0","cheerio":"^1.0.0-rc.3","cls-hooked":"^4.2.2","cross-env":"^7.0.2","delay":"^4.3.0","env-cmd":"^10.1.0","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^6.8.0","eslint-plugin-jsdoc":"^20.4.0","eslint-plugin-mocha":"^6.2.2","expect-type":"^0.11.0","fs-jetpack":"^4.1.0","husky":"^4.2.5","js-combinatorics":"^0.5.5","lcov-result-merger":"^3.0.0","lint-staged":"^10.2.6","mariadb":"^2.3.1","markdownlint-cli":"^0.26.0","marked":"^1.1.0","mocha":"^7.1.2","mysql2":"^2.1.0","nyc":"^15.0.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.2.1","pg-hstore":"^2.x","rimraf":"^3.0.2","semantic-release":"^17.3.0","sinon":"^9.0.2","sinon-chai":"^3.3.0","sqlite3":"^4.2.0","tedious":"8.3.0","typescript":"^4.1.3"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","mssql","orm","nodejs","object relational mapper"],"options":{"env_cmd":"-f ./test/config/.docker.env"},"commitlint":{"extends":["@commitlint/config-angular"]},"lint-staged":{"*.js":"eslint"},"husky":{"hooks":{"pre-commit":"lint-staged","commit-msg":"commitlint -E HUSKY_GIT_PARAMS"}},"release":{"branches":["v6"],"verifyConditions":["@semantic-release/npm","@semantic-release/github"]},"publishConfig":{"tag":"latest"},"scripts":{"lint":"eslint lib test --quiet","lint-docs":"markdownlint docs","test":"npm run teaser && npm run test-unit && npm run test-integration","test-docker":"npm run test-docker-unit && npm run test-docker-integration","test-docker-unit":"npm run test-unit","test-docker-integration":"env-cmd $npm_package_options_env_cmd npm run test-integration","docs":"rimraf esdoc && esdoc -c docs/esdoc-config.js && cp docs/favicon.ico esdoc/favicon.ico && cp docs/ROUTER.txt esdoc/ROUTER && node docs/run-docs-transforms.js && node docs/redirects/create-redirects.js && rimraf esdoc/file esdoc/source.html","teaser":"node scripts/teaser","test-unit":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/unit/**/*.js\\"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite","test-integration":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/integration/**/*.test.js\\"","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-all":"npm run test-integration-mariadb && npm run test-integration-mysql && npm run test-integration-postgres && npm run test-integration-postgres-native && npm run test-integration-mssql && npm run test-integration-sqlite","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-pgsql":"npm run test-postgres","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-postgresn":"npm run test-postgres-native","test-mssql":"cross-env DIALECT=mssql npm test","test-all":"npm run test-mariadb && npm run test-mysql && npm run test-sqlite && npm run test-postgres && npm run test-postgres-native && npm run test-mssql","test-typings":"tsc -b types/tsconfig.json && tsc -b types/test/tsconfig.json","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/integration/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/unit/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","sscce":"env-cmd $npm_package_options_env_cmd node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb npm run sscce","sscce-mysql":"cross-env DIALECT=mysql npm run sscce","sscce-postgres":"cross-env DIALECT=postgres npm run sscce","sscce-sqlite":"cross-env DIALECT=sqlite npm run sscce","sscce-mssql":"cross-env DIALECT=mssql npm run sscce","setup-mssql":"env-cmd $npm_package_options_env_cmd ./scripts/setup-mssql","semantic-release":"semantic-release"}}');

/***/ }),

/***/ "./node_modules/toposort-class/build/toposort.js":
/*!*******************************************************!*\
  !*** ./node_modules/toposort-class/build/toposort.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Gustavo Henke and Aaron Trent
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ****/
(function( global, factory ) {
    if( true ) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var mod; }
})( this, function( exports, module ) {
    "use strict";

    function _classCallCheck( instance, Constructor ) {
        if( !(instance instanceof Constructor) ) {
            throw new TypeError( "Cannot call a class as a function" );
        }
    }

    var Toposort = (function() {
        function Toposort() {
            _classCallCheck( this, Toposort );

            this.edges = [];
            this.Toposort = Toposort;
        }

        /**
         * Adds dependency edges.
         *
         * @since   0.1.0
         * @param   {String} item               An dependent name. Must be an string and not empty
         * @param   {String[]|String} [deps]    An dependency or array of dependencies
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.add = function add( item, deps ) {
            if( typeof item !== "string" || !item ) {
                throw new TypeError( "Dependent name must be given as a not empty string" );
            }

            deps = Array.isArray( deps ) ? deps : [deps];

            if( deps.length > 0 ) {
                for( var _iterator = deps, _isArray = Array.isArray( _iterator ), _i = 0, _iterator = _isArray ?
                                                                                                      _iterator :
                                                                                                      _iterator[Symbol.iterator](); ; ) {
                    var _ref;

                    if( _isArray ) {
                        if( _i >= _iterator.length ) {
                            break;
                        }
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if( _i.done ) {
                            break;
                        }
                        _ref = _i.value;
                    }

                    var dep = _ref;

                    if( typeof dep !== "string" || !dep ) {
                        throw new TypeError( "Dependency name must be given as a not empty string" );
                    }

                    this.edges.push( [item, dep] );
                }
            } else {
                this.edges.push( [item] );
            }

            return this;
        };

        /**
         * Runs the toposorting and return an ordered array of strings
         *
         * @since   0.1.0
         * @returns {String[]}  The list of items topologically sorted.
         */

        Toposort.prototype.sort = function sort() {
            var _this = this;

            var nodes = [];

            //accumulate unique nodes into a large list
            for( var _iterator2 = this.edges, _isArray2 = Array.isArray( _iterator2 ), _i2 = 0, _iterator2 = _isArray2 ?
                                                                                                             _iterator2 :
                                                                                                             _iterator2[Symbol.iterator](); ; ) {
                var _ref2;

                if( _isArray2 ) {
                    if( _i2 >= _iterator2.length ) {
                        break;
                    }
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if( _i2.done ) {
                        break;
                    }
                    _ref2 = _i2.value;
                }

                var edge = _ref2;

                for( var _iterator3 = edge, _isArray3 = Array.isArray( _iterator3 ), _i3 = 0, _iterator3 = _isArray3 ?
                                                                                                           _iterator3 :
                                                                                                           _iterator3[Symbol.iterator](); ; ) {
                    var _ref3;

                    if( _isArray3 ) {
                        if( _i3 >= _iterator3.length ) {
                            break;
                        }
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if( _i3.done ) {
                            break;
                        }
                        _ref3 = _i3.value;
                    }

                    var node = _ref3;

                    if( nodes.indexOf( node ) === -1 ) {
                        nodes.push( node );
                    }
                }
            }

            //initialize the placement of nodes into the sorted array at the end
            var place = nodes.length;

            //initialize the sorted array with the same length as the unique nodes array
            var sorted = new Array( nodes.length );

            //define a visitor function that recursively traverses dependencies.
            var visit = function visit( node, predecessors ) {
                //check if a node is dependent of itself
                if( predecessors.length !== 0 && predecessors.indexOf( node ) !== -1 ) {
                    throw new Error( "Cyclic dependency found. " + node + " is dependent of itself.\nDependency chain: "
                                     + predecessors.join( " -> " ) + " => " + node );
                }

                var index = nodes.indexOf( node );

                //if the node still exists, traverse its dependencies
                if( index !== -1 ) {
                    var copy = false;

                    //mark the node as false to exclude it from future iterations
                    nodes[index] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator4 = _this.edges, _isArray4 = Array.isArray( _iterator4 ), _i4 = 0, _iterator4 = _isArray4 ?
                                                                                                                      _iterator4 :
                                                                                                                      _iterator4[Symbol.iterator](); ; ) {
                        var _ref4;

                        if( _isArray4 ) {
                            if( _i4 >= _iterator4.length ) {
                                break;
                            }
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if( _i4.done ) {
                                break;
                            }
                            _ref4 = _i4.value;
                        }

                        var edge = _ref4;

                        if( edge[0] === node ) {
                            //lazily create a copy of predecessors with the current node concatenated onto it
                            copy = copy || predecessors.concat( [node] );

                            //recurse to node dependencies
                            visit( edge[1], copy );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            };

            for( var i = 0; i < nodes.length; i++ ) {
                var node = nodes[i];

                //ignore nodes that have been excluded
                if( node !== false ) {
                    //mark the node as false to exclude it from future iterations
                    nodes[i] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator5 = this.edges, _isArray5 = Array.isArray( _iterator5 ), _i5 = 0, _iterator5 = _isArray5 ?
                                                                                                                     _iterator5 :
                                                                                                                     _iterator5[Symbol.iterator](); ; ) {
                        var _ref5;

                        if( _isArray5 ) {
                            if( _i5 >= _iterator5.length ) {
                                break;
                            }
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if( _i5.done ) {
                                break;
                            }
                            _ref5 = _i5.value;
                        }

                        var edge = _ref5;

                        if( edge[0] === node ) {
                            //recurse to node dependencies
                            visit( edge[1], [node] );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            }

            return sorted;
        };

        /**
         * Clears edges
         *
         * @since   0.4.0
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.clear = function clear() {
            this.edges = [];

            return this;
        };

        return Toposort;
    })();

    module.exports = Toposort;
} );


/***/ }),

/***/ "./node_modules/toposort-class/index.js":
/*!**********************************************!*\
  !*** ./node_modules/toposort-class/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./build/toposort.js */ "./node_modules/toposort-class/build/toposort.js");


/***/ }),

/***/ "./src/configs/sequalize.ts":
/*!**********************************!*\
  !*** ./src/configs/sequalize.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = exports.sequelize = void 0;
var sequelize_typescript_1 = __webpack_require__(/*! sequelize-typescript */ "./node_modules/sequelize-typescript/dist/index.js");
var init = function () { return __awaiter(void 0, void 0, void 0, function () {
    var e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                exports.sequelize = new sequelize_typescript_1.Sequelize({
                    models: [__dirname + '/database/models/**/*.model.ts'],
                    modelMatch: function (filename, member) {
                        return filename.substring(0, filename.indexOf('.model')) === member.toLowerCase();
                    },
                    host: "localhost",
                    database: 'default',
                    dialect: 'mysql',
                    username: 'root',
                    password: ''
                });
                return [4, exports.sequelize.authenticate()];
            case 1:
                _a.sent();
                console.log("DB Connected");
                return [3, 3];
            case 2:
                e_1 = _a.sent();
                console.error("Unable to connect to DB", e_1);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
exports.init = init;


/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var index_1 = __importDefault(__webpack_require__(/*! ./typeDefs/index */ "./src/typeDefs/index.ts"));
var index_2 = __importDefault(__webpack_require__(/*! ./resolvers/index */ "./src/resolvers/index.ts"));
var sequalize_1 = __webpack_require__(/*! ./configs/sequalize */ "./src/configs/sequalize.ts");
var server = new apollo_server_1.ApolloServer({ typeDefs: index_1.default, resolvers: index_2.default });
sequalize_1.init();
server.listen()
    .then(function (_a) {
    var url = _a.url;
    return console.log("Server ready at " + url + ". ");
});


/***/ }),

/***/ "./node_modules/validator/index.js":
/*!*****************************************!*\
  !*** ./node_modules/validator/index.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./lib/toDate */ "./node_modules/validator/lib/toDate.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./lib/toFloat */ "./node_modules/validator/lib/toFloat.js"));

var _toInt = _interopRequireDefault(__webpack_require__(/*! ./lib/toInt */ "./node_modules/validator/lib/toInt.js"));

var _toBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/toBoolean */ "./node_modules/validator/lib/toBoolean.js"));

var _equals = _interopRequireDefault(__webpack_require__(/*! ./lib/equals */ "./node_modules/validator/lib/equals.js"));

var _contains = _interopRequireDefault(__webpack_require__(/*! ./lib/contains */ "./node_modules/validator/lib/contains.js"));

var _matches = _interopRequireDefault(__webpack_require__(/*! ./lib/matches */ "./node_modules/validator/lib/matches.js"));

var _isEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmail */ "./node_modules/validator/lib/isEmail.js"));

var _isURL = _interopRequireDefault(__webpack_require__(/*! ./lib/isURL */ "./node_modules/validator/lib/isURL.js"));

var _isMACAddress = _interopRequireDefault(__webpack_require__(/*! ./lib/isMACAddress */ "./node_modules/validator/lib/isMACAddress.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./lib/isIP */ "./node_modules/validator/lib/isIP.js"));

var _isIPRange = _interopRequireDefault(__webpack_require__(/*! ./lib/isIPRange */ "./node_modules/validator/lib/isIPRange.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./lib/isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/isBoolean */ "./node_modules/validator/lib/isBoolean.js"));

var _isAlpha = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlpha */ "./node_modules/validator/lib/isAlpha.js"));

var _isAlphanumeric = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlphanumeric */ "./node_modules/validator/lib/isAlphanumeric.js"));

var _isNumeric = _interopRequireDefault(__webpack_require__(/*! ./lib/isNumeric */ "./node_modules/validator/lib/isNumeric.js"));

var _isPort = _interopRequireDefault(__webpack_require__(/*! ./lib/isPort */ "./node_modules/validator/lib/isPort.js"));

var _isLowercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isLowercase */ "./node_modules/validator/lib/isLowercase.js"));

var _isUppercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isUppercase */ "./node_modules/validator/lib/isUppercase.js"));

var _isAscii = _interopRequireDefault(__webpack_require__(/*! ./lib/isAscii */ "./node_modules/validator/lib/isAscii.js"));

var _isFullWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isFullWidth */ "./node_modules/validator/lib/isFullWidth.js"));

var _isHalfWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js"));

var _isVariableWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isVariableWidth */ "./node_modules/validator/lib/isVariableWidth.js"));

var _isMultibyte = _interopRequireDefault(__webpack_require__(/*! ./lib/isMultibyte */ "./node_modules/validator/lib/isMultibyte.js"));

var _isSurrogatePair = _interopRequireDefault(__webpack_require__(/*! ./lib/isSurrogatePair */ "./node_modules/validator/lib/isSurrogatePair.js"));

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./lib/isInt */ "./node_modules/validator/lib/isInt.js"));

var _isFloat = _interopRequireWildcard(__webpack_require__(/*! ./lib/isFloat */ "./node_modules/validator/lib/isFloat.js"));

var _isDecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isDecimal */ "./node_modules/validator/lib/isDecimal.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

var _isDivisibleBy = _interopRequireDefault(__webpack_require__(/*! ./lib/isDivisibleBy */ "./node_modules/validator/lib/isDivisibleBy.js"));

var _isHexColor = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexColor */ "./node_modules/validator/lib/isHexColor.js"));

var _isISRC = _interopRequireDefault(__webpack_require__(/*! ./lib/isISRC */ "./node_modules/validator/lib/isISRC.js"));

var _isMD = _interopRequireDefault(__webpack_require__(/*! ./lib/isMD5 */ "./node_modules/validator/lib/isMD5.js"));

var _isHash = _interopRequireDefault(__webpack_require__(/*! ./lib/isHash */ "./node_modules/validator/lib/isHash.js"));

var _isJWT = _interopRequireDefault(__webpack_require__(/*! ./lib/isJWT */ "./node_modules/validator/lib/isJWT.js"));

var _isJSON = _interopRequireDefault(__webpack_require__(/*! ./lib/isJSON */ "./node_modules/validator/lib/isJSON.js"));

var _isEmpty = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmpty */ "./node_modules/validator/lib/isEmpty.js"));

var _isLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isLength */ "./node_modules/validator/lib/isLength.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isUUID = _interopRequireDefault(__webpack_require__(/*! ./lib/isUUID */ "./node_modules/validator/lib/isUUID.js"));

var _isMongoId = _interopRequireDefault(__webpack_require__(/*! ./lib/isMongoId */ "./node_modules/validator/lib/isMongoId.js"));

var _isAfter = _interopRequireDefault(__webpack_require__(/*! ./lib/isAfter */ "./node_modules/validator/lib/isAfter.js"));

var _isBefore = _interopRequireDefault(__webpack_require__(/*! ./lib/isBefore */ "./node_modules/validator/lib/isBefore.js"));

var _isIn = _interopRequireDefault(__webpack_require__(/*! ./lib/isIn */ "./node_modules/validator/lib/isIn.js"));

var _isCreditCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isCreditCard */ "./node_modules/validator/lib/isCreditCard.js"));

var _isIdentityCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isIdentityCard */ "./node_modules/validator/lib/isIdentityCard.js"));

var _isISIN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISIN */ "./node_modules/validator/lib/isISIN.js"));

var _isISBN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISBN */ "./node_modules/validator/lib/isISBN.js"));

var _isISSN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISSN */ "./node_modules/validator/lib/isISSN.js"));

var _isMobilePhone = _interopRequireWildcard(__webpack_require__(/*! ./lib/isMobilePhone */ "./node_modules/validator/lib/isMobilePhone.js"));

var _isCurrency = _interopRequireDefault(__webpack_require__(/*! ./lib/isCurrency */ "./node_modules/validator/lib/isCurrency.js"));

var _isISO = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO8601 */ "./node_modules/validator/lib/isISO8601.js"));

var _isRFC = _interopRequireDefault(__webpack_require__(/*! ./lib/isRFC3339 */ "./node_modules/validator/lib/isRFC3339.js"));

var _isISO31661Alpha = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha2 */ "./node_modules/validator/lib/isISO31661Alpha2.js"));

var _isISO31661Alpha2 = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha3 */ "./node_modules/validator/lib/isISO31661Alpha3.js"));

var _isBase = _interopRequireDefault(__webpack_require__(/*! ./lib/isBase64 */ "./node_modules/validator/lib/isBase64.js"));

var _isDataURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isDataURI */ "./node_modules/validator/lib/isDataURI.js"));

var _isMagnetURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isMagnetURI */ "./node_modules/validator/lib/isMagnetURI.js"));

var _isMimeType = _interopRequireDefault(__webpack_require__(/*! ./lib/isMimeType */ "./node_modules/validator/lib/isMimeType.js"));

var _isLatLong = _interopRequireDefault(__webpack_require__(/*! ./lib/isLatLong */ "./node_modules/validator/lib/isLatLong.js"));

var _isPostalCode = _interopRequireWildcard(__webpack_require__(/*! ./lib/isPostalCode */ "./node_modules/validator/lib/isPostalCode.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./lib/ltrim */ "./node_modules/validator/lib/ltrim.js"));

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./lib/rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _trim = _interopRequireDefault(__webpack_require__(/*! ./lib/trim */ "./node_modules/validator/lib/trim.js"));

var _escape = _interopRequireDefault(__webpack_require__(/*! ./lib/escape */ "./node_modules/validator/lib/escape.js"));

var _unescape = _interopRequireDefault(__webpack_require__(/*! ./lib/unescape */ "./node_modules/validator/lib/unescape.js"));

var _stripLow = _interopRequireDefault(__webpack_require__(/*! ./lib/stripLow */ "./node_modules/validator/lib/stripLow.js"));

var _whitelist = _interopRequireDefault(__webpack_require__(/*! ./lib/whitelist */ "./node_modules/validator/lib/whitelist.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./lib/blacklist */ "./node_modules/validator/lib/blacklist.js"));

var _isWhitelisted = _interopRequireDefault(__webpack_require__(/*! ./lib/isWhitelisted */ "./node_modules/validator/lib/isWhitelisted.js"));

var _normalizeEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/normalizeEmail */ "./node_modules/validator/lib/normalizeEmail.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./lib/util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = '10.11.0';
var validator = {
  version: version,
  toDate: _toDate.default,
  toFloat: _toFloat.default,
  toInt: _toInt.default,
  toBoolean: _toBoolean.default,
  equals: _equals.default,
  contains: _contains.default,
  matches: _matches.default,
  isEmail: _isEmail.default,
  isURL: _isURL.default,
  isMACAddress: _isMACAddress.default,
  isIP: _isIP.default,
  isIPRange: _isIPRange.default,
  isFQDN: _isFQDN.default,
  isBoolean: _isBoolean.default,
  isAlpha: _isAlpha.default,
  isAlphaLocales: _isAlpha.locales,
  isAlphanumeric: _isAlphanumeric.default,
  isAlphanumericLocales: _isAlphanumeric.locales,
  isNumeric: _isNumeric.default,
  isPort: _isPort.default,
  isLowercase: _isLowercase.default,
  isUppercase: _isUppercase.default,
  isAscii: _isAscii.default,
  isFullWidth: _isFullWidth.default,
  isHalfWidth: _isHalfWidth.default,
  isVariableWidth: _isVariableWidth.default,
  isMultibyte: _isMultibyte.default,
  isSurrogatePair: _isSurrogatePair.default,
  isInt: _isInt.default,
  isFloat: _isFloat.default,
  isFloatLocales: _isFloat.locales,
  isDecimal: _isDecimal.default,
  isHexadecimal: _isHexadecimal.default,
  isDivisibleBy: _isDivisibleBy.default,
  isHexColor: _isHexColor.default,
  isISRC: _isISRC.default,
  isMD5: _isMD.default,
  isHash: _isHash.default,
  isJWT: _isJWT.default,
  isJSON: _isJSON.default,
  isEmpty: _isEmpty.default,
  isLength: _isLength.default,
  isByteLength: _isByteLength.default,
  isUUID: _isUUID.default,
  isMongoId: _isMongoId.default,
  isAfter: _isAfter.default,
  isBefore: _isBefore.default,
  isIn: _isIn.default,
  isCreditCard: _isCreditCard.default,
  isIdentityCard: _isIdentityCard.default,
  isISIN: _isISIN.default,
  isISBN: _isISBN.default,
  isISSN: _isISSN.default,
  isMobilePhone: _isMobilePhone.default,
  isMobilePhoneLocales: _isMobilePhone.locales,
  isPostalCode: _isPostalCode.default,
  isPostalCodeLocales: _isPostalCode.locales,
  isCurrency: _isCurrency.default,
  isISO8601: _isISO.default,
  isRFC3339: _isRFC.default,
  isISO31661Alpha2: _isISO31661Alpha.default,
  isISO31661Alpha3: _isISO31661Alpha2.default,
  isBase64: _isBase.default,
  isDataURI: _isDataURI.default,
  isMagnetURI: _isMagnetURI.default,
  isMimeType: _isMimeType.default,
  isLatLong: _isLatLong.default,
  ltrim: _ltrim.default,
  rtrim: _rtrim.default,
  trim: _trim.default,
  escape: _escape.default,
  unescape: _unescape.default,
  stripLow: _stripLow.default,
  whitelist: _whitelist.default,
  blacklist: _blacklist.default,
  isWhitelisted: _isWhitelisted.default,
  normalizeEmail: _normalizeEmail.default,
  toString: _toString.default
};
var _default = validator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/alpha.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/alpha.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
var alpha = {
  'en-US': /^[A-Z]+$/i,
  'bg-BG': /^[-]+$/i,
  'cs-CZ': /^[A-Z]+$/i,
  'da-DK': /^[A-Z]+$/i,
  'de-DE': /^[A-Z]+$/i,
  'el-GR': /^[-]+$/i,
  'es-ES': /^[A-Z]+$/i,
  'fr-FR': /^[A-Z]+$/i,
  'it-IT': /^[A-Z]+$/i,
  'nb-NO': /^[A-Z]+$/i,
  'nl-NL': /^[A-Z]+$/i,
  'nn-NO': /^[A-Z]+$/i,
  'hu-HU': /^[A-Z]+$/i,
  'pl-PL': /^[A-Z]+$/i,
  'pt-PT': /^[A-Z]+$/i,
  'ru-RU': /^[-]+$/i,
  'sl-SI': /^[A-Z]+$/i,
  'sk-SK': /^[A-Z]+$/i,
  'sr-RS@latin': /^[A-Z]+$/i,
  'sr-RS': /^[-]+$/i,
  'sv-SE': /^[A-Z]+$/i,
  'tr-TR': /^[A-Z]+$/i,
  'uk-UA': /^[-I]+$/i,
  'ku-IQ': /^[]+$/i,
  ar: /^[]+$/
};
exports.alpha = alpha;
var alphanumeric = {
  'en-US': /^[0-9A-Z]+$/i,
  'bg-BG': /^[0-9-]+$/i,
  'cs-CZ': /^[0-9A-Z]+$/i,
  'da-DK': /^[0-9A-Z]+$/i,
  'de-DE': /^[0-9A-Z]+$/i,
  'el-GR': /^[0-9-]+$/i,
  'es-ES': /^[0-9A-Z]+$/i,
  'fr-FR': /^[0-9A-Z]+$/i,
  'it-IT': /^[0-9A-Z]+$/i,
  'hu-HU': /^[0-9A-Z]+$/i,
  'nb-NO': /^[0-9A-Z]+$/i,
  'nl-NL': /^[0-9A-Z]+$/i,
  'nn-NO': /^[0-9A-Z]+$/i,
  'pl-PL': /^[0-9A-Z]+$/i,
  'pt-PT': /^[0-9A-Z]+$/i,
  'ru-RU': /^[0-9-]+$/i,
  'sl-SI': /^[0-9A-Z]+$/i,
  'sk-SK': /^[0-9A-Z]+$/i,
  'sr-RS@latin': /^[0-9A-Z]+$/i,
  'sr-RS': /^[0-9-]+$/i,
  'sv-SE': /^[0-9A-Z]+$/i,
  'tr-TR': /^[0-9A-Z]+$/i,
  'uk-UA': /^[0-9-I]+$/i,
  'ku-IQ': /^[0-9]+$/i,
  ar: /^[0-9]+$/
};
exports.alphanumeric = alphanumeric;
var decimal = {
  'en-US': '.',
  ar: ''
};
exports.decimal = decimal;
var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
exports.englishLocales = englishLocales;

for (var locale, i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha['en-US'];
  alphanumeric[locale] = alphanumeric['en-US'];
  decimal[locale] = decimal['en-US'];
} // Source: http://www.localeplanet.com/java/


var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
exports.arabicLocales = arabicLocales;

for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
} // Source: https://en.wikipedia.org/wiki/Decimal_mark


var dotDecimal = [];
exports.dotDecimal = dotDecimal;
var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
exports.commaDecimal = commaDecimal;

for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
  decimal[dotDecimal[_i2]] = decimal['en-US'];
}

for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
  decimal[commaDecimal[_i3]] = ',';
}

alpha['pt-BR'] = alpha['pt-PT'];
alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
decimal['pt-BR'] = decimal['pt-PT']; // see #862

alpha['pl-Pl'] = alpha['pl-PL'];
alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
decimal['pl-Pl'] = decimal['pl-PL'];

/***/ }),

/***/ "./node_modules/validator/lib/blacklist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/blacklist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = blacklist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function blacklist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/contains.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/contains.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = contains;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, elem) {
  (0, _assertString.default)(str);
  return str.indexOf((0, _toString.default)(elem)) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/equals.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/equals.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = equals;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function equals(str, comparison) {
  (0, _assertString.default)(str);
  return str === comparison;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/escape.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/escape.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = escape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function escape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAfter.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAfter.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAfter;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAfter(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original > comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAlpha.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAlpha.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlpha;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlpha(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alpha) {
    return _alpha.alpha[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alpha);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAlphanumeric.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isAlphanumeric.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlphanumeric;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlphanumeric(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alphanumeric);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAscii.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAscii.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAscii;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var ascii = /^[\x00-\x7F]+$/;
/* eslint-enable no-control-regex */

function isAscii(str) {
  (0, _assertString.default)(str);
  return ascii.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBase64.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBase64.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBase64;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var notBase64 = /[^A-Z0-9+\/=]/i;

function isBase64(str) {
  (0, _assertString.default)(str);
  var len = str.length;

  if (!len || len % 4 !== 0 || notBase64.test(str)) {
    return false;
  }

  var firstPaddingChar = str.indexOf('=');
  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBefore.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBefore.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBefore;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBefore(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original < comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBoolean(str) {
  (0, _assertString.default)(str);
  return ['true', 'false', '1', '0'].indexOf(str) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isByteLength.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isByteLength.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isByteLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCreditCard.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isCreditCard.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCreditCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
/* eslint-enable max-len */

function isCreditCard(str) {
  (0, _assertString.default)(str);
  var sanitized = str.replace(/[- ]+/g, '');

  if (!creditCard.test(sanitized)) {
    return false;
  }

  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble;

  for (var i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum % 10 + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return !!(sum % 10 === 0 ? sanitized : false);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCurrency.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isCurrency.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCurrency;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function currencyRegex(options) {
  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
  options.digits_after_decimal.forEach(function (digit, index) {
    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
  });
  var symbol = "(\\".concat(options.symbol.replace(/\./g, '\\.'), ")").concat(options.require_symbol ? '' : '?'),
      negative = '-?',
      whole_dollar_amount_without_sep = '[1-9]\\d*',
      whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
      valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
      whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
      decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : ''); // default is negative sign before symbol, but there are two other options (besides parens)

  if (options.allow_negatives && !options.parens_for_negatives) {
    if (options.negative_sign_after_digits) {
      pattern += negative;
    } else if (options.negative_sign_before_digits) {
      pattern = negative + pattern;
    }
  } // South African Rand, for example, uses R 123 (space) and R-123 (no space)


  if (options.allow_negative_sign_placeholder) {
    pattern = "( (?!\\-))?".concat(pattern);
  } else if (options.allow_space_after_symbol) {
    pattern = " ?".concat(pattern);
  } else if (options.allow_space_after_digits) {
    pattern += '( (?!$))?';
  }

  if (options.symbol_after_digits) {
    pattern += symbol;
  } else {
    pattern = symbol + pattern;
  }

  if (options.allow_negatives) {
    if (options.parens_for_negatives) {
      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
      pattern = negative + pattern;
    }
  } // ensure there's a dollar and/or decimal amount, and that
  // it doesn't start with a space or a negative sign followed by a space


  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
}

var default_currency_options = {
  symbol: '$',
  require_symbol: false,
  allow_space_after_symbol: false,
  symbol_after_digits: false,
  allow_negatives: true,
  parens_for_negatives: false,
  negative_sign_before_digits: false,
  negative_sign_after_digits: false,
  allow_negative_sign_placeholder: false,
  thousands_separator: ',',
  decimal_separator: '.',
  allow_decimal: true,
  require_decimal: false,
  digits_after_decimal: [2],
  allow_space_after_digits: false
};

function isCurrency(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_currency_options);
  return currencyRegex(options).test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDataURI.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDataURI.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDataURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validMediaType = /^[a-z]+\/[a-z0-9\-\+]+$/i;
var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;

function isDataURI(str) {
  (0, _assertString.default)(str);
  var data = str.split(',');

  if (data.length < 2) {
    return false;
  }

  var attributes = data.shift().trim().split(';');
  var schemeAndMediaType = attributes.shift();

  if (schemeAndMediaType.substr(0, 5) !== 'data:') {
    return false;
  }

  var mediaType = schemeAndMediaType.substr(5);

  if (mediaType !== '' && !validMediaType.test(mediaType)) {
    return false;
  }

  for (var i = 0; i < attributes.length; i++) {
    if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {// ok
    } else if (!validAttribute.test(attributes[i])) {
      return false;
    }
  }

  for (var _i = 0; _i < data.length; _i++) {
    if (!validData.test(data[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDecimal.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDecimal.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDecimal;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function decimalRegExp(options) {
  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
  return regExp;
}

var default_decimal_options = {
  force_decimal: false,
  decimal_digits: '1,',
  locale: 'en-US'
};
var blacklist = ['', '-', '+'];

function isDecimal(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_decimal_options);

  if (options.locale in _alpha.decimal) {
    return !(0, _includes.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
  }

  throw new Error("Invalid locale '".concat(options.locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDivisibleBy.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isDivisibleBy.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDivisibleBy;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./toFloat */ "./node_modules/validator/lib/toFloat.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isDivisibleBy(str, num) {
  (0, _assertString.default)(str);
  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmail.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmail.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmail;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};
/* eslint-disable max-len */

/* eslint-disable no-control-regex */

var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */

/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);

    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');
  var lower_domain = domain.toLowerCase();

  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
    /*
      Previously we removed dots for gmail addresses before validating.
      This was removed because it allows `multiple..dots@gmail.com`
      to be reported as valid, but it is not.
      Gmail only normalizes single dots, removing them from here is pointless,
      should be done in normalizeEmail
    */
    user = user.toLowerCase(); // Removing sub-address from username before gmail validation

    var username = user.split('+')[0]; // Dots are not included in gmail length restriction

    if (!(0, _isByteLength.default)(username.replace('.', ''), {
      min: 6,
      max: 30
    })) {
      return false;
    }

    var _user_parts = username.split('.');

    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }

  if (!(0, _isByteLength.default)(user, {
    max: 64
  }) || !(0, _isByteLength.default)(domain, {
    max: 254
  })) {
    return false;
  }

  if (!(0, _isFQDN.default)(domain, {
    require_tld: options.require_tld
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }

    if (!(0, _isIP.default)(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }

      var noBracketdomain = domain.substr(1, domain.length - 2);

      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
        return false;
      }
    }
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  var user_parts = user.split('.');

  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmpty.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmpty.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmpty;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_is_empty_options = {
  ignore_whitespace: false
};

function isEmpty(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_is_empty_options);
  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFQDN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isFQDN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFQDN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFQDN(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_fqdn_options);
  /* Remove the optional trailing dot before checking validity */

  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }

  var parts = str.split('.');

  for (var i = 0; i < parts.length; i++) {
    if (parts[i].length > 63) {
      return false;
    }
  }

  if (options.require_tld) {
    var tld = parts.pop();

    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    } // disallow spaces


    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }

  for (var part, _i = 0; _i < parts.length; _i++) {
    part = parts[_i];

    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }

    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    } // disallow full-width chars


    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }

    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isFloat.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFloat;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFloat(str, options) {
  (0, _assertString.default)(str);
  options = options || {};
  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));

  if (str === '' || str === '.' || str === '-' || str === '+') {
    return false;
  }

  var value = parseFloat(str.replace(',', '.'));
  return float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);
}

var locales = Object.keys(_alpha.decimal);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isFullWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isFullWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFullWidth;
exports.fullWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.fullWidth = fullWidth;

function isFullWidth(str) {
  (0, _assertString.default)(str);
  return fullWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHalfWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isHalfWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHalfWidth;
exports.halfWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.halfWidth = halfWidth;

function isHalfWidth(str) {
  (0, _assertString.default)(str);
  return halfWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHash.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isHash.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHash;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengths = {
  md5: 32,
  md4: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8
};

function isHash(str, algorithm) {
  (0, _assertString.default)(str);
  var hash = new RegExp("^[a-f0-9]{".concat(lengths[algorithm], "}$"));
  return hash.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexColor.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isHexColor.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexColor;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

function isHexColor(str) {
  (0, _assertString.default)(str);
  return hexcolor.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexadecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isHexadecimal.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexadecimal;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexadecimal = /^[0-9A-F]+$/i;

function isHexadecimal(str) {
  (0, _assertString.default)(str);
  return hexadecimal.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIP.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIP.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIP;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  } else if (version === '4') {
    if (!ipv4Maybe.test(str)) {
      return false;
    }

    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  } else if (version === '6') {
    var blocks = str.split(':');
    var foundOmissionBlock = false; // marker to indicate ::
    // At least some OS accept the last 32 bits of an IPv6 address
    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
    // and '::a.b.c.d' is deprecated, but also valid.

    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

    if (blocks.length > expectedNumberOfBlocks) {
      return false;
    } // initial or final ::


    if (str === '::') {
      return true;
    } else if (str.substr(0, 2) === '::') {
      blocks.shift();
      blocks.shift();
      foundOmissionBlock = true;
    } else if (str.substr(str.length - 2) === '::') {
      blocks.pop();
      blocks.pop();
      foundOmissionBlock = true;
    }

    for (var i = 0; i < blocks.length; ++i) {
      // test for a :: which can not be at the string start/end
      // since those cases have been handled above
      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
        if (foundOmissionBlock) {
          return false; // multiple :: in address
        }

        foundOmissionBlock = true;
      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last
        // block is a valid IPv4 address
      } else if (!ipv6Block.test(blocks[i])) {
        return false;
      }
    }

    if (foundOmissionBlock) {
      return blocks.length >= 1;
    }

    return blocks.length === expectedNumberOfBlocks;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIPRange.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isIPRange.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIPRange;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subnetMaybe = /^\d{1,2}$/;

function isIPRange(str) {
  (0, _assertString.default)(str);
  var parts = str.split('/'); // parts[0] -> ip, parts[1] -> subnet

  if (parts.length !== 2) {
    return false;
  }

  if (!subnetMaybe.test(parts[1])) {
    return false;
  } // Disallow preceding 0 i.e. 01, 02, ...


  if (parts[1].length > 1 && parts[1].startsWith('0')) {
    return false;
  }

  return (0, _isIP.default)(parts[0], 4) && parts[1] <= 32 && parts[1] >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISBN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISBN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISBN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
var isbn13Maybe = /^(?:[0-9]{13})$/;
var factor = [1, 3];

function isISBN(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isISBN(str, 10) || isISBN(str, 13);
  }

  var sanitized = str.replace(/[\s-]+/g, '');
  var checksum = 0;
  var i;

  if (version === '10') {
    if (!isbn10Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 9; i++) {
      checksum += (i + 1) * sanitized.charAt(i);
    }

    if (sanitized.charAt(9) === 'X') {
      checksum += 10 * 10;
    } else {
      checksum += 10 * sanitized.charAt(9);
    }

    if (checksum % 11 === 0) {
      return !!sanitized;
    }
  } else if (version === '13') {
    if (!isbn13Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 12; i++) {
      checksum += factor[i % 2] * sanitized.charAt(i);
    }

    if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
      return !!sanitized;
    }
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISIN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISIN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISIN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

function isISIN(str) {
  (0, _assertString.default)(str);

  if (!isin.test(str)) {
    return false;
  }

  var checksumStr = str.replace(/[A-Z]/g, function (character) {
    return parseInt(character, 36);
  });
  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble = true;

  for (var i = checksumStr.length - 2; i >= 0; i--) {
    digit = checksumStr.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha2.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha2.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha2;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
var validISO31661Alpha2CountriesCodes = ['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW'];

function isISO31661Alpha2(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha2CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha3.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha3.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha3;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
var validISO31661Alpha3CountriesCodes = ['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE'];

function isISO31661Alpha3(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha3CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO8601.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isISO8601.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO8601;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */

var isValidDate = function isValidDate(str) {
  // str must have passed the ISO8601 check
  // this check is meant to catch invalid dates
  // like 2009-02-31
  // first check for ordinal dates
  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

  if (ordinalMatch) {
    var oYear = Number(ordinalMatch[1]);
    var oDay = Number(ordinalMatch[2]); // if is leap year

    if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
    return oDay <= 365;
  }

  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
  var year = match[1];
  var month = match[2];
  var day = match[3];
  var monthString = month ? "0".concat(month).slice(-2) : month;
  var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
  if (isNaN(d.getUTCFullYear())) return false;

  if (month && day) {
    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
  }

  return true;
};

function isISO8601(str, options) {
  (0, _assertString.default)(str);
  var check = iso8601.test(str);
  if (!options) return check;
  if (check && options.strict) return isValidDate(str);
  return check;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISRC.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISRC.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISRC;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;

function isISRC(str) {
  (0, _assertString.default)(str);
  return isrc.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISSN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISSN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISSN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var issn = '^\\d{4}-?\\d{3}[\\dX]$';

function isISSN(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString.default)(str);
  var testIssn = issn;
  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');

  if (!testIssn.test(str)) {
    return false;
  }

  var digits = str.replace('-', '').toUpperCase();
  var checksum = 0;

  for (var i = 0; i < digits.length; i++) {
    var digit = digits[i];
    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
  }

  return checksum % 11 === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIdentityCard.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isIdentityCard.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIdentityCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validators = {
  ES: function ES(str) {
    (0, _assertString.default)(str);
    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
    var charsValue = {
      X: 0,
      Y: 1,
      Z: 2
    };
    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E']; // sanitize user input

    var sanitized = str.trim().toUpperCase(); // validate the data structure

    if (!DNI.test(sanitized)) {
      return false;
    } // validate the control digit


    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {
      return charsValue[char];
    });
    return sanitized.endsWith(controlDigits[number % 23]);
  }
};

function isIdentityCard(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
  (0, _assertString.default)(str);

  if (locale in validators) {
    return validators[locale](str);
  } else if (locale === 'any') {
    for (var key in validators) {
      if (validators.hasOwnProperty(key)) {
        var validator = validators[key];

        if (validator(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIn.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIn.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIn;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isIn(str, options) {
  (0, _assertString.default)(str);
  var i;

  if (Object.prototype.toString.call(options) === '[object Array]') {
    var array = [];

    for (i in options) {
      if ({}.hasOwnProperty.call(options, i)) {
        array[i] = (0, _toString.default)(options[i]);
      }
    }

    return array.indexOf(str) >= 0;
  } else if (_typeof(options) === 'object') {
    return options.hasOwnProperty(str);
  } else if (options && typeof options.indexOf === 'function') {
    return options.indexOf(str) >= 0;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
var intLeadingZeroes = /^[-+]?[0-9]+$/;

function isInt(str, options) {
  (0, _assertString.default)(str);
  options = options || {}; // Get the regex to use for testing, based on whether
  // leading zeroes are allowed or not.

  var regex = options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ? int : intLeadingZeroes; // Check min/max/lt/gt

  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isJSON.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJSON;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isJSON(str) {
  (0, _assertString.default)(str);

  try {
    var obj = JSON.parse(str);
    return !!obj && _typeof(obj) === 'object';
  } catch (e) {
    /* ignore */
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJWT.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isJWT.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJWT;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jwt = /^([A-Za-z0-9\-_~+\/]+[=]{0,2})\.([A-Za-z0-9\-_~+\/]+[=]{0,2})(?:\.([A-Za-z0-9\-_~+\/]+[=]{0,2}))?$/;

function isJWT(str) {
  (0, _assertString.default)(str);
  return jwt.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLatLong.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isLatLong.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;

function _default(str) {
  (0, _assertString.default)(str);
  if (!str.includes(',')) return false;
  var pair = str.split(',');
  return lat.test(pair[0]) && long.test(pair[1]);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLength.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isLength.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  var len = str.length - surrogatePairs.length;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLowercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isLowercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLowercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isLowercase(str) {
  (0, _assertString.default)(str);
  return str === str.toLowerCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMACAddress.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isMACAddress.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMACAddress;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
var macAddressNoColons = /^([0-9a-fA-F]){12}$/;

function isMACAddress(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_colons) {
    return macAddressNoColons.test(str);
  }

  return macAddress.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMD5.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isMD5.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMD5;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md5 = /^[a-f0-9]{32}$/;

function isMD5(str) {
  (0, _assertString.default)(str);
  return md5.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMagnetURI.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMagnetURI.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMagnetURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var magnetURI = /^magnet:\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;

function isMagnetURI(url) {
  (0, _assertString.default)(url);
  return magnetURI.test(url.trim());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMimeType.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isMimeType.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMimeType;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/
// Match simple MIME types
// NB :
//   Subtype length must not exceed 100 characters.
//   This rule does not comply to the RFC specs (what is the max length ?).
var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i; // eslint-disable-line max-len
// Handle "charset" in "text/*"

var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len
// Handle "boundary" in "multipart/*"

var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

function isMimeType(str) {
  (0, _assertString.default)(str);
  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMobilePhone.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isMobilePhone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMobilePhone;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var phones = {
  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
  'ar-EG': /^((\+?20)|0)?1[012]\d{8}$/,
  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
  'ar-KW': /^(\+?965)[569]\d{7}$/,
  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
  'bn-BD': /\+?(88)?0?1[356789][0-9]{8}\b/,
  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'de-DE': /^(\+49)?0?1(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7}$/,
  'el-GR': /^(\+?30|0)?(69\d{8})$/,
  'en-AU': /^(\+?61|0)4\d{8}$/,
  'en-GB': /^(\+?44|0)7\d{9}$/,
  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28)\d{7}$/,
  'en-HK': /^(\+?852\-?)?[456789]\d{3}\-?\d{4}$/,
  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
  'en-KE': /^(\+?254|0)?[7]\d{8}$/,
  'en-MU': /^(\+?230|0)?\d{8}$/,
  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
  'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
  'en-SG': /^(\+65)?[89]\d{7}$/,
  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  'en-ZA': /^(\+?27|0)\d{9}$/,
  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
  'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  'ja-JP': /^(\+?81|0)[789]0[ \-]?[1-9]\d{2}[ \-]?\d{5}$/,
  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  'lt-LT': /^(\+370|8)\d{8}$/,
  'ms-MY': /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
  'nb-NO': /^(\+?47)?[49]\d{7}$/,
  'nl-BE': /^(\+?32|0)4?\d{8}$/,
  'nn-NO': /^(\+?47)?[49]\d{7}$/,
  'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
  'pt-BR': /(?=^(\+?5{2}\-?|0)[1-9]{2}\-?\d{4}\-?\d{4}$)(^(\+?5{2}\-?|0)[1-9]{2}\-?[6-9]{1}\d{3}\-?\d{4}$)|(^(\+?5{2}\-?|0)[1-9]{2}\-?9[6-9]{1}\d{3}\-?\d{4}$)/,
  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
  'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
  'ru-RU': /^(\+?7|8)?9\d{9}$/,
  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  'th-TH': /^(\+66|66|0)\d{9}$/,
  'tr-TR': /^(\+?90|0)?5\d{9}$/,
  'uk-UA': /^(\+?38|8)?0\d{9}$/,
  'vi-VN': /^(\+?84|0)((3([2-9]))|(5([689]))|(7([0|6-9]))|(8([1-5]))|(9([0-9])))([0-9]{7})$/,
  'zh-CN': /^((\+|00)86)?1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$/,
  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
};
/* eslint-enable max-len */
// aliases

phones['en-CA'] = phones['en-US'];
phones['fr-BE'] = phones['nl-BE'];
phones['zh-HK'] = phones['en-HK'];

function isMobilePhone(str, locale, options) {
  (0, _assertString.default)(str);

  if (options && options.strictMode && !str.startsWith('+')) {
    return false;
  }

  if (Array.isArray(locale)) {
    return locale.some(function (key) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }

      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str); // alias falsey locale as 'any'
  } else if (!locale || locale === 'any') {
    for (var key in phones) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(phones);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isMongoId.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isMongoId.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMongoId;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isMongoId(str) {
  (0, _assertString.default)(str);
  return (0, _isHexadecimal.default)(str) && str.length === 24;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMultibyte.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMultibyte.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMultibyte;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var multibyte = /[^\x00-\x7F]/;
/* eslint-enable no-control-regex */

function isMultibyte(str) {
  (0, _assertString.default)(str);
  return multibyte.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isNumeric.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isNumeric.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isNumeric;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;
var numericNoSymbols = /^[0-9]+$/;

function isNumeric(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }

  return numeric.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPort.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isPort.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isPort;

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./isInt */ "./node_modules/validator/lib/isInt.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPort(str) {
  return (0, _isInt.default)(str, {
    min: 0,
    max: 65535
  });
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPostalCode.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isPostalCode.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// common patterns
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  BE: fourDigit,
  BG: fourDigit,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: fiveDigit,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HU: fourDigit,
  IL: fiveDigit,
  IN: sixDigit,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  MX: fiveDigit,
  NL: /^\d{4}\s?[a-z]{2}$/i,
  NO: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^\d{3}\s?\d{2}$/,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales = Object.keys(patterns);
exports.locales = locales;

function _default(str, locale) {
  (0, _assertString.default)(str);

  if (locale in patterns) {
    return patterns[locale].test(str);
  } else if (locale === 'any') {
    for (var key in patterns) {
      if (patterns.hasOwnProperty(key)) {
        var pattern = patterns[key];

        if (pattern.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

/***/ }),

/***/ "./node_modules/validator/lib/isRFC3339.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isRFC3339.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isRFC3339;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */
var dateFullYear = /[0-9]{4}/;
var dateMonth = /(0[1-9]|1[0-2])/;
var dateMDay = /([12]\d|0[1-9]|3[01])/;
var timeHour = /([01][0-9]|2[0-3])/;
var timeMinute = /[0-5][0-9]/;
var timeSecond = /([0-5][0-9]|60)/;
var timeSecFrac = /(\.[0-9]+)?/;
var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
var rfc3339 = new RegExp("".concat(fullDate.source, "[ tT]").concat(fullTime.source));

function isRFC3339(str) {
  (0, _assertString.default)(str);
  return rfc3339.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isSurrogatePair.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isSurrogatePair.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isSurrogatePair;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

function isSurrogatePair(str) {
  (0, _assertString.default)(str);
  return surrogatePair.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isURL.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isURL.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isURL;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];

    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }

  return false;
}

function isURL(url, options) {
  (0, _assertString.default)(url);

  if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
    return false;
  }

  if (url.indexOf('mailto:') === 0) {
    return false;
  }

  options = (0, _merge.default)(options, default_url_options);
  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');

  if (split.length > 1) {
    protocol = split.shift().toLowerCase();

    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.substr(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }

    split[0] = url.substr(2);
  }

  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');

  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }

    auth = split.shift();

    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
  }

  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);

  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();

    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null) {
    port = parseInt(port_str, 10);

    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  }

  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
    return false;
  }

  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUUID.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isUUID.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUUID;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuid = {
  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};

function isUUID(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
  (0, _assertString.default)(str);
  var pattern = uuid[version];
  return pattern && pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUppercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isUppercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUppercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isUppercase(str) {
  (0, _assertString.default)(str);
  return str === str.toUpperCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isVariableWidth.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isVariableWidth.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isVariableWidth;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFullWidth = __webpack_require__(/*! ./isFullWidth */ "./node_modules/validator/lib/isFullWidth.js");

var _isHalfWidth = __webpack_require__(/*! ./isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isVariableWidth(str) {
  (0, _assertString.default)(str);
  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isWhitelisted.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isWhitelisted.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isWhitelisted;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isWhitelisted(str, chars) {
  (0, _assertString.default)(str);

  for (var i = str.length - 1; i >= 0; i--) {
    if (chars.indexOf(str[i]) === -1) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/ltrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/ltrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = ltrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ltrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("^[".concat(chars, "]+"), 'g') : /^\s+/g;
  return str.replace(pattern, '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/matches.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/matches.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = matches;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matches(str, pattern, modifiers) {
  (0, _assertString.default)(str);

  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
    pattern = new RegExp(pattern, modifiers);
  }

  return pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/normalizeEmail.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/normalizeEmail.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeEmail;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_normalize_email_options = {
  // The following options apply to all email addresses
  // Lowercases the local part of the email address.
  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
  // The domain is always lowercased, as per RFC 1035
  all_lowercase: true,
  // The following conversions are specific to GMail
  // Lowercases the local part of the GMail address (known to be case-insensitive)
  gmail_lowercase: true,
  // Removes dots from the local part of the email address, as that's ignored by GMail
  gmail_remove_dots: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  gmail_remove_subaddress: true,
  // Conversts the googlemail.com domain to gmail.com
  gmail_convert_googlemaildotcom: true,
  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
  outlookdotcom_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  outlookdotcom_remove_subaddress: true,
  // The following conversions are specific to Yahoo
  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
  yahoo_lowercase: true,
  // Removes the subaddress (e.g. "-foo") from the email address
  yahoo_remove_subaddress: true,
  // The following conversions are specific to Yandex
  // Lowercases the local part of the Yandex address (known to be case-insensitive)
  yandex_lowercase: true,
  // The following conversions are specific to iCloud
  // Lowercases the local part of the iCloud address (known to be case-insensitive)
  icloud_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  icloud_remove_subaddress: true
}; // List of domains used by iCloud

var icloud_domains = ['icloud.com', 'me.com']; // List of domains used by Outlook.com and its predecessors
// This list is likely incomplete.
// Partial reference:
// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/

var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com']; // List of domains used by Yahoo Mail
// This list is likely incomplete

var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com']; // List of domains used by yandex.ru

var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru']; // replace single dots, but not multiple consecutive dots

function dotsReplacer(match) {
  if (match.length > 1) {
    return match;
  }

  return '';
}

function normalizeEmail(email, options) {
  options = (0, _merge.default)(options, default_normalize_email_options);
  var raw_parts = email.split('@');
  var domain = raw_parts.pop();
  var user = raw_parts.join('@');
  var parts = [user, domain]; // The domain is always lowercased, as it's case-insensitive per RFC 1035

  parts[1] = parts[1].toLowerCase();

  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
    // Address is GMail
    if (options.gmail_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (options.gmail_remove_dots) {
      // this does not replace consecutive dots like example..email@gmail.com
      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.gmail_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
    // Address is iCloud
    if (options.icloud_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.icloud_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
    // Address is Outlook.com
    if (options.outlookdotcom_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.outlookdotcom_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
    // Address is Yahoo
    if (options.yahoo_remove_subaddress) {
      var components = parts[0].split('-');
      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.yahoo_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
    if (options.all_lowercase || options.yandex_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = 'yandex.ru'; // all yandex domains are equal, 1st preffered
  } else if (options.all_lowercase) {
    // Any other address
    parts[0] = parts[0].toLowerCase();
  }

  return parts.join('@');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/rtrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/rtrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = rtrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rtrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("[".concat(chars, "]")) : /\s/;
  var idx = str.length - 1;

  for (; idx >= 0 && pattern.test(str[idx]); idx--) {
    ;
  }

  return idx < str.length ? str.substr(0, idx + 1) : str;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/stripLow.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/stripLow.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = stripLow;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./blacklist */ "./node_modules/validator/lib/blacklist.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stripLow(str, keep_new_lines) {
  (0, _assertString.default)(str);
  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
  return (0, _blacklist.default)(str, chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/toBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBoolean(str, strict) {
  (0, _assertString.default)(str);

  if (strict) {
    return str === '1' || str === 'true';
  }

  return str !== '0' && str !== 'false' && str !== '';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toDate.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/toDate.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toDate;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toDate(date) {
  (0, _assertString.default)(date);
  date = Date.parse(date);
  return !isNaN(date) ? new Date(date) : null;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/toFloat.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toFloat;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toFloat(str) {
  (0, _assertString.default)(str);
  return parseFloat(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/toInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toInt(str, radix) {
  (0, _assertString.default)(str);
  return parseInt(str, radix || 10);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/trim.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/trim.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = trim;

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./ltrim */ "./node_modules/validator/lib/ltrim.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trim(str, chars) {
  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/unescape.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/unescape.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = unescape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unescape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/assertString.js":
/*!*********************************************************!*\
  !*** ./node_modules/validator/lib/util/assertString.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = assertString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    var invalidType;

    if (input === null) {
      invalidType = 'null';
    } else {
      invalidType = _typeof(input);

      if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
        invalidType = input.constructor.name;
      } else {
        invalidType = "a ".concat(invalidType);
      }
    }

    throw new TypeError("Expected string but received ".concat(invalidType, "."));
  }
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/includes.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/includes.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var includes = function includes(arr, val) {
  return arr.some(function (arrVal) {
    return val === arrVal;
  });
};

var _default = includes;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = merge;

function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }

  return obj;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/toString.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/toString.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function toString(input) {
  if (_typeof(input) === 'object' && input !== null) {
    if (typeof input.toString === 'function') {
      input = input.toString();
    } else {
      input = '[object Object]';
    }
  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
    input = '';
  }

  return String(input);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/whitelist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/whitelist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = whitelist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function whitelist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/wkx/lib/binaryreader.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binaryreader.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryReader;

function BinaryReader(buffer, isBigEndian) {
    this.buffer = buffer;
    this.position = 0;
    this.isBigEndian = isBigEndian || false;
}

function _read(readLE, readBE, size) {
    return function () {
        var value;

        if (this.isBigEndian)
            value = readBE.call(this.buffer, this.position);
        else
            value = readLE.call(this.buffer, this.position);

        this.position += size;

        return value;
    };
}

BinaryReader.prototype.readUInt8 = _read(Buffer.prototype.readUInt8, Buffer.prototype.readUInt8, 1);
BinaryReader.prototype.readUInt16 = _read(Buffer.prototype.readUInt16LE, Buffer.prototype.readUInt16BE, 2);
BinaryReader.prototype.readUInt32 = _read(Buffer.prototype.readUInt32LE, Buffer.prototype.readUInt32BE, 4);
BinaryReader.prototype.readInt8 = _read(Buffer.prototype.readInt8, Buffer.prototype.readInt8, 1);
BinaryReader.prototype.readInt16 = _read(Buffer.prototype.readInt16LE, Buffer.prototype.readInt16BE, 2);
BinaryReader.prototype.readInt32 = _read(Buffer.prototype.readInt32LE, Buffer.prototype.readInt32BE, 4);
BinaryReader.prototype.readFloat = _read(Buffer.prototype.readFloatLE, Buffer.prototype.readFloatBE, 4);
BinaryReader.prototype.readDouble = _read(Buffer.prototype.readDoubleLE, Buffer.prototype.readDoubleBE, 8);

BinaryReader.prototype.readVarInt = function () {
    var nextByte,
        result = 0,
        bytesRead = 0;

    do {
        nextByte = this.buffer[this.position + bytesRead];
        result += (nextByte & 0x7F) << (7 * bytesRead);
        bytesRead++;
    } while (nextByte >= 0x80);

    this.position += bytesRead;

    return result;
};


/***/ }),

/***/ "./node_modules/wkx/lib/binarywriter.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binarywriter.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryWriter;

function BinaryWriter(size, allowResize) {
    this.buffer = new Buffer(size);
    this.position = 0;
    this.allowResize = allowResize;
}

function _write(write, size) {
    return function (value, noAssert) {
        this.ensureSize(size);

        write.call(this.buffer, value, this.position, noAssert);
        this.position += size;
    };
}

BinaryWriter.prototype.writeUInt8 = _write(Buffer.prototype.writeUInt8, 1);
BinaryWriter.prototype.writeUInt16LE = _write(Buffer.prototype.writeUInt16LE, 2);
BinaryWriter.prototype.writeUInt16BE = _write(Buffer.prototype.writeUInt16BE, 2);
BinaryWriter.prototype.writeUInt32LE = _write(Buffer.prototype.writeUInt32LE, 4);
BinaryWriter.prototype.writeUInt32BE = _write(Buffer.prototype.writeUInt32BE, 4);
BinaryWriter.prototype.writeInt8 = _write(Buffer.prototype.writeInt8, 1);
BinaryWriter.prototype.writeInt16LE = _write(Buffer.prototype.writeInt16LE, 2);
BinaryWriter.prototype.writeInt16BE = _write(Buffer.prototype.writeInt16BE, 2);
BinaryWriter.prototype.writeInt32LE = _write(Buffer.prototype.writeInt32LE, 4);
BinaryWriter.prototype.writeInt32BE = _write(Buffer.prototype.writeInt32BE, 4);
BinaryWriter.prototype.writeFloatLE = _write(Buffer.prototype.writeFloatLE, 4);
BinaryWriter.prototype.writeFloatBE = _write(Buffer.prototype.writeFloatBE, 4);
BinaryWriter.prototype.writeDoubleLE = _write(Buffer.prototype.writeDoubleLE, 8);
BinaryWriter.prototype.writeDoubleBE = _write(Buffer.prototype.writeDoubleBE, 8);

BinaryWriter.prototype.writeBuffer = function (buffer) {
    this.ensureSize(buffer.length);

    buffer.copy(this.buffer, this.position, 0, buffer.length);
    this.position += buffer.length;
};

BinaryWriter.prototype.writeVarInt = function (value) {
    var length = 1;

    while ((value & 0xFFFFFF80) !== 0) {
        this.writeUInt8((value & 0x7F) | 0x80);
        value >>>= 7;
        length++;
    }

    this.writeUInt8(value & 0x7F);

    return length;
};

BinaryWriter.prototype.ensureSize = function (size) {
    if (this.buffer.length < this.position + size) {
        if (this.allowResize) {
            var tempBuffer = new Buffer(this.position + size);
            this.buffer.copy(tempBuffer, 0, 0, this.buffer.length);
            this.buffer = tempBuffer;
        }
        else {
            throw new RangeError('index out of range');
        }
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometry.js":
/*!******************************************!*\
  !*** ./node_modules/wkx/lib/geometry.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Geometry;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
var MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
var MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
var GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");
var BinaryReader = __webpack_require__(/*! ./binaryreader */ "./node_modules/wkx/lib/binaryreader.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var WktParser = __webpack_require__(/*! ./wktparser */ "./node_modules/wkx/lib/wktparser.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Geometry() {
    this.srid = undefined;
    this.hasZ = false;
    this.hasM = false;
}

Geometry.parse = function (value, options) {
    var valueType = typeof value;

    if (valueType === 'string' || value instanceof WktParser)
        return Geometry._parseWkt(value);
    else if (Buffer.isBuffer(value) || value instanceof BinaryReader)
        return Geometry._parseWkb(value, options);
    else
        throw new Error('first argument must be a string or Buffer');
};

Geometry._parseWkt = function (value) {
    var wktParser,
        srid;

    if (value instanceof WktParser)
        wktParser = value;
    else
        wktParser = new WktParser(value);

    var match = wktParser.matchRegex([/^SRID=(\d+);/]);
    if (match)
        srid = parseInt(match[1], 10);

    var geometryType = wktParser.matchType();
    var dimension = wktParser.matchDimension();

    var options = {
        srid: srid,
        hasZ: dimension.hasZ,
        hasM: dimension.hasM
    };

    switch (geometryType) {
        case Types.wkt.Point:
            return Point._parseWkt(wktParser, options);
        case Types.wkt.LineString:
            return LineString._parseWkt(wktParser, options);
        case Types.wkt.Polygon:
            return Polygon._parseWkt(wktParser, options);
        case Types.wkt.MultiPoint:
            return MultiPoint._parseWkt(wktParser, options);
        case Types.wkt.MultiLineString:
            return MultiLineString._parseWkt(wktParser, options);
        case Types.wkt.MultiPolygon:
            return MultiPolygon._parseWkt(wktParser, options);
        case Types.wkt.GeometryCollection:
            return GeometryCollection._parseWkt(wktParser, options);
    }
};

Geometry._parseWkb = function (value, parentOptions) {
    var binaryReader,
        wkbType,
        geometryType,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    binaryReader.isBigEndian = !binaryReader.readInt8();

    wkbType = binaryReader.readUInt32();

    options.hasSrid = (wkbType & 0x20000000) === 0x20000000;
    options.isEwkb = (wkbType & 0x20000000) || (wkbType & 0x40000000) || (wkbType & 0x80000000);

    if (options.hasSrid)
        options.srid = binaryReader.readUInt32();

    options.hasZ = false;
    options.hasM = false;

    if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {
        if (wkbType >= 1000 && wkbType < 2000) {
            options.hasZ = true;
            geometryType = wkbType - 1000;
        }
        else if (wkbType >= 2000 && wkbType < 3000) {
            options.hasM = true;
            geometryType = wkbType - 2000;
        }
        else if (wkbType >= 3000 && wkbType < 4000) {
            options.hasZ = true;
            options.hasM = true;
            geometryType = wkbType - 3000;
        }
        else {
            geometryType = wkbType;
        }
    }
    else {
        if (wkbType & 0x80000000)
            options.hasZ = true;
        if (wkbType & 0x40000000)
            options.hasM = true;

        geometryType = wkbType & 0xF;
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseWkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseWkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseWkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseWkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseWkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseWkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseWkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseTwkb = function (value) {
    var binaryReader,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    var type = binaryReader.readUInt8();
    var metadataHeader = binaryReader.readUInt8();

    var geometryType = type & 0x0F;
    options.precision = ZigZag.decode(type >> 4);
    options.precisionFactor = Math.pow(10, options.precision);

    options.hasBoundingBox = metadataHeader >> 0 & 1;
    options.hasSizeAttribute = metadataHeader >> 1 & 1;
    options.hasIdList = metadataHeader >> 2 & 1;
    options.hasExtendedPrecision = metadataHeader >> 3 & 1;
    options.isEmpty = metadataHeader >> 4 & 1;

    if (options.hasExtendedPrecision) {
        var extendedPrecision = binaryReader.readUInt8();
        options.hasZ = (extendedPrecision & 0x01) === 0x01;
        options.hasM = (extendedPrecision & 0x02) === 0x02;

        options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);
        options.zPrecisionFactor = Math.pow(10, options.zPrecision);

        options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);
        options.mPrecisionFactor = Math.pow(10, options.mPrecision);
    }
    else {
        options.hasZ = false;
        options.hasM = false;
    }

    if (options.hasSizeAttribute)
        binaryReader.readVarInt();
    if (options.hasBoundingBox) {
        var dimensions = 2;

        if (options.hasZ)
            dimensions++;
        if (options.hasM)
            dimensions++;

        for (var i = 0; i < dimensions; i++) {
            binaryReader.readVarInt();
            binaryReader.readVarInt();
        }
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseTwkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseTwkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseTwkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseTwkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseTwkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseGeoJSON = function (value) {
    return Geometry._parseGeoJSON(value);
};

Geometry._parseGeoJSON = function (value, isSubGeometry) {
    var geometry;

    switch (value.type) {
        case Types.geoJSON.Point:
            geometry = Point._parseGeoJSON(value); break;
        case Types.geoJSON.LineString:
            geometry = LineString._parseGeoJSON(value); break;
        case Types.geoJSON.Polygon:
            geometry = Polygon._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPoint:
            geometry = MultiPoint._parseGeoJSON(value); break;
        case Types.geoJSON.MultiLineString:
            geometry = MultiLineString._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPolygon:
            geometry = MultiPolygon._parseGeoJSON(value); break;
        case Types.geoJSON.GeometryCollection:
            geometry = GeometryCollection._parseGeoJSON(value); break;
        default:
            throw new Error('GeometryType ' + value.type + ' not supported');
    }

    if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {
        var crs = value.crs.properties.name;

        if (crs.indexOf('EPSG:') === 0)
            geometry.srid = parseInt(crs.substring(5));
        else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0)
            geometry.srid = parseInt(crs.substring(22));
        else
            throw new Error('Unsupported crs: ' + crs);
    }
    else if (!isSubGeometry) {
        geometry.srid = 4326;
    }

    return geometry;
};

Geometry.prototype.toEwkt = function () {
    return 'SRID=' + this.srid + ';' + this.toWkt();
};

Geometry.prototype.toEwkb = function () {
    var ewkb = new BinaryWriter(this._getWkbSize() + 4);
    var wkb = this.toWkb();

    ewkb.writeInt8(1);
    ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);
    ewkb.writeUInt32LE(this.srid);

    ewkb.writeBuffer(wkb.slice(5));

    return ewkb.buffer;
};

Geometry.prototype._getWktType = function (wktType, isEmpty) {
    var wkt = wktType;

    if (this.hasZ && this.hasM)
        wkt += ' ZM ';
    else if (this.hasZ)
        wkt += ' Z ';
    else if (this.hasM)
        wkt += ' M ';

    if (isEmpty && !this.hasZ && !this.hasM)
        wkt += ' ';

    if (isEmpty)
        wkt += 'EMPTY';

    return wkt;
};

Geometry.prototype._getWktCoordinate = function (point) {
    var coordinates = point.x + ' ' + point.y;

    if (this.hasZ)
        coordinates += ' ' + point.z;
    if (this.hasM)
        coordinates += ' ' + point.m;

    return coordinates;
};

Geometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {
    var dimensionType = 0;

    if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {
        if (this.hasZ && this.hasM)
            dimensionType += 3000;
        else if (this.hasZ)
            dimensionType += 1000;
        else if (this.hasM)
            dimensionType += 2000;
    }
    else {
        if (this.hasZ)
            dimensionType |= 0x80000000;
        if (this.hasM)
            dimensionType |= 0x40000000;
    }

    wkb.writeUInt32LE((dimensionType + geometryType) >>> 0, true);
};

Geometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {
    return {
        xy: xyPrecision,
        z: zPrecision,
        m: mPrecision,
        xyFactor: Math.pow(10, xyPrecision),
        zFactor: Math.pow(10, zPrecision),
        mFactor: Math.pow(10, mPrecision)
    };
};

Geometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {
    var type = (ZigZag.encode(precision.xy) << 4) + geometryType;
    var metadataHeader = (this.hasZ || this.hasM) << 3;
    metadataHeader += isEmpty << 4;

    twkb.writeUInt8(type);
    twkb.writeUInt8(metadataHeader);

    if (this.hasZ || this.hasM) {
        var extendedPrecision = 0;
        if (this.hasZ)
            extendedPrecision |= 0x1;
        if (this.hasM)
            extendedPrecision |= 0x2;

        twkb.writeUInt8(extendedPrecision);
    }
};

Geometry.prototype.toGeoJSON = function (options) {
    var geoJSON = {};

    if (this.srid) {
        if (options) {
            if (options.shortCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'EPSG:' + this.srid
                    }
                };
            }
            else if (options.longCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'urn:ogc:def:crs:EPSG::' + this.srid
                    }
                };
            }
        }
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometrycollection.js":
/*!****************************************************!*\
  !*** ./node_modules/wkx/lib/geometrycollection.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = GeometryCollection;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function GeometryCollection(geometries, srid) {
    Geometry.call(this);

    this.geometries = geometries || [];
	this.srid = srid;

    if (this.geometries.length > 0) {
        this.hasZ = this.geometries[0].hasZ;
        this.hasM = this.geometries[0].hasM;
    }
}

util.inherits(GeometryCollection, Geometry);

GeometryCollection.Z = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    return geometryCollection;
};

GeometryCollection.M = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection.ZM = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection._parseWkt = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return geometryCollection;

    value.expectGroupStart();

    do {
        geometryCollection.geometries.push(Geometry.parse(value));
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return geometryCollection;
};

GeometryCollection._parseWkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    var geometryCount = value.readUInt32();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parse(value, options));

    return geometryCollection;
};

GeometryCollection._parseTwkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (options.isEmpty)
        return geometryCollection;

    var geometryCount = value.readVarInt();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parseTwkb(value));

    return geometryCollection;
};

GeometryCollection._parseGeoJSON = function (value) {
    var geometryCollection = new GeometryCollection();

    for (var i = 0; i < value.geometries.length; i++)
        geometryCollection.geometries.push(Geometry._parseGeoJSON(value.geometries[i], true));

    if (geometryCollection.geometries.length > 0)
        geometryCollection.hasZ = geometryCollection.geometries[0].hasZ;

    return geometryCollection;
};

GeometryCollection.prototype.toWkt = function () {
    if (this.geometries.length === 0)
        return this._getWktType(Types.wkt.GeometryCollection, true);

    var wkt = this._getWktType(Types.wkt.GeometryCollection, false) + '(';

    for (var i = 0; i < this.geometries.length; i++)
        wkt += this.geometries[i].toWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

GeometryCollection.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.GeometryCollection);
    wkb.writeUInt32LE(this.geometries.length);

    for (var i = 0; i < this.geometries.length; i++)
        wkb.writeBuffer(this.geometries[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

GeometryCollection.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.geometries.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.GeometryCollection, precision, isEmpty);

    if (this.geometries.length > 0) {
        twkb.writeVarInt(this.geometries.length);

        for (var i = 0; i < this.geometries.length; i++)
            twkb.writeBuffer(this.geometries[i].toTwkb());
    }

    return twkb.buffer;
};

GeometryCollection.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.geometries.length; i++)
        size += this.geometries[i]._getWkbSize();

    return size;
};

GeometryCollection.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.GeometryCollection;
    geoJSON.geometries = [];

    for (var i = 0; i < this.geometries.length; i++)
        geoJSON.geometries.push(this.geometries[i].toGeoJSON());

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/linestring.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/linestring.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = LineString;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function LineString(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;

    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(LineString, Geometry);

LineString.Z = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    return lineString;
};

LineString.M = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasM = true;
    return lineString;
};

LineString.ZM = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    lineString.hasM = true;
    return lineString;
};

LineString._parseWkt = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return lineString;

    value.expectGroupStart();
    lineString.points.push.apply(lineString.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return lineString;
};

LineString._parseWkb = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readWkbPoint(value, options));

    return lineString;
};

LineString._parseTwkb = function (value, options) {
    var lineString = new LineString();
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (options.isEmpty)
        return lineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return lineString;
};

LineString._parseGeoJSON = function (value) {
    var lineString = new LineString();

    if (value.coordinates.length > 0)
        lineString.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        lineString.points.push(Point._readGeoJSONPoint(value.coordinates[i]));

    return lineString;
};

LineString.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.LineString, true);

    return this._getWktType(Types.wkt.LineString, false) + this._toInnerWkt();
};

LineString.prototype._toInnerWkt = function () {
    var innerWkt = '(';

    for (var i = 0; i < this.points.length; i++)
        innerWkt += this._getWktCoordinate(this.points[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    return innerWkt;
};

LineString.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.LineString, parentOptions);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        this.points[i]._writeWkbPoint(wkb);

    return wkb.buffer;
};

LineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.LineString, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

LineString.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

LineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.LineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++) {
        if (this.hasZ)
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y, this.points[i].z]);
        else
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y]);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multilinestring.js":
/*!*************************************************!*\
  !*** ./node_modules/wkx/lib/multilinestring.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiLineString;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiLineString(lineStrings, srid) {
    Geometry.call(this);

    this.lineStrings = lineStrings || [];
	this.srid = srid;

    if (this.lineStrings.length > 0) {
        this.hasZ = this.lineStrings[0].hasZ;
        this.hasM = this.lineStrings[0].hasM;
    }
}

util.inherits(MultiLineString, Geometry);

MultiLineString.Z = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    return multiLineString;
};

MultiLineString.M = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString.ZM = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString._parseWkt = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiLineString;

    value.expectGroupStart();

    do {
        value.expectGroupStart();
        multiLineString.lineStrings.push(new LineString(value.matchCoordinates(options)));
        value.expectGroupEnd();
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiLineString;
};

MultiLineString._parseWkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    var lineStringCount = value.readUInt32();

    for (var i = 0; i < lineStringCount; i++)
        multiLineString.lineStrings.push(Geometry.parse(value, options));

    return multiLineString;
};

MultiLineString._parseTwkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (options.isEmpty)
        return multiLineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var lineStringCount = value.readVarInt();

    for (var i = 0; i < lineStringCount; i++) {
        var lineString = new LineString();
        lineString.hasZ = options.hasZ;
        lineString.hasM = options.hasM;

        var pointCount = value.readVarInt();

        for (var j = 0; j < pointCount; j++)
            lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

        multiLineString.lineStrings.push(lineString);
    }

    return multiLineString;
};

MultiLineString._parseGeoJSON = function (value) {
    var multiLineString = new MultiLineString();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        multiLineString.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiLineString.lineStrings.push(LineString._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiLineString;
};

MultiLineString.prototype.toWkt = function () {
    if (this.lineStrings.length === 0)
        return this._getWktType(Types.wkt.MultiLineString, true);

    var wkt = this._getWktType(Types.wkt.MultiLineString, false) + '(';

    for (var i = 0; i < this.lineStrings.length; i++)
        wkt += this.lineStrings[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiLineString.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiLineString);
    wkb.writeUInt32LE(this.lineStrings.length);

    for (var i = 0; i < this.lineStrings.length; i++)
        wkb.writeBuffer(this.lineStrings[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiLineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.lineStrings.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiLineString, precision, isEmpty);

    if (this.lineStrings.length > 0) {
        twkb.writeVarInt(this.lineStrings.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.lineStrings.length; i++) {
            twkb.writeVarInt(this.lineStrings[i].points.length);

            for (var j = 0; j < this.lineStrings[i].points.length; j++)
                this.lineStrings[i].points[j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

MultiLineString.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.lineStrings.length; i++)
        size += this.lineStrings[i]._getWkbSize();

    return size;
};

MultiLineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiLineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.lineStrings.length; i++)
        geoJSON.coordinates.push(this.lineStrings[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipoint.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/multipoint.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPoint;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPoint(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;
	
    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(MultiPoint, Geometry);

MultiPoint.Z = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    return multiPoint;
};

MultiPoint.M = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint.ZM = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint._parseWkt = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPoint;

    value.expectGroupStart();
    multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return multiPoint;
};

MultiPoint._parseWkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Geometry.parse(value, options));

    return multiPoint;
};

MultiPoint._parseTwkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (options.isEmpty)
        return multiPoint;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return multiPoint;
};

MultiPoint._parseGeoJSON = function (value) {
    var multiPoint = new MultiPoint();

    if (value.coordinates.length > 0)
        multiPoint.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPoint.points.push(Point._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPoint;
};

MultiPoint.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.MultiPoint, true);

    var wkt = this._getWktType(Types.wkt.MultiPoint, false) + '(';

    for (var i = 0; i < this.points.length; i++)
        wkt += this._getWktCoordinate(this.points[i]) + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPoint.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPoint);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        wkb.writeBuffer(this.points[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPoint.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPoint, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

MultiPoint.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    coordinateSize += 5;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

MultiPoint.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPoint;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++)
        geoJSON.coordinates.push(this.points[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/multipolygon.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPolygon;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPolygon(polygons, srid) {
    Geometry.call(this);

    this.polygons = polygons || [];
	this.srid = srid;

    if (this.polygons.length > 0) {
        this.hasZ = this.polygons[0].hasZ;
        this.hasM = this.polygons[0].hasM;
    }
}

util.inherits(MultiPolygon, Geometry);

MultiPolygon.Z = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    return multiPolygon;
};

MultiPolygon.M = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon.ZM = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon._parseWkt = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPolygon;

    value.expectGroupStart();

    do {
        value.expectGroupStart();

        var exteriorRing = [];
        var interiorRings = [];

        value.expectGroupStart();
        exteriorRing.push.apply(exteriorRing, value.matchCoordinates(options));
        value.expectGroupEnd();

        while (value.isMatch([','])) {
            value.expectGroupStart();
            interiorRings.push(value.matchCoordinates(options));
            value.expectGroupEnd();
        }

        multiPolygon.polygons.push(new Polygon(exteriorRing, interiorRings));

        value.expectGroupEnd();

    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiPolygon;
};

MultiPolygon._parseWkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    var polygonCount = value.readUInt32();

    for (var i = 0; i < polygonCount; i++)
        multiPolygon.polygons.push(Geometry.parse(value, options));

    return multiPolygon;
};

MultiPolygon._parseTwkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (options.isEmpty)
        return multiPolygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var polygonCount = value.readVarInt();

    for (var i = 0; i < polygonCount; i++) {
        var polygon = new Polygon();
        polygon.hasZ = options.hasZ;
        polygon.hasM = options.hasM;

        var ringCount = value.readVarInt();
        var exteriorRingCount = value.readVarInt();

        for (var j = 0; j < exteriorRingCount; j++)
            polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        for (j = 1; j < ringCount; j++) {
            var interiorRing = [];

            var interiorRingCount = value.readVarInt();

            for (var k = 0; k < interiorRingCount; k++)
                interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

            polygon.interiorRings.push(interiorRing);
        }

        multiPolygon.polygons.push(polygon);
    }

    return multiPolygon;
};

MultiPolygon._parseGeoJSON = function (value) {
    var multiPolygon = new MultiPolygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0 && value.coordinates[0][0].length > 0)
        multiPolygon.hasZ = value.coordinates[0][0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPolygon.polygons.push(Polygon._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPolygon;
};

MultiPolygon.prototype.toWkt = function () {
    if (this.polygons.length === 0)
        return this._getWktType(Types.wkt.MultiPolygon, true);

    var wkt = this._getWktType(Types.wkt.MultiPolygon, false) + '(';

    for (var i = 0; i < this.polygons.length; i++)
        wkt += this.polygons[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPolygon.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPolygon);
    wkb.writeUInt32LE(this.polygons.length);

    for (var i = 0; i < this.polygons.length; i++)
        wkb.writeBuffer(this.polygons[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPolygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.polygons.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPolygon, precision, isEmpty);

    if (this.polygons.length > 0) {
        twkb.writeVarInt(this.polygons.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.polygons.length; i++) {
            twkb.writeVarInt(1 + this.polygons[i].interiorRings.length);

            twkb.writeVarInt(this.polygons[i].exteriorRing.length);

            for (var j = 0; j < this.polygons[i].exteriorRing.length; j++)
                this.polygons[i].exteriorRing[j]._writeTwkbPoint(twkb, precision, previousPoint);

            for (j = 0; j < this.polygons[i].interiorRings.length; j++) {
                twkb.writeVarInt(this.polygons[i].interiorRings[j].length);

                for (var k = 0; k < this.polygons[i].interiorRings[j].length; k++)
                    this.polygons[i].interiorRings[j][k]._writeTwkbPoint(twkb, precision, previousPoint);
            }
        }
    }

    return twkb.buffer;
};

MultiPolygon.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.polygons.length; i++)
        size += this.polygons[i]._getWkbSize();

    return size;
};

MultiPolygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPolygon;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.polygons.length; i++)
        geoJSON.coordinates.push(this.polygons[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/point.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/point.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Point;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Point(x, y, z, m, srid) {
    Geometry.call(this);

    this.x = x;
    this.y = y;
    this.z = z;
    this.m = m;
	this.srid = srid;

    this.hasZ = typeof this.z !== 'undefined';
    this.hasM = typeof this.m !== 'undefined';
}

util.inherits(Point, Geometry);

Point.Z = function (x, y, z, srid) {
    var point = new Point(x, y, z, undefined, srid);
    point.hasZ = true;
    return point;
};

Point.M = function (x, y, m, srid) {
    var point = new Point(x, y, undefined, m, srid);
    point.hasM = true;
    return point;
};

Point.ZM = function (x, y, z, m, srid) {
    var point = new Point(x, y, z, m, srid);
    point.hasZ = true;
    point.hasM = true;
    return point;
};

Point._parseWkt = function (value, options) {
    var point = new Point();
    point.srid = options.srid;
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return point;

    value.expectGroupStart();

    var coordinate = value.matchCoordinate(options);

    point.x = coordinate.x;
    point.y = coordinate.y;
    point.z = coordinate.z;
    point.m = coordinate.m;

    value.expectGroupEnd();

    return point;
};

Point._parseWkb = function (value, options) {
    var point = Point._readWkbPoint(value, options);
    point.srid = options.srid;
    return point;
};

Point._readWkbPoint = function (value, options) {
    return new Point(value.readDouble(), value.readDouble(),
        options.hasZ ? value.readDouble() : undefined,
        options.hasM ? value.readDouble() : undefined);
};

Point._parseTwkb = function (value, options) {
    var point = new Point();
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (options.isEmpty)
        return point;

    point.x = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.y = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.z = options.hasZ ? ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor : undefined;
    point.m = options.hasM ? ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor : undefined;

    return point;
};

Point._readTwkbPoint = function (value, options, previousPoint) {
    previousPoint.x += ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    previousPoint.y += ZigZag.decode(value.readVarInt()) / options.precisionFactor;

    if (options.hasZ)
        previousPoint.z += ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor;
    if (options.hasM)
        previousPoint.m += ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor;

    return new Point(previousPoint.x, previousPoint.y, previousPoint.z, previousPoint.m);
};

Point._parseGeoJSON = function (value) {
    return Point._readGeoJSONPoint(value.coordinates);
};

Point._readGeoJSONPoint = function (coordinates) {
    if (coordinates.length === 0)
        return new Point();

    if (coordinates.length > 2)
        return new Point(coordinates[0], coordinates[1], coordinates[2]);

    return new Point(coordinates[0], coordinates[1]);
};

Point.prototype.toWkt = function () {
    if (typeof this.x === 'undefined' && typeof this.y === 'undefined' &&
        typeof this.z === 'undefined' && typeof this.m === 'undefined')
        return this._getWktType(Types.wkt.Point, true);

    return this._getWktType(Types.wkt.Point, false) + '(' + this._getWktCoordinate(this) + ')';
};

Point.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);
    this._writeWkbType(wkb, Types.wkb.Point, parentOptions);

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined') {
        wkb.writeDoubleLE(NaN);
        wkb.writeDoubleLE(NaN);

        if (this.hasZ)
            wkb.writeDoubleLE(NaN);
        if (this.hasM)
            wkb.writeDoubleLE(NaN);
    }
    else {
        this._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Point.prototype._writeWkbPoint = function (wkb) {
    wkb.writeDoubleLE(this.x);
    wkb.writeDoubleLE(this.y);

    if (this.hasZ)
        wkb.writeDoubleLE(this.z);
    if (this.hasM)
        wkb.writeDoubleLE(this.m);
};

Point.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = typeof this.x === 'undefined' && typeof this.y === 'undefined';

    this._writeTwkbHeader(twkb, Types.wkb.Point, precision, isEmpty);

    if (!isEmpty)
        this._writeTwkbPoint(twkb, precision, new Point(0, 0, 0, 0));

    return twkb.buffer;
};

Point.prototype._writeTwkbPoint = function (twkb, precision, previousPoint) {
    var x = this.x * precision.xyFactor;
    var y = this.y * precision.xyFactor;
    var z = this.z * precision.zFactor;
    var m = this.m * precision.mFactor;

    twkb.writeVarInt(ZigZag.encode(x - previousPoint.x));
    twkb.writeVarInt(ZigZag.encode(y - previousPoint.y));
    if (this.hasZ)
        twkb.writeVarInt(ZigZag.encode(z - previousPoint.z));
    if (this.hasM)
        twkb.writeVarInt(ZigZag.encode(m - previousPoint.m));

    previousPoint.x = x;
    previousPoint.y = y;
    previousPoint.z = z;
    previousPoint.m = m;
};

Point.prototype._getWkbSize = function () {
    var size = 1 + 4 + 8 + 8;

    if (this.hasZ)
        size += 8;
    if (this.hasM)
        size += 8;

    return size;
};

Point.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Point;

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined')
        geoJSON.coordinates = [];
    else if (typeof this.z !== 'undefined')
        geoJSON.coordinates = [this.x, this.y, this.z];
    else
        geoJSON.coordinates = [this.x, this.y];

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/wkx/lib/polygon.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Polygon;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function Polygon(exteriorRing, interiorRings, srid) {
    Geometry.call(this);

    this.exteriorRing = exteriorRing || [];
    this.interiorRings = interiorRings || [];
	this.srid = srid;

    if (this.exteriorRing.length > 0) {
        this.hasZ = this.exteriorRing[0].hasZ;
        this.hasM = this.exteriorRing[0].hasM;
    }
}

util.inherits(Polygon, Geometry);

Polygon.Z = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    return polygon;
};

Polygon.M = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasM = true;
    return polygon;
};

Polygon.ZM = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    polygon.hasM = true;
    return polygon;
};

Polygon._parseWkt = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return polygon;

    value.expectGroupStart();

    value.expectGroupStart();
    polygon.exteriorRing.push.apply(polygon.exteriorRing, value.matchCoordinates(options));
    value.expectGroupEnd();

    while (value.isMatch([','])) {
        value.expectGroupStart();
        polygon.interiorRings.push(value.matchCoordinates(options));
        value.expectGroupEnd();
    }

    value.expectGroupEnd();

    return polygon;
};

Polygon._parseWkb = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    var ringCount = value.readUInt32();

    if (ringCount > 0) {
        var exteriorRingCount = value.readUInt32();

        for (var i = 0; i < exteriorRingCount; i++)
            polygon.exteriorRing.push(Point._readWkbPoint(value, options));

        for (i = 1; i < ringCount; i++) {
            var interiorRing = [];

            var interiorRingCount = value.readUInt32();

            for (var j = 0; j < interiorRingCount; j++)
                interiorRing.push(Point._readWkbPoint(value, options));

            polygon.interiorRings.push(interiorRing);
        }
    }

    return polygon;
};

Polygon._parseTwkb = function (value, options) {
    var polygon = new Polygon();
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (options.isEmpty)
        return polygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var ringCount = value.readVarInt();
    var exteriorRingCount = value.readVarInt();

    for (var i = 0; i < exteriorRingCount; i++)
        polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

    for (i = 1; i < ringCount; i++) {
        var interiorRing = [];

        var interiorRingCount = value.readVarInt();

        for (var j = 0; j < interiorRingCount; j++)
            interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        polygon.interiorRings.push(interiorRing);
    }

    return polygon;
};

Polygon._parseGeoJSON = function (value) {
    var polygon = new Polygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        polygon.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++) {
        if (i > 0)
            polygon.interiorRings.push([]);

        for (var j = 0; j  < value.coordinates[i].length; j++) {
            if (i === 0)
                polygon.exteriorRing.push(Point._readGeoJSONPoint(value.coordinates[i][j]));
            else
                polygon.interiorRings[i - 1].push(Point._readGeoJSONPoint(value.coordinates[i][j]));
        }
    }

    return polygon;
};

Polygon.prototype.toWkt = function () {
    if (this.exteriorRing.length === 0)
        return this._getWktType(Types.wkt.Polygon, true);

    return this._getWktType(Types.wkt.Polygon, false) + this._toInnerWkt();
};

Polygon.prototype._toInnerWkt = function () {
    var innerWkt = '((';

    for (var i = 0; i < this.exteriorRing.length; i++)
        innerWkt += this._getWktCoordinate(this.exteriorRing[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    for (i = 0; i < this.interiorRings.length; i++) {
        innerWkt += ',(';

        for (var j = 0; j < this.interiorRings[i].length; j++) {
            innerWkt += this._getWktCoordinate(this.interiorRings[i][j]) + ',';
        }

        innerWkt = innerWkt.slice(0, -1);
        innerWkt += ')';
    }

    innerWkt += ')';

    return innerWkt;
};

Polygon.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.Polygon, parentOptions);

    if (this.exteriorRing.length > 0) {
        wkb.writeUInt32LE(1 + this.interiorRings.length);
        wkb.writeUInt32LE(this.exteriorRing.length);
    }
    else {
        wkb.writeUInt32LE(0);
    }

    for (var i = 0; i < this.exteriorRing.length; i++)
        this.exteriorRing[i]._writeWkbPoint(wkb);

    for (i = 0; i < this.interiorRings.length; i++) {
        wkb.writeUInt32LE(this.interiorRings[i].length);

        for (var j = 0; j < this.interiorRings[i].length; j++)
            this.interiorRings[i][j]._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Polygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.exteriorRing.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.Polygon, precision, isEmpty);

    if (this.exteriorRing.length > 0) {
        twkb.writeVarInt(1 + this.interiorRings.length);

        twkb.writeVarInt(this.exteriorRing.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.exteriorRing.length; i++)
            this.exteriorRing[i]._writeTwkbPoint(twkb, precision, previousPoint);

        for (i = 0; i < this.interiorRings.length; i++) {
            twkb.writeVarInt(this.interiorRings[i].length);

            for (var j = 0; j < this.interiorRings[i].length; j++)
                this.interiorRings[i][j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

Polygon.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    var size = 1 + 4 + 4;

    if (this.exteriorRing.length > 0)
        size += 4 + (this.exteriorRing.length * coordinateSize);

    for (var i = 0; i < this.interiorRings.length; i++)
        size += 4 + (this.interiorRings[i].length * coordinateSize);

    return size;
};

Polygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Polygon;
    geoJSON.coordinates = [];

    if (this.exteriorRing.length > 0) {
        var exteriorRing = [];

        for (var i = 0; i < this.exteriorRing.length; i++) {
            if (this.hasZ)
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y, this.exteriorRing[i].z]);
            else
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y]);
        }

        geoJSON.coordinates.push(exteriorRing);
    }

    for (var j = 0; j < this.interiorRings.length; j++) {
        var interiorRing = [];

        for (var k = 0; k < this.interiorRings[j].length; k++) {
            if (this.hasZ)
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y, this.interiorRings[j][k].z]);
            else
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y]);
        }

        geoJSON.coordinates.push(interiorRing);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/types.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = {
    wkt: {
        Point: 'POINT',
        LineString: 'LINESTRING',
        Polygon: 'POLYGON',
        MultiPoint: 'MULTIPOINT',
        MultiLineString: 'MULTILINESTRING',
        MultiPolygon: 'MULTIPOLYGON',
        GeometryCollection: 'GEOMETRYCOLLECTION'
    },
    wkb: {
        Point: 1,
        LineString: 2,
        Polygon: 3,
        MultiPoint: 4,
        MultiLineString: 5,
        MultiPolygon: 6,
        GeometryCollection: 7
    },
    geoJSON: {
        Point: 'Point',
        LineString: 'LineString',
        Polygon: 'Polygon',
        MultiPoint: 'MultiPoint',
        MultiLineString: 'MultiLineString',
        MultiPolygon: 'MultiPolygon',
        GeometryCollection: 'GeometryCollection'
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/wktparser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkx/lib/wktparser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = WktParser;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");

function WktParser(value) {
    this.value = value;
    this.position = 0;
}

WktParser.prototype.match = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return tokens[i];
        }
    }

    return null;
};

WktParser.prototype.matchRegex = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        var match = this.value.substring(this.position).match(tokens[i]);

        if (match) {
            this.position += match[0].length;
            return match;
        }
    }

    return null;
};

WktParser.prototype.isMatch = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return true;
        }
    }

    return false;
};

WktParser.prototype.matchType = function () {
    var geometryType = this.match([Types.wkt.Point, Types.wkt.LineString, Types.wkt.Polygon, Types.wkt.MultiPoint,
    Types.wkt.MultiLineString, Types.wkt.MultiPolygon, Types.wkt.GeometryCollection]);

    if (!geometryType)
        throw new Error('Expected geometry type');

    return geometryType;
};

WktParser.prototype.matchDimension = function () {
    var dimension = this.match(['ZM', 'Z', 'M']);

    switch (dimension) {
        case 'ZM': return { hasZ: true, hasM: true };
        case 'Z': return { hasZ: true, hasM: false };
        case 'M': return { hasZ: false, hasM: true };
        default: return { hasZ: false, hasM: false };
    }
};

WktParser.prototype.expectGroupStart = function () {
    if (!this.isMatch(['(']))
        throw new Error('Expected group start');
};

WktParser.prototype.expectGroupEnd = function () {
    if (!this.isMatch([')']))
        throw new Error('Expected group end');
};

WktParser.prototype.matchCoordinate = function (options) {
    var match;

    if (options.hasZ && options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else if (options.hasZ || options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else
        match = this.matchRegex([/^(\S*)\s+([^\s,)]*)/]);

    if (!match)
        throw new Error('Expected coordinates');

    if (options.hasZ && options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4]));
    else if (options.hasZ)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]));
    else if (options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), undefined, parseFloat(match[3]));
    else
        return new Point(parseFloat(match[1]), parseFloat(match[2]));
};

WktParser.prototype.matchCoordinates = function (options) {
    var coordinates = [];

    do {
        var startsWithBracket = this.isMatch(['(']);

        coordinates.push(this.matchCoordinate(options));

        if (startsWithBracket)
            this.expectGroupEnd();
    } while (this.isMatch([',']));

    return coordinates;
};

WktParser.prototype.skipWhitespaces = function () {
    while (this.position < this.value.length && this.value[this.position] === ' ')
        this.position++;
};


/***/ }),

/***/ "./node_modules/wkx/lib/wkx.js":
/*!*************************************!*\
  !*** ./node_modules/wkx/lib/wkx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
exports.Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
exports.Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
exports.LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
exports.Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
exports.MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
exports.MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
exports.MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
exports.GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");

/***/ }),

/***/ "./node_modules/wkx/lib/zigzag.js":
/*!****************************************!*\
  !*** ./node_modules/wkx/lib/zigzag.js ***!
  \****************************************/
/***/ ((module) => {

module.exports = {
    encode: function (value) {
        return (value << 1) ^ (value >> 31);
    },
    decode: function (value) {
        return (value >> 1) ^ (-(value & 1));
    }
};


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("debug");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("glob");;

/***/ }),

/***/ "lodash/_baseIsNative":
/*!***************************************!*\
  !*** external "lodash/_baseIsNative" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/_baseIsNative");;

/***/ }),

/***/ "lru-cache":
/*!****************************!*\
  !*** external "lru-cache" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("lru-cache");;

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment");;

/***/ }),

/***/ "moment-timezone":
/*!**********************************!*\
  !*** external "moment-timezone" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment-timezone");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");;

/***/ })

};
exports.runtime =
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ "use strict";
/******/ 
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("082b30f08cb0926e0b2b")
/******/ })();
/******/ 
/******/ }
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2UvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2V8c3luYyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9kb3R0aWUvZG90dGllLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2luZmxlY3Rpb24vbGliL2luZmxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JldHJ5LWFzLXByb21pc2VkL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS1wb29sL2xpYi9BZ2dyZWdhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvRGVmZXJyZWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1Bvb2wuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1RpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYWxpYXMtaW5mZXJlbmNlL2FsaWFzLWluZmVyZW5jZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by9iZWxvbmdzLXRvLWFzc29jaWF0aW9uLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8vYmVsb25ncy10by5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvaGFzL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtb25lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvdW5pb24tYXNzb2NpYXRpb24tb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy90aHJvdWdoL3Rocm91Z2gtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXJlc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1zeW5jLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL2hvb2stb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NoYXJlZC9ob29rcy1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL3ZhbGlkYXRpb24tZmFpbGVkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWNvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1kZXN0cm95LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWZpbmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItaW5pdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXNhdmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItc3luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdXBzZXJ0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXZhbGlkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY29ubmVjdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNvdW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVmaW5lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmQtYWZ0ZXItZXhwYW5kLWluY2x1ZGUtYWxsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC1hZnRlci1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWluaXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtc2F2ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cHNlcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS12YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2FsbG93LW51bGwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvY29tbWVudC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9kZWZhdWx0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL3VuaXF1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvYXV0by1pbmNyZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvcHJpbWFyeS1rZXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy9jcmVhdGVkLWF0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvZGVsZXRlZC1hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL3VwZGF0ZWQtYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9pbmRleC9jcmVhdGUtaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWFjdGlvbi1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tY291bnQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWdldC1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9zaGFyZWQvbW9kZWwtY2xhc3MtZ2V0dGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvdGFibGUvdGFibGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3RhYmxlL3RhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL2RlZmF1bHQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3Njb3Blcy9zY29wZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL3Njb3BlLXRhYmxlLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3JlcG9zaXRvcnkvcmVwb3NpdG9yeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplfHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvdmFsaWRhdGlvbi1vbmx5L2RiLWRpYWxlY3QtZHVtbXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvb2JqZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2hhcmVkL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtYWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1hbHBoYW51bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFycmF5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1iZWZvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWNyZWRpdC1jYXJkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1lbWFpbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWlwLXY0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pcC12Ni5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtaXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWxvd2VyY2FzZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVtZXJpYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtdXBwZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy11cmwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLXV1aWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL21heC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL25vdC1lbXB0eS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vdmFsaWRhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1vbmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9taXhpbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvaGVscGVycy9xdW90ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0fHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktaW50ZXJmYWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9hZ2dyZWdhdGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9idWxrLXJlY29yZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2VhZ2VyLWxvYWRpbmctZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luc3RhbmNlLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL29wdGltaXN0aWMtbG9jay1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9xdWVyeS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9zZXF1ZWxpemUtc2NvcGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaG9va3MuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luc3RhbmNlLXZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL21vZGVsLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL29wZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3F1ZXJ5LXR5cGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc2VxdWVsaXplLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc3FsLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3RhYmxlLWhpbnRzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2RlcHJlY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvYnVpbGQvdG9wb3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvY29uZmlncy9zZXF1YWxpemUudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvc2VydmVyLnRzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2FscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvYmxhY2tsaXN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0FmdGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNBbHBoYS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQWxwaGFudW1lcmljLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNBc2NpaS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQmFzZTY0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNCZWZvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0Jvb2xlYW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0J5dGVMZW5ndGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0NyZWRpdENhcmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0N1cnJlbmN5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEYXRhVVJJLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEaXZpc2libGVCeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRW1haWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0VtcHR5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGUUROLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGbG9hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRnVsbFdpZHRoLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNIYWxmV2lkdGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hhc2guanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hleENvbG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNIZXhhZGVjaW1hbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lQUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTQk4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTSU4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTTzMxNjYxQWxwaGEyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJU08zMTY2MUFscGhhMy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNPODYwMS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNSQy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNTTi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSWRlbnRpdHlDYXJkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNKU09OLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNKV1QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0xhdExvbmcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTG93ZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNQUNBZGRyZXNzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNRDUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01hZ25ldFVSSS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTWltZVR5cGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01vYmlsZVBob25lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNb25nb0lkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNdWx0aWJ5dGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc051bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1BvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1Bvc3RhbENvZGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1JGQzMzMzkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1N1cnJvZ2F0ZVBhaXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1VSTC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzVVVJRC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzVXBwZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNWYXJpYWJsZVdpZHRoLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNXaGl0ZWxpc3RlZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2x0cmltLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvbWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL25vcm1hbGl6ZUVtYWlsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvcnRyaW0uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9zdHJpcExvdy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvQm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvRGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvRmxvYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi90b0ludC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RyaW0uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91bmVzY2FwZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvYXNzZXJ0U3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91dGlsL3RvU3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvd2hpdGVsaXN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvYmluYXJ5cmVhZGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvYmluYXJ5d3JpdGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvZ2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9nZW9tZXRyeWNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9saW5lc3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvbXVsdGlsaW5lc3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvbXVsdGlwb2ludC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL211bHRpcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3BvaW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3R5cGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvd2t0cGFyc2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvd2t4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvemlnemFnLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImRlYnVnXCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiZ2xvYlwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibG9kYXNoL19iYXNlSXNOYXRpdmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImxydS1jYWNoZVwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibW9tZW50XCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJtb21lbnQtdGltZXpvbmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXRpbFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXVpZFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUJBQWlCLG1CQUFPLENBQUMsMERBQVk7Ozs7Ozs7Ozs7OztBQ0F6QjtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdFWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxpRUFBUSxjQUFjLENBQUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVM7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxLQUE2QjtBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5Qjs7QUFFekIsUUFBUSxJQUE0QjtBQUNwQyxNQUFNLGlDQUFPLEVBQUUsbUNBQUUsYUFBYSxlQUFlLEVBQUU7QUFBQSxrR0FBQztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUMvTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUU7QUFDeEIsR0FBRyxLQUFLLEVBSUw7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3REFBd0QsdUNBQXVDO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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cEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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QTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsV0FBVyxTQUFTLEVBQUU7QUFDckY7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE4RixZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsZUFBZTtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUSxzQkFBc0IsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLHlEQUF5RCxtREFBbUQ7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULHVCQUF1QixlQUFlLEdBQUcsS0FBSztBQUM5Qzs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEUsd0NBQXdDO0FBQ3BIO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLFlBQVksSUFBSSxZQUFZO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEdBQTBHLFlBQVk7QUFDdEgsOEhBQThILFlBQVk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxvRUFBb0UsMERBQTBEO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsaUJBQWlCLFFBQVE7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkZBQWtDOztBQUV0RCxxQkFBcUIsVUFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FB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Q0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0VBQW9FO0FBQ3ZIO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSEEscUZBQWtDO0FBQ2xDLDhGQUF3QztBQUN4QyxxRkFBa0M7QUFDbEMsb0dBQTRDO0FBQzVDLDJGQUFzQztBQUN0QyxvR0FBNEM7QUFDNUMsbUhBQXNEO0FBQ3RELDBHQUFnRDtBQUNoRCw0SEFBNEQsQzs7Ozs7Ozs7OztBQ1I1RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BBLG9DOzs7Ozs7Ozs7OztBQ0FBLG9DOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLGtEOzs7Ozs7Ozs7OztBQ0FBLHVDOzs7Ozs7Ozs7OztBQ0FBLG9DOzs7Ozs7Ozs7OztBQ0FBLDZDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztVQ0FBLHNEIiwiZmlsZSI6Im1haW4uMWQ0ZTI1OGUzODFmN2Q5MmQ0OTUuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWdpc3RlcicpKCkuUHJvbWlzZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcbiAgICAvLyBnbG9iYWwga2V5IGZvciB1c2VyIHByZWZlcnJlZCByZWdpc3RyYXRpb25cbnZhciBSRUdJU1RSQVRJT05fS0VZID0gJ0BAYW55LXByb21pc2UvUkVHSVNUUkFUSU9OJyxcbiAgICAvLyBQcmlvciByZWdpc3RyYXRpb24gKHByZWZlcnJlZCBvciBkZXRlY3RlZClcbiAgICByZWdpc3RlcmVkID0gbnVsbFxuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaW1wbGVtZW50YXRpb24uICBBbiBpbXBsZW1lbnRhdGlvbiBtdXN0XG4gKiBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGFueSBjYWxsIHRvIGByZXF1aXJlKFwiYW55LXByb21pc2VcIilgLFxuICogdHlwaWNhbGx5IG9uIGFwcGxpY2F0aW9uIGxvYWQuXG4gKlxuICogSWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB3aWxsIHJldHVybiByZWdpc3RyYXRpb24gaW5cbiAqIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqXG4gKiBGb3IgTm9kZS5qczpcbiAqXG4gKiAxLiBQcmV2aW91cyByZWdpc3RyYXRpb25cbiAqIDIuIGdsb2JhbC5Qcm9taXNlIGlmIG5vZGUuanMgdmVyc2lvbiA+PSAwLjEyXG4gKiAzLiBBdXRvIGRldGVjdGVkIHByb21pc2UgYmFzZWQgb24gZmlyc3Qgc3VjZXNzZnVsIHJlcXVpcmUgb2ZcbiAqICAgIGtub3duIHByb21pc2UgbGlicmFyaWVzLiBOb3RlIHRoaXMgaXMgYSBsYXN0IHJlc29ydCwgYXMgdGhlXG4gKiAgICBsb2FkZWQgbGlicmFyeSBpcyBub24tZGV0ZXJtaW5pc3RpYy4gbm9kZS5qcyA+PSAwLjEyIHdpbGxcbiAqICAgIGFsd2F5cyB1c2UgZ2xvYmFsLlByb21pc2Ugb3ZlciB0aGlzIHByaW9yaXR5IGxpc3QuXG4gKiA0LiBUaHJvd3MgZXJyb3IuXG4gKlxuICogRm9yIEJyb3dzZXI6XG4gKlxuICogMS4gUHJldmlvdXMgcmVnaXN0cmF0aW9uXG4gKiAyLiB3aW5kb3cuUHJvbWlzZVxuICogMy4gVGhyb3dzIGVycm9yLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogUHJvbWlzZTogRGVzaXJlZCBQcm9taXNlIGNvbnN0cnVjdG9yXG4gKiBnbG9iYWw6IEJvb2xlYW4gLSBTaG91bGQgdGhlIHJlZ2lzdHJhdGlvbiBiZSBjYWNoZWQgaW4gYSBnbG9iYWwgdmFyaWFibGUgdG9cbiAqIGFsbG93IGNyb3NzIGRlcGVuZGVuY3kvYnVuZGxlIHJlZ2lzdHJhdGlvbj8gIChkZWZhdWx0IHRydWUpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocm9vdCwgbG9hZEltcGxlbWVudGF0aW9uKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlZ2lzdGVyKGltcGxlbWVudGF0aW9uLCBvcHRzKXtcbiAgICBpbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uIHx8IG51bGxcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb24gdW5sZXNzIGV4cGxpY2l0bHkgIHtnbG9iYWw6IGZhbHNlfSBpbiBvcHRpb25zIChkZWZhdWx0IHRydWUpXG4gICAgdmFyIHJlZ2lzdGVyR2xvYmFsID0gb3B0cy5nbG9iYWwgIT09IGZhbHNlO1xuXG4gICAgLy8gbG9hZCBhbnkgcHJldmlvdXMgZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgIGlmKHJlZ2lzdGVyZWQgPT09IG51bGwgJiYgcmVnaXN0ZXJHbG9iYWwpe1xuICAgICAgcmVnaXN0ZXJlZCA9IHJvb3RbUkVHSVNUUkFUSU9OX0tFWV0gfHwgbnVsbFxuICAgIH1cblxuICAgIGlmKHJlZ2lzdGVyZWQgIT09IG51bGxcbiAgICAgICAgJiYgaW1wbGVtZW50YXRpb24gIT09IG51bGxcbiAgICAgICAgJiYgcmVnaXN0ZXJlZC5pbXBsZW1lbnRhdGlvbiAhPT0gaW1wbGVtZW50YXRpb24pe1xuICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgYXR0ZW1wdGluZyB0byByZWRlZmluZSBpbXBsZW1lbnRhdGlvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbnktcHJvbWlzZSBhbHJlYWR5IGRlZmluZWQgYXMgXCInK3JlZ2lzdGVyZWQuaW1wbGVtZW50YXRpb24rXG4gICAgICAgICdcIi4gIFlvdSBjYW4gb25seSByZWdpc3RlciBhbiBpbXBsZW1lbnRhdGlvbiBiZWZvcmUgdGhlIGZpcnN0ICcrXG4gICAgICAgICcgY2FsbCB0byByZXF1aXJlKFwiYW55LXByb21pc2VcIikgYW5kIGFuIGltcGxlbWVudGF0aW9uIGNhbm5vdCBiZSBjaGFuZ2VkJylcbiAgICB9XG5cbiAgICBpZihyZWdpc3RlcmVkID09PSBudWxsKXtcbiAgICAgIC8vIHVzZSBwcm92aWRlZCBpbXBsZW1lbnRhdGlvblxuICAgICAgaWYoaW1wbGVtZW50YXRpb24gIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICByZWdpc3RlcmVkID0ge1xuICAgICAgICAgIFByb21pc2U6IG9wdHMuUHJvbWlzZSxcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZSBpbXBsZW1lbnRhdGlvbiBpZiBpbXBsZW1lbnRhdGlvbiBpcyBzcGVjaWZpZWQgYnV0IG5vdCBwcm92aWRlZFxuICAgICAgICByZWdpc3RlcmVkID0gbG9hZEltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKVxuICAgICAgfVxuXG4gICAgICBpZihyZWdpc3Rlckdsb2JhbCl7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHByZWZlcmVuY2UgZ2xvYmFsbHkgaW4gY2FzZSBtdWx0aXBsZSBpbnN0YWxsYXRpb25zXG4gICAgICAgIHJvb3RbUkVHSVNUUkFUSU9OX0tFWV0gPSByZWdpc3RlcmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sb2FkZXInKShnbG9iYWwsIGxvYWRJbXBsZW1lbnRhdGlvbik7XG5cbi8qKlxuICogTm9kZS5qcyB2ZXJzaW9uIG9mIGxvYWRJbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBSZXF1aXJlcyB0aGUgZ2l2ZW4gaW1wbGVtZW50YXRpb24gYW5kIHJldHVybnMgdGhlIHJlZ2lzdHJhdGlvblxuICogY29udGFpbmluZyB7UHJvbWlzZSwgaW1wbGVtZW50YXRpb259XG4gKlxuICogSWYgaW1wbGVtZW50YXRpb24gaXMgdW5kZWZpbmVkIG9yIGdsb2JhbC5Qcm9taXNlLCBsb2FkcyBpdFxuICogT3RoZXJ3aXNlIHVzZXMgcmVxdWlyZVxuICovXG5mdW5jdGlvbiBsb2FkSW1wbGVtZW50YXRpb24oaW1wbGVtZW50YXRpb24pe1xuICB2YXIgaW1wbCA9IG51bGxcblxuICBpZihzaG91bGRQcmVmZXJHbG9iYWxQcm9taXNlKGltcGxlbWVudGF0aW9uKSl7XG4gICAgLy8gaWYgbm8gaW1wbGVtZW50YXRpb24gb3IgZW52IHNwZWNpZmllZCB1c2UgZ2xvYmFsLlByb21pc2VcbiAgICBpbXBsID0ge1xuICAgICAgUHJvbWlzZTogZ2xvYmFsLlByb21pc2UsXG4gICAgICBpbXBsZW1lbnRhdGlvbjogJ2dsb2JhbC5Qcm9taXNlJ1xuICAgIH1cbiAgfSBlbHNlIGlmKGltcGxlbWVudGF0aW9uKXtcbiAgICAvLyBpZiBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpZWQsIHJlcXVpcmUgaXRcbiAgICB2YXIgbGliID0gcmVxdWlyZShpbXBsZW1lbnRhdGlvbilcbiAgICBpbXBsID0ge1xuICAgICAgUHJvbWlzZTogbGliLlByb21pc2UgfHwgbGliLFxuICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHRyeSB0byBhdXRvIGRldGVjdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyBpcyBub24tZGV0ZXJtaW5pc3RpY1xuICAgIC8vIGFuZCBzaG91bGQgcHJlZmVyIG90aGVyIGJyYW5jaGVzLCBidXQgdGhpcyBpcyBvdXIgbGFzdCBjaGFuY2VcbiAgICAvLyB0byBsb2FkIHNvbWV0aGluZyB3aXRob3V0IHRocm93aW5nIGVycm9yXG4gICAgaW1wbCA9IHRyeUF1dG9EZXRlY3QoKVxuICB9XG5cbiAgaWYoaW1wbCA9PT0gbnVsbCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhbnktcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBub3InK1xuICAgICAgJyBnbG9iYWwuUHJvbWlzZS4gWW91IG11c3QgaW5zdGFsbCBwb2x5ZmlsbCBvciBjYWxsJytcbiAgICAgICcgcmVxdWlyZShcImFueS1wcm9taXNlL3JlZ2lzdGVyXCIpIHdpdGggeW91ciBwcmVmZXJyZWQnK1xuICAgICAgJyBpbXBsZW1lbnRhdGlvbiwgZS5nLiByZXF1aXJlKFwiYW55LXByb21pc2UvcmVnaXN0ZXIvYmx1ZWJpcmRcIiknK1xuICAgICAgJyBvbiBhcHBsaWNhdGlvbiBsb2FkIHByaW9yIHRvIGFueSByZXF1aXJlKFwiYW55LXByb21pc2VcIikuJylcbiAgfVxuXG4gIHJldHVybiBpbXBsXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2xvYmFsLlByb21pc2Ugc2hvdWxkIGJlIHByZWZlcnJlZCBpZiBhbiBpbXBsZW1lbnRhdGlvblxuICogaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByZWZlckdsb2JhbFByb21pc2UoaW1wbGVtZW50YXRpb24pe1xuICBpZihpbXBsZW1lbnRhdGlvbil7XG4gICAgcmV0dXJuIGltcGxlbWVudGF0aW9uID09PSAnZ2xvYmFsLlByb21pc2UnXG4gIH0gZWxzZSBpZih0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICd1bmRlZmluZWQnKXtcbiAgICAvLyBMb2FkIGdsb2JhbCBwcm9taXNlIGlmIGltcGxlbWVudGF0aW9uIG5vdCBzcGVjaWZpZWRcbiAgICAvLyBWZXJzaW9ucyA8IDAuMTEgZGlkIG5vdCBoYXZlIGdsb2JhbCBQcm9taXNlXG4gICAgLy8gRG8gbm90IHVzZSBmb3IgdmVyc2lvbiA8IDAuMTIgYXMgdmVyc2lvbiAwLjExIGNvbnRhaW5lZCBidWdneSB2ZXJzaW9uc1xuICAgIHZhciB2ZXJzaW9uID0gKC92KFxcZCspXFwuKFxcZCspXFwuKFxcZCspLykuZXhlYyhwcm9jZXNzLnZlcnNpb24pXG4gICAgcmV0dXJuICEodmVyc2lvbiAmJiArdmVyc2lvblsxXSA9PSAwICYmICt2ZXJzaW9uWzJdIDwgMTIpXG4gIH1cblxuICAvLyBkbyBub3QgaGF2ZSBnbG9iYWwuUHJvbWlzZSBvciBhbm90aGVyIGltcGxlbWVudGF0aW9uIHdhcyBzcGVjaWZpZWRcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogTG9vayBmb3IgY29tbW9uIGxpYnMgYXMgbGFzdCByZXNvcnQgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXRcbiAqIHRoaXMgd2lsbCByZXR1cm4gYSBkZXNpcmVkIGltcGxlbWVudGF0aW9uIG9yIGV2ZW4gYmUgZGV0ZXJtaW5pc3RpYy5cbiAqIFRoZSBwcmlvcml0eSBpcyBhbHNvIG5lYXJseSBhcmJpdHJhcnkuIFdlIGFyZSBvbmx5IGRvaW5nIHRoaXNcbiAqIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIDwwLjEyIHRoYXQgZG8gbm90IGhhdmUgYSByZWFzb25hYmxlXG4gKiBnbG9iYWwuUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBhbmQgd2UgdGhlIHVzZXIgaGFzIG5vdCByZWdpc3RlcmVkXG4gKiB0aGUgcHJlZmVyZW5jZS4gVGhpcyBwcmVzZXJ2ZXMgdGhlIGJlaGF2aW9yIG9mIGFueS1wcm9taXNlIDw9IDAuMVxuICogYW5kIG1heSBiZSBkZXByZWNhdGVkIG9yIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZVxuICovXG5mdW5jdGlvbiB0cnlBdXRvRGV0ZWN0KCl7XG4gIHZhciBsaWJzID0gW1xuICAgICAgXCJlczYtcHJvbWlzZVwiLFxuICAgICAgXCJwcm9taXNlXCIsXG4gICAgICBcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIixcbiAgICAgIFwiYmx1ZWJpcmRcIixcbiAgICAgIFwicnN2cFwiLFxuICAgICAgXCJ3aGVuXCIsXG4gICAgICBcInFcIixcbiAgICAgIFwicGlua2llXCIsXG4gICAgICBcImxpZVwiLFxuICAgICAgXCJ2b3dcIl1cbiAgdmFyIGkgPSAwLCBsZW4gPSBsaWJzLmxlbmd0aFxuICBmb3IoOyBpIDwgbGVuOyBpKyspe1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbG9hZEltcGxlbWVudGF0aW9uKGxpYnNbaV0pXG4gICAgfSBjYXRjaChlKXt9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbiIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gKCkgPT4gKFtdKTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZSBzeW5jIHJlY3Vyc2l2ZVwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0OyIsIihmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFdlaXJkIElFIHNoaXQsIG9iamVjdHMgZG8gbm90IGhhdmUgaGFzT3duLCBidXQgdGhlIHByb3RvdHlwZSBkb2VzLi4uXG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICB2YXIgcmV2ZXJzZUR1cEFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIHZhciBpbmRleCAgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGFycmF5TWF4SW5kZXggPSBpbmRleCAtIDE7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgcmVzdWx0W2FycmF5TWF4SW5kZXggLSBpbmRleF0gPSBhcnJheVtpbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgRG90dGllID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcbiAgICAgIHJldHVybiBEb3R0aWUuZmluZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIERvdHRpZS50cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG5cbiAgLy8gTGVnYWN5IHN5bnRheCwgY2hhbmdlZCBzeW50YXggdG8gaGF2ZSBnZXQvc2V0IGJlIHNpbWlsYXIgaW4gYXJnIG9yZGVyXG4gIERvdHRpZS5maW5kID0gZnVuY3Rpb24ocGF0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIERvdHRpZS5nZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcblxuICAvLyBEb3R0aWUgbWVtb2l6YXRpb24gZmxhZ1xuICBEb3R0aWUubWVtb2l6ZVBhdGggPSB0cnVlO1xuICB2YXIgbWVtb2l6ZWQgPSB7fTtcblxuICAvLyBUcmF2ZXJzZSBvYmplY3QgYWNjb3JkaW5nIHRvIHBhdGgsIHJldHVybiB2YWx1ZSBpZiBmb3VuZCAtIFJldHVybiB1bmRlZmluZWQgaWYgZGVzdGluYXRpb24gaXMgdW5yZWFjaGFibGVcbiAgRG90dGllLmdldCA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbCkge1xuICAgIGlmICgob2JqZWN0ID09PSB1bmRlZmluZWQpIHx8IChvYmplY3QgPT09IG51bGwpIHx8IChwYXRoID09PSB1bmRlZmluZWQpIHx8IChwYXRoID09PSBudWxsKSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbDtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXM7XG5cbiAgICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChEb3R0aWUubWVtb2l6ZVBhdGgpIHtcbiAgICAgICAgaWYgKG1lbW9pemVkW3BhdGhdKSB7XG4gICAgICAgICAgbmFtZXMgPSBtZW1vaXplZFtwYXRoXS5zbGljZSgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gICAgICAgICAgbWVtb2l6ZWRbcGF0aF0gPSBuYW1lcy5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXMgPSBwYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgbmFtZXMgPSByZXZlcnNlRHVwQXJyYXkocGF0aCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5hbWVzLmxlbmd0aCAmJiAob2JqZWN0ID0gb2JqZWN0W25hbWVzLnBvcCgpXSkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgIT09IG51bGwpO1xuXG4gICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIGFjY2Vzc2luZyBhIGNoaWxkcHJvcCBvZiBhIG51bGwgdmFsdWVcbiAgICBpZiAob2JqZWN0ID09PSBudWxsICYmIG5hbWVzLmxlbmd0aCkgb2JqZWN0ID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIChvYmplY3QgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWwgOiBvYmplY3QpO1xuICB9O1xuXG4gIERvdHRpZS5leGlzdHMgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgpIHtcbiAgICByZXR1cm4gRG90dGllLmdldChvYmplY3QsIHBhdGgpICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gU2V0IG5lc3RlZCB2YWx1ZVxuICBEb3R0aWUuc2V0ID0gZnVuY3Rpb24ob2JqZWN0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBwaWVjZXMgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKSwgY3VycmVudCA9IG9iamVjdCwgcGllY2UsIGxlbmd0aCA9IHBpZWNlcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGlzIG5vdCBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcGllY2UgPSBwaWVjZXNbaW5kZXhdO1xuXG4gICAgICAvLyBDcmVhdGUgbmFtZXNwYWNlIChvYmplY3QpIHdoZXJlIG5vbmUgZXhpc3RzLlxuICAgICAgLy8gSWYgYGZvcmNlID09PSB0cnVlYCwgYnJ1dGVmb3JjZSB0aGUgcGF0aCB3aXRob3V0IHRocm93aW5nIGVycm9ycy5cbiAgICAgIGlmICghaGFzT3duUHJvcC5jYWxsKGN1cnJlbnQsIHBpZWNlKSB8fCBjdXJyZW50W3BpZWNlXSA9PT0gdW5kZWZpbmVkIHx8ICh0eXBlb2YgY3VycmVudFtwaWVjZV0gIT09ICdvYmplY3QnICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgY3VycmVudFtwaWVjZV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09IChsZW5ndGggLSAxKSkge1xuICAgICAgICAvLyBTZXQgZmluYWwgdmFsdWVcbiAgICAgICAgY3VycmVudFtwaWVjZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBvdmVyd3JpdGUgZXhpc3RpbmcgcGF0aCBwaWVjZXMgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRbcGllY2VdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IGtleSBcIicgKyBwaWVjZSArICdcIiBpcyBub3Qgc3VpdGFibGUgZm9yIGEgbmVzdGVkIHZhbHVlLiAoSXQgaXMgaW4gdXNlIGFzIG5vbi1vYmplY3QuIFNldCBgZm9yY2VgIHRvIGB0cnVlYCB0byBvdmVycmlkZS4pJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSBuZXh0IGluIHBhdGhcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGllY2VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElzIHRoZXJlIGFueSBjYXNlIHdoZW4gdGhpcyBpcyByZWxldmFudD8gSXQncyBhbHNvIHRoZSBsYXN0IGxpbmUgaW4gdGhlIGFib3ZlIGZvci1sb29wXG4gICAgY3VycmVudFtwaWVjZV0gPSB2YWx1ZTtcbiAgfTtcblxuICAvLyBTZXQgZGVmYXVsdCBuZXN0ZWQgdmFsdWVcbiAgRG90dGllWydkZWZhdWx0J10gPSBmdW5jdGlvbihvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKERvdHRpZS5nZXQob2JqZWN0LCBwYXRoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBEb3R0aWUuc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUcmFuc2Zvcm0gdW5uZXN0ZWQgb2JqZWN0IHdpdGggLi1zZXBlcmF0ZWQga2V5cyBpbnRvIGEgbmVzdGVkIG9iamVjdC5cbiAgRG90dGllLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIERvdHRpZSR0cmFuc2Zvcm1mdW5jdGlvbihvYmplY3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Lm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBEb3R0aWUudHJhbnNmb3JtKG8sIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlciB8fCAnLic7XG5cbiAgICB2YXIgcGllY2VzXG4gICAgICAsIHBpZWNlc0xlbmd0aFxuICAgICAgLCBwaWVjZVxuICAgICAgLCBjdXJyZW50XG4gICAgICAsIHRyYW5zZm9ybWVkID0ge31cbiAgICAgICwga2V5XG4gICAgICAsIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkuaW5kZXhPZihvcHRpb25zLmRlbGltaXRlcikgIT09IC0xKSB7XG4gICAgICAgIHBpZWNlcyA9IGtleS5zcGxpdChvcHRpb25zLmRlbGltaXRlcik7XG4gICAgICAgIHBpZWNlc0xlbmd0aCA9IHBpZWNlcy5sZW5ndGg7XG4gICAgICAgIGN1cnJlbnQgPSB0cmFuc2Zvcm1lZDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGllY2VzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgcGllY2UgPSBwaWVjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChpbmRleCAhPSAocGllY2VzTGVuZ3RoIC0gMSkgJiYgIWN1cnJlbnQuaGFzT3duUHJvcGVydHkocGllY2UpKSB7XG4gICAgICAgICAgICBjdXJyZW50W3BpZWNlXSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCA9PSAocGllY2VzTGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbcGllY2VdID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGllY2VdO1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zZm9ybWVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH07XG5cbiAgRG90dGllLmZsYXR0ZW4gPSBmdW5jdGlvbihvYmplY3QsIHNlcGVyYXRvcikge1xuICAgIGlmICh0eXBlb2Ygc2VwZXJhdG9yID09PSBcInVuZGVmaW5lZFwiKSBzZXBlcmF0b3IgPSAnLic7XG4gICAgdmFyIGZsYXR0ZW5lZCA9IHt9XG4gICAgICAsIGN1cnJlbnRcbiAgICAgICwgbmVzdGVkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKGhhc093blByb3AuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgY3VycmVudCA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGN1cnJlbnQpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgbmVzdGVkID0gRG90dGllLmZsYXR0ZW4oY3VycmVudCwgc2VwZXJhdG9yKTtcblxuICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gbmVzdGVkKSB7XG4gICAgICAgICAgICBmbGF0dGVuZWRba2V5K3NlcGVyYXRvcitfa2V5XSA9IG5lc3RlZFtfa2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdHRlbmVkW2tleV0gPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgfTtcblxuICBEb3R0aWUucGF0aHMgPSBmdW5jdGlvbihvYmplY3QsIHByZWZpeGVzKSB7XG4gICAgdmFyIHBhdGhzID0gW107XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBrZXk7XG5cbiAgICBwcmVmaXhlcyA9IHByZWZpeGVzIHx8IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMuY29uY2F0KERvdHRpZS5wYXRocyh2YWx1ZSwgcHJlZml4ZXMuY29uY2F0KFtrZXldKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhzLnB1c2gocHJlZml4ZXMuY29uY2F0KGtleSkuam9pbignLicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGhzIHdhcyBjYWxsZWQgd2l0aCBub24tb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb3R0aWU7XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnRG90dGllJ10gPSBEb3R0aWU7XG4gICAgcm9vdFsnRG90J10gPSBEb3R0aWU7IC8vQkNcblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gRG90dGllOyB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCIvKiFcbiAqIGluZmxlY3Rpb25cbiAqIENvcHlyaWdodChjKSAyMDExIEJlbiBMaW4gPGJlbkBkcmVhbWVyc2xhYi5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBBIHBvcnQgb2YgaW5mbGVjdGlvbi1qcyB0byBub2RlLmpzIG1vZHVsZS5cbiAqL1xuXG4oIGZ1bmN0aW9uICggcm9vdCwgZmFjdG9yeSApe1xuICBpZiggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICl7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5ICk7XG4gIH1lbHNlIGlmKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfWVsc2V7XG4gICAgcm9vdC5pbmZsZWN0aW9uID0gZmFjdG9yeSgpO1xuICB9XG59KCB0aGlzLCBmdW5jdGlvbiAoKXtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBsaXN0IG9mIG5vdW5zIHRoYXQgdXNlIHRoZSBzYW1lIGZvcm0gZm9yIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbC5cbiAgICogICAgICAgICAgICAgIFRoaXMgbGlzdCBzaG91bGQgcmVtYWluIGVudGlyZWx5IGluIGxvd2VyIGNhc2UgdG8gY29ycmVjdGx5IG1hdGNoIFN0cmluZ3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgdW5jb3VudGFibGVfd29yZHMgPSBbXG4gICAgLy8gJ2FjY2VzcycsXG4gICAgJ2FjY29tbW9kYXRpb24nLFxuICAgICdhZHVsdGhvb2QnLFxuICAgICdhZHZlcnRpc2luZycsXG4gICAgJ2FkdmljZScsXG4gICAgJ2FnZ3Jlc3Npb24nLFxuICAgICdhaWQnLFxuICAgICdhaXInLFxuICAgICdhaXJjcmFmdCcsXG4gICAgJ2FsY29ob2wnLFxuICAgICdhbmdlcicsXG4gICAgJ2FwcGxhdXNlJyxcbiAgICAnYXJpdGhtZXRpYycsXG4gICAgLy8gJ2FydCcsXG4gICAgJ2Fzc2lzdGFuY2UnLFxuICAgICdhdGhsZXRpY3MnLFxuICAgIC8vICdhdHRlbnRpb24nLFxuXG4gICAgJ2JhY29uJyxcbiAgICAnYmFnZ2FnZScsXG4gICAgLy8gJ2JhbGxldCcsXG4gICAgLy8gJ2JlYXV0eScsXG4gICAgJ2JlZWYnLFxuICAgIC8vICdiZWVyJyxcbiAgICAvLyAnYmVoYXZpb3InLFxuICAgICdiaW9sb2d5JyxcbiAgICAvLyAnYmlsbGlhcmRzJyxcbiAgICAnYmxvb2QnLFxuICAgICdib3RhbnknLFxuICAgIC8vICdib3dlbHMnLFxuICAgICdicmVhZCcsXG4gICAgLy8gJ2J1c2luZXNzJyxcbiAgICAnYnV0dGVyJyxcblxuICAgICdjYXJib24nLFxuICAgICdjYXJkYm9hcmQnLFxuICAgICdjYXNoJyxcbiAgICAnY2hhbGsnLFxuICAgICdjaGFvcycsXG4gICAgJ2NoZXNzJyxcbiAgICAnY3Jvc3Nyb2FkcycsXG4gICAgJ2NvdW50cnlzaWRlJyxcblxuICAgIC8vICdkYW1hZ2UnLFxuICAgICdkYW5jaW5nJyxcbiAgICAvLyAnZGFuZ2VyJyxcbiAgICAnZGVlcicsXG4gICAgLy8gJ2RlbGlnaHQnLFxuICAgIC8vICdkZXNzZXJ0JyxcbiAgICAnZGlnbml0eScsXG4gICAgJ2RpcnQnLFxuICAgIC8vICdkaXN0cmlidXRpb24nLFxuICAgICdkdXN0JyxcblxuICAgICdlY29ub21pY3MnLFxuICAgICdlZHVjYXRpb24nLFxuICAgICdlbGVjdHJpY2l0eScsXG4gICAgLy8gJ2VtcGxveW1lbnQnLFxuICAgIC8vICdlbmVyZ3knLFxuICAgICdlbmdpbmVlcmluZycsXG4gICAgJ2Vuam95bWVudCcsXG4gICAgLy8gJ2VudGVydGFpbm1lbnQnLFxuICAgICdlbnZ5JyxcbiAgICAnZXF1aXBtZW50JyxcbiAgICAnZXRoaWNzJyxcbiAgICAnZXZpZGVuY2UnLFxuICAgICdldm9sdXRpb24nLFxuXG4gICAgLy8gJ2ZhaWx1cmUnLFxuICAgIC8vICdmYWl0aCcsXG4gICAgJ2ZhbWUnLFxuICAgICdmaWN0aW9uJyxcbiAgICAvLyAnZmlzaCcsXG4gICAgJ2Zsb3VyJyxcbiAgICAnZmx1JyxcbiAgICAnZm9vZCcsXG4gICAgLy8gJ2ZyZWVkb20nLFxuICAgIC8vICdmcnVpdCcsXG4gICAgJ2Z1ZWwnLFxuICAgICdmdW4nLFxuICAgIC8vICdmdW5lcmFsJyxcbiAgICAnZnVybml0dXJlJyxcblxuICAgICdnYWxsb3dzJyxcbiAgICAnZ2FyYmFnZScsXG4gICAgJ2dhcmxpYycsXG4gICAgLy8gJ2dhcycsXG4gICAgJ2dlbmV0aWNzJyxcbiAgICAvLyAnZ2xhc3MnLFxuICAgICdnb2xkJyxcbiAgICAnZ29sZicsXG4gICAgJ2dvc3NpcCcsXG4gICAgJ2dyYW1tYXInLFxuICAgIC8vICdncmFzcycsXG4gICAgJ2dyYXRpdHVkZScsXG4gICAgJ2dyaWVmJyxcbiAgICAvLyAnZ3JvdW5kJyxcbiAgICAnZ3VpbHQnLFxuICAgICdneW1uYXN0aWNzJyxcblxuICAgIC8vICdoYWlyJyxcbiAgICAnaGFwcGluZXNzJyxcbiAgICAnaGFyZHdhcmUnLFxuICAgICdoYXJtJyxcbiAgICAnaGF0ZScsXG4gICAgJ2hhdHJlZCcsXG4gICAgJ2hlYWx0aCcsXG4gICAgJ2hlYXQnLFxuICAgIC8vICdoZWlnaHQnLFxuICAgICdoZWxwJyxcbiAgICAnaG9tZXdvcmsnLFxuICAgICdob25lc3R5JyxcbiAgICAnaG9uZXknLFxuICAgICdob3NwaXRhbGl0eScsXG4gICAgJ2hvdXNld29yaycsXG4gICAgJ2h1bW91cicsXG4gICAgJ2h1bmdlcicsXG4gICAgJ2h5ZHJvZ2VuJyxcblxuICAgICdpY2UnLFxuICAgICdpbXBvcnRhbmNlJyxcbiAgICAnaW5mbGF0aW9uJyxcbiAgICAnaW5mb3JtYXRpb24nLFxuICAgIC8vICdpbmp1c3RpY2UnLFxuICAgICdpbm5vY2VuY2UnLFxuICAgIC8vICdpbnRlbGxpZ2VuY2UnLFxuICAgICdpcm9uJyxcbiAgICAnaXJvbnknLFxuXG4gICAgJ2phbScsXG4gICAgLy8gJ2plYWxvdXN5JyxcbiAgICAvLyAnamVsbHknLFxuICAgICdqZXdlbHJ5JyxcbiAgICAvLyAnam95JyxcbiAgICAnanVkbycsXG4gICAgLy8gJ2p1aWNlJyxcbiAgICAvLyAnanVzdGljZScsXG5cbiAgICAna2FyYXRlJyxcbiAgICAvLyAna2luZG5lc3MnLFxuICAgICdrbm93bGVkZ2UnLFxuXG4gICAgLy8gJ2xhYm91cicsXG4gICAgJ2xhY2snLFxuICAgIC8vICdsYW5kJyxcbiAgICAnbGF1Z2h0ZXInLFxuICAgICdsYXZhJyxcbiAgICAnbGVhdGhlcicsXG4gICAgJ2xlaXN1cmUnLFxuICAgICdsaWdodG5pbmcnLFxuICAgICdsaW5ndWluZScsXG4gICAgJ2xpbmd1aW5pJyxcbiAgICAnbGluZ3Vpc3RpY3MnLFxuICAgICdsaXRlcmF0dXJlJyxcbiAgICAnbGl0dGVyJyxcbiAgICAnbGl2ZXN0b2NrJyxcbiAgICAnbG9naWMnLFxuICAgICdsb25lbGluZXNzJyxcbiAgICAvLyAnbG92ZScsXG4gICAgJ2x1Y2snLFxuICAgICdsdWdnYWdlJyxcblxuICAgICdtYWNhcm9uaScsXG4gICAgJ21hY2hpbmVyeScsXG4gICAgJ21hZ2ljJyxcbiAgICAvLyAnbWFpbCcsXG4gICAgJ21hbmFnZW1lbnQnLFxuICAgICdtYW5raW5kJyxcbiAgICAnbWFyYmxlJyxcbiAgICAnbWF0aGVtYXRpY3MnLFxuICAgICdtYXlvbm5haXNlJyxcbiAgICAnbWVhc2xlcycsXG4gICAgLy8gJ21lYXQnLFxuICAgIC8vICdtZXRhbCcsXG4gICAgJ21ldGhhbmUnLFxuICAgICdtaWxrJyxcbiAgICAnbWludXMnLFxuICAgICdtb25leScsXG4gICAgLy8gJ21vb3NlJyxcbiAgICAnbXVkJyxcbiAgICAnbXVzaWMnLFxuICAgICdtdW1wcycsXG5cbiAgICAnbmF0dXJlJyxcbiAgICAnbmV3cycsXG4gICAgJ25pdHJvZ2VuJyxcbiAgICAnbm9uc2Vuc2UnLFxuICAgICdudXJ0dXJlJyxcbiAgICAnbnV0cml0aW9uJyxcblxuICAgICdvYmVkaWVuY2UnLFxuICAgICdvYmVzaXR5JyxcbiAgICAvLyAnb2lsJyxcbiAgICAnb3h5Z2VuJyxcblxuICAgIC8vICdwYXBlcicsXG4gICAgLy8gJ3Bhc3Npb24nLFxuICAgICdwYXN0YScsXG4gICAgJ3BhdGllbmNlJyxcbiAgICAvLyAncGVybWlzc2lvbicsXG4gICAgJ3BoeXNpY3MnLFxuICAgICdwb2V0cnknLFxuICAgICdwb2xsdXRpb24nLFxuICAgICdwb3ZlcnR5JyxcbiAgICAvLyAncG93ZXInLFxuICAgICdwcmlkZScsXG4gICAgLy8gJ3Byb2R1Y3Rpb24nLFxuICAgIC8vICdwcm9ncmVzcycsXG4gICAgLy8gJ3Byb251bmNpYXRpb24nLFxuICAgICdwc3ljaG9sb2d5JyxcbiAgICAncHVibGljaXR5JyxcbiAgICAncHVuY3R1YXRpb24nLFxuXG4gICAgLy8gJ3F1YWxpdHknLFxuICAgIC8vICdxdWFudGl0eScsXG4gICAgJ3F1YXJ0eicsXG5cbiAgICAncmFjaXNtJyxcbiAgICAvLyAncmFpbicsXG4gICAgLy8gJ3JlY3JlYXRpb24nLFxuICAgICdyZWxheGF0aW9uJyxcbiAgICAncmVsaWFiaWxpdHknLFxuICAgICdyZXNlYXJjaCcsXG4gICAgJ3Jlc3BlY3QnLFxuICAgICdyZXZlbmdlJyxcbiAgICAncmljZScsXG4gICAgJ3J1YmJpc2gnLFxuICAgICdydW0nLFxuXG4gICAgJ3NhZmV0eScsXG4gICAgLy8gJ3NhbGFkJyxcbiAgICAvLyAnc2FsdCcsXG4gICAgLy8gJ3NhbmQnLFxuICAgIC8vICdzYXRpcmUnLFxuICAgICdzY2VuZXJ5JyxcbiAgICAnc2VhZm9vZCcsXG4gICAgJ3NlYXNpZGUnLFxuICAgICdzZXJpZXMnLFxuICAgICdzaGFtZScsXG4gICAgJ3NoZWVwJyxcbiAgICAnc2hvcHBpbmcnLFxuICAgIC8vICdzaWxlbmNlJyxcbiAgICAnc2xlZXAnLFxuICAgIC8vICdzbGFuZydcbiAgICAnc21va2UnLFxuICAgICdzbW9raW5nJyxcbiAgICAnc25vdycsXG4gICAgJ3NvYXAnLFxuICAgICdzb2Z0d2FyZScsXG4gICAgJ3NvaWwnLFxuICAgIC8vICdzb3Jyb3cnLFxuICAgIC8vICdzb3VwJyxcbiAgICAnc3BhZ2hldHRpJyxcbiAgICAvLyAnc3BlZWQnLFxuICAgICdzcGVjaWVzJyxcbiAgICAvLyAnc3BlbGxpbmcnLFxuICAgIC8vICdzcG9ydCcsXG4gICAgJ3N0ZWFtJyxcbiAgICAvLyAnc3RyZW5ndGgnLFxuICAgICdzdHVmZicsXG4gICAgJ3N0dXBpZGl0eScsXG4gICAgLy8gJ3N1Y2Nlc3MnLFxuICAgIC8vICdzdWdhcicsXG4gICAgJ3N1bnNoaW5lJyxcbiAgICAnc3ltbWV0cnknLFxuXG4gICAgLy8gJ3RlYScsXG4gICAgJ3Rlbm5pcycsXG4gICAgJ3RoaXJzdCcsXG4gICAgJ3RodW5kZXInLFxuICAgICd0aW1iZXInLFxuICAgIC8vICd0aW1lJyxcbiAgICAvLyAndG9hc3QnLFxuICAgIC8vICd0b2xlcmFuY2UnLFxuICAgIC8vICd0cmFkZScsXG4gICAgJ3RyYWZmaWMnLFxuICAgICd0cmFuc3BvcnRhdGlvbicsXG4gICAgLy8gJ3RyYXZlbCcsXG4gICAgJ3RydXN0JyxcblxuICAgIC8vICd1bmRlcnN0YW5kaW5nJyxcbiAgICAndW5kZXJ3ZWFyJyxcbiAgICAndW5lbXBsb3ltZW50JyxcbiAgICAndW5pdHknLFxuICAgIC8vICd1c2FnZScsXG5cbiAgICAndmFsaWRpdHknLFxuICAgICd2ZWFsJyxcbiAgICAndmVnZXRhdGlvbicsXG4gICAgJ3ZlZ2V0YXJpYW5pc20nLFxuICAgICd2ZW5nZWFuY2UnLFxuICAgICd2aW9sZW5jZScsXG4gICAgLy8gJ3Zpc2lvbicsXG4gICAgJ3ZpdGFsaXR5JyxcblxuICAgICd3YXJtdGgnLFxuICAgIC8vICd3YXRlcicsXG4gICAgJ3dlYWx0aCcsXG4gICAgJ3dlYXRoZXInLFxuICAgIC8vICd3ZWlnaHQnLFxuICAgICd3ZWxmYXJlJyxcbiAgICAnd2hlYXQnLFxuICAgIC8vICd3aGlza2V5JyxcbiAgICAvLyAnd2lkdGgnLFxuICAgICd3aWxkbGlmZScsXG4gICAgLy8gJ3dpbmUnLFxuICAgICd3aXNkb20nLFxuICAgIC8vICd3b29kJyxcbiAgICAvLyAnd29vbCcsXG4gICAgLy8gJ3dvcmsnLFxuXG4gICAgLy8gJ3llYXN0JyxcbiAgICAneW9nYScsXG5cbiAgICAnemluYycsXG4gICAgJ3pvb2xvZ3knXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBydWxlcyB0cmFuc2xhdGUgZnJvbSB0aGUgc2luZ3VsYXIgZm9ybSBvZiBhIG5vdW4gdG8gaXRzIHBsdXJhbCBmb3JtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgcmVnZXggPSB7XG4gICAgcGx1cmFsIDoge1xuICAgICAgbWVuICAgICAgIDogbmV3IFJlZ0V4cCggJ14obXx3b20pZW4kJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBwZW9wbGUgICAgOiBuZXcgUmVnRXhwKCAnKHBlKW9wbGUkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNoaWxkcmVuICA6IG5ldyBSZWdFeHAoICcoY2hpbGQpcmVuJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgdGlhICAgICAgIDogbmV3IFJlZ0V4cCggJyhbdGldKWEkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhbmFseXNlcyAgOiBuZXcgUmVnRXhwKCAnKChhKW5hbHl8KGIpYXwoZClpYWdub3wocClhcmVudGhlfChwKXJvZ25vfChzKXlub3B8KHQpaGUpc2VzJCcsJ2dpJyApLFxuICAgICAgaGl2ZXMgICAgIDogbmV3IFJlZ0V4cCggJyhoaXx0aSl2ZXMkJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjdXJ2ZXMgICAgOiBuZXcgUmVnRXhwKCAnKGN1cnZlKXMkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGxydmVzICAgICA6IG5ldyBSZWdFeHAoICcoW2xyXSl2ZXMkJyAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYXZlcyAgICAgIDogbmV3IFJlZ0V4cCggJyhbYV0pdmVzJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBmb3ZlcyAgICAgOiBuZXcgUmVnRXhwKCAnKFteZm9dKXZlcyQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG1vdmllcyAgICA6IG5ldyBSZWdFeHAoICcobSlvdmllcyQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYWVpb3V5aWVzIDogbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpaWVzJCcgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzZXJpZXMgICAgOiBuZXcgUmVnRXhwKCAnKHMpZXJpZXMkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHhlcyAgICAgICA6IG5ldyBSZWdFeHAoICcoeHxjaHxzc3xzaCllcyQnICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbWljZSAgICAgIDogbmV3IFJlZ0V4cCggJyhbbXxsXSlpY2UkJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBidXNlcyAgICAgOiBuZXcgUmVnRXhwKCAnKGJ1cyllcyQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG9lcyAgICAgICA6IG5ldyBSZWdFeHAoICcobyllcyQnICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgc2hvZXMgICAgIDogbmV3IFJlZ0V4cCggJyhzaG9lKXMkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjcmlzZXMgICAgOiBuZXcgUmVnRXhwKCAnKGNyaXN8YXh8dGVzdCllcyQnICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG9jdG9waSAgICA6IG5ldyBSZWdFeHAoICcob2N0b3B8dmlyKWkkJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYWxpYXNlcyAgIDogbmV3IFJlZ0V4cCggJyhhbGlhc3xjYW52YXN8c3RhdHVzfGNhbXB1cyllcyQnLCAnZ2knICksXG4gICAgICBzdW1tb25zZXMgOiBuZXcgUmVnRXhwKCAnXihzdW1tb25zKWVzJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG94ZW4gICAgICA6IG5ldyBSZWdFeHAoICdeKG94KWVuJyAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbWF0cmljZXMgIDogbmV3IFJlZ0V4cCggJyhtYXRyKWljZXMkJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB2ZXJ0aWNlcyAgOiBuZXcgUmVnRXhwKCAnKHZlcnR8aW5kKWljZXMkJyAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGZlZXQgICAgICA6IG5ldyBSZWdFeHAoICdeZmVldCQnICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgdGVldGggICAgIDogbmV3IFJlZ0V4cCggJ150ZWV0aCQnICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBnZWVzZSAgICAgOiBuZXcgUmVnRXhwKCAnXmdlZXNlJCcgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHF1aXp6ZXMgICA6IG5ldyBSZWdFeHAoICcocXVpeil6ZXMkJyAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgd2hlcmVhc2VzIDogbmV3IFJlZ0V4cCggJ14od2hlcmVhcyllcyQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBjcml0ZXJpYSAgOiBuZXcgUmVnRXhwKCAnXihjcml0ZXJpKWEkJyAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGdlbmVyYSAgICA6IG5ldyBSZWdFeHAoICdeZ2VuZXJhJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgc3MgICAgICAgIDogbmV3IFJlZ0V4cCggJ3NzJCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzICAgICAgICAgOiBuZXcgUmVnRXhwKCAncyQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKVxuICAgIH0sXG5cbiAgICBzaW5ndWxhciA6IHtcbiAgICAgIG1hbiAgICAgICA6IG5ldyBSZWdFeHAoICdeKG18d29tKWFuJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHBlcnNvbiAgICA6IG5ldyBSZWdFeHAoICcocGUpcnNvbiQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNoaWxkICAgICA6IG5ldyBSZWdFeHAoICcoY2hpbGQpJCcgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG94ICAgICAgICA6IG5ldyBSZWdFeHAoICdeKG94KSQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGF4aXMgICAgICA6IG5ldyBSZWdFeHAoICcoYXh8dGVzdClpcyQnICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG9jdG9wdXMgICA6IG5ldyBSZWdFeHAoICcob2N0b3B8dmlyKXVzJCcgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGFsaWFzICAgICA6IG5ldyBSZWdFeHAoICcoYWxpYXN8c3RhdHVzfGNhbnZhc3xjYW1wdXMpJCcsICdnaScgKSxcbiAgICAgIHN1bW1vbnMgICA6IG5ldyBSZWdFeHAoICdeKHN1bW1vbnMpJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGJ1cyAgICAgICA6IG5ldyBSZWdFeHAoICcoYnUpcyQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGJ1ZmZhbG8gICA6IG5ldyBSZWdFeHAoICcoYnVmZmFsfHRvbWF0fHBvdGF0KW8kJyAgICAgICAsICdnaScgKSxcbiAgICAgIHRpdW0gICAgICA6IG5ldyBSZWdFeHAoICcoW3RpXSl1bSQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHNpcyAgICAgICA6IG5ldyBSZWdFeHAoICdzaXMkJyAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGZmZSAgICAgICA6IG5ldyBSZWdFeHAoICcoPzooW15mXSlmZXwoW2xyXSlmKSQnICAgICAgICAsICdnaScgKSxcbiAgICAgIGhpdmUgICAgICA6IG5ldyBSZWdFeHAoICcoaGl8dGkpdmUkJyAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGFlaW91eXkgICA6IG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KXkkJyAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHggICAgICAgICA6IG5ldyBSZWdFeHAoICcoeHxjaHxzc3xzaCkkJyAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG1hdHJpeCAgICA6IG5ldyBSZWdFeHAoICcobWF0cilpeCQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHZlcnRleCAgICA6IG5ldyBSZWdFeHAoICcodmVydHxpbmQpZXgkJyAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIG1vdXNlICAgICA6IG5ldyBSZWdFeHAoICcoW218bF0pb3VzZSQnICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGZvb3QgICAgICA6IG5ldyBSZWdFeHAoICdeZm9vdCQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHRvb3RoICAgICA6IG5ldyBSZWdFeHAoICdedG9vdGgkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGdvb3NlICAgICA6IG5ldyBSZWdFeHAoICdeZ29vc2UkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHF1aXogICAgICA6IG5ldyBSZWdFeHAoICcocXVpeikkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHdoZXJlYXMgICA6IG5ldyBSZWdFeHAoICdeKHdoZXJlYXMpJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNyaXRlcmlvbiA6IG5ldyBSZWdFeHAoICdeKGNyaXRlcmkpb24kJyAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGdlbnVzICAgICA6IG5ldyBSZWdFeHAoICdeZ2VudXMkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHMgICAgICAgICA6IG5ldyBSZWdFeHAoICdzJCcgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNvbW1vbiAgICA6IG5ldyBSZWdFeHAoICckJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKVxuICAgIH1cbiAgfTtcblxuICB2YXIgcGx1cmFsX3J1bGVzID0gW1xuXG4gICAgLy8gZG8gbm90IHJlcGxhY2UgaWYgaXRzIGFscmVhZHkgYSBwbHVyYWwgd29yZFxuICAgIFsgcmVnZXgucGx1cmFsLm1lbiAgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnBlb3BsZSAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmNoaWxkcmVuICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnRpYSAgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFuYWx5c2VzICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmhpdmVzICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmN1cnZlcyAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmxydmVzICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmZvdmVzICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFlaW91eWllcyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnNlcmllcyAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1vdmllcyAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnhlcyAgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1pY2UgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmJ1c2VzICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm9lcyAgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnNob2VzICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmNyaXNlcyAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm9jdG9waSAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFsaWFzZXMgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnN1bW1vbnNlcyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm94ZW4gICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1hdHJpY2VzICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmZlZXQgICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnRlZXRoICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmdlZXNlICAgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnF1aXp6ZXMgICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLndoZXJlYXNlcyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmNyaXRlcmlhICBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmdlbmVyYSAgICBdLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgcmVnZXguc2luZ3VsYXIubWFuICAgICAgLCAnJDFlbicgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnBlcnNvbiAgICwgJyQxb3BsZScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmNoaWxkICAgICwgJyQxcmVuJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIub3ggICAgICAgLCAnJDFlbicgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmF4aXMgICAgICwgJyQxZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5vY3RvcHVzICAsICckMWknIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5hbGlhcyAgICAsICckMWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuc3VtbW9ucyAgLCAnJDFlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmJ1cyAgICAgICwgJyQxc2VzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYnVmZmFsbyAgLCAnJDFvZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci50aXVtICAgICAsICckMWEnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5zaXMgICAgICAsICdzZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5mZmUgICAgICAsICckMSQydmVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuaGl2ZSAgICAgLCAnJDF2ZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5hZWlvdXl5ICAsICckMWllcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1hdHJpeCAgICwgJyQxaWNlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnZlcnRleCAgICwgJyQxaWNlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnggICAgICAgICwgJyQxZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5tb3VzZSAgICAsICckMWljZScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmZvb3QgICAgICwgJ2ZlZXQnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci50b290aCAgICAsICd0ZWV0aCcgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmdvb3NlICAgICwgJ2dlZXNlJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIucXVpeiAgICAgLCAnJDF6ZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci53aGVyZWFzICAsICckMWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuY3JpdGVyaW9uLCAnJDFhJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZ2VudXMgICAgLCAnZ2VuZXJhJyBdLFxuXG4gICAgWyByZWdleC5zaW5ndWxhci5zICAgICAsICdzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuY29tbW9uLCAncycgXVxuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHBsdXJhbCBmb3JtIG9mIGEgbm91biB0byBpdHMgc2luZ3VsYXIgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBzaW5ndWxhcl9ydWxlcyA9IFtcblxuICAgIC8vIGRvIG5vdCByZXBsYWNlIGlmIGl0cyBhbHJlYWR5IGEgc2luZ3VsYXIgd29yZFxuICAgIFsgcmVnZXguc2luZ3VsYXIubWFuICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIucGVyc29uICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuY2hpbGQgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIub3ggICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYXhpcyAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIub2N0b3B1cyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYWxpYXMgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuc3VtbW9ucyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYnVzICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYnVmZmFsbyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIudGl1bSAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuc2lzICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZmZlICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuaGl2ZSAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYWVpb3V5eSBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIueCAgICAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIubWF0cml4ICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIubW91c2UgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZm9vdCAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIudG9vdGggICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZ29vc2UgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIucXVpeiAgICBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIud2hlcmVhcyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuY3JpdGVyaW9uIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5nZW51cyBdLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgcmVnZXgucGx1cmFsLm1lbiAgICAgICwgJyQxYW4nIF0sXG4gICAgWyByZWdleC5wbHVyYWwucGVvcGxlICAgLCAnJDFyc29uJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmNoaWxkcmVuICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmdlbmVyYSAgICwgJ2dlbnVzJ10sXG4gICAgWyByZWdleC5wbHVyYWwuY3JpdGVyaWEgLCAnJDFvbiddLFxuICAgIFsgcmVnZXgucGx1cmFsLnRpYSAgICAgICwgJyQxdW0nIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYW5hbHlzZXMgLCAnJDEkMnNpcycgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5oaXZlcyAgICAsICckMXZlJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmN1cnZlcyAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmxydmVzICAgICwgJyQxZicgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hdmVzICAgICAsICckMXZlJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmZvdmVzICAgICwgJyQxZmUnIF0sXG4gICAgWyByZWdleC5wbHVyYWwubW92aWVzICAgLCAnJDFvdmllJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmFlaW91eWllcywgJyQxeScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zZXJpZXMgICAsICckMWVyaWVzJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnhlcyAgICAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm1pY2UgICAgICwgJyQxb3VzZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5idXNlcyAgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5vZXMgICAgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zaG9lcyAgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jcmlzZXMgICAsICckMWlzJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm9jdG9waSAgICwgJyQxdXMnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYWxpYXNlcyAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc3VtbW9uc2VzLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwub3hlbiAgICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwubWF0cmljZXMgLCAnJDFpeCcgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC52ZXJ0aWNlcyAsICckMWV4JyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmZlZXQgICAgICwgJ2Zvb3QnIF0sXG4gICAgWyByZWdleC5wbHVyYWwudGVldGggICAgLCAndG9vdGgnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZ2Vlc2UgICAgLCAnZ29vc2UnIF0sXG4gICAgWyByZWdleC5wbHVyYWwucXVpenplcyAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwud2hlcmVhc2VzLCAnJDEnIF0sXG5cbiAgICBbIHJlZ2V4LnBsdXJhbC5zcywgJ3NzJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnMgLCAnJyBdXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZCBub3QgYmUgY2FwaXRhbGl6ZWQgZm9yIHRpdGxlIGNhc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgbm9uX3RpdGxlY2FzZWRfd29yZHMgPSBbXG4gICAgJ2FuZCcsICdvcicsICdub3InLCAnYScsICdhbicsICd0aGUnLCAnc28nLCAnYnV0JywgJ3RvJywgJ29mJywgJ2F0JywnYnknLFxuICAgICdmcm9tJywgJ2ludG8nLCAnb24nLCAnb250bycsICdvZmYnLCAnb3V0JywgJ2luJywgJ292ZXInLCAnd2l0aCcsICdmb3InXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBhcmUgcmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gU3RyaW5nIGZvcm1hdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgaWRfc3VmZml4ICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKF9pZHN8X2lkKSQnLCAnZycgKTtcbiAgdmFyIHVuZGVyYmFyICAgICAgICAgID0gbmV3IFJlZ0V4cCggJ18nLCAnZycgKTtcbiAgdmFyIHNwYWNlX29yX3VuZGVyYmFyID0gbmV3IFJlZ0V4cCggJ1tcXCBfXScsICdnJyApO1xuICB2YXIgdXBwZXJjYXNlICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKFtBLVpdKScsICdnJyApO1xuICB2YXIgdW5kZXJiYXJfcHJlZml4ICAgPSBuZXcgUmVnRXhwKCAnXl8nICk7XG5cbiAgdmFyIGluZmxlY3RvciA9IHtcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgYXBwbGllcyBydWxlcyBiYXNlZCByZXBsYWNlbWVudCB0byBhIFN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIG1vZGlmeSBhbmQgcmV0dXJuIGJhc2VkIG9uIHRoZSBwYXNzZWQgcnVsZXMuXG4gICAqIEBwYXJhbSB7QXJyYXk6IFtSZWdFeHAsIFN0cmluZ119IHJ1bGVzIFJlZ2V4cCB0byBtYXRjaCBwYWlyZWQgd2l0aCBTdHJpbmcgdG8gdXNlIGZvciByZXBsYWNlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5OiBbU3RyaW5nXX0gc2tpcCBTdHJpbmdzIHRvIHNraXAgaWYgdGhleSBtYXRjaFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3ZlcnJpZGUgU3RyaW5nIHRvIHJldHVybiBhcyB0aG91Z2ggdGhpcyBtZXRob2Qgc3VjY2VlZGVkICh1c2VkIHRvIGNvbmZvcm0gdG8gQVBJcylcbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIHBhc3NlZCBTdHJpbmcgbW9kaWZpZWQgYnkgcGFzc2VkIHJ1bGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdGhpcy5fYXBwbHlfcnVsZXMoICdjb3dzJywgc2luZ3VsYXJfcnVsZXMgKTsgLy8gPT09ICdjb3cnXG4gICAqL1xuICAgIF9hcHBseV9ydWxlcyA6IGZ1bmN0aW9uICggc3RyLCBydWxlcywgc2tpcCwgb3ZlcnJpZGUgKXtcbiAgICAgIGlmKCBvdmVycmlkZSApe1xuICAgICAgICBzdHIgPSBvdmVycmlkZTtcbiAgICAgIH1lbHNle1xuICAgICAgICB2YXIgaWdub3JlID0gKCBpbmZsZWN0b3IuaW5kZXhPZiggc2tpcCwgc3RyLnRvTG93ZXJDYXNlKCkpID4gLTEgKTtcblxuICAgICAgICBpZiggIWlnbm9yZSApe1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB2YXIgaiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgICAgICBpZiggc3RyLm1hdGNoKCBydWxlc1sgaSBdWyAwIF0pKXtcbiAgICAgICAgICAgICAgaWYoIHJ1bGVzWyBpIF1bIDEgXSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIHJ1bGVzWyBpIF1bIDAgXSwgcnVsZXNbIGkgXVsgMSBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBsZXRzIHVzIGRldGVjdCBpZiBhbiBBcnJheSBjb250YWlucyBhIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgc3ViamVjdCBhcnJheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gT2JqZWN0IHRvIGxvY2F0ZSBpbiB0aGUgQXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tX2luZGV4IFN0YXJ0cyBjaGVja2luZyBmcm9tIHRoaXMgcG9zaXRpb24gaW4gdGhlIEFycmF5LihvcHRpb25hbClcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZV9mdW5jIEZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBBcnJheSBpdGVtIHZzIHBhc3NlZCBpdGVtLihvcHRpb25hbClcbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJuIGluZGV4IHBvc2l0aW9uIGluIHRoZSBBcnJheSBvZiB0aGUgcGFzc2VkIGl0ZW0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmRleE9mKFsgJ2hpJywndGhlcmUnIF0sICdndXlzJyApOyAvLyA9PT0gLTFcbiAgICogICAgIGluZmxlY3Rpb24uaW5kZXhPZihbICdoaScsJ3RoZXJlJyBdLCAnaGknICk7IC8vID09PSAwXG4gICAqL1xuICAgIGluZGV4T2YgOiBmdW5jdGlvbiAoIGFyciwgaXRlbSwgZnJvbV9pbmRleCwgY29tcGFyZV9mdW5jICl7XG4gICAgICBpZiggIWZyb21faW5kZXggKXtcbiAgICAgICAgZnJvbV9pbmRleCA9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBpICAgICA9IGZyb21faW5kZXg7XG4gICAgICB2YXIgaiAgICAgPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBpZiggYXJyWyBpIF0gID09PSBpdGVtIHx8IGNvbXBhcmVfZnVuYyAmJiBjb21wYXJlX2Z1bmMoIGFyclsgaSBdLCBpdGVtICkpe1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBwbHVyYWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVyYWwgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFNpbmd1bGFyIEVuZ2xpc2ggbGFuZ3VhZ2Ugbm91bnMgYXJlIHJldHVybmVkIGluIHBsdXJhbCBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAncGVyc29uJyApOyAvLyA9PT0gJ3Blb3BsZSdcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAnb2N0b3B1cycgKTsgLy8gPT09ICdvY3RvcGknXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ0hhdCcgKTsgLy8gPT09ICdIYXRzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdwZXJzb24nLCAnZ3V5cycgKTsgLy8gPT09ICdndXlzJ1xuICAgKi9cbiAgICBwbHVyYWxpemUgOiBmdW5jdGlvbiAoIHN0ciwgcGx1cmFsICl7XG4gICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBwbHVyYWxfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBwbHVyYWwgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHNpbmd1bGFyaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2luZ3VsYXIgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFBsdXJhbCBFbmdsaXNoIGxhbmd1YWdlIG5vdW5zIGFyZSByZXR1cm5lZCBpbiBzaW5ndWxhciBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdwZW9wbGUnICk7IC8vID09PSAncGVyc29uJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ29jdG9waScgKTsgLy8gPT09ICdvY3RvcHVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ0hhdHMnICk7IC8vID09PSAnSGF0J1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ2d1eXMnLCAncGVyc29uJyApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICovXG4gICAgc2luZ3VsYXJpemUgOiBmdW5jdGlvbiAoIHN0ciwgc2luZ3VsYXIgKXtcbiAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHNpbmd1bGFyX3J1bGVzLCB1bmNvdW50YWJsZV93b3Jkcywgc2luZ3VsYXIgKTtcbiAgICB9LFxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbHVyYWxpemUgb3Igc2luZ3VsYXJsaXplIGEgU3RyaW5nIGFwcHJvcHJpYXRlbHkgYmFzZWQgb24gYW4gaW50ZWdlciB2YWx1ZVxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgdG8gYmFzZSBwbHVyYWxpemF0aW9uIG9mZiBvZi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpbmd1bGFyIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1cmFsIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBFbmdsaXNoIGxhbmd1YWdlIG5vdW5zIGFyZSByZXR1cm5lZCBpbiB0aGUgcGx1cmFsIG9yIHNpbmd1bGFyIGZvcm0gYmFzZWQgb24gdGhlIGNvdW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ3Blb3BsZScgMSApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ29jdG9waScgMSApOyAvLyA9PT0gJ29jdG9wdXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdIYXRzJyAxICk7IC8vID09PSAnSGF0J1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAnZ3V5cycsIDEgLCAncGVyc29uJyApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ3BlcnNvbicsIDIgKTsgLy8gPT09ICdwZW9wbGUnXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdvY3RvcHVzJywgMiApOyAvLyA9PT0gJ29jdG9waSdcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ0hhdCcsIDIgKTsgLy8gPT09ICdIYXRzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAncGVyc29uJywgMiwgbnVsbCwgJ2d1eXMnICk7IC8vID09PSAnZ3V5cydcbiAgICovXG4gICAgaW5mbGVjdCA6IGZ1bmN0aW9uICggc3RyLCBjb3VudCwgc2luZ3VsYXIsIHBsdXJhbCApe1xuICAgICAgY291bnQgPSBwYXJzZUludCggY291bnQsIDEwICk7XG5cbiAgICAgIGlmKCBpc05hTiggY291bnQgKSkgcmV0dXJuIHN0cjtcblxuICAgICAgaWYoIGNvdW50ID09PSAwIHx8IGNvdW50ID4gMSApe1xuICAgICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBwbHVyYWxfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBwbHVyYWwgKTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBzaW5ndWxhcl9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHNpbmd1bGFyICk7XG4gICAgICB9XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjYW1lbGl6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsb3dfZmlyc3RfbGV0dGVyIERlZmF1bHQgaXMgdG8gY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIHRoZSByZXN1bHRzLihvcHRpb25hbClcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXNzaW5nIHRydWUgd2lsbCBsb3dlcmNhc2UgaXQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IExvd2VyIGNhc2UgdW5kZXJzY29yZWQgd29yZHMgd2lsbCBiZSByZXR1cm5lZCBpbiBjYW1lbCBjYXNlLlxuICAgKiAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxseSAnLycgaXMgdHJhbnNsYXRlZCB0byAnOjonXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jYW1lbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlUHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uY2FtZWxpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnLCB0cnVlICk7IC8vID09PSAnbWVzc2FnZVByb3BlcnRpZXMnXG4gICAqL1xuICAgIGNhbWVsaXplIDogZnVuY3Rpb24gKCBzdHIsIGxvd19maXJzdF9sZXR0ZXIgKXtcbiAgICAgIHZhciBzdHJfcGF0aCA9IHN0ci5zcGxpdCggJy8nICk7XG4gICAgICB2YXIgaSAgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgID0gc3RyX3BhdGgubGVuZ3RoO1xuICAgICAgdmFyIHN0cl9hcnIsIGluaXRfeCwgaywgbCwgZmlyc3Q7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIHN0cl9hcnIgPSBzdHJfcGF0aFsgaSBdLnNwbGl0KCAnXycgKTtcbiAgICAgICAgayAgICAgICA9IDA7XG4gICAgICAgIGwgICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IoIDsgayA8IGw7IGsrKyApe1xuICAgICAgICAgIGlmKCBrICE9PSAwICl7XG4gICAgICAgICAgICBzdHJfYXJyWyBrIF0gPSBzdHJfYXJyWyBrIF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaXJzdCA9IHN0cl9hcnJbIGsgXS5jaGFyQXQoIDAgKTtcbiAgICAgICAgICBmaXJzdCA9IGxvd19maXJzdF9sZXR0ZXIgJiYgaSA9PT0gMCAmJiBrID09PSAwXG4gICAgICAgICAgICA/IGZpcnN0LnRvTG93ZXJDYXNlKCkgOiBmaXJzdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHN0cl9hcnJbIGsgXSA9IGZpcnN0ICsgc3RyX2FyclsgayBdLnN1YnN0cmluZyggMSApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9hcnIuam9pbiggJycgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9wYXRoLmpvaW4oICc6OicgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHVuZGVyc2NvcmUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbGxfdXBwZXJfY2FzZSBEZWZhdWx0IGlzIHRvIGxvd2VyY2FzZSBhbmQgYWRkIHVuZGVyc2NvcmUgcHJlZml4LihvcHRpb25hbClcbiAgICogICAgICAgICAgICAgICAgICBQYXNzaW5nIHRydWUgd2lsbCByZXR1cm4gYXMgZW50ZXJlZC5cbiAgICogQHJldHVybnMge1N0cmluZ30gQ2FtZWwgY2FzZWQgd29yZHMgYXJlIHJldHVybmVkIGFzIGxvd2VyIGNhc2VkIGFuZCB1bmRlcnNjb3JlZC5cbiAgICogICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsbHkgJzo6JyBpcyB0cmFuc2xhdGVkIHRvICcvJy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnVuZGVyc2NvcmUoICdNZXNzYWdlUHJvcGVydGllcycgKTsgLy8gPT09ICdtZXNzYWdlX3Byb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnVuZGVyc2NvcmUoICdtZXNzYWdlUHJvcGVydGllcycgKTsgLy8gPT09ICdtZXNzYWdlX3Byb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnVuZGVyc2NvcmUoICdNUCcsIHRydWUgKTsgLy8gPT09ICdNUCdcbiAgICovXG4gICAgdW5kZXJzY29yZSA6IGZ1bmN0aW9uICggc3RyLCBhbGxfdXBwZXJfY2FzZSApe1xuICAgICAgaWYoIGFsbF91cHBlcl9jYXNlICYmIHN0ciA9PT0gc3RyLnRvVXBwZXJDYXNlKCkpIHJldHVybiBzdHI7XG5cbiAgICAgIHZhciBzdHJfcGF0aCA9IHN0ci5zcGxpdCggJzo6JyApO1xuICAgICAgdmFyIGkgICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgICA9IHN0cl9wYXRoLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9wYXRoWyBpIF0ucmVwbGFjZSggdXBwZXJjYXNlLCAnXyQxJyApO1xuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX3BhdGhbIGkgXS5yZXBsYWNlKCB1bmRlcmJhcl9wcmVmaXgsICcnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfcGF0aC5qb2luKCAnLycgKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgaHVtYW5pemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsb3dfZmlyc3RfbGV0dGVyIERlZmF1bHQgaXMgdG8gY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIHRoZSByZXN1bHRzLihvcHRpb25hbClcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXNzaW5nIHRydWUgd2lsbCBsb3dlcmNhc2UgaXQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IExvd2VyIGNhc2UgdW5kZXJzY29yZWQgd29yZHMgd2lsbCBiZSByZXR1cm5lZCBpbiBodW1hbml6ZWQgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmh1bWFuaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UgcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uaHVtYW5pemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnLCB0cnVlICk7IC8vID09PSAnbWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBodW1hbml6ZSA6IGZ1bmN0aW9uICggc3RyLCBsb3dfZmlyc3RfbGV0dGVyICl7XG4gICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCBpZF9zdWZmaXgsICcnICk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSggdW5kZXJiYXIsICcgJyApO1xuXG4gICAgICBpZiggIWxvd19maXJzdF9sZXR0ZXIgKXtcbiAgICAgICAgc3RyID0gaW5mbGVjdG9yLmNhcGl0YWxpemUoIHN0ciApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgY2FwaXRhbGl6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gQWxsIGNoYXJhY3RlcnMgd2lsbCBiZSBsb3dlciBjYXNlIGFuZCB0aGUgZmlyc3Qgd2lsbCBiZSB1cHBlci5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmNhcGl0YWxpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5jYXBpdGFsaXplKCAnbWVzc2FnZSBwcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ01lc3NhZ2UgcHJvcGVydGllcydcbiAgICovXG4gICAgY2FwaXRhbGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZyggMSApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJlcGxhY2VzIHVuZGVyc2NvcmVzIHdpdGggZGFzaGVzIGluIHRoZSBzdHJpbmcuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXBsYWNlcyBhbGwgc3BhY2VzIG9yIHVuZGVyc2NvcmVzIHdpdGggZGFzaGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2UtcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnTWVzc2FnZSBQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UtUHJvcGVydGllcydcbiAgICovXG4gICAgZGFzaGVyaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSggc3BhY2Vfb3JfdW5kZXJiYXIsICctJyApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGl0bGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gQ2FwaXRhbGl6ZXMgd29yZHMgYXMgeW91IHdvdWxkIGZvciBhIGJvb2sgdGl0bGUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50aXRsZWl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIFByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnRpdGxlaXplKCAnbWVzc2FnZSBwcm9wZXJ0aWVzIHRvIGtlZXAnICk7IC8vID09PSAnTWVzc2FnZSBQcm9wZXJ0aWVzIHRvIEtlZXAnXG4gICAqL1xuICAgIHRpdGxlaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciAgICAgICAgID0gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSggdW5kZXJiYXIsICcgJyApO1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICcgJyApO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcbiAgICAgIHZhciBkLCBrLCBsO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBkID0gc3RyX2FyclsgaSBdLnNwbGl0KCAnLScgKTtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGwgPSBkLmxlbmd0aDtcblxuICAgICAgICBmb3IoIDsgayA8IGw7IGsrKyl7XG4gICAgICAgICAgaWYoIGluZmxlY3Rvci5pbmRleE9mKCBub25fdGl0bGVjYXNlZF93b3JkcywgZFsgayBdLnRvTG93ZXJDYXNlKCkpIDwgMCApe1xuICAgICAgICAgICAgZFsgayBdID0gaW5mbGVjdG9yLmNhcGl0YWxpemUoIGRbIGsgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyX2FyclsgaSBdID0gZC5qb2luKCAnLScgKTtcbiAgICAgIH1cblxuICAgICAgc3RyID0gc3RyX2Fyci5qb2luKCAnICcgKTtcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZyggMSApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZGVtb2R1bGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZW1vdmVzIG1vZHVsZSBuYW1lcyBsZWF2aW5nIG9ubHkgY2xhc3MgbmFtZXMuKFJ1Ynkgc3R5bGUpXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5kZW1vZHVsaXplKCAnTWVzc2FnZTo6QnVzOjpQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ1Byb3BlcnRpZXMnXG4gICAqL1xuICAgIGRlbW9kdWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICc6OicgKTtcblxuICAgICAgcmV0dXJuIHN0cl9hcnJbIHN0cl9hcnIubGVuZ3RoIC0gMSBdO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGFibGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIGNhbWVsIGNhc2VkIHdvcmRzIGludG8gdGhlaXIgdW5kZXJzY29yZWQgcGx1cmFsIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50YWJsZWl6ZSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICB0YWJsZWl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IudW5kZXJzY29yZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IucGx1cmFsaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNsYXNzaWZpY2F0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuZGVyc2NvcmVkIHBsdXJhbCBub3VucyBiZWNvbWUgdGhlIGNhbWVsIGNhc2VkIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jbGFzc2lmeSggJ21lc3NhZ2VfYnVzX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZUJ1c1Byb3BlcnR5J1xuICAgKi9cbiAgICBjbGFzc2lmeSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IuY2FtZWxpemUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnNpbmd1bGFyaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGZvcmVpZ24ga2V5IHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJvcF9pZF91YmFyIERlZmF1bHQgaXMgdG8gc2VwZXJhdGUgaWQgd2l0aCBhbiB1bmRlcmJhciBhdCB0aGUgZW5kIG9mIHRoZSBjbGFzcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeW91IGNhbiBwYXNzIHRydWUgdG8gc2tpcCBpdC4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuZGVyc2NvcmVkIHBsdXJhbCBub3VucyBiZWNvbWUgdGhlIGNhbWVsIGNhc2VkIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5mb3JlaWduX2tleSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0eV9pZCdcbiAgICogICAgIGluZmxlY3Rpb24uZm9yZWlnbl9rZXkoICdNZXNzYWdlQnVzUHJvcGVydHknLCB0cnVlICk7IC8vID09PSAnbWVzc2FnZV9idXNfcHJvcGVydHlpZCdcbiAgICovXG4gICAgZm9yZWlnbl9rZXkgOiBmdW5jdGlvbiAoIHN0ciwgZHJvcF9pZF91YmFyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IuZGVtb2R1bGl6ZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IudW5kZXJzY29yZSggc3RyICkgKyAoKCBkcm9wX2lkX3ViYXIgKSA/ICggJycgKSA6ICggJ18nICkpICsgJ2lkJztcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIG9yZGluYWxpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIGFsbCBmb3VuZCBudW1iZXJzIHRoZWlyIHNlcXVlbmNlIGxpa2UgJzIybmQnLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24ub3JkaW5hbGl6ZSggJ3RoZSAxIHBpdGNoJyApOyAvLyA9PT0gJ3RoZSAxc3QgcGl0Y2gnXG4gICAqL1xuICAgIG9yZGluYWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICcgJyApO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgdmFyIGsgPSBwYXJzZUludCggc3RyX2FyclsgaSBdLCAxMCApO1xuXG4gICAgICAgIGlmKCAhaXNOYU4oIGsgKSl7XG4gICAgICAgICAgdmFyIGx0ZCA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAyICk7XG4gICAgICAgICAgdmFyIGxkICA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAxICk7XG4gICAgICAgICAgdmFyIHN1ZiA9ICd0aCc7XG5cbiAgICAgICAgICBpZiggbHRkICE9ICcxMScgJiYgbHRkICE9ICcxMicgJiYgbHRkICE9ICcxMycgKXtcbiAgICAgICAgICAgIGlmKCBsZCA9PT0gJzEnICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICdzdCc7XG4gICAgICAgICAgICB9ZWxzZSBpZiggbGQgPT09ICcyJyApe1xuICAgICAgICAgICAgICBzdWYgPSAnbmQnO1xuICAgICAgICAgICAgfWVsc2UgaWYoIGxkID09PSAnMycgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ3JkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHJfYXJyWyBpIF0gKz0gc3VmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfYXJyLmpvaW4oICcgJyApO1xuICAgIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgbXVsdGlwbGUgaW5mbGVjdGlvbiBtZXRob2RzIG9uIGEgc3RyaW5nXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQW4gYXJyYXkgb2YgaW5mbGVjdGlvbiBtZXRob2RzLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udHJhbnNmb3JtKCAnYWxsIGpvYicsIFsgJ3BsdXJhbGl6ZScsICdjYXBpdGFsaXplJywgJ2Rhc2hlcml6ZScgXSk7IC8vID09PSAnQWxsLWpvYnMnXG4gICAqL1xuICAgIHRyYW5zZm9ybSA6IGZ1bmN0aW9uICggc3RyLCBhcnIgKXtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7aSA8IGo7IGkrKyApe1xuICAgICAgICB2YXIgbWV0aG9kID0gYXJyWyBpIF07XG5cbiAgICAgICAgaWYoIGluZmxlY3Rvci5oYXNPd25Qcm9wZXJ0eSggbWV0aG9kICkpe1xuICAgICAgICAgIHN0ciA9IGluZmxlY3RvclsgbWV0aG9kIF0oIHN0ciApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuICBpbmZsZWN0b3IudmVyc2lvbiA9ICcxLjEyLjAnO1xuXG4gIHJldHVybiBpbmZsZWN0b3I7XG59KSk7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoQykgTWljcm9zb2Z0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXG5cblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBSZWZsZWN0O1xuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XG4gICAgLy8gTWV0YWRhdGEgUHJvcG9zYWxcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhL1xuICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDpcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOlxuICAgICAgICAgICAgICAgICAgICBGdW5jdGlvbihcInJldHVybiB0aGlzO1wiKSgpO1xuICAgICAgICB2YXIgZXhwb3J0ZXIgPSBtYWtlRXhwb3J0ZXIoUmVmbGVjdCk7XG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdC5SZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByb290LlJlZmxlY3QgPSBSZWZsZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0ZXIgPSBtYWtlRXhwb3J0ZXIocm9vdC5SZWZsZWN0LCBleHBvcnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yeShleHBvcnRlcik7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VFeHBvcnRlcih0YXJnZXQsIHByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyhrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KShmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcbiAgICAgICAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgICAgIC8vIGZlYXR1cmUgdGVzdCBmb3IgU3ltYm9sIHN1cHBvcnRcbiAgICAgICAgdmFyIHN1cHBvcnRzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB2YXIgdG9QcmltaXRpdmVTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLnRvUHJpbWl0aXZlIDogXCJAQHRvUHJpbWl0aXZlXCI7XG4gICAgICAgIHZhciBpdGVyYXRvclN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcbiAgICAgICAgdmFyIHN1cHBvcnRzQ3JlYXRlID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIjsgLy8gZmVhdHVyZSB0ZXN0IGZvciBPYmplY3QuY3JlYXRlIHN1cHBvcnRcbiAgICAgICAgdmFyIHN1cHBvcnRzUHJvdG8gPSB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5OyAvLyBmZWF0dXJlIHRlc3QgZm9yIF9fcHJvdG9fXyBzdXBwb3J0XG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XG4gICAgICAgIHZhciBIYXNoTWFwID0ge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIG9iamVjdCBpbiBkaWN0aW9uYXJ5IG1vZGUgKGEuay5hLiBcInNsb3dcIiBtb2RlIGluIHY4KVxuICAgICAgICAgICAgY3JlYXRlOiBzdXBwb3J0c0NyZWF0ZVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoT2JqZWN0LmNyZWF0ZShudWxsKSk7IH1cbiAgICAgICAgICAgICAgICA6IHN1cHBvcnRzUHJvdG9cbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7IF9fcHJvdG9fXzogbnVsbCB9KTsgfVxuICAgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KHt9KTsgfSxcbiAgICAgICAgICAgIGhhczogZG93bkxldmVsXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBrZXkgaW4gbWFwOyB9LFxuICAgICAgICAgICAgZ2V0OiBkb3duTGV2ZWxcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gbWFwW2tleV07IH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIExvYWQgZ2xvYmFsIG9yIHNoaW0gdmVyc2lvbnMgb2YgTWFwLCBTZXQsIGFuZCBXZWFrTWFwXG4gICAgICAgIHZhciBmdW5jdGlvblByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbik7XG4gICAgICAgIHZhciB1c2VQb2x5ZmlsbCA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W1wiUkVGTEVDVF9NRVRBREFUQV9VU0VfTUFQX1BPTFlGSUxMXCJdID09PSBcInRydWVcIjtcbiAgICAgICAgdmFyIF9NYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IE1hcCA6IENyZWF0ZU1hcFBvbHlmaWxsKCk7XG4gICAgICAgIHZhciBfU2V0ID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBTZXQgOiBDcmVhdGVTZXRQb2x5ZmlsbCgpO1xuICAgICAgICB2YXIgX1dlYWtNYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKTtcbiAgICAgICAgLy8gW1tNZXRhZGF0YV1dIGludGVybmFsIHNsb3RcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXG4gICAgICAgIHZhciBNZXRhZGF0YSA9IG5ldyBfV2Vha01hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhIHNldCBvZiBkZWNvcmF0b3JzIHRvIGEgcHJvcGVydHkgb2YgYSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZGVjb3JhdG9ycyBBbiBhcnJheSBvZiBkZWNvcmF0b3JzLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IHRvIGRlY29yYXRlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgdGFyZ2V0IGtleS5cbiAgICAgICAgICogQHJlbWFya3MgRGVjb3JhdG9ycyBhcmUgYXBwbGllZCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICBFeGFtcGxlID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcbiAgICAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoSXNOdWxsKGF0dHJpYnV0ZXMpKVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJkZWNvcmF0ZVwiLCBkZWNvcmF0ZSk7XG4gICAgICAgIC8vIDQuMS4yIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI3JlZmxlY3QubWV0YWRhdGFcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGVmYXVsdCBtZXRhZGF0YSBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIG9uIGEgY2xhc3MsIGNsYXNzIG1lbWJlciwgb3IgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgVGhlIGtleSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAgICAgICAgICogQHJldHVybnMgQSBkZWNvcmF0b3IgZnVuY3Rpb24uXG4gICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcbiAgICAgICAgICogbWV0YWRhdGFWYWx1ZSBmb3IgdGhhdCBrZXkgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IsIFR5cGVTY3JpcHQgb25seSlcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSwgVHlwZVNjcmlwdCBvbmx5KVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBwcm9wZXJ0eTtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QoKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBtZXRob2QoKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpICYmICFJc1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcIm1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhIHVuaXF1ZSBtZXRhZGF0YSBlbnRyeSBvbiB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cbiAgICAgICAgICogICAgIGZ1bmN0aW9uIE15QW5ub3RhdGlvbihvcHRpb25zKTogRGVjb3JhdG9yIHtcbiAgICAgICAgICogICAgICAgICByZXR1cm4gKHRhcmdldCwga2V5PykgPT4gUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIHRhcmdldCwga2V5KTtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlZmluZU1ldGFkYXRhXCIsIGRlZmluZU1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW47IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImhhc01ldGFkYXRhXCIsIGhhc01ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGtleSB3YXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiaGFzT3duTWV0YWRhdGFcIiwgaGFzT3duTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRNZXRhZGF0YVwiLCBnZXRNZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRPd25NZXRhZGF0YVwiLCBnZXRPd25NZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFLZXlzXCIsIGdldE1ldGFkYXRhS2V5cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB1bmlxdWUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRPd25NZXRhZGF0YUtleXNcIiwgZ2V0T3duTWV0YWRhdGFLZXlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgdGhlIG1ldGFkYXRhIGVudHJ5IGZyb20gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEgZW50cnkgd2FzIGZvdW5kIGFuZCBkZWxldGVkOyBvdGhlcndpc2UsIGZhbHNlLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHByb3BlcnR5S2V5LCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUobWV0YWRhdGFLZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YU1hcC5zaXplID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IE1ldGFkYXRhLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEuZGVsZXRlKHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRNZXRhZGF0YS5zaXplID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlbGV0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJkZWxldGVNZXRhZGF0YVwiLCBkZWxldGVNZXRhZGF0YSk7XG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3RvcihkZWNvcmF0ZWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBkZWNvcmF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoZGVjb3JhdGVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGRlY29yYXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIENyZWF0ZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KE8pO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmICghQ3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhID0gbmV3IF9NYXAoKTtcbiAgICAgICAgICAgICAgICBNZXRhZGF0YS5zZXQoTywgdGFyZ2V0TWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSkge1xuICAgICAgICAgICAgICAgIGlmICghQ3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwID0gbmV3IF9NYXAoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5zZXQoUCwgbWV0YWRhdGFNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS4xLjEgT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNtZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gICAgICAgICAgICBpZiAoaGFzT3duKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS4yLjEgT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNvd25tZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gVG9Cb29sZWFuKG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS4zLjEgT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRtZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gICAgICAgICAgICBpZiAoaGFzT3duKVxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjQuMSBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG93bm1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNS4xIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5ZGVmaW5lb3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIHRydWUpO1xuICAgICAgICAgICAgbWV0YWRhdGFNYXAuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNi4xIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5bWV0YWRhdGFrZXlzXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XG4gICAgICAgICAgICB2YXIgcGFyZW50S2V5cyA9IE9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gICAgICAgICAgICBpZiAocGFyZW50S2V5cy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcbiAgICAgICAgICAgIGlmIChvd25LZXlzLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xuICAgICAgICAgICAgdmFyIHNldCA9IG5ldyBfU2V0KCk7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvd25LZXlzXzEgPSBvd25LZXlzOyBfaSA8IG93bktleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gb3duS2V5c18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwYXJlbnRLZXlzXzEgPSBwYXJlbnRLZXlzOyBfYSA8IHBhcmVudEtleXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyZW50S2V5c18xW19hXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW93bm1ldGFkYXRha2V5c1xuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICB2YXIga2V5c09iaiA9IG1ldGFkYXRhTWFwLmtleXMoKTtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKGtleXNPYmopO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXNba10gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDYgRUNNQVNjcmlwdCBEYXRhIFR5cDBlcyBhbmQgVmFsdWVzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoeCkge1xuICAgICAgICAgICAgaWYgKHggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogTnVsbCAqLztcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6IHJldHVybiAwIC8qIFVuZGVmaW5lZCAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiByZXR1cm4gMiAvKiBCb29sZWFuICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDMgLyogU3RyaW5nICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjogcmV0dXJuIDQgLyogU3ltYm9sICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIDUgLyogTnVtYmVyICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjogcmV0dXJuIHggPT09IG51bGwgPyAxIC8qIE51bGwgKi8gOiA2IC8qIE9iamVjdCAqLztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gNiAvKiBPYmplY3QgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjEgVGhlIFVuZGVmaW5lZCBUeXBlXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtdW5kZWZpbmVkLXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNVbmRlZmluZWQoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuMiBUaGUgTnVsbCBUeXBlXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtbnVsbC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzTnVsbCh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuNSBUaGUgU3ltYm9sIFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1zeW1ib2wtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc1N5bWJvbCh4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjcgVGhlIE9iamVjdCBUeXBlXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzT2JqZWN0KHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiA/IHggIT09IG51bGwgOiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMSBUeXBlIENvbnZlcnNpb25cbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZS1jb252ZXJzaW9uXG4gICAgICAgIC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuICAgICAgICBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCwgUHJlZmVycmVkVHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoIChUeXBlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBVbmRlZmluZWQgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogTnVsbCAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBCb29sZWFuICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogTnVtYmVyICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGludCA9IFByZWZlcnJlZFR5cGUgPT09IDMgLyogU3RyaW5nICovID8gXCJzdHJpbmdcIiA6IFByZWZlcnJlZFR5cGUgPT09IDUgLyogTnVtYmVyICovID8gXCJudW1iZXJcIiA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgdG9QcmltaXRpdmVTeW1ib2wpO1xuICAgICAgICAgICAgaWYgKGV4b3RpY1RvUHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gXCJkZWZhdWx0XCIgPyBcIm51bWJlclwiIDogaGludCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjEuMSBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG4gICAgICAgICAgICBpZiAoaGludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18xID0gTy50b1N0cmluZztcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18xKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMS5jYWxsKE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZU9mLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18yID0gTy50b1N0cmluZztcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18yKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMi5jYWxsKE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMiBUb0Jvb2xlYW4oYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtdG9ib29sZWFuXG4gICAgICAgIGZ1bmN0aW9uIFRvQm9vbGVhbihhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICEhYXJndW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjEyIFRvU3RyaW5nKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3N0cmluZ1xuICAgICAgICBmdW5jdGlvbiBUb1N0cmluZyhhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBhcmd1bWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMTQgVG9Qcm9wZXJ0eUtleShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxuICAgICAgICBmdW5jdGlvbiBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gVG9QcmltaXRpdmUoYXJndW1lbnQsIDMgLyogU3RyaW5nICovKTtcbiAgICAgICAgICAgIGlmIChJc1N5bWJvbChrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICByZXR1cm4gVG9TdHJpbmcoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIgVGVzdGluZyBhbmQgQ29tcGFyaXNvbiBPcGVyYXRpb25zXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlc3RpbmctYW5kLWNvbXBhcmlzb24tb3BlcmF0aW9uc1xuICAgICAgICAvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4gICAgICAgIGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KGFyZ3VtZW50KVxuICAgICAgICAgICAgICAgIDogYXJndW1lbnQgaW5zdGFuY2VvZiBPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgPyBhcmd1bWVudCBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMi4zIElzQ2FsbGFibGUoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbiAgICAgICAgZnVuY3Rpb24gSXNDYWxsYWJsZShhcmd1bWVudCkge1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMi40IElzQ29uc3RydWN0b3IoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbiAgICAgICAgZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yLjcgSXNQcm9wZXJ0eUtleShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNwcm9wZXJ0eWtleVxuICAgICAgICBmdW5jdGlvbiBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKFR5cGUoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDcuMyBPcGVyYXRpb25zIG9uIE9iamVjdHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1vYmplY3RzXG4gICAgICAgIC8vIDcuMy45IEdldE1ldGhvZChWLCBQKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbiAgICAgICAgZnVuY3Rpb24gR2V0TWV0aG9kKFYsIFApIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gVltQXTtcbiAgICAgICAgICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQgfHwgZnVuYyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNCBPcGVyYXRpb25zIG9uIEl0ZXJhdG9yIE9iamVjdHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1pdGVyYXRvci1vYmplY3RzXG4gICAgICAgIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdldE1ldGhvZChvYmosIGl0ZXJhdG9yU3ltYm9sKTtcbiAgICAgICAgICAgIGlmICghSXNDYWxsYWJsZShtZXRob2QpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gZnJvbSBDYWxsXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBtZXRob2QuY2FsbChvYmopO1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdChpdGVyYXRvcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNC40IEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy1pdGVyYXRvcnZhbHVlXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40LjUgSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcnN0ZXBcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gZmFsc2UgOiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JjbG9zZVxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGl0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgZi5jYWxsKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjEgT3JkaW5hcnkgT2JqZWN0IEludGVybmFsIE1ldGhvZHMgYW5kIEludGVybmFsIFNsb3RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90c1xuICAgICAgICAvLyA5LjEuMS4xIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTylcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnlnZXRwcm90b3R5cGVvZlxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTyAhPT0gXCJmdW5jdGlvblwiIHx8IE8gPT09IGZ1bmN0aW9uUHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBzZXQgX19wcm90b19fIGluIEVTNSwgYXMgaXQncyBub24tc3RhbmRhcmQuXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLiBDb21wYXRpYmxlIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgLy8gbXVzdCBlaXRoZXIgc2V0IF9fcHJvdG9fXyBvbiBhIHN1YmNsYXNzIGNvbnN0cnVjdG9yIHRvIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgLy8gb3IgZW5zdXJlIGVhY2ggY2xhc3MgaGFzIGEgdmFsaWQgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBvbiBpdHMgcHJvdG90eXBlIHRoYXRcbiAgICAgICAgICAgIC8vIHBvaW50cyBiYWNrIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIEZ1bmN0aW9uLltbUHJvdG90eXBlXV0sIHRoZW4gdGhpcyBpcyBkZWZpbmF0ZWx5IGluaGVyaXRlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBpbiBFUzYgb3Igd2hlbiB1c2luZyBfX3Byb3RvX18gaW4gYSBjb21wYXRpYmxlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAocHJvdG8gIT09IGZ1bmN0aW9uUHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIElmIHRoZSBzdXBlciBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZSwgbnVsbCwgb3IgdW5kZWZpbmVkLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE8ucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHByb3RvdHlwZVByb3RvID0gcHJvdG90eXBlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKHByb3RvdHlwZVByb3RvID09IG51bGwgfHwgcHJvdG90eXBlUHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnN0cnVjdG9yIHdhcyBub3QgYSBmdW5jdGlvbiwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvdHlwZVByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc29tZSBraW5kIG9mIHNlbGYtcmVmZXJlbmNlLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBwcmV0dHkgZ29vZCBndWVzcyBhdCB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmFpdmUgTWFwIHNoaW1cbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlTWFwUG9seWZpbGwoKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVTZW50aW5lbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGFycmF5U2VudGluZWwgPSBbXTtcbiAgICAgICAgICAgIHZhciBNYXBJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZXMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc2VsZWN0b3IodGhpcy5fa2V5c1tpbmRleF0sIHRoaXMuX3ZhbHVlc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwSXRlcmF0b3I7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9rZXlzLmxlbmd0aDsgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSkgPj0gMDsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHRoaXMuX3ZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5c1tpIC0gMV0gPSB0aGlzLl9rZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5fY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0VmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEVudHJ5KTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5fZmluZCA9IGZ1bmN0aW9uIChrZXksIGluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZih0aGlzLl9jYWNoZUtleSA9IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IHRoaXMuX2tleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUluZGV4O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hcDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmFpdmUgU2V0IHNoaW1cbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlU2V0UG9seWZpbGwoKSB7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IF9NYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnNpemU7IH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLnNldCh2YWx1ZSwgdmFsdWUpLCB0aGlzOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tYXAuY2xlYXIoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5haXZlIFdlYWtNYXAgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKSB7XG4gICAgICAgICAgICB2YXIgVVVJRF9TSVpFID0gMTY7XG4gICAgICAgICAgICB2YXIga2V5cyA9IEhhc2hNYXAuY3JlYXRlKCk7XG4gICAgICAgICAgICB2YXIgcm9vdEtleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xuICAgICAgICAgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuaGFzKHRhYmxlLCB0aGlzLl9rZXkpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZSAhPT0gdW5kZWZpbmVkID8gSGFzaE1hcC5nZXQodGFibGUsIHRoaXMuX2tleSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlW3RoaXMuX2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZSAhPT0gdW5kZWZpbmVkID8gZGVsZXRlIHRhYmxlW3RoaXMuX2tleV0gOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBub3QgYSByZWFsIGNsZWFyLCBqdXN0IG1ha2VzIHRoZSBwcmV2aW91cyBkYXRhIHVucmVhY2hhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYWtNYXA7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVW5pcXVlS2V5KCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJAQFdlYWtNYXBAQFwiICsgQ3JlYXRlVVVJRCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChIYXNoTWFwLmhhcyhrZXlzLCBrZXkpKTtcbiAgICAgICAgICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCByb290S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHJvb3RLZXksIHsgdmFsdWU6IEhhc2hNYXAuY3JlYXRlKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcm9vdEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBGaWxsUmFuZG9tQnl0ZXMoYnVmZmVyLCBzaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAweGZmIHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gR2VuUmFuZG9tQnl0ZXMoc2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSksIHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBBcnJheShzaXplKSwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVVVUlEKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gR2VuUmFuZG9tQnl0ZXMoVVVJRF9TSVpFKTtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIHJhbmRvbSAtIFJGQyA0MTIyIMKnIDQuNFxuICAgICAgICAgICAgICAgIGRhdGFbNl0gPSBkYXRhWzZdICYgMHg0ZiB8IDB4NDA7XG4gICAgICAgICAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gJiAweGJmIHwgMHg4MDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBVVUlEX1NJWkU7ICsrb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSA0IHx8IG9mZnNldCA9PT0gNiB8fCBvZmZzZXQgPT09IDgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlIDwgMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBieXRlLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVzZXMgYSBoZXVyaXN0aWMgdXNlZCBieSB2OCBhbmQgY2hha3JhIHRvIGZvcmNlIGFuIG9iamVjdCBpbnRvIGRpY3Rpb25hcnkgbW9kZS5cbiAgICAgICAgZnVuY3Rpb24gTWFrZURpY3Rpb25hcnkob2JqKSB7XG4gICAgICAgICAgICBvYmouX18gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9fO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoUmVmbGVjdCB8fCAoUmVmbGVjdCA9IHt9KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYW55LXByb21pc2UnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGZvcm1hdCA9IHV0aWwuZm9ybWF0O1xuXG5mdW5jdGlvbiBUaW1lb3V0RXJyb3IobWVzc2FnZSwgZXJyKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRpbWVvdXRFcnJvcik7XG4gIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnByZXZpb3VzID0gZXJyO1xufVxuXG51dGlsLmluaGVyaXRzKFRpbWVvdXRFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBtYXRjaGVzKG1hdGNoLCBlcnIpIHtcbiAgaWYgKG1hdGNoID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgbWF0Y2gpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiAhIW1hdGNoKGVycik7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaCA9PT0gZXJyLnRvU3RyaW5nKCkpIHJldHVybiB0cnVlO1xuICBpZiAobWF0Y2ggPT09IGVyci5tZXNzYWdlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgJiYgKG1hdGNoLnRlc3QoZXJyLm1lc3NhZ2UpIHx8IG1hdGNoLnRlc3QoZXJyLnRvU3RyaW5nKCkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXRyeUFzUHJvbWlzZWQoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKCFjYWxsYmFjayB8fCAhb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdyZXRyeS1hcy1wcm9taXNlZCBtdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrIGFuZCBhIG9wdGlvbnMgc2V0IG9yIGEgbnVtYmVyJ1xuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heDogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICAvLyBTdXBlciBjaGVhcCBjbG9uZVxuICBvcHRpb25zID0ge1xuICAgICRjdXJyZW50OiBvcHRpb25zLiRjdXJyZW50IHx8IDEsXG4gICAgbWF4OiBvcHRpb25zLm1heCxcbiAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgdW5kZWZpbmVkLFxuICAgIG1hdGNoOiBvcHRpb25zLm1hdGNoIHx8IFtdLFxuICAgIGJhY2tvZmZCYXNlOiBvcHRpb25zLmJhY2tvZmZCYXNlID09PSB1bmRlZmluZWQgPyAxMDAgOiBvcHRpb25zLmJhY2tvZmZCYXNlLFxuICAgIGJhY2tvZmZFeHBvbmVudDogb3B0aW9ucy5iYWNrb2ZmRXhwb25lbnQgfHwgMS4xLFxuICAgIHJlcG9ydDogb3B0aW9ucy5yZXBvcnQgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgbmFtZTogb3B0aW9ucy5uYW1lIHx8IGNhbGxiYWNrLm5hbWUgfHwgJ3Vua25vd24nXG4gIH07XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMubWF0Y2gpKSBvcHRpb25zLm1hdGNoID0gW29wdGlvbnMubWF0Y2hdO1xuICBvcHRpb25zLnJlcG9ydCgnVHJ5aW5nICcgKyBvcHRpb25zLm5hbWUgKyAnICMnICsgb3B0aW9ucy4kY3VycmVudCArICcgYXQgJyArIG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCksIG9wdGlvbnMpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdGltZW91dCwgYmFja29mZlRpbWVvdXQsIGxhc3RFcnJvcjtcblxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYmFja29mZlRpbWVvdXQpIGNsZWFyVGltZW91dChiYWNrb2ZmVGltZW91dCk7XG4gICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKG9wdGlvbnMubmFtZSArICcgdGltZWQgb3V0JywgbGFzdEVycm9yKSk7XG4gICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZShjYWxsYmFjayh7IGN1cnJlbnQ6IG9wdGlvbnMuJGN1cnJlbnQgfSkpXG4gICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGlmIChiYWNrb2ZmVGltZW91dCkgY2xlYXJUaW1lb3V0KGJhY2tvZmZUaW1lb3V0KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGlmIChiYWNrb2ZmVGltZW91dCkgY2xlYXJUaW1lb3V0KGJhY2tvZmZUaW1lb3V0KTtcblxuICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgIG9wdGlvbnMucmVwb3J0KChlcnIgJiYgZXJyLnRvU3RyaW5nKCkpIHx8IGVyciwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIG5vdCByZXRyeSBpZiBtYXggaGFzIGJlZW4gcmVhY2hlZFxuICAgICAgICB2YXIgc2hvdWxkUmV0cnkgPSBvcHRpb25zLiRjdXJyZW50IDwgb3B0aW9ucy5tYXg7XG4gICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgc2hvdWxkUmV0cnkgPSBvcHRpb25zLm1hdGNoLmxlbmd0aCA9PT0gMCB8fCBvcHRpb25zLm1hdGNoLnNvbWUoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXMobWF0Y2gsIGVycilcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHJldHVybiByZWplY3QoZXJyKTtcblxuICAgICAgICB2YXIgcmV0cnlEZWxheSA9IE1hdGgucG93KFxuICAgICAgICAgIG9wdGlvbnMuYmFja29mZkJhc2UsXG4gICAgICAgICAgTWF0aC5wb3cob3B0aW9ucy5iYWNrb2ZmRXhwb25lbnQsIG9wdGlvbnMuJGN1cnJlbnQgLSAxKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERvIHNvbWUgYWNjb3VudGluZ1xuICAgICAgICBvcHRpb25zLiRjdXJyZW50Kys7XG4gICAgICAgIG9wdGlvbnMucmVwb3J0KGZvcm1hdCgnUmV0cnlpbmcgJXMgKCVzKScsIG9wdGlvbnMubmFtZSwgb3B0aW9ucy4kY3VycmVudCksIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZXRyeURlbGF5KSB7XG4gICAgICAgICAgLy8gVXNlIGJhY2tvZmYgZnVuY3Rpb24gdG8gZWFzZSByZXRyeSByYXRlXG4gICAgICAgICAgb3B0aW9ucy5yZXBvcnQoZm9ybWF0KCdEZWxheWluZyByZXRyeSBvZiAlcyBieSAlcycsIG9wdGlvbnMubmFtZSwgcmV0cnlEZWxheSksIG9wdGlvbnMpO1xuICAgICAgICAgIGJhY2tvZmZUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHJ5QXNQcm9taXNlZChjYWxsYmFjaywgb3B0aW9ucylcbiAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSwgcmV0cnlEZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0cnlBc1Byb21pc2VkKGNhbGxiYWNrLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCIvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0KClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICAgIHRoaXMucmF3ID0gcmFuZ2VcbiAgICB0aGlzLnNldCA9IHJhbmdlXG4gICAgICAuc3BsaXQoL1xccypcXHxcXHxcXHMqLylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyYW5nZSA9PiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3JhbmdlfWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0XG4gICAgICAubWFwKChjb21wcykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCd8fCcpXG4gICAgICAudHJpbSgpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuXG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmpvaW4oJywnKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBgcGFyc2VSYW5nZToke21lbW9PcHRzfToke3JhbmdlfWBcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQobWVtb0tleSlcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgcmV0dXJuIGNhY2hlZFxuXG4gICAgY29uc3QgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBjb25zdCBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpXG4gICAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVt0LkNPTVBBUkFUT1JUUklNXSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGNvbnN0IGNvbXBSZSA9IGxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICAuZmlsdGVyKHRoaXMub3B0aW9ucy5sb29zZSA/IGNvbXAgPT4gISFjb21wLm1hdGNoKGNvbXBSZSkgOiAoKSA9PiB0cnVlKVxuICAgICAgLm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbCA9IHJhbmdlTGlzdC5sZW5ndGhcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiByYW5nZUxpc3QpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpXG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSlcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKHsgbWF4OiAxMDAwIH0pXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZVxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgaXNOdWxsU2V0ID0gYyA9PiBjLnZhbHVlID09PSAnPDAuMC4wLTAnXG5jb25zdCBpc0FueSA9IGMgPT4gYy52YWx1ZSA9PT0gJydcblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmNvbnN0IGlzU2F0aXNmaWFibGUgPSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgY29uc3QgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeSgob3RoZXJDb21wYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuY29uc3QgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmNvbnN0IGlzWCA9IGlkID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMC0wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIGNvbnN0IHhNID0gaXNYKE0pXG4gICAgY29uc3QgeG0gPSB4TSB8fCBpc1gobSlcbiAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKVxuICAgIGNvbnN0IGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndGx0ID09PSAnPCcpXG4gICAgICAgIHByID0gJy0wJ1xuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG5jb25zdCBoeXBoZW5SZXBsYWNlID0gaW5jUHIgPT4gKCQwLFxuICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICB0bywgdE0sIHRtLCB0cCwgdHByLCB0YikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIChgJHtmcm9tfSAke3RvfWApLnRyaW0oKVxufVxuXG5jb25zdCB0ZXN0U2V0ID0gKHNldCwgdmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQ29tcGFyYXRvci5BTlkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyXG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgY29tcGFyZUlkZW50aWZpZXJzIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgICAgdmVyc2lvbi5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtNQVhfTEVOR1RIfSBjaGFyYWN0ZXJzYFxuICAgICAgKVxuICAgIH1cblxuICAgIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgLy8gdGhpcyBpc24ndCBhY3R1YWxseSByZWxldmFudCBmb3IgdmVyc2lvbnMsIGJ1dCBrZWVwIGl0IHNvIHRoYXQgd2VcbiAgICAvLyBkb24ndCBydW4gaW50byB0cm91YmxlIHBhc3NpbmcgdGhpcy5vcHRpb25zIGFyb3VuZC5cbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICBjb25zdCBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gob3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXSlcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICB0aGlzLnJhdyA9IHZlcnNpb25cblxuICAgIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gICAgdGhpcy5tYWpvciA9ICttWzFdXG4gICAgdGhpcy5taW5vciA9ICttWzJdXG4gICAgdGhpcy5wYXRjaCA9ICttWzNdXG5cbiAgICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgICBpZiAoIW1bNF0pIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK2lkXG4gICAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW11cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IGAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWBcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgdGhpcy52ZXJzaW9uICs9IGAtJHt0aGlzLnByZXJlbGVhc2Uuam9pbignLicpfWBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIGNvbXBhcmUgKG90aGVyKSB7XG4gICAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKVxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycgJiYgb3RoZXIgPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKVxuICB9XG5cbiAgY29tcGFyZU1haW4gKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKVxuICAgIClcbiAgfVxuXG4gIGNvbXBhcmVQcmUgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMucHJlcmVsZWFzZVtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLnByZXJlbGVhc2VbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIGNvbXBhcmVCdWlsZCAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmJ1aWxkW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIuYnVpbGRbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgICAvLyBwcmVwYXRjaC5cbiAgICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgY29lcmNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBsZXQgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHBhcnNlKGAke21hdGNoWzJdfS4ke21hdGNoWzNdIHx8ICcwJ30uJHttYXRjaFs0XSB8fCAnMCd9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IHtNQVhfTEVOR1RIfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFNlbVZlcjogcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKS5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKS5yY29tcGFyZUlkZW50aWZpZXJzLFxuICBwYXJzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKSxcbiAgdmFsaWQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJyksXG4gIGNsZWFuOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpLFxuICBpbmM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpLFxuICBkaWZmOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJyksXG4gIG1ham9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpLFxuICBtaW5vcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKSxcbiAgcGF0Y2g6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJyksXG4gIHByZXJlbGVhc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKSxcbiAgY29tcGFyZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpLFxuICByY29tcGFyZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKSxcbiAgY29tcGFyZUxvb3NlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJyksXG4gIGNvbXBhcmVCdWlsZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpLFxuICBzb3J0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JyksXG4gIHJzb3J0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpLFxuICBndDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKSxcbiAgbHQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JyksXG4gIGVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpLFxuICBuZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpLFxuICBndGU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpLFxuICBsdGU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpLFxuICBjbXA6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpLFxuICBjb2VyY2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpLFxuICBDb21wYXJhdG9yOiByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpLFxuICBSYW5nZTogcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJyksXG4gIHNhdGlzZmllczogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJyksXG4gIHRvQ29tcGFyYXRvcnM6IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJyksXG4gIG1heFNhdGlzZnlpbmc6IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJyksXG4gIG1pblNhdGlzZnlpbmc6IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJyksXG4gIG1pblZlcnNpb246IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJyksXG4gIHZhbGlkUmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJyksXG4gIG91dHNpZGU6IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKSxcbiAgZ3RyOiByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKSxcbiAgbHRyOiByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKSxcbiAgaW50ZXJzZWN0czogcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpLFxuICBzaW1wbGlmeVJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpLFxuICBzdWJzZXQ6IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpLFxufVxuIiwiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIXG59XG4iLCJjb25zdCBkZWJ1ZyA9IChcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MuZW52ICYmXG4gIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbikgPyAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcignU0VNVkVSJywgLi4uYXJncylcbiAgOiAoKSA9PiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnXG4iLCJjb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzXG59XG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0IHNvIHdlIGFsd2F5cyBnZXQgYSBjb25zaXN0ZW50XG4vLyBvYmogd2l0aCBrZXlzIGluIGEgY29uc2lzdGVudCBvcmRlci5cbmNvbnN0IG9wdHMgPSBbJ2luY2x1ZGVQcmVyZWxlYXNlJywgJ2xvb3NlJywgJ3J0bCddXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+XG4gICFvcHRpb25zID8ge31cbiAgOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IGxvb3NlOiB0cnVlIH1cbiAgOiBvcHRzLmZpbHRlcihrID0+IG9wdGlvbnNba10pLnJlZHVjZSgob3B0aW9ucywgaykgPT4ge1xuICAgIG9wdGlvbnNba10gPSB0cnVlXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfSwge30pXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgeyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcoaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdbMC05XSsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKicpXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCAnWzAtOUEtWmEtei1dKycpXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcLjBcXC4wLTBcXFxccyokJylcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsImNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSlcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHtBTll9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghbWluKVxuICAgICAgICBtaW4gPSB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFttaW4sIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIG1pbiA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKG1pbilcbiAgICBzZXQucHVzaChbbWluLCBudWxsXSlcblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIGVsc2UgaWYgKCFtYXgpXG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIGVsc2UgaWYgKG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgZWxzZVxuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKVxuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJykgXVxuICAgIGVsc2VcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgZG9tID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49JylcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpXG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKVxuICAgIHJldHVybiBudWxsXG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2dyZWdhdGVFcnJvciA9IHZvaWQgMDtcbmNsYXNzIEFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FnZ3JlZ2F0ZUVycm9yJztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQWdncmVnYXRlRXJyb3Igb2Y6XFxuJHt0aGlzLmVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZXJyb3IpID0+IGVycm9yID09PSB0aGlzXG4gICAgICAgICAgICA/ICdbQ2lyY3VsYXIgQWdncmVnYXRlRXJyb3JdJ1xuICAgICAgICAgICAgOiBlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL1xcbiQvLCAnJykucmVwbGFjZSgvXi9nbSwgJyAgJylcbiAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXi9nbSwgJyAgICAnKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAuam9pbignXFxuJyl9XFxuYDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxufVxuZXhwb3J0cy5BZ2dyZWdhdGVFcnJvciA9IEFnZ3JlZ2F0ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdncmVnYXRlRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmVycmVkID0gdm9pZCAwO1xuY29uc3QgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKFwiLi9UaW1lb3V0RXJyb3JcIik7XG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyVGltZW91dCh0aW1lb3V0SW5NaWxsaXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QobmV3IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcignT3BlcmF0aW9uIHRpbWVvdXQnKSk7XG4gICAgICAgIH0sIHRpbWVvdXRJbk1pbGxpcyk7XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGltZW91dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIH1cbiAgICByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gICAgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9XG59XG5leHBvcnRzLkRlZmVycmVkID0gRGVmZXJyZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZlcnJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb29sID0gdm9pZCAwO1xuY29uc3QgRGVmZXJyZWRfMSA9IHJlcXVpcmUoXCIuL0RlZmVycmVkXCIpO1xuY29uc3QgQWdncmVnYXRlRXJyb3JfMSA9IHJlcXVpcmUoXCIuL0FnZ3JlZ2F0ZUVycm9yXCIpO1xuY2xhc3MgUG9vbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmxvZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWZhY3RvcnkuY3JlYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmFjdG9yeS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3Ryb3kgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZhY3RvcnkudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdGUgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkubWluICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgZmFjdG9yeS5taW4gPCAwIHx8XG4gICAgICAgICAgICBmYWN0b3J5Lm1pbiAhPT0gTWF0aC5yb3VuZChmYWN0b3J5Lm1pbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWluIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5Lm1heCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIGZhY3RvcnkubWF4IDw9IDAgfHxcbiAgICAgICAgICAgIGZhY3RvcnkubWF4ICE9PSBNYXRoLnJvdW5kKGZhY3RvcnkubWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXggbXVzdCBiZSBhbiBpbnRlZ2VyID4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWN0b3J5Lm1pbiA+IGZhY3RvcnkubWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heCBpcyBzbWFsbGVyIHRoYW4gbWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhY3RvcnkubWF4VXNlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAodHlwZW9mIGZhY3RvcnkubWF4VXNlcyAhPT0gJ251bWJlcicgfHwgZmFjdG9yeS5tYXhVc2VzIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4VXNlcyBtdXN0IGJlIGFuIGludGVnZXIgPj0gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNaWxsaXMgPSBmYWN0b3J5LmlkbGVUaW1lb3V0TWlsbGlzIHx8IDMwMDAwO1xuICAgICAgICB0aGlzLmFjcXVpcmVUaW1lb3V0TWlsbGlzID0gZmFjdG9yeS5hY3F1aXJlVGltZW91dE1pbGxpcyB8fCAzMDAwMDtcbiAgICAgICAgdGhpcy5yZWFwSW50ZXJ2YWxNaWxsaXMgPSBmYWN0b3J5LnJlYXBJbnRlcnZhbE1pbGxpcyB8fCAxMDAwO1xuICAgICAgICB0aGlzLm1heFVzZXNQZXJSZXNvdXJjZSA9IGZhY3RvcnkubWF4VXNlcyB8fCBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5sb2cgPSBmYWN0b3J5LmxvZyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0FjcXVpcmVzID0gW107XG4gICAgICAgIHRoaXMuX2luVXNlT2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVPYmplY3RzID0gW107XG4gICAgICAgIHRoaXMuX3JlbW92ZUlkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5Lm5hbWU7XG4gICAgfVxuICAgIGdldCBhdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHVzaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5Vc2VPYmplY3RzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHdhaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQWNxdWlyZXMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbWF4U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkubWF4O1xuICAgIH1cbiAgICBnZXQgbWluU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkubWluO1xuICAgIH1cbiAgICBfbG9nKG1lc3NhZ2UsIGxldmVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKG1lc3NhZ2UsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxvZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bGV2ZWwudG9VcHBlckNhc2UoKX0gcG9vbCAke3RoaXMubmFtZSB8fCAnJ30gLSAke21lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlbW92ZUlkbGUoKSB7XG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1heFJlbW92YWJsZSA9IHRoaXMuc2l6ZSAtIHRoaXMubWluU2l6ZTtcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3JlbW92ZUlkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF2YWlsYWJsZSAmJiBtYXhSZW1vdmFibGUgPiB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGltZW91dCA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHNbaV0udGltZW91dDtcbiAgICAgICAgICAgIGlmIChub3cgPj0gdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygncmVtb3ZlSWRsZSgpIGRlc3Ryb3lpbmcgb2JqIC0gbm93OicgKyBub3cgKyAnIHRpbWVvdXQ6JyArIHRpbWVvdXQsICd2ZXJib3NlJyk7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaCh0aGlzLl9hdmFpbGFibGVPYmplY3RzW2ldLnJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1JlbW92ZS5mb3JFYWNoKHRoaXMuZGVzdHJveSwgdGhpcyk7XG4gICAgICAgIGF2YWlsYWJsZSA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoO1xuICAgICAgICBpZiAoYXZhaWxhYmxlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCd0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aD0nICsgYXZhaWxhYmxlLCAndmVyYm9zZScpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVSZW1vdmVJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ3JlbW92ZUlkbGUoKSBhbGwgb2JqZWN0cyByZW1vdmVkJywgJ3ZlcmJvc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2NoZWR1bGVSZW1vdmVJZGxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbW92ZUlkbGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZSgpO1xuICAgICAgICAgICAgfSwgdGhpcy5yZWFwSW50ZXJ2YWxNaWxsaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kaXNwZW5zZSgpIHtcbiAgICAgICAgbGV0IHdyYXBwZWRSZXNvdXJjZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHdhaXRpbmdDb3VudCA9IHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2xvZyhgZGlzcGVuc2UoKSBjbGllbnRzPSR7d2FpdGluZ0NvdW50fSBhdmFpbGFibGU9JHt0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aH1gLCAnaW5mbycpO1xuICAgICAgICBpZiAod2FpdGluZ0NvdW50IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnZGlzcGVuc2UoKSAtIHJldXNpbmcgb2JqJywgJ3ZlcmJvc2UnKTtcbiAgICAgICAgICAgIHdyYXBwZWRSZXNvdXJjZSA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHNbdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmFjdG9yeS52YWxpZGF0ZSh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVPYmplY3RzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkUmVzb3VyY2VUb0luVXNlT2JqZWN0cyh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UsIHdyYXBwZWRSZXNvdXJjZS51c2VDb3VudCk7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUod3JhcHBlZFJlc291cmNlLnJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplIDwgdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVSZXNvdXJjZSgpIHtcbiAgICAgICAgdGhpcy5fY291bnQgKz0gMTtcbiAgICAgICAgdGhpcy5fbG9nKGBjcmVhdGVSZXNvdXJjZSgpIC0gY3JlYXRpbmcgb2JqIC0gY291bnQ9JHt0aGlzLnNpemV9IG1pbj0ke3RoaXMubWluU2l6ZX0gbWF4PSR7dGhpcy5tYXhTaXplfWAsICd2ZXJib3NlJyk7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGUoKVxuICAgICAgICAgICAgLnRoZW4oKHJlc291cmNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmVzb3VyY2VUb0luVXNlT2JqZWN0cyhyZXNvdXJjZSwgMCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSZXNvdXJjZVRvQXZhaWxhYmxlT2JqZWN0cyhyZXNvdXJjZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudCA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BlbnNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRSZXNvdXJjZVRvQXZhaWxhYmxlT2JqZWN0cyhyZXNvdXJjZSwgdXNlQ291bnQpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFJlc291cmNlID0ge1xuICAgICAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlLFxuICAgICAgICAgICAgdXNlQ291bnQ6IHVzZUNvdW50LFxuICAgICAgICAgICAgdGltZW91dDogRGF0ZS5ub3coKSArIHRoaXMuaWRsZVRpbWVvdXRNaWxsaXMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZU9iamVjdHMucHVzaCh3cmFwcGVkUmVzb3VyY2UpO1xuICAgICAgICB0aGlzLl9kaXNwZW5zZSgpO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlbW92ZUlkbGUoKTtcbiAgICB9XG4gICAgX2FkZFJlc291cmNlVG9JblVzZU9iamVjdHMocmVzb3VyY2UsIHVzZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRSZXNvdXJjZSA9IHtcbiAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgIHVzZUNvdW50OiB1c2VDb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5Vc2VPYmplY3RzLnB1c2god3JhcHBlZFJlc291cmNlKTtcbiAgICB9XG4gICAgX2Vuc3VyZU1pbmltdW0oKSB7XG4gICAgICAgIGxldCBpLCBkaWZmO1xuICAgICAgICBpZiAoIXRoaXMuX2RyYWluaW5nICYmIHRoaXMuc2l6ZSA8IHRoaXMubWluU2l6ZSkge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMubWluU2l6ZSAtIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmFpbmluZykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigncG9vbCBpcyBkcmFpbmluZyBhbmQgY2Fubm90IGFjY2VwdCB3b3JrJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgZGVmZXJyZWQucmVnaXN0ZXJUaW1lb3V0KHRoaXMuYWNxdWlyZVRpbWVvdXRNaWxsaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdBY3F1aXJlcyA9IHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5maWx0ZXIoKHBlbmRpbmcpID0+IHBlbmRpbmcgIT09IGRlZmVycmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgdGhpcy5fZGlzcGVuc2UoKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9XG4gICAgcmVsZWFzZShyZXNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5zb21lKChyZXNvdXJjZVdpdGhUaW1lb3V0KSA9PiByZXNvdXJjZVdpdGhUaW1lb3V0LnJlc291cmNlID09PSByZXNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygncmVsZWFzZSBjYWxsZWQgdHdpY2UgZm9yIHRoZSBzYW1lIHJlc291cmNlOiAnICsgbmV3IEVycm9yKCkuc3RhY2ssICdlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5Vc2VPYmplY3RzLmZpbmRJbmRleCgod3JhcHBlZFJlc291cmNlKSA9PiB3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UgPT09IHJlc291cmNlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdhdHRlbXB0IHRvIHJlbGVhc2UgYW4gaW52YWxpZCByZXNvdXJjZTogJyArIG5ldyBFcnJvcigpLnN0YWNrLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkUmVzb3VyY2UgPSB0aGlzLl9pblVzZU9iamVjdHNbaW5kZXhdO1xuICAgICAgICB3cmFwcGVkUmVzb3VyY2UudXNlQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKHdyYXBwZWRSZXNvdXJjZS51c2VDb3VudCA+PSB0aGlzLm1heFVzZXNQZXJSZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdyZWxlYXNlKCkgZGVzdHJveWluZyBvYmogLSB1c2VDb3VudDonICtcbiAgICAgICAgICAgICAgICB3cmFwcGVkUmVzb3VyY2UudXNlQ291bnQgK1xuICAgICAgICAgICAgICAgICcgbWF4VXNlc1BlclJlc291cmNlOicgK1xuICAgICAgICAgICAgICAgIHRoaXMubWF4VXNlc1BlclJlc291cmNlLCAndmVyYm9zZScpO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwZW5zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5Vc2VPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZXNvdXJjZVRvQXZhaWxhYmxlT2JqZWN0cyh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UsIHdyYXBwZWRSZXNvdXJjZS51c2VDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveShyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB1c2luZyA9IHRoaXMuX2luVXNlT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVPYmplY3RzID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5maWx0ZXIoKG9iamVjdCkgPT4gb2JqZWN0LnJlc291cmNlICE9PSByZXNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9pblVzZU9iamVjdHMgPSB0aGlzLl9pblVzZU9iamVjdHMuZmlsdGVyKChvYmplY3QpID0+IG9iamVjdC5yZXNvdXJjZSAhPT0gcmVzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSA9PT0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB1c2luZyA9PT0gdGhpcy5faW5Vc2VPYmplY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZU1pbmltdW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50IDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX2ZhY3RvcnkuZGVzdHJveShyZXNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVNaW5pbXVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgdGhpcy5fbG9nKCdkcmFpbmluZycsICdpbmZvJyk7XG4gICAgICAgIHRoaXMuX2RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQWNxdWlyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BlbnNlKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aCAhPT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBjaGVjayhyZXNvbHZlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3lBbGxOb3coKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ2ZvcmNlIGRlc3Ryb3lpbmcgYWxsIG9iamVjdHMnLCAnaW5mbycpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZUlkbGVUaW1lcik7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLm1hcCgocmVzb3VyY2UpID0+IHJlc291cmNlLnJlc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlc3Ryb3kocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdFcnJvciBkZXN0cm95aW5nIHJlc291cmNlOiAnICsgZXguc3RhY2ssICdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yXzEuQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb29sID0gUG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IHZvaWQgMDtcbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRpbWVvdXRFcnJvcl8xID0gcmVxdWlyZShcIi4vVGltZW91dEVycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZW91dEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBUaW1lb3V0RXJyb3JfMS5UaW1lb3V0RXJyb3I7IH0gfSk7XG52YXIgUG9vbF8xID0gcmVxdWlyZShcIi4vUG9vbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvb2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBvb2xfMS5Qb29sOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZmVyQWxpYXMgPSB2b2lkIDA7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG4vKipcbiAqIFByZSBjb25mb3JtIGluY2x1ZGVzLCBzbyB0aGF0IFwiYXNcIiB2YWx1ZSBjYW4gYmUgaW5mZXJyZWQgZnJvbSBzb3VyY2VcbiAqL1xuZnVuY3Rpb24gaW5mZXJBbGlhcyhvcHRpb25zLCBzb3VyY2UpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8vIGlmIGluY2x1ZGUgaXMgbm90IGFuIGFycmF5LCB3cmFwIGluIGFuIGFycmF5XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZSkpIHtcbiAgICAgICAgb3B0aW9ucy5pbmNsdWRlID0gW29wdGlvbnMuaW5jbHVkZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmluY2x1ZGU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IGFsbCBpbmNsdWRlZCBlbGVtZW50cyB0byB7IG1vZGVsOiBNb2RlbCB9IGZvcm1cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUubWFwKChpbmNsdWRlKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgPSBpbmZlckFsaWFzRm9ySW5jbHVkZShpbmNsdWRlLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMuaW5mZXJBbGlhcyA9IGluZmVyQWxpYXM7XG4vKipcbiAqIFByZSBjb25mb3JtIGluY2x1ZGUsIHNvIHRoYXQgYWxpYXMgKFwiYXNcIikgdmFsdWUgY2FuIGJlIGluZmVycmVkIGZyb20gc291cmNlIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGluZmVyQWxpYXNGb3JJbmNsdWRlKGluY2x1ZGUsIHNvdXJjZSkge1xuICAgIGNvbnN0IGhhc01vZGVsT3B0aW9uV2l0aG91dEFzT3B0aW9uID0gISEoaW5jbHVkZS5tb2RlbCAmJiAhaW5jbHVkZS5hcyk7XG4gICAgY29uc3QgaGFzSW5jbHVkZU9wdGlvbnMgPSAhIWluY2x1ZGUuaW5jbHVkZTtcbiAgICBjb25zdCBpc0NvbnN0cnVjdG9yRm4gPSBpbmNsdWRlIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gICAgaWYgKGlzQ29uc3RydWN0b3JGbiB8fCBoYXNNb2RlbE9wdGlvbldpdGhvdXRBc09wdGlvbikge1xuICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvckZuKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0geyBtb2RlbDogaW5jbHVkZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFByb3RvdHlwZSA9IHNvdXJjZS5wcm90b3R5cGUgfHwgc291cmNlO1xuICAgICAgICBjb25zdCByZWxhdGVkQ2xhc3MgPSBpbmNsdWRlLm1vZGVsO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuZ2V0QXNzb2NpYXRpb25zQnlSZWxhdGlvbih0YXJnZXRQcm90b3R5cGUsIHJlbGF0ZWRDbGFzcyk7XG4gICAgICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGlhcyBjYW5ub3QgYmUgaW5mZXJyZWQ6IFwiJHtzb3VyY2UubmFtZX1cIiBoYXMgbXVsdGlwbGUgYCArXG4gICAgICAgICAgICAgICAgICAgIGByZWxhdGlvbnMgd2l0aCBcIiR7aW5jbHVkZS5tb2RlbC5uYW1lfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmNsdWRlLmFzID0gYXNzb2NpYXRpb25zWzBdLmdldEFzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0NvbnN0cnVjdG9yRm4gJiYgaGFzSW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgaW5jbHVkZSA9IGluZmVyQWxpYXMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxpYXMtaW5mZXJlbmNlLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlbG9uZ3NUb01hbnlBc3NvY2lhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL3NoYXJlZC9tb2RlbC1ub3QtaW5pdGlhbGl6ZWQtZXJyb3JcIik7XG5jb25zdCBmb3JlaWduX2tleV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZm9yZWlnbi1rZXkvZm9yZWlnbi1rZXktc2VydmljZVwiKTtcbmNvbnN0IGFzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uXCIpO1xuY2xhc3MgQmVsb25nc1RvTWFueUFzc29jaWF0aW9uIGV4dGVuZHMgYmFzZV9hc3NvY2lhdGlvbl8xLkJhc2VBc3NvY2lhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldEFzc29jaWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb25fMS5Bc3NvY2lhdGlvbi5CZWxvbmdzVG9NYW55O1xuICAgIH1cbiAgICBnZXRTZXF1ZWxpemVPcHRpb25zKG1vZGVsLCBzZXF1ZWxpemUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0ZWRDbGFzcyA9IHRoaXMuZ2V0QXNzb2NpYXRlZENsYXNzKCk7XG4gICAgICAgIGNvbnN0IHRocm91Z2hPcHRpb25zID0gdGhpcy5nZXRUaHJvdWdoT3B0aW9ucyhzZXF1ZWxpemUpO1xuICAgICAgICBjb25zdCB0aHJvdWdoTW9kZWwgPSB0eXBlb2YgdGhyb3VnaE9wdGlvbnMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvdWdoT3B0aW9ucy5tb2RlbCAhPT0gXCJzdHJpbmdcIiA/IHRocm91Z2hPcHRpb25zLm1vZGVsIDogdW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zLnRocm91Z2ggPSB0aHJvdWdoT3B0aW9ucztcbiAgICAgICAgb3B0aW9ucy5mb3JlaWduS2V5ID0gZm9yZWlnbl9rZXlfc2VydmljZV8xLmdldEZvcmVpZ25LZXlPcHRpb25zKG1vZGVsLCB0aHJvdWdoTW9kZWwsIHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgb3B0aW9ucy5vdGhlcktleSA9IGZvcmVpZ25fa2V5X3NlcnZpY2VfMS5nZXRGb3JlaWduS2V5T3B0aW9ucyhhc3NvY2lhdGVkQ2xhc3MsIHRocm91Z2hNb2RlbCwgdGhpcy5vcHRpb25zLm90aGVyS2V5KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGdldFRocm91Z2hPcHRpb25zKHNlcXVlbGl6ZSkge1xuICAgICAgICBjb25zdCB0aHJvdWdoID0gdGhpcy5vcHRpb25zLnRocm91Z2g7XG4gICAgICAgIGNvbnN0IHRocm91Z2hNb2RlbCA9IHR5cGVvZiB0aHJvdWdoID09PSAnb2JqZWN0JyA/IHRocm91Z2gubW9kZWwgOiB0aHJvdWdoO1xuICAgICAgICBjb25zdCB0aHJvdWdoT3B0aW9ucyA9IHR5cGVvZiB0aHJvdWdoID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIHRocm91Z2gpIDoge307XG4gICAgICAgIGlmICh0eXBlb2YgdGhyb3VnaE1vZGVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB0aHJvdWdoTW9kZWxDbGFzcyA9IHNlcXVlbGl6ZS5tb2RlbCh0aHJvdWdoTW9kZWwoKSk7XG4gICAgICAgICAgICBpZiAoIXRocm91Z2hNb2RlbENsYXNzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yKHRocm91Z2hNb2RlbENsYXNzLCAnQXNzb2NpYXRpb24gY2Fubm90IGJlIHJlc29sdmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3VnaE9wdGlvbnMubW9kZWwgPSB0aHJvdWdoTW9kZWxDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvdWdoTW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRocm91Z2hPcHRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuQmVsb25nc1RvTWFueUFzc29jaWF0aW9uID0gQmVsb25nc1RvTWFueUFzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by1tYW55LWFzc29jaWF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by1tYW55LW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlbG9uZ3NUb01hbnkgPSB2b2lkIDA7XG5jb25zdCBiZWxvbmdzX3RvX21hbnlfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG8tbWFueS1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlbG9uZ3NUb01hbnkoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCB0aHJvdWdoT3JPcHRpb25zLCBmb3JlaWduS2V5LCBvdGhlcktleSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7IGZvcmVpZ25LZXksIG90aGVyS2V5IH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhyb3VnaE9yT3B0aW9ucyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aHJvdWdoT3JPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRocm91Z2ggPSB0aHJvdWdoT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRocm91Z2hPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5hcylcbiAgICAgICAgICAgIG9wdGlvbnMuYXMgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIGFzc29jaWF0aW9uX3NlcnZpY2VfMS5hZGRBc3NvY2lhdGlvbih0YXJnZXQsIG5ldyBiZWxvbmdzX3RvX21hbnlfYXNzb2NpYXRpb25fMS5CZWxvbmdzVG9NYW55QXNzb2NpYXRpb24oYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuQmVsb25nc1RvTWFueSA9IEJlbG9uZ3NUb01hbnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLW1hbnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlbG9uZ3NUb0Fzc29jaWF0aW9uID0gdm9pZCAwO1xuY29uc3QgYmFzZV9hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9iYXNlLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgZm9yZWlnbl9rZXlfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LXNlcnZpY2VcIik7XG5jb25zdCBhc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvblwiKTtcbmNsYXNzIEJlbG9uZ3NUb0Fzc29jaWF0aW9uIGV4dGVuZHMgYmFzZV9hc3NvY2lhdGlvbl8xLkJhc2VBc3NvY2lhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldEFzc29jaWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb25fMS5Bc3NvY2lhdGlvbi5CZWxvbmdzVG87XG4gICAgfVxuICAgIGdldFNlcXVlbGl6ZU9wdGlvbnMobW9kZWwpIHtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRlZENsYXNzID0gdGhpcy5nZXRBc3NvY2lhdGVkQ2xhc3MoKTtcbiAgICAgICAgY29uc3QgZm9yZWlnbktleSA9IGZvcmVpZ25fa2V5X3NlcnZpY2VfMS5nZXRGb3JlaWduS2V5T3B0aW9ucyhhc3NvY2lhdGVkQ2xhc3MsIG1vZGVsLCB0aGlzLm9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHsgZm9yZWlnbktleSB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJlbG9uZ3NUb0Fzc29jaWF0aW9uID0gQmVsb25nc1RvQXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLWFzc29jaWF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWxvbmdzVG8gPSB2b2lkIDA7XG5jb25zdCBiZWxvbmdzX3RvX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVsb25nc1RvKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9uc09yRm9yZWlnbktleSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFzc29jaWF0aW9uX3NlcnZpY2VfMS5nZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyhvcHRpb25zT3JGb3JlaWduS2V5KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFzKVxuICAgICAgICAgICAgb3B0aW9ucy5hcyA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgYXNzb2NpYXRpb25fc2VydmljZV8xLmFkZEFzc29jaWF0aW9uKHRhcmdldCwgbmV3IGJlbG9uZ3NfdG9fYXNzb2NpYXRpb25fMS5CZWxvbmdzVG9Bc3NvY2lhdGlvbihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5CZWxvbmdzVG8gPSBCZWxvbmdzVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGb3JlaWduS2V5cyA9IGV4cG9ydHMuYWRkRm9yZWlnbktleSA9IGV4cG9ydHMuZ2V0Rm9yZWlnbktleU9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBGT1JFSUdOX0tFWVNfS0VZID0gJ3NlcXVlbGl6ZTpmb3JlaWduS2V5cyc7XG5mdW5jdGlvbiBnZXRGb3JlaWduS2V5T3B0aW9ucyhyZWxhdGVkQ2xhc3MsIGNsYXNzV2l0aEZvcmVpZ25LZXksIGZvcmVpZ25LZXkpIHtcbiAgICBsZXQgZm9yZWlnbktleU9wdGlvbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGZvcmVpZ25LZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvcmVpZ25LZXlPcHRpb25zLm5hbWUgPSBmb3JlaWduS2V5O1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JlaWduS2V5ICYmIHR5cGVvZiBmb3JlaWduS2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JlaWduS2V5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGZvcmVpZ25LZXkpO1xuICAgIH1cbiAgICBpZiAoIWZvcmVpZ25LZXlPcHRpb25zLm5hbWUgJiYgY2xhc3NXaXRoRm9yZWlnbktleSkge1xuICAgICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGdldEZvcmVpZ25LZXlzKGNsYXNzV2l0aEZvcmVpZ25LZXkucHJvdG90eXBlKSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZm9yZWlnbktleXMpIHtcbiAgICAgICAgICAgIGlmIChrZXkucmVsYXRlZENsYXNzR2V0dGVyKCkgPT09IHJlbGF0ZWRDbGFzcyB8fFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBrZXkucmVsYXRlZENsYXNzR2V0dGVyKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JlaWduS2V5T3B0aW9ucy5uYW1lID0ga2V5LmZvcmVpZ25LZXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3JlaWduS2V5T3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yZWlnbiBrZXkgZm9yIFwiJHtyZWxhdGVkQ2xhc3MubmFtZX1cIiBpcyBtaXNzaW5nIGAgK1xuICAgICAgICAgICAgYG9uIFwiJHtjbGFzc1dpdGhGb3JlaWduS2V5Lm5hbWV9XCIuYCk7XG4gICAgfVxuICAgIHJldHVybiBmb3JlaWduS2V5T3B0aW9ucztcbn1cbmV4cG9ydHMuZ2V0Rm9yZWlnbktleU9wdGlvbnMgPSBnZXRGb3JlaWduS2V5T3B0aW9ucztcbi8qKlxuICogQWRkcyBmb3JlaWduIGtleSBtZXRhIGRhdGEgZm9yIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBhZGRGb3JlaWduS2V5KHRhcmdldCwgcmVsYXRlZENsYXNzR2V0dGVyLCBmb3JlaWduS2V5KSB7XG4gICAgbGV0IGZvcmVpZ25LZXlzID0gZ2V0Rm9yZWlnbktleXModGFyZ2V0KTtcbiAgICBpZiAoIWZvcmVpZ25LZXlzKSB7XG4gICAgICAgIGZvcmVpZ25LZXlzID0gW107XG4gICAgfVxuICAgIGZvcmVpZ25LZXlzLnB1c2goe1xuICAgICAgICByZWxhdGVkQ2xhc3NHZXR0ZXIsXG4gICAgICAgIGZvcmVpZ25LZXksXG4gICAgfSk7XG4gICAgc2V0Rm9yZWlnbktleXModGFyZ2V0LCBmb3JlaWduS2V5cyk7XG59XG5leHBvcnRzLmFkZEZvcmVpZ25LZXkgPSBhZGRGb3JlaWduS2V5O1xuLyoqXG4gKiBSZXR1cm5zIGZvcmVpZ24ga2V5IG1ldGEgZGF0YSBmcm9tIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRGb3JlaWduS2V5cyh0YXJnZXQpIHtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoRk9SRUlHTl9LRVlTX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAoZm9yZWlnbktleXMpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5mb3JlaWduS2V5c107XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGb3JlaWduS2V5cyA9IGdldEZvcmVpZ25LZXlzO1xuLyoqXG4gKiBTZXRzIGZvcmVpZ24ga2V5IG1ldGEgZGF0YVxuICovXG5mdW5jdGlvbiBzZXRGb3JlaWduS2V5cyh0YXJnZXQsIGZvcmVpZ25LZXlzKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShGT1JFSUdOX0tFWVNfS0VZLCBmb3JlaWduS2V5cywgdGFyZ2V0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcmVpZ24ta2V5LXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvcmVpZ25LZXkgPSB2b2lkIDA7XG5jb25zdCBmb3JlaWduX2tleV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9mb3JlaWduLWtleS1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gRm9yZWlnbktleShyZWxhdGVkQ2xhc3NHZXR0ZXIpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGZvcmVpZ25fa2V5X3NlcnZpY2VfMS5hZGRGb3JlaWduS2V5KHRhcmdldCwgcmVsYXRlZENsYXNzR2V0dGVyLCBwcm9wZXJ0eU5hbWUpO1xuICAgIH07XG59XG5leHBvcnRzLkZvcmVpZ25LZXkgPSBGb3JlaWduS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yZWlnbi1rZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc0Fzc29jaWF0aW9uID0gdm9pZCAwO1xuY29uc3QgYmFzZV9hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9iYXNlLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgZm9yZWlnbl9rZXlfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LXNlcnZpY2VcIik7XG5jbGFzcyBIYXNBc3NvY2lhdGlvbiBleHRlbmRzIGJhc2VfYXNzb2NpYXRpb25fMS5CYXNlQXNzb2NpYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucywgYXNzb2NpYXRpb24pIHtcbiAgICAgICAgc3VwZXIoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbiA9IGFzc29jaWF0aW9uO1xuICAgIH1cbiAgICBnZXRBc3NvY2lhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzb2NpYXRpb247XG4gICAgfVxuICAgIGdldFNlcXVlbGl6ZU9wdGlvbnMobW9kZWwpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0ZWRDbGFzcyA9IHRoaXMuZ2V0QXNzb2NpYXRlZENsYXNzKCk7XG4gICAgICAgIG9wdGlvbnMuZm9yZWlnbktleSA9IGZvcmVpZ25fa2V5X3NlcnZpY2VfMS5nZXRGb3JlaWduS2V5T3B0aW9ucyhtb2RlbCwgYXNzb2NpYXRlZENsYXNzLCBvcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkhhc0Fzc29jaWF0aW9uID0gSGFzQXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtYXNzb2NpYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc01hbnkgPSB2b2lkIDA7XG5jb25zdCBoYXNfYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuL2hhcy1hc3NvY2lhdGlvblwiKTtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbmNvbnN0IGFzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uXCIpO1xuZnVuY3Rpb24gSGFzTWFueShhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnNPckZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMob3B0aW9uc09yRm9yZWlnbktleSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcylcbiAgICAgICAgICAgIG9wdGlvbnMuYXMgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIGFzc29jaWF0aW9uX3NlcnZpY2VfMS5hZGRBc3NvY2lhdGlvbih0YXJnZXQsIG5ldyBoYXNfYXNzb2NpYXRpb25fMS5IYXNBc3NvY2lhdGlvbihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMsIGFzc29jaWF0aW9uXzEuQXNzb2NpYXRpb24uSGFzTWFueSkpO1xuICAgIH07XG59XG5leHBvcnRzLkhhc01hbnkgPSBIYXNNYW55O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLW1hbnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc09uZSA9IHZvaWQgMDtcbmNvbnN0IGhhc19hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4vaGFzLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb25cIik7XG5mdW5jdGlvbiBIYXNPbmUoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zT3JGb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXNzb2NpYXRpb25fc2VydmljZV8xLmdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zKG9wdGlvbnNPckZvcmVpZ25LZXkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXMpXG4gICAgICAgICAgICBvcHRpb25zLmFzID0gcHJvcGVydHlOYW1lO1xuICAgICAgICBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuYWRkQXNzb2NpYXRpb24odGFyZ2V0LCBuZXcgaGFzX2Fzc29jaWF0aW9uXzEuSGFzQXNzb2NpYXRpb24oYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zLCBhc3NvY2lhdGlvbl8xLkFzc29jaWF0aW9uLkhhc09uZSkpO1xuICAgIH07XG59XG5leHBvcnRzLkhhc09uZSA9IEhhc09uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1vbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFzc29jaWF0aW9uc0J5UmVsYXRpb24gPSBleHBvcnRzLnNldEFzc29jaWF0aW9ucyA9IGV4cG9ydHMuZ2V0QXNzb2NpYXRpb25zID0gZXhwb3J0cy5hZGRBc3NvY2lhdGlvbiA9IGV4cG9ydHMuZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMgPSB2b2lkIDA7XG5yZXF1aXJlKFwicmVmbGVjdC1tZXRhZGF0YVwiKTtcbmNvbnN0IEFTU09DSUFUSU9OU19LRVkgPSAnc2VxdWVsaXplOmFzc29jaWF0aW9ucyc7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcbmZ1bmN0aW9uIGdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zKG9wdGlvbnNPckZvcmVpZ25LZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zT3JGb3JlaWduS2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yRm9yZWlnbktleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9yZWlnbktleSA9IG9wdGlvbnNPckZvcmVpZ25LZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uc09yRm9yZWlnbktleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLmdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zID0gZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnM7XG4vKipcbiAqIFN0b3JlcyBhc3NvY2lhdGlvbiBtZXRhIGRhdGEgZm9yIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBhZGRBc3NvY2lhdGlvbih0YXJnZXQsIGFzc29jaWF0aW9uKSB7XG4gICAgbGV0IGFzc29jaWF0aW9ucyA9IGdldEFzc29jaWF0aW9ucyh0YXJnZXQpO1xuICAgIGlmICghYXNzb2NpYXRpb25zKSB7XG4gICAgICAgIGFzc29jaWF0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBhc3NvY2lhdGlvbnMucHVzaChhc3NvY2lhdGlvbik7XG4gICAgc2V0QXNzb2NpYXRpb25zKHRhcmdldCwgYXNzb2NpYXRpb25zKTtcbn1cbmV4cG9ydHMuYWRkQXNzb2NpYXRpb24gPSBhZGRBc3NvY2lhdGlvbjtcbi8qKlxuICogUmV0dXJucyBhc3NvY2lhdGlvbiBtZXRhIGRhdGEgZnJvbSBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gZ2V0QXNzb2NpYXRpb25zKHRhcmdldCkge1xuICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoQVNTT0NJQVRJT05TX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAoYXNzb2NpYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBbLi4uYXNzb2NpYXRpb25zXTtcbiAgICB9XG59XG5leHBvcnRzLmdldEFzc29jaWF0aW9ucyA9IGdldEFzc29jaWF0aW9ucztcbmZ1bmN0aW9uIHNldEFzc29jaWF0aW9ucyh0YXJnZXQsIGFzc29jaWF0aW9ucykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoQVNTT0NJQVRJT05TX0tFWSwgYXNzb2NpYXRpb25zLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRBc3NvY2lhdGlvbnMgPSBzZXRBc3NvY2lhdGlvbnM7XG5mdW5jdGlvbiBnZXRBc3NvY2lhdGlvbnNCeVJlbGF0aW9uKHRhcmdldCwgcmVsYXRlZENsYXNzKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb25zID0gZ2V0QXNzb2NpYXRpb25zKHRhcmdldCk7XG4gICAgcmV0dXJuIChhc3NvY2lhdGlvbnMgfHwgW10pLmZpbHRlcihhc3NvY2lhdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IF9yZWxhdGVkQ2xhc3MgPSBhc3NvY2lhdGlvbi5nZXRBc3NvY2lhdGVkQ2xhc3MoKTtcbiAgICAgICAgcmV0dXJuIChfcmVsYXRlZENsYXNzLnByb3RvdHlwZSA9PT0gcmVsYXRlZENsYXNzLnByb3RvdHlwZSB8fFxuICAgICAgICAgICAgcmVsYXRlZENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIF9yZWxhdGVkQ2xhc3MpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRBc3NvY2lhdGlvbnNCeVJlbGF0aW9uID0gZ2V0QXNzb2NpYXRpb25zQnlSZWxhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzc29jaWF0aW9uID0gdm9pZCAwO1xudmFyIEFzc29jaWF0aW9uO1xuKGZ1bmN0aW9uIChBc3NvY2lhdGlvbikge1xuICAgIEFzc29jaWF0aW9uW1wiQmVsb25nc1RvTWFueVwiXSA9IFwiYmVsb25nc1RvTWFueVwiO1xuICAgIEFzc29jaWF0aW9uW1wiQmVsb25nc1RvXCJdID0gXCJiZWxvbmdzVG9cIjtcbiAgICBBc3NvY2lhdGlvbltcIkhhc01hbnlcIl0gPSBcImhhc01hbnlcIjtcbiAgICBBc3NvY2lhdGlvbltcIkhhc09uZVwiXSA9IFwiaGFzT25lXCI7XG59KShBc3NvY2lhdGlvbiA9IGV4cG9ydHMuQXNzb2NpYXRpb24gfHwgKGV4cG9ydHMuQXNzb2NpYXRpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VBc3NvY2lhdGlvbiA9IHZvaWQgMDtcbmNsYXNzIEJhc2VBc3NvY2lhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRlZENsYXNzR2V0dGVyID0gYXNzb2NpYXRlZENsYXNzR2V0dGVyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRBc3NvY2lhdGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc29jaWF0ZWRDbGFzc0dldHRlcigpO1xuICAgIH1cbiAgICBnZXRBcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcztcbiAgICB9XG59XG5leHBvcnRzLkJhc2VBc3NvY2lhdGlvbiA9IEJhc2VBc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtYXNzb2NpYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlvbi1hc3NvY2lhdGlvbi1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3VnaC1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckJ1bGtDcmVhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckJ1bGtDcmVhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJCdWxrQ3JlYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQnVsa0NyZWF0ZSA9IEFmdGVyQnVsa0NyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWJ1bGstY3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckJ1bGtEZXN0cm95ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJCdWxrRGVzdHJveSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckJ1bGtEZXN0cm95JywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQnVsa0Rlc3Ryb3kgPSBBZnRlckJ1bGtEZXN0cm95O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItYnVsay1kZXN0cm95LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckJ1bGtSZXN0b3JlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJCdWxrUmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckJ1bGtSZXN0b3JlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQnVsa1Jlc3RvcmUgPSBBZnRlckJ1bGtSZXN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItYnVsay1yZXN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckJ1bGtTeW5jID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJCdWxrU3luYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckJ1bGtTeW5jJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQnVsa1N5bmMgPSBBZnRlckJ1bGtTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItYnVsay1zeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckJ1bGtVcGRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckJ1bGtVcGRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJCdWxrVXBkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQnVsa1VwZGF0ZSA9IEFmdGVyQnVsa1VwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWJ1bGstdXBkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVCdWxrQ3JlYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQnVsa0NyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVCdWxrQ3JlYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUJ1bGtDcmVhdGUgPSBCZWZvcmVCdWxrQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWJ1bGstY3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVCdWxrRGVzdHJveSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUJ1bGtEZXN0cm95KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUJ1bGtEZXN0cm95JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUJ1bGtEZXN0cm95ID0gQmVmb3JlQnVsa0Rlc3Ryb3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtYnVsay1kZXN0cm95LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVCdWxrUmVzdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUJ1bGtSZXN0b3JlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUJ1bGtSZXN0b3JlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUJ1bGtSZXN0b3JlID0gQmVmb3JlQnVsa1Jlc3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtYnVsay1yZXN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVCdWxrU3luYyA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUJ1bGtTeW5jKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUJ1bGtTeW5jJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUJ1bGtTeW5jID0gQmVmb3JlQnVsa1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtYnVsay1zeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVCdWxrVXBkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQnVsa1VwZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVCdWxrVXBkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUJ1bGtVcGRhdGUgPSBCZWZvcmVCdWxrVXBkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWJ1bGstdXBkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9vay1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRIb29rcyA9IGV4cG9ydHMuZ2V0SG9va3MgPSBleHBvcnRzLmFkZEhvb2sgPSBleHBvcnRzLmltcGxlbWVudEhvb2tEZWNvcmF0b3IgPSBleHBvcnRzLmluc3RhbGxIb29rcyA9IHZvaWQgMDtcbnJlcXVpcmUoXCJyZWZsZWN0LW1ldGFkYXRhXCIpO1xuY29uc3QgSE9PS1NfS0VZID0gJ3NlcXVlbGl6ZTpob29rcyc7XG4vKipcbiAqIEluc3RhbGxzIGhvb2tzIG9uIHRoZSBzcGVjaWZpZWQgbW9kZWxzXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxIb29rcyhtb2RlbHMpIHtcbiAgICBtb2RlbHMuZm9yRWFjaChtb2RlbCA9PiB7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gZ2V0SG9va3MobW9kZWwpO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgIGhvb2tzLmZvckVhY2goaG9vayA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdGFsbEhvb2sobW9kZWwsIGhvb2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuaW5zdGFsbEhvb2tzID0gaW5zdGFsbEhvb2tzO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBmb3IgaG9vayBkZWNvcmF0b3IgZnVuY3Rpb25zLiBUaGVzZSBhcmUgcG9seW1vcnBoaWMuIFdoZW5cbiAqIGNhbGxlZCB3aXRoIGEgc2luZ2xlIGFyZ3VtZW50IChJSG9va09wdGlvbnMpIHRoZXkgcmV0dXJuIGEgZGVjb3JhdG9yXG4gKiBmYWN0b3J5IGZ1bmN0aW9uLiBXaGVuIGNhbGxlZCB3aXRoIG11bHRpcGxlIGFyZ3VtZW50cywgdGhleSBhZGQgdGhlIGhvb2tcbiAqIHRvIHRoZSBtb2RlbOKAmXMgbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudEhvb2tEZWNvcmF0b3IoaG9va1R5cGUsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGFkZEhvb2sodGFyZ2V0LCBob29rVHlwZSwgcHJvcGVydHlOYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGFyZ3NbMV07XG4gICAgICAgIGFkZEhvb2sodGFyZ2V0LCBob29rVHlwZSwgcHJvcGVydHlOYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLmltcGxlbWVudEhvb2tEZWNvcmF0b3IgPSBpbXBsZW1lbnRIb29rRGVjb3JhdG9yO1xuLyoqXG4gKiBBZGRzIGhvb2sgbWV0YSBkYXRhIGZvciBzcGVjaWZpZWQgbW9kZWxcbiAqIEB0aHJvd3MgaWYgYXBwbGllZCB0byBhIG5vbi1zdGF0aWMgbWV0aG9kXG4gKiBAdGhyb3dzIGlmIHRoZSBob29rIG1ldGhvZCBuYW1lIGlzIHJlc2VydmVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhvb2sodGFyZ2V0LCBob29rVHlwZSwgbWV0aG9kTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb29rIG1ldGhvZCAnJHttZXRob2ROYW1lfScgaXMgbm90IGEgc3RhdGljIG1ldGhvZC4gYCArXG4gICAgICAgICAgICBgT25seSBzdGF0aWMgbWV0aG9kcyBjYW4gYmUgdXNlZCBmb3IgaG9va3NgKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBob29rIG5hbWUgZG9lc27igJl0IGNvbmZsaWN0IHdpdGggU2VxdWVsaXpl4oCZcyBleGlzdGluZyBtZXRob2RzXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09IGhvb2tUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9vayBtZXRob2QgY2Fubm90IGJlIG5hbWVkICcke21ldGhvZE5hbWV9Jy4gVGhhdCBuYW1lIGlzIGAgK1xuICAgICAgICAgICAgYHJlc2VydmVkIGJ5IFNlcXVlbGl6ZWApO1xuICAgIH1cbiAgICBjb25zdCBob29rcyA9IGdldEhvb2tzKHRhcmdldCkgfHwgW107XG4gICAgaG9va3MucHVzaCh7XG4gICAgICAgIGhvb2tUeXBlLFxuICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgc2V0SG9va3ModGFyZ2V0LCBob29rcyk7XG59XG5leHBvcnRzLmFkZEhvb2sgPSBhZGRIb29rO1xuLyoqXG4gKiBJbnN0YWxsIGEgaG9va1xuICovXG5mdW5jdGlvbiBpbnN0YWxsSG9vayhtb2RlbCwgaG9vaykge1xuICAgIGlmIChob29rLm9wdGlvbnMgJiYgaG9vay5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgbW9kZWwuYWRkSG9vayhob29rLmhvb2tUeXBlLCBob29rLm9wdGlvbnMubmFtZSwgbW9kZWxbaG9vay5tZXRob2ROYW1lXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwuYWRkSG9vayhob29rLmhvb2tUeXBlLCBtb2RlbFtob29rLm1ldGhvZE5hbWVdKTtcbn1cbi8qKlxuICogUmV0dXJucyBob29rcyBtZXRhIGRhdGEgZnJvbSBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va3ModGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSBSZWZsZWN0LmdldE1ldGFkYXRhKEhPT0tTX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5ob29rc107XG4gICAgfVxufVxuZXhwb3J0cy5nZXRIb29rcyA9IGdldEhvb2tzO1xuLyoqXG4gKiBTYXZlcyBob29rcyBtZXRhIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgY2xhc3NcbiAqL1xuZnVuY3Rpb24gc2V0SG9va3ModGFyZ2V0LCBob29rcykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoSE9PS1NfS0VZLCBob29rcywgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0SG9va3MgPSBzZXRIb29rcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRpb25GYWlsZWQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gVmFsaWRhdGlvbkZhaWxlZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCd2YWxpZGF0aW9uRmFpbGVkJywgYXJncyk7XG59XG5leHBvcnRzLlZhbGlkYXRpb25GYWlsZWQgPSBWYWxpZGF0aW9uRmFpbGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi1mYWlsZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQ29ubmVjdCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQ29ubmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckNvbm5lY3QnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJDb25uZWN0ID0gQWZ0ZXJDb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItY29ubmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJDcmVhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckNyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckNyZWF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckNyZWF0ZSA9IEFmdGVyQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItY3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckRlZmluZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyRGVmaW5lKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyRGVmaW5lJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyRGVmaW5lID0gQWZ0ZXJEZWZpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1kZWZpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyRGVzdHJveSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyRGVzdHJveSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckRlc3Ryb3knLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJEZXN0cm95ID0gQWZ0ZXJEZXN0cm95O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItZGVzdHJveS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJGaW5kID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJGaW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyRmluZCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckZpbmQgPSBBZnRlckZpbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1maW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckluaXQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckluaXQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJJbml0JywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVySW5pdCA9IEFmdGVySW5pdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWluaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyUmVzdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyUmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclJlc3RvcmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJSZXN0b3JlID0gQWZ0ZXJSZXN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItcmVzdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJTYXZlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJTYXZlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyU2F2ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclNhdmUgPSBBZnRlclNhdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1zYXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclN5bmMgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclN5bmMoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJTeW5jJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyU3luYyA9IEFmdGVyU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyVXBkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJVcGRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJVcGRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJVcGRhdGUgPSBBZnRlclVwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXVwZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJVcHNlcnQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclVwc2VydCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclVwc2VydCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclVwc2VydCA9IEFmdGVyVXBzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItdXBzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJWYWxpZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclZhbGlkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyVmFsaWRhdGUgPSBBZnRlclZhbGlkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItdmFsaWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUNvbm5lY3QgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVDb25uZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUNvbm5lY3QnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQ29ubmVjdCA9IEJlZm9yZUNvbm5lY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtY29ubmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQ291bnQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVDb3VudCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVDb3VudCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVDb3VudCA9IEJlZm9yZUNvdW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWNvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVDcmVhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVDcmVhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQ3JlYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUNyZWF0ZSA9IEJlZm9yZUNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1jcmVhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZURlZmluZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZURlZmluZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVEZWZpbmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlRGVmaW5lID0gQmVmb3JlRGVmaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWRlZmluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlRGVzdHJveSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZURlc3Ryb3koLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlRGVzdHJveScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVEZXN0cm95ID0gQmVmb3JlRGVzdHJveTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1kZXN0cm95LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGwgPSBCZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWZpbmQtYWZ0ZXItZXhwYW5kLWluY2x1ZGUtYWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVGaW5kQWZ0ZXJPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlRmluZEFmdGVyT3B0aW9ucyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUZpbmRBZnRlck9wdGlvbnMgPSBCZWZvcmVGaW5kQWZ0ZXJPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWZpbmQtYWZ0ZXItb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlRmluZCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUZpbmQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlRmluZCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVGaW5kID0gQmVmb3JlRmluZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1maW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVJbml0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlSW5pdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVJbml0JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUluaXQgPSBCZWZvcmVJbml0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWluaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVJlc3RvcmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVSZXN0b3JlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVJlc3RvcmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlUmVzdG9yZSA9IEJlZm9yZVJlc3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtcmVzdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlU2F2ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVNhdmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlU2F2ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVTYXZlID0gQmVmb3JlU2F2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1zYXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVTeW5jID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlU3luYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVTeW5jJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVN5bmMgPSBCZWZvcmVTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVVwZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVVwZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVVcGRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlVXBkYXRlID0gQmVmb3JlVXBkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXVwZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlVXBzZXJ0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlVXBzZXJ0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVVwc2VydCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVVcHNlcnQgPSBCZWZvcmVVcHNlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtdXBzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVZhbGlkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVZhbGlkYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVZhbGlkYXRlID0gQmVmb3JlVmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtdmFsaWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by9iZWxvbmdzLXRvXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by9iZWxvbmdzLXRvLWFzc29jaWF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnkvYmVsb25ncy10by1tYW55LW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9mb3JlaWduLWtleS9mb3JlaWduLWtleVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy9oYXMtYXNzb2NpYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMvaGFzLW9uZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy9oYXMtbWFueVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL3NoYXJlZC9iYXNlLWFzc29jaWF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9tb2RlbC9hc3NvY2lhdGlvbi9hc3NvY2lhdGlvbi1hY3Rpb24tb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL3NoYXJlZC91bmlvbi1hc3NvY2lhdGlvbi1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy90aHJvdWdoL3Rocm91Z2gtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLWNyZWF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLWRlc3Ryb3lcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1yZXN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstc3luY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXVwZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstY3JlYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1kZXN0cm95XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1yZXN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1zeW5jXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay11cGRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1jb25uZWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItY3JlYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItZGVmaW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItZGVzdHJveVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWZpbmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1pbml0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItcmVzdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXNhdmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1zeW5jXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdXBkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdXBzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdmFsaWRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNvbm5lY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNvdW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1jcmVhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWRlZmluZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVzdHJveVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC1hZnRlci1leHBhbmQtaW5jbHVkZS1hbGxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmQtYWZ0ZXItb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtaW5pdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtcmVzdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtc2F2ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtc3luY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtdXBkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cHNlcnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXZhbGlkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaGFyZWQvaG9vay1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaGFyZWQvaG9va3Mtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2hhcmVkL3ZhbGlkYXRpb24tZmFpbGVkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvYWxsb3ctbnVsbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2NvbW1lbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9kZWZhdWx0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvdW5pcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvYXV0by1pbmNyZW1lbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9wcmltYXJ5LWtleS9wcmltYXJ5LWtleVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvY3JlYXRlZC1hdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvZGVsZXRlZC1hdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvdXBkYXRlZC1hdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vY29sdW1uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9tb2RlbC9hc3NvY2lhdGlvbi9hc3NvY2lhdGlvbi1jb3VudC1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9tb2RlbC9hc3NvY2lhdGlvbi9hc3NvY2lhdGlvbi1nZXQtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvbW9kZWwvbW9kZWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL3NoYXJlZC9tb2RlbC1jbGFzcy1nZXR0ZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC90YWJsZS90YWJsZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvdGFibGUvdGFibGUtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvaW5kZXgvY3JlYXRlLWluZGV4LWRlY29yYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvaW5kZXgvaW5kZXgtZGVjb3JhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9pbmRleC9pbmRleC1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY29wZXMvZGVmYXVsdC1zY29wZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NvcGVzL3Njb3BlLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Njb3Blcy9zY29wZS1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY29wZXMvc2NvcGUtdGFibGUtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NvcGVzL3Njb3Blc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS92YWxpZGF0aW9uLW9ubHkvZGItZGlhbGVjdC1kdW1teVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS9yZXBvc2l0b3J5L3JlcG9zaXRvcnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vY29udGFpbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vZXF1YWxzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWFmdGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWFscGhhXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWFscGhhbnVtZXJpY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1iZWZvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtY3JlZGl0LWNhcmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1kZWNpbWFsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWVtYWlsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWZsb2F0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWluXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWludFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1pcFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1pcC12NFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1hcnJheVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1pcC12NlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1sb3dlcmNhc2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtbnVsbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1udW1lcmljXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLXVwcGVyY2FzZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy11cmxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtdXVpZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9sZW5ndGhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbWF4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL21pblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9ub3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbm90LWNvbnRhaW5zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL25vdC1lbXB0eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9ub3QtaW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbm90LW51bGxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vdmFsaWRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vdmFsaWRhdG9yXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRBdHRyaWJ1dGVPcHRpb25zID0gZXhwb3J0cy5hZGRBdHRyaWJ1dGUgPSBleHBvcnRzLnNldEF0dHJpYnV0ZXMgPSBleHBvcnRzLmdldEF0dHJpYnV0ZXMgPSB2b2lkIDA7XG5jb25zdCBvYmplY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvb2JqZWN0XCIpO1xuY29uc3QgQVRUUklCVVRFU19LRVkgPSAnc2VxdWVsaXplOmF0dHJpYnV0ZXMnO1xuLyoqXG4gKiBSZXR1cm5zIG1vZGVsIGF0dHJpYnV0ZXMgZnJvbSBjbGFzcyBieSByZXN0b3JpbmcgdGhpc1xuICogaW5mb3JtYXRpb24gZnJvbSByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXModGFyZ2V0KSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoQVRUUklCVVRFU19LRVksIHRhcmdldCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdFxuICAgICAgICAgICAgLmtleXMoYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKGNvcHksIGtleSkgPT4ge1xuICAgICAgICAgICAgY29weVtrZXldID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcztcbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXModGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShBVFRSSUJVVEVTX0tFWSwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIHRhcmdldCk7XG59XG5leHBvcnRzLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuLyoqXG4gKiBBZGRzIG1vZGVsIGF0dHJpYnV0ZSBieSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZSBhbmRcbiAqIHNlcXVlbGl6ZSBhdHRyaWJ1dGUgb3B0aW9ucyBhbmQgc3RvcmVzIHRoaXMgaW5mb3JtYXRpb25cbiAqIHRocm91Z2ggcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBhZGRBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzKHRhcmdldCk7XG4gICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9XG4gICAgYXR0cmlidXRlc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHNldEF0dHJpYnV0ZXModGFyZ2V0LCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuYWRkQXR0cmlidXRlID0gYWRkQXR0cmlidXRlO1xuLyoqXG4gKiBBZGRzIGF0dHJpYnV0ZSBvcHRpb25zIGZvciBzcGVjaWZpYyBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzKHRhcmdldCk7XG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8ICFhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAQ29sdW1uIGFubm90YXRpb24gaXMgbWlzc2luZyBmb3IgXCIke3Byb3BlcnR5TmFtZX1cIiBvZiBjbGFzcyBcIiR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9XCJgICtcbiAgICAgICAgICAgIGAgb3IgYW5ub3RhdGlvbiBvcmRlciBpcyB3cm9uZy5gKTtcbiAgICB9XG4gICAgYXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdID0gb2JqZWN0XzEuZGVlcEFzc2lnbihhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0sIG9wdGlvbnMpO1xuICAgIHNldEF0dHJpYnV0ZXModGFyZ2V0LCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuYWRkQXR0cmlidXRlT3B0aW9ucyA9IGFkZEF0dHJpYnV0ZU9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGUtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxsb3dOdWxsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFsbG93TnVsbCguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGFsbG93TnVsbCA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwgeyBhbGxvd051bGwgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhcmdzWzFdO1xuICAgICAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGFsbG93TnVsbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFsbG93TnVsbCA9IEFsbG93TnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbG93LW51bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1lbnQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgY29tbWVudCB2YWx1ZSBmb3IgdGhlIGFubm90YXRlZCBmaWVsZFxuICovXG5mdW5jdGlvbiBDb21tZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLkNvbW1lbnQgPSBDb21tZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmYXVsdCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIGZvciB0aGUgYW5ub3RhdGVkIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIERlZmF1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5EZWZhdWx0ID0gRGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuaXF1ZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBVbmlxdWUoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBbb3B0aW9uc10gPSBhcmdzO1xuICAgICAgICByZXR1cm4gKF90YXJnZXQsIF9wcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgICAgIGFubm90YXRlKF90YXJnZXQsIF9wcm9wZXJ0eU5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBbdGFyZ2V0LCBwcm9wZXJ0eU5hbWVdID0gYXJncztcbiAgICBhbm5vdGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG59XG5leHBvcnRzLlVuaXF1ZSA9IFVuaXF1ZTtcbmZ1bmN0aW9uIGFubm90YXRlKHRhcmdldCwgcHJvcGVydHlOYW1lLCBvcHRpb24gPSB0cnVlKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHVuaXF1ZTogb3B0aW9uLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2x1bW4gPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5jb25zdCBkYXRhX3R5cGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLXNlcnZpY2VcIik7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBDb2x1bW4oLi4uYXJncykge1xuICAgIC8vIEluIGNhc2Ugb2Ygbm8gc3BlY2lmaWVkIG9wdGlvbnMsIHdlIGluZmVyIHRoZVxuICAgIC8vIHNlcXVlbGl6ZSBkYXRhIHR5cGUgYnkgdGhlIHR5cGUgb2YgdGhlIHByb3BlcnR5XG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gYXJnc1sxXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yID0gYXJnc1syXTtcbiAgICAgICAgYW5ub3RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5RGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgICAgIGFubm90YXRlKHRhcmdldCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eURlc2NyaXB0b3IsIGFyZ3NbMF0pO1xuICAgIH07XG59XG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbmZ1bmN0aW9uIGFubm90YXRlKHRhcmdldCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eURlc2NyaXB0b3IsIG9wdGlvbnNPckRhdGFUeXBlID0ge30pIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoZGF0YV90eXBlX3NlcnZpY2VfMS5pc0RhdGFUeXBlKG9wdGlvbnNPckRhdGFUeXBlKSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZTogb3B0aW9uc09yRGF0YVR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zT3JEYXRhVHlwZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBtb2RlbF9zZXJ2aWNlXzEuZ2V0U2VxdWVsaXplVHlwZUJ5RGVzaWduVHlwZSh0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgICAgb3B0aW9ucy5nZXQgPSBwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBvcHRpb25zLnNldCA9IHByb3BlcnR5RGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXRvSW5jcmVtZW50ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogU2V0cyBhdXRvIGluY3JlbWVudCB0cnVlIGZvciBhbm5vdGF0ZWQgZmllbGRcbiAqL1xuZnVuY3Rpb24gQXV0b0luY3JlbWVudCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG59XG5leHBvcnRzLkF1dG9JbmNyZW1lbnQgPSBBdXRvSW5jcmVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0by1pbmNyZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaW1hcnlLZXkgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBTZXRzIHByaW1hcnkga2V5IG9wdGlvbiB0cnVlIGZvciBhbm5vdGF0ZWQgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIFByaW1hcnlLZXkodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgcHJpbWFyeUtleTogdHJ1ZVxuICAgIH0pO1xufVxuZXhwb3J0cy5QcmltYXJ5S2V5ID0gUHJpbWFyeUtleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW1hcnkta2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcmVhdGVkQXQgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBDcmVhdGVkQXQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuYWRkT3B0aW9ucyh0YXJnZXQsIHtcbiAgICAgICAgY3JlYXRlZEF0OiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHRpbWVzdGFtcHM6IHRydWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuQ3JlYXRlZEF0ID0gQ3JlYXRlZEF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlZC1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVsZXRlZEF0ID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gRGVsZXRlZEF0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgbW9kZWxfc2VydmljZV8xLmFkZE9wdGlvbnModGFyZ2V0LCB7XG4gICAgICAgIGRlbGV0ZWRBdDogcHJvcGVydHlOYW1lLFxuICAgICAgICB0aW1lc3RhbXBzOiB0cnVlLFxuICAgICAgICBwYXJhbm9pZDogdHJ1ZVxuICAgIH0pO1xufVxuZXhwb3J0cy5EZWxldGVkQXQgPSBEZWxldGVkQXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxldGVkLWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcGRhdGVkQXQgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBVcGRhdGVkQXQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuYWRkT3B0aW9ucyh0YXJnZXQsIHtcbiAgICAgICAgdXBkYXRlZEF0OiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHRpbWVzdGFtcHM6IHRydWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuVXBkYXRlZEF0ID0gVXBkYXRlZEF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlZC1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5kZXhEZWNvcmF0b3IgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9pbmRleC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhEZWNvcmF0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGluZGV4SWQ7XG4gICAgcmV0dXJuICgoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgW3RhcmdldCwgcHJvcGVydHlOYW1lXSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE9wdGlvbnMgPSB7IG5hbWU6IHByb3BlcnR5TmFtZSB9O1xuICAgICAgICAgICAgaW5kZXhJZCA9IGluZGV4X3NlcnZpY2VfMS5hZGRGaWVsZFRvSW5kZXgodGFyZ2V0LCBmaWVsZE9wdGlvbnMsIG9wdGlvbnMsIGluZGV4SWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBwcm9wZXJ0eU5hbWUgfSwgYXJnc1swXSk7XG4gICAgICAgICAgICBpbmRleElkID0gaW5kZXhfc2VydmljZV8xLmFkZEZpZWxkVG9JbmRleCh0YXJnZXQsIGZpZWxkT3B0aW9ucywgb3B0aW9ucywgaW5kZXhJZCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUluZGV4RGVjb3JhdG9yID0gY3JlYXRlSW5kZXhEZWNvcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtaW5kZXgtZGVjb3JhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbm5vdGF0ZU1vZGVsV2l0aEluZGV4ID0gZXhwb3J0cy5JbmRleCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2luZGV4LXNlcnZpY2VcIik7XG5mdW5jdGlvbiBJbmRleCguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgW3RhcmdldCwgcHJvcGVydHlOYW1lXSA9IGFyZ3M7XG4gICAgICAgIGFubm90YXRlTW9kZWxXaXRoSW5kZXgodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgYW5ub3RhdGVNb2RlbFdpdGhJbmRleCh0YXJnZXQsIHByb3BlcnR5TmFtZSwgYXJnc1swXSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuSW5kZXggPSBJbmRleDtcbmZ1bmN0aW9uIGFubm90YXRlTW9kZWxXaXRoSW5kZXgodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIG9wdGlvbnNPck5hbWUgPSB7fSwgaW5kZXhJZCkge1xuICAgIGxldCBpbmRleE9wdGlvbnM7XG4gICAgbGV0IGZpZWxkT3B0aW9ucztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPck5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGV4T3B0aW9ucyA9IHsgbmFtZTogb3B0aW9uc09yTmFtZSB9O1xuICAgICAgICBmaWVsZE9wdGlvbnMgPSB7IG5hbWU6IHByb3BlcnR5TmFtZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZW5ndGgsIG9yZGVyLCBjb2xsYXRlIH0gPSBvcHRpb25zT3JOYW1lLCByZXN0ID0gX19yZXN0KG9wdGlvbnNPck5hbWUsIFtcImxlbmd0aFwiLCBcIm9yZGVyXCIsIFwiY29sbGF0ZVwiXSk7XG4gICAgICAgIGluZGV4T3B0aW9ucyA9IHJlc3Q7XG4gICAgICAgIGZpZWxkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgICAgY29sbGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4X3NlcnZpY2VfMS5hZGRGaWVsZFRvSW5kZXgodGFyZ2V0LCBmaWVsZE9wdGlvbnMsIGluZGV4T3B0aW9ucywgaW5kZXhJZCk7XG59XG5leHBvcnRzLmFubm90YXRlTW9kZWxXaXRoSW5kZXggPSBhbm5vdGF0ZU1vZGVsV2l0aEluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtZGVjb3JhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRGaWVsZFRvSW5kZXggPSBleHBvcnRzLnNldEluZGV4ZXMgPSBleHBvcnRzLmdldEluZGV4ZXMgPSB2b2lkIDA7XG5yZXF1aXJlKFwicmVmbGVjdC1tZXRhZGF0YVwiKTtcbmNvbnN0IElOREVYRVNfS0VZID0gJ3NlcXVlbGl6ZTppbmRleGVzJztcbi8qKlxuICogUmV0dXJucyBtb2RlbCBpbmRleGVzIGZyb20gY2xhc3MgYnkgcmVzdG9yaW5nIHRoaXNcbiAqIGluZm9ybWF0aW9uIGZyb20gcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBnZXRJbmRleGVzKHRhcmdldCkge1xuICAgIGNvbnN0IHsgbmFtZWQgPSB7fSwgdW5uYW1lZCA9IFtdIH0gPSBSZWZsZWN0LmdldE1ldGFkYXRhKElOREVYRVNfS0VZLCB0YXJnZXQpIHx8IHt9O1xuICAgIHJldHVybiB7IG5hbWVkOiBPYmplY3QuYXNzaWduKHt9LCBuYW1lZCksIHVubmFtZWQ6IFsuLi51bm5hbWVkXSB9O1xufVxuZXhwb3J0cy5nZXRJbmRleGVzID0gZ2V0SW5kZXhlcztcbi8qKlxuICogU2V0cyBpbmRleGVzXG4gKi9cbmZ1bmN0aW9uIHNldEluZGV4ZXModGFyZ2V0LCBpbmRleGVzKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShJTkRFWEVTX0tFWSwgaW5kZXhlcywgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0SW5kZXhlcyA9IHNldEluZGV4ZXM7XG4vKipcbiAqIEFkZHMgZmllbGQgdG8gaW5kZXggYnkgc2VxdWVsaXplIGluZGV4IGFuZCBpbmRleCBmaWVsZCBvcHRpb25zLFxuICogYW5kIHN0b3JlcyB0aGlzIGluZm9ybWF0aW9uIHRocm91Z2ggcmVmbGVjdCBtZXRhZGF0YS4gUmV0dXJucyBpbmRleCBJRC5cbiAqL1xuZnVuY3Rpb24gYWRkRmllbGRUb0luZGV4KHRhcmdldCwgZmllbGRPcHRpb25zLCBpbmRleE9wdGlvbnMsIGluZGV4SWQpIHtcbiAgICBjb25zdCBpbmRleGVzID0gZ2V0SW5kZXhlcyh0YXJnZXQpO1xuICAgIGNvbnN0IGNob3NlbklkID0gdHlwZW9mIGluZGV4SWQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gaW5kZXhJZFxuICAgICAgICA6IGluZGV4T3B0aW9ucy5uYW1lIHx8IGluZGV4ZXMudW5uYW1lZC5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXhTdG9yZSA9IHR5cGVvZiBjaG9zZW5JZCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpbmRleGVzLm5hbWVkXG4gICAgICAgIDogaW5kZXhlcy51bm5hbWVkO1xuICAgIGlmICghaW5kZXhTdG9yZVtjaG9zZW5JZF0pXG4gICAgICAgIGluZGV4U3RvcmVbY2hvc2VuSWRdID0gT2JqZWN0LmFzc2lnbih7fSwgaW5kZXhPcHRpb25zKTtcbiAgICBjb25zdCBpbmRleCA9IGluZGV4U3RvcmVbY2hvc2VuSWRdO1xuICAgIGlmICghaW5kZXguZmllbGRzKVxuICAgICAgICBpbmRleC5maWVsZHMgPSBbXTtcbiAgICBpbmRleC5maWVsZHMucHVzaChmaWVsZE9wdGlvbnMpO1xuICAgIHNldEluZGV4ZXModGFyZ2V0LCBpbmRleGVzKTtcbiAgICByZXR1cm4gY2hvc2VuSWQ7XG59XG5leHBvcnRzLmFkZEZpZWxkVG9JbmRleCA9IGFkZEZpZWxkVG9JbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LXNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi1hY3Rpb24tb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLWNvdW50LW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi1nZXQtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSU5GRVJfQUxJQVNfTUFQID0gZXhwb3J0cy5Nb2RlbCA9IHZvaWQgMDtcbmNvbnN0IHNlcXVlbGl6ZV8xID0gcmVxdWlyZShcInNlcXVlbGl6ZVwiKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9zdHJpbmdcIik7XG5jb25zdCBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9hbGlhcy1pbmZlcmVuY2UvYWxpYXMtaW5mZXJlbmNlLXNlcnZpY2VcIik7XG5jb25zdCBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbW9kZWwtbm90LWluaXRpYWxpemVkLWVycm9yXCIpO1xuY29uc3Qgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL29iamVjdFwiKTtcbmNsYXNzIE1vZGVsIGV4dGVuZHMgc2VxdWVsaXplXzEuTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW5ldy50YXJnZXQuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvcihuZXcudGFyZ2V0LCBgJHtuZXcudGFyZ2V0Lm5hbWV9IGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIodmFsdWVzLCBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMob3B0aW9ucywgbmV3LnRhcmdldCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluaXQoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgcmVsYXRpb24gYmV0d2VlbiBzcGVjaWZpZWQgaW5zdGFuY2VzIGFuZCBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkYWRkKHByb3BlcnR5S2V5LCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2FkZCcgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0oaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyByZWxhdGlvbiBiZXR3ZWVuIHNwZWNpZmllZCBpbnN0YW5jZXMgYW5kIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqIChyZXBsYWNlcyBvbGQgcmVsYXRpb25zKVxuICAgICAqL1xuICAgICRzZXQocHJvcGVydHlLZXksIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snc2V0JyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJlbGF0ZWQgaW5zdGFuY2UgKHNwZWNpZmllZCBieSBwcm9wZXJ0eUtleSkgb2Ygc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJGdldChwcm9wZXJ0eUtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snZ2V0JyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHJlbGF0ZWQgaW5zdGFuY2VzIChzcGVjaWZpZWQgYnkgcHJvcGVydHlLZXkpIG9mIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRjb3VudChwcm9wZXJ0eUtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snY291bnQnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGluc3RhbmNlcyBhbmQgcmVsYXRlIHRoZW0gdG8gc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJGNyZWF0ZShwcm9wZXJ0eUtleSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydjcmVhdGUnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgaW5zdGFuY2VzIGlzIHJlbGF0ZWQgdG8gc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJGhhcyhwcm9wZXJ0eUtleSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydoYXMnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3BlY2lmaWVkIGluc3RhbmNlcyBmcm9tIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRyZW1vdmUocHJvcGVydHlLZXksIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1sncmVtb3ZlJyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZWxvYWQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVsb2FkKGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhvcHRpb25zLCB0aGlzKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xuTW9kZWwuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuLyoqXG4gKiBJbmRpY2F0ZXMgd2hpY2ggc3RhdGljIG1ldGhvZHMgb2YgTW9kZWwgaGFzIHRvIGJlIHByb3hpZWQsXG4gKiB0byBwcmVwYXJlIGluY2x1ZGUgb3B0aW9uIHRvIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZSBhbGlhcztcbiAqIFRoZSBpbmRleCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgb3B0aW9ucyBvZiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgbWV0aG9kIHBhcmFtZXRlclxuICovXG5leHBvcnRzLklORkVSX0FMSUFTX01BUCA9IHtcbiAgICBidWxrQnVpbGQ6IDEsXG4gICAgYnVpbGQ6IDEsXG4gICAgY3JlYXRlOiAxLFxuICAgIGFnZ3JlZ2F0ZTogMixcbiAgICBhbGw6IDAsXG4gICAgZmluZDogMCxcbiAgICBmaW5kQWxsOiAwLFxuICAgIGZpbmRBbmRDb3VudDogMCxcbiAgICBmaW5kQW5kQ291bnRBbGw6IDAsXG4gICAgZmluZEJ5SWQ6IDEsXG4gICAgZmluZEJ5UHJpbWFyeTogMSxcbiAgICBmaW5kQ3JlYXRlRmluZDogMCxcbiAgICBmaW5kT25lOiAwLFxuICAgIGZpbmRPckJ1aWxkOiAwLFxuICAgIGZpbmRPckNyZWF0ZTogMCxcbiAgICBmaW5kT3JJbml0aWFsaXplOiAwLFxuICAgIHJlbG9hZDogMCxcbn07XG5jb25zdCBzdGF0aWNNb2RlbEZ1bmN0aW9uUHJvcGVydGllcyA9IG9iamVjdF8xLmdldEFsbFByb3BlcnR5TmFtZXMoc2VxdWVsaXplXzEuTW9kZWwpXG4gICAgLmZpbHRlcihrZXkgPT4gIWlzRm9yYmlkZGVuTWVtYmVyKGtleSkgJiZcbiAgICBpc0Z1bmN0aW9uTWVtYmVyKGtleSwgc2VxdWVsaXplXzEuTW9kZWwpICYmXG4gICAgIWlzUHJpdmF0ZU1lbWJlcihrZXkpKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb25NZW1iZXIocHJvcGVydHlLZXksIHRhcmdldCkge1xuICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0W3Byb3BlcnR5S2V5XSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuTWVtYmVyKHByb3BlcnR5S2V5KSB7XG4gICAgY29uc3QgRk9SQklEREVOX0tFWVMgPSBbJ25hbWUnLCAnY29uc3RydWN0b3InLCAnbGVuZ3RoJywgJ3Byb3RvdHlwZScsICdjYWxsZXInLCAnYXJndW1lbnRzJywgJ2FwcGx5JyxcbiAgICAgICAgJ3F1ZXJ5SW50ZXJmYWNlJywgJ3F1ZXJ5R2VuZXJhdG9yJywgJ2luaXQnLCAncmVwbGFjZUhvb2tBbGlhc2VzJywgJ3JlZnJlc2hBdHRyaWJ1dGVzJywgJ2luc3BlY3QnXTtcbiAgICByZXR1cm4gRk9SQklEREVOX0tFWVMuaW5kZXhPZihwcm9wZXJ0eUtleSkgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNQcml2YXRlTWVtYmVyKHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIChwcm9wZXJ0eUtleS5jaGFyQXQoMCkgPT09ICdfJyk7XG59XG5mdW5jdGlvbiBhZGRUaHJvd05vdEluaXRpYWxpemVkUHJveHkoKSB7XG4gICAgc3RhdGljTW9kZWxGdW5jdGlvblByb3BlcnRpZXNcbiAgICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3Qgc3VwZXJGbiA9IE1vZGVsW2tleV07XG4gICAgICAgIE1vZGVsW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yKHRoaXMsIGBNZW1iZXIgXCIke2tleX1cIiBjYW5ub3QgYmUgY2FsbGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyRm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEluZmVyQWxpYXNPdmVycmlkZXMoKSB7XG4gICAgT2JqZWN0XG4gICAgICAgIC5rZXlzKGV4cG9ydHMuSU5GRVJfQUxJQVNfTUFQKVxuICAgICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25JbmRleCA9IGV4cG9ydHMuSU5GRVJfQUxJQVNfTUFQW2tleV07XG4gICAgICAgIGNvbnN0IHN1cGVyRm4gPSBNb2RlbFtrZXldO1xuICAgICAgICBNb2RlbFtrZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGFyZ3Nbb3B0aW9uSW5kZXhdID0gYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKGFyZ3Nbb3B0aW9uSW5kZXhdLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBzdXBlckZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5hZGRUaHJvd05vdEluaXRpYWxpemVkUHJveHkoKTtcbmFkZEluZmVyQWxpYXNPdmVycmlkZXMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtY2xhc3MtZ2V0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBNb2RlbE5vdEluaXRpYWxpemVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobW9kZWxDbGFzcywgYWRkaXRpb25hbE1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYE1vZGVsIG5vdCBpbml0aWFsaXplZDogJHthZGRpdGlvbmFsTWVzc2FnZX0gXCIke21vZGVsQ2xhc3MubmFtZX1cIiBgICtcbiAgICAgICAgICAgIGBuZWVkcyB0byBiZSBhZGRlZCB0byBhIFNlcXVlbGl6ZSBpbnN0YW5jZS5gO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yID0gTW9kZWxOb3RJbml0aWFsaXplZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtbm90LWluaXRpYWxpemVkLWVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlTW9kZWxHZXR0ZXIgPSBleHBvcnRzLmdldFNlcXVlbGl6ZVR5cGVCeURlc2lnblR5cGUgPSBleHBvcnRzLmFkZE9wdGlvbnMgPSBleHBvcnRzLnNldE9wdGlvbnMgPSBleHBvcnRzLmdldE9wdGlvbnMgPSBleHBvcnRzLmdldE1vZGVsTmFtZSA9IGV4cG9ydHMuc2V0TW9kZWxOYW1lID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9tb2RlbFwiKTtcbmNvbnN0IGRhdGFfdHlwZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZVwiKTtcbmNvbnN0IE1PREVMX05BTUVfS0VZID0gJ3NlcXVlbGl6ZTptb2RlbE5hbWUnO1xuY29uc3QgT1BUSU9OU19LRVkgPSAnc2VxdWVsaXplOm9wdGlvbnMnO1xuLyoqXG4gKiBTZXRzIG1vZGVsIG5hbWUgZnJvbSBjbGFzcyBieSBzdG9yaW5nIHRoaXNcbiAqIGluZm9ybWF0aW9uIHRocm91Z2ggcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBzZXRNb2RlbE5hbWUodGFyZ2V0LCBtb2RlbE5hbWUpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKE1PREVMX05BTUVfS0VZLCBtb2RlbE5hbWUsIHRhcmdldCk7XG59XG5leHBvcnRzLnNldE1vZGVsTmFtZSA9IHNldE1vZGVsTmFtZTtcbi8qKlxuICogUmV0dXJucyBtb2RlbCBuYW1lIGZyb20gY2xhc3MgYnkgcmVzdG9yaW5nIHRoaXNcbiAqIGluZm9ybWF0aW9uIGZyb20gcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBnZXRNb2RlbE5hbWUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0TWV0YWRhdGEoTU9ERUxfTkFNRV9LRVksIHRhcmdldCk7XG59XG5leHBvcnRzLmdldE1vZGVsTmFtZSA9IGdldE1vZGVsTmFtZTtcbi8qKlxuICogUmV0dXJucyBzZXF1ZWxpemUgZGVmaW5lIG9wdGlvbnMgZnJvbSBjbGFzcyBwcm90b3R5cGVcbiAqIGJ5IHJlc3RvcmluZyB0aGlzIGluZm9ybWF0aW9uIGZyb20gcmVmbGVjdCBtZXRhZGF0YVxuICovXG5mdW5jdGlvbiBnZXRPcHRpb25zKHRhcmdldCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKE9QVElPTlNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmdldE9wdGlvbnMgPSBnZXRPcHRpb25zO1xuLyoqXG4gKiBTZXRzIHNldXFsaXplIGRlZmluZSBvcHRpb25zIHRvIGNsYXNzIHByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBzZXRPcHRpb25zKHRhcmdldCwgb3B0aW9ucykge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoT1BUSU9OU19LRVksIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRPcHRpb25zID0gc2V0T3B0aW9ucztcbi8qKlxuICogQWRkcyBvcHRpb25zIGJlIGFzc2lnbmluZyBuZXcgb3B0aW9ucyB0byBvbGQgb25lXG4gKi9cbmZ1bmN0aW9uIGFkZE9wdGlvbnModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IF9vcHRpb25zID0gZ2V0T3B0aW9ucyh0YXJnZXQpO1xuICAgIGlmICghX29wdGlvbnMpIHtcbiAgICAgICAgX29wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyh0YXJnZXQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfb3B0aW9ucyksIG9wdGlvbnMpLCB7IHZhbGlkYXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfb3B0aW9ucy52YWxpZGF0ZSB8fCB7fSkpLCAob3B0aW9ucy52YWxpZGF0ZSB8fCB7fSkpIH0pKTtcbn1cbmV4cG9ydHMuYWRkT3B0aW9ucyA9IGFkZE9wdGlvbnM7XG4vKipcbiAqIE1hcHMgZGVzaWduIHR5cGVzIHRvIHNlcXVlbGl6ZSBkYXRhIHR5cGVzO1xuICogQHRocm93cyBpZiBkZXNpZ24gdHlwZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBtYXBwZWQgdG9cbiAqIGEgc2VxdWVsaXplIGRhdGEgdHlwZVxuICovXG5mdW5jdGlvbiBnZXRTZXF1ZWxpemVUeXBlQnlEZXNpZ25UeXBlKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZGF0YV90eXBlX3NlcnZpY2VfMS5pbmZlckRhdGFUeXBlKHR5cGUpO1xuICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgU3BlY2lmaWVkIHR5cGUgb2YgcHJvcGVydHkgJyR7cHJvcGVydHlOYW1lfSdcbiAgICAgICAgICAgIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGEgc2VxdWVsaXplIGRhdGEgdHlwZS4gUGxlYXNlXG4gICAgICAgICAgICBkZWZpbmUgdGhlIGRhdGEgdHlwZSBtYW51YWxseWApO1xufVxuZXhwb3J0cy5nZXRTZXF1ZWxpemVUeXBlQnlEZXNpZ25UeXBlID0gZ2V0U2VxdWVsaXplVHlwZUJ5RGVzaWduVHlwZTtcbi8qKlxuICogUmVzb2x2ZXMgYWxsIG1vZGVsIGdldHRlcnMgb2Ygc3BlY2lmaWVkIG9wdGlvbnMgb2JqZWN0XG4gKiByZWN1cnNpdmVseS5cbiAqIFNvIHRoYXQge21vZGVsOiAoKSA9PiBQZXJzb259IHdpbGwgYmUgY29udmVydGVkIHRvXG4gKiB7bW9kZWw6IFBlcnNvbn1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU1vZGVsR2V0dGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXliZU1vZGVsR2V0dGVyID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBpc01vZGVsID0gdmFsdWUgPT4gdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlICYmIHZhbHVlLnByb3RvdHlwZSBpbnN0YW5jZW9mIG1vZGVsXzEuTW9kZWw7XG4gICAgY29uc3QgaXNPcHRpb25PYmplY3RPckFycmF5ID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbiAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgIC5rZXlzKG9wdGlvbnMpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICBpZiAobWF5YmVNb2RlbEdldHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlTW9kZWwgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGlzTW9kZWwobWF5YmVNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IG1heWJlTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25PYmplY3RPckFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSByZXNvbHZlTW9kZWxHZXR0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IFsuLi5vcHRpb25zXSA6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZU1vZGVsR2V0dGVyID0gcmVzb2x2ZU1vZGVsR2V0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYmxlID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gVGFibGUoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYW5ub3RhdGUoYXJnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcmcpO1xuICAgICAgICByZXR1cm4gKHRhcmdldCkgPT4gYW5ub3RhdGUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG5mdW5jdGlvbiBhbm5vdGF0ZSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIG1vZGVsX3NlcnZpY2VfMS5zZXRNb2RlbE5hbWUodGFyZ2V0LnByb3RvdHlwZSwgb3B0aW9ucy5tb2RlbE5hbWUgfHwgdGFyZ2V0Lm5hbWUpO1xuICAgIG1vZGVsX3NlcnZpY2VfMS5hZGRPcHRpb25zKHRhcmdldC5wcm90b3R5cGUsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRTY29wZSA9IHZvaWQgMDtcbmNvbnN0IHNjb3BlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3Njb3BlLXNlcnZpY2VcIik7XG4vKipcbiAqIERlY29yYXRvciBmb3IgZGVmaW5pbmcgZGVmYXVsdCBNb2RlbCBzY29wZVxuICovXG5mdW5jdGlvbiBEZWZhdWx0U2NvcGUoc2NvcGVPclNzb3BlR2V0dGVyKSB7XG4gICAgcmV0dXJuICh0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZU9yU3NvcGVHZXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNjb3BlX3NlcnZpY2VfMS5hZGRTY29wZU9wdGlvbnNHZXR0ZXIodGFyZ2V0LnByb3RvdHlwZSwgeyBnZXREZWZhdWx0U2NvcGU6IHNjb3BlT3JTc29wZUdldHRlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlX3NlcnZpY2VfMS5hZGRTY29wZU9wdGlvbnModGFyZ2V0LnByb3RvdHlwZSwgeyBkZWZhdWx0U2NvcGU6IHNjb3BlT3JTc29wZUdldHRlciB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLkRlZmF1bHRTY29wZSA9IERlZmF1bHRTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQtc2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY29wZU9wdGlvbnMgPSBleHBvcnRzLmFkZFNjb3BlT3B0aW9ucyA9IGV4cG9ydHMucmVzb2x2ZXNEZXByZWNhdGVkU2NvcGVzID0gZXhwb3J0cy5zZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gZXhwb3J0cy5nZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gZXhwb3J0cy5hZGRTY29wZU9wdGlvbnNHZXR0ZXIgPSBleHBvcnRzLnJlc29sdmVTY29wZSA9IGV4cG9ydHMucmVzb2x2ZVNjb3BlcyA9IHZvaWQgMDtcbmNvbnN0IG9iamVjdF8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9vYmplY3RcIik7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5jb25zdCBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2Fzc29jaWF0aW9ucy9hbGlhcy1pbmZlcmVuY2UvYWxpYXMtaW5mZXJlbmNlLXNlcnZpY2VcIik7XG5jb25zdCBTQ09QRVNfS0VZID0gJ3NlcXVlbGl6ZTpzY29wZXMnO1xuY29uc3QgU0NPUEVTX09QVElPTlNfS0VZID0gJ3NlcXVlbGl6ZTpzY29wZXMtb3B0aW9ucyc7XG4vKipcbiAqIFJlc29sdmVzIHNjb3BlcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWxzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTY29wZXMobW9kZWxzKSB7XG4gICAgbW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgICBleHBvcnRzLnJlc29sdmVzRGVwcmVjYXRlZFNjb3Blcyhtb2RlbCk7XG4gICAgICAgIGNvbnN0IHsgZ2V0RGVmYXVsdFNjb3BlLCBnZXRTY29wZXMgfSA9IGV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zR2V0dGVycyhtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoZ2V0RGVmYXVsdFNjb3BlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkZWZhdWx0U2NvcGU6IGdldERlZmF1bHRTY29wZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRTY29wZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCBnZXRTY29wZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IGV4cG9ydHMucmVzb2x2ZVNjb3BlKGtleSwgbW9kZWwsIG9wdGlvbnNba2V5XSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NvcGVzID0gcmVzb2x2ZVNjb3BlcztcbmNvbnN0IHJlc29sdmVTY29wZSA9IChzY29wZU5hbWUsIG1vZGVsLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGZuID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9ICguLi5hcmdzKSA9PiBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMoZm4oLi4uYXJncyksIG1vZGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMob3B0aW9ucywgbW9kZWwpO1xuICAgIH1cbiAgICBtb2RlbC5hZGRTY29wZShzY29wZU5hbWUsIG9wdGlvbnMsIHsgb3ZlcnJpZGU6IHRydWUgfSk7XG59O1xuZXhwb3J0cy5yZXNvbHZlU2NvcGUgPSByZXNvbHZlU2NvcGU7XG5jb25zdCBhZGRTY29wZU9wdGlvbnNHZXR0ZXIgPSAodGFyZ2V0LCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY3VycmVudE9wdGlvbnMgPSBleHBvcnRzLmdldFNjb3BlT3B0aW9uc0dldHRlcnModGFyZ2V0KSB8fCB7fTtcbiAgICBleHBvcnRzLnNldFNjb3BlT3B0aW9uc0dldHRlcnModGFyZ2V0LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRPcHRpb25zKSwgb3B0aW9ucykpO1xufTtcbmV4cG9ydHMuYWRkU2NvcGVPcHRpb25zR2V0dGVyID0gYWRkU2NvcGVPcHRpb25zR2V0dGVyO1xuY29uc3QgZ2V0U2NvcGVPcHRpb25zR2V0dGVycyA9ICh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gUmVmbGVjdC5nZXRNZXRhZGF0YShTQ09QRVNfT1BUSU9OU19LRVksIHRhcmdldCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuZXhwb3J0cy5nZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gZ2V0U2NvcGVPcHRpb25zR2V0dGVycztcbmNvbnN0IHNldFNjb3BlT3B0aW9uc0dldHRlcnMgPSAodGFyZ2V0LCBvcHRpb25zKSA9PiB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShTQ09QRVNfT1BUSU9OU19LRVksIG9wdGlvbnMsIHRhcmdldCk7XG59O1xuZXhwb3J0cy5zZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gc2V0U2NvcGVPcHRpb25zR2V0dGVycztcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3QgcmVzb2x2ZXNEZXByZWNhdGVkU2NvcGVzID0gKG1vZGVsKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldFNjb3BlT3B0aW9ucyhtb2RlbC5wcm90b3R5cGUpIHx8IHt9O1xuICAgIE9iamVjdFxuICAgICAgICAua2V5cyhvcHRpb25zKVxuICAgICAgICAuZm9yRWFjaChrZXkgPT4gcmVzb2x2ZURlcHJlY2F0ZWRTY29wZShrZXksIG1vZGVsLCBvcHRpb25zW2tleV0pKTtcbn07XG5leHBvcnRzLnJlc29sdmVzRGVwcmVjYXRlZFNjb3BlcyA9IHJlc29sdmVzRGVwcmVjYXRlZFNjb3Blcztcbi8qKlxuICogQWRkcyBzY29wZSBvcHRpb24gbWV0YSBkYXRhIGZvciBzcGVjaWZpZWQgcHJvdG90eXBlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBhZGRTY29wZU9wdGlvbnModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgX29wdGlvbnMgPSBnZXRTY29wZU9wdGlvbnModGFyZ2V0KSB8fCB7fTtcbiAgICBzZXRTY29wZU9wdGlvbnModGFyZ2V0LCBvYmplY3RfMS5kZWVwQXNzaWduKHt9LCBfb3B0aW9ucywgb3B0aW9ucykpO1xufVxuZXhwb3J0cy5hZGRTY29wZU9wdGlvbnMgPSBhZGRTY29wZU9wdGlvbnM7XG4vKipcbiAqIFJldHVybnMgc2NvcGUgb3B0aW9uIG1ldGEgZGF0YSBmcm9tIHNwZWNpZmllZCB0YXJnZXRcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlT3B0aW9ucyh0YXJnZXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gUmVmbGVjdC5nZXRNZXRhZGF0YShTQ09QRVNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RfMS5kZWVwQXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFNjb3BlT3B0aW9ucyA9IGdldFNjb3BlT3B0aW9ucztcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZURlcHJlY2F0ZWRTY29wZShzY29wZU5hbWUsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGZuID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9ICguLi5hcmdzKSA9PiBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMoZm4oLi4uYXJncyksIG1vZGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMobW9kZWxfc2VydmljZV8xLnJlc29sdmVNb2RlbEdldHRlcihvcHRpb25zKSwgbW9kZWwpO1xuICAgIH1cbiAgICBtb2RlbC5hZGRTY29wZShzY29wZU5hbWUsIG9wdGlvbnMsIHsgb3ZlcnJpZGU6IHRydWUgfSk7XG59XG4vKipcbiAqIFNldCBzY29wZSBvcHRpb24gbWV0YSBkYXRhIGZvciBzcGVjaWZpZWQgcHJvdG90eXBlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBzZXRTY29wZU9wdGlvbnModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShTQ09QRVNfS0VZLCBvcHRpb25zLCB0YXJnZXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLXRhYmxlLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNjb3BlcyA9IHZvaWQgMDtcbmNvbnN0IHNjb3BlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3Njb3BlLXNlcnZpY2VcIik7XG4vKipcbiAqIERlY29yYXRvciBmb3IgZGVmaW5pbmcgTW9kZWwgc2NvcGVzXG4gKi9cbmZ1bmN0aW9uIFNjb3BlcyhzY29wZXNPclNjb3Blc0dldHRlcikge1xuICAgIHJldHVybiAodGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzT3JTY29wZXNHZXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNjb3BlX3NlcnZpY2VfMS5hZGRTY29wZU9wdGlvbnNHZXR0ZXIodGFyZ2V0LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgIGdldFNjb3Blczogc2NvcGVzT3JTY29wZXNHZXR0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlX3NlcnZpY2VfMS5hZGRTY29wZU9wdGlvbnModGFyZ2V0LnByb3RvdHlwZSwgc2NvcGVzT3JTY29wZXNHZXR0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuU2NvcGVzID0gU2NvcGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmZlckRhdGFUeXBlID0gZXhwb3J0cy5pc0RhdGFUeXBlID0gdm9pZCAwO1xuY29uc3Qgc2VxdWVsaXplXzEgPSByZXF1aXJlKFwic2VxdWVsaXplXCIpO1xuLypcbiAqIENoZWNrcyBpZiBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzZXF1ZWxpemUgZGF0YSB0eXBlIChBQlNUUkFDVCwgU1RSSU5HLi4uKVxuICovXG5mdW5jdGlvbiBpc0RhdGFUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSh7fSkgaW5zdGFuY2VvZiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuQUJTVFJBQ1QpIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2Ygc2VxdWVsaXplXzEuRGF0YVR5cGVzLkFCU1RSQUNUO1xufVxuZXhwb3J0cy5pc0RhdGFUeXBlID0gaXNEYXRhVHlwZTtcbi8qKlxuICogSW5mZXJzIHNlcXVlbGl6ZSBkYXRhIHR5cGUgYnkgZGVzaWduIHR5cGVcbiAqL1xuZnVuY3Rpb24gaW5mZXJEYXRhVHlwZShkZXNpZ25UeXBlKSB7XG4gICAgc3dpdGNoIChkZXNpZ25UeXBlKSB7XG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5TVFJJTkc7XG4gICAgICAgIGNhc2UgQmlnSW50OlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5CSUdJTlQ7XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5JTlRFR0VSO1xuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLkJPT0xFQU47XG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuREFURTtcbiAgICAgICAgY2FzZSBCdWZmZXI6XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLkJMT0I7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuaW5mZXJEYXRhVHlwZSA9IGluZmVyRGF0YVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGUtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBzZXF1ZWxpemVfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemVcIik7XG5leHBvcnRzLkRhdGFUeXBlID0gc2VxdWVsaXplXzEuRGF0YVR5cGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3NpdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbGl6ZS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRNb2RlbHMgPSBleHBvcnRzLnByZXBhcmVBcmdzID0gZXhwb3J0cy5wcmVwYXJlT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZ2xvYiA9IHJlcXVpcmUoXCJnbG9iXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvYXJyYXlcIik7XG4vKipcbiAqIFByZXBhcmVzIHNlcXVlbGl6ZSBjb25maWcgcGFzc2VkIHRvIG9yaWdpbmFsIHNlcXVlbGl6ZSBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGVPbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXRWYWxpZGF0aW9uT25seU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucHJlcGFyZU9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucztcbmZ1bmN0aW9uIHByZXBhcmVBcmdzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBsYXN0QXJnICYmIHR5cGVvZiBsYXN0QXJnID09PSAnb2JqZWN0J1xuICAgICAgICA/IHByZXBhcmVPcHRpb25zKGxhc3RBcmcpIDogdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7IHByZXBhcmVkQXJnczogYXJncywgb3B0aW9ucyB9O1xufVxuZXhwb3J0cy5wcmVwYXJlQXJncyA9IHByZXBhcmVBcmdzO1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbk9ubHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkaWFsZWN0OiAnc3FsaXRlJywgZGlhbGVjdE1vZHVsZVBhdGg6IF9fZGlybmFtZSArICcvLi4vdmFsaWRhdGlvbi1vbmx5L2RiLWRpYWxlY3QtZHVtbXknIH0pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIG1vZGVscyBmcm9tIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVscyhhcmcsIG1vZGVsTWF0Y2gpIHtcbiAgICBjb25zdCBoYXNTdXBwb3J0ZWRFeHRlbnNpb24gPSBwYXRoID0+IFsnLnRzJywgJy5qcyddLmluZGV4T2YocGF0aF8xLmV4dG5hbWUocGF0aCkpICE9PSAtMTtcbiAgICBpZiAoYXJnICYmIHR5cGVvZiBhcmdbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhcmcucmVkdWNlKChtb2RlbHMsIGRpcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFnbG9iLmhhc01hZ2ljKGRpcikgJiYgIWhhc1N1cHBvcnRlZEV4dGVuc2lvbihkaXIpKVxuICAgICAgICAgICAgICAgIGRpciA9IHBhdGhfMS5qb2luKGRpciwgJy8qJyk7XG4gICAgICAgICAgICBjb25zdCBfbW9kZWxzID0gZ2xvYlxuICAgICAgICAgICAgICAgIC5zeW5jKGRpcilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGlzSW1wb3J0YWJsZSlcbiAgICAgICAgICAgICAgICAubWFwKGdldEZ1bGxmaWxlcGF0aFdpdGhvdXRFeHRlbnNpb24pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihhcnJheV8xLnVuaXF1ZUZpbHRlcilcbiAgICAgICAgICAgICAgICAubWFwKGZ1bGxQYXRoID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSByZXF1aXJlKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGhfMS5iYXNlbmFtZShmdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZE1lbWJlcktleSA9IE9iamVjdC5rZXlzKG1vZHVsZSkuZmluZChtID0+IG1vZGVsTWF0Y2goZmlsZU5hbWUsIG0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkTWVtYmVyID0gbWF0Y2hlZE1lbWJlcktleSA/IG1vZHVsZVttYXRjaGVkTWVtYmVyS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRNZW1iZXIgJiYgIW1vZHVsZS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVmYXVsdCBleHBvcnQgZGVmaW5lZCBmb3IgZmlsZSBcIiR7ZmlsZU5hbWV9XCIgb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZXhwb3J0IGRvZXMgbm90IHNhdGlzZnkgZmlsZW5hbWUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkTWVtYmVyIHx8IG1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2RlbHMucHVzaCguLi5fbW9kZWxzKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbn1cbmV4cG9ydHMuZ2V0TW9kZWxzID0gZ2V0TW9kZWxzO1xuLyoqXG4gKiBDaGVja3MgaWYgc3BlY2lmaWVkIGZpbGVuYW1lIGlzIGltcG9ydGFibGUgb3Igbm90O1xuICogV2hpY2ggbWVhbnMgdGhhdCwgaXQgbmVlZHMgdG8gaGF2ZSBhIHNwZWNpZmljIGZpbGUgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIGlzSW1wb3J0YWJsZShmaWxlKSB7XG4gICAgY29uc3QgZmlsZVBhcnQgPSBmaWxlLnNsaWNlKC0zKTtcbiAgICByZXR1cm4gZmlsZVBhcnQgPT09ICcuanMnIHx8IChmaWxlUGFydCA9PT0gJy50cycgJiYgZmlsZS5zbGljZSgtNSkgIT09ICcuZC50cycpO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmdWxsIHBhdGggd2l0aCBmaWxlbmFtZSwgd2l0aG91dCBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RnVsbGZpbGVwYXRoV2l0aG91dEV4dGVuc2lvbihmaWxlKSB7XG4gICAgY29uc3QgcGFyc2VkRmlsZSA9IHBhdGhfMS5wYXJzZShmaWxlKTtcbiAgICByZXR1cm4gcGF0aF8xLmpvaW4ocGFyc2VkRmlsZS5kaXIsIHBhcnNlZEZpbGUubmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZWxpemUtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VxdWVsaXplID0gdm9pZCAwO1xuY29uc3Qgc2VxdWVsaXplXzEgPSByZXF1aXJlKFwic2VxdWVsaXplXCIpO1xuY29uc3QgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvclwiKTtcbmNvbnN0IHNlcXVlbGl6ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXF1ZWxpemUtc2VydmljZVwiKTtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmNvbnN0IHNjb3BlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY29wZXMvc2NvcGUtc2VydmljZVwiKTtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9ob29rcy9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmNvbnN0IGluZGV4X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9pbmRleC9pbmRleC1zZXJ2aWNlXCIpO1xuY2xhc3MgU2VxdWVsaXplIGV4dGVuZHMgc2VxdWVsaXplXzEuU2VxdWVsaXplIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlcGFyZWRBcmdzLCBvcHRpb25zIH0gPSBzZXF1ZWxpemVfc2VydmljZV8xLnByZXBhcmVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICBzdXBlciguLi5wcmVwYXJlZEFyZ3MpO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0b3J5TW9kZSA9ICEhb3B0aW9ucy5yZXBvc2l0b3J5TW9kZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZGVscylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1vZGVscyhvcHRpb25zLm1vZGVscyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlbFBhdGhzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTW9kZWxzKG9wdGlvbnMubW9kZWxQYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRvcnlNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kZWwobW9kZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5tb2RlbChtb2RlbF9zZXJ2aWNlXzEuZ2V0TW9kZWxOYW1lKG1vZGVsLnByb3RvdHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5tb2RlbChtb2RlbCk7XG4gICAgfVxuICAgIGFkZE1vZGVscyhhcmcsIG1vZGVsTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE1vZGVsTWF0Y2ggPSAoZmlsZW5hbWUsIG1lbWJlcikgPT4gZmlsZW5hbWUgPT09IG1lbWJlcjtcbiAgICAgICAgY29uc3QgbW9kZWxzID0gc2VxdWVsaXplX3NlcnZpY2VfMS5nZXRNb2RlbHMoYXJnLCBtb2RlbE1hdGNoIHx8IHRoaXMub3B0aW9ucy5tb2RlbE1hdGNoIHx8IGRlZmF1bHRNb2RlbE1hdGNoKTtcbiAgICAgICAgY29uc3QgZGVmaW5lZE1vZGVscyA9IHRoaXMuZGVmaW5lTW9kZWxzKG1vZGVscyk7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRlTW9kZWxzKGRlZmluZWRNb2RlbHMpO1xuICAgICAgICBzY29wZV9zZXJ2aWNlXzEucmVzb2x2ZVNjb3BlcyhkZWZpbmVkTW9kZWxzKTtcbiAgICAgICAgaG9va3Nfc2VydmljZV8xLmluc3RhbGxIb29rcyhkZWZpbmVkTW9kZWxzKTtcbiAgICB9XG4gICAgZ2V0UmVwb3NpdG9yeShtb2RlbENsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsKG1vZGVsQ2xhc3MpO1xuICAgIH1cbiAgICBhc3NvY2lhdGVNb2RlbHMobW9kZWxzKSB7XG4gICAgICAgIG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IGFzc29jaWF0aW9uX3NlcnZpY2VfMS5nZXRBc3NvY2lhdGlvbnMobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGlmICghYXNzb2NpYXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFzc29jaWF0aW9ucy5mb3JFYWNoKGFzc29jaWF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gYXNzb2NpYXRpb24uZ2V0U2VxdWVsaXplT3B0aW9ucyhtb2RlbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRlZENsYXNzID0gdGhpcy5tb2RlbChhc3NvY2lhdGlvbi5nZXRBc3NvY2lhdGVkQ2xhc3MoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhc3NvY2lhdGVkQ2xhc3MuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yKGFzc29jaWF0ZWRDbGFzcywgYEFzc29jaWF0aW9uIGJldHdlZW4gJHthc3NvY2lhdGVkQ2xhc3MubmFtZX0gYW5kICR7bW9kZWwubmFtZX0gY2Fubm90IGJlIHJlc29sdmVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlbFthc3NvY2lhdGlvbi5nZXRBc3NvY2lhdGlvbigpXShhc3NvY2lhdGVkQ2xhc3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZpbmVNb2RlbHMobW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBtb2RlbHMubWFwKG1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IG1vZGVsX3NlcnZpY2VfMS5nZXRNb2RlbE5hbWUobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVfc2VydmljZV8xLmdldEF0dHJpYnV0ZXMobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleF9zZXJ2aWNlXzEuZ2V0SW5kZXhlcyhtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPcHRpb25zID0gbW9kZWxfc2VydmljZV8xLmdldE9wdGlvbnMobW9kZWwucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGlmICghbW9kZWxPcHRpb25zKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQFRhYmxlIGFubm90YXRpb24gaXMgbWlzc2luZyBvbiBjbGFzcyBcIiR7bW9kZWxbJ25hbWUnXX1cImApO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhBcnJheSA9IE9iamVjdC5rZXlzKGluZGV4ZXMubmFtZWQpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gaW5kZXhlcy5uYW1lZFtrZXldKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoaW5kZXhlcy51bm5hbWVkKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChpbmRleEFycmF5Lmxlbmd0aCA+IDAgJiYgeyBpbmRleGVzOiBpbmRleEFycmF5IH0pKSwgbW9kZWxPcHRpb25zKSwgeyBtb2RlbE5hbWUsIHNlcXVlbGl6ZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluZWRNb2RlbCA9IHRoaXMucmVwb3NpdG9yeU1vZGVcbiAgICAgICAgICAgICAgICA/IHRoaXMuY3JlYXRlUmVwb3NpdG9yeU1vZGVsKG1vZGVsKVxuICAgICAgICAgICAgICAgIDogbW9kZWw7XG4gICAgICAgICAgICBkZWZpbmVkTW9kZWwuaW5pdChhdHRyaWJ1dGVzLCBpbml0T3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZE1vZGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUmVwb3NpdG9yeU1vZGVsKG1vZGVsQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgbW9kZWxDbGFzcyB7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TZXF1ZWxpemUgPSBTZXF1ZWxpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZWxpemUuanMubWFwIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3NlcXVlbGl6ZSBzeW5jIHJlY3Vyc2l2ZVwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0OyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBEdW1teSBkYXRhYmFzZSBmaWxlLCB3aGljaCBnZXRzIHJlcXVpcmVkIGJ5IHNlcXVlbGl6ZSwgdG9cbiAqIG1ha2UgdmFsaWRhdGlvbiBvZiBtb2RlbHMgcG9zc2libGUgd2l0aG91dCB1c2luZyB0aGVcbiAqIGFjdHVhbCBPUk0gb3IgYW55IGRhdGFiYXNlIGNvbm5lY3Rpb24uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyYm9zZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHZlcmJvc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy52ZXJib3NlID0gdmVyYm9zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRiLWRpYWxlY3QtZHVtbXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaXF1ZUZpbHRlciA9IGV4cG9ydHMudW5pcXVlID0gdm9pZCAwO1xuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBzcGVjaWZpZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKGV4cG9ydHMudW5pcXVlRmlsdGVyKTtcbn1cbmV4cG9ydHMudW5pcXVlID0gdW5pcXVlO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgZm9yIGl0ZW1zLCB0aGF0IG9ubHkgZXhpc3RzIG9uY2Ugb24gYW4gYXJyYXlcbiAqL1xuY29uc3QgdW5pcXVlRmlsdGVyID0gKGl0ZW0sIGluZGV4LCBhcnIpID0+IGFyci5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbmV4cG9ydHMudW5pcXVlRmlsdGVyID0gdW5pcXVlRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFsbFByb3BlcnR5TmFtZXMgPSBleHBvcnRzLmNsb25lUmVnRXhwID0gZXhwb3J0cy5kZWVwQXNzaWduID0gdm9pZCAwO1xuZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpXG4gICAgICAgICAgICAuZm9yRWFjaChrZXkgPT4gYXNzaWduKGtleSwgdGFyZ2V0LCBzb3VyY2UpKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIE9iamVjdFxuICAgICAgICAgICAgICAgIC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiBhc3NpZ24oa2V5LCB0YXJnZXQsIHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgICBmdW5jdGlvbiBhc3NpZ24oa2V5LCBfdGFyZ2V0LCBfc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gX3NvdXJjZVtrZXldO1xuICAgICAgICBpZiAoc291cmNlVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldFZhbHVlID0gX3RhcmdldFtrZXldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0YXJnZXRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc291cmNlVmFsdWUuZm9yRWFjaCgoXywgaW5kZXgpID0+IGFzc2lnbihsZW5ndGggKyBpbmRleCwgdGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gY2xvbmVSZWdFeHAoc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBuZXcgRGF0ZShzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gT2JqZWN0LmNyZWF0ZShzb3VyY2VWYWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZXBBc3NpZ24odGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RhcmdldFtrZXldID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZXBBc3NpZ24gPSBkZWVwQXNzaWduO1xuLyoqXG4gKiBJIGNsb25lIHRoZSBnaXZlbiBSZWdFeHAgb2JqZWN0LCBhbmQgZW5zdXJlIHRoYXQgdGhlIGdpdmVuIGZsYWdzIGV4aXN0IG9uXG4gKiB0aGUgY2xvbmUuIFRoZSBpbmplY3RGbGFncyBwYXJhbWV0ZXIgaXMgcHVyZWx5IGFkZGl0aXZlIC0gaXQgY2Fubm90IHJlbW92ZVxuICogZmxhZ3MgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZVxuICpcbiAqIEBwYXJhbSBpbnB1dCBSZWdFeHAgLSBJIGFtIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGJlaW5nIGNsb25lZC5cbiAqIEBwYXJhbSBpbmplY3RGbGFncyBTdHJpbmcoIE9wdGlvbmFsICkgLSBJIGFtIHRoZSBmbGFncyB0byBlbmZvcmNlIG9uIHRoZSBjbG9uZS5cbiAqIEBzb3VyY2UgaHR0cHM6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjY2NC1jbG9uaW5nLXJlZ2V4cC1yZWd1bGFyLWV4cHJlc3Npb24tb2JqZWN0cy1pbi1qYXZhc2NyaXB0Lmh0bVxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChpbnB1dCwgaW5qZWN0RmxhZ3MpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gaW5wdXQuc291cmNlO1xuICAgIGxldCBmbGFncyA9IFwiXCI7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJhbWV0ZXIgaXMgYSBkZWZpbmVkIHN0cmluZyAtIGl0IHdpbGwgbWFrZSB0aGUgY29uZGl0aW9uYWxcbiAgICAvLyBsb2dpYyBlYXNpZXIgdG8gcmVhZC5cbiAgICBpbmplY3RGbGFncyA9IChpbmplY3RGbGFncyB8fCBcIlwiKTtcbiAgICAvLyBUZXN0IGZvciBnbG9iYWwuXG4gICAgaWYgKGlucHV0Lmdsb2JhbCB8fCAoL2cvaSkudGVzdChpbmplY3RGbGFncykpIHtcbiAgICAgICAgZmxhZ3MgKz0gXCJnXCI7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIGlnbm9yZUNhc2UuXG4gICAgaWYgKGlucHV0Lmlnbm9yZUNhc2UgfHwgKC9pL2kpLnRlc3QoaW5qZWN0RmxhZ3MpKSB7XG4gICAgICAgIGZsYWdzICs9IFwiaVwiO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBtdWx0aWxpbmUuXG4gICAgaWYgKGlucHV0Lm11bHRpbGluZSB8fCAoL20vaSkudGVzdChpbmplY3RGbGFncykpIHtcbiAgICAgICAgZmxhZ3MgKz0gXCJtXCI7XG4gICAgfVxuICAgIC8vIFJldHVybiBhIGNsb25lIHdpdGggdGhlIGFkZGl0aXZlIGZsYWdzLlxuICAgIHJldHVybiAobmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncykpO1xufVxuZXhwb3J0cy5jbG9uZVJlZ0V4cCA9IGNsb25lUmVnRXhwO1xuZnVuY3Rpb24gZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IGV4aXN0cyA9IHt9O1xuICAgIGRvIHtcbiAgICAgICAgbmFtZXMucHVzaC5hcHBseShuYW1lcywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG4gICAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIH0gd2hpbGUgKG9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIG5hbWVzLmZpbHRlcihuYW1lID0+IHtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9ICFleGlzdHNbbmFtZV0gJiYgbmFtZSAhPT0gJ2NvbnN0cnVjdG9yJztcbiAgICAgICAgZXhpc3RzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldEFsbFByb3BlcnR5TmFtZXMgPSBnZXRBbGxQcm9wZXJ0eU5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYXBpdGFsaXplID0gdm9pZCAwO1xuLyoqXG4gKiBDYXBpdGFsaXplIHNwZWNpZmllZCBzdHJpbmcgdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGgpO1xufVxuZXhwb3J0cy5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGFpbnMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogRm9yY2Ugc3BlY2lmaWMgc3Vic3RyaW5nc1xuICovXG5mdW5jdGlvbiBDb250YWlucyh2YWx1ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgY29udGFpbnM6IHZhbHVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuQ29udGFpbnMgPSBDb250YWlucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FcXVhbHMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyBhIHNwZWNpZmljIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIEVxdWFscyh2YWx1ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgZXF1YWxzOiB2YWx1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLkVxdWFscyA9IEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNBZnRlciA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IGRhdGUgc3RyaW5ncyBhZnRlciBhIHNwZWNpZmljIGRhdGVcbiAqL1xuZnVuY3Rpb24gSXNBZnRlcihkYXRlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0FmdGVyOiBkYXRlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNBZnRlciA9IElzQWZ0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hZnRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNBbHBoYSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXaWxsIG9ubHkgYWxsb3cgbGV0dGVyc1xuICovXG5mdW5jdGlvbiBJc0FscGhhKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0FscGhhOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNBbHBoYSA9IElzQWxwaGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hbHBoYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNBbHBoYW51bWVyaWMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV2lsbCBvbmx5IGFsbG93IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLCBzbyBcIl9hYmNcIiB3aWxsIGZhaWxcbiAqL1xuZnVuY3Rpb24gSXNBbHBoYW51bWVyaWModGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQWxwaGFudW1lcmljOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNBbHBoYW51bWVyaWMgPSBJc0FscGhhbnVtZXJpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFscGhhbnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXaWxsIG9ubHkgYWxsb3cgYXJyYXlzXG4gKi9cbmZ1bmN0aW9uIElzQXJyYXkodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0FycmF5ID0gSXNBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0JlZm9yZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IGRhdGUgc3RyaW5ncyBiZWZvcmUgYSBzcGVjaWZpYyBkYXRlXG4gKi9cbmZ1bmN0aW9uIElzQmVmb3JlKGRhdGUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQmVmb3JlOiBkYXRlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNCZWZvcmUgPSBJc0JlZm9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWJlZm9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNDcmVkaXRDYXJkID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrIGZvciB2YWxpZCBjcmVkaXQgY2FyZCBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIElzQ3JlZGl0Q2FyZCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNDcmVkaXRDYXJkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNDcmVkaXRDYXJkID0gSXNDcmVkaXRDYXJkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtY3JlZGl0LWNhcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzRGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IGRhdGUgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBJc0RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzRGF0ZSA9IElzRGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzRGVjaW1hbCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIGFueSBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIElzRGVjaW1hbCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNEZWNpbWFsOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNEZWNpbWFsID0gSXNEZWNpbWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZGVjaW1hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNFbWFpbCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIGVtYWlsIGZvcm1hdCAoZm9vQGJhci5jb20pXG4gKi9cbmZ1bmN0aW9uIElzRW1haWwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzRW1haWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0VtYWlsID0gSXNFbWFpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWVtYWlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0Zsb2F0ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgdmFsaWQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyc1xuICovXG5mdW5jdGlvbiBJc0Zsb2F0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0Zsb2F0OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNGbG9hdCA9IElzRmxvYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1mbG9hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNJbiA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVjayB0aGUgdmFsdWUgaXMgb25lIG9mIHRoZXNlXG4gKi9cbmZ1bmN0aW9uIElzSW4oYXJnKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0luOiBhcmdcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0luID0gSXNJbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0ludCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIHZhbGlkIGludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIElzSW50KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0ludDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzSW50ID0gSXNJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1pbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzSVB2NCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIElQdjQgKDEyOS44OS4yMy4xKVxuICovXG5mdW5jdGlvbiBJc0lQdjQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzSVB2NDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzSVB2NCA9IElzSVB2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWlwLXY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0lQdjYgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBJUHY2IGZvcm1hdFxuICovXG5mdW5jdGlvbiBJc0lQdjYodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzSVB2NjogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzSVB2NiA9IElzSVB2Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWlwLXY2LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0lQID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgSVB2NCAoMTI5Ljg5LjIzLjEpIG9yIElQdjYgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIElzSVAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzSVA6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0lQID0gSXNJUDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWlwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0xvd2VyY2FzZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIGxvd2VyY2FzZVxuICovXG5mdW5jdGlvbiBJc0xvd2VyY2FzZSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNMb3dlcmNhc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0xvd2VyY2FzZSA9IElzTG93ZXJjYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbG93ZXJjYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc051bGwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvd3MgbnVsbFxuICovXG5mdW5jdGlvbiBJc051bGwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzTnVsbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzTnVsbCA9IElzTnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW51bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzTnVtZXJpYyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXaWxsIG9ubHkgYWxsb3cgbnVtYmVyc1xuICovXG5mdW5jdGlvbiBJc051bWVyaWModGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzTnVtZXJpYzogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzTnVtZXJpYyA9IElzTnVtZXJpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW51bWVyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzVXBwZXJjYXNlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgdXBwZXJjYXNlXG4gKi9cbmZ1bmN0aW9uIElzVXBwZXJjYXNlKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc1VwcGVyY2FzZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzVXBwZXJjYXNlID0gSXNVcHBlcmNhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy11cHBlcmNhc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzVXJsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgdXJsIGZvcm1hdCAoaHR0cDovL2Zvby5jb20pXG4gKi9cbmZ1bmN0aW9uIElzVXJsKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc1VybDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzVXJsID0gSXNVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy11cmwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzVVVJRCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLypcbiAqIE9ubHkgYWxsb3cgdXVpZHMuXG4gKiBWZXJzaW9uJ3MgcmVndWxhciBleHByZXNzaW9uczpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzL2Jsb2IvYjU5MTMzYjE3MjdiNmFmMzU1YjQwM2E5YTk3YTE5MjI2Y2NlYjM0Yi9saWIvaXNVVUlELmpzI0wxNC1MMTkuXG4gKi9cbmZ1bmN0aW9uIElzVVVJRCh2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc1VVSUQ6IHZlcnNpb25cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc1VVSUQgPSBJc1VVSUQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy11dWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JcyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gSXMoLi4uYXJncykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBhcmdJc0Z1bmN0aW9uID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGFyZ0lzRnVuY3Rpb24gfHwgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgbGV0IHZhbGlkYXRvcjtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGlmIChhcmdJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IgPSBhcmdzWzBdO1xuICAgICAgICAgICAgbmFtZSA9IHZhbGlkYXRvci5uYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIHZhbGlkYXRvciBmdW5jdGlvbiBtdXN0IGhhdmUgYSBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhbGlkYXRvciA9IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uc1tgaXMke25hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCl9YF0gPSB2YWxpZGF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zLmlzID0gYXJnc1swXTtcbiAgICB9XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLklzID0gSXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGVuZ3RoID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgdmFsdWVzIHdpdGggbGVuZ3RoIGJldHdlZW4gbWluIGFuZCBtYXhcbiAqL1xuZnVuY3Rpb24gTGVuZ3RoKHsgbXNnLCBtaW4sIG1heCB9KSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgY29uc3QgbGVuZ3RoID0gW21pbiB8fCAwLCBtYXhdO1xuICAgIG9wdGlvbnMgPSBtc2cgPyB7IGFyZ3M6IGxlbmd0aCwgbXNnOiBtc2cgfSA6IGxlbmd0aDtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGxlbjogb3B0aW9uc1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLkxlbmd0aCA9IExlbmd0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgdmFsdWVzIDw9IGxpbWl0XG4gKi9cbmZ1bmN0aW9uIE1heChsaW1pdCkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbWF4OiBsaW1pdFxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk1heCA9IE1heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWluID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgdmFsdWVzID49IGxpbWl0XG4gKi9cbmZ1bmN0aW9uIE1pbihsaW1pdCkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbWluOiBsaW1pdFxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk1pbiA9IE1pbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90Q29udGFpbnMgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogRG9uJ3QgYWxsb3cgc3BlY2lmaWMgc3Vic3RyaW5nc1xuICovXG5mdW5jdGlvbiBOb3RDb250YWlucyh2YWx1ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbm90Q29udGFpbnM6IHZhbHVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTm90Q29udGFpbnMgPSBOb3RDb250YWlucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90RW1wdHkgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmZ1bmN0aW9uIE5vdEVtcHR5KC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgICAgICBub3RFbXB0eTogb3B0aW9ucyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhcmdzWzFdO1xuICAgICAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICAgICAgbm90RW1wdHk6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RFbXB0eSA9IE5vdEVtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LWVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3RJbiA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVjayB0aGUgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGVzZVxuICovXG5mdW5jdGlvbiBOb3RJbihhcmcpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG5vdEluOiBhcmdcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Ob3RJbiA9IE5vdEluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3ROdWxsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdvbid0IGFsbG93IG51bGxcbiAqL1xuZnVuY3Rpb24gTm90TnVsbCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbm90TnVsbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk5vdE51bGwgPSBOb3ROdWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LW51bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXaWxsIG5vdCBhbGxvdyB2YWx1ZXMsIHRoYXQgbWF0Y2ggdGhlIHN0cmluZyByZWdleCBvciByZWFsIHJlZ2V4XG4gKi9cbmZ1bmN0aW9uIE5vdChhcmcpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIG5vdDogYXJnXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTm90ID0gTm90O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBTZXRzIHZhbGlkYXRpb24gb3B0aW9ucyBmb3IgYW5ub3RhdGVkIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIFZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLlZhbGlkYXRlID0gVmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdG9yID0gdm9pZCAwO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuY29uc3QgVmFsaWRhdG9yID0gKHRhcmdldCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgbW9kZWxfc2VydmljZV8xLmFkZE9wdGlvbnModGFyZ2V0LCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBbcHJvcGVydHlOYW1lXTogZGVzY3JpcHRvci52YWx1ZVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5WYWxpZGF0b3IgPSBWYWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAgKiBUaGUgZW50cnkgcG9pbnQuXG4gICpcbiAgKiBAbW9kdWxlIFNlcXVlbGl6ZVxuICAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9zZXF1ZWxpemUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBBc3NvY2lhdGlvbkVycm9yIH0gPSByZXF1aXJlKCcuLy4uL2Vycm9ycycpO1xuXG4vKipcbiAqIENyZWF0aW5nIGFzc29jaWF0aW9ucyBpbiBzZXF1ZWxpemUgaXMgZG9uZSBieSBjYWxsaW5nIG9uZSBvZiB0aGUgYmVsb25nc1RvIC8gaGFzT25lIC8gaGFzTWFueSAvIGJlbG9uZ3NUb01hbnkgZnVuY3Rpb25zIG9uIGEgbW9kZWwgKHRoZSBzb3VyY2UpLCBhbmQgcHJvdmlkaW5nIGFub3RoZXIgbW9kZWwgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbiAodGhlIHRhcmdldCkuXG4gKlxuICogKiBoYXNPbmUgLSBhZGRzIGEgZm9yZWlnbiBrZXkgdG8gdGhlIHRhcmdldCBhbmQgc2luZ3VsYXIgYXNzb2NpYXRpb24gbWl4aW5zIHRvIHRoZSBzb3VyY2UuXG4gKiAqIGJlbG9uZ3NUbyAtIGFkZCBhIGZvcmVpZ24ga2V5IGFuZCBzaW5ndWxhciBhc3NvY2lhdGlvbiBtaXhpbnMgdG8gdGhlIHNvdXJjZS5cbiAqICogaGFzTWFueSAtIGFkZHMgYSBmb3JlaWduIGtleSB0byB0YXJnZXQgYW5kIHBsdXJhbCBhc3NvY2lhdGlvbiBtaXhpbnMgdG8gdGhlIHNvdXJjZS5cbiAqICogYmVsb25nc1RvTWFueSAtIGNyZWF0ZXMgYW4gTjpNIGFzc29jaWF0aW9uIHdpdGggYSBqb2luIHRhYmxlIGFuZCBhZGRzIHBsdXJhbCBhc3NvY2lhdGlvbiBtaXhpbnMgdG8gdGhlIHNvdXJjZS4gVGhlIGp1bmN0aW9uIHRhYmxlIGlzIGNyZWF0ZWQgd2l0aCBzb3VyY2VJZCBhbmQgdGFyZ2V0SWQuXG4gKlxuICogQ3JlYXRpbmcgYW4gYXNzb2NpYXRpb24gd2lsbCBhZGQgYSBmb3JlaWduIGtleSBjb25zdHJhaW50IHRvIHRoZSBhdHRyaWJ1dGVzLiBBbGwgYXNzb2NpYXRpb25zIHVzZSBgQ0FTQ0FERWAgb24gdXBkYXRlIGFuZCBgU0VUIE5VTExgIG9uIGRlbGV0ZSwgZXhjZXB0IGZvciBuOm0sIHdoaWNoIGFsc28gdXNlcyBgQ0FTQ0FERWAgb24gZGVsZXRlLlxuICpcbiAqIFdoZW4gY3JlYXRpbmcgYXNzb2NpYXRpb25zLCB5b3UgY2FuIHByb3ZpZGUgYW4gYWxpYXMsIHZpYSB0aGUgYGFzYCBvcHRpb24uIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSBzYW1lIG1vZGVsIGlzIGFzc29jaWF0ZWQgdHdpY2UsIG9yIHlvdSB3YW50IHlvdXIgYXNzb2NpYXRpb24gdG8gYmUgY2FsbGVkIHNvbWV0aGluZyBvdGhlciB0aGFuIHRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbW9kZWwuXG4gKlxuICogQXMgYW4gZXhhbXBsZSwgY29uc2lkZXIgdGhlIGNhc2Ugd2hlcmUgdXNlcnMgaGF2ZSBtYW55IHBpY3R1cmVzLCBvbmUgb2Ygd2hpY2ggaXMgdGhlaXIgcHJvZmlsZSBwaWN0dXJlLiBBbGwgcGljdHVyZXMgaGF2ZSBhIGB1c2VySWRgLCBidXQgaW4gYWRkaXRpb24gdGhlIHVzZXIgbW9kZWwgYWxzbyBoYXMgYSBgcHJvZmlsZVBpY3R1cmVJZGAsIHRvIGJlIGFibGUgdG8gZWFzaWx5IGxvYWQgdGhlIHVzZXIncyBwcm9maWxlIHBpY3R1cmUuXG4gKlxuICogYGBganNcbiAqIFVzZXIuaGFzTWFueShQaWN0dXJlKVxuICogVXNlci5iZWxvbmdzVG8oUGljdHVyZSwgeyBhczogJ1Byb2ZpbGVQaWN0dXJlJywgY29uc3RyYWludHM6IGZhbHNlIH0pXG4gKlxuICogdXNlci5nZXRQaWN0dXJlcygpIC8vIGdldHMgeW91IGFsbCBwaWN0dXJlc1xuICogdXNlci5nZXRQcm9maWxlUGljdHVyZSgpIC8vIGdldHMgeW91IG9ubHkgdGhlIHByb2ZpbGUgcGljdHVyZVxuICpcbiAqIFVzZXIuZmluZEFsbCh7XG4gKiAgIHdoZXJlOiAuLi4sXG4gKiAgIGluY2x1ZGU6IFtcbiAqICAgICB7IG1vZGVsOiBQaWN0dXJlIH0sIC8vIGxvYWQgYWxsIHBpY3R1cmVzXG4gKiAgICAgeyBtb2RlbDogUGljdHVyZSwgYXM6ICdQcm9maWxlUGljdHVyZScgfSwgLy8gbG9hZCB0aGUgcHJvZmlsZSBwaWN0dXJlLlxuICogICAgIC8vIE5vdGljZSB0aGF0IHRoZSBzcGVsbGluZyBtdXN0IGJlIHRoZSBleGFjdCBzYW1lIGFzIHRoZSBvbmUgaW4gdGhlIGFzc29jaWF0aW9uXG4gKiAgIF1cbiAqIH0pXG4gKiBgYGBcbiAqIFRvIGdldCBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgZm9yZWlnbiBrZXkgY29sdW1uIGFkZGVkIGJ5IHNlcXVlbGl6ZSwgeW91IGNhbiB1c2UgdGhlIGBmb3JlaWduS2V5YCBvcHRpb24uIEl0IGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcsIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lLCBvciBhbmQgb2JqZWN0IHR5cGUgZGVmaW5pdGlvbixcbiAqIGVxdWl2YWxlbnQgdG8gdGhvc2UgcGFzc2VkIHRvIGBzZXF1ZWxpemUuZGVmaW5lYC5cbiAqXG4gKiBgYGBqc1xuICogVXNlci5oYXNNYW55KFBpY3R1cmUsIHsgZm9yZWlnbktleTogJ3VpZCcgfSlcbiAqIGBgYFxuICpcbiAqIFRoZSBmb3JlaWduIGtleSBjb2x1bW4gaW4gUGljdHVyZSB3aWxsIG5vdyBiZSBjYWxsZWQgYHVpZGAgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgdXNlcklkYC5cbiAqXG4gKiBgYGBqc1xuICogVXNlci5oYXNNYW55KFBpY3R1cmUsIHtcbiAqICAgZm9yZWlnbktleToge1xuICogICAgIG5hbWU6ICd1aWQnLFxuICogICAgIGFsbG93TnVsbDogZmFsc2VcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoaXMgc3BlY2lmaWVzIHRoYXQgdGhlIGB1aWRgIGNvbHVtbiBjYW5ub3QgYmUgbnVsbC4gSW4gbW9zdCBjYXNlcyB0aGlzIHdpbGwgYWxyZWFkeSBiZSBjb3ZlcmVkIGJ5IHRoZSBmb3JlaWduIGtleSBjb25zdHJhaW50cywgd2hpY2ggc2VxdWVsaXplIGNyZWF0ZXMgYXV0b21hdGljYWxseSwgYnV0IGNhbiBiZSB1c2VmdWwgaW4gY2FzZSB3aGVyZSB0aGUgZm9yZWlnbiBrZXlzIGFyZSBkaXNhYmxlZCwgZS5nLiBkdWUgdG8gY2lyY3VsYXIgcmVmZXJlbmNlcyAoc2VlIGBjb25zdHJhaW50czogZmFsc2VgIGJlbG93KS5cbiAqXG4gKiBXaGVuIGZldGNoaW5nIGFzc29jaWF0ZWQgbW9kZWxzLCB5b3UgY2FuIGxpbWl0IHlvdXIgcXVlcnkgdG8gb25seSBsb2FkIHNvbWUgbW9kZWxzLiBUaGVzZSBxdWVyaWVzIGFyZSB3cml0dGVuIGluIHRoZSBzYW1lIHdheSBhcyBxdWVyaWVzIHRvIGBmaW5kYC9gZmluZEFsbGAuIFRvIG9ubHkgZ2V0IHBpY3R1cmVzIGluIEpQRywgeW91IGNhbiBkbzpcbiAqXG4gKiBgYGBqc1xuICogdXNlci5nZXRQaWN0dXJlcyh7XG4gKiAgIHdoZXJlOiB7XG4gKiAgICAgZm9ybWF0OiAnanBnJ1xuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byB1cGRhdGUgYW5kIGFkZCBuZXcgYXNzb2NpYXRpb25zLiBDb250aW51aW5nIHdpdGggb3VyIGV4YW1wbGUgb2YgdXNlcnMgYW5kIHBpY3R1cmVzOlxuICogYGBganNcbiAqIHVzZXIuYWRkUGljdHVyZShwKSAvLyBBZGQgYSBzaW5nbGUgcGljdHVyZVxuICogdXNlci5zZXRQaWN0dXJlcyhbcDEsIHAyXSkgLy8gQXNzb2NpYXRlIHVzZXIgd2l0aCBPTkxZIHRoZXNlIHR3byBwaWN0dXJlLCBhbGwgb3RoZXIgYXNzb2NpYXRpb25zIHdpbGwgYmUgZGVsZXRlZFxuICogdXNlci5hZGRQaWN0dXJlcyhbcDEsIHAyXSkgLy8gQXNzb2NpYXRlIHVzZXIgd2l0aCB0aGVzZSB0d28gcGljdHVyZXMsIGJ1dCBkb24ndCB0b3VjaCBhbnkgY3VycmVudCBhc3NvY2lhdGlvbnNcbiAqIGBgYFxuICpcbiAqIFlvdSBkb24ndCBoYXZlIHRvIHBhc3MgaW4gYSBjb21wbGV0ZSBvYmplY3QgdG8gdGhlIGFzc29jaWF0aW9uIGZ1bmN0aW9ucywgaWYgeW91ciBhc3NvY2lhdGVkIG1vZGVsIGhhcyBhIHNpbmdsZSBwcmltYXJ5IGtleTpcbiAqXG4gKiBgYGBqc1xuICogdXNlci5hZGRQaWN0dXJlKHJlcS5xdWVyeS5waWQpIC8vIEhlcmUgcGlkIGlzIGp1c3QgYW4gaW50ZWdlciwgcmVwcmVzZW50aW5nIHRoZSBwcmltYXJ5IGtleSBvZiB0aGUgcGljdHVyZVxuICogYGBgXG4gKlxuICogSW4gdGhlIGV4YW1wbGUgYWJvdmUgd2UgaGF2ZSBzcGVjaWZpZWQgdGhhdCBhIHVzZXIgYmVsb25ncyB0byBoaXMgcHJvZmlsZSBwaWN0dXJlLiBDb25jZXB0dWFsbHksIHRoaXMgbWlnaHQgbm90IG1ha2Ugc2Vuc2UsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGFkZCB0aGUgZm9yZWlnbiBrZXkgdG8gdGhlIHVzZXIgbW9kZWwgdGhpcyBpcyB0aGUgd2F5IHRvIGRvIGl0LlxuICpcbiAqIE5vdGUgaG93IHdlIGFsc28gc3BlY2lmaWVkIGBjb25zdHJhaW50czogZmFsc2VgIGZvciBwcm9maWxlIHBpY3R1cmUuIFRoaXMgaXMgYmVjYXVzZSB3ZSBhZGQgYSBmb3JlaWduIGtleSBmcm9tIHVzZXIgdG8gcGljdHVyZSAocHJvZmlsZVBpY3R1cmVJZCksIGFuZCBmcm9tIHBpY3R1cmUgdG8gdXNlciAodXNlcklkKS4gSWYgd2Ugd2VyZSB0byBhZGQgZm9yZWlnbiBrZXlzIHRvIGJvdGgsIGl0IHdvdWxkIGNyZWF0ZSBhIGN5Y2xpYyBkZXBlbmRlbmN5LCBhbmQgc2VxdWVsaXplIHdvdWxkIG5vdCBrbm93IHdoaWNoIHRhYmxlIHRvIGNyZWF0ZSBmaXJzdCwgc2luY2UgdXNlciBkZXBlbmRzIG9uIHBpY3R1cmUsIGFuZCBwaWN0dXJlIGRlcGVuZHMgb24gdXNlci4gVGhlc2Uga2luZHMgb2YgcHJvYmxlbXMgYXJlIGRldGVjdGVkIGJ5IHNlcXVlbGl6ZSBiZWZvcmUgdGhlIG1vZGVscyBhcmUgc3luY2VkIHRvIHRoZSBkYXRhYmFzZSwgYW5kIHlvdSB3aWxsIGdldCBhbiBlcnJvciBhbG9uZyB0aGUgbGluZXMgb2YgYEVycm9yOiBDeWNsaWMgZGVwZW5kZW5jeSBmb3VuZC4gJ3VzZXJzJyBpcyBkZXBlbmRlbnQgb2YgaXRzZWxmYC4gSWYgeW91IGVuY291bnRlciB0aGlzLCB5b3Ugc2hvdWxkIGVpdGhlciBkaXNhYmxlIHNvbWUgY29uc3RyYWludHMsIG9yIHJldGhpbmsgeW91ciBhc3NvY2lhdGlvbnMgY29tcGxldGVseS5cbiAqL1xuY2xhc3MgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01vZGVsfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge01vZGVsfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZTtcbiAgICB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID0gdGhpcy5zb3VyY2UgPT09IHRoaXMudGFyZ2V0O1xuICAgIHRoaXMuYXMgPSBvcHRpb25zLmFzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGFzc29jaWF0aW9uLiBPbmUgb2YgYEhhc01hbnlgLCBgQmVsb25nc1RvYCwgYEhhc09uZWAsIGBCZWxvbmdzVG9NYW55YFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9ICcnO1xuXG4gICAgaWYgKHNvdXJjZS5oYXNBbGlhcyhvcHRpb25zLmFzKSkge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoYFlvdSBoYXZlIHVzZWQgdGhlIGFsaWFzICR7b3B0aW9ucy5hc30gaW4gdHdvIHNlcGFyYXRlIGFzc29jaWF0aW9ucy4gYCArXG4gICAgICAnQWxpYXNlZCBhc3NvY2lhdGlvbnMgbXVzdCBoYXZlIHVuaXF1ZSBhbGlhc2VzLidcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gaW5wdXQgaXQgbWF5IGJlIGFycmF5IG9yIHNpbmdsZSBvYmosIGluc3RhbmNlIG9yIHByaW1hcnkga2V5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYnVpbHQgb2JqZWN0c1xuICAgKi9cbiAgdG9JbnN0YW5jZUFycmF5KGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnB1dC5tYXAoZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSByZXR1cm4gZWxlbWVudDtcblxuICAgICAgY29uc3QgdG1wSW5zdGFuY2UgPSB7fTtcbiAgICAgIHRtcEluc3RhbmNlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gZWxlbWVudDtcblxuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0LmJ1aWxkKHRtcEluc3RhbmNlLCB7IGlzTmV3UmVjb3JkOiBmYWxzZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc29jaWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKCcuL2JlbG9uZ3MtdG8nKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKCcuL2hhcy1tYW55Jyk7XG5jb25zdCBIYXNPbmUgPSByZXF1aXJlKCcuL2hhcy1vbmUnKTtcbmNvbnN0IEFzc29jaWF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5Bc3NvY2lhdGlvbkVycm9yO1xuY29uc3QgRW1wdHlSZXN1bHRFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLkVtcHR5UmVzdWx0RXJyb3I7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG4vKipcbiAqIE1hbnktdG8tbWFueSBhc3NvY2lhdGlvbiB3aXRoIGEgam9pbiB0YWJsZS5cbiAqXG4gKiBXaGVuIHRoZSBqb2luIHRhYmxlIGhhcyBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMsIHRoZXNlIGNhbiBiZSBwYXNzZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0OlxuICpcbiAqIGBgYGpzXG4gKiBVc2VyUHJvamVjdCA9IHNlcXVlbGl6ZS5kZWZpbmUoJ3VzZXJfcHJvamVjdCcsIHtcbiAqICAgcm9sZTogU2VxdWVsaXplLlNUUklOR1xuICogfSk7XG4gKiBVc2VyLmJlbG9uZ3NUb01hbnkoUHJvamVjdCwgeyB0aHJvdWdoOiBVc2VyUHJvamVjdCB9KTtcbiAqIFByb2plY3QuYmVsb25nc1RvTWFueShVc2VyLCB7IHRocm91Z2g6IFVzZXJQcm9qZWN0IH0pO1xuICogLy8gdGhyb3VnaCBpcyByZXF1aXJlZCFcbiAqXG4gKiB1c2VyLmFkZFByb2plY3QocHJvamVjdCwgeyB0aHJvdWdoOiB7IHJvbGU6ICdtYW5hZ2VyJyB9fSk7XG4gKiBgYGBcbiAqXG4gKiBBbGwgbWV0aG9kcyBhbGxvdyB5b3UgdG8gcGFzcyBlaXRoZXIgYSBwZXJzaXN0ZWQgaW5zdGFuY2UsIGl0cyBwcmltYXJ5IGtleSwgb3IgYSBtaXh0dXJlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwcm9qZWN0ID0gYXdhaXQgUHJvamVjdC5jcmVhdGUoeyBpZDogMTEgfSk7XG4gKiBhd2FpdCB1c2VyLmFkZFByb2plY3RzKFtwcm9qZWN0LCAxMl0pO1xuICogYGBgXG4gKlxuICogSWYgeW91IHdhbnQgdG8gc2V0IHNldmVyYWwgdGFyZ2V0IGluc3RhbmNlcywgYnV0IHdpdGggZGlmZmVyZW50IGF0dHJpYnV0ZXMgeW91IGhhdmUgdG8gc2V0IHRoZSBhdHRyaWJ1dGVzIG9uIHRoZSBpbnN0YW5jZSwgdXNpbmcgYSBwcm9wZXJ0eSB3aXRoIHRoZSBuYW1lIG9mIHRoZSB0aHJvdWdoIG1vZGVsOlxuICpcbiAqIGBgYGpzXG4gKiBwMS5Vc2VyUHJvamVjdHMgPSB7XG4gKiAgIHN0YXJ0ZWQ6IHRydWVcbiAqIH1cbiAqIHVzZXIuc2V0UHJvamVjdHMoW3AxLCBwMl0sIHsgdGhyb3VnaDogeyBzdGFydGVkOiBmYWxzZSB9fSkgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UsIGJ1dCBwMSBvdmVycmlkZXMgdGhhdC5cbiAqIGBgYFxuICpcbiAqIFNpbWlsYXJseSwgd2hlbiBmZXRjaGluZyB0aHJvdWdoIGEgam9pbiB0YWJsZSB3aXRoIGN1c3RvbSBhdHRyaWJ1dGVzLCB0aGVzZSBhdHRyaWJ1dGVzIHdpbGwgYmUgYXZhaWxhYmxlIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSB0aHJvdWdoIG1vZGVsLlxuICogYGBganNcbiAqIGNvbnN0IHByb2plY3RzID0gYXdhaXQgdXNlci5nZXRQcm9qZWN0cygpO1xuICogY29uc3QgcDEgPSBwcm9qZWN0c1swXTtcbiAqIHAxLlVzZXJQcm9qZWN0cy5zdGFydGVkIC8vIElzIHRoaXMgcHJvamVjdCBzdGFydGVkIHlldD9cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgQVBJIHJlZmVyZW5jZSBiZWxvdywgYWRkIHRoZSBuYW1lIG9mIHRoZSBhc3NvY2lhdGlvbiB0byB0aGUgbWV0aG9kLCBlLmcuIGZvciBgVXNlci5iZWxvbmdzVG9NYW55KFByb2plY3QpYCB0aGUgZ2V0dGVyIHdpbGwgYmUgYHVzZXIuZ2V0UHJvamVjdHMoKWAuXG4gKlxuICogQHNlZSB7QGxpbmsgTW9kZWwuYmVsb25nc1RvTWFueX1cbiAqL1xuY2xhc3MgQmVsb25nc1RvTWFueSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2ggPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoYCR7c291cmNlLm5hbWV9LmJlbG9uZ3NUb01hbnkoJHt0YXJnZXQubmFtZX0pIHJlcXVpcmVzIHRocm91Z2ggb3B0aW9uLCBwYXNzIGVpdGhlciBhIHN0cmluZyBvciBhIG1vZGVsYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgdGhpcy5vcHRpb25zLnRocm91Z2ggPSB7XG4gICAgICAgIG1vZGVsOiBvcHRpb25zLnRocm91Z2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSAnQmVsb25nc1RvTWFueSc7XG4gICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzb3VyY2Uuc2VxdWVsaXplO1xuICAgIHRoaXMudGhyb3VnaCA9IHsgLi4udGhpcy5vcHRpb25zLnRocm91Z2ggfTtcbiAgICB0aGlzLmlzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5kb3VibGVMaW5rZWQgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5hcyAmJiB0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcignXFwnYXNcXCcgbXVzdCBiZSBkZWZpbmVkIGZvciBtYW55LXRvLW1hbnkgc2VsZi1hc3NvY2lhdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMuYXMpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy5hcztcbiAgICAgICAgdGhpcy5hcyA9IHRoaXMuYXMucGx1cmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgICAgcGx1cmFsOiB0aGlzLmFzLFxuICAgICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnBsdXJhbDtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cblxuICAgIHRoaXMuY29tYmluZWRUYWJsZU5hbWUgPSBVdGlscy5jb21iaW5lVGFibGVOYW1lcyhcbiAgICAgIHRoaXMuc291cmNlLnRhYmxlTmFtZSxcbiAgICAgIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPyB0aGlzLmFzIHx8IHRoaXMudGFyZ2V0LnRhYmxlTmFtZSA6IHRoaXMudGFyZ2V0LnRhYmxlTmFtZVxuICAgICk7XG5cbiAgICAvKlxuICAgICogSWYgc2VsZiBhc3NvY2lhdGlvbiwgdGhpcyBpcyB0aGUgdGFyZ2V0IGFzc29jaWF0aW9uIC0gVW5sZXNzIHdlIGZpbmQgYSBwYWlyaW5nIGFzc29jaWF0aW9uXG4gICAgKi9cbiAgICBpZiAodGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIEZpbmQgcGFpcmVkIGFzc29jaWF0aW9uIChpZiBleGlzdHMpXG4gICAgKi9cbiAgICBfLmVhY2godGhpcy50YXJnZXQuYXNzb2NpYXRpb25zLCBhc3NvY2lhdGlvbiA9PiB7XG4gICAgICBpZiAoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlICE9PSAnQmVsb25nc1RvTWFueScpIHJldHVybjtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi50YXJnZXQgIT09IHRoaXMuc291cmNlKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaC5tb2RlbCA9PT0gYXNzb2NpYXRpb24ub3B0aW9ucy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgIHRoaXMucGFpcmVkID0gYXNzb2NpYXRpb247XG4gICAgICAgIGFzc29jaWF0aW9uLnBhaXJlZCA9IHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICogRGVmYXVsdC9nZW5lcmF0ZWQgc291cmNlL3RhcmdldCBrZXlzXG4gICAgKi9cbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEtleSkge1xuICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLm9wdGlvbnMudGFyZ2V0S2V5O1xuICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcmdldEtleURlZmF1bHQgPSB0cnVlO1xuICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy50aHJvdWdoLm1vZGVsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5pc0RlZmluZWQodGhpcy50aHJvdWdoLm1vZGVsKSkge1xuICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwgPSB0aGlzLnNlcXVlbGl6ZS5kZWZpbmUodGhpcy50aHJvdWdoLm1vZGVsLCB7fSwgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICB0YWJsZU5hbWU6IHRoaXMudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgICBpbmRleGVzOiBbXSwgLy93ZSBkb24ndCB3YW50IGluZGV4ZXMgaGVyZSAoYXMgcmVmZXJlbmNlZCBpbiAjMjQxNilcbiAgICAgICAgICBwYXJhbm9pZDogdGhpcy50aHJvdWdoLnBhcmFub2lkID8gdGhpcy50aHJvdWdoLnBhcmFub2lkIDogZmFsc2UsIC8vIERlZmF1bHQgdG8gbm9uLXBhcmFub2lkIGpvaW4gKHJlZmVyZW5jZWQgaW4gIzExOTkxKVxuICAgICAgICAgIHZhbGlkYXRlOiB7fSAvLyBEb24ndCBwcm9wYWdhdGUgbW9kZWwtbGV2ZWwgdmFsaWRhdGlvbnNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsID0gdGhpcy5zZXF1ZWxpemUubW9kZWwodGhpcy50aHJvdWdoLm1vZGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgXy5waWNrKHRoaXMudGhyb3VnaC5tb2RlbC5vcHRpb25zLCBbXG4gICAgICAndGltZXN0YW1wcycsICdjcmVhdGVkQXQnLCAndXBkYXRlZEF0JywgJ2RlbGV0ZWRBdCcsICdwYXJhbm9pZCdcbiAgICBdKSk7XG5cbiAgICBpZiAodGhpcy5wYWlyZWQpIHtcbiAgICAgIGxldCBuZWVkSW5qZWN0UGFpcmVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldEtleURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLnBhaXJlZC5zb3VyY2VLZXk7XG4gICAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnBhaXJlZC5zb3VyY2VLZXlGaWVsZDtcbiAgICAgICAgdGhpcy5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpcmVkLnRhcmdldEtleURlZmF1bHQpIHtcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHBhaXJlZC5vdGhlcktleSBkZXBlbmRzIG9uIHBhaXJlZC50YXJnZXRLZXksXG4gICAgICAgIC8vIHNvIGNsZWFudXAgcHJldmlvdXNseSB3cm9uZyBnZW5lcmF0ZWQgb3RoZXJLZXlcbiAgICAgICAgaWYgKHRoaXMucGFpcmVkLnRhcmdldEtleSAhPT0gdGhpcy5zb3VyY2VLZXkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldO1xuICAgICAgICAgIHRoaXMucGFpcmVkLnRhcmdldEtleSA9IHRoaXMuc291cmNlS2V5O1xuICAgICAgICAgIHRoaXMucGFpcmVkLnRhcmdldEtleUZpZWxkID0gdGhpcy5zb3VyY2VLZXlGaWVsZDtcbiAgICAgICAgICB0aGlzLnBhaXJlZC5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuICAgICAgICAgIG5lZWRJbmplY3RQYWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5wYWlyZWQuZm9yZWlnbktleTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaXJlZC5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgICAgLy8gSWYgcGFpcmVkIG90aGVyS2V5IHdhcyBpbmZlcnJlZCB3ZSBzaG91bGQgbWFrZSBzdXJlIHRvIGNsZWFuIGl0IHVwXG4gICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgYSBuZXcgb25lIHRoYXQgbWF0Y2hlcyB0aGUgZm9yZWlnbktleVxuICAgICAgICBpZiAodGhpcy5wYWlyZWQub3RoZXJLZXkgIT09IHRoaXMuZm9yZWlnbktleSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV07XG4gICAgICAgICAgdGhpcy5wYWlyZWQub3RoZXJLZXkgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgICAgICAgbmVlZEluamVjdFBhaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRJbmplY3RQYWlyZWQpIHtcbiAgICAgICAgdGhpcy5wYWlyZWQuX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50aHJvdWdoKSB7XG4gICAgICB0aGlzLnRocm91Z2hNb2RlbCA9IHRoaXMudGhyb3VnaC5tb2RlbDtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMudGFibGVOYW1lID0gdGhpcy5jb21iaW5lZE5hbWUgPSB0aGlzLnRocm91Z2gubW9kZWwgPT09IE9iamVjdCh0aGlzLnRocm91Z2gubW9kZWwpID8gdGhpcy50aHJvdWdoLm1vZGVsLnRhYmxlTmFtZSA6IHRoaXMudGhyb3VnaC5tb2RlbDtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG5cbiAgICAvLyBHZXQgc2luZ3VsYXIgYW5kIHBsdXJhbCBuYW1lcywgdHJ5aW5nIHRvIHVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyLCB1bmxlc3MgdGhlIG1vZGVsIGZvcmJpZHMgaXRcbiAgICBjb25zdCBwbHVyYWwgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUucGx1cmFsKTtcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7cGx1cmFsfWAsXG4gICAgICBzZXQ6IGBzZXQke3BsdXJhbH1gLFxuICAgICAgYWRkTXVsdGlwbGU6IGBhZGQke3BsdXJhbH1gLFxuICAgICAgYWRkOiBgYWRkJHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlOiBgcmVtb3ZlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IGByZW1vdmUke3BsdXJhbH1gLFxuICAgICAgaGFzU2luZ2xlOiBgaGFzJHtzaW5ndWxhcn1gLFxuICAgICAgaGFzQWxsOiBgaGFzJHtwbHVyYWx9YCxcbiAgICAgIGNvdW50OiBgY291bnQke3BsdXJhbH1gXG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCkge1xuICAgIC8qXG4gICAgKiBEZWZhdWx0L2dlbmVyYXRlZCBmb3JlaWduL290aGVyIGtleXNcbiAgICAqL1xuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5IHx8IFV0aWxzLmNhbWVsaXplKFxuICAgICAgICBbXG4gICAgICAgICAgdGhpcy5zb3VyY2Uub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICAgIHRoaXMuc291cmNlS2V5XG4gICAgICAgIF0uam9pbignXycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5vdGhlcktleSkpIHtcbiAgICAgIHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMub3RoZXJLZXk7XG4gICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5vdGhlcktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdGhlcktleSkge1xuICAgICAgICB0aGlzLm90aGVyS2V5RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLm9wdGlvbnMub3RoZXJLZXkgfHwgVXRpbHMuY2FtZWxpemUoXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID8gVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcykgOiB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgICAgdGhpcy50YXJnZXRLZXlcbiAgICAgICAgXS5qb2luKCdfJylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIGlkIGlzIGluIHRoZSB0YXJnZXQgdGFibGVcbiAgLy8gb3IgaW4gYW4gZXh0cmEgdGFibGUgd2hpY2ggY29ubmVjdHMgdHdvIHRhYmxlc1xuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduSWRlbnRpZmllciA9IHRoaXMub3RoZXJLZXk7XG5cbiAgICAvLyByZW1vdmUgYW55IFBLcyBwcmV2aW91c2x5IGRlZmluZWQgYnkgc2VxdWVsaXplXG4gICAgLy8gYnV0IGlnbm9yZSBhbnkga2V5cyB0aGF0IGFyZSBwYXJ0IG9mIHRoaXMgYXNzb2NpYXRpb24gKCM1ODY1KVxuICAgIF8uZWFjaCh0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSkgPT4ge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5ID09PSB0cnVlICYmIGF0dHJpYnV0ZS5fYXV0b0dlbmVyYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gdGhpcy5mb3JlaWduS2V5IHx8IGF0dHJpYnV0ZU5hbWUgPT09IHRoaXMub3RoZXJLZXkpIHtcbiAgICAgICAgICAvLyB0aGlzIGtleSBpcyBzdGlsbCBuZWVkZWQgYXMgaXQncyBwYXJ0IG9mIHRoZSBhc3NvY2lhdGlvblxuICAgICAgICAgIC8vIHNvIGp1c3Qgc2V0IHByaW1hcnlLZXkgdG8gZmFsc2VcbiAgICAgICAgICBhdHRyaWJ1dGUucHJpbWFyeUtleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW1hcnlLZXlEZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHNvdXJjZUtleSA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldO1xuICAgIGNvbnN0IHNvdXJjZUtleVR5cGUgPSBzb3VyY2VLZXkudHlwZTtcbiAgICBjb25zdCBzb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlS2V5RmllbGQ7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV07XG4gICAgY29uc3QgdGFyZ2V0S2V5VHlwZSA9IHRhcmdldEtleS50eXBlO1xuICAgIGNvbnN0IHRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXRLZXlGaWVsZDtcbiAgICBjb25zdCBzb3VyY2VBdHRyaWJ1dGUgPSB7IHR5cGU6IHNvdXJjZUtleVR5cGUsIC4uLnRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSB9O1xuICAgIGNvbnN0IHRhcmdldEF0dHJpYnV0ZSA9IHsgdHlwZTogdGFyZ2V0S2V5VHlwZSwgLi4udGhpcy5vdGhlcktleUF0dHJpYnV0ZSB9O1xuXG4gICAgaWYgKHRoaXMucHJpbWFyeUtleURlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gc291cmNlQXR0cmlidXRlLnByaW1hcnlLZXkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aHJvdWdoLnVuaXF1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGxldCB1bmlxdWVLZXk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51bmlxdWVLZXkgPT09ICdzdHJpbmcnICYmIHRoaXMub3B0aW9ucy51bmlxdWVLZXkgIT09ICcnKSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IHRoaXMub3B0aW9ucy51bmlxdWVLZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVLZXkgPSBbdGhpcy50aHJvdWdoLm1vZGVsLnRhYmxlTmFtZSwgdGhpcy5mb3JlaWduS2V5LCB0aGlzLm90aGVyS2V5LCAndW5pcXVlJ10uam9pbignXycpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0QXR0cmlidXRlLnVuaXF1ZSA9IHNvdXJjZUF0dHJpYnV0ZS51bmlxdWUgPSB1bmlxdWVLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldKSB7XG4gICAgICB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSA9IHtcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogdGhpcy5zb3VyY2UuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleTogc291cmNlS2V5RmllbGRcbiAgICAgIH07XG4gICAgICAvLyBGb3IgdGhlIHNvdXJjZSBhdHRyaWJ1dGUgdGhlIHBhc3NlZCBvcHRpb24gaXMgdGhlIHByaW9yaXR5XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5vbkRlbGV0ZTtcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLm9uVXBkYXRlO1xuXG4gICAgICBpZiAoIXNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSkgc291cmNlQXR0cmlidXRlLm9uRGVsZXRlID0gJ0NBU0NBREUnO1xuICAgICAgaWYgKCFzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUpIHNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSA9ICdDQVNDQURFJztcblxuICAgICAgdGFyZ2V0QXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLnRhcmdldC5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiB0YXJnZXRLZXlGaWVsZFxuICAgICAgfTtcbiAgICAgIC8vIEJ1dCB0aGUgZm9yIHRhcmdldCBhdHRyaWJ1dGUgdGhlIHByZXZpb3VzbHkgZGVmaW5lZCBvcHRpb24gaXMgdGhlIHByaW9yaXR5IChzaW5jZSBpdCBjb3VsZCd2ZSBiZWVuIHNldCBieSBhbm90aGVyIGJlbG9uZ3NUb01hbnkgY2FsbClcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLm9uRGVsZXRlIHx8IHRoaXMub3B0aW9ucy5vbkRlbGV0ZTtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLm9uVXBkYXRlIHx8IHRoaXMub3B0aW9ucy5vblVwZGF0ZTtcblxuICAgICAgaWYgKCF0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUpIHRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSA9ICdDQVNDQURFJztcbiAgICAgIGlmICghdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlKSB0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUgPSAnQ0FTQ0FERSc7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCBzb3VyY2VBdHRyaWJ1dGUpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0sIHRhcmdldEF0dHJpYnV0ZSk7XG5cbiAgICB0aGlzLnRocm91Z2gubW9kZWwucmVmcmVzaEF0dHJpYnV0ZXMoKTtcblxuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduSWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0uZmllbGQgfHwgdGhpcy5vdGhlcktleTtcblxuICAgIGlmICh0aGlzLnBhaXJlZCAmJiAhdGhpcy5wYWlyZWQuZm9yZWlnbklkZW50aWZpZXJGaWVsZCkge1xuICAgICAgdGhpcy5wYWlyZWQuZm9yZWlnbklkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XS5maWVsZCB8fCB0aGlzLnBhaXJlZC5vdGhlcktleTtcbiAgICB9XG5cbiAgICB0aGlzLnRvU291cmNlID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnRocm91Z2gubW9kZWwsIHRoaXMuc291cmNlLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXlcbiAgICB9KTtcbiAgICB0aGlzLm1hbnlGcm9tU291cmNlID0gbmV3IEhhc01hbnkodGhpcy5zb3VyY2UsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5XG4gICAgfSk7XG4gICAgdGhpcy5vbmVGcm9tU291cmNlID0gbmV3IEhhc09uZSh0aGlzLnNvdXJjZSwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXksXG4gICAgICBzb3VyY2VLZXk6IHRoaXMuc291cmNlS2V5LFxuICAgICAgYXM6IHRoaXMudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgfSk7XG5cbiAgICB0aGlzLnRvVGFyZ2V0ID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnRocm91Z2gubW9kZWwsIHRoaXMudGFyZ2V0LCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5XG4gICAgfSk7XG4gICAgdGhpcy5tYW55RnJvbVRhcmdldCA9IG5ldyBIYXNNYW55KHRoaXMudGFyZ2V0LCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXlcbiAgICB9KTtcbiAgICB0aGlzLm9uZUZyb21UYXJnZXQgPSBuZXcgSGFzT25lKHRoaXMudGFyZ2V0LCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXksXG4gICAgICBzb3VyY2VLZXk6IHRoaXMudGFyZ2V0S2V5LFxuICAgICAgYXM6IHRoaXMudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wYWlyZWQgJiYgdGhpcy5wYWlyZWQub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICB0aGlzLnBhaXJlZC50b1RhcmdldCA9IG5ldyBCZWxvbmdzVG8odGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbCwgdGhpcy5wYWlyZWQudGFyZ2V0LCB7XG4gICAgICAgIGZvcmVpZ25LZXk6IHRoaXMucGFpcmVkLm90aGVyS2V5XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wYWlyZWQub25lRnJvbVRhcmdldCA9IG5ldyBIYXNPbmUodGhpcy5wYWlyZWQudGFyZ2V0LCB0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLCB7XG4gICAgICAgIGZvcmVpZ25LZXk6IHRoaXMucGFpcmVkLm90aGVyS2V5LFxuICAgICAgICBzb3VyY2VLZXk6IHRoaXMucGFpcmVkLnRhcmdldEtleSxcbiAgICAgICAgYXM6IHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwubmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ2NvdW50JywgJ2hhc1NpbmdsZScsICdoYXNBbGwnLCAnc2V0JywgJ2FkZCcsICdhZGRNdWx0aXBsZScsICdyZW1vdmUnLCAncmVtb3ZlTXVsdGlwbGUnLCAnY3JlYXRlJ107XG4gICAgY29uc3QgYWxpYXNlcyA9IHtcbiAgICAgIGhhc1NpbmdsZTogJ2hhcycsXG4gICAgICBoYXNBbGw6ICdoYXMnLFxuICAgICAgYWRkTXVsdGlwbGU6ICdhZGQnLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6ICdyZW1vdmUnXG4gICAgfTtcblxuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcywgYWxpYXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV2ZXJ5dGhpbmcgY3VycmVudGx5IGFzc29jaWF0ZWQgd2l0aCB0aGlzLCB1c2luZyBhbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsfSBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gaW5zdGFuY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndoZXJlXSBBbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UgdG8gbGltaXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1hXSBBcHBseSBhIHNjaGVtYSBvbiB0aGUgcmVsYXRlZCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGhyb3VnaC53aGVyZV0gQW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlIGFwcGxpZWQgdG8gdGhyb3VnaCBtb2RlbCAoam9pbiB0YWJsZSlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvdWdoLnBhcmFub2lkPXRydWVdIElmIHRydWUsIG9ubHkgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlIGpvaW4gdGFibGUuIElmIGZhbHNlLCBib3RoIGRlbGV0ZWQgYW5kIG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSByZXR1cm5lZC4gT25seSBhcHBsaWVzIGlmIHRocm91Z2ggbW9kZWwgaXMgcGFyYW5vaWRcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TW9kZWw+Pn1cbiAgICovXG4gIGFzeW5jIGdldChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG5cbiAgICBjb25zdCB0aHJvdWdoID0gdGhpcy50aHJvdWdoO1xuICAgIGxldCBzY29wZVdoZXJlO1xuICAgIGxldCB0aHJvdWdoV2hlcmU7XG5cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgc2NvcGVXaGVyZSA9IHsgLi4udGhpcy5zY29wZSB9O1xuICAgIH1cblxuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICBzY29wZVdoZXJlLFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcblxuICAgIGlmIChPYmplY3QodGhyb3VnaC5tb2RlbCkgPT09IHRocm91Z2gubW9kZWwpIHtcbiAgICAgIHRocm91Z2hXaGVyZSA9IHt9O1xuICAgICAgdGhyb3VnaFdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuXG4gICAgICBpZiAodGhyb3VnaC5zY29wZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRocm91Z2hXaGVyZSwgdGhyb3VnaC5zY29wZSk7XG4gICAgICB9XG5cbiAgICAgIC8vSWYgYSB1c2VyIHBhc3MgYSB3aGVyZSBvbiB0aGUgb3B0aW9ucyB0aHJvdWdoIG9wdGlvbnMsIG1ha2UgYW4gXCJhbmRcIiB3aXRoIHRoZSBjdXJyZW50IHRocm91Z2hXaGVyZVxuICAgICAgaWYgKG9wdGlvbnMudGhyb3VnaCAmJiBvcHRpb25zLnRocm91Z2gud2hlcmUpIHtcbiAgICAgICAgdGhyb3VnaFdoZXJlID0ge1xuICAgICAgICAgIFtPcC5hbmRdOiBbdGhyb3VnaFdoZXJlLCBvcHRpb25zLnRocm91Z2gud2hlcmVdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZSB8fCBbXTtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZS5wdXNoKHtcbiAgICAgICAgYXNzb2NpYXRpb246IHRoaXMub25lRnJvbVRhcmdldCxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5qb2luVGFibGVBdHRyaWJ1dGVzLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgcGFyYW5vaWQ6IF8uZ2V0KG9wdGlvbnMudGhyb3VnaCwgJ3BhcmFub2lkJywgdHJ1ZSksXG4gICAgICAgIHdoZXJlOiB0aHJvdWdoV2hlcmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBtb2RlbCA9IHRoaXMudGFyZ2V0O1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3Njb3BlJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBtb2RlbCA9IG1vZGVsLnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbCA9IG1vZGVsLnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NjaGVtYScpKSB7XG4gICAgICBtb2RlbCA9IG1vZGVsLnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5maW5kQWxsKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvdW50IGV2ZXJ5dGhpbmcgY3VycmVudGx5IGFzc29jaWF0ZWQgd2l0aCB0aGlzLCB1c2luZyBhbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IGluc3RhbmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53aGVyZV0gQW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlIHRvIGxpbWl0IHRoZSBhc3NvY2lhdGVkIG1vZGVsc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2VcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIGFzeW5jIGNvdW50KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VxdWVsaXplID0gdGhpcy50YXJnZXQuc2VxdWVsaXplO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbXG4gICAgICBbc2VxdWVsaXplLmZuKCdDT1VOVCcsIHNlcXVlbGl6ZS5jb2woW3RoaXMudGFyZ2V0Lm5hbWUsIHRoaXMudGFyZ2V0S2V5RmllbGRdLmpvaW4oJy4nKSkpLCAnY291bnQnXVxuICAgIF07XG4gICAgb3B0aW9ucy5qb2luVGFibGVBdHRyaWJ1dGVzID0gW107XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoaW5zdGFuY2UsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5jb3VudCwgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvciBtb3JlIGluc3RhbmNlKHMpIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhpcy4gSWYgYSBsaXN0IG9mIGluc3RhbmNlcyBpcyBwYXNzZWQsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgaWYgX2FsbF8gaW5zdGFuY2VzIGFyZSBhc3NvY2lhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZSB0byBjaGVjayBmb3IgYW4gYXNzb2NpYXRpb24gd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW2luc3RhbmNlc10gQ2FuIGJlIGFuIGFycmF5IG9mIGluc3RhbmNlcyBvciB0aGVpciBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBnZXRBc3NvY2lhdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMoc291cmNlSW5zdGFuY2UsIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNjb3BlOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt0aGlzLnRhcmdldEtleV0sXG4gICAgICBqb2luVGFibGVBdHRyaWJ1dGVzOiBbXVxuICAgIH07XG5cbiAgICBjb25zdCBpbnN0YW5jZVByaW1hcnlLZXlzID0gaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uud2hlcmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFt0aGlzLnRhcmdldEtleV06IGluc3RhbmNlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHsgW09wLm9yXTogaW5zdGFuY2VQcmltYXJ5S2V5cyB9LFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcblxuICAgIGNvbnN0IGFzc29jaWF0ZWRPYmplY3RzID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZVdpdGgoaW5zdGFuY2VQcmltYXJ5S2V5cywgYXNzb2NpYXRlZE9iamVjdHMsXG4gICAgICAoYSwgYikgPT4gXy5pc0VxdWFsKGFbdGhpcy50YXJnZXRLZXldLCBiW3RoaXMudGFyZ2V0S2V5XSkpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgaW5zdGFuY2VzIG9yIHRoZWlyIHByaW1hcnkga2V5cy5cbiAgICogRXZlcnl0aGluZyB0aGF0IGl0IG5vdCBpbiB0aGUgcGFzc2VkIGFycmF5IHdpbGwgYmUgdW4tYXNzb2NpYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlIHRvIGFzc29jaWF0ZSBuZXcgaW5zdGFuY2VzIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFtuZXdBc3NvY2lhdGVkT2JqZWN0c10gQSBzaW5nbGUgaW5zdGFuY2Ugb3IgcHJpbWFyeSBrZXksIG9yIGEgbWl4ZWQgYXJyYXkgb2YgcGVyc2lzdGVkIGluc3RhbmNlcyBvciBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGhyb3VnaC5maW5kQWxsYCwgYGJ1bGtDcmVhdGVgLCBgdXBkYXRlYCBhbmQgYGRlc3Ryb3lgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy52YWxpZGF0ZV0gUnVuIHZhbGlkYXRpb24gZm9yIHRoZSBqb2luIG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50aHJvdWdoXSBBZGRpdGlvbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBqb2luIHRhYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgbmV3QXNzb2NpYXRlZE9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHNvdXJjZUtleSA9IHRoaXMuc291cmNlS2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudGFyZ2V0S2V5O1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmlkZW50aWZpZXI7XG4gICAgY29uc3QgZm9yZWlnbklkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25JZGVudGlmaWVyO1xuXG4gICAgaWYgKG5ld0Fzc29jaWF0ZWRPYmplY3RzID09PSBudWxsKSB7XG4gICAgICBuZXdBc3NvY2lhdGVkT2JqZWN0cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBc3NvY2lhdGVkT2JqZWN0cyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KG5ld0Fzc29jaWF0ZWRPYmplY3RzKTtcbiAgICB9XG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgLi4udGhpcy50aHJvdWdoLnNjb3BlXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZUFzc29jaWF0aW9ucyA9IGN1cnJlbnRSb3dzID0+IHtcbiAgICAgIGNvbnN0IG9ic29sZXRlQXNzb2NpYXRpb25zID0gW107XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSBvcHRpb25zLnRocm91Z2ggfHwge307XG5cbiAgICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSBuZXdBc3NvY2lhdGVkT2JqZWN0cy5maWx0ZXIob2JqID0+XG4gICAgICAgICFjdXJyZW50Um93cy5zb21lKGN1cnJlbnRSb3cgPT4gY3VycmVudFJvd1tmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSlcbiAgICAgICk7XG5cbiAgICAgIGZvciAoY29uc3QgY3VycmVudFJvdyBvZiBjdXJyZW50Um93cykge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBuZXdBc3NvY2lhdGVkT2JqZWN0cy5maW5kKG9iaiA9PiBjdXJyZW50Um93W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKTtcblxuICAgICAgICBpZiAoIW5ld09iaikge1xuICAgICAgICAgIG9ic29sZXRlQXNzb2NpYXRpb25zLnB1c2goY3VycmVudFJvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHRocm91Z2hBdHRyaWJ1dGVzID0gbmV3T2JqW3RoaXMudGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICAvLyBRdWljay1maXggZm9yIHN1YnRsZSBidWcgd2hlbiB1c2luZyBleGlzdGluZyBvYmplY3RzIHRoYXQgbWlnaHQgaGF2ZSB0aGUgdGhyb3VnaCBtb2RlbCBhdHRhY2hlZCAobm90IGFzIGFuIGF0dHJpYnV0ZSBvYmplY3QpXG4gICAgICAgICAgaWYgKHRocm91Z2hBdHRyaWJ1dGVzIGluc3RhbmNlb2YgdGhpcy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdWdoQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLCAuLi50aHJvdWdoQXR0cmlidXRlcyB9O1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLnVwZGF0ZShhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG5ld09iai5nZXQodGFyZ2V0S2V5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9ic29sZXRlQXNzb2NpYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwuZGVzdHJveSh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogb2Jzb2xldGVBc3NvY2lhdGlvbnMubWFwKG9ic29sZXRlQXNzb2NpYXRpb24gPT4gb2Jzb2xldGVBc3NvY2lhdGlvbltmb3JlaWduSWRlbnRpZmllcl0pLFxuICAgICAgICAgICAgICAuLi50aGlzLnRocm91Z2guc2NvcGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGJ1bGsgPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCh1bmFzc29jaWF0ZWRPYmplY3QgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIC4uLnVuYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRocm91Z2gubW9kZWwubmFtZV0sXG4gICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0YXJnZXRLZXkpLFxuICAgICAgICAgICAgLi4udGhpcy50aHJvdWdoLnNjb3BlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRocm91Z2gubW9kZWwuYnVsa0NyZWF0ZShidWxrLCB7IHZhbGlkYXRlOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3dzID0gYXdhaXQgdGhpcy50aHJvdWdoLm1vZGVsLmZpbmRBbGwoeyAuLi5vcHRpb25zLCB3aGVyZSwgcmF3OiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUFzc29jaWF0aW9ucyhjdXJyZW50Um93cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVtcHR5UmVzdWx0RXJyb3IpIHJldHVybiB1cGRhdGVBc3NvY2lhdGlvbnMoW10pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZSBvbmUgb3Igc2V2ZXJhbCByb3dzIHdpdGggc291cmNlIGluc3RhbmNlLiBJdCB3aWxsIG5vdCB1bi1hc3NvY2lhdGUgYW55IGFscmVhZHkgYXNzb2NpYXRlZCBpbnN0YW5jZVxuICAgKiB0aGF0IG1heSBiZSBtaXNzaW5nIGZyb20gYG5ld0luc3RhbmNlc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZSB0byBhc3NvY2lhdGUgbmV3IGluc3RhbmNlcyB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbbmV3SW5zdGFuY2VzXSBBIHNpbmdsZSBpbnN0YW5jZSBvciBwcmltYXJ5IGtleSwgb3IgYSBtaXhlZCBhcnJheSBvZiBwZXJzaXN0ZWQgaW5zdGFuY2VzIG9yIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0aHJvdWdoLmZpbmRBbGxgLCBgYnVsa0NyZWF0ZWAgYW5kIGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy52YWxpZGF0ZV0gUnVuIHZhbGlkYXRpb24gZm9yIHRoZSBqb2luIG1vZGVsLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGhyb3VnaF0gQWRkaXRpb25hbCBhdHRyaWJ1dGVzIGZvciB0aGUgam9pbiB0YWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhZGQoc291cmNlSW5zdGFuY2UsIG5ld0luc3RhbmNlcywgb3B0aW9ucykge1xuICAgIC8vIElmIG5ld0luc3RhbmNlcyBpcyBudWxsIG9yIHVuZGVmaW5lZCwgbm8tb3BcbiAgICBpZiAoIW5ld0luc3RhbmNlcykgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleTtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBhc3NvY2lhdGlvbi50YXJnZXRLZXk7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGFzc29jaWF0aW9uLmlkZW50aWZpZXI7XG4gICAgY29uc3QgZm9yZWlnbklkZW50aWZpZXIgPSBhc3NvY2lhdGlvbi5mb3JlaWduSWRlbnRpZmllcjtcbiAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlcyA9IG9wdGlvbnMudGhyb3VnaCB8fCB7fTtcblxuICAgIG5ld0luc3RhbmNlcyA9IGFzc29jaWF0aW9uLnRvSW5zdGFuY2VBcnJheShuZXdJbnN0YW5jZXMpO1xuXG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogbmV3SW5zdGFuY2VzLm1hcChuZXdJbnN0YW5jZSA9PiBuZXdJbnN0YW5jZS5nZXQodGFyZ2V0S2V5KSksXG4gICAgICAuLi5hc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZUFzc29jaWF0aW9ucyA9IGN1cnJlbnRSb3dzID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gW107XG4gICAgICBjb25zdCBjaGFuZ2VkQXNzb2NpYXRpb25zID0gW107XG4gICAgICBmb3IgKGNvbnN0IG9iaiBvZiBuZXdJbnN0YW5jZXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBc3NvY2lhdGlvbiA9IGN1cnJlbnRSb3dzICYmIGN1cnJlbnRSb3dzLmZpbmQoY3VycmVudCA9PiBjdXJyZW50W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKTtcblxuICAgICAgICBpZiAoIWV4aXN0aW5nQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICB1bmFzc29jaWF0ZWRPYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IG9ialthc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLCAuLi50aHJvdWdoQXR0cmlidXRlcyB9O1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvbWUoYXR0cmlidXRlID0+IGF0dHJpYnV0ZXNbYXR0cmlidXRlXSAhPT0gZXhpc3RpbmdBc3NvY2lhdGlvblthdHRyaWJ1dGVdKSkge1xuICAgICAgICAgICAgY2hhbmdlZEFzc29jaWF0aW9ucy5wdXNoKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYnVsayA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKHVuYXNzb2NpYXRlZE9iamVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgdGhyb3VnaEF0dHJpYnV0ZXMgPSB1bmFzc29jaWF0ZWRPYmplY3RbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udGhyb3VnaEF0dHJpYnV0ZXMgfTtcblxuICAgICAgICAgIGF0dHJpYnV0ZXNbaWRlbnRpZmllcl0gPSBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KTtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2ZvcmVpZ25JZGVudGlmaWVyXSA9IHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGFyZ2V0S2V5KTtcblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZSk7XG5cbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaChhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmJ1bGtDcmVhdGUoYnVsaywgeyB2YWxpZGF0ZTogdHJ1ZSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgYXNzb2Mgb2YgY2hhbmdlZEFzc29jaWF0aW9ucykge1xuICAgICAgICBsZXQgdGhyb3VnaEF0dHJpYnV0ZXMgPSBhc3NvY1thc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0geyAuLi5kZWZhdWx0QXR0cmlidXRlcywgLi4udGhyb3VnaEF0dHJpYnV0ZXMgfTtcbiAgICAgICAgLy8gUXVpY2stZml4IGZvciBzdWJ0bGUgYnVnIHdoZW4gdXNpbmcgZXhpc3Rpbmcgb2JqZWN0cyB0aGF0IG1pZ2h0IGhhdmUgdGhlIHRocm91Z2ggbW9kZWwgYXR0YWNoZWQgKG5vdCBhcyBhbiBhdHRyaWJ1dGUgb2JqZWN0KVxuICAgICAgICBpZiAodGhyb3VnaEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgICAgdGhyb3VnaEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2VzLnB1c2goYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC51cGRhdGUoYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHdoZXJlOiB7XG4gICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBhc3NvYy5nZXQodGFyZ2V0S2V5KVxuICAgICAgICB9IH0pKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93cyA9IGF3YWl0IGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuZmluZEFsbCh7IC4uLm9wdGlvbnMsIHdoZXJlLCByYXc6IHRydWUgfSk7XG4gICAgICBjb25zdCBbYXNzb2NpYXRpb25zXSA9IGF3YWl0IHVwZGF0ZUFzc29jaWF0aW9ucyhjdXJyZW50Um93cyk7XG4gICAgICByZXR1cm4gYXNzb2NpYXRpb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFbXB0eVJlc3VsdEVycm9yKSByZXR1cm4gdXBkYXRlQXNzb2NpYXRpb25zKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW4tYXNzb2NpYXRlIG9uZSBvciBtb3JlIGluc3RhbmNlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBpbnN0YW5jZSB0byB1biBhc3NvY2lhdGUgaW5zdGFuY2VzIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW119IFtvbGRBc3NvY2lhdGVkT2JqZWN0c10gQ2FuIGJlIGFuIEluc3RhbmNlIG9yIGl0cyBwcmltYXJ5IGtleSwgb3IgYSBtaXhlZCBhcnJheSBvZiBpbnN0YW5jZXMgYW5kIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0aHJvdWdoLmRlc3Ryb3lgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgcmVtb3ZlKHNvdXJjZUluc3RhbmNlLCBvbGRBc3NvY2lhdGVkT2JqZWN0cywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb2xkQXNzb2NpYXRlZE9iamVjdHMgPSBhc3NvY2lhdGlvbi50b0luc3RhbmNlQXJyYXkob2xkQXNzb2NpYXRlZE9iamVjdHMpO1xuXG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbYXNzb2NpYXRpb24uaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChhc3NvY2lhdGlvbi5zb3VyY2VLZXkpLFxuICAgICAgW2Fzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyXTogb2xkQXNzb2NpYXRlZE9iamVjdHMubWFwKG5ld0luc3RhbmNlID0+IG5ld0luc3RhbmNlLmdldChhc3NvY2lhdGlvbi50YXJnZXRLZXkpKVxuICAgIH07XG5cbiAgICByZXR1cm4gYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5kZXN0cm95KHsgLi4ub3B0aW9ucywgd2hlcmUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBhc3NvY2lhdGVkIG1vZGVsIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdIHZhbHVlcyBmb3IgdGFyZ2V0IG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gY3JlYXRlIGFuZCBhZGRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRocm91Z2hdIEFkZGl0aW9uYWwgYXR0cmlidXRlcyBmb3IgdGhlIGpvaW4gdGFibGVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBmaWVsZHM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGFzc29jaWF0aW9uLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gb3B0aW9ucy5maWVsZHMuY29uY2F0KE9iamVjdC5rZXlzKGFzc29jaWF0aW9uLnNjb3BlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSByZWxhdGVkIG1vZGVsIGluc3RhbmNlXG4gICAgY29uc3QgbmV3QXNzb2NpYXRlZE9iamVjdCA9IGF3YWl0IGFzc29jaWF0aW9uLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcblxuICAgIGF3YWl0IHNvdXJjZUluc3RhbmNlW2Fzc29jaWF0aW9uLmFjY2Vzc29ycy5hZGRdKG5ld0Fzc29jaWF0ZWRPYmplY3QsIF8ub21pdChvcHRpb25zLCBbJ2ZpZWxkcyddKSk7XG4gICAgcmV0dXJuIG5ld0Fzc29jaWF0ZWRPYmplY3Q7XG4gIH1cblxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMucGx1cmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMucGx1cmFsO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCZWxvbmdzVG9NYW55O1xubW9kdWxlLmV4cG9ydHMuQmVsb25nc1RvTWFueSA9IEJlbG9uZ3NUb01hbnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQmVsb25nc1RvTWFueTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuLyoqXG4gKiBPbmUtdG8tb25lIGFzc29jaWF0aW9uXG4gKlxuICogSW4gdGhlIEFQSSByZWZlcmVuY2UgYmVsb3csIGFkZCB0aGUgbmFtZSBvZiB0aGUgYXNzb2NpYXRpb24gdG8gdGhlIG1ldGhvZCwgZS5nLiBmb3IgYFVzZXIuYmVsb25nc1RvKFByb2plY3QpYCB0aGUgZ2V0dGVyIHdpbGwgYmUgYHVzZXIuZ2V0UHJvamVjdCgpYC5cbiAqXG4gKiBAc2VlIHtAbGluayBNb2RlbC5iZWxvbmdzVG99XG4gKi9cbmNsYXNzIEJlbG9uZ3NUbyBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9ICdCZWxvbmdzVG8nO1xuICAgIHRoaXMuaXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG5cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgIHNpbmd1bGFyOiB0aGlzLmFzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFxuICAgICAgICBbXG4gICAgICAgICAgdGhpcy5hcyxcbiAgICAgICAgICB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgIF0uam9pbignXycpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuaWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbktleTtcbiAgICBpZiAodGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmlkZW50aWZpZXJdKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5pZGVudGlmaWVyXS5maWVsZCB8fCB0aGlzLmlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnRhcmdldEtleVxuICAgICAgJiYgIXRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5vcHRpb25zLnRhcmdldEtleV1cbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgXCIke3RoaXMub3B0aW9ucy50YXJnZXRLZXl9XCIgcGFzc2VkIGFzIHRhcmdldEtleSwgZGVmaW5lIHRoaXMgYXR0cmlidXRlIG9uIG1vZGVsIFwiJHt0aGlzLnRhcmdldC5uYW1lfVwiIGZpcnN0YCk7XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLm9wdGlvbnMudGFyZ2V0S2V5IHx8IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIHRoaXMudGFyZ2V0S2V5SXNQcmltYXJ5ID0gdGhpcy50YXJnZXRLZXkgPT09IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy50YXJnZXRJZGVudGlmaWVyID0gdGhpcy50YXJnZXRLZXk7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMub3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMudXNlSG9va3M7XG5cbiAgICAvLyBHZXQgc2luZ3VsYXIgbmFtZSwgdHJ5aW5nIHRvIHVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyLCB1bmxlc3MgdGhlIG1vZGVsIGZvcmJpZHMgaXRcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7c2luZ3VsYXJ9YCxcbiAgICAgIHNldDogYHNldCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YFxuICAgIH07XG4gIH1cblxuICAvLyB0aGUgaWQgaXMgaW4gdGhlIHNvdXJjZSB0YWJsZVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlLFxuICAgICAgICAuLi50aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICB0aGlzLm9wdGlvbnMub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgKHNvdXJjZS5hbGxvd051bGwgPyAnU0VUIE5VTEwnIDogJ05PIEFDVElPTicpO1xuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8ICdDQVNDQURFJztcbiAgICB9XG5cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMudGFyZ2V0LCB0aGlzLnNvdXJjZSwgdGhpcy5vcHRpb25zLCB0aGlzLnRhcmdldEtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5zb3VyY2UucmVmcmVzaEF0dHJpYnV0ZXMoKTtcblxuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcblxuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdzZXQnLCAnY3JlYXRlJ107XG5cbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbHxBcnJheTxNb2RlbD59IGluc3RhbmNlcyBzb3VyY2UgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdICBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgW29wdGlvbnMuc2NoZW1hXSBBcHBseSBhIHNjaGVtYSBvbiB0aGUgcmVsYXRlZCBtb2RlbFxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kT25lfSBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgbGV0IFRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY29wZScpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NoZW1hJykpIHtcbiAgICAgIFRhcmdldCA9IFRhcmdldC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgd2hlcmVbdGhpcy50YXJnZXRLZXldID0ge1xuICAgICAgICBbT3AuaW5dOiBpbnN0YW5jZXMubWFwKF9pbnN0YW5jZSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy50YXJnZXRLZXlJc1ByaW1hcnkgJiYgIW9wdGlvbnMud2hlcmUpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldC5maW5kQnlQayhpbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB3aGVyZVt0aGlzLnRhcmdldEtleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KTtcbiAgICAgIG9wdGlvbnMubGltaXQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID9cbiAgICAgIHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6XG4gICAgICB3aGVyZTtcblxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBUYXJnZXQuZmluZEFsbChvcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnRhcmdldEtleSwgeyByYXc6IHRydWUgfSldID0gX2luc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBUYXJnZXQuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFzc29jaWF0ZWQgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/PE1vZGVsPnxzdHJpbmd8bnVtYmVyfSBbYXNzb2NpYXRlZEluc3RhbmNlXSBBbiBwZXJzaXN0ZWQgaW5zdGFuY2Ugb3IgdGhlIHByaW1hcnkga2V5IG9mIGFuIGluc3RhbmNlIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMuIFBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgIHRvIHJlbW92ZSB0aGUgYXNzb2NpYXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBwYXNzZWQgdG8gYHRoaXMuc2F2ZWBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zYXZlPXRydWVdIFNraXAgc2F2aW5nIHRoaXMgYWZ0ZXIgc2V0dGluZyB0aGUgZm9yZWlnbiBrZXkgaWYgZmFsc2UuXG4gICAqXG4gICAqICBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgYXNzb2NpYXRlZEluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdmFsdWUgPSBhc3NvY2lhdGVkSW5zdGFuY2U7XG5cbiAgICBpZiAoYXNzb2NpYXRlZEluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgIHZhbHVlID0gYXNzb2NpYXRlZEluc3RhbmNlW3RoaXMudGFyZ2V0S2V5XTtcbiAgICB9XG5cbiAgICBzb3VyY2VJbnN0YW5jZS5zZXQodGhpcy5mb3JlaWduS2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5zYXZlID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGZpZWxkczogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICBhbGxvd051bGw6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgYXNzb2NpYXRpb246IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIC8vIHBhc3NlcyB0aGUgY2hhbmdlZCBmaWVsZCB0byBzYXZlLCBzbyBvbmx5IHRoYXQgZmllbGQgZ2V0IHVwZGF0ZWQuXG4gICAgcmV0dXJuIGF3YWl0IHNvdXJjZUluc3RhbmNlLnNhdmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBhc3NvY2lhdGVkIG1vZGVsIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzPXt9XSB2YWx1ZXMgdG8gY3JlYXRlIGFzc29jaWF0ZWQgbW9kZWwgaW5zdGFuY2Ugd2l0aFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQuY3JlYXRlYCBhbmQgc2V0QXNzb2NpYXRpb24uXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI2NyZWF0ZX0gIGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59IFRoZSBjcmVhdGVkIHRhcmdldCBtb2RlbFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBuZXdBc3NvY2lhdGVkT2JqZWN0ID0gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgYXdhaXQgc291cmNlSW5zdGFuY2VbdGhpcy5hY2Nlc3NvcnMuc2V0XShuZXdBc3NvY2lhdGVkT2JqZWN0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBuZXdBc3NvY2lhdGVkT2JqZWN0O1xuICB9XG5cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnNpbmd1bGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMuc2luZ3VsYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJlbG9uZ3NUbztcbm1vZHVsZS5leHBvcnRzLkJlbG9uZ3NUbyA9IEJlbG9uZ3NUbztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBCZWxvbmdzVG87XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbi8qKlxuICogT25lLXRvLW1hbnkgYXNzb2NpYXRpb25cbiAqXG4gKiBJbiB0aGUgQVBJIHJlZmVyZW5jZSBiZWxvdywgYWRkIHRoZSBuYW1lIG9mIHRoZSBhc3NvY2lhdGlvbiB0byB0aGUgbWV0aG9kLCBlLmcuIGZvciBgVXNlci5oYXNNYW55KFByb2plY3QpYCB0aGUgZ2V0dGVyIHdpbGwgYmUgYHVzZXIuZ2V0UHJvamVjdHMoKWAuXG4gKiBJZiB0aGUgYXNzb2NpYXRpb24gaXMgYWxpYXNlZCwgdXNlIHRoZSBhbGlhcyBpbnN0ZWFkLCBlLmcuIGBVc2VyLmhhc01hbnkoUHJvamVjdCwgeyBhczogJ2pvYnMnIH0pYCB3aWxsIGJlIGB1c2VyLmdldEpvYnMoKWAuXG4gKlxuICogQHNlZSB7QGxpbmsgTW9kZWwuaGFzTWFueX1cbiAqL1xuY2xhc3MgSGFzTWFueSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9ICdIYXNNYW55JztcbiAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNvdXJjZS5zZXF1ZWxpemU7XG4gICAgdGhpcy5pc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ046TSBhc3NvY2lhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBoYXNNYW55LiBVc2UgYmVsb25nc1RvTWFueSBpbnN0ZWFkJyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIElmIHNlbGYgYXNzb2NpYXRpb24sIHRoaXMgaXMgdGhlIHRhcmdldCBhc3NvY2lhdGlvblxuICAgICovXG4gICAgaWYgKHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG5cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5hcykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLmFzO1xuICAgICAgICB0aGlzLmFzID0gdGhpcy5hcy5wbHVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgICBwbHVyYWw6IHRoaXMuYXMsXG4gICAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUucGx1cmFsO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBGb3JlaWduIGtleSBzZXR1cFxuICAgICAqL1xuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMuc291cmNlLm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgICB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgIF0uam9pbignXycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFNvdXJjZSBrZXkgc2V0dXBcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcblxuICAgIGlmICh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XSkge1xuICAgICAgdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLnNvdXJjZUtleTtcbiAgICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnByaW1hcnlLZXlGaWVsZDtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2luZ3VsYXIgYW5kIHBsdXJhbCBuYW1lc1xuICAgIC8vIHRyeSB0byB1cHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciwgdW5sZXNzIHRoZSBtb2RlbCBmb3JiaWRzIGl0XG4gICAgY29uc3QgcGx1cmFsID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnBsdXJhbCk7XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7cGx1cmFsfWAsXG4gICAgICBzZXQ6IGBzZXQke3BsdXJhbH1gLFxuICAgICAgYWRkTXVsdGlwbGU6IGBhZGQke3BsdXJhbH1gLFxuICAgICAgYWRkOiBgYWRkJHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlOiBgcmVtb3ZlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IGByZW1vdmUke3BsdXJhbH1gLFxuICAgICAgaGFzU2luZ2xlOiBgaGFzJHtzaW5ndWxhcn1gLFxuICAgICAgaGFzQWxsOiBgaGFzJHtwbHVyYWx9YCxcbiAgICAgIGNvdW50OiBgY291bnQke3BsdXJhbH1gXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRoZSBpZCBpcyBpbiB0aGUgdGFyZ2V0IHRhYmxlXG4gIC8vIG9yIGluIGFuIGV4dHJhIHRhYmxlIHdoaWNoIGNvbm5lY3RzIHR3byB0YWJsZXNcbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiB7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGVdLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5mb3JlaWduS2V5QXR0cmlidXRlXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCBmb3IgdXNlIHdpdGggYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzLCB0byBhdm9pZCBwb2xsdXRpbmcgdGhpcy5vcHRpb25zIGluIGNhc2UgaXQgaXMgbGF0ZXIgdXNlZCBmb3IgYSBuOm1cbiAgICBjb25zdCBjb25zdHJhaW50T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIGNvbnN0cmFpbnRPcHRpb25zLm9uRGVsZXRlID0gY29uc3RyYWludE9wdGlvbnMub25EZWxldGUgfHwgKHRhcmdldC5hbGxvd051bGwgPyAnU0VUIE5VTEwnIDogJ0NBU0NBREUnKTtcbiAgICAgIGNvbnN0cmFpbnRPcHRpb25zLm9uVXBkYXRlID0gY29uc3RyYWludE9wdGlvbnMub25VcGRhdGUgfHwgJ0NBU0NBREUnO1xuICAgIH1cblxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy5zb3VyY2UsIHRoaXMudGFyZ2V0LCBjb25zdHJhaW50T3B0aW9ucywgdGhpcy5zb3VyY2VLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFyZ2V0LnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5zb3VyY2UucmVmcmVzaEF0dHJpYnV0ZXMoKTtcblxuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25LZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuXG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ2NvdW50JywgJ2hhc1NpbmdsZScsICdoYXNBbGwnLCAnc2V0JywgJ2FkZCcsICdhZGRNdWx0aXBsZScsICdyZW1vdmUnLCAncmVtb3ZlTXVsdGlwbGUnLCAnY3JlYXRlJ107XG4gICAgY29uc3QgYWxpYXNlcyA9IHtcbiAgICAgIGhhc1NpbmdsZTogJ2hhcycsXG4gICAgICBoYXNBbGw6ICdoYXMnLFxuICAgICAgYWRkTXVsdGlwbGU6ICdhZGQnLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6ICdyZW1vdmUnXG4gICAgfTtcblxuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcywgYWxpYXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV2ZXJ5dGhpbmcgY3VycmVudGx5IGFzc29jaWF0ZWQgd2l0aCB0aGlzLCB1c2luZyBhbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx8QXJyYXk8TW9kZWw+fSBpbnN0YW5jZXMgc291cmNlIGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2hlcmVdIEFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZSB0byBsaW1pdCB0aGUgYXNzb2NpYXRlZCBtb2RlbHNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWFdIEFwcGx5IGEgc2NoZW1hIG9uIHRoZSByZWxhdGVkIG1vZGVsXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9ICBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TW9kZWw+Pn1cbiAgICovXG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG5cbiAgICBsZXQgTW9kZWwgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IHZhbHVlcztcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih3aGVyZSwgdGhpcy5zY29wZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgdmFsdWVzID0gaW5zdGFuY2VzLm1hcChfaW5zdGFuY2UgPT4gX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSkpO1xuXG4gICAgICBpZiAob3B0aW9ucy5saW1pdCAmJiBpbnN0YW5jZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBvcHRpb25zLmdyb3VwZWRMaW1pdCA9IHtcbiAgICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICAgICAgICBvbjogdGhpcywgLy8gYXNzb2NpYXRpb25cbiAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBkZWxldGUgb3B0aW9ucy5saW1pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgICAgW09wLmluXTogdmFsdWVzXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmdyb3VwZWRMaW1pdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgP1xuICAgICAgeyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDpcbiAgICAgIHdoZXJlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NvcGUnKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIE1vZGVsID0gTW9kZWwudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1vZGVsID0gTW9kZWwuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NoZW1hJykpIHtcbiAgICAgIE1vZGVsID0gTW9kZWwuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IE1vZGVsLmZpbmRBbGwob3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlKSByZXR1cm4gcmVzdWx0cztcblxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pXSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldLnB1c2goX2luc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvdW50IGV2ZXJ5dGhpbmcgY3VycmVudGx5IGFzc29jaWF0ZWQgd2l0aCB0aGlzLCB1c2luZyBhbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICBpbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zXSBmaW5kICYgY291bnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICBbb3B0aW9ucy53aGVyZV0gQW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlIHRvIGxpbWl0IHRoZSBhc3NvY2lhdGVkIG1vZGVsc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2VcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIGFzeW5jIGNvdW50KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFtcbiAgICAgIFtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUuZm4oXG4gICAgICAgICAgJ0NPVU5UJyxcbiAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5jb2woYCR7dGhpcy50YXJnZXQubmFtZX0uJHt0aGlzLnRhcmdldC5wcmltYXJ5S2V5RmllbGR9YClcbiAgICAgICAgKSxcbiAgICAgICAgJ2NvdW50J1xuICAgICAgXVxuICAgIF07XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoaW5zdGFuY2UsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5jb3VudCwgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvciBtb3JlIHJvd3MgYXJlIGFzc29jaWF0ZWQgd2l0aCBgdGhpc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFt0YXJnZXRJbnN0YW5jZXNdIENhbiBiZSBhbiBhcnJheSBvZiBpbnN0YW5jZXMgb3IgdGhlaXIgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gZ2V0QXNzb2NpYXRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgaGFzKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldEluc3RhbmNlcykpIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IFt0YXJnZXRJbnN0YW5jZXNdO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2NvcGU6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlczogW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLFxuICAgICAgcmF3OiB0cnVlXG4gICAgfTtcblxuICAgIHdoZXJlW09wLm9yXSA9IHRhcmdldEluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLndoZXJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IGluc3RhbmNlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHdoZXJlLFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcblxuICAgIGNvbnN0IGFzc29jaWF0ZWRPYmplY3RzID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA9PT0gdGFyZ2V0SW5zdGFuY2VzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgcGVyc2lzdGVkIGluc3RhbmNlcyBvciB0aGVpciBwcmltYXJ5IGtleXMuIEV2ZXJ5dGhpbmcgdGhhdCBpcyBub3QgaW4gdGhlIHBhc3NlZCBhcnJheSB3aWxsIGJlIHVuLWFzc29jaWF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlIHRvIGFzc29jaWF0ZSBuZXcgaW5zdGFuY2VzIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFt0YXJnZXRJbnN0YW5jZXNdIEFuIGFycmF5IG9mIHBlcnNpc3RlZCBpbnN0YW5jZXMgb3IgcHJpbWFyeSBrZXkgb2YgaW5zdGFuY2VzIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMuIFBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgIHRvIHJlbW92ZSBhbGwgYXNzb2NpYXRpb25zLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQuZmluZEFsbGAgYW5kIGB1cGRhdGVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudmFsaWRhdGVdIFJ1biB2YWxpZGF0aW9uIGZvciB0aGUgam9pbiBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldEluc3RhbmNlcyA9PT0gbnVsbCkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQXNzb2NpYXRpb25zID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIHsgLi4ub3B0aW9ucywgc2NvcGU6IGZhbHNlLCByYXc6IHRydWUgfSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCBvYnNvbGV0ZUFzc29jaWF0aW9ucyA9IG9sZEFzc29jaWF0aW9ucy5maWx0ZXIob2xkID0+XG4gICAgICAhdGFyZ2V0SW5zdGFuY2VzLmZpbmQob2JqID0+XG4gICAgICAgIG9ialt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gb2xkW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gdGFyZ2V0SW5zdGFuY2VzLmZpbHRlcihvYmogPT5cbiAgICAgICFvbGRBc3NvY2lhdGlvbnMuZmluZChvbGQgPT5cbiAgICAgICAgb2JqW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBvbGRbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgIClcbiAgICApO1xuICAgIGxldCB1cGRhdGVXaGVyZTtcbiAgICBsZXQgdXBkYXRlO1xuXG4gICAgaWYgKG9ic29sZXRlQXNzb2NpYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHVwZGF0ZSA9IHt9O1xuICAgICAgdXBkYXRlW3RoaXMuZm9yZWlnbktleV0gPSBudWxsO1xuXG4gICAgICB1cGRhdGVXaGVyZSA9IHtcbiAgICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBvYnNvbGV0ZUFzc29jaWF0aW9ucy5tYXAoYXNzb2NpYXRlZE9iamVjdCA9PlxuICAgICAgICAgIGFzc29jaWF0ZWRPYmplY3RbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgICAgKVxuICAgICAgfTtcblxuXG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKFxuICAgICAgICB1cGRhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHdoZXJlOiB1cGRhdGVXaGVyZVxuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9XG5cbiAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1cGRhdGVXaGVyZSA9IHt9O1xuXG4gICAgICB1cGRhdGUgPSB7fTtcbiAgICAgIHVwZGF0ZVt0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcblxuICAgICAgT2JqZWN0LmFzc2lnbih1cGRhdGUsIHRoaXMuc2NvcGUpO1xuICAgICAgdXBkYXRlV2hlcmVbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCh1bmFzc29jaWF0ZWRPYmplY3QgPT5cbiAgICAgICAgdW5hc3NvY2lhdGVkT2JqZWN0W3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICApO1xuXG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKFxuICAgICAgICB1cGRhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHdoZXJlOiB1cGRhdGVXaGVyZVxuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICByZXR1cm4gc291cmNlSW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlIG9uZSBvciBtb3JlIHRhcmdldCByb3dzIHdpdGggYHRoaXNgLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGEgTW9kZWwgLyBzdHJpbmcgLyBudW1iZXIgdG8gYXNzb2NpYXRlIGEgc2luZ2xlIHJvdyxcbiAgICogb3IgYSBtaXhlZCBhcnJheSBvZiBNb2RlbCAvIHN0cmluZyAvIG51bWJlcnMgdG8gYXNzb2NpYXRlIG11bHRpcGxlIHJvd3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFt0YXJnZXRJbnN0YW5jZXNdIEEgc2luZ2xlIGluc3RhbmNlIG9yIHByaW1hcnkga2V5LCBvciBhIG1peGVkIGFycmF5IG9mIHBlcnNpc3RlZCBpbnN0YW5jZXMgb3IgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC51cGRhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZChzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRhcmdldEluc3RhbmNlcykgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG5cbiAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuXG4gICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSksXG4gICAgICAuLi50aGlzLnNjb3BlXG4gICAgfTtcblxuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiB0YXJnZXRJbnN0YW5jZXMubWFwKHVuYXNzb2NpYXRlZE9iamVjdCA9PlxuICAgICAgICB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGUpXG4gICAgICApXG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMudGFyZ2V0LnVuc2NvcGVkKCkudXBkYXRlKHVwZGF0ZSwgeyAuLi5vcHRpb25zLCB3aGVyZSB9KTtcblxuICAgIHJldHVybiBzb3VyY2VJbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbi1hc3NvY2lhdGUgb25lIG9yIHNldmVyYWwgdGFyZ2V0IHJvd3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIGluc3RhbmNlIHRvIHVuIGFzc29jaWF0ZSBpbnN0YW5jZXMgd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nfHN0cmluZ1tdfG51bWJlcnxudW1iZXJbXX0gW3RhcmdldEluc3RhbmNlc10gQ2FuIGJlIGFuIEluc3RhbmNlIG9yIGl0cyBwcmltYXJ5IGtleSwgb3IgYSBtaXhlZCBhcnJheSBvZiBpbnN0YW5jZXMgYW5kIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0YXJnZXQudXBkYXRlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbW92ZShzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogbnVsbFxuICAgIH07XG5cbiAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuXG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KSxcbiAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogdGFyZ2V0SW5zdGFuY2VzLm1hcCh0YXJnZXRJbnN0YW5jZSA9PlxuICAgICAgICB0YXJnZXRJbnN0YW5jZS5nZXQodGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZSlcbiAgICAgIClcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCB7IC4uLm9wdGlvbnMsIHdoZXJlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBhc3NvY2lhdGVkIG1vZGVsIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdIHZhbHVlcyBmb3IgdGFyZ2V0IG1vZGVsIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC5jcmVhdGVgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBmaWVsZHM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXModGhpcy5zY29wZSkpIHtcbiAgICAgICAgdmFsdWVzW2F0dHJpYnV0ZV0gPSB0aGlzLnNjb3BlW2F0dHJpYnV0ZV07XG4gICAgICAgIGlmIChvcHRpb25zLmZpZWxkcykgb3B0aW9ucy5maWVsZHMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc1t0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMpIG9wdGlvbnMuZmllbGRzLnB1c2godGhpcy5mb3JlaWduS2V5KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cblxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMucGx1cmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMucGx1cmFsO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNNYW55O1xubW9kdWxlLmV4cG9ydHMuSGFzTWFueSA9IEhhc01hbnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSGFzTWFueTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuLyoqXG4gKiBPbmUtdG8tb25lIGFzc29jaWF0aW9uXG4gKlxuICogSW4gdGhlIEFQSSByZWZlcmVuY2UgYmVsb3csIGFkZCB0aGUgbmFtZSBvZiB0aGUgYXNzb2NpYXRpb24gdG8gdGhlIG1ldGhvZCwgZS5nLiBmb3IgYFVzZXIuaGFzT25lKFByb2plY3QpYCB0aGUgZ2V0dGVyIHdpbGwgYmUgYHVzZXIuZ2V0UHJvamVjdCgpYC5cbiAqIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIGBiZWxvbmdzVG9gIHdpdGggb25lIGV4Y2VwdGlvbiAtIFRoZSBmb3JlaWduIGtleSB3aWxsIGJlIGRlZmluZWQgb24gdGhlIHRhcmdldCBtb2RlbC5cbiAqXG4gKiBAc2VlIHtAbGluayBNb2RlbC5oYXNPbmV9XG4gKi9cbmNsYXNzIEhhc09uZSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9ICdIYXNPbmUnO1xuICAgIHRoaXMuaXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG5cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgIHNpbmd1bGFyOiB0aGlzLmFzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFxuICAgICAgICBbXG4gICAgICAgICAgVXRpbHMuc2luZ3VsYXJpemUodGhpcy5vcHRpb25zLmFzIHx8IHRoaXMuc291cmNlLm5hbWUpLFxuICAgICAgICAgIHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgXS5qb2luKCdfJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnNvdXJjZUtleVxuICAgICAgJiYgIXRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5vcHRpb25zLnNvdXJjZUtleV1cbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgXCIke3RoaXMub3B0aW9ucy5zb3VyY2VLZXl9XCIgcGFzc2VkIGFzIHNvdXJjZUtleSwgZGVmaW5lIHRoaXMgYXR0cmlidXRlIG9uIG1vZGVsIFwiJHt0aGlzLnNvdXJjZS5uYW1lfVwiIGZpcnN0YCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgdGhpcy5zb3VyY2VLZXlJc1ByaW1hcnkgPSB0aGlzLnNvdXJjZUtleSA9PT0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5vcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy51c2VIb29rcztcblxuICAgIGlmICh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2luZ3VsYXIgbmFtZSwgdHJ5aW5nIHRvIHVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyLCB1bmxlc3MgdGhlIG1vZGVsIGZvcmJpZHMgaXRcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7c2luZ3VsYXJ9YCxcbiAgICAgIHNldDogYHNldCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YFxuICAgIH07XG4gIH1cblxuICAvLyB0aGUgaWQgaXMgaW4gdGhlIHRhcmdldCB0YWJsZVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlLFxuICAgICAgICAuLi50aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICB0aGlzLm9wdGlvbnMub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgKHRhcmdldC5hbGxvd051bGwgPyAnU0VUIE5VTEwnIDogJ0NBU0NBREUnKTtcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCAnQ0FTQ0FERSc7XG4gICAgfVxuXG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnNvdXJjZSwgdGhpcy50YXJnZXQsIHRoaXMub3B0aW9ucywgdGhpcy5zb3VyY2VLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFyZ2V0LnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG5cbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG5cbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gWydnZXQnLCAnc2V0JywgJ2NyZWF0ZSddO1xuXG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFzc29jaWF0ZWQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx8QXJyYXk8TW9kZWw+fSBpbnN0YW5jZXMgc291cmNlIGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1hXSBBcHBseSBhIHNjaGVtYSBvbiB0aGUgcmVsYXRlZCBtb2RlbFxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kT25lfSBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG5cbiAgICBsZXQgVGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3Njb3BlJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY2hlbWEnKSkge1xuICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICBbT3AuaW5dOiBpbnN0YW5jZXMubWFwKF9pbnN0YW5jZSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHdoZXJlLCB0aGlzLnNjb3BlKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/XG4gICAgICB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOlxuICAgICAgd2hlcmU7XG5cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgVGFyZ2V0LmZpbmRBbGwob3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSldID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXSA9IF9pbnN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gVGFyZ2V0LmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhc3NvY2lhdGVkIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSB0aGUgc291cmNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7PzxNb2RlbD58c3RyaW5nfG51bWJlcn0gW2Fzc29jaWF0ZWRJbnN0YW5jZV0gQW4gcGVyc2lzdGVkIGluc3RhbmNlIG9yIHRoZSBwcmltYXJ5IGtleSBvZiBhbiBpbnN0YW5jZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzLiBQYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYCB0byByZW1vdmUgdGhlIGFzc29jaWF0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGdldEFzc29jaWF0aW9uIGFuZCBgdGFyZ2V0LnNhdmVgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBhc3NvY2lhdGVkSW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBzY29wZTogZmFsc2UgfTtcblxuICAgIGNvbnN0IG9sZEluc3RhbmNlID0gYXdhaXQgc291cmNlSW5zdGFuY2VbdGhpcy5hY2Nlc3NvcnMuZ2V0XShvcHRpb25zKTtcbiAgICAvLyBUT0RPIFVzZSBlcXVhbHMgbWV0aG9kIG9uY2UgIzU2MDUgaXMgcmVzb2x2ZWRcbiAgICBjb25zdCBhbHJlYWR5QXNzb2NpYXRlZCA9IG9sZEluc3RhbmNlICYmIGFzc29jaWF0ZWRJbnN0YW5jZSAmJiB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlcy5ldmVyeShhdHRyaWJ1dGUgPT5cbiAgICAgIG9sZEluc3RhbmNlLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSAoYXNzb2NpYXRlZEluc3RhbmNlLmdldCA/IGFzc29jaWF0ZWRJbnN0YW5jZS5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA6IGFzc29jaWF0ZWRJbnN0YW5jZSlcbiAgICApO1xuXG4gICAgaWYgKG9sZEluc3RhbmNlICYmICFhbHJlYWR5QXNzb2NpYXRlZCkge1xuICAgICAgb2xkSW5zdGFuY2VbdGhpcy5mb3JlaWduS2V5XSA9IG51bGw7XG5cbiAgICAgIGF3YWl0IG9sZEluc3RhbmNlLnNhdmUoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBmaWVsZHM6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgICBhbGxvd051bGw6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgICBhc3NvY2lhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhc3NvY2lhdGVkSW5zdGFuY2UgJiYgIWFscmVhZHlBc3NvY2lhdGVkKSB7XG4gICAgICBpZiAoIShhc3NvY2lhdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgdG1wSW5zdGFuY2UgPSB7fTtcbiAgICAgICAgdG1wSW5zdGFuY2VbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBhc3NvY2lhdGVkSW5zdGFuY2U7XG4gICAgICAgIGFzc29jaWF0ZWRJbnN0YW5jZSA9IHRoaXMudGFyZ2V0LmJ1aWxkKHRtcEluc3RhbmNlLCB7XG4gICAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGFzc29jaWF0ZWRJbnN0YW5jZSwgdGhpcy5zY29wZSk7XG4gICAgICBhc3NvY2lhdGVkSW5zdGFuY2Uuc2V0KHRoaXMuZm9yZWlnbktleSwgc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5QXR0cmlidXRlKSk7XG5cbiAgICAgIHJldHVybiBhc3NvY2lhdGVkSW5zdGFuY2Uuc2F2ZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGFzc29jaWF0ZWQgbW9kZWwgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXM9e31dIHZhbHVlcyB0byBjcmVhdGUgYXNzb2NpYXRlZCBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC5jcmVhdGVgIGFuZCBzZXRBc3NvY2lhdGlvbi5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjY3JlYXRlfSBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fSBUaGUgY3JlYXRlZCB0YXJnZXQgbW9kZWxcbiAgICovXG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKHRoaXMuc2NvcGUpKSB7XG4gICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gdGhpcy5zY29wZVthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHRoaXMuZm9yZWlnbktleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnNpbmd1bGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMuc2luZ3VsYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc09uZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tOYW1pbmdDb2xsaXNpb24oYXNzb2NpYXRpb24pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhc3NvY2lhdGlvbi5zb3VyY2UucmF3QXR0cmlidXRlcywgYXNzb2NpYXRpb24uYXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5hbWluZyBjb2xsaXNpb24gYmV0d2VlbiBhdHRyaWJ1dGUgJyR7YXNzb2NpYXRpb24uYXN9J2AgK1xuICAgICAgYCBhbmQgYXNzb2NpYXRpb24gJyR7YXNzb2NpYXRpb24uYXN9JyBvbiBtb2RlbCAke2Fzc29jaWF0aW9uLnNvdXJjZS5uYW1lfWAgK1xuICAgICAgJy4gVG8gcmVtZWR5IHRoaXMsIGNoYW5nZSBlaXRoZXIgZm9yZWlnbktleSBvciBhcyBpbiB5b3VyIGFzc29jaWF0aW9uIGRlZmluaXRpb24nXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0cy5jaGVja05hbWluZ0NvbGxpc2lvbiA9IGNoZWNrTmFtaW5nQ29sbGlzaW9uO1xuXG5mdW5jdGlvbiBhZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlLCBzb3VyY2UsIHRhcmdldCwgb3B0aW9ucywga2V5KSB7XG4gIC8vIEZLIGNvbnN0cmFpbnRzIGFyZSBvcHQtaW46IHVzZXJzIG11c3QgZWl0aGVyIHNldCBgZm9yZWlnbktleUNvbnN0cmFpbnRzYFxuICAvLyBvbiB0aGUgYXNzb2NpYXRpb24sIG9yIHJlcXVlc3QgYW4gYG9uRGVsZXRlYCBvciBgb25VcGRhdGVgIGJlaGF2aW9yXG5cbiAgaWYgKG9wdGlvbnMuZm9yZWlnbktleUNvbnN0cmFpbnQgfHwgb3B0aW9ucy5vbkRlbGV0ZSB8fCBvcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgLy8gRmluZCBwcmltYXJ5IGtleXM6IGNvbXBvc2l0ZSBrZXlzIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIGFwcHJvYWNoXG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UucHJpbWFyeUtleXMpXG4gICAgICAubWFwKHByaW1hcnlLZXlBdHRyaWJ1dGUgPT4gc291cmNlLnJhd0F0dHJpYnV0ZXNbcHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgfHwgcHJpbWFyeUtleUF0dHJpYnV0ZSk7XG5cbiAgICBpZiAocHJpbWFyeUtleXMubGVuZ3RoID09PSAxIHx8ICFwcmltYXJ5S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBuZXdBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHNvdXJjZS5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiBrZXkgfHwgcHJpbWFyeUtleXNbMF1cbiAgICAgIH07XG5cbiAgICAgIG5ld0F0dHJpYnV0ZS5vbkRlbGV0ZSA9IG9wdGlvbnMub25EZWxldGU7XG4gICAgICBuZXdBdHRyaWJ1dGUub25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMgPSBhZGRGb3JlaWduS2V5Q29uc3RyYWludHM7XG5cbi8qKlxuICogTWl4aW4gKGluamVjdCkgYXNzb2NpYXRpb24gbWV0aG9kcyB0byBtb2RlbCBwcm90b3R5cGVcbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhc3NvY2lhdGlvbiBpbnN0YW5jZVxuICogQHBhcmFtIHtvYmplY3R9IG9iaiBNb2RlbCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGhvZHMgTWV0aG9kIG5hbWVzIHRvIGluamVjdFxuICogQHBhcmFtIHtvYmplY3R9IGFsaWFzZXMgTWFwcGluZyBiZXR3ZWVuIG1vZGVsIGFuZCBhc3NvY2lhdGlvbiBtZXRob2QgbmFtZXNcbiAqXG4gKi9cbmZ1bmN0aW9uIG1peGluTWV0aG9kcyhhc3NvY2lhdGlvbiwgb2JqLCBtZXRob2RzLCBhbGlhc2VzKSB7XG4gIGFsaWFzZXMgPSBhbGlhc2VzIHx8IHt9O1xuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAvLyBkb24ndCBvdmVycmlkZSBjdXN0b20gbWV0aG9kc1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgYXNzb2NpYXRpb24uYWNjZXNzb3JzW21ldGhvZF0pKSB7XG4gICAgICBjb25zdCByZWFsTWV0aG9kID0gYWxpYXNlc1ttZXRob2RdIHx8IG1ldGhvZDtcblxuICAgICAgb2JqW2Fzc29jaWF0aW9uLmFjY2Vzc29yc1ttZXRob2RdXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb25bcmVhbE1ldGhvZF0odGhpcywgLi4uQXJyYXkuZnJvbShhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5leHBvcnRzLm1peGluTWV0aG9kcyA9IG1peGluTWV0aG9kcztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxuQXNzb2NpYXRpb24uQmVsb25nc1RvID0gcmVxdWlyZSgnLi9iZWxvbmdzLXRvJyk7XG5Bc3NvY2lhdGlvbi5IYXNPbmUgPSByZXF1aXJlKCcuL2hhcy1vbmUnKTtcbkFzc29jaWF0aW9uLkhhc01hbnkgPSByZXF1aXJlKCcuL2hhcy1tYW55Jyk7XG5Bc3NvY2lhdGlvbi5CZWxvbmdzVG9NYW55ID0gcmVxdWlyZSgnLi9iZWxvbmdzLXRvLW1hbnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NvY2lhdGlvbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBc3NvY2lhdGlvbjtcbm1vZHVsZS5leHBvcnRzLkFzc29jaWF0aW9uID0gQXNzb2NpYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEhhc09uZSA9IHJlcXVpcmUoJy4vaGFzLW9uZScpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoJy4vaGFzLW1hbnknKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKCcuL2JlbG9uZ3MtdG8tbWFueScpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi9iZWxvbmdzLXRvJyk7XG5cbmZ1bmN0aW9uIGlzTW9kZWwobW9kZWwsIHNlcXVlbGl6ZSkge1xuICByZXR1cm4gbW9kZWxcbiAgICAmJiBtb2RlbC5wcm90b3R5cGVcbiAgICAmJiBtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBzZXF1ZWxpemUuU2VxdWVsaXplLk1vZGVsO1xufVxuXG5jb25zdCBNaXhpbiA9IHtcbiAgaGFzTWFueSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHRoaXMuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0uaGFzTWFueSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG5cbiAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbWl4aW4sIHdlJ2xsIG5lZWQgYSB1bmlxdWUgbGV0aWFibGUgbmFtZSBmb3IgaG9va3MgKHNpbmNlIE1vZGVsIHdpbGwgb3ZlcnJpZGUgb3VyIGhvb2tzIG9wdGlvbilcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuXG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBfLm9taXQoc291cmNlLm9wdGlvbnMsIFsnaG9va3MnXSkpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHRoaXMucnVuSG9va3MoJ2JlZm9yZUFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEhhc01hbnkgfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGlkIGlzIGluIHRoZSBmb3JlaWduIHRhYmxlIG9yIGluIGEgY29ubmVjdGluZyB0YWJsZVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IEhhc01hbnkoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcblxuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcygnYWZ0ZXJBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBIYXNNYW55LCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH0sXG5cbiAgYmVsb25nc1RvTWFueSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHRoaXMuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0uYmVsb25nc1RvTWFueSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG5cbiAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbWl4aW4sIHdlJ2xsIG5lZWQgYSB1bmlxdWUgbGV0aWFibGUgbmFtZSBmb3IgaG9va3MgKHNpbmNlIE1vZGVsIHdpbGwgb3ZlcnJpZGUgb3VyIGhvb2tzIG9wdGlvbilcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuICAgIG9wdGlvbnMudGltZXN0YW1wcyA9IG9wdGlvbnMudGltZXN0YW1wcyA9PT0gdW5kZWZpbmVkID8gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lc3RhbXBzIDogb3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgXy5vbWl0KHNvdXJjZS5vcHRpb25zLCBbJ2hvb2tzJywgJ3RpbWVzdGFtcHMnLCAnc2NvcGVzJywgJ2RlZmF1bHRTY29wZSddKSk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogQmVsb25nc1RvTWFueSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdGhlIGlkIGlzIGluIHRoZSBmb3JlaWduIHRhYmxlIG9yIGluIGEgY29ubmVjdGluZyB0YWJsZVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IEJlbG9uZ3NUb01hbnkoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcblxuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcygnYWZ0ZXJBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBCZWxvbmdzVG9NYW55LCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH0sXG5cbiAgZ2V0QXNzb2NpYXRpb25zKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuYXNzb2NpYXRpb25zKS5maWx0ZXIoYXNzb2NpYXRpb24gPT4gYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IHRhcmdldC5uYW1lKTtcbiAgfSxcblxuICBnZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldCwgYWxpYXMpIHtcbiAgICAvLyBUd28gYXNzb2NpYXRpb25zIGNhbm5vdCBoYXZlIHRoZSBzYW1lIGFsaWFzLCBzbyB3ZSBjYW4gdXNlIGZpbmQgaW5zdGVhZCBvZiBmaWx0ZXJcbiAgICByZXR1cm4gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0KS5maW5kKGFzc29jaWF0aW9uID0+IGFzc29jaWF0aW9uLnZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpKSB8fCBudWxsO1xuICB9XG59O1xuXG4vLyBUaGUgbG9naWMgZm9yIGhhc09uZSBhbmQgYmVsb25nc1RvIGlzIGV4YWN0bHkgdGhlIHNhbWVcbmZ1bmN0aW9uIHNpbmdsZUxpbmtlZChUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHNvdXJjZS5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c291cmNlLm5hbWV9LiR7Xy5sb3dlckZpcnN0KFR5cGUubmFtZSl9IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuXG5cbiAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbWl4aW4sIHdlJ2xsIG5lZWQgYSB1bmlxdWUgbGV0aWFibGUgbmFtZSBmb3IgaG9va3MgKHNpbmNlIE1vZGVsIHdpbGwgb3ZlcnJpZGUgb3VyIGhvb2tzIG9wdGlvbilcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHNvdXJjZS5ydW5Ib29rcygnYmVmb3JlQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogVHlwZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdGhlIGlkIGlzIGluIHRoZSBmb3JlaWduIHRhYmxlXG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgVHlwZShzb3VyY2UsIHRhcmdldCwgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzb3VyY2Uub3B0aW9ucykpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcblxuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgc291cmNlLnJ1bkhvb2tzKCdhZnRlckFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IFR5cGUsIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfTtcbn1cblxuTWl4aW4uaGFzT25lID0gc2luZ2xlTGlua2VkKEhhc09uZSk7XG5NaXhpbi5iZWxvbmdzVG8gPSBzaW5nbGVMaW5rZWQoQmVsb25nc1RvKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaXhpbjtcbm1vZHVsZS5leHBvcnRzLk1peGluID0gTWl4aW47XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gTWl4aW47XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB3a3ggPSByZXF1aXJlKCd3a3gnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMnKS52YWxpZGF0b3I7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IHdhcm5pbmdzID0ge307XG5jb25zdCB7IGNsYXNzVG9JbnZva2FibGUgfSA9IHJlcXVpcmUoJy4vdXRpbHMvY2xhc3MtdG8taW52b2thYmxlJyk7XG5jb25zdCB7IGpvaW5TUUxGcmFnbWVudHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMvam9pbi1zcWwtZnJhZ21lbnRzJyk7XG5cbmNsYXNzIEFCU1RSQUNUIHtcbiAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvU3FsKG9wdGlvbnMpO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiB0aGlzLmtleTtcbiAgfVxuICBzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5naWZ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGJpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9iaW5kUGFyYW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICBzdGF0aWMgd2FybihsaW5rLCB0ZXh0KSB7XG4gICAgaWYgKCF3YXJuaW5nc1t0ZXh0XSkge1xuICAgICAgd2FybmluZ3NbdGV4dF0gPSB0cnVlO1xuICAgICAgbG9nZ2VyLndhcm4oYCR7dGV4dH0gXFxuPj4gQ2hlY2s6ICR7bGlua31gKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGV4dGVuZChvbGRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9sZFR5cGUub3B0aW9ucyk7XG4gIH1cbn1cblxuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9ICcnO1xuXG4vKipcbiAqIFNUUklORyBBIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmdcbiAqL1xuY2xhc3MgU1RSSU5HIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MjU1XSBsZW5ndGggb2Ygc3RyaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpbmFyeT1mYWxzZV0gSXMgdGhpcyBiaW5hcnk/XG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGJpbmFyeSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgYmluYXJ5IH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9iaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAyNTU7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYFZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWAsXG4gICAgICB0aGlzLl9iaW5hcnkgJiYgJ0JJTkFSWSdcbiAgICBdKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iaW5hcnkgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZycsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0IEJJTkFSWSgpIHtcbiAgICB0aGlzLl9iaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5iaW5hcnkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIGdldCBCSU5BUlkoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuQklOQVJZO1xuICB9XG59XG5cbi8qKlxuICogQ0hBUiBBIGZpeGVkIGxlbmd0aCBzdHJpbmdcbiAqL1xuY2xhc3MgQ0hBUiBleHRlbmRzIFNUUklORyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0yNTVdIGxlbmd0aCBvZiBzdHJpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBbYmluYXJ5PWZhbHNlXSBJcyB0aGlzIGJpbmFyeT9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgYmluYXJ5KSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBiaW5hcnkgfSk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYENIQVIoJHt0aGlzLl9sZW5ndGh9KWAsXG4gICAgICB0aGlzLl9iaW5hcnkgJiYgJ0JJTkFSWSdcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIFVubGltaXRlZCBsZW5ndGggVEVYVCBjb2x1bW5cbiAqL1xuY2xhc3MgVEVYVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPScnXSBjb3VsZCBiZSB0aW55LCBtZWRpdW0sIGxvbmcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8ICcnO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3RpbnknOlxuICAgICAgICByZXR1cm4gJ1RJTllURVhUJztcbiAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgIHJldHVybiAnTUVESVVNVEVYVCc7XG4gICAgICBjYXNlICdsb25nJzpcbiAgICAgICAgcmV0dXJuICdMT05HVEVYVCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBzdHJpbmcnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIHVubGltaXRlZCBsZW5ndGggY2FzZS1pbnNlbnNpdGl2ZSB0ZXh0IGNvbHVtbi5cbiAqIE9yaWdpbmFsIGNhc2UgaXMgcHJlc2VydmVkIGJ1dCBhY3RzIGNhc2UtaW5zZW5zaXRpdmUgd2hlbiBjb21wYXJpbmcgdmFsdWVzIChzdWNoIGFzIHdoZW4gZmluZGluZyBvciB1bmlxdWUgY29uc3RyYWludHMpLlxuICogT25seSBhdmFpbGFibGUgaW4gUG9zdGdyZXMgYW5kIFNRTGl0ZS5cbiAqXG4gKi9cbmNsYXNzIENJVEVYVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdDSVRFWFQnO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBzdHJpbmcnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgbnVtYmVyIHR5cGUgd2hpY2ggaXMgdXNlZCB0byBidWlsZCBvdGhlciB0eXBlc1xuICovXG5jbGFzcyBOVU1CRVIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0eXBlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGhdIGxlbmd0aCBvZiB0eXBlLCBsaWtlIGBJTlQoNClgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuemVyb2ZpbGxdIElzIHplcm8gZmlsbGVkP1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuc2lnbmVkXSBJcyB1bnNpZ25lZD9cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5kZWNpbWFsc10gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCB1c2VkIHdpdGggbGVuZ3RoIGBGTE9BVCg1LCA0KWBcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5wcmVjaXNpb25dIGRlZmluZXMgcHJlY2lzaW9uIGZvciBkZWNpbWFsIHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5zY2FsZV0gZGVmaW5lcyBzY2FsZSBmb3IgZGVjaW1hbCB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxlbmd0aDogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aDtcbiAgICB0aGlzLl96ZXJvZmlsbCA9IG9wdGlvbnMuemVyb2ZpbGw7XG4gICAgdGhpcy5fZGVjaW1hbHMgPSBvcHRpb25zLmRlY2ltYWxzO1xuICAgIHRoaXMuX3ByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIHRoaXMuX3NjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB0aGlzLl91bnNpZ25lZCA9IG9wdGlvbnMudW5zaWduZWQ7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fbGVuZ3RofWA7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2RlY2ltYWxzID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX2RlY2ltYWxzfWA7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyknO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgIHJlc3VsdCArPSAnIFVOU0lHTkVEJztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICByZXN1bHQgKz0gJyBaRVJPRklMTCc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Zsb2F0KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChgJWogaXMgbm90IGEgdmFsaWQgJHt0aGlzLmtleS50b0xvd2VyQ2FzZSgpfWAsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkobnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInIHx8IHR5cGVvZiBudW1iZXIgPT09ICdib29sZWFuJyB8fCBudW1iZXIgPT09IG51bGwgfHwgbnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbnVtYmVyLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICBnZXQgVU5TSUdORUQoKSB7XG4gICAgdGhpcy5fdW5zaWduZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy51bnNpZ25lZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgWkVST0ZJTEwoKSB7XG4gICAgdGhpcy5femVyb2ZpbGwgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy56ZXJvZmlsbCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFVOU0lHTkVEKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLlVOU0lHTkVEO1xuICB9XG5cbiAgc3RhdGljIGdldCBaRVJPRklMTCgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5aRVJPRklMTDtcbiAgfVxufVxuXG4vKipcbiAqIEEgMzIgYml0IGludGVnZXJcbiAqL1xuY2xhc3MgSU5URUdFUiBleHRlbmRzIE5VTUJFUiB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNJbnQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KGAlaiBpcyBub3QgYSB2YWxpZCAke3RoaXMua2V5LnRvTG93ZXJDYXNlKCl9YCwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIDggYml0IGludGVnZXJcbiAqL1xuY2xhc3MgVElOWUlOVCBleHRlbmRzIElOVEVHRVIge1xufVxuXG4vKipcbiAqIEEgMTYgYml0IGludGVnZXJcbiAqL1xuY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cblxuLyoqXG4gKiBBIDI0IGJpdCBpbnRlZ2VyXG4gKi9cbmNsYXNzIE1FRElVTUlOVCBleHRlbmRzIElOVEVHRVIge1xufVxuXG4vKipcbiAqIEEgNjQgYml0IGludGVnZXJcbiAqL1xuY2xhc3MgQklHSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5cbi8qKlxuICogRmxvYXRpbmcgcG9pbnQgbnVtYmVyICg0LWJ5dGUgcHJlY2lzaW9uKS5cbiAqL1xuY2xhc3MgRkxPQVQgZXh0ZW5kcyBOVU1CRVIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdHlwZSwgbGlrZSBgRkxPQVQoNClgXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2RlY2ltYWxzXSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIHVzZWQgd2l0aCBsZW5ndGggYEZMT0FUKDUsIDQpYFxuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Zsb2F0KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgZmxvYXQnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEZsb2F0aW5nIHBvaW50IG51bWJlciAoNC1ieXRlIHByZWNpc2lvbikuXG4gKi9cbmNsYXNzIFJFQUwgZXh0ZW5kcyBOVU1CRVIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdHlwZSwgbGlrZSBgUkVBTCg0KWBcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGVjaW1hbHNdIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgdXNlZCB3aXRoIGxlbmd0aCBgUkVBTCg1LCA0KWBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG59XG5cbi8qKlxuICogRmxvYXRpbmcgcG9pbnQgbnVtYmVyICg4LWJ5dGUgcHJlY2lzaW9uKS5cbiAqL1xuY2xhc3MgRE9VQkxFIGV4dGVuZHMgTlVNQkVSIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIHR5cGUsIGxpa2UgYERPVUJMRSBQUkVDSVNJT04oMjUpYFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkZWNpbWFsc10gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCB1c2VkIHdpdGggbGVuZ3RoIGBET1VCTEUgUFJFQ0lTSU9OKDI1LCAxMClgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERlY2ltYWwgdHlwZSwgdmFyaWFibGUgcHJlY2lzaW9uLCB0YWtlIGxlbmd0aCBhcyBzcGVjaWZpZWQgYnkgdXNlclxuICovXG5jbGFzcyBERUNJTUFMIGV4dGVuZHMgTlVNQkVSIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3ByZWNpc2lvbl0gZGVmaW5lcyBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbc2NhbGVdIGRlZmluZXMgc2NhbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByZWNpc2lvbiwgc2NhbGUpIHtcbiAgICBzdXBlcih0eXBlb2YgcHJlY2lzaW9uID09PSAnb2JqZWN0JyAmJiBwcmVjaXNpb24gfHwgeyBwcmVjaXNpb24sIHNjYWxlIH0pO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIGlmICh0aGlzLl9wcmVjaXNpb24gfHwgdGhpcy5fc2NhbGUpIHtcbiAgICAgIHJldHVybiBgREVDSU1BTCgke1t0aGlzLl9wcmVjaXNpb24sIHRoaXMuX3NjYWxlXS5maWx0ZXIoXy5pZGVudGl0eSkuam9pbignLCcpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gJ0RFQ0lNQUwnO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNEZWNpbWFsKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgZGVjaW1hbCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFRPRE86IENyZWF0ZSBpbnRlcm1lZGlhdGUgY2xhc3NcbmNvbnN0IHByb3RvRXh0ZW5zaW9ucyA9IHtcbiAgZXNjYXBlOiBmYWxzZSxcbiAgX3ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuICdOYU4nO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgICAgcmV0dXJuIGAke3NpZ259SW5maW5pdHlgO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBgJyR7dGhpcy5fdmFsdWUodmFsdWUpfSdgO1xuICB9LFxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlKSk7XG4gIH1cbn07XG5cbmZvciAoY29uc3QgZmxvYXRpbmcgb2YgW0ZMT0FULCBET1VCTEUsIFJFQUxdKSB7XG4gIE9iamVjdC5hc3NpZ24oZmxvYXRpbmcucHJvdG90eXBlLCBwcm90b0V4dGVuc2lvbnMpO1xufVxuXG4vKipcbiAqIEEgYm9vbGVhbiAvIHRpbnlpbnQgY29sdW1uLCBkZXBlbmRpbmcgb24gZGlhbGVjdFxuICovXG5jbGFzcyBCT09MRUFOIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ1RJTllJTlQoMSknO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNCb29sZWFuKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgYm9vbGVhbicsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gQml0IGZpZWxkcyBhcmUgcmV0dXJuZWQgYXMgYnVmZmVyc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBPbmx5IHRha2UgYWN0aW9uIG9uIHZhbGlkIGJvb2xlYW4gc3RyaW5ncy5cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgPyB0cnVlIDogdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIE9ubHkgdGFrZSBhY3Rpb24gb24gdmFsaWQgYm9vbGVhbiBpbnRlZ2Vycy5cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxID8gdHJ1ZSA6IHZhbHVlID09PSAwID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cblxuQk9PTEVBTi5wYXJzZSA9IEJPT0xFQU4ucHJvdG90eXBlLl9zYW5pdGl6ZTtcblxuLyoqXG4gKiBBIHRpbWUgY29sdW1uXG4gKlxuICovXG5jbGFzcyBUSU1FIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ1RJTUUnO1xuICB9XG59XG5cbi8qKlxuICogRGF0ZSBjb2x1bW4gd2l0aCB0aW1lem9uZSwgZGVmYXVsdCBpcyBVVENcbiAqL1xuY2xhc3MgREFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2xlbmd0aF0gcHJlY2lzaW9uIHRvIGFsbG93IHN0b3JpbmcgbWlsbGlzZWNvbmRzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8ICcnO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnREFURVRJTUUnO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNEYXRlKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgZGF0ZScsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX2lzQ2hhbmdlZCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkge1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICYmICEhdmFsdWUgJiZcbiAgICAgICh2YWx1ZSA9PT0gb3JpZ2luYWxWYWx1ZSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgb3JpZ2luYWxWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgdmFsdWUuZ2V0VGltZSgpID09PSBvcmlnaW5hbFZhbHVlLmdldFRpbWUoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbm90IGNoYW5nZWQgd2hlbiBzZXQgdG8gc2FtZSBlbXB0eSB2YWx1ZVxuICAgIGlmICghb3JpZ2luYWxWYWx1ZSAmJiAhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnRpbWV6b25lKSB7XG4gICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICByZXR1cm4gbW9tZW50VHooZGF0ZSkudHoob3B0aW9ucy50aW1lem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZSA9IG1vbWVudChkYXRlKS51dGNPZmZzZXQob3B0aW9ucy50aW1lem9uZSk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnRUeihkYXRlKTtcbiAgfVxuICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAvLyBaIGhlcmUgbWVhbnMgY3VycmVudCB0aW1lem9uZSwgX25vdF8gVVRDXG4gICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBaJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGRhdGUgb25seSBjb2x1bW4gKG5vIHRpbWVzdGFtcClcbiAqL1xuY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnREFURSc7XG4gIH1cbiAgX3N0cmluZ2lmeShkYXRlKSB7XG4gICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF9pc0NoYW5nZWQodmFsdWUsIG9yaWdpbmFsVmFsdWUpIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiAhIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5vdCBjaGFuZ2VkIHdoZW4gc2V0IHRvIHNhbWUgZW1wdHkgdmFsdWVcbiAgICBpZiAoIW9yaWdpbmFsVmFsdWUgJiYgIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSBrZXkgLyB2YWx1ZSBzdG9yZSBjb2x1bW4uIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVzLlxuICovXG5jbGFzcyBIU1RPUkUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgaHN0b3JlJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIEpTT04gc3RyaW5nIGNvbHVtbi4gQXZhaWxhYmxlIGluIE15U1FMLCBQb3N0Z3JlcyBhbmQgU1FMaXRlXG4gKi9cbmNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYmluYXJ5IHN0b3JhZ2UgSlNPTiBjb2x1bW4uIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVzLlxuICovXG5jbGFzcyBKU09OQiBleHRlbmRzIEpTT05UWVBFIHtcbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gKi9cbmNsYXNzIE5PVyBleHRlbmRzIEFCU1RSQUNUIHtcbn1cblxuLyoqXG4gKiBCaW5hcnkgc3RvcmFnZVxuICovXG5jbGFzcyBCTE9CIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9JyddIGNvdWxkIGJlIHRpbnksIG1lZGl1bSwgbG9uZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgJyc7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAndGlueSc6XG4gICAgICAgIHJldHVybiAnVElOWUJMT0InO1xuICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgcmV0dXJuICdNRURJVU1CTE9CJztcbiAgICAgIGNhc2UgJ2xvbmcnOlxuICAgICAgICByZXR1cm4gJ0xPTkdCTE9CJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGJsb2InLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGV4ID0gdmFsdWUudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiB0aGlzLl9oZXhpZnkoaGV4KTtcbiAgfVxuICBfaGV4aWZ5KGhleCkge1xuICAgIHJldHVybiBgWCcke2hleH0nYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgfVxufVxuXG5cbkJMT0IucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4vKipcbiAqIFJhbmdlIHR5cGVzIGFyZSBkYXRhIHR5cGVzIHJlcHJlc2VudGluZyBhIHJhbmdlIG9mIHZhbHVlcyBvZiBzb21lIGVsZW1lbnQgdHlwZSAoY2FsbGVkIHRoZSByYW5nZSdzIHN1YnR5cGUpLlxuICogT25seSBhdmFpbGFibGUgaW4gUG9zdGdyZXMuIFNlZSBbdGhlIFBvc3RncmVzIGRvY3VtZW50YXRpb25dKGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjQvc3RhdGljL3JhbmdldHlwZXMuaHRtbCkgZm9yIG1vcmUgZGV0YWlsc1xuICovXG5jbGFzcyBSQU5HRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QUJTVFJBQ1R9IHN1YnR5cGUgQSBzdWJ0eXBlIGZvciByYW5nZSwgbGlrZSBSQU5HRShEQVRFKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3VidHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdChzdWJ0eXBlKSA/IHN1YnR5cGUgOiB7IHN1YnR5cGUgfTtcbiAgICBpZiAoIW9wdGlvbnMuc3VidHlwZSlcbiAgICAgIG9wdGlvbnMuc3VidHlwZSA9IG5ldyBJTlRFR0VSKCk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnN1YnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMuc3VidHlwZSA9IG5ldyBvcHRpb25zLnN1YnR5cGUoKTtcbiAgICB9XG4gICAgdGhpcy5fc3VidHlwZSA9IG9wdGlvbnMuc3VidHlwZS5rZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCByYW5nZScsIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKCdBIHJhbmdlIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gZWxlbWVudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbHVtbiBzdG9yaW5nIGEgdW5pcXVlIHVuaXZlcnNhbCBpZGVudGlmaWVyLlxuICogVXNlIHdpdGggYFVVSURWMWAgb3IgYFVVSURWNGAgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICovXG5jbGFzcyBVVUlEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlKSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCB1dWlkJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgdW5pcXVlIHVuaXZlcnNhbCBpZGVudGlmaWVyIGdlbmVyYXRlZCBmb2xsb3dpbmcgdGhlIFVVSUQgdjEgc3RhbmRhcmRcbiAqL1xuY2xhc3MgVVVJRFYxIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlKSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCB1dWlkJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgdW5pcXVlIHVuaXZlcnNhbCBpZGVudGlmaWVyIGdlbmVyYXRlZCBmb2xsb3dpbmcgdGhlIFVVSUQgdjQgc3RhbmRhcmRcbiAqL1xuY2xhc3MgVVVJRFY0IGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlLCA0KSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCB1dWlkdjQnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdmlydHVhbCB2YWx1ZSB0aGF0IGlzIG5vdCBzdG9yZWQgaW4gdGhlIERCLiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBpbiB5b3VyIG1vZGVsIHRoYXQgaXMgcmV0dXJuZWQgdG8gdGhlIHVzZXIgYnV0IG5vdCBzdG9yZWQgaW4gdGhlIERCLlxuICpcbiAqIFlvdSBjb3VsZCBhbHNvIHVzZSBpdCB0byB2YWxpZGF0ZSBhIHZhbHVlIGJlZm9yZSBwZXJtdXRpbmcgYW5kIHN0b3JpbmcgaXQuIFZJUlRVQUwgYWxzbyB0YWtlcyBhIHJldHVybiB0eXBlIGFuZCBkZXBlbmRlbmN5IGZpZWxkcyBhcyBhcmd1bWVudHNcbiAqIElmIGEgdmlydHVhbCBhdHRyaWJ1dGUgaXMgcHJlc2VudCBpbiBgYXR0cmlidXRlc2AgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHB1bGwgaW4gdGhlIGV4dHJhIGZpZWxkcyBhcyB3ZWxsLlxuICogUmV0dXJuIHR5cGUgaXMgbW9zdGx5IHVzZWZ1bCBmb3Igc2V0dXBzIHRoYXQgcmVseSBvbiB0eXBlcyBsaWtlIEdyYXBoUUwuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q2hlY2tpbmcgcGFzc3dvcmQgbGVuZ3RoIGJlZm9yZSBoYXNoaW5nIGl0PC9jYXB0aW9uPlxuICogc2VxdWVsaXplLmRlZmluZSgndXNlcicsIHtcbiAqICAgcGFzc3dvcmRfaGFzaDogRGF0YVR5cGVzLlNUUklORyxcbiAqICAgcGFzc3dvcmQ6IHtcbiAqICAgICB0eXBlOiBEYXRhVHlwZXMuVklSVFVBTCxcbiAqICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAqICAgICAgICAvLyBSZW1lbWJlciB0byBzZXQgdGhlIGRhdGEgdmFsdWUsIG90aGVyd2lzZSBpdCB3b24ndCBiZSB2YWxpZGF0ZWRcbiAqICAgICAgICB0aGlzLnNldERhdGFWYWx1ZSgncGFzc3dvcmQnLCB2YWwpO1xuICogICAgICAgIHRoaXMuc2V0RGF0YVZhbHVlKCdwYXNzd29yZF9oYXNoJywgdGhpcy5zYWx0ICsgdmFsKTtcbiAqICAgICAgfSxcbiAqICAgICAgdmFsaWRhdGU6IHtcbiAqICAgICAgICAgaXNMb25nRW5vdWdoOiBmdW5jdGlvbiAodmFsKSB7XG4gKiAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPCA3KSB7XG4gKiAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgY2hvb3NlIGEgbG9uZ2VyIHBhc3N3b3JkXCIpXG4gKiAgICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICpcbiAqICMgSW4gdGhlIGFib3ZlIGNvZGUgdGhlIHBhc3N3b3JkIGlzIHN0b3JlZCBwbGFpbmx5IGluIHRoZSBwYXNzd29yZCBmaWVsZCBzbyBpdCBjYW4gYmUgdmFsaWRhdGVkLCBidXQgaXMgbmV2ZXIgc3RvcmVkIGluIHRoZSBEQi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5WaXJ0dWFsIHdpdGggZGVwZW5kZW5jeSBmaWVsZHM8L2NhcHRpb24+XG4gKiB7XG4gKiAgIGFjdGl2ZToge1xuICogICAgIHR5cGU6IG5ldyBEYXRhVHlwZXMuVklSVFVBTChEYXRhVHlwZXMuQk9PTEVBTiwgWydjcmVhdGVkQXQnXSksXG4gKiAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLmdldCgnY3JlYXRlZEF0JykgPiBEYXRlLm5vdygpIC0gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKVxuICogICAgIH1cbiAqICAgfVxuICogfVxuICpcbiAqL1xuY2xhc3MgVklSVFVBTCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QUJTVFJBQ1R9IFtSZXR1cm5UeXBlXSByZXR1cm4gdHlwZSBmb3IgdmlydHVhbCB0eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtmaWVsZHNdIGFycmF5IG9mIGZpZWxkcyB0aGlzIHZpcnR1YWwgdHlwZSBpcyBkZXBlbmRlbnQgb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKFJldHVyblR5cGUsIGZpZWxkcykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBSZXR1cm5UeXBlID09PSAnZnVuY3Rpb24nKVxuICAgICAgUmV0dXJuVHlwZSA9IG5ldyBSZXR1cm5UeXBlKCk7XG4gICAgdGhpcy5yZXR1cm5UeXBlID0gUmV0dXJuVHlwZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uLCBQb3N0Z3JlcyBPbmx5XG4gKlxuICogQGV4YW1wbGVcbiAqIERhdGFUeXBlcy5FTlVNKCd2YWx1ZScsICdhbm90aGVyIHZhbHVlJylcbiAqIERhdGFUeXBlcy5FTlVNKFsndmFsdWUnLCAnYW5vdGhlciB2YWx1ZSddKVxuICogRGF0YVR5cGVzLkVOVU0oe1xuICogICB2YWx1ZXM6IFsndmFsdWUnLCAnYW5vdGhlciB2YWx1ZSddXG4gKiB9KVxuICovXG5jbGFzcyBFTlVNIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl8eyB2YWx1ZXM6IGFueVtdIH18YW55W119IGFyZ3MgZWl0aGVyIGFycmF5IG9mIHZhbHVlcyBvciBvcHRpb25zIG9iamVjdCB3aXRoIHZhbHVlcyBhcnJheS4gSXQgYWxzbyBzdXBwb3J0cyB2YXJpYWRpYyB2YWx1ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1swXTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUgfHwge1xuICAgICAgdmFsdWVzOiBhcmdzLnJlZHVjZSgocmVzdWx0LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KEFycmF5LmlzQXJyYXkoZWxlbWVudCkgPyBlbGVtZW50IDogW2VsZW1lbnRdKTtcbiAgICAgIH0sIFtdKVxuICAgIH07XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBjaG9pY2UgaW4gJWonLCB2YWx1ZSwgdGhpcy52YWx1ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBgdHlwZWAuIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBEYXRhVHlwZXMuQVJSQVkoRGF0YVR5cGVzLkRFQ0lNQUwpXG4gKi9cbmNsYXNzIEFSUkFZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtBQlNUUkFDVH0gdHlwZSB0eXBlIG9mIGFycmF5IHZhbHVlc1xuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdmdW5jdGlvbicgPyBuZXcgb3B0aW9ucy50eXBlKCkgOiBvcHRpb25zLnR5cGU7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwZS50b1NxbCgpfVtdYDtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBhcnJheScsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBpcyhvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQVJSQVkgJiYgb2JqLnR5cGUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQSBjb2x1bW4gc3RvcmluZyBHZW9tZXRyeSBpbmZvcm1hdGlvbi5cbiAqIEl0IGlzIG9ubHkgYXZhaWxhYmxlIGluIFBvc3RncmVTUUwgKHdpdGggUG9zdEdJUyksIE1hcmlhREIgb3IgTXlTUUwuXG4gKlxuICogR2VvSlNPTiBpcyBhY2NlcHRlZCBhcyBpbnB1dCBhbmQgcmV0dXJuZWQgYXMgb3V0cHV0LlxuICpcbiAqIEluIFBvc3RHSVMsIHRoZSBHZW9KU09OIGlzIHBhcnNlZCB1c2luZyB0aGUgUG9zdEdJUyBmdW5jdGlvbiBgU1RfR2VvbUZyb21HZW9KU09OYC5cbiAqIEluIE15U1FMIGl0IGlzIHBhcnNlZCB1c2luZyB0aGUgZnVuY3Rpb24gYEdlb21Gcm9tVGV4dGAuXG4gKlxuICogVGhlcmVmb3JlLCBvbmUgY2FuIGp1c3QgZm9sbG93IHRoZSBbR2VvSlNPTiBzcGVjXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgZm9yIGhhbmRsaW5nIGdlb21ldHJ5IG9iamVjdHMuICBTZWUgdGhlIGZvbGxvd2luZyBleGFtcGxlczpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmluZyBhIEdlb21ldHJ5IHR5cGUgYXR0cmlidXRlPC9jYXB0aW9uPlxuICogRGF0YVR5cGVzLkdFT01FVFJZXG4gKiBEYXRhVHlwZXMuR0VPTUVUUlkoJ1BPSU5UJylcbiAqIERhdGFUeXBlcy5HRU9NRVRSWSgnUE9JTlQnLCA0MzI2KVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIG5ldyBwb2ludDwvY2FwdGlvbj5cbiAqIGNvbnN0IHBvaW50ID0geyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWzM5LjgwNzIyMiwtNzYuOTg0NzIyXX07XG4gKlxuICogVXNlci5jcmVhdGUoe3VzZXJuYW1lOiAndXNlcm5hbWUnLCBnZW9tZXRyeTogcG9pbnQgfSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgbmV3IGxpbmVzdHJpbmc8L2NhcHRpb24+XG4gKiBjb25zdCBsaW5lID0geyB0eXBlOiAnTGluZVN0cmluZycsICdjb29yZGluYXRlcyc6IFsgWzEwMC4wLCAwLjBdLCBbMTAxLjAsIDEuMF0gXSB9O1xuICpcbiAqIFVzZXIuY3JlYXRlKHt1c2VybmFtZTogJ3VzZXJuYW1lJywgZ2VvbWV0cnk6IGxpbmUgfSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgbmV3IHBvbHlnb248L2NhcHRpb24+XG4gKiBjb25zdCBwb2x5Z29uID0geyB0eXBlOiAnUG9seWdvbicsIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgICAgICAgICAgWyBbMTAwLjAsIDAuMF0sIFsxMDEuMCwgMC4wXSwgWzEwMS4wLCAxLjBdLFxuICogICAgICAgICAgICAgICAgICAgWzEwMC4wLCAxLjBdLCBbMTAwLjAsIDAuMF0gXVxuICogICAgICAgICAgICAgICAgIF19O1xuICpcbiAqIFVzZXIuY3JlYXRlKHt1c2VybmFtZTogJ3VzZXJuYW1lJywgZ2VvbWV0cnk6IHBvbHlnb24gfSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgbmV3IHBvaW50IHdpdGggYSBjdXN0b20gU1JJRDwvY2FwdGlvbj5cbiAqIGNvbnN0IHBvaW50ID0ge1xuICogICB0eXBlOiAnUG9pbnQnLFxuICogICBjb29yZGluYXRlczogWzM5LjgwNzIyMiwtNzYuOTg0NzIyXSxcbiAqICAgY3JzOiB7IHR5cGU6ICduYW1lJywgcHJvcGVydGllczogeyBuYW1lOiAnRVBTRzo0MzI2J30gfVxuICogfTtcbiAqXG4gKiBVc2VyLmNyZWF0ZSh7dXNlcm5hbWU6ICd1c2VybmFtZScsIGdlb21ldHJ5OiBwb2ludCB9KVxuICpcbiAqXG4gKiBAc2VlIHtAbGluayBEYXRhVHlwZXMuR0VPR1JBUEhZfVxuICovXG5jbGFzcyBHRU9NRVRSWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZSBvZiBnZW9tZXRyeSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3JpZF0gU1JJRCBvZiB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSwgc3JpZCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuc3JpZCA9IG9wdGlvbnMuc3JpZDtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBHZW9tRnJvbVRleHQoJHtvcHRpb25zLmVzY2FwZSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBHZW9tRnJvbVRleHQoJHtvcHRpb25zLmJpbmRQYXJhbSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxufVxuXG5HRU9NRVRSWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbi8qKlxuICogQSBnZW9ncmFwaHkgZGF0YXR5cGUgcmVwcmVzZW50cyB0d28gZGltZW5zaW9uYWwgc3BhY2lhbCBvYmplY3RzIGluIGFuIGVsbGlwdGljIGNvb3JkIHN5c3RlbS5cbiAqXG4gKiBfX1RoZSBkaWZmZXJlbmNlIGZyb20gZ2VvbWV0cnkgYW5kIGdlb2dyYXBoeSB0eXBlOl9fXG4gKlxuICogUG9zdEdJUyAxLjUgaW50cm9kdWNlZCBhIG5ldyBzcGF0aWFsIHR5cGUgY2FsbGVkIGdlb2dyYXBoeSwgd2hpY2ggdXNlcyBnZW9kZXRpYyBtZWFzdXJlbWVudCBpbnN0ZWFkIG9mIENhcnRlc2lhbiBtZWFzdXJlbWVudC5cbiAqIENvb3JkaW5hdGUgcG9pbnRzIGluIHRoZSBnZW9ncmFwaHkgdHlwZSBhcmUgYWx3YXlzIHJlcHJlc2VudGVkIGluIFdHUyA4NCBsb24gbGF0IGRlZ3JlZXMgKFNSSUQgNDMyNiksXG4gKiBidXQgbWVhc3VyZW1lbnQgZnVuY3Rpb25zIGFuZCByZWxhdGlvbnNoaXBzIFNUX0Rpc3RhbmNlLCBTVF9EV2l0aGluLCBTVF9MZW5ndGgsIGFuZCBTVF9BcmVhIGFsd2F5cyByZXR1cm4gYW5zd2VycyBpbiBtZXRlcnMgb3IgYXNzdW1lIGlucHV0cyBpbiBtZXRlcnMuXG4gKlxuICogX19XaGF0IGlzIGJlc3QgdG8gdXNlPyBJdCBkZXBlbmRzOl9fXG4gKlxuICogV2hlbiBjaG9vc2luZyBiZXR3ZWVuIHRoZSBnZW9tZXRyeSBhbmQgZ2VvZ3JhcGh5IHR5cGUgZm9yIGRhdGEgc3RvcmFnZSwgeW91IHNob3VsZCBjb25zaWRlciB3aGF0IHlvdeKAmWxsIGJlIHVzaW5nIGl0IGZvci5cbiAqIElmIGFsbCB5b3UgZG8gYXJlIHNpbXBsZSBtZWFzdXJlbWVudHMgYW5kIHJlbGF0aW9uc2hpcCBjaGVja3Mgb24geW91ciBkYXRhLCBhbmQgeW91ciBkYXRhIGNvdmVycyBhIGZhaXJseSBsYXJnZSBhcmVhLCB0aGVuIG1vc3QgbGlrZWx5IHlvdeKAmWxsIGJlIGJldHRlciBvZmYgc3RvcmluZyB5b3VyIGRhdGEgdXNpbmcgdGhlIG5ldyBnZW9ncmFwaHkgdHlwZS5cbiAqIEFsdGhvdWdoIHRoZSBuZXcgZ2VvZ3JhcGh5IGRhdGEgdHlwZSBjYW4gY292ZXIgdGhlIGdsb2JlLCB0aGUgZ2VvbWV0cnkgdHlwZSBpcyBmYXIgZnJvbSBvYnNvbGV0ZS5cbiAqIFRoZSBnZW9tZXRyeSB0eXBlIGhhcyBhIG11Y2ggcmljaGVyIHNldCBvZiBmdW5jdGlvbnMgdGhhbiBnZW9ncmFwaHksIHJlbGF0aW9uc2hpcCBjaGVja3MgYXJlIGdlbmVyYWxseSBmYXN0ZXIsIGFuZCBpdCBoYXMgd2lkZXIgc3VwcG9ydCBjdXJyZW50bHkgYWNyb3NzIGRlc2t0b3AgYW5kIHdlYi1tYXBwaW5nIHRvb2xzXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVmaW5pbmcgYSBHZW9ncmFwaHkgdHlwZSBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gKiBEYXRhVHlwZXMuR0VPR1JBUEhZXG4gKiBEYXRhVHlwZXMuR0VPR1JBUEhZKCdQT0lOVCcpXG4gKiBEYXRhVHlwZXMuR0VPR1JBUEhZKCdQT0lOVCcsIDQzMjYpXG4gKi9cbmNsYXNzIEdFT0dSQVBIWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZSBvZiBnZW9ncmFwaHkgZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyaWRdIFNSSUQgb2YgdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUsIHNyaWQgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLnNyaWQgPSBvcHRpb25zLnNyaWQ7XG4gIH1cbiAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5lc2NhcGUod2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBgR2VvbUZyb21UZXh0KCR7b3B0aW9ucy5iaW5kUGFyYW0od2t4Lkdlb21ldHJ5LnBhcnNlR2VvSlNPTih2YWx1ZSkudG9Xa3QoKSl9KWA7XG4gIH1cbn1cblxuXG5HRU9HUkFQSFkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBjaWRyIHR5cGUgaG9sZHMgYW4gSVB2NCBvciBJUHY2IG5ldHdvcmsgc3BlY2lmaWNhdGlvbi4gVGFrZXMgNyBvciAxOSBieXRlcy5cbiAqXG4gKiBPbmx5IGF2YWlsYWJsZSBmb3IgUG9zdGdyZXNcbiAqL1xuY2xhc3MgQ0lEUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzSVBSYW5nZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBDSURSJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSU5FVCB0eXBlIGhvbGRzIGFuIElQdjQgb3IgSVB2NiBob3N0IGFkZHJlc3MsIGFuZCBvcHRpb25hbGx5IGl0cyBzdWJuZXQuIFRha2VzIDcgb3IgMTkgYnl0ZXNcbiAqXG4gKiBPbmx5IGF2YWlsYWJsZSBmb3IgUG9zdGdyZXNcbiAqL1xuY2xhc3MgSU5FVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzSVAodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgSU5FVCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIE1BQ0FERFIgdHlwZSBzdG9yZXMgTUFDIGFkZHJlc3Nlcy4gVGFrZXMgNiBieXRlc1xuICpcbiAqIE9ubHkgYXZhaWxhYmxlIGZvciBQb3N0Z3Jlc1xuICpcbiAqL1xuY2xhc3MgTUFDQUREUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhVmFsaWRhdG9yLmlzTUFDQWRkcmVzcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBNQUNBRERSJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgVFNWRUNUT1IgdHlwZSBzdG9yZXMgdGV4dCBzZWFyY2ggdmVjdG9ycy5cbiAqXG4gKiBPbmx5IGF2YWlsYWJsZSBmb3IgUG9zdGdyZXNcbiAqXG4gKi9cbmNsYXNzIFRTVkVDVE9SIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbmNlIGNsYXNzIGhvbGRpbmcgY29tbW9ubHkgdXNlZCBkYXRhIHR5cGVzLiBUaGUgZGF0YSB0eXBlcyBhcmUgdXNlZCB3aGVuIGRlZmluaW5nIGEgbmV3IG1vZGVsIHVzaW5nIGBTZXF1ZWxpemUuZGVmaW5lYCwgbGlrZSB0aGlzOlxuICogYGBganNcbiAqIHNlcXVlbGl6ZS5kZWZpbmUoJ21vZGVsJywge1xuICogICBjb2x1bW46IERhdGFUeXBlcy5JTlRFR0VSXG4gKiB9KVxuICogYGBgXG4gKiBXaGVuIGRlZmluaW5nIGEgbW9kZWwgeW91IGNhbiBqdXN0IGFzIGVhc2lseSBwYXNzIGEgc3RyaW5nIGFzIHR5cGUsIGJ1dCBvZnRlbiB1c2luZyB0aGUgdHlwZXMgZGVmaW5lZCBoZXJlIGlzIGJlbmVmaWNpYWwuIEZvciBleGFtcGxlLCB1c2luZyBgRGF0YVR5cGVzLkJMT0JgLCBtZWFuXG4gKiB0aGF0IHRoYXQgY29sdW1uIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gaW5zdGFuY2Ugb2YgYEJ1ZmZlcmAgd2hlbiBiZWluZyBmZXRjaGVkIGJ5IHNlcXVlbGl6ZS5cbiAqXG4gKiBUbyBwcm92aWRlIGEgbGVuZ3RoIGZvciB0aGUgZGF0YSB0eXBlLCB5b3UgY2FuIGludm9rZSBpdCBsaWtlIGEgZnVuY3Rpb246IGBJTlRFR0VSKDIpYFxuICpcbiAqIFNvbWUgZGF0YSB0eXBlcyBoYXZlIHNwZWNpYWwgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBpbiBvcmRlciB0byBjaGFuZ2UgdGhlIGRhdGEgdHlwZS5cbiAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4gdW5zaWduZWQgaW50ZWdlciB3aXRoIHplcm9maWxsIHlvdSBjYW4gZG8gYERhdGFUeXBlcy5JTlRFR0VSLlVOU0lHTkVELlpFUk9GSUxMYC5cbiAqIFRoZSBvcmRlciB5b3UgYWNjZXNzIHRoZSBwcm9wZXJ0aWVzIGluIGRvIG5vdCBtYXR0ZXIsIHNvIGBEYXRhVHlwZXMuSU5URUdFUi5aRVJPRklMTC5VTlNJR05FRGAgaXMgZmluZSBhcyB3ZWxsLlxuICpcbiAqICogQWxsIG51bWJlciB0eXBlcyAoYElOVEVHRVJgLCBgQklHSU5UYCwgYEZMT0FUYCwgYERPVUJMRWAsIGBSRUFMYCwgYERFQ0lNQUxgKSBleHBvc2UgdGhlIHByb3BlcnRpZXMgYFVOU0lHTkVEYCBhbmQgYFpFUk9GSUxMYFxuICogKiBUaGUgYENIQVJgIGFuZCBgU1RSSU5HYCB0eXBlcyBleHBvc2UgdGhlIGBCSU5BUllgIHByb3BlcnR5XG4gKlxuICogVGhyZWUgb2YgdGhlIHZhbHVlcyBwcm92aWRlZCBoZXJlIChgTk9XYCwgYFVVSURWMWAgYW5kIGBVVUlEVjRgKSBhcmUgc3BlY2lhbCBkZWZhdWx0IHZhbHVlcywgdGhhdCBzaG91bGQgbm90IGJlIHVzZWQgdG8gZGVmaW5lIHR5cGVzLiBJbnN0ZWFkIHRoZXkgYXJlIHVzZWQgYXMgc2hvcnRoYW5kcyBmb3JcbiAqIGRlZmluaW5nIGRlZmF1bHQgdmFsdWVzLiBGb3IgZXhhbXBsZSwgdG8gZ2V0IGEgdXVpZCBmaWVsZCB3aXRoIGEgZGVmYXVsdCB2YWx1ZSBnZW5lcmF0ZWQgZm9sbG93aW5nIHYxIG9mIHRoZSBVVUlEIHN0YW5kYXJkOlxuICogYGBganNcbiAqIHNlcXVlbGl6ZS5kZWZpbmUoJ21vZGVsJywge1xuICogICB1dWlkOiB7XG4gKiAgICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gKiAgICAgZGVmYXVsdFZhbHVlOiBEYXRhVHlwZXMuVVVJRFYxLFxuICogICAgIHByaW1hcnlLZXk6IHRydWVcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogVGhlcmUgbWF5IGJlIHRpbWVzIHdoZW4geW91IHdhbnQgdG8gZ2VuZXJhdGUgeW91ciBvd24gVVVJRCBjb25mb3JtaW5nIHRvIHNvbWUgb3RoZXIgYWxnb3JpdGhtLiBUaGlzIGlzIGFjY29tcGxpc2hlZFxuICogdXNpbmcgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSBhcyB3ZWxsLCBidXQgaW5zdGVhZCBvZiBzcGVjaWZ5aW5nIG9uZSBvZiB0aGUgc3VwcGxpZWQgVVVJRCB0eXBlcywgeW91IHJldHVybiBhIHZhbHVlXG4gKiBmcm9tIGEgZnVuY3Rpb24uXG4gKiBgYGBqc1xuICogc2VxdWVsaXplLmRlZmluZSgnbW9kZWwnLCB7XG4gKiAgIHV1aWQ6IHtcbiAqICAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAqICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIGdlbmVyYXRlTXlJZCgpXG4gKiAgICAgfSxcbiAqICAgICBwcmltYXJ5S2V5OiB0cnVlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqL1xuY29uc3QgRGF0YVR5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCU1RSQUNULFxuICBTVFJJTkcsXG4gIENIQVIsXG4gIFRFWFQsXG4gIE5VTUJFUixcbiAgVElOWUlOVCxcbiAgU01BTExJTlQsXG4gIE1FRElVTUlOVCxcbiAgSU5URUdFUixcbiAgQklHSU5ULFxuICBGTE9BVCxcbiAgVElNRSxcbiAgREFURSxcbiAgREFURU9OTFksXG4gIEJPT0xFQU4sXG4gIE5PVyxcbiAgQkxPQixcbiAgREVDSU1BTCxcbiAgTlVNRVJJQzogREVDSU1BTCxcbiAgVVVJRCxcbiAgVVVJRFYxLFxuICBVVUlEVjQsXG4gIEhTVE9SRSxcbiAgSlNPTjogSlNPTlRZUEUsXG4gIEpTT05CLFxuICBWSVJUVUFMLFxuICBBUlJBWSxcbiAgRU5VTSxcbiAgUkFOR0UsXG4gIFJFQUwsXG4gICdET1VCTEUgUFJFQ0lTSU9OJzogRE9VQkxFLFxuICBET1VCTEUsXG4gIEdFT01FVFJZLFxuICBHRU9HUkFQSFksXG4gIENJRFIsXG4gIElORVQsXG4gIE1BQ0FERFIsXG4gIENJVEVYVCxcbiAgVFNWRUNUT1Jcbn07XG5cbl8uZWFjaChEYXRhVHlwZXMsIChkYXRhVHlwZSwgbmFtZSkgPT4ge1xuICAvLyBndWFyZCBmb3IgYWxpYXNlc1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgJ2tleScpKSB7XG4gICAgZGF0YVR5cGUudHlwZXMgPSB7fTtcbiAgICBkYXRhVHlwZS5rZXkgPSBkYXRhVHlwZS5wcm90b3R5cGUua2V5ID0gbmFtZTtcbiAgfVxufSk7XG5cbmNvbnN0IGRpYWxlY3RNYXAgPSB7fTtcbmRpYWxlY3RNYXAucG9zdGdyZXMgPSByZXF1aXJlKCcuL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXMnKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5teXNxbCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlcycpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm1hcmlhZGIgPSByZXF1aXJlKCcuL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlcycpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLnNxbGl0ZSA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXMnKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5tc3NxbCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbXNzcWwvZGF0YS10eXBlcycpKERhdGFUeXBlcyk7XG5cbmNvbnN0IGRpYWxlY3RMaXN0ID0gT2JqZWN0LnZhbHVlcyhkaWFsZWN0TWFwKTtcblxuZm9yIChjb25zdCBkYXRhVHlwZXMgb2YgZGlhbGVjdExpc3QpIHtcbiAgXy5lYWNoKGRhdGFUeXBlcywgKERhdGFUeXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIURhdGFUeXBlLmtleSkge1xuICAgICAgRGF0YVR5cGUua2V5ID0gRGF0YVR5cGUucHJvdG90eXBlLmtleSA9IGtleTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBXcmFwIGFsbCBkYXRhIHR5cGVzIHRvIG5vdCByZXF1aXJlIGBuZXdgXG5mb3IgKGNvbnN0IGRhdGFUeXBlcyBvZiBbRGF0YVR5cGVzLCAuLi5kaWFsZWN0TGlzdF0pIHtcbiAgXy5lYWNoKGRhdGFUeXBlcywgKERhdGFUeXBlLCBrZXkpID0+IHtcbiAgICBkYXRhVHlwZXNba2V5XSA9IGNsYXNzVG9JbnZva2FibGUoRGF0YVR5cGUpO1xuICB9KTtcbn1cblxuT2JqZWN0LmFzc2lnbihEYXRhVHlwZXMsIGRpYWxlY3RNYXApO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGNsYXNzVG9JbnZva2FibGUgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY2xhc3MgQUJTVFJBQ1Qge1xuICBzdGF0aWMgdG9TdHJpbmcoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgdGhpcygpLnRvU3RyaW5nKC4uLmFyZ3MpO1xuICB9XG5cbiAgdG9TdHJpbmcoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLnRvU3FsKC4uLmFyZ3MpO1xuICB9XG5cbiAgdG9TcWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b1NxbCBpbXBsZW1lbnRhdGlvbiBtaXNzaW5nJyk7XG4gIH1cbn1cblxuY2xhc3MgSU5JVElBTExZX0RFRkVSUkVEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ0RFRkVSUkFCTEUgSU5JVElBTExZIERFRkVSUkVEJztcbiAgfVxufVxuXG5jbGFzcyBJTklUSUFMTFlfSU1NRURJQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ0RFRkVSUkFCTEUgSU5JVElBTExZIElNTUVESUFURSc7XG4gIH1cbn1cblxuY2xhc3MgTk9UIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ05PVCBERUZFUlJBQkxFJztcbiAgfVxufVxuXG5jbGFzcyBTRVRfREVGRVJSRUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIH1cblxuICB0b1NxbChxdWVyeUdlbmVyYXRvcikge1xuICAgIHJldHVybiBxdWVyeUdlbmVyYXRvci5zZXREZWZlcnJlZFF1ZXJ5KHRoaXMuY29uc3RyYWludHMpO1xuICB9XG59XG5cbmNsYXNzIFNFVF9JTU1FRElBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIH1cblxuICB0b1NxbChxdWVyeUdlbmVyYXRvcikge1xuICAgIHJldHVybiBxdWVyeUdlbmVyYXRvci5zZXRJbW1lZGlhdGVRdWVyeSh0aGlzLmNvbnN0cmFpbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gZGVmZXJyYWJsZSBjb25zdHJhaW50cy4gSXQgY2FuIGJlIHVzZWQgdG9cbiAqIG1ha2UgZm9yZWlnbiBrZXkgY29uc3RyYWludHMgZGVmZXJyYWJsZSBhbmQgdG8gc2V0IHRoZSBjb25zdHJhaW50cyB3aXRoaW4gYVxuICogdHJhbnNhY3Rpb24uIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgaW4gUG9zdGdyZVNRTC5cbiAqXG4gKiBUaGUgZm9yZWlnbiBrZXlzIGNhbiBiZSBjb25maWd1cmVkIGxpa2UgdGhpcy4gSXQgd2lsbCBjcmVhdGUgYSBmb3JlaWduIGtleVxuICogdGhhdCB3aWxsIGNoZWNrIHRoZSBjb25zdHJhaW50cyBpbW1lZGlhdGVseSB3aGVuIHRoZSBkYXRhIHdhcyBpbnNlcnRlZC5cbiAqXG4gKiBgYGBqc1xuICogc2VxdWVsaXplLmRlZmluZSgnTW9kZWwnLCB7XG4gKiAgIGZvcmVpZ25faWQ6IHtcbiAqICAgICB0eXBlOiBTZXF1ZWxpemUuSU5URUdFUixcbiAqICAgICByZWZlcmVuY2VzOiB7XG4gKiAgICAgICBtb2RlbDogT3RoZXJNb2RlbCxcbiAqICAgICAgIGtleTogJ2lkJyxcbiAqICAgICAgIGRlZmVycmFibGU6IFNlcXVlbGl6ZS5EZWZlcnJhYmxlLklOSVRJQUxMWV9JTU1FRElBVEVcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogVGhlIGNvbnN0cmFpbnRzIGNhbiBiZSBjb25maWd1cmVkIGluIGEgdHJhbnNhY3Rpb24gbGlrZSB0aGlzLiBJdCB3aWxsXG4gKiB0cmlnZ2VyIGEgcXVlcnkgb25jZSB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCBhbmQgc2V0IHRoZSBjb25zdHJhaW50c1xuICogdG8gYmUgY2hlY2tlZCBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBzZXF1ZWxpemUudHJhbnNhY3Rpb24oe1xuICogICBkZWZlcnJhYmxlOiBTZXF1ZWxpemUuRGVmZXJyYWJsZS5TRVRfREVGRVJSRURcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IElOSVRJQUxMWV9ERUZFUlJFRCAgICBVc2Ugd2hlbiBkZWNsYXJpbmcgYSBjb25zdHJhaW50LiBBbGxvdyBhbmQgZW5hYmxlIGJ5IGRlZmF1bHQgdGhpcyBjb25zdHJhaW50J3MgY2hlY2tzIHRvIGJlIGRlZmVycmVkIGF0IHRoZSBlbmQgb2YgdHJhbnNhY3Rpb25zLlxuICogQHByb3BlcnR5IElOSVRJQUxMWV9JTU1FRElBVEUgICBVc2Ugd2hlbiBkZWNsYXJpbmcgYSBjb25zdHJhaW50LiBBbGxvdyB0aGUgY29uc3RyYWludCdzIGNoZWNrcyB0byBiZSBkZWZlcnJlZCBhdCB0aGUgZW5kIG9mIHRyYW5zYWN0aW9ucy5cbiAqIEBwcm9wZXJ0eSBOT1QgICAgICAgICAgICAgICAgICAgVXNlIHdoZW4gZGVjbGFyaW5nIGEgY29uc3RyYWludC4gU2V0IHRoZSBjb25zdHJhaW50IHRvIG5vdCBkZWZlcnJlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbiBQb3N0Z3JlU1FMIGFuZCBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGR5bmFtaWNhbGx5IGRlZmVyIHRoZSBjb25zdHJhaW50cyB3aXRoaW4gYSB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSBTRVRfREVGRVJSRUQgICAgICAgICAgVXNlIHdoZW4gZGVjbGFyaW5nIGEgdHJhbnNhY3Rpb24uIERlZmVyIHRoZSBkZWZlcnJhYmxlIGNoZWNrcyBpbnZvbHZlZCBpbiB0aGlzIHRyYW5zYWN0aW9uIGF0IGNvbW1pdC5cbiAqIEBwcm9wZXJ0eSBTRVRfSU1NRURJQVRFICAgICAgICAgVXNlIHdoZW4gZGVjbGFyaW5nIGEgdHJhbnNhY3Rpb24uIEV4ZWN1dGUgdGhlIGRlZmVycmFibGUgY2hlY2tzIGludm9sdmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuXG4gKi9cblxuY29uc3QgRGVmZXJyYWJsZSA9IHtcbiAgSU5JVElBTExZX0RFRkVSUkVEOiBjbGFzc1RvSW52b2thYmxlKElOSVRJQUxMWV9ERUZFUlJFRCksXG4gIElOSVRJQUxMWV9JTU1FRElBVEU6IGNsYXNzVG9JbnZva2FibGUoSU5JVElBTExZX0lNTUVESUFURSksXG4gIE5PVDogY2xhc3NUb0ludm9rYWJsZShOT1QpLFxuICBTRVRfREVGRVJSRUQ6IGNsYXNzVG9JbnZva2FibGUoU0VUX0RFRkVSUkVEKSxcbiAgU0VUX0lNTUVESUFURTogY2xhc3NUb0ludm9rYWJsZShTRVRfSU1NRURJQVRFKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZlcnJhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFBvb2wsIFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZSgnc2VxdWVsaXplLXBvb2wnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9kZXByZWNhdGlvbnMnKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgncG9vbCcpO1xuXG4vKipcbiAqIEFic3RyYWN0IENvbm5lY3Rpb24gTWFuYWdlclxuICpcbiAqIENvbm5lY3Rpb24gbWFuYWdlciB3aGljaCBoYW5kbGVzIHBvb2xpbmcgJiByZXBsaWNhdGlvbi5cbiAqIFVzZXMgc2VxdWVsaXplLXBvb2wgZm9yIHBvb2xpbmdcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IF8uY2xvbmVEZWVwKHNlcXVlbGl6ZS5jb25maWcpO1xuXG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5kaWFsZWN0ID0gZGlhbGVjdDtcbiAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLmRpYWxlY3ROYW1lID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0O1xuXG4gICAgaWYgKGNvbmZpZy5wb29sID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciBwb29sOmZhbHNlIHdhcyByZW1vdmVkIGluIHY0LjAnKTtcbiAgICB9XG5cbiAgICBjb25maWcucG9vbCA9IF8uZGVmYXVsdHMoY29uZmlnLnBvb2wgfHwge30sIHtcbiAgICAgIG1heDogNSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGlkbGU6IDEwMDAwLFxuICAgICAgYWNxdWlyZTogNjAwMDAsXG4gICAgICBldmljdDogMTAwMCxcbiAgICAgIHZhbGlkYXRlOiB0aGlzLl92YWxpZGF0ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG5cbiAgICB0aGlzLmluaXRQb29scygpO1xuICB9XG5cbiAgcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzKSB7XG4gICAgXy5lYWNoKGRhdGFUeXBlcywgZGF0YVR5cGUgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgJ3BhcnNlJykpIHtcbiAgICAgICAgaWYgKGRhdGFUeXBlLnR5cGVzW3RoaXMuZGlhbGVjdE5hbWVdKSB7XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyc2UgZnVuY3Rpb24gbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAke2RhdGFUeXBlLmtleX0gaW4gZGlhbGVjdCAke3RoaXMuZGlhbGVjdE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gbG9hZCBkaWFsZWN0IG1vZHVsZSBmcm9tIHZhcmlvdXMgY29uZmlndXJlZCBvcHRpb25zLlxuICAgKiBQcmlvcml0eSBnb2VzIGxpa2UgZGlhbGVjdE1vZHVsZVBhdGggPiBkaWFsZWN0TW9kdWxlID4gcmVxdWlyZShkZWZhdWx0KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBOYW1lIG9mIGRpYWxlY3QgbW9kdWxlIHRvIGxvb2t1cFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgX2xvYWREaWFsZWN0TW9kdWxlKG1vZHVsZU5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1aXJlKG1vZHVsZU5hbWUpO1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBkaWFsZWN0IGF0ICR7dGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGluc3RhbGwgJHttb2R1bGVOYW1lfSBwYWNrYWdlIG1hbnVhbGx5YCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciB3aGljaCBleGVjdXRlcyBvbiBwcm9jZXNzIGV4aXQgb3IgY29ubmVjdGlvbiBtYW5hZ2VyIHNodXRkb3duXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgX29uUHJvY2Vzc0V4aXQoKSB7XG4gICAgaWYgKCF0aGlzLnBvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnBvb2wuZHJhaW4oKTtcbiAgICBkZWJ1ZygnY29ubmVjdGlvbiBkcmFpbiBkdWUgdG8gcHJvY2VzcyBleGl0Jyk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb29sLmRlc3Ryb3lBbGxOb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFpbiB0aGUgcG9vbCBhbmQgY2xvc2UgaXQgcGVybWFuZW50bHlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjbG9zZSgpIHtcbiAgICAvLyBNYXJrIGNsb3NlIG9mIHBvb2xcbiAgICB0aGlzLmdldENvbm5lY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uIHdhcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gbWFuYWdlciB3YXMgY2xvc2VkIScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fb25Qcm9jZXNzRXhpdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY29ubmVjdGlvbiBwb29sLiBCeSBkZWZhdWx0IHBvb2wgYXV0b3N0YXJ0IGlzIHNldCB0byBmYWxzZSwgc28gbm8gY29ubmVjdGlvbiB3aWxsIGJlXG4gICAqIGJlIGNyZWF0ZWQgdW5sZXNzIGBwb29sLmFjcXVpcmVgIGlzIGNhbGxlZC5cbiAgICovXG4gIGluaXRQb29scygpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICghY29uZmlnLnJlcGxpY2F0aW9uKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6ICdzZXF1ZWxpemUnLFxuICAgICAgICBjcmVhdGU6ICgpID0+IHRoaXMuX2Nvbm5lY3QoY29uZmlnKSxcbiAgICAgICAgZGVzdHJveTogYXN5bmMgY29ubmVjdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICAgICAgICBkZWJ1ZygnY29ubmVjdGlvbiBkZXN0cm95Jyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSk7XG5cbiAgICAgIGRlYnVnKGBwb29sIGNyZWF0ZWQgd2l0aCBtYXgvbWluOiAke2NvbmZpZy5wb29sLm1heH0vJHtjb25maWcucG9vbC5taW59LCBubyByZXBsaWNhdGlvbmApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkKSkge1xuICAgICAgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQgPSBbY29uZmlnLnJlcGxpY2F0aW9uLnJlYWRdO1xuICAgIH1cblxuICAgIC8vIE1hcCBtYWluIGNvbm5lY3Rpb24gY29uZmlnXG4gICAgY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlID0gXy5kZWZhdWx0cyhjb25maWcucmVwbGljYXRpb24ud3JpdGUsIF8ub21pdChjb25maWcsICdyZXBsaWNhdGlvbicpKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHRzIHRvIGVhY2ggcmVhZCBjb25maWdcbiAgICBjb25maWcucmVwbGljYXRpb24ucmVhZCA9IGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkLm1hcChyZWFkQ29uZmlnID0+XG4gICAgICBfLmRlZmF1bHRzKHJlYWRDb25maWcsIF8ub21pdCh0aGlzLmNvbmZpZywgJ3JlcGxpY2F0aW9uJykpXG4gICAgKTtcblxuICAgIC8vIGN1c3RvbSBwb29saW5nIGZvciByZXBsaWNhdGlvbiAob3JpZ2luYWwgYXV0aG9yIEBqYW5tZWllcilcbiAgICBsZXQgcmVhZHMgPSAwO1xuICAgIHRoaXMucG9vbCA9IHtcbiAgICAgIHJlbGVhc2U6IGNsaWVudCA9PiB7XG4gICAgICAgIGlmIChjbGllbnQucXVlcnlUeXBlID09PSAncmVhZCcpIHtcbiAgICAgICAgICB0aGlzLnBvb2wucmVhZC5yZWxlYXNlKGNsaWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wb29sLndyaXRlLnJlbGVhc2UoY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjcXVpcmU6IChxdWVyeVR5cGUsIHVzZU1hc3RlcikgPT4ge1xuICAgICAgICB1c2VNYXN0ZXIgPSB1c2VNYXN0ZXIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdXNlTWFzdGVyO1xuICAgICAgICBpZiAocXVlcnlUeXBlID09PSAnU0VMRUNUJyAmJiAhdXNlTWFzdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9vbC5yZWFkLmFjcXVpcmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb29sLndyaXRlLmFjcXVpcmUoKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBjb25uZWN0aW9uID0+IHtcbiAgICAgICAgdGhpcy5wb29sW2Nvbm5lY3Rpb24ucXVlcnlUeXBlXS5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICBkZWJ1ZygnY29ubmVjdGlvbiBkZXN0cm95Jyk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveUFsbE5vdzogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgdGhpcy5wb29sLnJlYWQuZGVzdHJveUFsbE5vdygpLFxuICAgICAgICAgIHRoaXMucG9vbC53cml0ZS5kZXN0cm95QWxsTm93KClcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZGVidWcoJ2FsbCBjb25uZWN0aW9ucyBkZXN0cm95ZWQnKTtcbiAgICAgIH0sXG4gICAgICBkcmFpbjogYXN5bmMgKCkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnBvb2wud3JpdGUuZHJhaW4oKSxcbiAgICAgICAgdGhpcy5wb29sLnJlYWQuZHJhaW4oKVxuICAgICAgXSksXG4gICAgICByZWFkOiBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6ICdzZXF1ZWxpemU6cmVhZCcsXG4gICAgICAgIGNyZWF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIHJvdW5kIHJvYmluIGNvbmZpZ1xuICAgICAgICAgIGNvbnN0IG5leHRSZWFkID0gcmVhZHMrKyAlIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdChjb25maWcucmVwbGljYXRpb24ucmVhZFtuZXh0UmVhZF0pO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnlUeXBlID0gJ3JlYWQnO1xuICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBjb25uZWN0aW9uID0+IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiksXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pLFxuICAgICAgd3JpdGU6IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbGl6ZTp3cml0ZScsXG4gICAgICAgIGNyZWF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSk7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeVR5cGUgPSAnd3JpdGUnO1xuICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBjb25uZWN0aW9uID0+IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiksXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcucG9vbC52YWxpZGF0ZSxcbiAgICAgICAgbWF4OiBjb25maWcucG9vbC5tYXgsXG4gICAgICAgIG1pbjogY29uZmlnLnBvb2wubWluLFxuICAgICAgICBhY3F1aXJlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuYWNxdWlyZSxcbiAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmlkbGUsXG4gICAgICAgIHJlYXBJbnRlcnZhbE1pbGxpczogY29uZmlnLnBvb2wuZXZpY3QsXG4gICAgICAgIG1heFVzZXM6IGNvbmZpZy5wb29sLm1heFVzZXNcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIGRlYnVnKGBwb29sIGNyZWF0ZWQgd2l0aCBtYXgvbWluOiAke2NvbmZpZy5wb29sLm1heH0vJHtjb25maWcucG9vbC5taW59LCB3aXRoIHJlcGxpY2F0aW9uYCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbm5lY3Rpb24gZnJvbSBwb29sLiBJdCBzZXRzIGRhdGFiYXNlIHZlcnNpb24gaWYgaXQncyBub3QgYWxyZWFkeSBzZXQuXG4gICAqIENhbGwgcG9vbC5hY3F1aXJlIHRvIGdldCBhIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICBQb29sIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMudHlwZV0gICAgICAgICAgICBTZXQgd2hpY2ggcmVwbGljYSB0byB1c2UuIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBgcmVhZGAgYW5kIGB3cml0ZWBcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMudXNlTWFzdGVyPWZhbHNlXSBGb3JjZSBtYXN0ZXIgb3Igd3JpdGUgcmVwbGljYSB0byBnZXQgY29ubmVjdGlvbiBmcm9tXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmICghdGhpcy52ZXJzaW9uUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QodGhpcy5jb25maWcucmVwbGljYXRpb24ud3JpdGUgfHwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgY29uc3QgX29wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgX29wdGlvbnMudHJhbnNhY3Rpb24gPSB7IGNvbm5lY3Rpb24gfTsgLy8gQ2hlYXQgLnF1ZXJ5IHRvIHVzZSBvdXIgcHJpdmF0ZSBjb25uZWN0aW9uXG4gICAgICAgICAgICBfb3B0aW9ucy5sb2dnaW5nID0gKCkgPT4ge307XG4gICAgICAgICAgICBfb3B0aW9ucy5sb2dnaW5nLl9fdGVzdExvZ2dpbmdGbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vY29ubmVjdGlvbiBtaWdodCBoYXZlIHNldCBkYXRhYmFzZVZlcnNpb24gdmFsdWUgYXQgaW5pdGlhbGl6YXRpb24sXG4gICAgICAgICAgICAvL2F2b2lkaW5nIGEgdXNlbGVzcyByb3VuZCB0cmlwXG4gICAgICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLmRhdGFiYXNlVmVyc2lvbihfb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZlcnNpb24gPSBfLmdldChzZW12ZXIuY29lcmNlKHZlcnNpb24pLCAndmVyc2lvbicpIHx8IHZlcnNpb247XG4gICAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLnZhbGlkKHBhcnNlZFZlcnNpb24pXG4gICAgICAgICAgICAgICAgPyBwYXJzZWRWZXJzaW9uXG4gICAgICAgICAgICAgICAgOiB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZW12ZXIubHQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sIHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgZGVwcmVjYXRpb25zLnVuc3VwcG9ydGVkRW5naW5lKCk7XG4gICAgICAgICAgICAgIGRlYnVnKGBVbnN1cHBvcnRlZCBkYXRhYmFzZSBlbmdpbmUgdmVyc2lvbiAke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy52ZXJzaW9uUHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucG9vbC5hY3F1aXJlKG9wdGlvbnMudHlwZSwgb3B0aW9ucy51c2VNYXN0ZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpIHRocm93IG5ldyBlcnJvcnMuQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgZGVidWcoJ2Nvbm5lY3Rpb24gYWNxdWlyZWQnKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSBhIHBvb2xlZCBjb25uZWN0aW9uIHNvIGl0IGNhbiBiZSB1dGlsaXplZCBieSBvdGhlciBjb25uZWN0aW9uIHJlcXVlc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLnBvb2wucmVsZWFzZShjb25uZWN0aW9uKTtcbiAgICBkZWJ1ZygnY29ubmVjdGlvbiByZWxlYXNlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgZGlhbGVjdCBsaWJyYXJ5IHRvIGdldCBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gY29uZmlnIENvbm5lY3Rpb24gY29uZmlnXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgX2Nvbm5lY3QoY29uZmlnKSB7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2JlZm9yZUNvbm5lY3QnLCBjb25maWcpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdChjb25maWcpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdhZnRlckNvbm5lY3QnLCBjb25uZWN0aW9uLCBjb25maWcpO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgZGlhbGVjdCBsaWJyYXJ5IHRvIGRpc2Nvbm5lY3QgYSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIF9kaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYmVmb3JlRGlzY29ubmVjdCcsIGNvbm5lY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYWZ0ZXJEaXNjb25uZWN0JywgY29ubmVjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgY29ubmVjdGlvbiBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgX3ZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci52YWxpZGF0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci52YWxpZGF0ZShjb25uZWN0aW9uKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgQWJzdHJhY3REaWFsZWN0IHt9XG5cbkFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSB7XG4gICdERUZBVUxUJzogdHJ1ZSxcbiAgJ0RFRkFVTFQgVkFMVUVTJzogZmFsc2UsXG4gICdWQUxVRVMgKCknOiBmYWxzZSxcbiAgJ0xJTUlUIE9OIFVQREFURSc6IGZhbHNlLFxuICAnT1JERVIgTlVMTFMnOiBmYWxzZSxcbiAgJ1VOSU9OJzogdHJ1ZSxcbiAgJ1VOSU9OIEFMTCc6IHRydWUsXG4gICdSSUdIVCBKT0lOJzogdHJ1ZSxcblxuICAvKiBkb2VzIHRoZSBkaWFsZWN0IHN1cHBvcnQgcmV0dXJuaW5nIHZhbHVlcyBmb3IgaW5zZXJ0ZWQvdXBkYXRlZCBmaWVsZHMgKi9cbiAgcmV0dXJuVmFsdWVzOiBmYWxzZSxcblxuICAvKiBmZWF0dXJlcyBzcGVjaWZpYyB0byBhdXRvSW5jcmVtZW50IHZhbHVlcyAqL1xuICBhdXRvSW5jcmVtZW50OiB7XG4gICAgLyogZG9lcyB0aGUgZGlhbGVjdCByZXF1aXJlIG1vZGlmaWNhdGlvbiBvZiBpbnNlcnQgcXVlcmllcyB3aGVuIGluc2VydGluZyBhdXRvIGluY3JlbWVudCBmaWVsZHMgKi9cbiAgICBpZGVudGl0eUluc2VydDogZmFsc2UsXG5cbiAgICAvKiBkb2VzIHRoZSBkaWFsZWN0IHN1cHBvcnQgaW5zZXJ0aW5nIGRlZmF1bHQvbnVsbCB2YWx1ZXMgZm9yIGF1dG9pbmNyZW1lbnQgZmllbGRzICovXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuXG4gICAgLyogZG9lcyB0aGUgZGlhbGVjdCBzdXBwb3J0IHVwZGF0aW5nIGF1dG9pbmNyZW1lbnQgZmllbGRzICovXG4gICAgdXBkYXRlOiB0cnVlXG4gIH0sXG4gIC8qIERvIHdlIG5lZWQgdG8gc2F5IERFRkFVTFQgZm9yIGJ1bGsgaW5zZXJ0ICovXG4gIGJ1bGtEZWZhdWx0OiBmYWxzZSxcbiAgc2NoZW1hczogZmFsc2UsXG4gIHRyYW5zYWN0aW9uczogdHJ1ZSxcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IHRydWUsXG4gIHRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIHR5cGU6IGZhbHNlXG4gIH0sXG4gIG1pZ3JhdGlvbnM6IHRydWUsXG4gIHVwc2VydHM6IHRydWUsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiAnJywgLyogZGlhbGVjdCBzcGVjaWZpYyB3b3JkcyBmb3IgSU5TRVJUIElHTk9SRSBvciBETyBOT1RISU5HICovXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IGZhbHNlLCAvKiB3aGV0aGVyIGRpYWxlY3Qgc3VwcG9ydHMgT04gRFVQTElDQVRFIEtFWSBVUERBVEUgKi9cbiAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiAnJyAvKiBkaWFsZWN0IHNwZWNpZmljIHdvcmRzIGZvciBPTiBDT05GTElDVCBETyBOT1RISU5HICovXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IHRydWUsXG4gICAgYWRkQ29uc3RyYWludDogdHJ1ZSxcbiAgICBkcm9wQ29uc3RyYWludDogdHJ1ZSxcbiAgICB1bmlxdWU6IHRydWUsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgY2hlY2s6IHRydWUsXG4gICAgZm9yZWlnbktleTogdHJ1ZSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogdHJ1ZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgY29uY3VycmVudGx5OiBmYWxzZSxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICB1c2luZzogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiBmYWxzZSxcbiAgICBvcGVyYXRvcjogZmFsc2VcbiAgfSxcbiAgam9pblRhYmxlRGVwZW5kZW50OiB0cnVlLFxuICBncm91cGVkTGltaXQ6IHRydWUsXG4gIGluZGV4VmlhQWx0ZXI6IGZhbHNlLFxuICBKU09OOiBmYWxzZSxcbiAgZGVmZXJyYWJsZUNvbnN0cmFpbnRzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdERpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5BYnN0cmFjdERpYWxlY3QgPSBBYnN0cmFjdERpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3REaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9kZXByZWNhdGlvbnMnKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3NxbC1zdHJpbmcnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi4vLi4vYXNzb2NpYXRpb25zL2Jhc2UnKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4uLy4uL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvJyk7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZSgnLi4vLi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueScpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoJy4uLy4uL2Fzc29jaWF0aW9ucy9oYXMtbWFueScpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvcnMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBJbmRleEhpbnRzID0gcmVxdWlyZSgnLi4vLi4vaW5kZXgtaGludHMnKTtcblxuY29uc3QgUXVvdGVIZWxwZXIgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvci9oZWxwZXJzL3F1b3RlJyk7XG5cbi8qKlxuICogQWJzdHJhY3QgUXVlcnkgR2VuZXJhdG9yXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnNlcXVlbGl6ZSkgdGhyb3cgbmV3IEVycm9yKCdRdWVyeUdlbmVyYXRvciBpbml0aWFsaXplZCB3aXRob3V0IG9wdGlvbnMuc2VxdWVsaXplJyk7XG4gICAgaWYgKCFvcHRpb25zLl9kaWFsZWN0KSB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5R2VuZXJhdG9yIGluaXRpYWxpemVkIHdpdGhvdXQgb3B0aW9ucy5fZGlhbGVjdCcpO1xuXG4gICAgdGhpcy5zZXF1ZWxpemUgPSBvcHRpb25zLnNlcXVlbGl6ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNlcXVlbGl6ZS5vcHRpb25zO1xuXG4gICAgLy8gZGlhbGVjdCBuYW1lXG4gICAgdGhpcy5kaWFsZWN0ID0gb3B0aW9ucy5fZGlhbGVjdC5uYW1lO1xuICAgIHRoaXMuX2RpYWxlY3QgPSBvcHRpb25zLl9kaWFsZWN0O1xuICB9XG5cbiAgZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYSB8fCBvcHRpb25zLnNjaGVtYSB8fCAncHVibGljJyxcbiAgICAgIHRhYmxlTmFtZTogXy5pc1BsYWluT2JqZWN0KHRhYmxlTmFtZSkgPyB0YWJsZU5hbWUudGFibGVOYW1lIDogdGFibGVOYW1lLFxuICAgICAgZGVsaW1pdGVyOiB0YWJsZU5hbWUuZGVsaW1pdGVyIHx8IG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcuJ1xuICAgIH07XG4gIH1cblxuICBhZGRTY2hlbWEocGFyYW0pIHtcbiAgICBpZiAoIXBhcmFtLl9zY2hlbWEpIHJldHVybiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW07XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlTmFtZTogcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtLFxuICAgICAgdGFibGU6IHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbSxcbiAgICAgIG5hbWU6IHBhcmFtLm5hbWUgfHwgcGFyYW0sXG4gICAgICBzY2hlbWE6IHBhcmFtLl9zY2hlbWEsXG4gICAgICBkZWxpbWl0ZXI6IHBhcmFtLl9zY2hlbWFEZWxpbWl0ZXIgfHwgJy4nLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnF1b3RlVGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGRyb3BTY2hlbWEodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUoXG4gICAgICB0aGlzLmFkZFNjaGVtYSh7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXJcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiBgREVTQ1JJQkUgJHt0YWJsZX07YDtcbiAgfVxuXG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX07YDtcbiAgfVxuXG4gIHJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcikge1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUoYmVmb3JlKX0gUkVOQU1FIFRPICR7dGhpcy5xdW90ZVRhYmxlKGFmdGVyKX07YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc2VydCBpbnRvIGNvbW1hbmRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZUhhc2ggICAgICAgYXR0cmlidXRlIHZhbHVlIHBhaXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbEF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5zZXJ0UXVlcnkodGFibGUsIHZhbHVlSGFzaCwgbW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgY29uc3QgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzID0gW107XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGUpO1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtID09PSB1bmRlZmluZWQgPyB0aGlzLmJpbmRQYXJhbShiaW5kKSA6IG9wdGlvbnMuYmluZFBhcmFtO1xuICAgIGxldCBxdWVyeTtcbiAgICBsZXQgdmFsdWVRdWVyeSA9ICcnO1xuICAgIGxldCBlbXB0eVF1ZXJ5ID0gJyc7XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gJyc7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gJyc7XG4gICAgbGV0IGlkZW50aXR5V3JhcHBlclJlcXVpcmVkID0gZmFsc2U7XG4gICAgbGV0IHRtcFRhYmxlID0gJyc7IC8vdG1wVGFibGUgZGVjbGFyYXRpb24gZm9yIHRyaWdnZXJcblxuICAgIGlmIChtb2RlbEF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChtb2RlbEF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ0RFRkFVTFQgVkFMVUVTJ10pIHtcbiAgICAgIGVtcHR5UXVlcnkgKz0gJyBERUZBVUxUIFZBTFVFUyc7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydWQUxVRVMgKCknXSkge1xuICAgICAgZW1wdHlRdWVyeSArPSAnIFZBTFVFUyAoKSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKG1vZGVsQXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5wdXNoKC4uLnJldHVyblZhbHVlcy5yZXR1cm5GaWVsZHMpO1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICB0bXBUYWJsZSA9IHJldHVyblZhbHVlcy50bXBUYWJsZSB8fCAnJztcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50IHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChfLmdldCh0aGlzLCBbJ3NlcXVlbGl6ZScsICdvcHRpb25zJywgJ2RpYWxlY3RPcHRpb25zJywgJ3ByZXBlbmRTZWFyY2hQYXRoJ10pIHx8IG9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgLy8gTm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgd2l0aCBzZWFyY2ggcGF0aCAocmVxdWlyZXMgb3V0cHV0IG9mIG11bHRpcGxlIHF1ZXJpZXMpXG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkVYQ0VQVElPTiAmJiBvcHRpb25zLmV4Y2VwdGlvbikge1xuICAgICAgLy8gTm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgd2l0aCBiaW5kIHBhcmFtZXRlcnMgKHJlcXVpcmVzIG91dHB1dCBvZiBtdWx0aXBsZSBxdWVyaWVzKVxuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2godmFsdWVIYXNoLCB0aGlzLm9wdGlvbnMub21pdE51bGwpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlSGFzaCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZUhhc2gsIGtleSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUhhc2hba2V5XTtcbiAgICAgICAgZmllbGRzLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSk7XG5cbiAgICAgICAgLy8gU0VSSUFMUycgY2FuJ3QgYmUgTlVMTCBpbiBwb3N0Z3Jlc3FsLCB1c2UgREVGQVVMVCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlICYmICF2YWx1ZSkge1xuICAgICAgICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgZmllbGRzLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkRFRkFVTFQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKCdERUZBVUxUJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZXNjYXBlKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdJTlNFUlQnIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdJTlNFUlQnIH0sIGJpbmRQYXJhbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9ICcnO1xuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSAmJiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlID09ICcgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVCcpIHsgLy8gcG9zdGdyZXMgLyBzcWxpdGVcbiAgICAgICAgLy8gSWYgbm8gY29uZmxpY3QgdGFyZ2V0IGNvbHVtbnMgd2VyZSBzcGVjaWZpZWQsIHVzZSB0aGUgcHJpbWFyeSBrZXkgbmFtZXMgZnJvbSBvcHRpb25zLnVwc2VydEtleXNcbiAgICAgICAgY29uc3QgY29uZmxpY3RLZXlzID0gb3B0aW9ucy51cHNlcnRLZXlzLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKGF0dHIgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PUVYQ0xVREVELiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCk7XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gYCBPTiBDT05GTElDVCAoJHtjb25mbGljdEtleXMuam9pbignLCcpfSkgRE8gVVBEQVRFIFNFVCAke3VwZGF0ZUtleXMuam9pbignLCcpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWx1ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcChhdHRyID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1WQUxVRVMoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0pYCk7XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlICs9IGAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZX0gJHt2YWx1ZUtleXMuam9pbignLCcpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuICAgICAgaWdub3JlRHVwbGljYXRlczogb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLmlnbm9yZUR1cGxpY2F0ZXMgOiAnJyxcbiAgICAgIG9uQ29uZmxpY3REb05vdGhpbmc6IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0RG9Ob3RoaW5nIDogJycsXG4gICAgICBhdHRyaWJ1dGVzOiBmaWVsZHMuam9pbignLCcpLFxuICAgICAgb3V0cHV0OiBvdXRwdXRGcmFnbWVudCxcbiAgICAgIHZhbHVlczogdmFsdWVzLmpvaW4oJywnKSxcbiAgICAgIHRtcFRhYmxlXG4gICAgfTtcblxuICAgIHZhbHVlUXVlcnkgPSBgJHt0bXBUYWJsZX1JTlNFUlQke3JlcGxhY2VtZW50cy5pZ25vcmVEdXBsaWNhdGVzfSBJTlRPICR7cXVvdGVkVGFibGV9ICgke3JlcGxhY2VtZW50cy5hdHRyaWJ1dGVzfSkke3JlcGxhY2VtZW50cy5vdXRwdXR9IFZBTFVFUyAoJHtyZXBsYWNlbWVudHMudmFsdWVzfSkke29uRHVwbGljYXRlS2V5VXBkYXRlfSR7cmVwbGFjZW1lbnRzLm9uQ29uZmxpY3REb05vdGhpbmd9JHt2YWx1ZVF1ZXJ5fWA7XG4gICAgZW1wdHlRdWVyeSA9IGAke3RtcFRhYmxlfUlOU0VSVCR7cmVwbGFjZW1lbnRzLmlnbm9yZUR1cGxpY2F0ZXN9IElOVE8gJHtxdW90ZWRUYWJsZX0ke3JlcGxhY2VtZW50cy5vdXRwdXR9JHtvbkR1cGxpY2F0ZUtleVVwZGF0ZX0ke3JlcGxhY2VtZW50cy5vbkNvbmZsaWN0RG9Ob3RoaW5nfSR7ZW1wdHlRdWVyeX1gO1xuXG4gICAgLy8gTW9zdGx5IGZvciBpbnRlcm5hbCB1c2UsIHNvIHdlIGV4cGVjdCB0aGUgdXNlciB0byBrbm93IHdoYXQgaGUncyBkb2luZyFcbiAgICAvLyBwZ190ZW1wIGZ1bmN0aW9ucyBhcmUgcHJpdmF0ZSBwZXIgY29ubmVjdGlvbiwgc28gd2UgbmV2ZXIgcmlzayB0aGlzIGZ1bmN0aW9uIGludGVyZmVyaW5nIHdpdGggYW5vdGhlciBvbmUuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuRVhDRVBUSU9OICYmIG9wdGlvbnMuZXhjZXB0aW9uKSB7XG4gICAgICBjb25zdCBkcm9wRnVuY3Rpb24gPSAnRFJPUCBGVU5DVElPTiBJRiBFWElTVFMgcGdfdGVtcC50ZXN0ZnVuYygpJztcblxuICAgICAgaWYgKHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLnB1c2goJyonKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsaW1pdGVyID0gYCRmdW5jXyR7dXVpZHY0KCkucmVwbGFjZSgvLS9nLCAnJyl9JGA7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeSA9IGBTRUxFQ1QgKHRlc3RmdW5jLnJlc3BvbnNlKS4ke3JldHVybmluZ01vZGVsQXR0cmlidXRlcy5qb2luKCcsICh0ZXN0ZnVuYy5yZXNwb25zZSkuJyl9LCB0ZXN0ZnVuYy5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiBGUk9NIHBnX3RlbXAudGVzdGZ1bmMoKTtgO1xuXG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbiA9ICdXSEVOIHVuaXF1ZV92aW9sYXRpb24gVEhFTiBHRVQgU1RBQ0tFRCBESUFHTk9TVElDUyBzZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiA9IFBHX0VYQ0VQVElPTl9ERVRBSUw7JztcbiAgICAgIHZhbHVlUXVlcnkgPSBgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gcGdfdGVtcC50ZXN0ZnVuYyhPVVQgcmVzcG9uc2UgJHtxdW90ZWRUYWJsZX0sIE9VVCBzZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiB0ZXh0KSBSRVRVUk5TIFJFQ09SRCBBUyAke2RlbGltaXRlcn0gQkVHSU4gJHt2YWx1ZVF1ZXJ5fSBSRVRVUk5JTkcgKiBJTlRPIHJlc3BvbnNlOyBFWENFUFRJT04gJHtvcHRpb25zLmV4Y2VwdGlvbn0gRU5EICR7ZGVsaW1pdGVyfSBMQU5HVUFHRSBwbHBnc3FsOyAke3NlbGVjdFF1ZXJ5fSAke2Ryb3BGdW5jdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVF1ZXJ5ICs9IHJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgZW1wdHlRdWVyeSArPSByZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG5cbiAgICBxdWVyeSA9IGAke3JlcGxhY2VtZW50cy5hdHRyaWJ1dGVzLmxlbmd0aCA/IHZhbHVlUXVlcnkgOiBlbXB0eVF1ZXJ5fTtgO1xuICAgIGlmIChpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQuaWRlbnRpdHlJbnNlcnQpIHtcbiAgICAgIHF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT047ICR7cXVlcnl9IFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT0ZGO2A7XG4gICAgfVxuXG4gICAgLy8gVXNlZCBieSBQb3N0Z3JlcyB1cHNlcnRRdWVyeSBhbmQgY2FsbHMgdG8gaGVyZSB3aXRoIG9wdGlvbnMuZXhjZXB0aW9uIHNldCB0byB0cnVlXG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gYmluZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5zZXJ0IGludG8gY29tbWFuZCBmb3IgbXVsdGlwbGUgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZFZhbHVlSGFzaGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGZpZWxkTWFwcGVkQXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IGZpZWxkTWFwcGVkQXR0cmlidXRlcyB8fCB7fTtcblxuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbHMgPSB7fTtcbiAgICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gW107XG4gICAgbGV0IG9uRHVwbGljYXRlS2V5VXBkYXRlID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIF8uZm9yT3duKGZpZWxkVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWFsbEF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICYmIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2VyaWFsc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcChrZXkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5idWxrRGVmYXVsdFxuICAgICAgICAgICYmIHNlcmlhbHNba2V5XSA9PT0gdHJ1ZVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZUhhc2hba2V5XSB8fCAnREVGQVVMVCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUoZmllbGRWYWx1ZUhhc2hba2V5XSwgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0sIHsgY29udGV4dDogJ0lOU0VSVCcgfSk7XG4gICAgICB9KTtcblxuICAgICAgdHVwbGVzLnB1c2goYCgke3ZhbHVlcy5qb2luKCcsJyl9KWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgJiYgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSA9PSAnIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVQnKSB7IC8vIHBvc3RncmVzIC8gc3FsaXRlXG4gICAgICAgIC8vIElmIG5vIGNvbmZsaWN0IHRhcmdldCBjb2x1bW5zIHdlcmUgc3BlY2lmaWVkLCB1c2UgdGhlIHByaW1hcnkga2V5IG5hbWVzIGZyb20gb3B0aW9ucy51cHNlcnRLZXlzXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0S2V5cyA9IG9wdGlvbnMudXBzZXJ0S2V5cy5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcChhdHRyID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1FWENMVURFRC4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWApO1xuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IGAgT04gQ09ORkxJQ1QgKCR7Y29uZmxpY3RLZXlzLmpvaW4oJywnKX0pIERPIFVQREFURSBTRVQgJHt1cGRhdGVLZXlzLmpvaW4oJywnKX1gO1xuICAgICAgfSBlbHNlIHsgLy8gbXlzcWwgLyBtYXJpYVxuICAgICAgICBjb25zdCB2YWx1ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcChhdHRyID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1WQUxVRVMoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0pYCk7XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gYCR7dGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlfSAke3ZhbHVlS2V5cy5qb2luKCcsJyl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpZ25vcmVEdXBsaWNhdGVzID0gb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLmlnbm9yZUR1cGxpY2F0ZXMgOiAnJztcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbignLCcpO1xuICAgIGNvbnN0IG9uQ29uZmxpY3REb05vdGhpbmcgPSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdERvTm90aGluZyA6ICcnO1xuICAgIGxldCByZXR1cm5pbmcgPSAnJztcblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhmaWVsZE1hcHBlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm5pbmcgKz0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdJTlNFUlQnLFxuICAgICAgaWdub3JlRHVwbGljYXRlcyxcbiAgICAgICdJTlRPJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYCgke2F0dHJpYnV0ZXN9KWAsXG4gICAgICAnVkFMVUVTJyxcbiAgICAgIHR1cGxlcy5qb2luKCcsJyksXG4gICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSxcbiAgICAgIG9uQ29uZmxpY3REb05vdGhpbmcsXG4gICAgICByZXR1cm5pbmcsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHVwZGF0ZSBxdWVyeVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyVmFsdWVIYXNoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3aGVyZSBBIGhhc2ggd2l0aCBjb25kaXRpb25zIChlLmcuIHtuYW1lOiAnZm9vJ30pIE9SIGFuIElEIGFzIGludGVnZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBhdHRyVmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMub21pdE51bGwsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gJyc7XG4gICAgbGV0IHRtcFRhYmxlID0gJyc7IC8vIHRtcFRhYmxlIGRlY2xhcmF0aW9uIGZvciB0cmlnZ2VyXG4gICAgbGV0IHN1ZmZpeCA9ICcnO1xuXG4gICAgaWYgKF8uZ2V0KHRoaXMsIFsnc2VxdWVsaXplJywgJ29wdGlvbnMnLCAnZGlhbGVjdE9wdGlvbnMnLCAncHJlcGVuZFNlYXJjaFBhdGgnXSkgfHwgb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICAvLyBOb3QgY3VycmVudGx5IHN1cHBvcnRlZCB3aXRoIHNlYXJjaCBwYXRoIChyZXF1aXJlcyBvdXRwdXQgb2YgbXVsdGlwbGUgcXVlcmllcylcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gPT09IHVuZGVmaW5lZCA/IHRoaXMuYmluZFBhcmFtKGJpbmQpIDogb3B0aW9ucy5iaW5kUGFyYW07XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snTElNSVQgT04gVVBEQVRFJ10gJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgaWYgKHRoaXMuZGlhbGVjdCAhPT0gJ21zc3FsJykge1xuICAgICAgICBzdWZmaXggPSBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgICBzdWZmaXggKz0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgICAgdG1wVGFibGUgPSByZXR1cm5WYWx1ZXMudG1wVGFibGUgfHwgJyc7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudCB8fCAnJztcblxuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHJldHVybiBvdXRwdXQgaXMgcHJvcGVybHkgbWFwcGVkIHRvIG1vZGVsIGZpZWxkcy5cbiAgICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMub3V0cHV0ICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIG9wdGlvbnMubWFwVG9Nb2RlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJWYWx1ZUhhc2gpIHtcbiAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmXG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJlxuICAgICAgICAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LnVwZGF0ZSkge1xuICAgICAgICAvLyBub3QgYWxsb3dlZCB0byB1cGRhdGUgaWRlbnRpdHkgY29sdW1uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJWYWx1ZUhhc2hba2V5XTtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnVVBEQVRFJyB9KX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdVUERBVEUnIH0sIGJpbmRQYXJhbSl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd2hlcmVPcHRpb25zID0geyAuLi5vcHRpb25zLCBiaW5kUGFyYW0gfTtcblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnkgPSBgJHt0bXBUYWJsZX1VUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oJywnKX0ke291dHB1dEZyYWdtZW50fSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX0ke3N1ZmZpeH1gLnRyaW0oKTtcbiAgICAvLyBVc2VkIGJ5IFBvc3RncmVzIHVwc2VydFF1ZXJ5IGFuZCBjYWxscyB0byBoZXJlIHdpdGggb3B0aW9ucy5leGNlcHRpb24gc2V0IHRvIHRydWVcbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgaWYgKG9wdGlvbnMuYmluZFBhcmFtICE9PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmJpbmQgPSBiaW5kO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gdXBkYXRlIHF1ZXJ5IHVzaW5nIGFyaXRobWV0aWMgb3BlcmF0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yICAgICAgICAgICAgICAgICAgICBTdHJpbmcgd2l0aCB0aGUgYXJpdGhtZXRpYyBvcGVyYXRvciAoZS5nLiAnKycgb3IgJy0nKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgICAgICAgICAgICAgIE5hbWUgb2YgdGhlIHRhYmxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3aGVyZSAgICAgICAgICAgICAgICAgICAgICAgQSBwbGFpbi1vYmplY3Qgd2l0aCBjb25kaXRpb25zIChlLmcuIHtuYW1lOiAnZm9vJ30pIE9SIGFuIElEIGFzIGludGVnZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluY3JlbWVudEFtb3VudHNCeUZpZWxkICAgICBBIHBsYWluLW9iamVjdCB3aXRoIGF0dHJpYnV0ZS12YWx1ZS1wYWlyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQgIEEgcGxhaW4tb2JqZWN0IHdpdGggYXR0cmlidXRlLXZhbHVlLXBhaXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcml0aG1ldGljUXVlcnkob3BlcmF0b3IsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgeyByZXR1cm5pbmc6IHRydWUgfSk7XG5cbiAgICBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgdGhpcy5vcHRpb25zLm9taXROdWxsKTtcblxuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9ICcnO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9ICcnO1xuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKG51bGwsIG9wdGlvbnMpO1xuXG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudDtcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZVNldFNxbEZyYWdtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmllbGQgaW4gaW5jcmVtZW50QW1vdW50c0J5RmllbGQpIHtcbiAgICAgIGNvbnN0IGluY3JlbWVudEFtb3VudCA9IGluY3JlbWVudEFtb3VudHNCeUZpZWxkW2ZpZWxkXTtcbiAgICAgIGNvbnN0IHF1b3RlZEZpZWxkID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgY29uc3QgZXNjYXBlZEFtb3VudCA9IHRoaXMuZXNjYXBlKGluY3JlbWVudEFtb3VudCk7XG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMucHVzaChgJHtxdW90ZWRGaWVsZH09JHtxdW90ZWRGaWVsZH0ke29wZXJhdG9yfSAke2VzY2FwZWRBbW91bnR9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGQgaW4gZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWRbZmllbGRdO1xuICAgICAgY29uc3QgcXVvdGVkRmllbGQgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICBjb25zdCBlc2NhcGVkVmFsdWUgPSB0aGlzLmVzY2FwZShuZXdWYWx1ZSk7XG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMucHVzaChgJHtxdW90ZWRGaWVsZH09JHtlc2NhcGVkVmFsdWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1VQREFURScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdTRVQnLFxuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLmpvaW4oJywnKSxcbiAgICAgIG91dHB1dEZyYWdtZW50LFxuICAgICAgdGhpcy53aGVyZVF1ZXJ5KHdoZXJlKSxcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50XG4gICAgXSk7XG4gIH1cblxuICAvKlxuICAgIFJldHVybnMgYW4gYWRkIGluZGV4IHF1ZXJ5LlxuICAgIFBhcmFtZXRlcnM6XG4gICAgICAtIHRhYmxlTmFtZSAtPiBOYW1lIG9mIGFuIGV4aXN0aW5nIHRhYmxlLCBwb3NzaWJseSB3aXRoIHNjaGVtYS5cbiAgICAgIC0gb3B0aW9uczpcbiAgICAgICAgLSB0eXBlOiBVTklRVUV8RlVMTFRFWFR8U1BBVElBTFxuICAgICAgICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBpbmRleC4gRGVmYXVsdCBpcyA8dGFibGU+XzxhdHRyMT5fPGF0dHIyPlxuICAgICAgICAtIGZpZWxkczogQW4gYXJyYXkgb2YgYXR0cmlidXRlcyBhcyBzdHJpbmcgb3IgYXMgaGFzaC5cbiAgICAgICAgICAgICAgICAgIElmIHRoZSBhdHRyaWJ1dGUgaXMgYSBoYXNoLCBpdCBtdXN0IGhhdmUgdGhlIGZvbGxvd2luZyBjb250ZW50OlxuICAgICAgICAgICAgICAgICAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlL2NvbHVtblxuICAgICAgICAgICAgICAgICAgLSBsZW5ndGg6IEFuIGludGVnZXIuIE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAtIG9yZGVyOiAnQVNDJyBvciAnREVTQycuIE9wdGlvbmFsXG4gICAgICAgIC0gcGFyc2VyXG4gICAgICAgIC0gdXNpbmdcbiAgICAgICAgLSBvcGVyYXRvclxuICAgICAgICAtIGNvbmN1cnJlbnRseTogUGFzcyBDT05DVVJSRU5UIHNvIG90aGVyIG9wZXJhdGlvbnMgcnVuIHdoaWxlIHRoZSBpbmRleCBpcyBjcmVhdGVkXG4gICAgICAtIHJhd1RhYmxlbmFtZSwgdGhlIG5hbWUgb2YgdGhlIHRhYmxlLCB3aXRob3V0IHNjaGVtYS4gVXNlZCB0byBjcmVhdGUgdGhlIG5hbWUgb2YgdGhlIGluZGV4XG4gICBAcHJpdmF0ZVxuICAqL1xuICBhZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICAgIG9wdGlvbnMgPSBhdHRyaWJ1dGVzO1xuICAgICAgYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBhdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgcmF3VGFibGVuYW1lIHx8IHRhYmxlTmFtZTtcbiAgICBpZiAob3B0aW9ucy5wcmVmaXggJiYgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeC5yZXBsYWNlKC9cXC4vZywgJ18nKTtcbiAgICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXgucmVwbGFjZSgvKFwifCcpL2csICcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZHNTcWwgPSBvcHRpb25zLmZpZWxkcy5tYXAoZmllbGQgPT4ge1xuICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICBuYW1lOiBmaWVsZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgICBpZiAoZmllbGQuYXR0cmlidXRlKSB7XG4gICAgICAgIGZpZWxkLm5hbWUgPSBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmllbGQubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgaW5kZXggZmllbGQgaGFzIG5vIG5hbWU6ICR7dXRpbC5pbnNwZWN0KGZpZWxkKX1gKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLm5hbWUpO1xuXG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5jb2xsYXRlICYmIGZpZWxkLmNvbGxhdGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAgQ09MTEFURSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLmNvbGxhdGUpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4Lm9wZXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yID0gZmllbGQub3BlcmF0b3IgfHwgb3B0aW9ucy5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAgJHtvcGVyYXRvcn1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4Lmxlbmd0aCAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHtmaWVsZC5sZW5ndGh9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5vcmRlcikge1xuICAgICAgICByZXN1bHQgKz0gYCAke2ZpZWxkLm9yZGVyfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgLy8gTW9zdGx5IGZvciBjYXNlcyB3aGVyZSBhZGRJbmRleCBpcyBjYWxsZWQgZGlyZWN0bHkgYnkgdGhlIHVzZXIgd2l0aG91dCBhbiBvcHRpb25zIG9iamVjdCAoZm9yIGV4YW1wbGUgaW4gbWlncmF0aW9ucylcbiAgICAgIC8vIEFsbCBjYWxscyB0aGF0IGdvIHRocm91Z2ggc2VxdWVsaXplIHNob3VsZCBhbHJlYWR5IGhhdmUgYSBuYW1lXG4gICAgICBvcHRpb25zID0gVXRpbHMubmFtZUluZGV4KG9wdGlvbnMsIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gTW9kZWwuX2NvbmZvcm1JbmRleChvcHRpb25zKTtcblxuICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC50eXBlKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0gdGhpcy53aGVyZVF1ZXJ5KG9wdGlvbnMud2hlcmUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmN1cnJlbnRseSA9IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXguY29uY3VycmVudGx5ICYmIG9wdGlvbnMuY29uY3VycmVudGx5ID8gJ0NPTkNVUlJFTlRMWScgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGluZDtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyKSB7XG4gICAgICBpbmQgPSBbXG4gICAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgY29uY3VycmVudGx5LFxuICAgICAgICAnQUREJ1xuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kID0gWydDUkVBVEUnXTtcbiAgICB9XG5cbiAgICBpbmQgPSBpbmQuY29uY2F0KFxuICAgICAgb3B0aW9ucy51bmlxdWUgPyAnVU5JUVVFJyA6ICcnLFxuICAgICAgb3B0aW9ucy50eXBlLCAnSU5ERVgnLFxuICAgICAgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlciA/IGNvbmN1cnJlbnRseSA6IHVuZGVmaW5lZCxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVycyhvcHRpb25zLm5hbWUpLFxuICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC51c2luZyA9PT0gMSAmJiBvcHRpb25zLnVzaW5nID8gYFVTSU5HICR7b3B0aW9ucy51c2luZ31gIDogJycsXG4gICAgICAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyID8gYE9OICR7dGFibGVOYW1lfWAgOiB1bmRlZmluZWQsXG4gICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnVzaW5nID09PSAyICYmIG9wdGlvbnMudXNpbmcgPyBgVVNJTkcgJHtvcHRpb25zLnVzaW5nfWAgOiAnJyxcbiAgICAgIGAoJHtmaWVsZHNTcWwuam9pbignLCAnKX0pYCxcbiAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgucGFyc2VyICYmIG9wdGlvbnMucGFyc2VyID8gYFdJVEggUEFSU0VSICR7b3B0aW9ucy5wYXJzZXJ9YCA6IHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgud2hlcmUgJiYgb3B0aW9ucy53aGVyZSA/IG9wdGlvbnMud2hlcmUgOiB1bmRlZmluZWRcbiAgICApO1xuXG4gICAgcmV0dXJuIF8uY29tcGFjdChpbmQpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGFibGVOYW1lLFxuICAgICAgJ0FERCcsXG4gICAgICB0aGlzLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyB8fCB7fSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50U25pcHBldCwgY29uc3RyYWludE5hbWU7XG5cbiAgICBjb25zdCBmaWVsZHNTcWwgPSBvcHRpb25zLmZpZWxkcy5tYXAoZmllbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkLmF0dHJpYnV0ZSkge1xuICAgICAgICBmaWVsZC5uYW1lID0gZmllbGQuYXR0cmlidXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIGluZGV4IGZpZWxkIGhhcyBubyBuYW1lOiAke2ZpZWxkfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQubmFtZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWVsZHNTcWxRdW90ZWRTdHJpbmcgPSBmaWVsZHNTcWwuam9pbignLCAnKTtcbiAgICBjb25zdCBmaWVsZHNTcWxTdHJpbmcgPSBmaWVsZHNTcWwuam9pbignXycpO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSkge1xuICAgICAgY2FzZSAnVU5JUVVFJzpcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fdWtgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBVTklRVUUgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NIRUNLJzpcbiAgICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KG9wdGlvbnMud2hlcmUpO1xuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9ja2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IENIRUNLICgke29wdGlvbnMud2hlcmV9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnREVGQVVMVCc6XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHZhbHVlIG11c3QgYmUgc3BlY2lmZWQgZm9yIERFRkFVTFQgQ09OU1RSQUlOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RpYWxlY3QubmFtZSAhPT0gJ21zc3FsJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCBjb25zdHJhaW50cyBhcmUgc3VwcG9ydGVkIG9ubHkgZm9yIE1TU1FMIGRpYWxlY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9kZmApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IERFRkFVTFQgKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5kZWZhdWx0VmFsdWUpfSkgRk9SICR7ZmllbGRzU3FsWzBdfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUFJJTUFSWSBLRVknOlxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9wa2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFBSSU1BUlkgS0VZICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGT1JFSUdOIEtFWSc6XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBvcHRpb25zLnJlZmVyZW5jZXM7XG4gICAgICAgIGlmICghcmVmZXJlbmNlcyB8fCAhcmVmZXJlbmNlcy50YWJsZSB8fCAhKHJlZmVyZW5jZXMuZmllbGQgfHwgcmVmZXJlbmNlcy5maWVsZHMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWZlcmVuY2VzIG9iamVjdCB3aXRoIHRhYmxlIGFuZCBmaWVsZCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9XyR7cmVmZXJlbmNlcy50YWJsZX1fZmtgKTtcbiAgICAgICAgY29uc3QgcXVvdGVkUmVmZXJlbmNlcyA9XG4gICAgICAgICAgdHlwZW9mIHJlZmVyZW5jZXMuZmllbGQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHRoaXMucXVvdGVJZGVudGlmaWVyKHJlZmVyZW5jZXMuZmllbGQpXG4gICAgICAgICAgICA6IHJlZmVyZW5jZXMuZmllbGRzLm1hcChmID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGYpKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzU25pcHBldCA9IGAke3RoaXMucXVvdGVUYWJsZShyZWZlcmVuY2VzLnRhYmxlKX0gKCR7cXVvdGVkUmVmZXJlbmNlc30pYDtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBgO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgRk9SRUlHTiBLRVkgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSkgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNTbmlwcGV0fWA7XG4gICAgICAgIGlmIChvcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBVUERBVEUgJHtvcHRpb25zLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbkRlbGV0ZSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gREVMRVRFICR7b3B0aW9ucy5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy50eXBlfSBpcyBpbnZhbGlkLmApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlZmVycmFibGUgJiYgWydVTklRVUUnLCAnUFJJTUFSWSBLRVknLCAnRk9SRUlHTiBLRVknXS5pbmNsdWRlcyhvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgJHt0aGlzLmRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdHJhaW50U25pcHBldDtcbiAgfVxuXG4gIHJlbW92ZUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgICdEUk9QIENPTlNUUkFJTlQnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXJzKGNvbnN0cmFpbnROYW1lKVxuICAgIF0pO1xuICB9XG5cbiAgLypcbiAgICBRdW90ZSBhbiBvYmplY3QgYmFzZWQgb24gaXRzIHR5cGUuIFRoaXMgaXMgYSBtb3JlIGdlbmVyYWwgdmVyc2lvbiBvZiBxdW90ZUlkZW50aWZpZXJzXG4gICAgU3RyaW5nczogc2hvdWxkIHByb3h5IHRvIHF1b3RlSWRlbnRpZmllcnNcbiAgICBBcnJheXM6XG4gICAgICAqIEV4cGVjdHMgYXJyYXkgaW4gdGhlIGZvcm06IFs8bW9kZWw+IChvcHRpb25hbCksIDxtb2RlbD4gKG9wdGlvbmFsKSwuLi4gU3RyaW5nLCBTdHJpbmcgKG9wdGlvbmFsKV1cbiAgICAgICAgRWFjaCA8bW9kZWw+IGNhbiBiZSBhIG1vZGVsLCBvciBhbiBvYmplY3Qge21vZGVsOiBNb2RlbCwgYXM6IFN0cmluZ30sIG1hdGNoaW5nIGluY2x1ZGUsIG9yIGFuXG4gICAgICAgIGFzc29jaWF0aW9uIG9iamVjdCwgb3IgdGhlIG5hbWUgb2YgYW4gYXNzb2NpYXRpb24uXG4gICAgICAqIFplcm8gb3IgbW9yZSBtb2RlbHMgY2FuIGJlIGluY2x1ZGVkIGluIHRoZSBhcnJheSBhbmQgYXJlIHVzZWQgdG8gdHJhY2UgYSBwYXRoIHRocm91Z2ggdGhlIHRyZWUgb2ZcbiAgICAgICAgaW5jbHVkZWQgbmVzdGVkIGFzc29jaWF0aW9ucy4gVGhpcyBwcm9kdWNlcyB0aGUgY29ycmVjdCB0YWJsZSBuYW1lIGZvciB0aGUgT1JERVIgQlkvR1JPVVAgQlkgU1FMXG4gICAgICAgIGFuZCBxdW90ZXMgaXQuXG4gICAgICAqIElmIGEgc2luZ2xlIHN0cmluZyBpcyBhcHBlbmRlZCB0byBlbmQgb2YgYXJyYXksIGl0IGlzIHF1b3RlZC5cbiAgICAgICAgSWYgdHdvIHN0cmluZ3MgYXBwZW5kZWQsIHRoZSAxc3Qgc3RyaW5nIGlzIHF1b3RlZCwgdGhlIDJuZCBzdHJpbmcgdW5xdW90ZWQuXG4gICAgT2JqZWN0czpcbiAgICAgICogSWYgcmF3IGlzIHNldCwgdGhhdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgdmVyYmF0aW0sIHdpdGhvdXQgcXVvdGluZ1xuICAgICAgKiBJZiBmbiBpcyBzZXQsIHRoZSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHZhbHVlIG9mIGZuLCBzdGFydGluZyBwYXJlbiwgZm9sbG93ZWQgYnlcbiAgICAgICAgdGhlIHZhbHVlcyBvZiBjb2xzICh3aGljaCBpcyBhc3N1bWVkIHRvIGJlIGFuIGFycmF5KSwgcXVvdGVkIGFuZCBqb2luZWQgd2l0aCAnLCAnLFxuICAgICAgICB1bmxlc3MgdGhleSBhcmUgdGhlbXNlbHZlcyBvYmplY3RzXG4gICAgICAqIElmIGRpcmVjdGlvbiBpcyBzZXQsIHNob3VsZCBiZSBwcmVwZW5kZWRcblxuICAgIEN1cnJlbnRseSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBmb3Igb3JkZXJpbmcgLyBncm91cGluZyBjb2x1bW5zIGFuZCBTZXF1ZWxpemUuY29sKCksIGJ1dCBpdCBjb3VsZFxuICAgIHBvdGVudGlhbGx5IGFsc28gYmUgdXNlZCBmb3Igb3RoZXIgcGxhY2VzIHdoZXJlIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBjYWxsIFNRTCBmdW5jdGlvbnMgKGUuZy4gYXMgZGVmYXVsdCB2YWx1ZXMpXG4gICBAcHJpdmF0ZVxuICAqL1xuICBxdW90ZShjb2xsZWN0aW9uLCBwYXJlbnQsIGNvbm5lY3Rvcikge1xuICAgIC8vIGluaXRcbiAgICBjb25zdCB2YWxpZE9yZGVyT3B0aW9ucyA9IFtcbiAgICAgICdBU0MnLFxuICAgICAgJ0RFU0MnLFxuICAgICAgJ0FTQyBOVUxMUyBMQVNUJyxcbiAgICAgICdERVNDIE5VTExTIExBU1QnLFxuICAgICAgJ0FTQyBOVUxMUyBGSVJTVCcsXG4gICAgICAnREVTQyBOVUxMUyBGSVJTVCcsXG4gICAgICAnTlVMTFMgRklSU1QnLFxuICAgICAgJ05VTExTIExBU1QnXG4gICAgXTtcblxuICAgIC8vIGRlZmF1bHRcbiAgICBjb25uZWN0b3IgPSBjb25uZWN0b3IgfHwgJy4nO1xuXG4gICAgLy8ganVzdCBxdW90ZSBhcyBpZGVudGlmaWVycyBpZiBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uIGFuZCBtdXRhdGUgb2JqZWN0cyBpbnRvIGFzc29jaWF0aW9uc1xuICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcbiAgICAgICAgbGV0IHByZXZpb3VzQXNzb2NpYXRpb247XG4gICAgICAgIGxldCBwcmV2aW91c01vZGVsO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcHJldmlvdXMgYXMgdGhlIHBhcmVudCB3aGVuIHByZXZpb3VzIGlzIHVuZGVmaW5lZCBvciB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NvY2lhdGlvblxuICAgICAgICBpZiAoIXByZXZpb3VzICYmIHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJldmlvdXNNb2RlbCA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cyBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgcHJldmlvdXNBc3NvY2lhdGlvbiA9IHByZXZpb3VzO1xuICAgICAgICAgIHByZXZpb3VzTW9kZWwgPSBwcmV2aW91cy50YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSBpcyBhIG1vZGVsLCB0aGVuIGF0dGVtcHQgZ2V0dGluZyBhbiBhc3NvY2lhdGlvblxuICAgICAgICBpZiAocHJldmlvdXNNb2RlbCAmJiBwcmV2aW91c01vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgbGV0IG1vZGVsO1xuICAgICAgICAgIGxldCBhcztcblxuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyAmJiBpdGVtLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICAgIG1vZGVsID0gaXRlbTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSAmJiBpdGVtLm1vZGVsICYmIGl0ZW0ubW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIHNldFxuICAgICAgICAgICAgbW9kZWwgPSBpdGVtLm1vZGVsO1xuICAgICAgICAgICAgYXMgPSBpdGVtLmFzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBhcyB0byBlaXRoZXIgdGhlIHRocm91Z2ggbmFtZSBvciB0aGUgbW9kZWwgbmFtZVxuICAgICAgICAgICAgaWYgKCFhcyAmJiBwcmV2aW91c0Fzc29jaWF0aW9uICYmIHByZXZpb3VzQXNzb2NpYXRpb24gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbiAmJiBwcmV2aW91c0Fzc29jaWF0aW9uLnRocm91Z2ggJiYgcHJldmlvdXNBc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsID09PSBtb2RlbCkge1xuICAgICAgICAgICAgICAvLyBnZXQgZnJvbSBwcmV2aW91cyBhc3NvY2lhdGlvblxuICAgICAgICAgICAgICBpdGVtID0gbmV3IEFzc29jaWF0aW9uKHByZXZpb3VzTW9kZWwsIG1vZGVsLCB7XG4gICAgICAgICAgICAgICAgYXM6IG1vZGVsLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBnZXQgYXNzb2NpYXRpb24gZnJvbSBwcmV2aW91cyBtb2RlbFxuICAgICAgICAgICAgICBpdGVtID0gcHJldmlvdXNNb2RlbC5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKG1vZGVsLCBhcyk7XG5cbiAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byB1c2UgdGhlIG1vZGVsIG5hbWUgaWYgdGhlIGl0ZW0gaXMgc3RpbGwgbnVsbFxuICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gcHJldmlvdXNNb2RlbC5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKG1vZGVsLCBtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBhc3NvY2lhdGlvblxuICAgICAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ1VuYWJsZSB0byBmaW5kIGEgdmFsaWQgYXNzb2NpYXRpb24gZm9yIG1vZGVsLCBcXCclc1xcJycsIG1vZGVsLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gZ2V0IG9yZGVyIGluZGV4XG4gICAgICAgICAgY29uc3Qgb3JkZXJJbmRleCA9IHZhbGlkT3JkZXJPcHRpb25zLmluZGV4T2YoaXRlbS50b1VwcGVyQ2FzZSgpKTtcblxuICAgICAgICAgIC8vIHNlZSBpZiB0aGlzIGlzIGFuIG9yZGVyXG4gICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBvcmRlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoYCAke3ZhbGlkT3JkZXJPcHRpb25zW29yZGVySW5kZXhdfWApO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb2RlbCAmJiBwcmV2aW91c01vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGdvIGRvd24gdGhpcyBwYXRoIGlmIHdlIGhhdmUgcHJlaXZvdXMgbW9kZWwgYW5kIGNoZWNrIG9ubHkgb25jZVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zICE9PSB1bmRlZmluZWQgJiYgcHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnNbaXRlbV0pIHtcbiAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgaXRlbSB0byBhbiBhc3NvY2lhdGlvblxuICAgICAgICAgICAgICBpdGVtID0gcHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnNbaXRlbV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtXSAmJiBpdGVtICE9PSBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbV0uZmllbGQpIHtcbiAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgaXRlbSBhdHRyaWJ1dGUgZnJvbSBpdHMgYWxpYXNcbiAgICAgICAgICAgICAgaXRlbSA9IHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtXS5maWVsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGl0ZW0uaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgICAmJiBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW1TcGxpdCA9IGl0ZW0uc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1TcGxpdFswXV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBxdW90ZSBpZGVudGlmaWVycyBmb3Igbm93XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMucXVvdGVJZGVudGlmaWVycyhgJHtwcmV2aW91c01vZGVsLm5hbWV9LiR7cHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1TcGxpdFswXV0uZmllbGR9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgcGF0aFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBpdGVtU3BsaXQuc2xpY2UoMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHBhdGhcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShpZGVudGlmaWVyLCBwYXRoKTtcblxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFwcGVuZCB0aGUgbW9kZWwgbmFtZSB3aGVuIHN0cmluZ1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbltpbmRleF0gPSBpdGVtO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhcnJheSwgYWRkaW5nIHRhYmxlIG5hbWVzIG9mIG1vZGVscyB0byBxdW90ZWRcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBbXTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGVjdGlvbkxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpdGVtID0gY29sbGVjdGlvbltpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyB8fCBpdGVtLl9tb2RlbEF0dHJpYnV0ZSB8fCBpdGVtIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgdGFibGVOYW1lc1tpXSA9IGl0ZW0uYXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnQgYnVpbGRpbmcgc3FsXG4gICAgICBsZXQgc3FsID0gJyc7XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBzcWwgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVOYW1lcy5qb2luKGNvbm5lY3RvcikpfS5gO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGVjdGlvblswXSA9PT0gJ3N0cmluZycgJiYgcGFyZW50KSB7XG4gICAgICAgIHNxbCArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJlbnQubmFtZSl9LmA7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBldmVyeXRoaW5nIHBhc3QgaSBhbmQgYXBwZW5kIHRvIHRoZSBzcWxcbiAgICAgIGNvbGxlY3Rpb24uc2xpY2UoaSkuZm9yRWFjaChjb2xsZWN0aW9uSXRlbSA9PiB7XG4gICAgICAgIHNxbCArPSB0aGlzLnF1b3RlKGNvbGxlY3Rpb25JdGVtLCBwYXJlbnQsIGNvbm5lY3Rvcik7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHNxbDtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24uX21vZGVsQXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5xdW90ZVRhYmxlKGNvbGxlY3Rpb24uTW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoY29sbGVjdGlvbi5maWVsZE5hbWUpfWA7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChfLmlzUGxhaW5PYmplY3QoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5yYXcpIHtcbiAgICAgIC8vIHNpbXBsZSBvYmplY3RzIHdpdGggcmF3IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGB7cmF3OiBcIi4uLlwifWAgc3ludGF4IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICBVc2UgYHNlcXVlbGl6ZS5saXRlcmFsYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RydWN0dXJlIHBhc3NlZCB0byBvcmRlciAvIGdyb3VwOiAke3V0aWwuaW5zcGVjdChjb2xsZWN0aW9uKX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBhIGxpc3Qgb2YgaWRlbnRpZmllcnMgYnkgXCIuXCIgYW5kIHF1b3RlIGVhY2ggcGFydFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gUXVvdGVIZWxwZXIucXVvdGVJZGVudGlmaWVyKHRoaXMuZGlhbGVjdCwgaWRlbnRpZmllciwge1xuICAgICAgZm9yY2UsXG4gICAgICBxdW90ZUlkZW50aWZpZXJzOiB0aGlzLm9wdGlvbnMucXVvdGVJZGVudGlmaWVyc1xuICAgIH0pO1xuICB9XG5cbiAgcXVvdGVJZGVudGlmaWVycyhpZGVudGlmaWVycykge1xuICAgIGlmIChpZGVudGlmaWVycy5pbmNsdWRlcygnLicpKSB7XG4gICAgICBpZGVudGlmaWVycyA9IGlkZW50aWZpZXJzLnNwbGl0KCcuJyk7XG5cbiAgICAgIGNvbnN0IGhlYWQgPSBpZGVudGlmaWVycy5zbGljZSgwLCBpZGVudGlmaWVycy5sZW5ndGggLSAxKS5qb2luKCctPicpO1xuICAgICAgY29uc3QgdGFpbCA9IGlkZW50aWZpZXJzW2lkZW50aWZpZXJzLmxlbmd0aCAtIDFdO1xuXG4gICAgICByZXR1cm4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaGVhZCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFpbCl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcnMpO1xuICB9XG5cbiAgcXVvdGVBdHRyaWJ1dGUoYXR0cmlidXRlLCBtb2RlbCkge1xuICAgIGlmIChtb2RlbCAmJiBhdHRyaWJ1dGUgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYXR0cmlidXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdW90ZSB0YWJsZSBuYW1lIHdpdGggb3B0aW9uYWwgYWxpYXMgYW5kIHNjaGVtYSBhdHRyaWJ1dGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICBwYXJhbSB0YWJsZSBzdHJpbmcgb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IGFsaWFzIGFsaWFzIG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHF1b3RlVGFibGUocGFyYW0sIGFsaWFzKSB7XG4gICAgbGV0IHRhYmxlID0gJyc7XG5cbiAgICBpZiAoYWxpYXMgPT09IHRydWUpIHtcbiAgICAgIGFsaWFzID0gcGFyYW0uYXMgfHwgcGFyYW0ubmFtZSB8fCBwYXJhbTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdChwYXJhbSkpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnNjaGVtYXMpIHtcbiAgICAgICAgaWYgKHBhcmFtLnNjaGVtYSkge1xuICAgICAgICAgIHRhYmxlICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtLnNjaGVtYSl9LmA7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZSArPSB0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbS50YWJsZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtLnNjaGVtYSkge1xuICAgICAgICAgIHRhYmxlICs9IHBhcmFtLnNjaGVtYSArIChwYXJhbS5kZWxpbWl0ZXIgfHwgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlICs9IHBhcmFtLnRhYmxlTmFtZTtcbiAgICAgICAgdGFibGUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0pO1xuICAgIH1cblxuICAgIGlmIChhbGlhcykge1xuICAgICAgdGFibGUgKz0gYCBBUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKX1gO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qXG4gICAgRXNjYXBlIGEgdmFsdWUgKGUuZy4gYSBzdHJpbmcsIG51bWJlciBvciBkYXRlKVxuICAgIEBwcml2YXRlXG4gICovXG4gIGVzY2FwZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC50eXBlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoZmllbGQudHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgICAvLyBVc2VycyBzaG91bGRuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGVzZSBhcmdzIC0ganVzdCBnaXZlIHRoZW0gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ1xuICAgICAgICAgIGNvbnN0IHNpbXBsZUVzY2FwZSA9IGVzY1ZhbCA9PiBTcWxTdHJpbmcuZXNjYXBlKGVzY1ZhbCwgdGhpcy5vcHRpb25zLnRpbWV6b25lLCB0aGlzLmRpYWxlY3QpO1xuXG4gICAgICAgICAgdmFsdWUgPSBmaWVsZC50eXBlLnN0cmluZ2lmeSh2YWx1ZSwgeyBlc2NhcGU6IHNpbXBsZUVzY2FwZSwgZmllbGQsIHRpbWV6b25lOiB0aGlzLm9wdGlvbnMudGltZXpvbmUsIG9wZXJhdGlvbjogb3B0aW9ucy5vcGVyYXRpb24gfSk7XG5cbiAgICAgICAgICBpZiAoZmllbGQudHlwZS5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBUaGUgZGF0YS10eXBlIGFscmVhZHkgZGlkIHRoZSByZXF1aXJlZCBlc2NhcGluZ1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnRpbWV6b25lLCB0aGlzLmRpYWxlY3QpO1xuICB9XG5cbiAgYmluZFBhcmFtKGJpbmQpIHtcbiAgICByZXR1cm4gdmFsdWUgPT4ge1xuICAgICAgYmluZC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBgJCR7YmluZC5sZW5ndGh9YDtcbiAgICB9O1xuICB9XG5cbiAgLypcbiAgICBSZXR1cm5zIGEgYmluZCBwYXJhbWV0ZXIgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSAoZS5nLiBhIHN0cmluZywgbnVtYmVyIG9yIGRhdGUpXG4gICAgQHByaXZhdGVcbiAgKi9cbiAgZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgYmluZFBhcmFtKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhc3MgU2VxdWVsaXplTWV0aG9kIGFzIGEgYmluZCBwYXJhbWV0ZXIgLSB1c2UgZXNjYXBlIGluc3RlYWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC50eXBlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoZmllbGQudHlwZS5iaW5kUGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQudHlwZS5iaW5kUGFyYW0odmFsdWUsIHsgZXNjYXBlOiBfLmlkZW50aXR5LCBmaWVsZCwgdGltZXpvbmU6IHRoaXMub3B0aW9ucy50aW1lem9uZSwgb3BlcmF0aW9uOiBvcHRpb25zLm9wZXJhdGlvbiwgYmluZFBhcmFtIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmRQYXJhbSh2YWx1ZSk7XG4gIH1cblxuICAvKlxuICAgIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIGZpZWxkIHNwZWNpZmljYXRpb25cbiAgICBAcHJpdmF0ZVxuICAqL1xuICB2YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy50eXBlVmFsaWRhdGlvbiAmJiBmaWVsZC50eXBlLnZhbGlkYXRlICYmIHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5pc0xpc3QgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkLnR5cGUudmFsaWRhdGUoaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkLnR5cGUudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICBlcnJvci5lcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAnVmFsaWRhdGlvbiBlcnJvcicsXG4gICAgICAgICAgICBmaWVsZC5maWVsZE5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBgJHtmaWVsZC50eXBlLmtleX0gdmFsaWRhdG9yYFxuICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNJZGVudGlmaWVyUXVvdGVkKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gUXVvdGVIZWxwZXIuaXNJZGVudGlmaWVyUXVvdGVkKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCBleHRyYWN0IEpTT04gcHJvcGVydHkgb2YgZ2l2ZW4gcGF0aC5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICAgICBjb2x1bW4gIFRoZSBKU09OIGNvbHVtblxuICAgKiBAcGFyYW0gICB7c3RyaW5nfEFycmF5PHN0cmluZz59IFtwYXRoXSAgVGhlIHBhdGggdG8gZXh0cmFjdCAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAganNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRoKSB7XG4gICAgbGV0IHBhdGhzID0gXy50b1BhdGgocGF0aCk7XG4gICAgbGV0IHBhdGhTdHI7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uID0gdGhpcy5pc0lkZW50aWZpZXJRdW90ZWQoY29sdW1uKVxuICAgICAgPyBjb2x1bW5cbiAgICAgIDogdGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKTtcblxuICAgIHN3aXRjaCAodGhpcy5kaWFsZWN0KSB7XG4gICAgICBjYXNlICdteXNxbCc6XG4gICAgICBjYXNlICdtYXJpYWRiJzpcbiAgICAgIGNhc2UgJ3NxbGl0ZSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24gZGlnaXQgc3ViIHBhdGhzIG5lZWQgdG8gYmUgcXVvdGVkIGFzIEVDTUFTY3JpcHQgaWRlbnRpZmllcnNcbiAgICAgICAgICogaHR0cHM6Ly9idWdzLm15c3FsLmNvbS9idWcucGhwP2lkPTgxODk2XG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaWFsZWN0ID09PSAnbXlzcWwnKSB7XG4gICAgICAgICAgcGF0aHMgPSBwYXRocy5tYXAoc3ViUGF0aCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gL1xcRC8udGVzdChzdWJQYXRoKVxuICAgICAgICAgICAgICA/IFV0aWxzLmFkZFRpY2tzKHN1YlBhdGgsICdcIicpXG4gICAgICAgICAgICAgIDogc3ViUGF0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhTdHIgPSB0aGlzLmVzY2FwZShbJyQnXVxuICAgICAgICAgIC5jb25jYXQocGF0aHMpXG4gICAgICAgICAgLmpvaW4oJy4nKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXC4oXFxkKykoPzooPz1cXC4pfCQpL2csIChfXywgZGlnaXQpID0+IGBbJHtkaWdpdH1dYCkpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpYWxlY3QgPT09ICdzcWxpdGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGBqc29uX2V4dHJhY3QoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBganNvbl91bnF1b3RlKGpzb25fZXh0cmFjdCgke3F1b3RlZENvbHVtbn0sJHtwYXRoU3RyfSkpYDtcblxuICAgICAgY2FzZSAncG9zdGdyZXMnOlxuICAgICAgICBwYXRoU3RyID0gdGhpcy5lc2NhcGUoYHske3BhdGhzLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiBgKCR7cXVvdGVkQ29sdW1ufSM+PiR7cGF0aFN0cn0pYDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCAke3RoaXMuZGlhbGVjdH0gZm9yIEpTT04gb3BlcmF0aW9uc2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgUmV0dXJucyBhIHF1ZXJ5IGZvciBzZWxlY3RpbmcgZWxlbWVudHMgaW4gdGhlIHRhYmxlIDx0YWJsZU5hbWU+LlxuICAgIE9wdGlvbnM6XG4gICAgICAtIGF0dHJpYnV0ZXMgLT4gQW4gYXJyYXkgb2YgYXR0cmlidXRlcyAoZS5nLiBbJ25hbWUnLCAnYmlydGhkYXknXSkuIERlZmF1bHQ6ICpcbiAgICAgIC0gd2hlcmUgLT4gQSBoYXNoIHdpdGggY29uZGl0aW9ucyAoZS5nLiB7bmFtZTogJ2Zvbyd9KVxuICAgICAgICAgICAgICAgICBPUiBhbiBJRCBhcyBpbnRlZ2VyXG4gICAgICAtIG9yZGVyIC0+IGUuZy4gJ2lkIERFU0MnXG4gICAgICAtIGdyb3VwXG4gICAgICAtIGxpbWl0IC0+IFRoZSBtYXhpbXVtIGNvdW50IHlvdSB3YW50IHRvIGdldC5cbiAgICAgIC0gb2Zmc2V0IC0+IEFuIG9mZnNldCB2YWx1ZSB0byBzdGFydCBmcm9tLiBPbmx5IHVzZWFibGUgd2l0aCBsaW1pdCFcbiAgIEBwcml2YXRlXG4gICovXG4gIHNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQ7XG4gICAgY29uc3QgbWFpblF1ZXJ5SXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdWJRdWVyeUl0ZW1zID0gW107XG4gICAgY29uc3Qgc3ViUXVlcnkgPSBvcHRpb25zLnN1YlF1ZXJ5ID09PSB1bmRlZmluZWQgPyBsaW1pdCAmJiBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gOiBvcHRpb25zLnN1YlF1ZXJ5O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBtYWluOiBvcHRpb25zLmF0dHJpYnV0ZXMgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzLnNsaWNlKCksXG4gICAgICBzdWJRdWVyeTogbnVsbFxuICAgIH07XG4gICAgY29uc3QgbWFpblRhYmxlID0ge1xuICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgcXVvdGVkTmFtZTogbnVsbCxcbiAgICAgIGFzOiBudWxsLFxuICAgICAgbW9kZWxcbiAgICB9O1xuICAgIGNvbnN0IHRvcExldmVsSW5mbyA9IHtcbiAgICAgIG5hbWVzOiBtYWluVGFibGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgc3ViUXVlcnlcbiAgICB9O1xuICAgIGxldCBtYWluSm9pblF1ZXJpZXMgPSBbXTtcbiAgICBsZXQgc3ViSm9pblF1ZXJpZXMgPSBbXTtcbiAgICBsZXQgcXVlcnk7XG5cbiAgICAvLyBBbGlhc2VzIGNhbiBiZSBwYXNzZWQgdGhyb3VnaCBzdWJxdWVyaWVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIHJlc2V0IHRoZW1cbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgIW9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgIG9wdGlvbnMuYWxpYXNlc01hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICAgICBvcHRpb25zLmFsaWFzZXNCeVRhYmxlID0ge307XG4gICAgICBvcHRpb25zLmluY2x1ZGVBbGlhc2VzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgdGFibGUgbmFtZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMudGFibGVBcykge1xuICAgICAgbWFpblRhYmxlLmFzID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy50YWJsZUFzKTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1haW5UYWJsZS5uYW1lKSAmJiBtYWluVGFibGUubW9kZWwpIHtcbiAgICAgIG1haW5UYWJsZS5hcyA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG1haW5UYWJsZS5tb2RlbC5uYW1lKTtcbiAgICB9XG5cbiAgICBtYWluVGFibGUucXVvdGVkTmFtZSA9ICFBcnJheS5pc0FycmF5KG1haW5UYWJsZS5uYW1lKSA/IHRoaXMucXVvdGVUYWJsZShtYWluVGFibGUubmFtZSkgOiB0YWJsZU5hbWUubWFwKHQgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLnF1b3RlVGFibGUodFswXSwgdFsxXSkgOiB0aGlzLnF1b3RlVGFibGUodCwgdHJ1ZSk7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChzdWJRdWVyeSAmJiBhdHRyaWJ1dGVzLm1haW4pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5QXR0IG9mIG1haW5UYWJsZS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcykge1xuICAgICAgICAvLyBDaGVjayBpZiBtYWluQXR0cmlidXRlcyBjb250YWluIHRoZSBwcmltYXJ5IGtleSBvZiB0aGUgbW9kZWwgZWl0aGVyIGFzIGEgZmllbGQgb3IgYW4gYWxpYXNlZCBmaWVsZFxuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMubWFpbi5zb21lKGF0dHIgPT4ga2V5QXR0ID09PSBhdHRyIHx8IGtleUF0dCA9PT0gYXR0clswXSB8fCBrZXlBdHQgPT09IGF0dHJbMV0pKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2gobWFpblRhYmxlLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5QXR0XS5maWVsZCA/IFtrZXlBdHQsIG1haW5UYWJsZS5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleUF0dF0uZmllbGRdIDoga2V5QXR0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMubWFpbiA9IHRoaXMuZXNjYXBlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLm1haW4sIG9wdGlvbnMsIG1haW5UYWJsZS5hcyk7XG4gICAgYXR0cmlidXRlcy5tYWluID0gYXR0cmlidXRlcy5tYWluIHx8IChvcHRpb25zLmluY2x1ZGUgPyBbYCR7bWFpblRhYmxlLmFzfS4qYF0gOiBbJyonXSk7XG5cbiAgICAvLyBJZiBzdWJxdWVyeSwgd2UgYWRkIHRoZSBtYWluQXR0cmlidXRlcyB0byB0aGUgc3ViUXVlcnkgYW5kIHNldCB0aGUgbWFpbkF0dHJpYnV0ZXMgdG8gc2VsZWN0ICogZnJvbSBzdWJxdWVyeVxuICAgIGlmIChzdWJRdWVyeSB8fCBvcHRpb25zLmdyb3VwZWRMaW1pdCkge1xuICAgICAgLy8gV2UgbmVlZCBwcmltYXJ5IGtleXNcbiAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLm1haW47XG4gICAgICBhdHRyaWJ1dGVzLm1haW4gPSBbYCR7bWFpblRhYmxlLmFzIHx8IG1haW5UYWJsZS5xdW90ZWROYW1lfS4qYF07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICBpZiAoaW5jbHVkZS5zZXBhcmF0ZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpvaW5RdWVyaWVzID0gdGhpcy5nZW5lcmF0ZUluY2x1ZGUoaW5jbHVkZSwgeyBleHRlcm5hbEFzOiBtYWluVGFibGUuYXMsIGludGVybmFsQXM6IG1haW5UYWJsZS5hcyB9LCB0b3BMZXZlbEluZm8pO1xuXG4gICAgICAgIHN1YkpvaW5RdWVyaWVzID0gc3ViSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgbWFpbkpvaW5RdWVyaWVzID0gbWFpbkpvaW5RdWVyaWVzLmNvbmNhdChqb2luUXVlcmllcy5tYWluUXVlcnkpO1xuXG4gICAgICAgIGlmIChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IF8udW5pcShhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gXy51bmlxKGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsLCBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzKSk7XG4gICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goc3ViSm9pblF1ZXJpZXMuam9pbignJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgICAgaWYgKCFtYWluVGFibGUuYXMpIHtcbiAgICAgICAgICBtYWluVGFibGUuYXMgPSBtYWluVGFibGUucXVvdGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aGVyZSA9IHsgLi4ub3B0aW9ucy53aGVyZSB9O1xuICAgICAgICBsZXQgZ3JvdXBlZExpbWl0T3JkZXIsXG4gICAgICAgICAgd2hlcmVLZXksXG4gICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICBncm91cGVkVGFibGVOYW1lID0gbWFpblRhYmxlLmFzO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cGVkTGltaXQub24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgd2hlcmVLZXkgPSBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbjtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiBpbnN0YW5jZW9mIEhhc01hbnkpIHtcbiAgICAgICAgICB3aGVyZUtleSA9IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLmZvcmVpZ25LZXlGaWVsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICAvLyBCVE0gaW5jbHVkZXMgbmVlZHMgdG8gam9pbiB0aGUgdGhyb3VnaCB0YWJsZSBvbiB0byBjaGVjayBJRFxuICAgICAgICAgIGdyb3VwZWRUYWJsZU5hbWUgPSBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5tYW55RnJvbVNvdXJjZS5hcztcbiAgICAgICAgICBjb25zdCBncm91cGVkTGltaXRPcHRpb25zID0gTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh7XG4gICAgICAgICAgICBpbmNsdWRlOiBbe1xuICAgICAgICAgICAgICBhc3NvY2lhdGlvbjogb3B0aW9ucy5ncm91cGVkTGltaXQub24ubWFueUZyb21Tb3VyY2UsXG4gICAgICAgICAgICAgIGR1cGxpY2F0aW5nOiBmYWxzZSwgLy8gVGhlIFVOSU9OJ2VkIHF1ZXJ5IG1heSBjb250YWluIGR1cGxpY2F0ZXMsIGJ1dCBlYWNoIHN1Yi1xdWVyeSBjYW5ub3RcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgW09wLnBsYWNlaG9sZGVyXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoICYmIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2gud2hlcmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBtb2RlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgam9pbiB0YWJsZSBhcmUgbWFwcGVkIGJhY2sgdG8gbW9kZWxzXG4gICAgICAgICAgb3B0aW9ucy5oYXNKb2luID0gdHJ1ZTtcbiAgICAgICAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgICAgIG9wdGlvbnMuaW5jbHVkZU1hcCA9IE9iamVjdC5hc3NpZ24oZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlTWFwLCBvcHRpb25zLmluY2x1ZGVNYXApO1xuICAgICAgICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzID0gZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlTmFtZXMuY29uY2F0KG9wdGlvbnMuaW5jbHVkZU5hbWVzIHx8IFtdKTtcbiAgICAgICAgICBpbmNsdWRlID0gZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vcmRlcikpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBvcmRlciBieSBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUgdG8gdGhlIHBhcmVudCBxdWVyeVxuICAgICAgICAgICAgb3B0aW9ucy5vcmRlci5mb3JFYWNoKChvcmRlciwgaSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyWzBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IGFsaWFzID0gYHN1YnF1ZXJ5X29yZGVyXyR7aX1gO1xuICAgICAgICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMucHVzaChbb3JkZXIsIGFsaWFzXSk7XG5cbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwcmVwZW5kIG1vZGVsIG5hbWUgd2hlbiB3ZSBhbGlhcyB0aGUgYXR0cmlidXRlcywgc28gcXVvdGUgdGhlbSBoZXJlXG4gICAgICAgICAgICAgIGFsaWFzID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlKGFsaWFzKSk7XG5cbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vcmRlcltpXSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9yZGVyW2ldWzBdID0gYWxpYXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcmRlcltpXSA9IGFsaWFzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3VwZWRMaW1pdE9yZGVyID0gb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3JkZXJpbmcgaXMgaGFuZGxlZCBieSB0aGUgc3VicXVlcmllcywgc28gb3JkZXJpbmcgdGhlIFVOSU9OJ2VkIHJlc3VsdCBpcyBub3QgbmVlZGVkXG4gICAgICAgICAgZ3JvdXBlZExpbWl0T3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIHdoZXJlW09wLnBsYWNlaG9sZGVyXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoaW5nIHRoZSBiYXNlIHF1ZXJ5IGFuZCBzcGxpY2luZyB0aGUgd2hlcmUgcGFydCBpbnRvIGl0IGlzIGNvbnNpc3RlbnRseSA+IHR3aWNlXG4gICAgICAgIC8vIGFzIGZhc3QgdGhhbiBnZW5lcmF0aW5nIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUgZm9yIHZhbHVlcy5sZW5ndGggPj0gNVxuICAgICAgICBjb25zdCBiYXNlUXVlcnkgPSBgU0VMRUNUICogRlJPTSAoJHt0aGlzLnNlbGVjdFF1ZXJ5KFxuICAgICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnMuZ3JvdXBlZExpbWl0LmxpbWl0LFxuICAgICAgICAgICAgb3JkZXI6IGdyb3VwZWRMaW1pdE9yZGVyLFxuICAgICAgICAgICAgYWxpYXNlc01hcHBpbmc6IG9wdGlvbnMuYWxpYXNlc01hcHBpbmcsXG4gICAgICAgICAgICBhbGlhc2VzQnlUYWJsZTogb3B0aW9ucy5hbGlhc2VzQnlUYWJsZSxcbiAgICAgICAgICAgIHdoZXJlLFxuICAgICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICAgIG1vZGVsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFxuICAgICAgICApLnJlcGxhY2UoLzskLywgJycpfSkgQVMgc3ViYDsgLy8gRXZlcnkgZGVyaXZlZCB0YWJsZSBtdXN0IGhhdmUgaXRzIG93biBhbGlhc1xuICAgICAgICBjb25zdCBwbGFjZUhvbGRlciA9IHRoaXMud2hlcmVJdGVtUXVlcnkoT3AucGxhY2Vob2xkZXIsIHRydWUsIHsgbW9kZWwgfSk7XG4gICAgICAgIGNvbnN0IHNwbGljZVBvcyA9IGJhc2VRdWVyeS5pbmRleE9mKHBsYWNlSG9sZGVyKTtcblxuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIGAoJHtcbiAgICAgICAgICBvcHRpb25zLmdyb3VwZWRMaW1pdC52YWx1ZXMubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cFdoZXJlO1xuICAgICAgICAgICAgaWYgKHdoZXJlS2V5KSB7XG4gICAgICAgICAgICAgIGdyb3VwV2hlcmUgPSB7XG4gICAgICAgICAgICAgICAgW3doZXJlS2V5XTogdmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGdyb3VwV2hlcmUgPSB7XG4gICAgICAgICAgICAgICAgW29wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLmZvcmVpZ25JZGVudGlmaWVyRmllbGRdOiB2YWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuc3BsaWNlU3RyKGJhc2VRdWVyeSwgc3BsaWNlUG9zLCBwbGFjZUhvbGRlci5sZW5ndGgsIHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKGdyb3VwV2hlcmUsIGdyb3VwZWRUYWJsZU5hbWUpKTtcbiAgICAgICAgICB9KS5qb2luKFxuICAgICAgICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snVU5JT04gQUxMJ10gPyAnIFVOSU9OIEFMTCAnIDogJyBVTklPTiAnXG4gICAgICAgICAgKVxuICAgICAgICB9KWAsIG1haW5UYWJsZS5hcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaCh0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCwgYXR0cmlidXRlcy5tYWluLCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzKSk7XG4gICAgICB9XG5cbiAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2gobWFpbkpvaW5RdWVyaWVzLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgV0hFUkUgdG8gc3ViIG9yIG1haW4gcXVlcnlcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd3aGVyZScpICYmICFvcHRpb25zLmdyb3VwZWRMaW1pdCkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKG9wdGlvbnMud2hlcmUsIG1haW5UYWJsZS5hcyB8fCB0YWJsZU5hbWUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIFdIRVJFICR7b3B0aW9ucy53aGVyZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgV0hFUkUgJHtvcHRpb25zLndoZXJlfWApO1xuICAgICAgICAgIC8vIFdhbGsgdGhlIG1haW4gcXVlcnkgdG8gdXBkYXRlIGFsbCBzZWxlY3RzXG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1NFTEVDVCcpKSB7XG4gICAgICAgICAgICAgIG1haW5RdWVyeUl0ZW1zW2tleV0gPSB0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIEdST1VQIEJZIHRvIHN1YiBvciBtYWluIHF1ZXJ5XG4gICAgaWYgKG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgIG9wdGlvbnMuZ3JvdXAgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuZ3JvdXApID8gb3B0aW9ucy5ncm91cC5tYXAodCA9PiB0aGlzLmFsaWFzR3JvdXBpbmcodCwgbW9kZWwsIG1haW5UYWJsZS5hcywgb3B0aW9ucykpLmpvaW4oJywgJykgOiB0aGlzLmFsaWFzR3JvdXBpbmcob3B0aW9ucy5ncm91cCwgbW9kZWwsIG1haW5UYWJsZS5hcywgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChzdWJRdWVyeSAmJiBvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIEdST1VQIEJZICR7b3B0aW9ucy5ncm91cH1gKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgR1JPVVAgQlkgJHtvcHRpb25zLmdyb3VwfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBIQVZJTkcgdG8gc3ViIG9yIG1haW4gcXVlcnlcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdoYXZpbmcnKSkge1xuICAgICAgb3B0aW9ucy5oYXZpbmcgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLmhhdmluZywgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgaWYgKG9wdGlvbnMuaGF2aW5nKSB7XG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIEhBVklORyAke29wdGlvbnMuaGF2aW5nfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBIQVZJTkcgJHtvcHRpb25zLmhhdmluZ31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBPUkRFUiB0byBzdWIgb3IgbWFpbiBxdWVyeVxuICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICBjb25zdCBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBzdWJRdWVyeSk7XG4gICAgICBpZiAob3JkZXJzLm1haW5RdWVyeU9yZGVyLmxlbmd0aCkge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgT1JERVIgQlkgJHtvcmRlcnMubWFpblF1ZXJ5T3JkZXIuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgT1JERVIgQlkgJHtvcmRlcnMuc3ViUXVlcnlPcmRlci5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBMSU1JVCwgT0ZGU0VUIHRvIHN1YiBvciBtYWluIHF1ZXJ5XG4gICAgY29uc3QgbGltaXRPcmRlciA9IHRoaXMuYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsKTtcbiAgICBpZiAobGltaXRPcmRlciAmJiAhb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2gobGltaXRPcmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGxpbWl0T3JkZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgdGhpcy5fdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLm1haW4sIHsgbW9kZWxOYW1lOiBtb2RlbCAmJiBtb2RlbC5uYW1lLCBhczogbWFpblRhYmxlLmFzIH0pO1xuICAgICAgcXVlcnkgPSBgU0VMRUNUICR7YXR0cmlidXRlcy5tYWluLmpvaW4oJywgJyl9IEZST00gKCR7c3ViUXVlcnlJdGVtcy5qb2luKCcnKX0pIEFTICR7bWFpblRhYmxlLmFzfSR7bWFpbkpvaW5RdWVyaWVzLmpvaW4oJycpfSR7bWFpblF1ZXJ5SXRlbXMuam9pbignJyl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBtYWluUXVlcnlJdGVtcy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2NrICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMubG9jaykge1xuICAgICAgbGV0IGxvY2sgPSBvcHRpb25zLmxvY2s7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jayA9IG9wdGlvbnMubG9jay5sZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2tLZXkgJiYgKGxvY2sgPT09ICdLRVkgU0hBUkUnIHx8IGxvY2sgPT09ICdOTyBLRVkgVVBEQVRFJykpIHtcbiAgICAgICAgcXVlcnkgKz0gYCBGT1IgJHtsb2NrfWA7XG4gICAgICB9IGVsc2UgaWYgKGxvY2sgPT09ICdTSEFSRScpIHtcbiAgICAgICAgcXVlcnkgKz0gYCAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuZm9yU2hhcmV9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5ICs9ICcgRk9SIFVQREFURSc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5sb2NrT2YgJiYgb3B0aW9ucy5sb2NrLm9mICYmIG9wdGlvbnMubG9jay5vZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICBxdWVyeSArPSBgIE9GICR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMubG9jay5vZi5uYW1lKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuc2tpcExvY2tlZCAmJiBvcHRpb25zLnNraXBMb2NrZWQpIHtcbiAgICAgICAgcXVlcnkgKz0gJyBTS0lQIExPQ0tFRCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG5cbiAgYWxpYXNHcm91cGluZyhmaWVsZCwgbW9kZWwsIHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNyYyA9IEFycmF5LmlzQXJyYXkoZmllbGQpID8gZmllbGRbMF0gOiBmaWVsZDtcblxuICAgIHJldHVybiB0aGlzLnF1b3RlKHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBzcmMsIG9wdGlvbnMpIHx8IHNyYywgbW9kZWwpO1xuICB9XG5cbiAgZXNjYXBlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRpb25zLCBtYWluVGFibGVBcykge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubWFwKGF0dHIgPT4ge1xuICAgICAgbGV0IGFkZFRhYmxlID0gdHJ1ZTtcblxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcbiAgICAgICAgaWYgKGF0dHIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pTT04uc3RyaW5naWZ5KGF0dHIpfSBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgZGVmaW5pdGlvbi4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogWydhdHRyaWJ1dGUgZGVmaW5pdGlvbicsICdhbGlhcyddYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IGF0dHIuc2xpY2UoKTtcblxuICAgICAgICBpZiAoYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIGF0dHJbMF0gPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyWzBdKTtcbiAgICAgICAgICBhZGRUYWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFhdHRyWzBdLmluY2x1ZGVzKCcoJykgJiYgIWF0dHJbMF0uaW5jbHVkZXMoJyknKSkge1xuICAgICAgICAgIGF0dHJbMF0gPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXByZWNhdGlvbnMubm9SYXdBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWFzID0gYXR0clsxXTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIG1haW5UYWJsZUFzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHIgPSBbYXR0clswXSwgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMpXS5qb2luKCcgQVMgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyID0gIWF0dHIuaW5jbHVkZXMoVXRpbHMuVElDS19DSEFSKSAmJiAhYXR0ci5pbmNsdWRlcygnXCInKVxuICAgICAgICAgID8gdGhpcy5xdW90ZUF0dHJpYnV0ZShhdHRyLCBvcHRpb25zLm1vZGVsKVxuICAgICAgICAgIDogdGhpcy5lc2NhcGUoYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmluY2x1ZGUpICYmICFhdHRyLmluY2x1ZGVzKCcuJykgJiYgYWRkVGFibGUpIHtcbiAgICAgICAgYXR0ciA9IGAke21haW5UYWJsZUFzfS4ke2F0dHJ9YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSk7XG4gIH1cblxuICBnZW5lcmF0ZUluY2x1ZGUoaW5jbHVkZSwgcGFyZW50VGFibGVOYW1lLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCBqb2luUXVlcmllcyA9IHtcbiAgICAgIG1haW5RdWVyeTogW10sXG4gICAgICBzdWJRdWVyeTogW11cbiAgICB9O1xuICAgIGNvbnN0IG1haW5DaGlsZEluY2x1ZGVzID0gW107XG4gICAgY29uc3Qgc3ViQ2hpbGRJbmNsdWRlcyA9IFtdO1xuICAgIGxldCByZXF1aXJlZE1pc21hdGNoID0gZmFsc2U7XG4gICAgY29uc3QgaW5jbHVkZUFzID0ge1xuICAgICAgaW50ZXJuYWxBczogaW5jbHVkZS5hcyxcbiAgICAgIGV4dGVybmFsQXM6IGluY2x1ZGUuYXNcbiAgICB9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBtYWluOiBbXSxcbiAgICAgIHN1YlF1ZXJ5OiBbXVxuICAgIH07XG4gICAgbGV0IGpvaW5RdWVyeTtcblxuICAgIHRvcExldmVsSW5mby5vcHRpb25zLmtleXNFc2NhcGVkID0gdHJ1ZTtcblxuICAgIGlmICh0b3BMZXZlbEluZm8ubmFtZXMubmFtZSAhPT0gcGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXMgJiYgdG9wTGV2ZWxJbmZvLm5hbWVzLmFzICE9PSBwYXJlbnRUYWJsZU5hbWUuZXh0ZXJuYWxBcykge1xuICAgICAgaW5jbHVkZUFzLmludGVybmFsQXMgPSBgJHtwYXJlbnRUYWJsZU5hbWUuaW50ZXJuYWxBc30tPiR7aW5jbHVkZS5hc31gO1xuICAgICAgaW5jbHVkZUFzLmV4dGVybmFsQXMgPSBgJHtwYXJlbnRUYWJsZU5hbWUuZXh0ZXJuYWxBc30uJHtpbmNsdWRlLmFzfWA7XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgaXMgdXNlZCBieSBhZ2dyZWdhdGUgZnVuY3Rpb25zXG4gICAgaWYgKHRvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzICE9PSBmYWxzZSkge1xuICAgICAgaW5jbHVkZS5tb2RlbC5fZXhwYW5kQXR0cmlidXRlcyhpbmNsdWRlKTtcbiAgICAgIFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG5cbiAgICAgIGNvbnN0IGluY2x1ZGVBdHRyaWJ1dGVzID0gaW5jbHVkZS5hdHRyaWJ1dGVzLm1hcChhdHRyID0+IHtcbiAgICAgICAgbGV0IGF0dHJBcyA9IGF0dHI7XG4gICAgICAgIGxldCB2ZXJiYXRpbSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgJiYgKFxuICAgICAgICAgICAgYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwgfHxcbiAgICAgICAgICAgIGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8XG4gICAgICAgICAgICBhdHRyWzBdIGluc3RhbmNlb2YgVXRpbHMuRm5cbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICB2ZXJiYXRpbSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0ciA9IGF0dHIubWFwKGF0dHIgPT4gYXR0ciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCA/IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIpIDogYXR0cik7XG5cbiAgICAgICAgICBhdHRyQXMgPSBhdHRyWzFdO1xuICAgICAgICAgIGF0dHIgPSBhdHRyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiBhdHRyLnZhbDsgLy8gV2UgdHJ1c3QgdGhlIHVzZXIgdG8gcmVuYW1lIHRoZSBmaWVsZCBjb3JyZWN0bHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkNhc3QgfHwgYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RyaWVkIHRvIHNlbGVjdCBhdHRyaWJ1dGVzIHVzaW5nIFNlcXVlbGl6ZS5jYXN0IG9yIFNlcXVlbGl6ZS5mbiB3aXRob3V0IHNwZWNpZnlpbmcgYW4gYWxpYXMgZm9yIHRoZSByZXN1bHQsIGR1cmluZyBlYWdlciBsb2FkaW5nLiAnICtcbiAgICAgICAgICAgICdUaGlzIG1lYW5zIHRoZSBhdHRyaWJ1dGUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHJldHVybmVkIGluc3RhbmNlJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHJlZml4O1xuICAgICAgICBpZiAodmVyYmF0aW0gPT09IHRydWUpIHtcbiAgICAgICAgICBwcmVmaXggPSBhdHRyO1xuICAgICAgICB9IGVsc2UgaWYgKC8jPj58LT4+Ly50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgcHJlZml4ID0gYCgke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uJHthdHRyLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpfSlgO1xuICAgICAgICB9IGVsc2UgaWYgKC9qc29uX2V4dHJhY3RcXCgvLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBhdHRyLnJlcGxhY2UoL2pzb25fZXh0cmFjdFxcKC9pLCBganNvbl9leHRyYWN0KCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVmaXggPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWxpYXMgPSBgJHtpbmNsdWRlQXMuZXh0ZXJuYWxBc30uJHthdHRyQXN9YDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIGluY2x1ZGVBcy5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICdBUycsXG4gICAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMsIHRydWUpXG4gICAgICAgIF0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAmJiB0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeS5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgaW5jbHVkZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vdGhyb3VnaFxuICAgIGlmIChpbmNsdWRlLnRocm91Z2gpIHtcbiAgICAgIGpvaW5RdWVyeSA9IHRoaXMuZ2VuZXJhdGVUaHJvdWdoSm9pbihpbmNsdWRlLCBpbmNsdWRlQXMsIHBhcmVudFRhYmxlTmFtZS5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICAgIGpvaW5RdWVyeSA9IHRoaXMuZ2VuZXJhdGVKb2luKGluY2x1ZGUsIHRvcExldmVsSW5mbyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHBvc3NpYmxlIG5ldyBhdHRyaWJ1dGVzIGNyZWF0ZWQgaW4gam9pblxuICAgIGlmIChqb2luUXVlcnkuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoam9pblF1ZXJ5LmF0dHJpYnV0ZXMubWFpbik7XG4gICAgfVxuXG4gICAgaWYgKGpvaW5RdWVyeS5hdHRyaWJ1dGVzLnN1YlF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChqb2luUXVlcnkuYXR0cmlidXRlcy5zdWJRdWVyeSk7XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZEluY2x1ZGUgb2YgaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChjaGlsZEluY2x1ZGUuc2VwYXJhdGUgfHwgY2hpbGRJbmNsdWRlLl9wc2V1ZG8pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkSm9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShjaGlsZEluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKTtcblxuICAgICAgICBpZiAoaW5jbHVkZS5yZXF1aXJlZCA9PT0gZmFsc2UgJiYgY2hpbGRJbmNsdWRlLnJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmVxdWlyZWRNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGlzIGEgc3ViIHF1ZXJ5IHdlIGp1c3QgZ2l2ZSBpdCB0byB0aGVcbiAgICAgICAgaWYgKGNoaWxkSW5jbHVkZS5zdWJRdWVyeSAmJiB0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJDaGlsZEluY2x1ZGVzLnB1c2goY2hpbGRKb2luUXVlcmllcy5zdWJRdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkSm9pblF1ZXJpZXMubWFpblF1ZXJ5KSB7XG4gICAgICAgICAgbWFpbkNoaWxkSW5jbHVkZXMucHVzaChjaGlsZEpvaW5RdWVyaWVzLm1haW5RdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4gPSBhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5zdWJRdWVyeS5jb25jYXQoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgaWYgKHJlcXVpcmVkTWlzbWF0Y2ggJiYgc3ViQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHtzdWJDaGlsZEluY2x1ZGVzLmpvaW4oJycpfSApIE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAke2pvaW5RdWVyeS5ib2R5fSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICAgIGlmIChzdWJDaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKHN1YkNoaWxkSW5jbHVkZXMuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChtYWluQ2hpbGRJbmNsdWRlcy5qb2luKCcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXF1aXJlZE1pc21hdGNoICYmIG1haW5DaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHttYWluQ2hpbGRJbmNsdWRlcy5qb2luKCcnKX0gKSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICR7am9pblF1ZXJ5LmJvZHl9IE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgICAgaWYgKG1haW5DaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChtYWluQ2hpbGRJbmNsdWRlcy5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goc3ViQ2hpbGRJbmNsdWRlcy5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1haW5RdWVyeTogam9pblF1ZXJpZXMubWFpblF1ZXJ5LmpvaW4oJycpLFxuICAgICAgc3ViUXVlcnk6IGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LmpvaW4oJycpLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH1cblxuICBfZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmUtYWxpYXMgaW4gY2FzZSBvZiBhIHN1YnF1ZXJ5XG4gICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhbGlhcyBjdXN0b20gc3VxdWVyeV9vcmRlcnNcbiAgICBpZiAoYWxpYXMubWF0Y2goL3N1YnF1ZXJ5X29yZGVyX1swLTldLykpIHtcbiAgICAgIHJldHVybiBhbGlhcztcbiAgICB9XG5cbiAgICBjb25zdCBtaW5pZmllZEFsaWFzID0gYF8ke29wdGlvbnMuYWxpYXNlc01hcHBpbmcuc2l6ZX1gO1xuXG4gICAgb3B0aW9ucy5hbGlhc2VzTWFwcGluZy5zZXQobWluaWZpZWRBbGlhcywgYWxpYXMpO1xuICAgIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF0gPSBtaW5pZmllZEFsaWFzO1xuXG4gICAgcmV0dXJuIG1pbmlmaWVkQWxpYXM7XG4gIH1cblxuICBfZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHtmaWVsZH1gXSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHtmaWVsZH1gXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZW5lcmF0ZUpvaW4oaW5jbHVkZSwgdG9wTGV2ZWxJbmZvKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IHBhcmVudCA9IGluY2x1ZGUucGFyZW50O1xuICAgIGNvbnN0IHBhcmVudElzVG9wID0gISFwYXJlbnQgJiYgIWluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsLm5hbWUgPT09IHRvcExldmVsSW5mby5vcHRpb25zLm1vZGVsLm5hbWU7XG4gICAgbGV0ICRwYXJlbnQ7XG4gICAgbGV0IGpvaW5XaGVyZTtcbiAgICAvKiBBdHRyaWJ1dGVzIGZvciB0aGUgbGVmdCBzaWRlICovXG4gICAgY29uc3QgbGVmdCA9IGFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICBjb25zdCBhdHRyTGVmdCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID9cbiAgICAgIGFzc29jaWF0aW9uLmlkZW50aWZpZXIgOlxuICAgICAgYXNzb2NpYXRpb24uc291cmNlS2V5QXR0cmlidXRlIHx8IGxlZnQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBjb25zdCBmaWVsZExlZnQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/XG4gICAgICBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQgOlxuICAgICAgbGVmdC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnNvdXJjZUtleUF0dHJpYnV0ZSB8fCBsZWZ0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkO1xuICAgIGxldCBhc0xlZnQ7XG4gICAgLyogQXR0cmlidXRlcyBmb3IgdGhlIHJpZ2h0IHNpZGUgKi9cbiAgICBjb25zdCByaWdodCA9IGluY2x1ZGUubW9kZWw7XG4gICAgY29uc3QgdGFibGVSaWdodCA9IHJpZ2h0LmdldFRhYmxlTmFtZSgpO1xuICAgIGNvbnN0IGZpZWxkUmlnaHQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/XG4gICAgICByaWdodC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnRhcmdldElkZW50aWZpZXIgfHwgcmlnaHQucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgOlxuICAgICAgYXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkO1xuICAgIGxldCBhc1JpZ2h0ID0gaW5jbHVkZS5hcztcblxuICAgIHdoaWxlICgoJHBhcmVudCA9ICRwYXJlbnQgJiYgJHBhcmVudC5wYXJlbnQgfHwgaW5jbHVkZS5wYXJlbnQpICYmICRwYXJlbnQuYXNzb2NpYXRpb24pIHtcbiAgICAgIGlmIChhc0xlZnQpIHtcbiAgICAgICAgYXNMZWZ0ID0gYCR7JHBhcmVudC5hc30tPiR7YXNMZWZ0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc0xlZnQgPSAkcGFyZW50LmFzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXNMZWZ0KSBhc0xlZnQgPSBwYXJlbnQuYXMgfHwgcGFyZW50Lm1vZGVsLm5hbWU7XG4gICAgZWxzZSBhc1JpZ2h0ID0gYCR7YXNMZWZ0fS0+JHthc1JpZ2h0fWA7XG5cbiAgICBsZXQgam9pbk9uID0gYCR7dGhpcy5xdW90ZVRhYmxlKGFzTGVmdCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRMZWZ0KX1gO1xuICAgIGNvbnN0IHN1YnF1ZXJ5QXR0cmlidXRlcyA9IFtdO1xuXG4gICAgaWYgKHRvcExldmVsSW5mby5vcHRpb25zLmdyb3VwZWRMaW1pdCAmJiBwYXJlbnRJc1RvcCB8fCB0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgaW5jbHVkZS5wYXJlbnQuc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkpIHtcbiAgICAgIGlmIChwYXJlbnRJc1RvcCkge1xuICAgICAgICAvLyBUaGUgbWFpbiBtb2RlbCBhdHRyaWJ1dGVzIGlzIG5vdCBhbGlhc2VkIHRvIGEgcHJlZml4XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShwYXJlbnQuYXMgfHwgcGFyZW50Lm1vZGVsLm5hbWUpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBwb3RlbnRpYWwgYWxpYXNlZCBKT0lOIGNvbmRpdGlvblxuICAgICAgICBqb2luT24gPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgYXR0ckxlZnQsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckxlZnQpfWA7XG5cbiAgICAgICAgaWYgKHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICAgIHN1YnF1ZXJ5QXR0cmlidXRlcy5wdXNoKGAke3RhYmxlTmFtZX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZExlZnQpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBqb2luU291cmNlID0gYCR7YXNMZWZ0LnJlcGxhY2UoLy0+L2csICcuJyl9LiR7YXR0ckxlZnR9YDtcblxuICAgICAgICAvLyBDaGVjayBmb3IgcG90ZW50aWFsIGFsaWFzZWQgSk9JTiBjb25kaXRpb25cbiAgICAgICAgam9pbk9uID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZChhc0xlZnQsIGpvaW5Tb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCB0aGlzLnF1b3RlSWRlbnRpZmllcihqb2luU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBqb2luT24gKz0gYCA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRSaWdodCl9YDtcblxuICAgIGlmIChpbmNsdWRlLm9uKSB7XG4gICAgICBqb2luT24gPSB0aGlzLndoZXJlSXRlbXNRdWVyeShpbmNsdWRlLm9uLCB7XG4gICAgICAgIHByZWZpeDogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihhc1JpZ2h0KSksXG4gICAgICAgIG1vZGVsOiBpbmNsdWRlLm1vZGVsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS53aGVyZSkge1xuICAgICAgam9pbldoZXJlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaW5jbHVkZS53aGVyZSwge1xuICAgICAgICBwcmVmaXg6IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCkpLFxuICAgICAgICBtb2RlbDogaW5jbHVkZS5tb2RlbFxuICAgICAgfSk7XG4gICAgICBpZiAoam9pbldoZXJlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLm9yKSB7XG4gICAgICAgICAgam9pbk9uICs9IGAgT1IgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luT24gKz0gYCBBTkQgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiBhc1JpZ2h0Lmxlbmd0aCA+IDYzKSB7XG4gICAgICBjb25zdCBhbGlhcyA9IGAlJHt0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlQWxpYXNlcy5zaXplfWA7XG5cbiAgICAgIHRvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVBbGlhc2VzLnNldChhbGlhcywgYXNSaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGpvaW46IGluY2x1ZGUucmVxdWlyZWQgPyAnSU5ORVIgSk9JTicgOiBpbmNsdWRlLnJpZ2h0ICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ1JJR0hUIEpPSU4nXSA/ICdSSUdIVCBPVVRFUiBKT0lOJyA6ICdMRUZUIE9VVEVSIEpPSU4nLFxuICAgICAgYm9keTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlUmlnaHQsIGFzUmlnaHQpLFxuICAgICAgY29uZGl0aW9uOiBqb2luT24sXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIG1haW46IFtdLFxuICAgICAgICBzdWJRdWVyeTogc3VicXVlcnlBdHRyaWJ1dGVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBTUUwgZnJhZ21lbnRzIHRvIGhhbmRsZSByZXR1cm5pbmcgdGhlIGF0dHJpYnV0ZXMgZnJvbSBhbiBpbnNlcnQvdXBkYXRlIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG1vZGVsQXR0cmlidXRlcyBBbiBvYmplY3Qgd2l0aCB0aGUgbW9kZWwgYXR0cmlidXRlcy5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdlbmVyYXRlUmV0dXJuVmFsdWVzKG1vZGVsQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJldHVybkZpZWxkcyA9IFtdO1xuICAgIGNvbnN0IHJldHVyblR5cGVzID0gW107XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gJyc7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gJyc7XG4gICAgbGV0IHRtcFRhYmxlID0gJyc7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJldHVybmluZykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKC4uLm9wdGlvbnMucmV0dXJuaW5nLm1hcChmaWVsZCA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpKTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsQXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKG1vZGVsQXR0cmlidXRlcywgYXR0cmlidXRlID0+IHtcbiAgICAgICAgaWYgKCEoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVklSVFVBTCkpIHtcbiAgICAgICAgICByZXR1cm5GaWVsZHMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuZmllbGQpKTtcbiAgICAgICAgICByZXR1cm5UeXBlcy5wdXNoKGF0dHJpYnV0ZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNFbXB0eShyZXR1cm5GaWVsZHMpKSB7XG4gICAgICByZXR1cm5GaWVsZHMucHVzaCgnKicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5yZXR1cm5pbmcpIHtcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gYCBSRVRVUk5JTkcgJHtyZXR1cm5GaWVsZHMuam9pbignLCcpfWA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5vdXRwdXQpIHtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gYCBPVVRQVVQgJHtyZXR1cm5GaWVsZHMubWFwKGZpZWxkID0+IGBJTlNFUlRFRC4ke2ZpZWxkfWApLmpvaW4oJywnKX1gO1xuXG4gICAgICAvL1RvIGNhcHR1cmUgb3V0cHV0IHJvd3Mgd2hlbiB0aGVyZSBpcyBhIHRyaWdnZXIgb24gTVNTUUwgREJcbiAgICAgIGlmIChvcHRpb25zLmhhc1RyaWdnZXIgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy50bXBUYWJsZVRyaWdnZXIpIHtcbiAgICAgICAgY29uc3QgdG1wQ29sdW1ucyA9IHJldHVybkZpZWxkcy5tYXAoKGZpZWxkLCBpKSA9PiBgJHtmaWVsZH0gJHtyZXR1cm5UeXBlc1tpXS50b1NxbCgpfWApO1xuXG4gICAgICAgIHRtcFRhYmxlID0gYERFQ0xBUkUgQHRtcCBUQUJMRSAoJHt0bXBDb2x1bW5zLmpvaW4oJywnKX0pOyBgO1xuICAgICAgICBvdXRwdXRGcmFnbWVudCArPSAnIElOVE8gQHRtcCc7XG4gICAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gJzsgU0VMRUNUICogRlJPTSBAdG1wJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBvdXRwdXRGcmFnbWVudCwgcmV0dXJuRmllbGRzLCByZXR1cm5pbmdGcmFnbWVudCwgdG1wVGFibGUgfTtcbiAgfVxuXG4gIGdlbmVyYXRlVGhyb3VnaEpvaW4oaW5jbHVkZSwgaW5jbHVkZUFzLCBwYXJlbnRUYWJsZU5hbWUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IHRocm91Z2ggPSBpbmNsdWRlLnRocm91Z2g7XG4gICAgY29uc3QgdGhyb3VnaFRhYmxlID0gdGhyb3VnaC5tb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICBjb25zdCB0aHJvdWdoQXMgPSBgJHtpbmNsdWRlQXMuaW50ZXJuYWxBc30tPiR7dGhyb3VnaC5hc31gO1xuICAgIGNvbnN0IGV4dGVybmFsVGhyb3VnaEFzID0gYCR7aW5jbHVkZUFzLmV4dGVybmFsQXN9LiR7dGhyb3VnaC5hc31gO1xuICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gdGhyb3VnaC5hdHRyaWJ1dGVzLm1hcChhdHRyID0+IHtcbiAgICAgIGxldCBhbGlhcyA9IGAke2V4dGVybmFsVGhyb3VnaEFzfS4ke0FycmF5LmlzQXJyYXkoYXR0cikgPyBhdHRyWzFdIDogYXR0cn1gO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCB0aHJvdWdoQXMsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKEFycmF5LmlzQXJyYXkoYXR0cikgPyBhdHRyWzBdIDogYXR0cil9YCxcbiAgICAgICAgJ0FTJyxcbiAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMpXG4gICAgICBdKTtcbiAgICB9KTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgcGFyZW50SXNUb3AgPSAhaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwubmFtZSA9PT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubW9kZWwubmFtZTtcbiAgICBjb25zdCB0YWJsZVNvdXJjZSA9IHBhcmVudFRhYmxlTmFtZTtcbiAgICBjb25zdCBpZGVudFNvdXJjZSA9IGFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcbiAgICBjb25zdCB0YWJsZVRhcmdldCA9IGluY2x1ZGVBcy5pbnRlcm5hbEFzO1xuICAgIGNvbnN0IGlkZW50VGFyZ2V0ID0gYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXJGaWVsZDtcbiAgICBjb25zdCBhdHRyVGFyZ2V0ID0gYXNzb2NpYXRpb24udGFyZ2V0S2V5RmllbGQ7XG5cbiAgICBjb25zdCBqb2luVHlwZSA9IGluY2x1ZGUucmVxdWlyZWQgPyAnSU5ORVIgSk9JTicgOiBpbmNsdWRlLnJpZ2h0ICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ1JJR0hUIEpPSU4nXSA/ICdSSUdIVCBPVVRFUiBKT0lOJyA6ICdMRUZUIE9VVEVSIEpPSU4nO1xuICAgIGxldCBqb2luQm9keTtcbiAgICBsZXQgam9pbkNvbmRpdGlvbjtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogW10sXG4gICAgICBzdWJRdWVyeTogW11cbiAgICB9O1xuICAgIGxldCBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5O1xuICAgIGxldCBzb3VyY2VKb2luT247XG4gICAgbGV0IHRhcmdldEpvaW5PbjtcbiAgICBsZXQgdGhyb3VnaFdoZXJlO1xuICAgIGxldCB0YXJnZXRXaGVyZTtcblxuICAgIGlmICh0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlSWdub3JlQXR0cmlidXRlcyAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIFRocm91Z2ggaW5jbHVkZXMgYXJlIGFsd2F5cyBoYXNNYW55LCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGUgYXR0cmlidXRlcyB0byB0aGUgbWFpbkF0dHJpYnV0ZXMgbm8gbWF0dGVyIHdoYXQgKFJlYWwgam9pbiB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkIGluIHN1YnF1ZXJ5KVxuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHRocm91Z2hBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCB0byB1c2UgZmllbGQgb3IgYXR0cmlidXRlXG4gICAgaWYgKCF0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgIGF0dHJTb3VyY2UgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSAmJiAhaW5jbHVkZS5wYXJlbnQuc3ViUXVlcnkgJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwgIT09IHRvcExldmVsSW5mby5vcHRpb25zLm1haW5Nb2RlbCkge1xuICAgICAgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBzdGF0ZW1lbnQgZm9yIGxlZnQgc2lkZSBvZiB0aHJvdWdoXG4gICAgLy8gVXNlZCBieSBib3RoIGpvaW4gYW5kIHN1YnF1ZXJ5IHdoZXJlXG4gICAgLy8gSWYgcGFyZW50IGluY2x1ZGUgd2FzIGluIGEgc3VicXVlcnkgbmVlZCB0byBqb2luIG9uIHRoZSBhbGlhc2VkIGF0dHJpYnV0ZVxuICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkgJiYgaW5jbHVkZS5wYXJlbnQuc3ViUXVlcnkgJiYgIXBhcmVudElzVG9wKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgbWluaWZ5aW5nIGFsaWFzZXMgYW5kIG91ciBKT0lOIHRhcmdldCBoYXMgYmVlbiBtaW5pZmllZCwgd2UgbmVlZCB0byB1c2UgdGhlIGFsaWFzIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNvbHVtbiBuYW1lXG4gICAgICBjb25zdCBqb2luU291cmNlID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZVNvdXJjZSwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gLCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gO1xuXG4gICAgICBzb3VyY2VKb2luT24gPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihqb2luU291cmNlKX0gPSBgO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgbWluaWZ5aW5nIGFsaWFzZXMgYW5kIG91ciBKT0lOIHRhcmdldCBoYXMgYmVlbiBtaW5pZmllZCwgd2UgbmVlZCB0byB1c2UgdGhlIGFsaWFzIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNvbHVtbiBuYW1lXG4gICAgICBjb25zdCBhbGlhc2VkU291cmNlID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZVNvdXJjZSwgYXR0clNvdXJjZSwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IGF0dHJTb3VyY2U7XG5cbiAgICAgIHNvdXJjZUpvaW5PbiA9IGAke3RoaXMucXVvdGVUYWJsZSh0YWJsZVNvdXJjZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXNlZFNvdXJjZSl9ID0gYDtcbiAgICB9XG4gICAgc291cmNlSm9pbk9uICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRTb3VyY2UpfWA7XG5cbiAgICAvLyBGaWx0ZXIgc3RhdGVtZW50IGZvciByaWdodCBzaWRlIG9mIHRocm91Z2hcbiAgICAvLyBVc2VkIGJ5IGJvdGggam9pbiBhbmQgc3VicXVlcnkgd2hlcmVcbiAgICB0YXJnZXRKb2luT24gPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZVRhcmdldCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0clRhcmdldCl9ID0gYDtcbiAgICB0YXJnZXRKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFRhcmdldCl9YDtcblxuICAgIGlmICh0aHJvdWdoLndoZXJlKSB7XG4gICAgICB0aHJvdWdoV2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh0aHJvdWdoLndoZXJlLCB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcykpLCB0aHJvdWdoLm1vZGVsKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5qb2luVGFibGVEZXBlbmRlbnQpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgd3JhcHBlZCBqb2luIHNvIHRoYXQgdGhlIHRocm91Z2ggdGFibGUgam9pbiBjYW4gYmUgZGVwZW5kZW50IG9uIHRoZSB0YXJnZXQgam9pblxuICAgICAgam9pbkJvZHkgPSBgKCAke3RoaXMucXVvdGVUYWJsZSh0aHJvdWdoVGFibGUsIHRocm91Z2hBcyl9IElOTkVSIEpPSU4gJHt0aGlzLnF1b3RlVGFibGUoaW5jbHVkZS5tb2RlbC5nZXRUYWJsZU5hbWUoKSwgaW5jbHVkZUFzLmludGVybmFsQXMpfSBPTiAke3RhcmdldEpvaW5Pbn1gO1xuICAgICAgaWYgKHRocm91Z2hXaGVyZSkge1xuICAgICAgICBqb2luQm9keSArPSBgIEFORCAke3Rocm91Z2hXaGVyZX1gO1xuICAgICAgfVxuICAgICAgam9pbkJvZHkgKz0gJyknO1xuICAgICAgam9pbkNvbmRpdGlvbiA9IHNvdXJjZUpvaW5PbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2VuZXJhdGUgam9pbiBTUUwgZm9yIGxlZnQgc2lkZSBvZiB0aHJvdWdoXG4gICAgICBqb2luQm9keSA9IGAke3RoaXMucXVvdGVUYWJsZSh0aHJvdWdoVGFibGUsIHRocm91Z2hBcyl9IE9OICR7c291cmNlSm9pbk9ufSAke2pvaW5UeXBlfSAke3RoaXMucXVvdGVUYWJsZShpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCBpbmNsdWRlQXMuaW50ZXJuYWxBcyl9YDtcbiAgICAgIGpvaW5Db25kaXRpb24gPSB0YXJnZXRKb2luT247XG4gICAgICBpZiAodGhyb3VnaFdoZXJlKSB7XG4gICAgICAgIGpvaW5Db25kaXRpb24gKz0gYCBBTkQgJHt0aHJvdWdoV2hlcmV9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS53aGVyZSB8fCBpbmNsdWRlLnRocm91Z2gud2hlcmUpIHtcbiAgICAgIGlmIChpbmNsdWRlLndoZXJlKSB7XG4gICAgICAgIHRhcmdldFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoaW5jbHVkZS53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcykpLCBpbmNsdWRlLm1vZGVsLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIGlmICh0YXJnZXRXaGVyZSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gKz0gYCBBTkQgJHt0YXJnZXRXaGVyZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgam9pbjogam9pblR5cGUsXG4gICAgICBib2R5OiBqb2luQm9keSxcbiAgICAgIGNvbmRpdGlvbjogam9pbkNvbmRpdGlvbixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9XG5cbiAgLypcbiAgICogR2VuZXJhdGVzIHN1YlF1ZXJ5RmlsdGVyIC0gYSBzZWxlY3QgbmVzdGVkIGluIHRoZSB3aGVyZSBjbGF1c2Ugb2YgdGhlIHN1YlF1ZXJ5LlxuICAgKiBGb3IgYSBnaXZlbiBpbmNsdWRlIGEgcXVlcnkgaXMgZ2VuZXJhdGVkIHRoYXQgY29udGFpbnMgYWxsIHRoZSB3YXkgZnJvbSB0aGUgc3ViUXVlcnlcbiAgICogdGFibGUgdG8gdGhlIGluY2x1ZGUgdGFibGUgcGx1cyBldmVyeXRoaW5nIHRoYXQncyBpbiByZXF1aXJlZCB0cmFuc2l0aXZlIGNsb3N1cmUgb2YgdGhlXG4gICAqIGdpdmVuIGluY2x1ZGUuXG4gICAqL1xuICBfZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbykge1xuICAgIGlmICghdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5IHx8ICFpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZSkge1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmUgPSB7fTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGluY2x1ZGU7XG4gICAgbGV0IGNoaWxkID0gaW5jbHVkZTtcbiAgICBsZXQgbmVzdGVkSW5jbHVkZXMgPSB0aGlzLl9nZXRSZXF1aXJlZENsb3N1cmUoaW5jbHVkZSkuaW5jbHVkZTtcbiAgICBsZXQgcXVlcnk7XG5cbiAgICB3aGlsZSAoKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChwYXJlbnQucGFyZW50ICYmICFwYXJlbnQucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGdlbmVyYXRlIHN1YlF1ZXJ5RmlsdGVyIGlmIGFsbCB0aGUgcGFyZW50cyBvZiB0aGlzIGluY2x1ZGUgYXJlIHJlcXVpcmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQuc3ViUXVlcnlGaWx0ZXIpIHtcbiAgICAgICAgLy8gdGhlIGluY2x1ZGUgaXMgYWxyZWFkeSBoYW5kbGVkIGFzIHRoaXMgcGFyZW50IGhhcyB0aGUgaW5jbHVkZSBvbiBpdHMgcmVxdWlyZWQgY2xvc3VyZVxuICAgICAgICAvLyBza2lwIHRvIHByZXZlbnQgZHVwbGljYXRlIHN1YlF1ZXJ5RmlsdGVyXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmVzdGVkSW5jbHVkZXMgPSBbeyAuLi5jaGlsZCwgaW5jbHVkZTogbmVzdGVkSW5jbHVkZXMsIGF0dHJpYnV0ZXM6IFtdIH1dO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgdG9wSW5jbHVkZSA9IG5lc3RlZEluY2x1ZGVzWzBdO1xuICAgIGNvbnN0IHRvcFBhcmVudCA9IHRvcEluY2x1ZGUucGFyZW50O1xuICAgIGNvbnN0IHRvcEFzc29jaWF0aW9uID0gdG9wSW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICB0b3BJbmNsdWRlLmFzc29jaWF0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRvcEluY2x1ZGUudGhyb3VnaCAmJiBPYmplY3QodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSA9PT0gdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSB7XG4gICAgICBxdWVyeSA9IHRoaXMuc2VsZWN0UXVlcnkodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwucHJpbWFyeUtleUZpZWxkXSxcbiAgICAgICAgaW5jbHVkZTogTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh7XG4gICAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgICBpbmNsdWRlOiBbe1xuICAgICAgICAgICAgYXNzb2NpYXRpb246IHRvcEFzc29jaWF0aW9uLnRvVGFyZ2V0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICB3aGVyZTogdG9wSW5jbHVkZS53aGVyZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHRvcEluY2x1ZGUuaW5jbHVkZVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pLmluY2x1ZGUsXG4gICAgICAgIG1vZGVsOiB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoW1xuICAgICAgICAgICAgICBgJHt0aGlzLnF1b3RlVGFibGUodG9wUGFyZW50Lm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQpfWAsXG4gICAgICAgICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQpfWBcbiAgICAgICAgICAgIF0uam9pbignID0gJykpLFxuICAgICAgICAgICAgdG9wSW5jbHVkZS50aHJvdWdoLndoZXJlXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICB9LCB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc0JlbG9uZ3NUbyA9IHRvcEFzc29jaWF0aW9uLmFzc29jaWF0aW9uVHlwZSA9PT0gJ0JlbG9uZ3NUbyc7XG4gICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IGlzQmVsb25nc1RvID8gdG9wQXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkIDogdG9wQXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQgfHwgdG9wUGFyZW50Lm1vZGVsLnByaW1hcnlLZXlGaWVsZDtcbiAgICAgIGNvbnN0IHRhcmdldEZpZWxkID0gaXNCZWxvbmdzVG8gPyB0b3BBc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZCB8fCB0b3BJbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlGaWVsZCA6IHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcblxuICAgICAgY29uc3Qgam9pbiA9IFtcbiAgICAgICAgYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wSW5jbHVkZS5hcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFyZ2V0RmllbGQpfWAsXG4gICAgICAgIGAke3RoaXMucXVvdGVUYWJsZSh0b3BQYXJlbnQuYXMgfHwgdG9wUGFyZW50Lm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHNvdXJjZUZpZWxkKX1gXG4gICAgICBdLmpvaW4oJyA9ICcpO1xuXG4gICAgICBxdWVyeSA9IHRoaXMuc2VsZWN0UXVlcnkodG9wSW5jbHVkZS5tb2RlbC5nZXRUYWJsZU5hbWUoKSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiBbdGFyZ2V0RmllbGRdLFxuICAgICAgICBpbmNsdWRlOiBNb2RlbC5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKHRvcEluY2x1ZGUpLmluY2x1ZGUsXG4gICAgICAgIG1vZGVsOiB0b3BJbmNsdWRlLm1vZGVsLFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgICAgICB0b3BJbmNsdWRlLndoZXJlLFxuICAgICAgICAgICAgeyBbT3Auam9pbl06IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoam9pbikgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgIHRhYmxlQXM6IHRvcEluY2x1ZGUuYXMsXG4gICAgICAgIGluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZVxuICAgICAgfSwgdG9wSW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdKSB7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdID0gW107XG4gICAgfVxuXG4gICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmVbYF9fJHtpbmNsdWRlQXMuaW50ZXJuYWxBc31gXSA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoW1xuICAgICAgJygnLFxuICAgICAgcXVlcnkucmVwbGFjZSgvOyQvLCAnJyksXG4gICAgICAnKScsXG4gICAgICAnSVMgTk9UIE5VTEwnXG4gICAgXS5qb2luKCcgJykpO1xuICB9XG5cbiAgLypcbiAgICogRm9yIGEgZ2l2ZW4gaW5jbHVkZSBoaWVyYXJjaHkgY3JlYXRlcyBhIGNvcHkgb2YgaXQgd2hlcmUgb25seSB0aGUgcmVxdWlyZWQgaW5jbHVkZXNcbiAgICogYXJlIHByZXNlcnZlZC5cbiAgICovXG4gIF9nZXRSZXF1aXJlZENsb3N1cmUoaW5jbHVkZSkge1xuICAgIGNvbnN0IGNvcHkgPSB7IC4uLmluY2x1ZGUsIGF0dHJpYnV0ZXM6IFtdLCBpbmNsdWRlOiBbXSB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5jbHVkZS5pbmNsdWRlKSkge1xuICAgICAgY29weS5pbmNsdWRlID0gaW5jbHVkZS5pbmNsdWRlXG4gICAgICAgIC5maWx0ZXIoaSA9PiBpLnJlcXVpcmVkKVxuICAgICAgICAubWFwKGluYyA9PiB0aGlzLl9nZXRSZXF1aXJlZENsb3N1cmUoaW5jKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBnZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpIHtcbiAgICBjb25zdCBtYWluUXVlcnlPcmRlciA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5T3JkZXIgPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXIpKSB7XG4gICAgICBmb3IgKGxldCBvcmRlciBvZiBvcHRpb25zLm9yZGVyKSB7XG5cbiAgICAgICAgLy8gd3JhcCBpZiBub3QgYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9yZGVyKSkge1xuICAgICAgICAgIG9yZGVyID0gW29yZGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdWJRdWVyeVxuICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkob3JkZXIpXG4gICAgICAgICAgJiYgb3JkZXJbMF1cbiAgICAgICAgICAmJiAhKG9yZGVyWzBdIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pXG4gICAgICAgICAgJiYgISh0eXBlb2Ygb3JkZXJbMF0gPT09ICdmdW5jdGlvbicgJiYgb3JkZXJbMF0ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpXG4gICAgICAgICAgJiYgISh0eXBlb2Ygb3JkZXJbMF0ubW9kZWwgPT09ICdmdW5jdGlvbicgJiYgb3JkZXJbMF0ubW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpXG4gICAgICAgICAgJiYgISh0eXBlb2Ygb3JkZXJbMF0gPT09ICdzdHJpbmcnICYmIG1vZGVsICYmIG1vZGVsLmFzc29jaWF0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmFzc29jaWF0aW9uc1tvcmRlclswXV0pXG4gICAgICAgICkge1xuICAgICAgICAgIHN1YlF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlKG9yZGVyLCBtb2RlbCwgJy0+JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgc3ViLXF1ZXJ5IHJlbmFtZXMgYXR0cmlidXRlIHdlIHdhbnQgdG8gb3JkZXIgYnksXG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2lzc3Vlcy84NzM5XG4gICAgICAgICAgY29uc3Qgc3ViUXVlcnlBdHRyaWJ1dGUgPSBvcHRpb25zLmF0dHJpYnV0ZXMuZmluZChhID0+IEFycmF5LmlzQXJyYXkoYSkgJiYgYVswXSA9PT0gb3JkZXJbMF0gJiYgYVsxXSk7XG4gICAgICAgICAgaWYgKHN1YlF1ZXJ5QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5uYW1lKTtcblxuICAgICAgICAgICAgb3JkZXJbMF0gPSBuZXcgVXRpbHMuQ29sKHRoaXMuX2dldEFsaWFzRm9yRmllbGQobW9kZWxOYW1lLCBzdWJRdWVyeUF0dHJpYnV0ZVsxXSwgb3B0aW9ucykgfHwgc3ViUXVlcnlBdHRyaWJ1dGVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZShvcmRlciwgbW9kZWwsICctPicpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3JkZXIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgIGNvbnN0IHNxbCA9IHRoaXMucXVvdGUob3B0aW9ucy5vcmRlciwgbW9kZWwsICctPicpO1xuICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgIHN1YlF1ZXJ5T3JkZXIucHVzaChzcWwpO1xuICAgICAgfVxuICAgICAgbWFpblF1ZXJ5T3JkZXIucHVzaChzcWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyIG11c3QgYmUgdHlwZSBvZiBhcnJheSBvciBpbnN0YW5jZSBvZiBhIHZhbGlkIHNlcXVlbGl6ZSBtZXRob2QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWFpblF1ZXJ5T3JkZXIsIHN1YlF1ZXJ5T3JkZXIgfTtcbiAgfVxuXG4gIF90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGV4dHJhSW5mbyA9IHt9KSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGFzUGFydCA9IGV4dHJhSW5mby5hcyAmJiBgYXMgJHtleHRyYUluZm8uYXN9YCB8fCAnJztcbiAgICBjb25zdCBuYW1lUGFydCA9IGV4dHJhSW5mby5tb2RlbE5hbWUgJiYgYGZvciBtb2RlbCAnJHtleHRyYUluZm8ubW9kZWxOYW1lfSdgIHx8ICcnO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgQXR0ZW1wdGVkIGEgU0VMRUNUIHF1ZXJ5ICR7bmFtZVBhcnR9ICR7YXNQYXJ0fSB3aXRob3V0IHNlbGVjdGluZyBhbnkgY29sdW1uc2A7XG4gICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9yLlF1ZXJ5RXJyb3IobWVzc2FnZS5yZXBsYWNlKC8gKy9nLCAnICcpKTtcbiAgfVxuXG4gIHNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLCB0YWJsZXMsIG1haW5UYWJsZUFzKSB7XG4gICAgdGhpcy5fdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZUFzIH0pO1xuXG4gICAgbGV0IGZyYWdtZW50ID0gYFNFTEVDVCAke2F0dHJpYnV0ZXMuam9pbignLCAnKX0gRlJPTSAke3RhYmxlc31gO1xuXG4gICAgaWYgKG1haW5UYWJsZUFzKSB7XG4gICAgICBmcmFnbWVudCArPSBgIEFTICR7bWFpblRhYmxlQXN9YDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRleEhpbnRzICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhIaW50cykge1xuICAgICAgZm9yIChjb25zdCBoaW50IG9mIG9wdGlvbnMuaW5kZXhIaW50cykge1xuICAgICAgICBpZiAoSW5kZXhIaW50c1toaW50LnR5cGVdKSB7XG4gICAgICAgICAgZnJhZ21lbnQgKz0gYCAke0luZGV4SGludHNbaGludC50eXBlXX0gSU5ERVggKCR7aGludC52YWx1ZXMubWFwKGluZGV4TmFtZSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKSkuam9pbignLCcpfSlgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gU1FMIGZyYWdtZW50IGZvciBhZGRpbmcgcmVzdWx0IGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHdpdGggc2VsZWN0UXVlcnkgb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMpIHtcbiAgICBsZXQgZnJhZ21lbnQgPSAnJztcblxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwgJiYgb3B0aW9ucy5saW1pdCA9PSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSAnIExJTUlUICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCkgKyAnLCAnICsgMTAwMDAwMDAwMDAwMDA7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGZyYWdtZW50ICs9ICcgTElNSVQgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KSArICcsICcgKyB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50ICs9ICcgTElNSVQgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5PcGVyYXRvck1hcCwgc210aC5jb21wYXJhdG9yKSkge1xuICAgICAgc210aC5jb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtzbXRoLmNvbXBhcmF0b3JdO1xuICAgIH1cblxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuV2hlcmUpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHNtdGgubG9naWM7XG4gICAgICBsZXQga2V5O1xuXG4gICAgICBpZiAoc210aC5hdHRyaWJ1dGUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoc210aC5hdHRyaWJ1dGUsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBgJHt0aGlzLnF1b3RlVGFibGUoc210aC5hdHRyaWJ1dGUuTW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc210aC5hdHRyaWJ1dGUuZmllbGQgfHwgc210aC5hdHRyaWJ1dGUuZmllbGROYW1lKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh2YWx1ZSwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICdOVUxMJykge1xuICAgICAgICAgIGlmIChzbXRoLmNvbXBhcmF0b3IgPT09ICc9Jykge1xuICAgICAgICAgICAgc210aC5jb21wYXJhdG9yID0gJ0lTJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gJyE9Jykge1xuICAgICAgICAgICAgc210aC5jb21wYXJhdG9yID0gJ0lTIE5PVCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtzbXRoLmNvbXBhcmF0b3J9IGApO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkoc210aC5hdHRyaWJ1dGUsIHZhbHVlLCB7XG4gICAgICAgICAgbW9kZWw6IGZhY3RvcnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoW3RoaXMuT3BlcmF0b3JNYXBbT3AuYmV0d2Vlbl0sIHRoaXMuT3BlcmF0b3JNYXBbT3Aubm90QmV0d2Vlbl1dLmluY2x1ZGVzKHNtdGguY29tcGFyYXRvcikpIHtcbiAgICAgICAgdmFsdWUgPSBgJHt0aGlzLmVzY2FwZSh2YWx1ZVswXSl9IEFORCAke3RoaXMuZXNjYXBlKHZhbHVlWzFdKX1gO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYm9vbGVhblZhbHVlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09ICdOVUxMJykge1xuICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSAnPScpIHtcbiAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSAnSVMnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLmNvbXBhcmF0b3IgPT09ICchPScpIHtcbiAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSAnSVMgTk9UJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke3NtdGguY29tcGFyYXRvcn0gYCk7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHNtdGgudmFsO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmIChzbXRoLnZhbCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLnZhbCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHNtdGgudmFsKSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLnZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmVzY2FwZShzbXRoLnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgQ0FTVCgke3Jlc3VsdH0gQVMgJHtzbXRoLnR5cGUudG9VcHBlckNhc2UoKX0pYDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Gbikge1xuICAgICAgcmV0dXJuIGAke3NtdGguZm59KCR7XG4gICAgICAgIHNtdGguYXJncy5tYXAoYXJnID0+IHtcbiAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXJnLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBhcmcucmVwbGFjZSgnJCcsICckJCQnKSA6IGFyZyk7XG4gICAgICAgIH0pLmpvaW4oJywgJylcbiAgICAgIH0pYDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Db2wpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGguY29sKSAmJiAhZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIFNlcXVlbGl6ZS5jb2woKSB3aXRoIGFycmF5IG91dHNpZGUgb2Ygb3JkZXIgLyBncm91cCBjbGF1c2UnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbXRoLmNvbC5zdGFydHNXaXRoKCcqJykpIHtcbiAgICAgICAgcmV0dXJuICcqJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnF1b3RlKHNtdGguY29sLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNtdGgudG9TdHJpbmcodGhpcywgZmFjdG9yeSk7XG4gIH1cblxuICB3aGVyZVF1ZXJ5KHdoZXJlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLndoZXJlSXRlbXNRdWVyeSh3aGVyZSwgb3B0aW9ucyk7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGBXSEVSRSAke3F1ZXJ5fWA7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHdoZXJlSXRlbXNRdWVyeSh3aGVyZSwgb3B0aW9ucywgYmluZGluZykge1xuICAgIGlmIChcbiAgICAgIHdoZXJlID09PSBudWxsIHx8XG4gICAgICB3aGVyZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBVdGlscy5nZXRDb21wbGV4U2l6ZSh3aGVyZSkgPT09IDBcbiAgICApIHtcbiAgICAgIC8vIE5PIE9QXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aGVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgYHt3aGVyZTogXFwncmF3IHF1ZXJ5XFwnfWAgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgYmluZGluZyA9IGJpbmRpbmcgfHwgJ0FORCc7XG4gICAgaWYgKGJpbmRpbmdbMF0gIT09ICcgJykgYmluZGluZyA9IGAgJHtiaW5kaW5nfSBgO1xuXG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh3aGVyZSkpIHtcbiAgICAgIFV0aWxzLmdldENvbXBsZXhLZXlzKHdoZXJlKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gd2hlcmVbcHJvcF07XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShwcm9wLCBpdGVtLCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHVuZGVmaW5lZCwgd2hlcmUsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoICYmIGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpLmpvaW4oYmluZGluZykgfHwgJyc7XG4gIH1cblxuICB3aGVyZUl0ZW1RdWVyeShrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXSEVSRSBwYXJhbWV0ZXIgXCIke2tleX1cIiBoYXMgaW52YWxpZCBcInVuZGVmaW5lZFwiIHZhbHVlYCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5pbmNsdWRlcygnLicpICYmIG9wdGlvbnMubW9kZWwpIHtcbiAgICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICBpZiAob3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXSAmJiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5UGFydHNbMF1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICBjb25zdCB0bXAgPSB7fTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5UGFydHNbMF1dO1xuICAgICAgICBfLnNldCh0bXAsIGtleVBhcnRzLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGZpZWxkLmZpZWxkIHx8IGtleVBhcnRzWzBdLCB0bXAsIHsgZmllbGQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmllbGQgPSB0aGlzLl9maW5kRmllbGQoa2V5LCBvcHRpb25zKTtcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZCAmJiBmaWVsZC50eXBlIHx8IG9wdGlvbnMudHlwZTtcblxuICAgIGNvbnN0IGlzUGxhaW5PYmplY3QgPSBfLmlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIGNvbnN0IGlzQXJyYXkgPSAhaXNQbGFpbk9iamVjdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICBrZXkgPSB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwICYmIHRoaXMuT3BlcmF0b3JzQWxpYXNNYXBba2V5XSB8fCBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fcmVwbGFjZUFsaWFzZXModmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUtleXMgPSBpc1BsYWluT2JqZWN0ICYmIFV0aWxzLmdldENvbXBsZXhLZXlzKHZhbHVlKTtcblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCAmJiB2YWx1ZUtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KHZhbHVlS2V5c1swXSwgdmFsdWVbdmFsdWVLZXlzWzBdXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBvcFZhbHVlID0gb3B0aW9ucy5iaW5kUGFyYW0gPyAnTlVMTCcgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUsIHRoaXMuT3BlcmF0b3JNYXBbT3AuaXNdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kICYmICEoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5GbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB3aGVyZTogW10gdG8gT3AuYW5kIGlmIHBvc3NpYmxlLCBlbHNlIHRyZWF0IGFzIGxpdGVyYWwvcmVwbGFjZW1lbnRzXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkpIHtcbiAgICAgIGlmIChVdGlscy5jYW5UcmVhdEFycmF5QXNBbmQodmFsdWUpKSB7XG4gICAgICAgIGtleSA9IE9wLmFuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgbGl0ZXJhbCByZXBsYWNlbWVudHMgaW4gdGhlIGB3aGVyZWAgb2JqZWN0IGhhcyBiZWVuIHJlbW92ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gT3Aub3IgfHwga2V5ID09PSBPcC5hbmQgfHwga2V5ID09PSBPcC5ub3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUdyb3VwQmluZChrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cblxuICAgIGlmICh2YWx1ZVtPcC5vcl0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5vcl0sIGtleSwgdmFsdWVbT3Aub3JdLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVbT3AuYW5kXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlQmluZCh0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0sIGtleSwgdmFsdWVbT3AuYW5kXSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkgJiYgZmllbGRUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZKSB7XG4gICAgICBjb25zdCBvcFZhbHVlID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdCAmJiBmaWVsZFR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTiAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVKU09OKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBJZiBtdWx0aXBsZSBrZXlzIHdlIGNvbWJpbmUgdGhlIGRpZmZlcmVudCBsb2dpYyBjb25kaXRpb25zXG4gICAgaWYgKGlzUGxhaW5PYmplY3QgJiYgdmFsdWVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdLCBrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCBPcC5pbiwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iamVjdCkge1xuICAgICAgaWYgKHRoaXMuT3BlcmF0b3JNYXBbdmFsdWVLZXlzWzBdXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIHZhbHVlS2V5c1swXSwgdmFsdWVbdmFsdWVLZXlzWzBdXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gT3AucGxhY2Vob2xkZXIpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUodGhpcy5PcGVyYXRvck1hcFtrZXldLCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgfVxuXG4gIF9maW5kRmllbGQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZmllbGQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZpZWxkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlcyAmJiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXldO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9SL0FORC9OT1QgZ3JvdXBpbmcgbG9naWNcbiAgX3doZXJlR3JvdXBCaW5kKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBiaW5kaW5nID0ga2V5ID09PSBPcC5vciA/IHRoaXMuT3BlcmF0b3JNYXBbT3Aub3JdIDogdGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdO1xuICAgIGNvbnN0IG91dGVyQmluZGluZyA9IGtleSA9PT0gT3Aubm90ID8gJ05PVCAnIDogJyc7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGl0ZW0gPT4ge1xuICAgICAgICBsZXQgaXRlbVF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaXRlbSwgb3B0aW9ucywgdGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICAgICAgaWYgKGl0ZW1RdWVyeSAmJiBpdGVtUXVlcnkubGVuZ3RoICYmIChBcnJheS5pc0FycmF5KGl0ZW0pIHx8IF8uaXNQbGFpbk9iamVjdChpdGVtKSkgJiYgVXRpbHMuZ2V0Q29tcGxleFNpemUoaXRlbSkgPiAxKSB7XG4gICAgICAgICAgaXRlbVF1ZXJ5ID0gYCgke2l0ZW1RdWVyeX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVF1ZXJ5O1xuICAgICAgfSkuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCk7XG5cbiAgICAgIHZhbHVlID0gdmFsdWUubGVuZ3RoICYmIHZhbHVlLmpvaW4oYmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkodmFsdWUsIG9wdGlvbnMsIGJpbmRpbmcpO1xuICAgIH1cbiAgICAvLyBPcC5vcjogW10gc2hvdWxkIHJldHVybiBubyBkYXRhLlxuICAgIC8vIE9wLm5vdCBvZiBubyByZXN0cmljdGlvbiBzaG91bGQgYWxzbyByZXR1cm4gbm8gZGF0YVxuICAgIGlmICgoa2V5ID09PSBPcC5vciB8fCBrZXkgPT09IE9wLm5vdCkgJiYgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gJzAgPSAxJztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPyBgJHtvdXRlckJpbmRpbmd9KCR7dmFsdWV9KWAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBfd2hlcmVCaW5kKGJpbmRpbmcsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBVdGlscy5nZXRDb21wbGV4S2V5cyh2YWx1ZSkubWFwKHByb3AgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbcHJvcF07XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgeyBbcHJvcF06IGl0ZW0gfSwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoaXRlbSA9PiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgaXRlbSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gYCgke3ZhbHVlLmpvaW4oYmluZGluZyl9KWAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBfd2hlcmVKU09OKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBiYXNlS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICBpZiAob3B0aW9ucy5wcmVmaXgpIHtcbiAgICAgIGlmIChvcHRpb25zLnByZWZpeCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgYmFzZUtleSA9IGAke3RoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKG9wdGlvbnMucHJlZml4KX0uJHtiYXNlS2V5fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlS2V5ID0gYCR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMucHJlZml4KX0uJHtiYXNlS2V5fWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVXRpbHMuZ2V0T3BlcmF0b3JzKHZhbHVlKS5mb3JFYWNoKG9wID0+IHtcbiAgICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgICBbb3BdOiB2YWx1ZVtvcF1cbiAgICAgIH07XG4gICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkoa2V5LCB3aGVyZSwgeyAuLi5vcHRpb25zLCBqc29uOiBmYWxzZSB9KSk7XG4gICAgfSk7XG5cbiAgICBfLmZvck93bih2YWx1ZSwgKGl0ZW0sIHByb3ApID0+IHtcbiAgICAgIHRoaXMuX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgcHJvcCwgaXRlbSwgW3Byb3BdKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW1zLmpvaW4odGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMSA/IGAoJHtyZXN1bHR9KWAgOiByZXN1bHQ7XG4gIH1cblxuICBfdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBwcm9wLCBpdGVtLCBwYXRoKSB7XG4gICAgbGV0IGNhc3Q7XG5cbiAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdLmluY2x1ZGVzKCc6OicpKSB7XG4gICAgICBjb25zdCB0bXAgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uc3BsaXQoJzo6Jyk7XG4gICAgICBjYXN0ID0gdG1wWzFdO1xuICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID0gdG1wWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGhLZXkgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGJhc2VLZXksIHBhdGgpO1xuXG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgVXRpbHMuZ2V0T3BlcmF0b3JzKGl0ZW0pLmZvckVhY2gob3AgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3RvSlNPTlZhbHVlKGl0ZW1bb3BdKTtcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHRoaXMuX2Nhc3RLZXkocGF0aEtleSwgdmFsdWUsIGNhc3QpLCB7IFtvcF06IHZhbHVlIH0pKTtcbiAgICAgIH0pO1xuICAgICAgXy5mb3JPd24oaXRlbSwgKHZhbHVlLCBpdGVtUHJvcCkgPT4ge1xuICAgICAgICB0aGlzLl90cmF2ZXJzZUpTT04oaXRlbXMsIGJhc2VLZXksIGl0ZW1Qcm9wLCB2YWx1ZSwgcGF0aC5jb25jYXQoW2l0ZW1Qcm9wXSkpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpdGVtID0gdGhpcy5fdG9KU09OVmFsdWUoaXRlbSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHRoaXMuX2Nhc3RLZXkocGF0aEtleSwgaXRlbSwgY2FzdCksIHsgW09wLmVxXTogaXRlbSB9KSk7XG4gIH1cblxuICBfdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBfY2FzdEtleShrZXksIHZhbHVlLCBjYXN0LCBqc29uKSB7XG4gICAgY2FzdCA9IGNhc3QgfHwgdGhpcy5fZ2V0SnNvbkNhc3QoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKG5ldyBVdGlscy5DYXN0KG5ldyBVdGlscy5MaXRlcmFsKGtleSksIGNhc3QsIGpzb24pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKGtleSk7XG4gIH1cblxuICBfZ2V0SnNvbkNhc3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdkb3VibGUgcHJlY2lzaW9uJztcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICd0aW1lc3RhbXB0eic7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLCBjb21wYXJhdG9yLCBwcmVmaXgpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5fSBhbmQgJHt2YWx1ZX0gaGFzIG5vIGNvbXBhcmF0b3JgKTtcbiAgICB9XG4gICAga2V5ID0gdGhpcy5fZ2V0U2FmZUtleShrZXksIHByZWZpeCk7XG4gICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtjb21wYXJhdG9yfSBgKTtcbiAgfVxuXG4gIF9nZXRTYWZlS2V5KGtleSwgcHJlZml4KSB7XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAga2V5ID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzLl9wcmVmaXhLZXkodGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoa2V5KSwgcHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbHMuaXNDb2xTdHJpbmcoa2V5KSkge1xuICAgICAga2V5ID0ga2V5LnN1YnN0cigxLCBrZXkubGVuZ3RoIC0gMikuc3BsaXQoJy4nKTtcblxuICAgICAgaWYgKGtleS5sZW5ndGggPiAyKSB7XG4gICAgICAgIGtleSA9IFtcbiAgICAgICAgICAvLyBqb2luIHRoZSB0YWJsZXMgYnkgLT4gdG8gbWF0Y2ggb3V0IGludGVybmFsIG5hbWluZ3NcbiAgICAgICAgICBrZXkuc2xpY2UoMCwgLTEpLmpvaW4oJy0+JyksXG4gICAgICAgICAga2V5W2tleS5sZW5ndGggLSAxXVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5Lm1hcChpZGVudGlmaWVyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpKS5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ByZWZpeEtleSh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLCBwcmVmaXgpO1xuICB9XG5cbiAgX3ByZWZpeEtleShrZXksIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QocHJlZml4KSwga2V5XS5qb2luKCcuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdGhpcy5xdW90ZVRhYmxlKHByZWZpeCksIGtleV0uam9pbignLicpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICBfd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgPT09IE9wLm5vdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHByb3AgPSBPcC5ub3RJbjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHByb3AgPSBPcC5uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbcHJvcF0gfHwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV07XG5cbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgT3AuaW46XG4gICAgICBjYXNlIE9wLm5vdEluOlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLnZhbCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dmFsdWUubWFwKGl0ZW0gPT4gdGhpcy5lc2NhcGUoaXRlbSwgZmllbGQpKS5qb2luKCcsICcpfSlgLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyYXRvciA9PT0gdGhpcy5PcGVyYXRvck1hcFtPcC5pbl0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgJyhOVUxMKScsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIGNhc2UgT3AuYW55OlxuICAgICAgY2FzZSBPcC5hbGw6XG4gICAgICAgIGNvbXBhcmF0b3IgPSBgJHt0aGlzLk9wZXJhdG9yTWFwW09wLmVxXX0gJHtjb21wYXJhdG9yfWA7XG4gICAgICAgIGlmICh2YWx1ZVtPcC52YWx1ZXNdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoVkFMVUVTICR7dmFsdWVbT3AudmFsdWVzXS5tYXAoaXRlbSA9PiBgKCR7dGhpcy5lc2NhcGUoaXRlbSl9KWApLmpvaW4oJywgJyl9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5iZXR3ZWVuOlxuICAgICAgY2FzZSBPcC5ub3RCZXR3ZWVuOlxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCR7dGhpcy5lc2NhcGUodmFsdWVbMF0sIGZpZWxkKX0gQU5EICR7dGhpcy5lc2NhcGUodmFsdWVbMV0sIGZpZWxkKX1gLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICBjYXNlIE9wLnJhdzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYCRyYXdgIHdoZXJlIHByb3BlcnR5IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICBVc2UgYHNlcXVlbGl6ZS5saXRlcmFsYCBpbnN0ZWFkLicpO1xuICAgICAgY2FzZSBPcC5jb2w6XG4gICAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLicpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFsdWUgPSBbXG4gICAgICAgICAgICAvLyBqb2luIHRoZSB0YWJsZXMgYnkgLT4gdG8gbWF0Y2ggb3V0IGludGVybmFsIG5hbWluZ3NcbiAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIC0xKS5qb2luKCctPicpLFxuICAgICAgICAgICAgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLm1hcChpZGVudGlmaWVyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpKS5qb2luKCcuJyksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNhc2UgT3Auc3RhcnRzV2l0aDpcbiAgICAgIGNhc2UgT3AuZW5kc1dpdGg6XG4gICAgICBjYXNlIE9wLnN1YnN0cmluZzpcbiAgICAgICAgY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbT3AubGlrZV07XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhdHRlcm4gPSBgJHt2YWx1ZX0lYDtcblxuICAgICAgICBpZiAocHJvcCA9PT0gT3AuZW5kc1dpdGgpIHBhdHRlcm4gPSBgJSR7dmFsdWV9YDtcbiAgICAgICAgaWYgKHByb3AgPT09IE9wLnN1YnN0cmluZykgcGF0dGVybiA9IGAlJHt2YWx1ZX0lYDtcblxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUocGF0dGVybiksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBjb25zdCBlc2NhcGVPcHRpb25zID0ge1xuICAgICAgYWNjZXB0U3RyaW5nczogY29tcGFyYXRvci5pbmNsdWRlcyh0aGlzLk9wZXJhdG9yTWFwW09wLmxpa2VdKVxuICAgIH07XG5cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlW09wLmNvbF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMud2hlcmVJdGVtUXVlcnkobnVsbCwgdmFsdWUpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYW55XSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYW55XSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYW55XX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYWxsXSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYWxsXSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYWxsXX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsICYmIGNvbXBhcmF0b3IgPT09IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgdGhpcy5PcGVyYXRvck1hcFtPcC5pc10sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsICYmIGNvbXBhcmF0b3IgPT09IHRoaXMuT3BlcmF0b3JNYXBbT3AubmVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgdGhpcy5PcGVyYXRvck1hcFtPcC5ub3RdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgfVxuXG4gIC8qXG4gICAgVGFrZXMgc29tZXRoaW5nIGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gdmFsdWVzIG9mIGEgd2hlcmUgY29uZGl0aW9uLlxuICAgQHByaXZhdGVcbiAgKi9cbiAgZ2V0V2hlcmVDb25kaXRpb25zKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWJsZU5hbWUpKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWVbMF07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWJsZU5hbWUpKSB7XG4gICAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZVsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChwcmVwZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZXBlbmQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzbXRoICYmIHNtdGggaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHsgLy8gQ2hlY2tpbmcgYSBwcm9wZXJ0eSBpcyBjaGVhcGVyIHRoYW4gYSBsb3Qgb2YgaW5zdGFuY2VvZiBjYWxsc1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgfVxuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qoc210aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lLFxuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNtdGggPT09ICdudW1iZXInKSB7XG4gICAgICBsZXQgcHJpbWFyeUtleXMgPSBmYWN0b3J5ID8gT2JqZWN0LmtleXMoZmFjdG9yeS5wcmltYXJ5S2V5cykgOiBbXTtcblxuICAgICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUganVzdCBhIG51bWJlciwgYXNzdW1lIG9ubHkgdGhlIGZpcnN0IGtleVxuICAgICAgICBwcmltYXJ5S2V5cyA9IHByaW1hcnlLZXlzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbWFyeUtleXMgPSAnaWQnO1xuICAgICAgfVxuXG4gICAgICB3aGVyZVtwcmltYXJ5S2V5c10gPSBzbXRoO1xuXG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkod2hlcmUsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNtdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aCwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc210aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVzY2FwZShzbXRoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc210aCkpIHtcbiAgICAgIGlmIChzbXRoLmxlbmd0aCA9PT0gMCB8fCBzbXRoLmxlbmd0aCA+IDAgJiYgc210aFswXS5sZW5ndGggPT09IDApIHJldHVybiAnMT0xJztcbiAgICAgIGlmIChVdGlscy5jYW5UcmVhdEFycmF5QXNBbmQoc210aCkpIHtcbiAgICAgICAgY29uc3QgX3NtdGggPSB7IFtPcC5hbmRdOiBzbXRoIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhfc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgbGl0ZXJhbCByZXBsYWNlbWVudHMgaW4gdGhlIGB3aGVyZWAgb2JqZWN0IGhhcyBiZWVuIHJlbW92ZWQuJyk7XG4gICAgfVxuICAgIGlmIChzbXRoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aCwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcxPTEnO1xuICB9XG5cbiAgLy8gQSByZWN1cnNpdmUgcGFyc2VyIGZvciBuZXN0ZWQgd2hlcmUgY29uZGl0aW9uc1xuICBwYXJzZUNvbmRpdGlvbk9iamVjdChjb25kaXRpb25zLCBwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGggfHwgW107XG4gICAgcmV0dXJuIF8ucmVkdWNlKGNvbmRpdGlvbnMsIChyZXN1bHQsIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHZhbHVlLCBwYXRoLmNvbmNhdChrZXkpKSk7IC8vIFJlY3Vyc2l2ZWx5IHBhcnNlIG9iamVjdHNcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHsgcGF0aDogcGF0aC5jb25jYXQoa2V5KSwgdmFsdWUgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFF1ZXJ5R2VuZXJhdG9yLnByb3RvdHlwZSwgcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzJykpO1xuT2JqZWN0LmFzc2lnbihRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUsIHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yL3RyYW5zYWN0aW9uJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5R2VuZXJhdG9yO1xuIiwiLyoqXG4gKiBRdW90ZSBoZWxwZXJzIGltcGxlbWVudCBxdW90ZSBhYmlsaXR5IGZvciBhbGwgZGlhbGVjdHMuXG4gKiBUaGVzZSBhcmUgYmFzaWMgYmxvY2sgb2YgcXVlcnkgYnVpbGRpbmdcbiAqXG4gKiBJdHMgYmV0dGVyIHRvIGltcGxlbWVudCBhbGwgZGlhbGVjdCBpbXBsZW1lbnRhdGlvbiB0b2dldGhlciBoZXJlLiBXaGljaCB3aWxsIGFsbG93XG4gKiBldmVuIGFic3RyYWN0IGdlbmVyYXRvciB0byB1c2UgdGhlbSBieSBqdXN0IHNwZWNpZnlpbmcgZGlhbGVjdCB0eXBlLlxuICpcbiAqIERlZmluaW5nIHRoZXNlIGhlbHBlcnMgaW4gZWFjaCBxdWVyeSBkaWFsZWN0IHdpbGwgbGVhdmVcbiAqIGNvZGUgaW4gZHVhbCBkZXBlbmRlbmN5IG9mIGFic3RyYWN0IDwtPiBzcGVjaWZpYyBkaWFsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogbGlzdCBvZiByZXNlcnZlZCB3b3JkcyBpbiBQb3N0Z3JlU1FMIDEwXG4gKiBzb3VyY2U6IGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvMTAvc3RhdGljL3NxbC1rZXl3b3Jkcy1hcHBlbmRpeC5odG1sXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcG9zdGdyZXNSZXNlcnZlZFdvcmRzID0gJ2FsbCxhbmFseXNlLGFuYWx5emUsYW5kLGFueSxhcnJheSxhcyxhc2MsYXN5bW1ldHJpYyxhdXRob3JpemF0aW9uLGJpbmFyeSxib3RoLGNhc2UsY2FzdCxjaGVjayxjb2xsYXRlLGNvbGxhdGlvbixjb2x1bW4sY29uY3VycmVudGx5LGNvbnN0cmFpbnQsY3JlYXRlLGNyb3NzLGN1cnJlbnRfY2F0YWxvZyxjdXJyZW50X2RhdGUsY3VycmVudF9yb2xlLGN1cnJlbnRfc2NoZW1hLGN1cnJlbnRfdGltZSxjdXJyZW50X3RpbWVzdGFtcCxjdXJyZW50X3VzZXIsZGVmYXVsdCxkZWZlcnJhYmxlLGRlc2MsZGlzdGluY3QsZG8sZWxzZSxlbmQsZXhjZXB0LGZhbHNlLGZldGNoLGZvcixmb3JlaWduLGZyZWV6ZSxmcm9tLGZ1bGwsZ3JhbnQsZ3JvdXAsaGF2aW5nLGlsaWtlLGluLGluaXRpYWxseSxpbm5lcixpbnRlcnNlY3QsaW50byxpcyxpc251bGwsam9pbixsYXRlcmFsLGxlYWRpbmcsbGVmdCxsaWtlLGxpbWl0LGxvY2FsdGltZSxsb2NhbHRpbWVzdGFtcCxuYXR1cmFsLG5vdCxub3RudWxsLG51bGwsb2Zmc2V0LG9uLG9ubHksb3Isb3JkZXIsb3V0ZXIsb3ZlcmxhcHMscGxhY2luZyxwcmltYXJ5LHJlZmVyZW5jZXMscmV0dXJuaW5nLHJpZ2h0LHNlbGVjdCxzZXNzaW9uX3VzZXIsc2ltaWxhcixzb21lLHN5bW1ldHJpYyx0YWJsZSx0YWJsZXNhbXBsZSx0aGVuLHRvLHRyYWlsaW5nLHRydWUsdW5pb24sdW5pcXVlLHVzZXIsdXNpbmcsdmFyaWFkaWMsdmVyYm9zZSx3aGVuLHdoZXJlLHdpbmRvdyx3aXRoJy5zcGxpdCgnLCcpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIGRpYWxlY3QgICAgICAgICBEaWFsZWN0IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgaWRlbnRpZmllciAgICAgIElkZW50aWZpZXIgdG8gcXVvdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPWZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzPXRydWVdXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHF1b3RlSWRlbnRpZmllcihkaWFsZWN0LCBpZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gIGlmIChpZGVudGlmaWVyID09PSAnKicpIHJldHVybiBpZGVudGlmaWVyO1xuXG4gIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgZm9yY2U6IGZhbHNlLFxuICAgIHF1b3RlSWRlbnRpZmllcnM6IHRydWVcbiAgfSk7XG5cbiAgc3dpdGNoIChkaWFsZWN0KSB7XG4gICAgY2FzZSAnc3FsaXRlJzpcbiAgICBjYXNlICdtYXJpYWRiJzpcbiAgICBjYXNlICdteXNxbCc6XG4gICAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgJ2AnKSwgJ2AnKTtcblxuICAgIGNhc2UgJ3Bvc3RncmVzJzpcbiAgICAgIGNvbnN0IHJhd0lkZW50aWZpZXIgPSBVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKTtcblxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLmZvcmNlICE9PSB0cnVlICYmXG4gICAgICAgIG9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UgJiZcbiAgICAgICAgIWlkZW50aWZpZXIuaW5jbHVkZXMoJy4nKSAmJlxuICAgICAgICAhaWRlbnRpZmllci5pbmNsdWRlcygnLT4nKSAmJlxuICAgICAgICAhcG9zdGdyZXNSZXNlcnZlZFdvcmRzLmluY2x1ZGVzKHJhd0lkZW50aWZpZXIudG9Mb3dlckNhc2UoKSlcbiAgICAgICkge1xuICAgICAgICAvLyBJbiBQb3N0Z3JlcywgaWYgdGFibGVzIG9yIGF0dHJpYnV0ZXMgYXJlIGNyZWF0ZWQgZG91YmxlLXF1b3RlZCxcbiAgICAgICAgLy8gdGhleSBhcmUgYWxzbyBjYXNlIHNlbnNpdGl2ZS4gSWYgdGhleSBjb250YWluIGFueSB1cHBlcmNhc2VcbiAgICAgICAgLy8gY2hhcmFjdGVycywgdGhleSBtdXN0IGFsd2F5cyBiZSBkb3VibGUtcXVvdGVkLiBUaGlzIG1ha2VzIGl0XG4gICAgICAgIC8vIGltcG9zc2libGUgdG8gd3JpdGUgcXVlcmllcyBpbiBwb3J0YWJsZSBTUUwgaWYgdGFibGVzIGFyZSBjcmVhdGVkIGluXG4gICAgICAgIC8vIHRoaXMgd2F5LiBIZW5jZSwgd2Ugc3RyaXAgcXVvdGVzIGlmIHdlIGRvbid0IHdhbnQgY2FzZSBzZW5zaXRpdml0eS5cbiAgICAgICAgcmV0dXJuIHJhd0lkZW50aWZpZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MocmF3SWRlbnRpZmllciwgJ1wiJyk7XG4gICAgY2FzZSAnbXNzcWwnOlxuICAgICAgcmV0dXJuIGBbJHtpZGVudGlmaWVyLnJlcGxhY2UoL1tbXFxdJ10rL2csICcnKX1dYDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERpYWxlY3QgXCIke2RpYWxlY3R9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cy5xdW90ZUlkZW50aWZpZXIgPSBxdW90ZUlkZW50aWZpZXI7XG5cbi8qKlxuICogVGVzdCBpZiBhIGdpdmUgc3RyaW5nIGlzIGFscmVhZHkgcXVvdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXJcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclF1b3RlZChpZGVudGlmaWVyKSB7XG4gIHJldHVybiAvXlxccyooPzooW2BcIiddKSg/Oig/IVxcMSkufFxcMXsyfSkqXFwxXFwuPykrXFxzKiQvaS50ZXN0KGlkZW50aWZpZXIpO1xufVxubW9kdWxlLmV4cG9ydHMuaXNJZGVudGlmaWVyUXVvdGVkID0gaXNJZGVudGlmaWVyUXVvdGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdG9ycycpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG5jb25zdCBPcGVyYXRvckhlbHBlcnMgPSB7XG4gIE9wZXJhdG9yTWFwOiB7XG4gICAgW09wLmVxXTogJz0nLFxuICAgIFtPcC5uZV06ICchPScsXG4gICAgW09wLmd0ZV06ICc+PScsXG4gICAgW09wLmd0XTogJz4nLFxuICAgIFtPcC5sdGVdOiAnPD0nLFxuICAgIFtPcC5sdF06ICc8JyxcbiAgICBbT3Aubm90XTogJ0lTIE5PVCcsXG4gICAgW09wLmlzXTogJ0lTJyxcbiAgICBbT3AuaW5dOiAnSU4nLFxuICAgIFtPcC5ub3RJbl06ICdOT1QgSU4nLFxuICAgIFtPcC5saWtlXTogJ0xJS0UnLFxuICAgIFtPcC5ub3RMaWtlXTogJ05PVCBMSUtFJyxcbiAgICBbT3AuaUxpa2VdOiAnSUxJS0UnLFxuICAgIFtPcC5ub3RJTGlrZV06ICdOT1QgSUxJS0UnLFxuICAgIFtPcC5zdGFydHNXaXRoXTogJ0xJS0UnLFxuICAgIFtPcC5lbmRzV2l0aF06ICdMSUtFJyxcbiAgICBbT3Auc3Vic3RyaW5nXTogJ0xJS0UnLFxuICAgIFtPcC5yZWdleHBdOiAnficsXG4gICAgW09wLm5vdFJlZ2V4cF06ICchficsXG4gICAgW09wLmlSZWdleHBdOiAnfionLFxuICAgIFtPcC5ub3RJUmVnZXhwXTogJyF+KicsXG4gICAgW09wLmJldHdlZW5dOiAnQkVUV0VFTicsXG4gICAgW09wLm5vdEJldHdlZW5dOiAnTk9UIEJFVFdFRU4nLFxuICAgIFtPcC5vdmVybGFwXTogJyYmJyxcbiAgICBbT3AuY29udGFpbnNdOiAnQD4nLFxuICAgIFtPcC5jb250YWluZWRdOiAnPEAnLFxuICAgIFtPcC5hZGphY2VudF06ICctfC0nLFxuICAgIFtPcC5zdHJpY3RMZWZ0XTogJzw8JyxcbiAgICBbT3Auc3RyaWN0UmlnaHRdOiAnPj4nLFxuICAgIFtPcC5ub0V4dGVuZFJpZ2h0XTogJyY8JyxcbiAgICBbT3Aubm9FeHRlbmRMZWZ0XTogJyY+JyxcbiAgICBbT3AuYW55XTogJ0FOWScsXG4gICAgW09wLmFsbF06ICdBTEwnLFxuICAgIFtPcC5hbmRdOiAnIEFORCAnLFxuICAgIFtPcC5vcl06ICcgT1IgJyxcbiAgICBbT3AuY29sXTogJ0NPTCcsXG4gICAgW09wLnBsYWNlaG9sZGVyXTogJyQkUExBQ0VIT0xERVIkJCcsXG4gICAgW09wLm1hdGNoXTogJ0BAJ1xuICB9LFxuXG4gIE9wZXJhdG9yc0FsaWFzTWFwOiB7fSxcblxuICBzZXRPcGVyYXRvcnNBbGlhc2VzKGFsaWFzZXMpIHtcbiAgICBpZiAoIWFsaWFzZXMgfHwgXy5pc0VtcHR5KGFsaWFzZXMpKSB7XG4gICAgICB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgPSB7IC4uLmFsaWFzZXMgfTtcbiAgICB9XG4gIH0sXG5cbiAgX3JlcGxhY2VBbGlhc2VzKG9yaWcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBpZiAoIXRoaXMuT3BlcmF0b3JzQWxpYXNNYXApIHtcbiAgICAgIHJldHVybiBvcmlnO1xuICAgIH1cblxuICAgIFV0aWxzLmdldE9wZXJhdG9ycyhvcmlnKS5mb3JFYWNoKG9wID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBvcmlnW29wXTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgICAgb2JqW29wXSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW29wXSA9IGl0ZW07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfLmZvck93bihvcmlnLCAoaXRlbSwgcHJvcCkgPT4ge1xuICAgICAgcHJvcCA9IHRoaXMuT3BlcmF0b3JzQWxpYXNNYXBbcHJvcF0gfHwgcHJvcDtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKGl0ZW0pO1xuICAgICAgfVxuICAgICAgb2JqW3Byb3BdID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9ySGVscGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXVpZHY0ID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuXG5jb25zdCBUcmFuc2FjdGlvblF1ZXJpZXMgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcXVlcnkgdGhhdCBzZXRzIHRoZSB0cmFuc2FjdGlvbiBpc29sYXRpb24gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgICBUaGUgaXNvbGF0aW9uIGxldmVsLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gYFNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgJHt2YWx1ZX07YDtcbiAgfSxcblxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcXVlcnkgdGhhdCBzdGFydHMgYSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICAvLyBmb3JjZSBxdW90aW5nIG9mIHNhdmVwb2ludCBpZGVudGlmaWVycyBmb3IgcG9zdGdyZXNcbiAgICAgIHJldHVybiBgU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSwgdHJ1ZSl9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuICdTVEFSVCBUUkFOU0FDVElPTjsnO1xuICB9LFxuXG4gIGRlZmVyQ29uc3RyYWludHNRdWVyeSgpIHt9LFxuXG4gIHNldENvbnN0cmFpbnRRdWVyeSgpIHt9LFxuICBzZXREZWZlcnJlZFF1ZXJ5KCkge30sXG4gIHNldEltbWVkaWF0ZVF1ZXJ5KCkge30sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWVyeSB0aGF0IGNvbW1pdHMgYSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiAnQ09NTUlUOyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWVyeSB0aGF0IHJvbGxiYWNrcyBhIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIC8vIGZvcmNlIHF1b3Rpbmcgb2Ygc2F2ZXBvaW50IGlkZW50aWZpZXJzIGZvciBwb3N0Z3Jlc1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUTyBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lLCB0cnVlKX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1JPTExCQUNLOyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25RdWVyaWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgdGhhdCBTZXF1ZWxpemUgdXNlcyB0byB0YWxrIHRvIGFsbCBkYXRhYmFzZXNcbiAqL1xuY2xhc3MgUXVlcnlJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUsIHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IHF1ZXJ5R2VuZXJhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRhdGFiYXNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSAgRGF0YWJhc2UgbmFtZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jaGFyc2V0XSBEYXRhYmFzZSBkZWZhdWx0IGNoYXJhY3RlciBzZXQsIE1ZU1FMIG9ubHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbGxhdGVdIERhdGFiYXNlIGRlZmF1bHQgY29sbGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZ10gRGF0YWJhc2UgZGVmYXVsdCBjaGFyYWN0ZXIgc2V0LCBQb3N0Z3JlU1FMIG9ubHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmN0eXBlXSBEYXRhYmFzZSBjaGFyYWN0ZXIgY2xhc3NpZmljYXRpb24sIFBvc3RncmVTUUwgb25seVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGVtcGxhdGVdIFRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmcm9tIHdoaWNoIHRvIGNyZWF0ZSB0aGUgbmV3IGRhdGFiYXNlLCBQb3N0Z3JlU1FMIG9ubHlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGVEYXRhYmFzZShkYXRhYmFzZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhIGRhdGFiYXNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSAgRGF0YWJhc2UgbmFtZSB0byBkcm9wXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BEYXRhYmFzZShkYXRhYmFzZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2UpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNjaGVtYVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hICAgIFNjaGVtYSBuYW1lIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVTY2hlbWEoc2NoZW1hKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGEgc2NoZW1hXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWEgICAgU2NoZW1hIG5hbWUgdG8gZHJvcFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFNjaGVtYShzY2hlbWEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYWxsIHNjaGVtYXNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEFsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCF0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9kaWFsZWN0LnN1cHBvcnRzLnNjaGVtYXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5kcm9wKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWFzID0gYXdhaXQgdGhpcy5zaG93QWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2NoZW1hcy5tYXAoc2NoZW1hTmFtZSA9PiB0aGlzLmRyb3BTY2hlbWEoc2NoZW1hTmFtZSwgb3B0aW9ucykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGFsbCBzY2hlbWFzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gICAqL1xuICBhc3luYyBzaG93QWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICByYXc6IHRydWUsXG4gICAgICB0eXBlOiB0aGlzLnNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNFTEVDVFxuICAgIH07XG5cbiAgICBjb25zdCBzaG93U2NoZW1hc1NxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd1NjaGVtYXNRdWVyeShvcHRpb25zKTtcblxuICAgIGNvbnN0IHNjaGVtYU5hbWVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc2hvd1NjaGVtYXNTcWwsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIF8uZmxhdHRlbihzY2hlbWFOYW1lcy5tYXAodmFsdWUgPT4gdmFsdWUuc2NoZW1hX25hbWUgPyB2YWx1ZS5zY2hlbWFfbmFtZSA6IHZhbHVlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGRhdGFiYXNlIHZlcnNpb25cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgIFtvcHRpb25zXSAgICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtRdWVyeVR5cGV9IFtvcHRpb25zLnR5cGVdIFF1ZXJ5IHR5cGVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBkYXRhYmFzZVZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IudmVyc2lvblF1ZXJ5KCksXG4gICAgICB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuVkVSU0lPTiB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0YWJsZSB3aXRoIGdpdmVuIHNldCBvZiBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmNyZWF0ZVRhYmxlKFxuICAgKiAgICduYW1lT2ZUaGVOZXdUYWJsZScsXG4gICAqICAge1xuICAgKiAgICAgaWQ6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLklOVEVHRVIsXG4gICAqICAgICAgIHByaW1hcnlLZXk6IHRydWUsXG4gICAqICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICogICAgIH0sXG4gICAqICAgICBjcmVhdGVkQXQ6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLkRBVEVcbiAgICogICAgIH0sXG4gICAqICAgICB1cGRhdGVkQXQ6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLkRBVEVcbiAgICogICAgIH0sXG4gICAqICAgICBhdHRyMTogU2VxdWVsaXplLlNUUklORyxcbiAgICogICAgIGF0dHIyOiBTZXF1ZWxpemUuSU5URUdFUixcbiAgICogICAgIGF0dHIzOiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5CT09MRUFOLFxuICAgKiAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgKiAgICAgICBhbGxvd051bGw6IGZhbHNlXG4gICAqICAgICB9LFxuICAgKiAgICAgLy9mb3JlaWduIGtleSB1c2FnZVxuICAgKiAgICAgYXR0cjQ6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLklOVEVHRVIsXG4gICAqICAgICAgIHJlZmVyZW5jZXM6IHtcbiAgICogICAgICAgICBtb2RlbDogJ2Fub3RoZXJfdGFibGVfbmFtZScsXG4gICAqICAgICAgICAga2V5OiAnaWQnXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIG9uVXBkYXRlOiAnY2FzY2FkZScsXG4gICAqICAgICAgIG9uRGVsZXRlOiAnY2FzY2FkZSdcbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGVuZ2luZTogJ01ZSVNBTScsICAgIC8vIGRlZmF1bHQ6ICdJbm5vREInXG4gICAqICAgICBjaGFyc2V0OiAnbGF0aW4xJywgICAvLyBkZWZhdWx0OiBudWxsXG4gICAqICAgICBzY2hlbWE6ICdwdWJsaWMnLCAgICAvLyBkZWZhdWx0OiBwdWJsaWMsIFBvc3RncmVTUUwgb25seS5cbiAgICogICAgIGNvbW1lbnQ6ICdteSB0YWJsZScsIC8vIGNvbW1lbnQgZm9yIHRhYmxlXG4gICAqICAgICBjb2xsYXRlOiAnbGF0aW4xX2RhbmlzaF9jaScgLy8gY29sbGF0aW9uLCBNWVNRTCBvbmx5XG4gICAqICAgfVxuICAgKiApXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICBOYW1lIG9mIHRhYmxlIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyBPYmplY3QgcmVwcmVzZW50aW5nIGEgbGlzdCBvZiB0YWJsZSBhdHRyaWJ1dGVzIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIGNyZWF0ZSB0YWJsZSBhbmQgcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge01vZGVsfSAgW21vZGVsXSBtb2RlbCBjbGFzc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBsZXQgc3FsID0gJyc7XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZm9yT3duKG9wdGlvbnMudW5pcXVlS2V5cywgdW5pcXVlS2V5ID0+IHtcbiAgICAgICAgaWYgKHVuaXF1ZUtleS5jdXN0b21JbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdW5pcXVlS2V5LmN1c3RvbUluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBvcHRpb25zLnVuaXF1ZUtleXMgPSBvcHRpb25zLnVuaXF1ZUtleXMgfHwgbW9kZWwudW5pcXVlS2V5cztcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVzID0gXy5tYXBWYWx1ZXMoXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgYXR0cmlidXRlID0+IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpXG4gICAgKTtcblxuICAgIC8vIFBvc3RncmVzIHJlcXVpcmVzIHNwZWNpYWwgU1FMIGNvbW1hbmRzIGZvciBFTlVNL0VOVU1bXVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlRW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCk7XG5cbiAgICBpZiAoXG4gICAgICAhdGFibGVOYW1lLnNjaGVtYSAmJlxuICAgICAgKG9wdGlvbnMuc2NoZW1hIHx8ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSlcbiAgICApIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkU2NoZW1hKHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBfc2NoZW1hOiAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCB7IHRhYmxlOiB0YWJsZU5hbWUsIGNvbnRleHQ6ICdjcmVhdGVUYWJsZScgfSk7XG4gICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGEgdGFibGUgZnJvbSBkYXRhYmFzZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lIFRhYmxlIG5hbWUgdG8gZHJvcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgd2UncmUgZm9yY2luZyB3ZSBzaG91bGQgYmUgY2FzY2FkaW5nIHVubGVzcyBleHBsaWNpdGx5IHN0YXRlZCBvdGhlcndpc2VcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgb3B0aW9ucy5jYXNjYWRlID0gb3B0aW9ucy5jYXNjYWRlIHx8IG9wdGlvbnMuZm9yY2UgfHwgZmFsc2U7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG5cbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlTmFtZXMpIHtcbiAgICAgIC8vIGlmIHRhYmxlTmFtZSBpcyBub3QgaW4gdGhlIEFycmF5IG9mIHRhYmxlcyBuYW1lcyB0aGVuIGRvbid0IGRyb3AgaXRcbiAgICAgIGlmICghc2tpcC5pbmNsdWRlcyh0YWJsZU5hbWUudGFibGVOYW1lIHx8IHRhYmxlTmFtZSkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kcm9wVGFibGUodGFibGVOYW1lLCB7IC4uLm9wdGlvbnMsIGNhc2NhZGU6IHRydWUgfSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCB0YWJsZXMgZnJvbSBkYXRhYmFzZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLnNraXBdIExpc3Qgb2YgdGFibGUgdG8gc2tpcFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG5cbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zaG93QWxsVGFibGVzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gYXdhaXQgdGhpcy5nZXRGb3JlaWduS2V5c0ZvclRhYmxlcyh0YWJsZU5hbWVzLCBvcHRpb25zKTtcblxuICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlTmFtZXMpIHtcbiAgICAgIGxldCBub3JtYWxpemVkVGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICBub3JtYWxpemVkVGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleSBvZiBmb3JlaWduS2V5c1tub3JtYWxpemVkVGFibGVOYW1lXSkge1xuICAgICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVuYW1lIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJlZm9yZSAgICBDdXJyZW50IG5hbWUgb2YgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFmdGVyICAgICBOZXcgbmFtZSBmcm9tIHRhYmxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbmFtZVRhYmxlKGJlZm9yZSwgYWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0YWJsZXMgaW4gY3VycmVudCBkYXRhYmFzZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgIFtvcHRpb25zLnJhdz10cnVlXSBSdW4gcXVlcnkgaW4gcmF3IG1vZGVcbiAgICogQHBhcmFtIHtRdWVyeVR5cGV9IFtvcHRpb25zLnR5cGU9UXVlcnlUeXBlLlNIT1dUQUJMRV0gcXVlcnkgdHlwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBzaG93QWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV1RBQkxFU1xuICAgIH07XG5cbiAgICBjb25zdCBzaG93VGFibGVzU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93VGFibGVzUXVlcnkodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKTtcbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc2hvd1RhYmxlc1NxbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF8uZmxhdHRlbih0YWJsZU5hbWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNjcmliZSBhIHRhYmxlIHN0cnVjdHVyZVxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IG9mIGhhc2hlcyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGFsbCBhdHRyaWJ1dGVzIGluIHRoZSB0YWJsZS5cbiAgICpcbiAgICogYGBganNcbiAgICoge1xuICAgKiAgICBuYW1lOiB7XG4gICAqICAgICAgdHlwZTogICAgICAgICAnVkFSQ0hBUigyNTUpJywgLy8gdGhpcyB3aWxsIGJlICdDSEFSQUNURVIgVkFSWUlORycgZm9yIHBnIVxuICAgKiAgICAgIGFsbG93TnVsbDogICAgdHJ1ZSxcbiAgICogICAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgICogICAgfSxcbiAgICogICAgaXNCZXRhTWVtYmVyOiB7XG4gICAqICAgICAgdHlwZTogICAgICAgICAnVElOWUlOVCgxKScsIC8vIHRoaXMgd2lsbCBiZSAnQk9PTEVBTicgZm9yIHBnIVxuICAgKiAgICAgIGFsbG93TnVsbDogICAgZmFsc2UsXG4gICAqICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICAgKiAgICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgdGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn1cbiAgICovXG4gIGFzeW5jIGRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IG51bGw7XG4gICAgbGV0IHNjaGVtYURlbGltaXRlciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hIHx8IG51bGw7XG4gICAgICBzY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlciB8fCBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnb2JqZWN0JyAmJiB0YWJsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWE7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpO1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuREVTQ1JJQkUgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICAgIC8qXG4gICAgICAgKiBJZiBubyBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LCB0aGVuIHRoZSB0YWJsZSBuYW1lIG1heSBiZSB3cm9uZy5cbiAgICAgICAqIFF1ZXJ5IGdlbmVyYXRvcnMgdGhhdCB1c2UgaW5mb3JtYXRpb25fc2NoZW1hIGZvciByZXRyaWV2aW5nIHRhYmxlIGluZm8gd2lsbCBqdXN0IHJldHVybiBhbiBlbXB0eSByZXN1bHQgc2V0LFxuICAgICAgICogaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgbGlrZSBidWlsdC1pbnMgZG8gKGUuZy4gREVTQ1JJQkUgb24gTXlTcWwpLlxuICAgICAgICovXG4gICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbCAmJiBlLm9yaWdpbmFsLmNvZGUgPT09ICdFUl9OT19TVUNIX1RBQkxFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGNvbHVtbiB0byBhIHRhYmxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbHVtbigndGFibGVBJywgJ2NvbHVtbkMnLCBTZXF1ZWxpemUuU1RSSU5HLCB7XG4gICAqICAgIGFmdGVyOiAnY29sdW1uQicgLy8gYWZ0ZXIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IE15U1FMXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlICAgICBUYWJsZSB0byBhZGQgY29sdW1uIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgICAgICAgQ29sdW1uIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgZGVmaW5pdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhZGRDb2x1bW4odGFibGUsIGtleSwgYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0YWJsZSB8fCAha2V5IHx8ICFhdHRyaWJ1dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkQ29sdW1uIHRha2VzIGF0IGxlYXN0IDMgYXJndW1lbnRzICh0YWJsZSwgYXR0cmlidXRlIG5hbWUsIGF0dHJpYnV0ZSBkZWZpbml0aW9uKScpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGF0dHJpYnV0ZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGF0dHJpYnV0ZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbHVtbiBmcm9tIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgIFRhYmxlIHRvIHJlbW92ZSBjb2x1bW4gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSAgQ29sdW1uIG5hbWUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgICBRdWVyeSBvcHRpb25zXG4gICAqL1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSwgb3B0aW9ucyk7XG4gIH1cblxuICBub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpIHtcbiAgICBsZXQgYXR0cmlidXRlO1xuICAgIGlmIChPYmplY3QudmFsdWVzKERhdGFUeXBlcykuaW5jbHVkZXMoZGF0YVR5cGVPck9wdGlvbnMpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7IHR5cGU6IGRhdGFUeXBlT3JPcHRpb25zLCBhbGxvd051bGw6IHRydWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlID0gZGF0YVR5cGVPck9wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSBhIGNvbHVtbiBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgICAgVGFibGUgbmFtZSB0byBjaGFuZ2UgZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSAgICAgIENvbHVtbiBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHlwZU9yT3B0aW9ucyAgQXR0cmlidXRlIGRlZmluaXRpb24gZm9yIG5ldyBjb2x1bW5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgICAgICBRdWVyeSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBjaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBkYXRhVHlwZU9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTCh7XG4gICAgICBbYXR0cmlidXRlTmFtZV06IHRoaXMubm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKVxuICAgIH0sIHtcbiAgICAgIGNvbnRleHQ6ICdjaGFuZ2VDb2x1bW4nLFxuICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBxdWVyeSk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWplY3RzIGlmIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgdGhlIHNwZWNpZmllZCBjb2x1bW4sIG90aGVyd2lzZSByZXR1cm5zIHRoZSBjb2x1bW4gZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKGRlc2NyaXB0aW9uW2NvbHVtbk5hbWVdKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVGFibGUgJHt0YWJsZU5hbWV9IGRvZXNuJ3QgaGF2ZSB0aGUgY29sdW1uICR7Y29sdW1uTmFtZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgYSBjb2x1bW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICAgVGFibGUgbmFtZSB3aG9zZSBjb2x1bW4gdG8gcmVuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZUJlZm9yZSAgIEN1cnJlbnQgY29sdW1uIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJOYW1lQWZ0ZXIgICAgTmV3IGNvbHVtbiBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgICAgIFF1ZXJ5IG9wdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbmFtZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZGF0YSA9IChhd2FpdCB0aGlzLmFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIG9wdGlvbnMpKVthdHRyTmFtZUJlZm9yZV07XG5cbiAgICBjb25zdCBfb3B0aW9ucyA9IHt9O1xuXG4gICAgX29wdGlvbnNbYXR0ck5hbWVBZnRlcl0gPSB7XG4gICAgICBhdHRyaWJ1dGU6IGF0dHJOYW1lQWZ0ZXIsXG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBhbGxvd051bGw6IGRhdGEuYWxsb3dOdWxsLFxuICAgICAgZGVmYXVsdFZhbHVlOiBkYXRhLmRlZmF1bHRWYWx1ZVxuICAgIH07XG5cbiAgICAvLyBmaXg6IGEgbm90LW51bGwgY29sdW1uIGNhbm5vdCBoYXZlIG51bGwgYXMgZGVmYXVsdCB2YWx1ZVxuICAgIGlmIChkYXRhLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCAmJiAhZGF0YS5hbGxvd051bGwpIHtcbiAgICAgIGRlbGV0ZSBfb3B0aW9uc1thdHRyTmFtZUFmdGVyXS5kZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVDb2x1bW5RdWVyeShcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIGF0dHJOYW1lQmVmb3JlLFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoX29wdGlvbnMpXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW5kZXggdG8gYSBjb2x1bW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgdGFibGVOYW1lIFRhYmxlIG5hbWUgdG8gYWRkIGluZGV4IG9uLCBjYW4gYmUgYSBvYmplY3Qgd2l0aCBzY2hlbWFcbiAgICogQHBhcmFtIHtBcnJheX0gICBbYXR0cmlidXRlc10gICAgIFVzZSBvcHRpb25zLmZpZWxkcyBpbnN0ZWFkLCBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gYWRkIGluZGV4IG9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICBpbmRleGVzIG9wdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gICBvcHRpb25zLmZpZWxkcyAgIExpc3Qgb2YgYXR0cmlidXRlcyB0byBhZGQgaW5kZXggb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb25jdXJyZW50bHldIFBhc3MgQ09OQ1VSUkVOVCBzbyBvdGhlciBvcGVyYXRpb25zIHJ1biB3aGlsZSB0aGUgaW5kZXggaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuaXF1ZV0gQ3JlYXRlIGEgdW5pcXVlIGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW29wdGlvbnMudXNpbmddICBVc2VmdWwgZm9yIEdJTiBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW29wdGlvbnMub3BlcmF0b3JdIEluZGV4IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgW29wdGlvbnMudHlwZV0gICBUeXBlIG9mIGluZGV4LCBhdmFpbGFibGUgb3B0aW9ucyBhcmUgVU5JUVVFfEZVTExURVhUfFNQQVRJQUxcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBbb3B0aW9ucy5uYW1lXSAgIE5hbWUgb2YgdGhlIGluZGV4LiBEZWZhdWx0IGlzIDx0YWJsZT5fPGF0dHIxPl88YXR0cjI+XG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnMud2hlcmVdICBXaGVyZSBjb25kaXRpb24gb24gaW5kZXgsIGZvciBwYXJ0aWFsIGluZGV4ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBbcmF3VGFibGVuYW1lXSAgIHRhYmxlIG5hbWUsIHRoaXMgaXMganVzdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpaXR5XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWRkSW5kZXgodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBwYXNzaW5nIHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyBvciB0YWJsZU5hbWUsIG9wdGlvbnMgKHdpdGggYSBmaWVsZHMgcGFyYW0gd2hpY2ggaXMgdGhlIGF0dHJpYnV0ZXMpXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICByYXdUYWJsZW5hbWUgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgICBhdHRyaWJ1dGVzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuXG4gICAgaWYgKCFyYXdUYWJsZW5hbWUpIHtcbiAgICAgIC8vIE1hcCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgICAgcmF3VGFibGVuYW1lID0gdGFibGVOYW1lO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5maWVsZHMgPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkSW5kZXhRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLCBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgaW5kZXhlcyBvbiBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgdGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBzaG93SW5kZXgodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLlNIT1dJTkRFWEVTIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZm9yZWlnbiBrZXkgY29uc3RyYWludHMgb2YgcmVxdWVzdGVkIHRhYmxlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YWJsZU5hbWVzIHRhYmxlIG5hbWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGdldEZvcmVpZ25LZXlzRm9yVGFibGVzKHRhYmxlTmFtZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFibGVOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTIH07XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwodGFibGVOYW1lcy5tYXAodGFibGVOYW1lID0+XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpLCBvcHRpb25zKSkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICB0YWJsZU5hbWVzLmZvckVhY2goKHRhYmxlTmFtZSwgaSkgPT4ge1xuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3RhYmxlTmFtZV0gPSBBcnJheS5pc0FycmF5KHJlc3VsdHNbaV0pXG4gICAgICAgID8gcmVzdWx0c1tpXS5tYXAociA9PiByLmNvbnN0cmFpbnRfbmFtZSlcbiAgICAgICAgOiBbcmVzdWx0c1tpXSAmJiByZXN1bHRzW2ldLmNvbnN0cmFpbnRfbmFtZV07XG5cbiAgICAgIHJlc3VsdFt0YWJsZU5hbWVdID0gcmVzdWx0W3RhYmxlTmFtZV0uZmlsdGVyKF8uaWRlbnRpdHkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZm9yZWlnbiBrZXkgcmVmZXJlbmNlcyBkZXRhaWxzIGZvciB0aGUgdGFibGVcbiAgICpcbiAgICogVGhvc2UgZGV0YWlscyBjb250YWlucyBjb25zdHJhaW50U2NoZW1hLCBjb25zdHJhaW50TmFtZSwgY29uc3RyYWludENhdGFsb2dcbiAgICogdGFibGVDYXRhbG9nLCB0YWJsZVNjaGVtYSwgdGFibGVOYW1lLCBjb2x1bW5OYW1lLFxuICAgKiByZWZlcmVuY2VkVGFibGVDYXRhbG9nLCByZWZlcmVuY2VkVGFibGVDYXRhbG9nLCByZWZlcmVuY2VkVGFibGVTY2hlbWEsIHJlZmVyZW5jZWRUYWJsZU5hbWUsIHJlZmVyZW5jZWRDb2x1bW5OYW1lLlxuICAgKiBSZW1pbmQ6IGNvbnN0cmFpbnQgaW5mb3JtYXRpb25zIHdvbid0IHJldHVybiBpZiBpdCdzIHNxbGl0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSB0YWJsZSBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gIFF1ZXJ5IG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVNcbiAgICB9O1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIHF1ZXJ5T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGFscmVhZHkgZXhpc3RpbmcgaW5kZXggZnJvbSBhIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgICAgICAgICAgICAgIFRhYmxlIG5hbWUgdG8gZHJvcCBpbmRleCBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBpbmRleE5hbWVPckF0dHJpYnV0ZXMgIEluZGV4IG5hbWUgb3IgbGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgaW4gdGhlIGluZGV4XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZW1vdmVJbmRleCh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY29uc3RyYWludCB0byBhIHRhYmxlXG4gICAqXG4gICAqIEF2YWlsYWJsZSBjb25zdHJhaW50czpcbiAgICogLSBVTklRVUVcbiAgICogLSBERUZBVUxUIChNU1NRTCBvbmx5KVxuICAgKiAtIENIRUNLIChNeVNRTCAtIElnbm9yZWQgYnkgdGhlIGRhdGFiYXNlIGVuZ2luZSApXG4gICAqIC0gRk9SRUlHTiBLRVlcbiAgICogLSBQUklNQVJZIEtFWVxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5VTklRVUU8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1VzZXJzJywge1xuICAgKiAgIGZpZWxkczogWydlbWFpbCddLFxuICAgKiAgIHR5cGU6ICd1bmlxdWUnLFxuICAgKiAgIG5hbWU6ICdjdXN0b21fdW5pcXVlX2NvbnN0cmFpbnRfbmFtZSdcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkNIRUNLPC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdVc2VycycsIHtcbiAgICogICBmaWVsZHM6IFsncm9sZXMnXSxcbiAgICogICB0eXBlOiAnY2hlY2snLFxuICAgKiAgIHdoZXJlOiB7XG4gICAqICAgICAgcm9sZXM6IFsndXNlcicsICdhZG1pbicsICdtb2RlcmF0b3InLCAnZ3Vlc3QnXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkRlZmF1bHQgLSBNU1NRTCBvbmx5PC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdVc2VycycsIHtcbiAgICogICAgZmllbGRzOiBbJ3JvbGVzJ10sXG4gICAqICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICogICAgZGVmYXVsdFZhbHVlOiAnZ3Vlc3QnXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5QcmltYXJ5IEtleTwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnVXNlcnMnLCB7XG4gICAqICAgIGZpZWxkczogWyd1c2VybmFtZSddLFxuICAgKiAgICB0eXBlOiAncHJpbWFyeSBrZXknLFxuICAgKiAgICBuYW1lOiAnY3VzdG9tX3ByaW1hcnlfY29uc3RyYWludF9uYW1lJ1xuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yZWlnbiBLZXk8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1Bvc3RzJywge1xuICAgKiAgIGZpZWxkczogWyd1c2VybmFtZSddLFxuICAgKiAgIHR5cGU6ICdmb3JlaWduIGtleScsXG4gICAqICAgbmFtZTogJ2N1c3RvbV9ma2V5X2NvbnN0cmFpbnRfbmFtZScsXG4gICAqICAgcmVmZXJlbmNlczogeyAvL1JlcXVpcmVkIGZpZWxkXG4gICAqICAgICB0YWJsZTogJ3RhcmdldF90YWJsZV9uYW1lJyxcbiAgICogICAgIGZpZWxkOiAndGFyZ2V0X2NvbHVtbl9uYW1lJ1xuICAgKiAgIH0sXG4gICAqICAgb25EZWxldGU6ICdjYXNjYWRlJyxcbiAgICogICBvblVwZGF0ZTogJ2Nhc2NhZGUnXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21wb3NpdGUgRm9yZWlnbiBLZXk8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1RhYmxlTmFtZScsIHtcbiAgICogICBmaWVsZHM6IFsnc291cmNlX2NvbHVtbl9uYW1lJywgJ290aGVyX3NvdXJjZV9jb2x1bW5fbmFtZSddLFxuICAgKiAgIHR5cGU6ICdmb3JlaWduIGtleScsXG4gICAqICAgbmFtZTogJ2N1c3RvbV9ma2V5X2NvbnN0cmFpbnRfbmFtZScsXG4gICAqICAgcmVmZXJlbmNlczogeyAvL1JlcXVpcmVkIGZpZWxkXG4gICAqICAgICB0YWJsZTogJ3RhcmdldF90YWJsZV9uYW1lJyxcbiAgICogICAgIGZpZWxkczogWyd0YXJnZXRfY29sdW1uX25hbWUnLCAnb3RoZXJfdGFyZ2V0X2NvbHVtbl9uYW1lJ11cbiAgICogICB9LFxuICAgKiAgIG9uRGVsZXRlOiAnY2FzY2FkZScsXG4gICAqICAgb25VcGRhdGU6ICdjYXNjYWRlJ1xuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICAgICAgICAgICAgICBUYWJsZSBuYW1lIHdoZXJlIHlvdSB3YW50IHRvIGFkZCBhIGNvbnN0cmFpbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3QgdG8gZGVmaW5lIHRoZSBjb25zdHJhaW50IG5hbWUsIHR5cGUgZXRjXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnR5cGUgICAgICAgICAgICAgICAgVHlwZSBvZiBjb25zdHJhaW50LiBPbmUgb2YgdGhlIHZhbHVlcyBpbiBhdmFpbGFibGUgY29uc3RyYWludHMoY2FzZSBpbnNlbnNpdGl2ZSlcbiAgICogQHBhcmFtIHtBcnJheX0gIG9wdGlvbnMuZmllbGRzICAgICAgICAgICAgICBBcnJheSBvZiBjb2x1bW4gbmFtZXMgdG8gYXBwbHkgdGhlIGNvbnN0cmFpbnQgb3ZlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gICAgICAgICAgICAgIE5hbWUgb2YgdGhlIGNvbnN0cmFpbnQuIElmIG5vdCBzcGVjaWZpZWQsIHNlcXVlbGl6ZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBuYW1lZCBjb25zdHJhaW50IGJhc2VkIG9uIGNvbnN0cmFpbnQgdHlwZSwgdGFibGUgJiBjb2x1bW4gbmFtZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRWYWx1ZV0gICAgICBUaGUgdmFsdWUgZm9yIHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndoZXJlXSAgICAgICAgICAgICBXaGVyZSBjbGF1c2UvZXhwcmVzc2lvbiBmb3IgdGhlIENIRUNLIGNvbnN0cmFpbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnJlZmVyZW5jZXNdICAgICAgICBPYmplY3Qgc3BlY2lmeWluZyB0YXJnZXQgdGFibGUsIGNvbHVtbiBuYW1lIHRvIGNyZWF0ZSBmb3JlaWduIGtleSBjb25zdHJhaW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWZlcmVuY2VzLnRhYmxlXSAgVGFyZ2V0IHRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZXMuZmllbGRdICBUYXJnZXQgY29sdW1uIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZXMuZmllbGRzXSBUYXJnZXQgY29sdW1uIG5hbWVzIGZvciBhIGNvbXBvc2l0ZSBwcmltYXJ5IGtleS4gTXVzdCBtYXRjaCB0aGUgb3JkZXIgb2YgZmllbGRzIGluIG9wdGlvbnMuZmllbGRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVmZXJyYWJsZV0gICAgICAgIFNldHMgdGhlIGNvbnN0cmFpbnQgdG8gYmUgZGVmZXJyZWQgb3IgaW1tZWRpYXRlbHkgY2hlY2tlZC4gU2VlIFNlcXVlbGl6ZS5EZWZlcnJhYmxlLiBQb3N0Z3JlU1FMIE9ubHlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhZGRDb25zdHJhaW50KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGRzIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy5maWVsZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50IHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLnR5cGUnKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHNob3dDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFMgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29uc3RyYWludCBmcm9tIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICBUYWJsZSBuYW1lIHRvIGRyb3AgY29uc3RyYWludCBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25zdHJhaW50TmFtZSAgQ29uc3RyYWludCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgUXVlcnkgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIGluc2VydChpbnN0YW5jZSwgdGFibGVOYW1lLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMuaGFzVHJpZ2dlcjtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuSU5TRVJUO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSkgcmVzdWx0c1swXS5pc05ld1JlY29yZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogVXBzZXJ0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgdGFibGUgdG8gdXBzZXJ0IG9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnNlcnRWYWx1ZXMgdmFsdWVzIHRvIGJlIGluc2VydGVkLCBtYXBwZWQgdG8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlVmFsdWVzIHZhbHVlcyB0byBiZSB1cGRhdGVkLCBtYXBwZWQgdG8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gd2hlcmUgICAgICAgIHdoZXJlIGNvbmRpdGlvbnMsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBVUERBVEUgcGFydCB3aGVuIElOU0VSVCBmYWlsc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgIHF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbiw/bnVtYmVyPn0gUmVzb2x2ZXMgYW4gYXJyYXkgd2l0aCA8Y3JlYXRlZCwgcHJpbWFyeUtleT5cbiAgICovXG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcChpdGVtID0+IGl0ZW0uZmllbGQpO1xuICAgIGNvbnN0IHVuaXF1ZUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLmZpbHRlcihjID0+IGMuZmllbGRzLmxlbmd0aCA+PSAxKS5tYXAoYyA9PiBjLmZpZWxkcyk7XG4gICAgY29uc3QgaW5kZXhLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5faW5kZXhlcykuZmlsdGVyKGMgPT4gYy51bmlxdWUgJiYgYy5maWVsZHMubGVuZ3RoID49IDEpLm1hcChjID0+IGMuZmllbGRzKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IFtdO1xuXG4gICAgLy8gRm9yIGZpZWxkcyBpbiB1cGRhdGVWYWx1ZXMsIHRyeSB0byBmaW5kIGEgY29uc3RyYWludCBvciB1bmlxdWUgaW5kZXhcbiAgICAvLyB0aGF0IGluY2x1ZGVzIGdpdmVuIGZpZWxkLiBPbmx5IGZpcnN0IG1hdGNoaW5nIHVwc2VydCBrZXkgaXMgdXNlZC5cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHVuaXF1ZUtleXMuZmluZChmaWVsZHMgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHVuaXF1ZUtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4S2V5ID0gaW5kZXhLZXlzLmZpbmQoZmllbGRzID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgaWYgKGluZGV4S2V5KSB7XG4gICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IGluZGV4S2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHdheXMgdXNlIFBLLCBpZiBubyBjb25zdHJhaW50IGF2YWlsYWJsZSBPUiB1cGRhdGUgZGF0YSBjb250YWlucyBQS1xuICAgIGlmIChcbiAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cy5sZW5ndGggPT09IDBcbiAgICAgIHx8IF8uaW50ZXJzZWN0aW9uKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUsIHByaW1hcnlLZXlzKS5sZW5ndGhcbiAgICApIHtcbiAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHByaW1hcnlLZXlzO1xuICAgIH1cblxuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IF8udW5pcShvcHRpb25zLnVwc2VydEtleXMpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgbW9kZWwucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IG11bHRpcGxlIHJlY29yZHMgaW50byBhIHRhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmJ1bGtJbnNlcnQoJ3JvbGVzJywgW3tcbiAgICogICAgbGFiZWw6ICd1c2VyJyxcbiAgICogICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgKiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICogIH0sIHtcbiAgICogICAgbGFiZWw6ICdhZG1pbicsXG4gICAqICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICogICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAqICB9XSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICBUYWJsZSBuYW1lIHRvIGluc2VydCByZWNvcmQgdG9cbiAgICogQHBhcmFtIHtBcnJheX0gIHJlY29yZHMgICAgIExpc3Qgb2YgcmVjb3JkcyB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgIFZhcmlvdXMgb3B0aW9ucywgcGxlYXNlIHNlZSBNb2RlbC5idWxrQ3JlYXRlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgIFZhcmlvdXMgYXR0cmlidXRlcyBtYXBwZWQgYnkgZmllbGQgbmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGJ1bGtJbnNlcnQodGFibGVOYW1lLCByZWNvcmRzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuSU5TRVJUO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5idWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCByZWNvcmRzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gIH1cblxuICBhc3luYyB1cGRhdGUoaW5zdGFuY2UsIHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMuaGFzVHJpZ2dlcjtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBkYXRlUXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIsIG9wdGlvbnMsIGluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG5cbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG11bHRpcGxlIHJlY29yZHMgb2YgYSB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBxdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKCdyb2xlcycsIHtcbiAgICogICAgIGxhYmVsOiAnYWRtaW4nLFxuICAgKiAgIH0sIHtcbiAgICogICAgIHVzZXJUeXBlOiAzLFxuICAgKiAgIH0sXG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgIFRhYmxlIG5hbWUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgICAgICAgIFZhbHVlcyB0byBiZSBpbnNlcnRlZCwgbWFwcGVkIHRvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGlkZW50aWZpZXIgICAgQSBoYXNoIHdpdGggY29uZGl0aW9ucyBPUiBhbiBJRCBhcyBpbnRlZ2VyIE9SIGEgc3RyaW5nIHdpdGggY29uZGl0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICBWYXJpb3VzIG9wdGlvbnMsIHBsZWFzZSBzZWUgTW9kZWwuYnVsa0NyZWF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbYXR0cmlidXRlc10gIEF0dHJpYnV0ZXMgb24gcmV0dXJuIG9iamVjdHMgaWYgc3VwcG9ydGVkIGJ5IFNRTCBkaWFsZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYnVsa1VwZGF0ZSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllciwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnb2JqZWN0JykgaWRlbnRpZmllciA9IFV0aWxzLmNsb25lRGVlcChpZGVudGlmaWVyKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBkYXRlUXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IHRhYmxlID0gXy5pc09iamVjdCh0YWJsZU5hbWUpID8gdGFibGVOYW1lIDogeyB0YWJsZU5hbWUgfTtcbiAgICBjb25zdCBtb2RlbCA9IF8uZmluZCh0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIubW9kZWxzLCB7IHRhYmxlTmFtZTogdGFibGUudGFibGVOYW1lIH0pO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZShpbnN0YW5jZSwgdGFibGVOYW1lLCBpZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FzY2FkZXMgPSBbXTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgaWRlbnRpZmllciwge30sIGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIC8vIENoZWNrIGZvciBhIHJlc3RyaWN0IGZpZWxkXG4gICAgaWYgKCEhaW5zdGFuY2UuY29uc3RydWN0b3IgJiYgISFpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICBsZXQgYXNzb2NpYXRpb247XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzb2NpYXRpb24gPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnNba2V5c1tpXV07XG4gICAgICAgIGlmIChhc3NvY2lhdGlvbi5vcHRpb25zICYmIGFzc29jaWF0aW9uLm9wdGlvbnMub25EZWxldGUgJiZcbiAgICAgICAgICBhc3NvY2lhdGlvbi5vcHRpb25zLm9uRGVsZXRlLnRvTG93ZXJDYXNlKCkgPT09ICdjYXNjYWRlJyAmJlxuICAgICAgICAgIGFzc29jaWF0aW9uLm9wdGlvbnMudXNlSG9va3MgPT09IHRydWUpIHtcbiAgICAgICAgICBjYXNjYWRlcy5wdXNoKGFzc29jaWF0aW9uLmFjY2Vzc29ycy5nZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjYXNjYWRlIG9mIGNhc2NhZGVzKSB7XG4gICAgICBsZXQgaW5zdGFuY2VzID0gYXdhaXQgaW5zdGFuY2VbY2FzY2FkZV0ob3B0aW9ucyk7XG4gICAgICAvLyBDaGVjayBmb3IgaGFzT25lIHJlbGF0aW9uc2hpcCB3aXRoIG5vbi1leGlzdGluZyBhc3NvY2lhdGUgKFwiaGFzIHplcm9cIilcbiAgICAgIGlmICghaW5zdGFuY2VzKSBjb250aW51ZTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykgYXdhaXQgX2luc3RhbmNlLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgbXVsdGlwbGUgcmVjb3JkcyBmcm9tIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0YWJsZU5hbWUgICAgICAgICAgICB0YWJsZSBuYW1lIGZyb20gd2hlcmUgdG8gZGVsZXRlIHJlY29yZHNcbiAgICogQHBhcmFtIHtvYmplY3R9ICB3aGVyZSAgICAgICAgICAgICAgICB3aGVyZSBjb25kaXRpb25zIHRvIGZpbmQgcmVjb3JkcyB0byBkZWxldGVcbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc10gICAgICAgICAgICBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJ1bmNhdGVdICAgVXNlIHRydW5jYXRlIHRhYmxlIGNvbW1hbmRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jYXNjYWRlPWZhbHNlXSAgICAgICAgIE9ubHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFRSVU5DQVRFLiBUcnVuY2F0ZXMgIGFsbCB0YWJsZXMgdGhhdCBoYXZlIGZvcmVpZ24ta2V5IHJlZmVyZW5jZXMgdG8gdGhlIG5hbWVkIHRhYmxlLCBvciB0byBhbnkgdGFibGVzIGFkZGVkIHRvIHRoZSBncm91cCBkdWUgdG8gQ0FTQ0FERS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHk9ZmFsc2VdIE9ubHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFRSVU5DQVRFLiBBdXRvbWF0aWNhbGx5IHJlc3RhcnQgc2VxdWVuY2VzIG93bmVkIGJ5IGNvbHVtbnMgb2YgdGhlIHRydW5jYXRlZCB0YWJsZS5cbiAgICogQHBhcmFtIHtNb2RlbH0gICBbbW9kZWxdICAgICAgICAgICAgICBNb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGJ1bGtEZWxldGUodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgbGltaXQ6IG51bGwgfSk7XG5cbiAgICBpZiAob3B0aW9ucy50cnVuY2F0ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ29iamVjdCcpIHdoZXJlID0gVXRpbHMuY2xvbmVEZWVwKHdoZXJlKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IuZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBhc3luYyBzZWxlY3QobW9kZWwsIHRhYmxlTmFtZSwgb3B0aW9uc0FyZykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLm9wdGlvbnNBcmcsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNULCBtb2RlbCB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5zZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIG1vZGVsKSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgaW5jcmVtZW50KG1vZGVsLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hcml0aG1ldGljUXVlcnkoJysnLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBkZWNyZW1lbnQobW9kZWwsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFyaXRobWV0aWNRdWVyeSgnLScsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHJhd1NlbGVjdCh0YWJsZU5hbWUsIG9wdGlvbnMsIGF0dHJpYnV0ZVNlbGVjdG9yLCBNb2RlbCkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcGxhaW46IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIE1vZGVsKTtcblxuICAgIGlmIChhdHRyaWJ1dGVTZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGxhaW4pIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEgPyBkYXRhW2F0dHJpYnV0ZVNlbGVjdG9yXSA6IG51bGw7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZGF0YVR5cGUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YVR5cGUgPSBvcHRpb25zLmRhdGFUeXBlO1xuXG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRFQ0lNQUwgfHwgZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRkxPQVQpIHtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLklOVEVHRVIgfHwgZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQklHSU5UKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LCAxMCk7XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFKSB7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmICEocmVzdWx0IGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBjcmVhdGVUcmlnZ2VyKFxuICAgIHRhYmxlTmFtZSxcbiAgICB0cmlnZ2VyTmFtZSxcbiAgICB0aW1pbmdUeXBlLFxuICAgIGZpcmVPbkFycmF5LFxuICAgIGZ1bmN0aW9uTmFtZSxcbiAgICBmdW5jdGlvblBhcmFtcyxcbiAgICBvcHRpb25zQXJyYXksXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgdGltaW5nVHlwZSwgZmlyZU9uQXJyYXksIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIG9wdGlvbnNBcnJheSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gU1FMIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmNyZWF0ZUZ1bmN0aW9uKFxuICAgKiAgICdzb21lRnVuY3Rpb24nLFxuICAgKiAgIFtcbiAgICogICAgIHt0eXBlOiAnaW50ZWdlcicsIG5hbWU6ICdwYXJhbScsIGRpcmVjdGlvbjogJ0lOJ31cbiAgICogICBdLFxuICAgKiAgICdpbnRlZ2VyJyxcbiAgICogICAncGxwZ3NxbCcsXG4gICAqICAgJ1JFVFVSTiBwYXJhbSArIDE7JyxcbiAgICogICBbXG4gICAqICAgICAnSU1NVVRBQkxFJyxcbiAgICogICAgICdMRUFLUFJPT0YnXG4gICAqICAgXSxcbiAgICogICB7XG4gICAqICAgIHZhcmlhYmxlczpcbiAgICogICAgICBbXG4gICAqICAgICAgICB7dHlwZTogJ2ludGVnZXInLCBuYW1lOiAnbXlWYXInLCBkZWZhdWx0OiAxMDB9XG4gICAqICAgICAgXSxcbiAgICogICAgICBmb3JjZTogdHJ1ZVxuICAgKiAgIH07XG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgZnVuY3Rpb25OYW1lICBOYW1lIG9mIFNRTCBmdW5jdGlvbiB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gICBwYXJhbXMgICAgICAgIExpc3Qgb2YgcGFyYW1ldGVycyBkZWNsYXJlZCBmb3IgU1FMIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgcmV0dXJuVHlwZSAgICBTUUwgdHlwZSBvZiBmdW5jdGlvbiByZXR1cm5lZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGxhbmd1YWdlICAgICAgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGluXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgYm9keSAgICAgICAgICBTb3VyY2UgY29kZSBvZiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSAgIG9wdGlvbnNBcnJheSAgRXh0cmEtb3B0aW9ucyBmb3IgY3JlYXRpb25cbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc10gICAgIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmZvcmNlIElmIGZvcmNlIGlzIHRydWUsIGFueSBleGlzdGluZyBmdW5jdGlvbnMgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHdpbGwgYmUgcmVwbGFjZWQuIEZvciBwb3N0Z3JlcywgdGhpcyBtZWFucyB1c2luZyBgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT05gIGluc3RlYWQgb2YgYENSRUFURSBGVU5DVElPTmAuIERlZmF1bHQgaXMgZmFsc2VcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSAgIG9wdGlvbnMudmFyaWFibGVzIExpc3Qgb2YgZGVjbGFyZWQgdmFyaWFibGVzLiBFYWNoIHZhcmlhYmxlIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgZmllbGRzIGB0eXBlYCBhbmQgYG5hbWVgLCBhbmQgb3B0aW9uYWxseSBoYXZpbmcgYSBgZGVmYXVsdGAgZmllbGQgYXMgd2VsbC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYW4gU1FMIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmRyb3BGdW5jdGlvbihcbiAgICogICAnc29tZUZ1bmN0aW9uJyxcbiAgICogICBbXG4gICAqICAgICB7dHlwZTogJ3ZhcmNoYXInLCBuYW1lOiAncGFyYW0xJywgZGlyZWN0aW9uOiAnSU4nfSxcbiAgICogICAgIHt0eXBlOiAnaW50ZWdlcicsIG5hbWU6ICdwYXJhbTInLCBkaXJlY3Rpb246ICdJTk9VVCd9XG4gICAqICAgXVxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIE5hbWUgb2YgU1FMIGZ1bmN0aW9uIHRvIGRyb3BcbiAgICogQHBhcmFtIHtBcnJheX0gIHBhcmFtcyAgICAgICBMaXN0IG9mIHBhcmFtZXRlcnMgZGVjbGFyZWQgZm9yIFNRTCBmdW5jdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgIHF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuYW1lIGFuIFNRTCBmdW5jdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBxdWVyeUludGVyZmFjZS5yZW5hbWVGdW5jdGlvbihcbiAgICogICAnZm9vRnVuY3Rpb24nLFxuICAgKiAgIFtcbiAgICogICAgIHt0eXBlOiAndmFyY2hhcicsIG5hbWU6ICdwYXJhbTEnLCBkaXJlY3Rpb246ICdJTid9LFxuICAgKiAgICAge3R5cGU6ICdpbnRlZ2VyJywgbmFtZTogJ3BhcmFtMicsIGRpcmVjdGlvbjogJ0lOT1VUJ31cbiAgICogICBdLFxuICAgKiAgICdiYXJGdW5jdGlvbidcbiAgICogKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZEZ1bmN0aW9uTmFtZSAgQ3VycmVudCBuYW1lIG9mIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9ICBwYXJhbXMgICAgICAgICAgIExpc3Qgb2YgcGFyYW1ldGVycyBkZWNsYXJlZCBmb3IgU1FMIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdGdW5jdGlvbk5hbWUgIE5ldyBuYW1lIG9mIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgICAgIHF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzIHVzZWZ1bCBmb3IgcXVlcnlpbmdcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVuc3VyZUVudW1zKCkge1xuICAgIC8vIG5vb3AgYnkgZGVmYXVsdFxuICB9XG5cbiAgYXN5bmMgc2V0SXNvbGF0aW9uTGV2ZWwodHJhbnNhY3Rpb24sIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgaXNvbGF0aW9uIGxldmVsIGZvciBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IScpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQgfHwgIXZhbHVlKSB7XG4gICAgICAvLyBOb3QgcG9zc2libGUgdG8gc2V0IGEgc2VwYXJhdGUgaXNvbGF0aW9uIGxldmVsIGZvciBzYXZlcG9pbnRzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9O1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlLCB7XG4gICAgICBwYXJlbnQ6IHRyYW5zYWN0aW9uLnBhcmVudFxuICAgIH0pO1xuXG4gICAgaWYgKCFzcWwpIHJldHVybjtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCEnKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH07XG4gICAgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lID0gdHJhbnNhY3Rpb24ucGFyZW50ID8gdHJhbnNhY3Rpb24ubmFtZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIGRlZmVyQ29uc3RyYWludHModHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH07XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNvbW1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjb21taXQgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCEnKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgLy8gU2F2ZXBvaW50cyBjYW5ub3QgYmUgY29tbWl0dGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uLFxuICAgICAgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlc1RyYW5zYWN0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG5cbiAgICB0cmFuc2FjdGlvbi5maW5pc2hlZCA9ICdjb21taXQnO1xuXG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH1cblxuICBhc3luYyByb2xsYmFja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByb2xsYmFjayBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IScpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbixcbiAgICAgIHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UsXG4gICAgICBjb21wbGV0ZXNUcmFuc2FjdGlvbjogdHJ1ZVxuICAgIH07XG4gICAgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lID0gdHJhbnNhY3Rpb24ucGFyZW50ID8gdHJhbnNhY3Rpb24ubmFtZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG5cbiAgICB0cmFuc2FjdGlvbi5maW5pc2hlZCA9ICdyb2xsYmFjayc7XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxufVxuXG5leHBvcnRzLlF1ZXJ5SW50ZXJmYWNlID0gUXVlcnlJbnRlcmZhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3NxbC1zdHJpbmcnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3QgRG90ID0gcmVxdWlyZSgnZG90dGllJyk7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9kZXByZWNhdGlvbnMnKTtcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5cbmNsYXNzIEFic3RyYWN0UXVlcnkge1xuXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudXVpZCA9IHV1aWQoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBvcHRpb25zLmluc3RhbmNlO1xuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHBsYWluOiBmYWxzZSxcbiAgICAgIHJhdzogZmFsc2UsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgbG9nZ2luZzogY29uc29sZS5sb2csXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLmNoZWNrTG9nZ2luZ09wdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJld3JpdGUgcXVlcnkgd2l0aCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgIHF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKCdzZWxlY3QgJDEgYXMgZm9vJywgWydmb292YWwnXSk7XG4gICAqXG4gICAqICAgcXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoJ3NlbGVjdCAkZm9vIGFzIGZvbycsIHsgZm9vOiAnZm9vdmFsJyB9KTtcbiAgICpcbiAgICogT3B0aW9uc1xuICAgKiAgIHNraXBVbmVzY2FwZTogYm9vbCwgc2tpcCB1bmVzY2FwaW5nICQkXG4gICAqICAgc2tpcFZhbHVlUmVwbGFjZTogYm9vbCwgZG8gbm90IHJlcGxhY2UgKGJ1dCBkbyB1bmVzY2FwZSAkJCkuIENoZWNrIGNvcnJlY3Qgc3ludGF4IGFuZCBpZiBhbGwgdmFsdWVzIGFyZSBhdmFpbGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gdmFsdWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFsZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXBsYWNlbWVudEZ1bmNdXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jLCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBbc3FsLCBbXV07XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSByZXBsYWNlbWVudEZ1bmMgfHwge307XG4gICAgICByZXBsYWNlbWVudEZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFyZXBsYWNlbWVudEZ1bmMpIHtcbiAgICAgIGlmIChvcHRpb25zLnNraXBWYWx1ZVJlcGxhY2UpIHtcbiAgICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlcykgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCkgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZXNba2V5XSwgdGltZVpvbmUsIGRpYWxlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5za2lwVmFsdWVSZXBsYWNlKSB7XG4gICAgICBjb25zdCBvcmlnUmVwbGFjZW1lbnRGdW5jID0gcmVwbGFjZW1lbnRGdW5jO1xuICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKG9yaWdSZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFsdWVzKTtcbiAgICBzcWwgPSBzcWwucmVwbGFjZSgvXFxCXFwkKFxcJHxcXHcrKS9nLCAobWF0Y2gsIGtleSkgPT4ge1xuICAgICAgaWYgKCckJyA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNraXBVbmVzY2FwZSA/IG1hdGNoIDoga2V5O1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVwbFZhbDtcbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIGlmIChrZXkubWF0Y2goL15bMS05XVxcZCokLykpIHtcbiAgICAgICAgICBrZXkgPSBrZXkgLSAxO1xuICAgICAgICAgIHJlcGxWYWwgPSByZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWtleS5tYXRjaCgvXlxcZCokLykpIHtcbiAgICAgICAgcmVwbFZhbCA9IHJlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lZCBiaW5kIHBhcmFtZXRlciBcIiR7bWF0Y2h9XCIgaGFzIG5vIHZhbHVlIGluIHRoZSBnaXZlbiBvYmplY3QuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbFZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gW3NxbCwgW11dO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIHBhc3NlZCBzcWwgcXVlcnkuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgcXVlcnkucnVuKCdTRUxFQ1QgMScpXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcnVuIG1ldGhvZCB3YXNuXFwndCBvdmVyd3JpdHRlbiEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgbG9nZ2luZyBvcHRpb24gb2YgdGhlIGluc3RhbmNlIGFuZCBwcmludCBkZXByZWNhdGlvbiB3YXJuaW5ncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrTG9nZ2luZ09wdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5vcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGluc2VydCBxdWVyeSwgd2hpY2ggY29udGFpbnMgdGhlIGp1c3QgaW5zZXJ0ZWQgaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmaWVsZCBuYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gJ2luc2VydElkJztcbiAgfVxuXG4gIGdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGZpZWxkID8gYCR7ZmllbGR9IG11c3QgYmUgdW5pcXVlYCA6ICdNdXN0IGJlIHVuaXF1ZSc7XG5cbiAgICBpZiAoZmllbGQgJiYgdGhpcy5tb2RlbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0uZmllbGRzLmluY2x1ZGVzKGZpZWxkLnJlcGxhY2UoL1wiL2csICcnKSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0ubXNnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0ubXNnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGlzUmF3UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlJBVztcbiAgfVxuXG4gIGlzVmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5WRVJTSU9OO1xuICB9XG5cbiAgaXNVcHNlcnRRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICB9XG5cbiAgaXNJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLklOU0VSVCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaXMgaW5zZXJ0IHF1ZXJ5IGlmIHNxbCBjb250YWlucyBpbnNlcnQgaW50b1xuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2luc2VydCBpbnRvJyk7XG5cbiAgICAvLyBpcyBpbnNlcnQgcXVlcnkgaWYgbm8gcmVzdWx0cyBhcmUgcGFzc2VkIG9yIGlmIHRoZSByZXN1bHQgaGFzIHRoZSBpbnNlcnRlZCBpZFxuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAoIXJlc3VsdHMgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIHRoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpKSk7XG5cbiAgICAvLyBpcyBpbnNlcnQgcXVlcnkgaWYgbm8gbWV0YWRhdGEgYXJlIHBhc3NlZCBvciBpZiB0aGUgbWV0YWRhdGEgaGFzIHRoZSBpbnNlcnRlZCBpZFxuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAoIW1ldGFEYXRhIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXRhRGF0YSwgdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCkpKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAvLyBhZGQgdGhlIGluc2VydGVkIHJvdyBpZCB0byB0aGUgaW5zdGFuY2VcbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgaWQgPSBudWxsO1xuXG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1t0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcblxuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50QXR0cmlidXRlXSA9IGlkO1xuICAgIH1cbiAgfVxuXG4gIGlzU2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XVEFCTEVTO1xuICB9XG5cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHJlc3VsdHMubWFwKHJlc3VsdFNldCA9PiBPYmplY3QudmFsdWVzKHJlc3VsdFNldCkpKTtcbiAgfVxuXG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV0lOREVYRVM7XG4gIH1cblxuICBpc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFM7XG4gIH1cblxuICBpc0Rlc2NyaWJlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkRFU0NSSUJFO1xuICB9XG5cbiAgaXNTZWxlY3RRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0VMRUNUO1xuICB9XG5cbiAgaXNCdWxrVXBkYXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gIH1cblxuICBpc0J1bGtEZWxldGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURTtcbiAgfVxuXG4gIGlzRm9yZWlnbktleXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVM7XG4gIH1cblxuICBpc1VwZGF0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5VUERBVEU7XG4gIH1cblxuICBoYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAvLyBNYXAgcmF3IGZpZWxkcyB0byBuYW1lcyBpZiBhIG1hcHBpbmcgaXMgcHJvdmlkZWRcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpZWxkTWFwKSB7XG4gICAgICBjb25zdCBmaWVsZE1hcCA9IHRoaXMub3B0aW9ucy5maWVsZE1hcDtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcChyZXN1bHQgPT4gXy5yZWR1Y2UoZmllbGRNYXAsIChyZXN1bHQsIG5hbWUsIGZpZWxkKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRbZmllbGRdICE9PSB1bmRlZmluZWQgJiYgbmFtZSAhPT0gZmllbGQpIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSByZXN1bHRbZmllbGRdO1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCByZXN1bHQpKTtcbiAgICB9XG5cbiAgICAvLyBSYXcgcXVlcmllc1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3KSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRzLm1hcChyZXN1bHQgPT4ge1xuICAgICAgICBsZXQgbyA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICBvW2tleV0gPSByZXN1bHRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5lc3QpIHtcbiAgICAgICAgICBvID0gRG90LnRyYW5zZm9ybShvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSk7XG4gICAgLy8gUXVlcmllcyB3aXRoIGluY2x1ZGVcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5oYXNKb2luID09PSB0cnVlKSB7XG4gICAgICByZXN1bHRzID0gQWJzdHJhY3RRdWVyeS5fZ3JvdXBKb2luRGF0YShyZXN1bHRzLCB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBpbmNsdWRlTWFwOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1hcCxcbiAgICAgICAgaW5jbHVkZU5hbWVzOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU5hbWVzXG4gICAgICB9LCB7XG4gICAgICAgIGNoZWNrRXhpc3Rpbmc6IHRoaXMub3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uXG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5idWxrQnVpbGQocmVzdWx0cywge1xuICAgICAgICBpc05ld1JlY29yZDogZmFsc2UsXG4gICAgICAgIGluY2x1ZGU6IHRoaXMub3B0aW9ucy5pbmNsdWRlLFxuICAgICAgICBpbmNsdWRlTmFtZXM6IHRoaXMub3B0aW9ucy5pbmNsdWRlTmFtZXMsXG4gICAgICAgIGluY2x1ZGVNYXA6IHRoaXMub3B0aW9ucy5pbmNsdWRlTWFwLFxuICAgICAgICBpbmNsdWRlVmFsaWRhdGVkOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICByYXc6IHRydWVcbiAgICAgIH0pO1xuICAgIC8vIFJlZ3VsYXIgcXVlcmllc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLm1vZGVsLmJ1bGtCdWlsZChyZXN1bHRzLCB7XG4gICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZSxcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGhlIGZpcnN0IHJlYWwgbW9kZWwgaW5zdGFuY2UgaWYgb3B0aW9ucy5wbGFpbiBpcyBzZXQgKGUuZy4gTW9kZWwuZmluZClcbiAgICBpZiAodGhpcy5vcHRpb25zLnBsYWluKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlc3VsdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlzU2hvd09yRGVzY3JpYmVRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdzaG93Jyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZGVzY3JpYmUnKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpc0NhbGxRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjYWxsJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWJ1Z0NvbnRleHRcbiAgICogQHBhcmFtIHtBcnJheXxvYmplY3R9IHBhcmFtZXRlcnNcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciB0aGUgcXVlcnkgd2FzIGNvbXBsZXRlZC5cbiAgICovXG4gIF9sb2dRdWVyeShzcWwsIGRlYnVnQ29udGV4dCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBiZW5jaG1hcmsgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmJlbmNobWFyayB8fCBvcHRpb25zLmJlbmNobWFyaztcbiAgICBjb25zdCBsb2dRdWVyeVBhcmFtZXRlcnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmxvZ1F1ZXJ5UGFyYW1ldGVycyB8fCBvcHRpb25zLmxvZ1F1ZXJ5UGFyYW1ldGVycztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBsb2dQYXJhbWV0ZXIgPSAnJztcblxuICAgIGlmIChsb2dRdWVyeVBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVsaW1pdGVyID0gc3FsLmVuZHNXaXRoKCc7JykgPyAnJyA6ICc7JztcbiAgICAgIGxldCBwYXJhbVN0cjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHBhcmFtU3RyID0gcGFyYW1ldGVycy5tYXAocD0+SlNPTi5zdHJpbmdpZnkocCkpLmpvaW4oJywgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbVN0ciA9IEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgICAgbG9nUGFyYW1ldGVyID0gYCR7ZGVsaW1pdGVyfSAke3BhcmFtU3RyfWA7XG4gICAgfVxuICAgIGNvbnN0IGZtdCA9IGAoJHtjb25uZWN0aW9uLnV1aWQgfHwgJ2RlZmF1bHQnfSk6ICR7c3FsfSR7bG9nUGFyYW1ldGVyfWA7XG4gICAgY29uc3QgbXNnID0gYEV4ZWN1dGluZyAke2ZtdH1gO1xuICAgIGRlYnVnQ29udGV4dChtc2cpO1xuICAgIGlmICghYmVuY2htYXJrKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYEV4ZWN1dGluZyAke2ZtdH1gLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGFmdGVyTXNnID0gYEV4ZWN1dGVkICR7Zm10fWA7XG4gICAgICBkZWJ1Z0NvbnRleHQoYWZ0ZXJNc2cpO1xuICAgICAgaWYgKGJlbmNobWFyaykge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYWZ0ZXJNc2csIERhdGUubm93KCkgLSBzdGFydFRpbWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRha2VzIHRoZSByZXN1bHQgb2YgdGhlIHF1ZXJ5IGV4ZWN1dGlvbiBhbmQgZ3JvdXBzXG4gICAqIHRoZSBhc3NvY2lhdGVkIGRhdGEgYnkgdGhlIGNhbGxlZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICBncm91cEpvaW5EYXRhKFtcbiAgICogICAgIHtcbiAgICogICAgICAgc29tZTogJ2RhdGEnLFxuICAgKiAgICAgICBpZDogMSxcbiAgICogICAgICAgYXNzb2NpYXRpb246IHsgZm9vOiAnYmFyJywgaWQ6IDEgfVxuICAgKiAgICAgfSwge1xuICAgKiAgICAgICBzb21lOiAnZGF0YScsXG4gICAqICAgICAgIGlkOiAxLFxuICAgKiAgICAgICBhc3NvY2lhdGlvbjogeyBmb286ICdiYXInLCBpZDogMiB9XG4gICAqICAgICB9LCB7XG4gICAqICAgICAgIHNvbWU6ICdkYXRhJyxcbiAgICogICAgICAgaWQ6IDEsXG4gICAqICAgICAgIGFzc29jaWF0aW9uOiB7IGZvbzogJ2JhcicsIGlkOiAzIH1cbiAgICogICAgIH1cbiAgICogICBdKVxuICAgKlxuICAgKiBSZXN1bHQ6XG4gICAqICAgU29tZXRoaW5nIGxpa2UgdGhpczpcbiAgICpcbiAgICogICBbXG4gICAqICAgICB7XG4gICAqICAgICAgIHNvbWU6ICdkYXRhJyxcbiAgICogICAgICAgaWQ6IDEsXG4gICAqICAgICAgIGFzc29jaWF0aW9uOiBbXG4gICAqICAgICAgICAgeyBmb286ICdiYXInLCBpZDogMSB9LFxuICAgKiAgICAgICAgIHsgZm9vOiAnYmFyJywgaWQ6IDIgfSxcbiAgICogICAgICAgICB7IGZvbzogJ2JhcicsIGlkOiAzIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIF1cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcm93c1xuICAgKiBAcGFyYW0ge29iamVjdH0gaW5jbHVkZU9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfZ3JvdXBKb2luRGF0YShyb3dzLCBpbmNsdWRlT3B0aW9ucywgb3B0aW9ucykge1xuXG4gICAgLypcbiAgICAgKiBBc3N1bXB0aW9uc1xuICAgICAqIElEIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgZmlyc3QgZmllbGRcbiAgICAgKiBBbGwgZmllbGRzIGZvciBhIGxldmVsIGlzIGdyb3VwZWQgaW4gdGhlIHNhbWUgc2V0IChpLmUuIFBhbmVsLmlkLCBUYXNrLmlkLCBQYW5lbC50aXRsZSBpcyBub3QgcG9zc2libGUpXG4gICAgICogUGFyZW50IGtleXMgd2lsbCBiZSBzZWVuIGJlZm9yZSBhbnkgaW5jbHVkZS9jaGlsZCBrZXlzXG4gICAgICogUHJldmlvdXMgc2V0IHdvbid0IG5lY2Vzc2FyaWx5IGJlIHBhcmVudCBzZXQgKG9uZSBwYXJlbnQgY291bGQgaGF2ZSB0d28gY2hpbGRyZW4sIG9uZSBjaGlsZCB3b3VsZCB0aGVuIGJlIHByZXZpb3VzIHNldCBmb3IgdGhlIG90aGVyKVxuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiBBdXRob3IgKE1IKSBjb21tZW50OiBUaGlzIGNvZGUgaXMgYW4gdW5yZWFkYWJsZSBtZXNzLCBidXQgaXQncyBwZXJmb3JtYW50LlxuICAgICAqIGdyb3VwSm9pbkRhdGEgaXMgYSBwZXJmb3JtYW5jZSBjcml0aWNhbCBmdW5jdGlvbiBzbyB3ZSBwcmlvcml0aXplIHBlcmYgb3ZlciByZWFkYWJpbGl0eS5cbiAgICAgKi9cbiAgICBpZiAoIXJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gR2VuZXJpYyBsb29waW5nXG4gICAgbGV0IGk7XG4gICAgbGV0IGxlbmd0aDtcbiAgICBsZXQgJGk7XG4gICAgbGV0ICRsZW5ndGg7XG4gICAgLy8gUm93IHNwZWNpZmljIGxvb3BpbmdcbiAgICBsZXQgcm93c0k7XG4gICAgbGV0IHJvdztcbiAgICBjb25zdCByb3dzTGVuZ3RoID0gcm93cy5sZW5ndGg7XG4gICAgLy8gS2V5IHNwZWNpZmljIGxvb3BpbmdcbiAgICBsZXQga2V5cztcbiAgICBsZXQga2V5O1xuICAgIGxldCBrZXlJO1xuICAgIGxldCBrZXlMZW5ndGg7XG4gICAgbGV0IHByZXZLZXk7XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgdG9wVmFsdWVzO1xuICAgIGxldCB0b3BFeGlzdHM7XG4gICAgY29uc3QgY2hlY2tFeGlzdGluZyA9IG9wdGlvbnMuY2hlY2tFeGlzdGluZztcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHRvIGRlZHVwbGljYXRlIHdlIGNhbiBwcmUtYWxsb2NhdGUgdGhlIHJlc3VsdGluZyBhcnJheVxuICAgIGxldCBpdGVtSGFzaDtcbiAgICBsZXQgcGFyZW50SGFzaDtcbiAgICBsZXQgdG9wSGFzaDtcbiAgICBjb25zdCByZXN1bHRzID0gY2hlY2tFeGlzdGluZyA/IFtdIDogbmV3IEFycmF5KHJvd3NMZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgIGNvbnN0IGluY2x1ZGVNYXAgPSB7fTtcbiAgICAvLyBSZXN1bHQgdmFyaWFibGVzIGZvciB0aGUgcmVzcGVjdGl2ZSBmdW5jdGlvbnNcbiAgICBsZXQgJGtleVByZWZpeDtcbiAgICBsZXQgJGtleVByZWZpeFN0cmluZztcbiAgICBsZXQgJHByZXZLZXlQcmVmaXhTdHJpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBsZXQgJHByZXZLZXlQcmVmaXg7XG4gICAgbGV0ICRsYXN0S2V5UHJlZml4O1xuICAgIGxldCAkY3VycmVudDtcbiAgICBsZXQgJHBhcmVudDtcbiAgICAvLyBNYXAgZWFjaCBrZXkgdG8gYW4gaW5jbHVkZSBvcHRpb25cbiAgICBsZXQgcHJldmlvdXNQaWVjZTtcbiAgICBjb25zdCBidWlsZEluY2x1ZGVNYXAgPSBwaWVjZSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCRjdXJyZW50LmluY2x1ZGVNYXAsIHBpZWNlKSkge1xuICAgICAgICBpbmNsdWRlTWFwW2tleV0gPSAkY3VycmVudCA9ICRjdXJyZW50LmluY2x1ZGVNYXBbcGllY2VdO1xuICAgICAgICBpZiAocHJldmlvdXNQaWVjZSkge1xuICAgICAgICAgIHByZXZpb3VzUGllY2UgPSBgJHtwcmV2aW91c1BpZWNlfS4ke3BpZWNlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZSA9IHBpZWNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVNYXBbcHJldmlvdXNQaWVjZV0gPSAkY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RyaW5nIHByZWZpeCBvZiBhIGtleSAoJ1VzZXIuUmVzdWx0cycgZm9yICdVc2VyLlJlc3VsdHMuaWQnKVxuICAgIGNvbnN0IGtleVByZWZpeFN0cmluZ01lbW8gPSB7fTtcbiAgICBjb25zdCBrZXlQcmVmaXhTdHJpbmcgPSAoa2V5LCBtZW1vKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZW1vLCBrZXkpKSB7XG4gICAgICAgIG1lbW9ba2V5XSA9IGtleS5zdWJzdHIoMCwga2V5Lmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW9ba2V5XTtcbiAgICB9O1xuICAgIC8vIFJlbW92ZXMgdGhlIHByZWZpeCBmcm9tIGEga2V5ICgnaWQnIGZvciAnVXNlci5SZXN1bHRzLmlkJylcbiAgICBjb25zdCByZW1vdmVLZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3QgcmVtb3ZlS2V5UHJlZml4ID0ga2V5ID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlbW92ZUtleVByZWZpeE1lbW8sIGtleSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBrZXkubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgcmVtb3ZlS2V5UHJlZml4TWVtb1trZXldID0ga2V5LnN1YnN0cihpbmRleCA9PT0gLTEgPyAwIDogaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVLZXlQcmVmaXhNZW1vW2tleV07XG4gICAgfTtcbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBhcnJheSBwcmVmaXggb2YgYSBrZXkgKFsnVXNlcicsICdSZXN1bHRzJ10gZm9yICdVc2VyLlJlc3VsdHMuaWQnKVxuICAgIGNvbnN0IGtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCBrZXlQcmVmaXggPSBrZXkgPT4ge1xuICAgICAgLy8gV2UgdXNlIGEgZG91YmxlIG1lbW8gYW5kIGtleVByZWZpeFN0cmluZyBzbyB0aGF0IGRpZmZlcmVudCBrZXlzIHdpdGggdGhlIHNhbWUgcHJlZml4IHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcnJheSBpbnN0ZWFkIG9mIGRpZmZlcm5ldCBhcnJheXMgd2l0aCBlcXVhbCB2YWx1ZXNcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleVByZWZpeE1lbW8sIGtleSkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4U3RyaW5nID0ga2V5UHJlZml4U3RyaW5nKGtleSwga2V5UHJlZml4U3RyaW5nTWVtbyk7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleVByZWZpeE1lbW8sIHByZWZpeFN0cmluZykpIHtcbiAgICAgICAgICBrZXlQcmVmaXhNZW1vW3ByZWZpeFN0cmluZ10gPSBwcmVmaXhTdHJpbmcgPyBwcmVmaXhTdHJpbmcuc3BsaXQoJy4nKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGtleVByZWZpeE1lbW9ba2V5XSA9IGtleVByZWZpeE1lbW9bcHJlZml4U3RyaW5nXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlQcmVmaXhNZW1vW2tleV07XG4gICAgfTtcbiAgICAvLyBDYWxjdWF0ZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBhcnJheSBwcmVmaXggKCdSZXN1bHRzJyBmb3IgJ1VzZXIuUmVzdWx0cy5pZCcpXG4gICAgY29uc3QgbGFzdEtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCBsYXN0S2V5UHJlZml4ID0ga2V5ID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhc3RLZXlQcmVmaXhNZW1vLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGtleVByZWZpeChrZXkpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwcmVmaXgubGVuZ3RoO1xuXG4gICAgICAgIGxhc3RLZXlQcmVmaXhNZW1vW2tleV0gPSAhbGVuZ3RoID8gJycgOiBwcmVmaXhbbGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdEtleVByZWZpeE1lbW9ba2V5XTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBtb2RlbCA9PiB7XG4gICAgICBsZXQgdW5pcXVlS2V5QXR0cmlidXRlcyA9IF8uY2hhaW4obW9kZWwudW5pcXVlS2V5cyk7XG4gICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gdW5pcXVlS2V5QXR0cmlidXRlc1xuICAgICAgICAucmVzdWx0KGAke3VuaXF1ZUtleUF0dHJpYnV0ZXMuZmluZEtleSgpfS5maWVsZHNgKVxuICAgICAgICAubWFwKGZpZWxkID0+IF8uZmluZEtleShtb2RlbC5hdHRyaWJ1dGVzLCBjaHIgPT4gY2hyLmZpZWxkID09PSBmaWVsZCkpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICByZXR1cm4gdW5pcXVlS2V5QXR0cmlidXRlcztcbiAgICB9O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IG9iaiA9PiBvYmogaW5zdGFuY2VvZiBCdWZmZXIgPyBvYmoudG9TdHJpbmcoJ2hleCcpIDogb2JqO1xuICAgIGxldCBwcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICBsZXQgdW5pcXVlS2V5QXR0cmlidXRlcztcbiAgICBsZXQgcHJlZml4O1xuXG4gICAgZm9yIChyb3dzSSA9IDA7IHJvd3NJIDwgcm93c0xlbmd0aDsgcm93c0krKykge1xuICAgICAgcm93ID0gcm93c1tyb3dzSV07XG5cbiAgICAgIC8vIEtleXMgYXJlIHRoZSBzYW1lIGZvciBhbGwgcm93cywgc28gb25seSBuZWVkIHRvIGNvbXB1dGUgdGhlbSBvbiB0aGUgZmlyc3Qgcm93XG4gICAgICBpZiAocm93c0kgPT09IDApIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHJvdyk7XG4gICAgICAgIGtleUxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICB0b3BFeGlzdHMgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRvcCBsZXZlbCBoYXNoIGtleSAodGhpcyBpcyB1c3VhbGx5IGp1c3QgdGhlIHByaW1hcnkga2V5IHZhbHVlcylcbiAgICAgICAgJGxlbmd0aCA9IGluY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgdG9wSGFzaCA9ICcnO1xuICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRvcEhhc2ggPSBzdHJpbmdpZnkocm93W2luY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICB0b3BIYXNoICs9IHN0cmluZ2lmeShyb3dbaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU9wdGlvbnMubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlT3B0aW9ucy5tb2RlbCk7XG4gICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgIHRvcEhhc2ggKz0gcm93W3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9wVmFsdWVzID0gdmFsdWVzID0ge307XG4gICAgICAkcHJldktleVByZWZpeCA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAoa2V5SSA9IDA7IGtleUkgPCBrZXlMZW5ndGg7IGtleUkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2tleUldO1xuXG4gICAgICAgIC8vIFRoZSBzdHJpbmcgcHJlZml4IGlzbid0IGFjdHVhbHkgbmVlZGVkXG4gICAgICAgIC8vIFdlIHVzZSBpdCBzbyBrZXlQcmVmaXggZm9yIGRpZmZlcmVudCBrZXlzIHdpbGwgcmVzb2x2ZSB0byB0aGUgc2FtZSBhcnJheSBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgcHJlZml4XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5P1xuICAgICAgICAka2V5UHJlZml4U3RyaW5nID0ga2V5UHJlZml4U3RyaW5nKGtleSwga2V5UHJlZml4U3RyaW5nTWVtbyk7XG4gICAgICAgICRrZXlQcmVmaXggPSBrZXlQcmVmaXgoa2V5KTtcblxuICAgICAgICAvLyBPbiB0aGUgZmlyc3Qgcm93IHdlIGNvbXB1dGUgdGhlIGluY2x1ZGVNYXBcbiAgICAgICAgaWYgKHJvd3NJID09PSAwICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5jbHVkZU1hcCwga2V5KSkge1xuICAgICAgICAgIGlmICghJGtleVByZWZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluY2x1ZGVNYXBba2V5XSA9IGluY2x1ZGVNYXBbJyddID0gaW5jbHVkZU9wdGlvbnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjdXJyZW50ID0gaW5jbHVkZU9wdGlvbnM7XG4gICAgICAgICAgICBwcmV2aW91c1BpZWNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgJGtleVByZWZpeC5mb3JFYWNoKGJ1aWxkSW5jbHVkZU1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBvZiBrZXkgc2V0XG4gICAgICAgIGlmICgkcHJldktleVByZWZpeCAhPT0gdW5kZWZpbmVkICYmICRwcmV2S2V5UHJlZml4ICE9PSAka2V5UHJlZml4KSB7XG4gICAgICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgaGFzaCBrZXkgZm9yIHRoaXMgc2V0IGluc3RhbmNlXG4gICAgICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZVxuICAgICAgICAgICAgbGVuZ3RoID0gJHByZXZLZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAgICAgJHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBwYXJlbnRIYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAkcGFyZW50ID8gYCR7JHBhcmVudH0uJHskcHJldktleVByZWZpeFtpXX1gIDogJHByZXZLZXlQcmVmaXhbaV07XG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgJGxlbmd0aCA9IHByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbMF19YF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkbGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1skaV19YF0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHJvd1tgJHtwcmVmaXh9LiR7dW5pcXVlS2V5QXR0cmlidXRlc1skaV19YF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50SGFzaCkge1xuICAgICAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggPSBwYXJlbnRIYXNoICsgaXRlbUhhc2g7XG4gICAgICAgICAgICAgICAgJHBhcmVudCA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEhhc2ggPSBpdGVtSGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW1IYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZW1IYXNoID09PSB0b3BIYXNoKSB7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgICAkcGFyZW50ID0gcmVzdWx0TWFwW3BhcmVudEhhc2hdO1xuICAgICAgICAgICAgICAkbGFzdEtleVByZWZpeCA9IGxhc3RLZXlQcmVmaXgocHJldktleSk7XG5cbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVNYXBbcHJldktleV0uYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICgkcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghJHBhcmVudFskbGFzdEtleVByZWZpeF0pIHtcbiAgICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdLnB1c2gocmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXQgdmFsdWVzXG4gICAgICAgICAgICB2YWx1ZXMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgY2hlY2tFeGlzdGluZyBpcyBmYWxzZSBpdCdzIGJlY2F1c2UgdGhlcmUncyBvbmx5IDE6MSBhc3NvY2lhdGlvbnMgaW4gdGhpcyBxdWVyeVxuICAgICAgICAgICAgLy8gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIG1hcCBvbnRvIHRoZSBhcHByb3ByaWF0ZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIEZvciAxOjEgd2UgbWFwIGZvcndhcmQsIGluaXRpYWxpemluZyB0aGUgdmFsdWUgb2JqZWN0IG9uIHRoZSBwYXJlbnQgdG8gYmUgZmlsbGVkIGluIHRoZSBuZXh0IGl0ZXJhdGlvbnMgb2YgdGhlIGxvb3BcbiAgICAgICAgICAgICRjdXJyZW50ID0gdG9wVmFsdWVzO1xuICAgICAgICAgICAgbGVuZ3RoID0gJGtleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMgPSAkY3VycmVudFska2V5UHJlZml4W2ldXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkY3VycmVudCA9ICRjdXJyZW50WyRrZXlQcmVmaXhbaV1dIHx8IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIG9mIGl0ZXJhdGlvbiwgc2V0IHZhbHVlIGFuZCBzZXQgcHJldiB2YWx1ZXMgKGZvciBuZXh0IGl0ZXJhdGlvbilcbiAgICAgICAgdmFsdWVzW3JlbW92ZUtleVByZWZpeChrZXkpXSA9IHJvd1trZXldO1xuICAgICAgICBwcmV2S2V5ID0ga2V5O1xuICAgICAgICAkcHJldktleVByZWZpeCA9ICRrZXlQcmVmaXg7XG4gICAgICAgICRwcmV2S2V5UHJlZml4U3RyaW5nID0gJGtleVByZWZpeFN0cmluZztcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgbGVuZ3RoID0gJHByZXZLZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAkcGFyZW50ID0gbnVsbDtcbiAgICAgICAgcGFyZW50SGFzaCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlZml4ID0gJHBhcmVudCA/IGAkeyRwYXJlbnR9LiR7JHByZXZLZXlQcmVmaXhbaV19YCA6ICRwcmV2S2V5UHJlZml4W2ldO1xuICAgICAgICAgICAgcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAkbGVuZ3RoID0gcHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaXRlbUhhc2ggPSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1swXX1gXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldfWBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsKTtcbiAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSByb3dbYCR7cHJlZml4fS4ke3VuaXF1ZUtleUF0dHJpYnV0ZXNbJGldfWBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudEhhc2gpIHtcbiAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1IYXNoID0gcGFyZW50SGFzaCArIGl0ZW1IYXNoO1xuICAgICAgICAgICAgJHBhcmVudCA9IHByZWZpeDtcbiAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gaXRlbUhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1IYXNoID0gdG9wSGFzaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtSGFzaCA9PT0gdG9wSGFzaCkge1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAkcGFyZW50ID0gcmVzdWx0TWFwW3BhcmVudEhhc2hdO1xuICAgICAgICAgICRsYXN0S2V5UHJlZml4ID0gbGFzdEtleVByZWZpeChwcmV2S2V5KTtcblxuICAgICAgICAgIGlmIChpbmNsdWRlTWFwW3ByZXZLZXldLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICAgIGlmICgkcGFyZW50KSB7XG4gICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEkcGFyZW50WyRsYXN0S2V5UHJlZml4XSkge1xuICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0ucHVzaChyZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3BFeGlzdHMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godG9wVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1tyb3dzSV0gPSB0b3BWYWx1ZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuQWJzdHJhY3RRdWVyeSA9IEFic3RyYWN0UXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RRdWVyeTtcbiIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gKCkgPT4gKFtdKTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0IHN5bmMgcmVjdXJzaXZlXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm1hcmlhZGI7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOm1hcmlhZGInKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnbWFyaWFkYicpO1xuXG4vKipcbiAqIE1hcmlhREIgQ29ubmVjdGlvbiBNYW5hZ2VyXG4gKlxuICogR2V0IGNvbm5lY3Rpb25zLCB2YWxpZGF0ZSBhbmQgZGlzY29ubmVjdCB0aGVtLlxuICogQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciBwb29saW5nIHVzZSBpdCB0byBoYW5kbGUgTWFyaWFEQiBzcGVjaWZpYyBjb25uZWN0aW9uc1xuICogVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXJpYURCL21hcmlhZGItY29ubmVjdG9yLW5vZGVqcyB0byBjb25uZWN0IHdpdGggTWFyaWFEQiBzZXJ2ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoJ21hcmlhZGInKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cblxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cblxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuXG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHdpdGggTWFyaWFEQiBkYXRhYmFzZSBiYXNlZCBvbiBjb25maWcsIEhhbmRsZSBhbnkgZXJyb3JzIGluIGNvbm5lY3Rpb25cbiAgICogU2V0IHRoZSBwb29sIGhhbmRsZXJzIG9uIGNvbm5lY3Rpb24uZXJyb3JcbiAgICogQWxzbyBzZXQgcHJvcGVyIHRpbWV6b25lIG9uY2UgY29ubmVjdGlvbiBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIC8vIE5hbWVkIHRpbWV6b25lIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbWFyaWFkYiwgY29udmVydCB0byBvZmZzZXRcbiAgICBsZXQgdHpPZmZzZXQgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lO1xuICAgIHR6T2Zmc2V0ID0gL1xcLy8udGVzdCh0ek9mZnNldCkgPyBtb21lbnRUei50eih0ek9mZnNldCkuZm9ybWF0KCdaJylcbiAgICAgIDogdHpPZmZzZXQ7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0ge1xuICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgdGltZXpvbmU6IHR6T2Zmc2V0LFxuICAgICAgdHlwZUNhc3Q6IENvbm5lY3Rpb25NYW5hZ2VyLl90eXBlY2FzdC5iaW5kKHRoaXMpLFxuICAgICAgYmlnTnVtYmVyU3RyaW5nczogZmFsc2UsXG4gICAgICBzdXBwb3J0QmlnTnVtYmVyczogdHJ1ZSxcbiAgICAgIGZvdW5kUm93czogZmFsc2UsXG4gICAgICAuLi5jb25maWcuZGlhbGVjdE9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgLy8gc2V0IHRpbWV6b25lIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KFxuICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCkpIHtcbiAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwgPSBbY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsXTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwucHVzaChgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCA9IGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmxpYi5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNvbm5lY3Rpb24uc2VydmVyVmVyc2lvbigpKS52ZXJzaW9uO1xuXG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiBhY3F1aXJlZCcpO1xuICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VTT0NLRVQnOlxuICAgICAgICAgIGNhc2UgJ0VDT05OUkVTRVQnOlxuICAgICAgICAgIGNhc2UgJ0VQSVBFJzpcbiAgICAgICAgICBjYXNlICdQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1QnOlxuICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ0VDT05OUkVGVVNFRCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VSX0FDQ0VTU19ERU5JRURfRVJST1InOlxuICAgICAgICBjYXNlICdFUl9BQ0NFU1NfREVOSUVEX05PX1BBU1NXT1JEX0VSUk9SJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VOT1RGT1VORCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFSE9TVFVOUkVBQ0gnOlxuICAgICAgICBjYXNlICdFTkVUVU5SRUFDSCc6XG4gICAgICAgIGNhc2UgJ0VBRERSTk9UQVZBSUwnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VJTlZBTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICAvLyBEb24ndCBkaXNjb25uZWN0IGNvbm5lY3Rpb25zIHdpdGggQ0xPU0VEIHN0YXRlXG4gICAgaWYgKCFjb25uZWN0aW9uLmlzVmFsaWQoKSkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xuICB9XG5cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uaXNWYWxpZCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB3a3ggPSByZXF1aXJlKCd3a3gnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUeXBlcyA9PiB7XG4gIEJhc2VUeXBlcy5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gJ2h0dHBzOi8vbWFyaWFkYi5jb20va2IvZW4vbGlicmFyeS9yZXN1bHRzZXQvI2ZpZWxkLXR5cGVzJztcblxuICAvKipcbiAgICogdHlwZXM6IFtidWZmZXJfdHlwZSwgLi4uXVxuICAgKlxuICAgKiBAc2VlIGRvY3VtZW50YXRpb24gOiBodHRwczovL21hcmlhZGIuY29tL2tiL2VuL2xpYnJhcnkvcmVzdWx0c2V0LyNmaWVsZC10eXBlc1xuICAgKiBAc2VlIGNvbm5lY3RvciBpbXBsZW1lbnRhdGlvbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYXJpYURCL21hcmlhZGItY29ubmVjdG9yLW5vZGVqcy9ibG9iL21hc3Rlci9saWIvY29uc3QvZmllbGQtdHlwZS5qc1xuICAgKi9cblxuICBCYXNlVHlwZXMuREFURS50eXBlcy5tYXJpYWRiID0gWydEQVRFVElNRSddO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm1hcmlhZGIgPSBbJ1ZBUl9TVFJJTkcnXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubWFyaWFkYiA9IFsnU1RSSU5HJ107XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm1hcmlhZGIgPSBbJ0JMT0InXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubWFyaWFkYiA9IFsnVElOWSddO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubWFyaWFkYiA9IFsnU0hPUlQnXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5tYXJpYWRiID0gWydJTlQyNCddO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5tYXJpYWRiID0gWydMT05HJ107XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubWFyaWFkYiA9IFsnTE9OR0xPTkcnXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm1hcmlhZGIgPSBbJ0ZMT0FUJ107XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm1hcmlhZGIgPSBbJ1RJTUUnXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm1hcmlhZGIgPSBbJ0RBVEUnXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubWFyaWFkYiA9IFsnVElOWSddO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5tYXJpYWRiID0gWydUSU5ZQkxPQicsICdCTE9CJywgJ0xPTkdCTE9CJ107XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm1hcmlhZGIgPSBbJ05FV0RFQ0lNQUwnXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubWFyaWFkYiA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5tYXJpYWRiID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm1hcmlhZGIgPSBbJ0RPVUJMRSddO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm1hcmlhZGIgPSBbJ0RPVUJMRSddO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubWFyaWFkYiA9IFsnR0VPTUVUUlknXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMubWFyaWFkYiA9IFsnSlNPTiddO1xuXG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHN1cGVyLnRvU3FsKCk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSAnIFVOU0lHTkVEJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICBkZWZpbml0aW9uICs9ICcgWkVST0ZJTEwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPyBgREFURVRJTUUoJHt0aGlzLl9sZW5ndGh9KWAgOiAnREFURVRJTUUnO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzLlNTUycpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vbWVudC50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50LnR6KHZhbHVlLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGAke3ZhbHVlfSAke29wdGlvbnMudGltZXpvbmV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0NIQVIoMzYpIEJJTkFSWSc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICAgIHN1cGVyKHR5cGUsIHNyaWQpO1xuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMua2V5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMudHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcigpO1xuICAgICAgLy8gRW1wdHkgYnVmZmVyLCBNeVNRTCBkb2Vzbid0IHN1cHBvcnQgUE9JTlQgRU1QVFlcbiAgICAgIC8vIGNoZWNrLCBodHRwczovL2Rldi5teXNxbC5jb20vd29ya2xvZy90YXNrLz9pZD0yMzgxXG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgZGlzY2FyZCB0aGUgZmlyc3QgNCBieXRlc1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSg0KTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UodmFsdWUpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNxbFR5cGU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYEVOVU0oJHt0aGlzLnZhbHVlcy5tYXAodmFsdWUgPT4gb3B0aW9ucy5lc2NhcGUodmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ3doZXJlJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWVcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBFTlVNLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgVVVJRCxcbiAgICBHRU9NRVRSWSxcbiAgICBERUNJTUFMLFxuICAgIEpTT046IEpTT05UWVBFXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKCcuLi9hYnN0cmFjdCcpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCB7IE15U1FMUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4uL215c3FsL3F1ZXJ5LWludGVyZmFjZScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm1hcmlhZGI7XG5cbmNsYXNzIE1hcmlhZGJEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTXlTUUxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5cbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXG4gIF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gICAgJ1ZBTFVFUyAoKSc6IHRydWUsXG4gICAgJ0xJTUlUIE9OIFVQREFURSc6IHRydWUsXG4gICAgbG9jazogdHJ1ZSxcbiAgICBmb3JTaGFyZTogJ0xPQ0sgSU4gU0hBUkUgTU9ERScsXG4gICAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IGZhbHNlLFxuICAgIHNjaGVtYXM6IHRydWUsXG4gICAgaW5zZXJ0czoge1xuICAgICAgaWdub3JlRHVwbGljYXRlczogJyBJR05PUkUnLFxuICAgICAgdXBkYXRlT25EdXBsaWNhdGU6ICcgT04gRFVQTElDQVRFIEtFWSBVUERBVEUnXG4gICAgfSxcbiAgICBpbmRleDoge1xuICAgICAgY29sbGF0ZTogZmFsc2UsXG4gICAgICBsZW5ndGg6IHRydWUsXG4gICAgICBwYXJzZXI6IHRydWUsXG4gICAgICB0eXBlOiB0cnVlLFxuICAgICAgdXNpbmc6IDFcbiAgICB9LFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICBkcm9wQ29uc3RyYWludDogZmFsc2UsXG4gICAgICBjaGVjazogZmFsc2VcbiAgICB9LFxuICAgIGluZGV4VmlhQWx0ZXI6IHRydWUsXG4gICAgaW5kZXhIaW50czogdHJ1ZSxcbiAgICBOVU1FUklDOiB0cnVlLFxuICAgIEdFT01FVFJZOiB0cnVlLFxuICAgIEpTT046IHRydWUsXG4gICAgUkVHRVhQOiB0cnVlXG4gIH0pO1xuXG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSAnMTAuMS40NCc7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5RdWVyeUdlbmVyYXRvciA9IFF1ZXJ5R2VuZXJhdG9yO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gJ21hcmlhZGInO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdgJztcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IE1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXJpYWRiRGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTXlTUUxRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL215c3FsL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLy4uLy4uL3V0aWxzJyk7XG5cbmNsYXNzIE1hcmlhREJRdWVyeUdlbmVyYXRvciBleHRlbmRzIE15U1FMUXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUkFDVEVSIFNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY2hhcnNldCl9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgREVGQVVMVCBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBgRFJPUCBTQ0hFTUEgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKX07YDtcbiAgfVxuXG4gIHNob3dTY2hlbWFzUXVlcnkob3B0aW9ucykge1xuICAgIGNvbnN0IHNjaGVtYXNUb1NraXAgPSBbXG4gICAgICAnXFwnTVlTUUxcXCcnLFxuICAgICAgJ1xcJ0lORk9STUFUSU9OX1NDSEVNQVxcJycsXG4gICAgICAnXFwnUEVSRk9STUFOQ0VfU0NIRU1BXFwnJ1xuICAgIF07XG4gICAgaWYgKG9wdGlvbnMuc2tpcCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2tpcCkgJiYgb3B0aW9ucy5za2lwLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hTmFtZSBvZiBvcHRpb25zLnNraXApIHtcbiAgICAgICAgc2NoZW1hc1RvU2tpcC5wdXNoKHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCBTQ0hFTUFfTkFNRSBhcyBzY2hlbWFfbmFtZScsXG4gICAgICAnRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuU0NIRU1BVEEnLFxuICAgICAgYFdIRVJFIFNDSEVNQV9OQU1FIE5PVCBJTiAoJHtzY2hlbWFzVG9Ta2lwLmpvaW4oJywgJyl9KWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHNob3dUYWJsZXNRdWVyeShkYXRhYmFzZSkge1xuICAgIGxldCBxdWVyeSA9ICdTRUxFQ1QgVEFCTEVfTkFNRSwgVEFCTEVfU0NIRU1BIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gXFwnQkFTRSBUQUJMRVxcJyc7XG4gICAgaWYgKGRhdGFiYXNlKSB7XG4gICAgICBxdWVyeSArPSBgIEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKGRhdGFiYXNlKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSArPSAnIEFORCBUQUJMRV9TQ0hFTUEgTk9UIElOIChcXCdNWVNRTFxcJywgXFwnSU5GT1JNQVRJT05fU0NIRU1BXFwnLCBcXCdQRVJGT1JNQU5DRV9TQ0hFTUFcXCcpJztcbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaWFEQlF1ZXJ5R2VuZXJhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnknKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuXG5jb25zdCBFUl9EVVBfRU5UUlkgPSAxMDYyO1xuY29uc3QgRVJfREVBRExPQ0sgPSAxMjEzO1xuY29uc3QgRVJfUk9XX0lTX1JFRkVSRU5DRUQgPSAxNDUxO1xuY29uc3QgRVJfTk9fUkVGRVJFTkNFRF9ST1cgPSAxNDUyO1xuXG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3NxbDptYXJpYWRiJyk7XG5cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgeyBzaG93V2FybmluZ3M6IGZhbHNlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0gW107XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlc18pID0+IHtcbiAgICAgIGlmICh2YWx1ZXNfW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaW5kUGFyYW0ucHVzaCh2YWx1ZXNfW2tleV0pO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbS5sZW5ndGggPiAwID8gYmluZFBhcmFtIDogdW5kZWZpbmVkXTtcbiAgfVxuXG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnNob3dXYXJuaW5ncyB8fCBvcHRpb25zLnNob3dXYXJuaW5ncztcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG5cbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgZGVidWcoJ3BhcmFtZXRlcnMoJWopJywgcGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdHM7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IGNvbm5lY3Rpb24ucXVlcnkodGhpcy5zcWwsIHBhcmFtZXRlcnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBlcnJvci5lcnJubyA9PT0gRVJfREVBRExPQ0spIHtcbiAgICAgICAgLy8gTWFyaWFEQiBhdXRvbWF0aWNhbGx5IHJvbGxzLWJhY2sgdHJhbnNhY3Rpb25zIGluIHRoZSBldmVudCBvZiBhIGRlYWRsb2NrLlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSBzdGlsbCBpbml0aWF0ZSBhIG1hbnVhbCByb2xsYmFjayB0byBlbnN1cmUgdGhlIGNvbm5lY3Rpb24gZ2V0cyByZWxlYXNlZCAtIHNlZSAjMTMxMDIuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgb3B0aW9ucy50cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIC0gc2luY2UgTWFyaWFEQiBhdXRvbWF0aWNhbGx5IHJvbGxlZCBiYWNrLCB3ZSdyZVxuICAgICAgICAgIC8vIG5vdCB0aGF0IHdvcnJpZWQgYWJvdXQgdGhpcyByZWR1bmRhbnQgcm9sbGJhY2sgZmFpbGluZy5cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgPSAncm9sbGJhY2snO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChzaG93V2FybmluZ3MgJiYgcmVzdWx0cyAmJiByZXN1bHRzLndhcm5pbmdTdGF0dXMgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1dhcm5pbmdzKHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgZXhlY3V0aW9uLlxuICAgKlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgcXVlcnkuZm9ybWF0UmVzdWx0cyhbXG4gICAqICAgIHtcbiAgICogICAgICBpZDogMSwgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIGF0dHIyOiAnc25hZnUnLCAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgVGFza3MuaWQ6IDEsICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgICBUYXNrcy50aXRsZTogJ3Rhc2snIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICB9XG4gICAqICBdKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gVGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgZXhlY3V0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYWZmZWN0ZWRSb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93cyA9PT0gMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG5cbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAvLyBoYW5kbGUgYnVsa0NyZWF0ZSBBSSBwcmltYXJ5IGtleVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5tb2RlbFxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gT05MWSBUUlVFIElGIEBhdXRvX2luY3JlbWVudF9pbmNyZW1lbnQgaXMgc2V0IHRvIDEgISFcbiAgICAgICAgICAvLyBEb2Vzbid0IHdvcmsgd2l0aCBHQUxFUkEgPT4gZWFjaCBub2RlIHdpbGwgcmVzZXJ2ZSBpbmNyZW1lbnQgKHggZm9yIGZpcnN0IHNlcnZlciwgeCsxIGZvciBuZXh0IG5vZGUuLi4pXG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShkYXRhLmFmZmVjdGVkUm93cyk7XG4gICAgICAgICAgY29uc3QgcGtGaWVsZCA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5hZmZlY3RlZFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0geyBbcGtGaWVsZF06IHN0YXJ0SWQgKyBpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2RhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldLCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZUpzb25TZWxlY3RRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBkYXRhLm1ldGE7XG4gICAgICBkZWxldGUgZGF0YS5tZXRhO1xuICAgICAgcmV0dXJuIFtkYXRhLCBtZXRhXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpIHx8IHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdlbnVtJykgPyBfcmVzdWx0LlR5cGUucmVwbGFjZSgvXmVudW0vaSxcbiAgICAgICAgICAgICdFTlVNJykgOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTnVsbCA9PT0gJ1lFUycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXkgPT09ICdQUkknLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCAnRXh0cmEnKVxuICAgICAgICAgICAgJiYgX3Jlc3VsdC5FeHRyYS50b0xvd2VyQ2FzZSgpID09PSAnYXV0b19pbmNyZW1lbnQnLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudCA/IF9yZXN1bHQuQ29tbWVudCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGhhbmRsZUpzb25TZWxlY3RRdWVyeShyb3dzKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsIHx8ICF0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IF9maWVsZCBvZiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcCkpIHtcbiAgICAgIGNvbnN0IG1vZGVsRmllbGQgPSB0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtfZmllbGRdO1xuICAgICAgaWYgKG1vZGVsRmllbGQudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgIC8vIFZhbHVlIGlzIHJldHVybmVkIGFzIFN0cmluZywgbm90IEpTT05cbiAgICAgICAgcm93cyA9IHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcm93W21vZGVsRmllbGQuZmllbGROYW1lXSA9IHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0gPyBKU09OLnBhcnNlKFxuICAgICAgICAgICAgcm93W21vZGVsRmllbGQuZmllbGROYW1lXSkgOiBudWxsO1xuICAgICAgICAgIGlmIChEYXRhVHlwZXMuSlNPTi5wYXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGFUeXBlcy5KU09OLnBhcnNlKG1vZGVsRmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsXG4gICAgICAgICAgICAgIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2dXYXJuaW5ncyhyZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FybmluZ1Jlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bignU0hPVyBXQVJOSU5HUycpO1xuICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYE1hcmlhREIgV2FybmluZ3MgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgJ2RlZmF1bHQnfSk6IGA7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IF93YXJuaW5nUm93IG9mIHdhcm5pbmdSZXN1bHRzKSB7XG4gICAgICBpZiAoX3dhcm5pbmdSb3cgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgX3dhcm5pbmdSb3dbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX3dhcm5pbmdSZXN1bHQgb2YgX3dhcm5pbmdSb3cpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfd2FybmluZ1Jlc3VsdCwgJ01lc3NhZ2UnKSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goX3dhcm5pbmdSZXN1bHQuTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBfb2JqZWN0S2V5IG9mIF93YXJuaW5nUmVzdWx0LmtleXMoKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChbX29iamVjdEtleSwgX3dhcm5pbmdSZXN1bHRbX29iamVjdEtleV1dLmpvaW4oJzogJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2VxdWVsaXplLmxvZyh3YXJuaW5nTWVzc2FnZSArIG1lc3NhZ2VzLmpvaW4oJzsgJyksIHRoaXMub3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIHN3aXRjaCAoZXJyLmVycm5vKSB7XG4gICAgICBjYXNlIEVSX0RVUF9FTlRSWToge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKFxuICAgICAgICAgIC9EdXBsaWNhdGUgZW50cnkgJyhbXFxzXFxTXSopJyBmb3Iga2V5ICc/KCgufFxccykqPyknP1xccy4qJC8pO1xuXG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBlcnJvcic7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoJy0nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmllbGRLZXkgPSBtYXRjaCA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmaWVsZFZhbCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW2ZpZWxkS2V5XTtcblxuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgaWYgKHVuaXF1ZUtleS5tc2cpIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkS2V5XSA9IGZpZWxkVmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICAgIHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksXG4gICAgICAgICAgICAndW5pcXVlIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuREIsXG4gICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAgICdub3RfdW5pcXVlJ1xuICAgICAgICAgICkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgRVJfUk9XX0lTX1JFRkVSRU5DRUQ6XG4gICAgICBjYXNlIEVSX05PX1JFRkVSRU5DRURfUk9XOiB7XG4gICAgICAgIC8vIGUuZy4gQ09OU1RSQUlOVCBgZXhhbXBsZV9jb25zdHJhaW50X25hbWVgIEZPUkVJR04gS0VZIChgZXhhbXBsZV9pZGApIFJFRkVSRU5DRVMgYGV4YW1wbGVzYCAoYGlkYClcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaChcbiAgICAgICAgICAvQ09OU1RSQUlOVCAoW2BcIl0pKC4qKVxcMSBGT1JFSUdOIEtFWSBcXChcXDEoLiopXFwxXFwpIFJFRkVSRU5DRVMgXFwxKC4qKVxcMSBcXChcXDEoLiopXFwxXFwpL1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ2AnO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBtYXRjaCA/IG1hdGNoWzNdLnNwbGl0KG5ldyBSZWdFeHAoYCR7cXVvdGVDaGFyfSwgKiR7cXVvdGVDaGFyfWApKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICByZWx0eXBlOiBlcnIuZXJybm8gPT09IEVSX1JPV19JU19SRUZFUkVOQ0VEID8gJ3BhcmVudCcgOiAnY2hpbGQnLFxuICAgICAgICAgIHRhYmxlOiBtYXRjaCA/IG1hdGNoWzRdIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzICYmIGZpZWxkcy5sZW5ndGggJiYgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkc1swXV0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGluZGV4OiBtYXRjaCA/IG1hdGNoWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAocmVzdWx0U2V0ID0+ICh7XG4gICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgfSkpO1xuICB9XG5cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG5cbiAgICBsZXQgY3Vyckl0ZW07XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBkYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoIWN1cnJJdGVtIHx8IGN1cnJJdGVtLm5hbWUgIT09IGl0ZW0uS2V5X25hbWUpIHtcbiAgICAgICAgY3Vyckl0ZW0gPSB7XG4gICAgICAgICAgcHJpbWFyeTogaXRlbS5LZXlfbmFtZSA9PT0gJ1BSSU1BUlknLFxuICAgICAgICAgIGZpZWxkczogW10sXG4gICAgICAgICAgbmFtZTogaXRlbS5LZXlfbmFtZSxcbiAgICAgICAgICB0YWJsZU5hbWU6IGl0ZW0uVGFibGUsXG4gICAgICAgICAgdW5pcXVlOiBpdGVtLk5vbl91bmlxdWUgIT09IDEsXG4gICAgICAgICAgdHlwZTogaXRlbS5JbmRleF90eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJJdGVtKTtcbiAgICAgIH1cblxuICAgICAgY3Vyckl0ZW0uZmllbGRzW2l0ZW0uU2VxX2luX2luZGV4IC0gMV0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogaXRlbS5Db2x1bW5fbmFtZSxcbiAgICAgICAgbGVuZ3RoOiBpdGVtLlN1Yl9wYXJ0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgb3JkZXI6IGl0ZW0uQ29sbGF0aW9uID09PSAnQScgPyAnQVNDJyA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzL2Jhc2UtZXJyb3InKTtcbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaXMgY2xvc2VkIHdoaWxlIGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICovXG5jbGFzcyBBc3luY1F1ZXVlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUFzeW5jUXVldWVFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0cy5Bc3luY1F1ZXVlRXJyb3IgPSBBc3luY1F1ZXVlRXJyb3I7XG5cbmNsYXNzIEFzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByZXZpb3VzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlamVjdEN1cnJlbnQgPSAoKSA9PiB7fTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5yZWplY3RDdXJyZW50KG5ldyBDb25uZWN0aW9uRXJyb3IobmV3IEFzeW5jUXVldWVFcnJvcigndGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgdGhpcyBxdWVyeSBjb3VsZCBmaW5pc2ggZXhlY3V0aW5nJykpKTtcbiAgfVxuICBlbnF1ZXVlKGFzeW5jRnVuY3Rpb24pIHtcbiAgICAvLyBUaGlzIG91dGVyIHByb21pc2UgbWlnaHQgc2VlbXMgc3VwZXJmbG91cyBzaW5jZSBkb3duIGJlbG93IHdlIHJldHVybiBhc3luY0Z1bmN0aW9uKCkudGhlbihyZXNvbHZlLCByZWplY3QpLlxuICAgIC8vIEhvd2V2ZXIsIHRoaXMgZW5zdXJlcyB0aGF0IHRoaXMucHJldmlvdXMgd2lsbCBuZXZlciBiZSBhIHJlamVjdGVkIHByb21pc2Ugc28gdGhlIHF1ZXVlIHdpbGxcbiAgICAvLyBhbHdheXMga2VlcCBnb2luZywgd2hpbGUgc3RpbGwgY29tbXVuaWNhdGluZyByZWplY3Rpb24gZnJvbSBhc3luY0Z1bmN0aW9uIHRvIHRoZSB1c2VyLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5wcmV2aW91cy50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWplY3RDdXJyZW50ID0gcmVqZWN0O1xuICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKG5ldyBBc3luY1F1ZXVlRXJyb3IoJ3RoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIHRoaXMgcXVlcnkgY291bGQgYmUgZXhlY3V0ZWQnKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN5bmNGdW5jdGlvbigpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBBc3luY1F1ZXVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBBc3luY1F1ZXVlID0gcmVxdWlyZSgnLi9hc3luYy1xdWV1ZScpLmRlZmF1bHQ7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5tc3NxbDtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnbXNzcWwnKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjptc3NxbCcpO1xuY29uc3QgZGVidWdUZWRpb3VzID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjptc3NxbDp0ZWRpb3VzJyk7XG5cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAxNDMzO1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZSgndGVkaW91cycpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuXG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG5cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0ge1xuICAgICAgc2VydmVyOiBjb25maWcuaG9zdCxcbiAgICAgIGF1dGhlbnRpY2F0aW9uOiB7XG4gICAgICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHVzZXJOYW1lOiBjb25maWcudXNlcm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQgfHwgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KGNvbmZpZy5wb3J0LCAxMCksXG4gICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgIHRydXN0U2VydmVyQ2VydGlmaWNhdGU6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgLy8gb25seSBzZXQgcG9ydCBpZiBubyBpbnN0YW5jZSBuYW1lIHdhcyBwcm92aWRlZFxuICAgICAgaWYgKFxuICAgICAgICBjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyAmJlxuICAgICAgICBjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucy5pbnN0YW5jZU5hbWVcbiAgICAgICkge1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNvbmZpZy5vcHRpb25zLnBvcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMuYXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uQ29uZmlnLmF1dGhlbnRpY2F0aW9uLCBjb25maWcuZGlhbGVjdE9wdGlvbnMuYXV0aGVudGljYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGNvbm5lY3Rpb25Db25maWcub3B0aW9ucywgY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IHRoaXMubGliLkNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXRlID09PSBjb25uZWN0aW9uLlNUQVRFLklOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgICAgIGNvbm5lY3Rpb24ubGliID0gdGhpcy5saWI7XG5cbiAgICAgICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSBlcnJvciA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kSGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcblxuICAgICAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGFjcXVpcmVkJyk7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gd2FzIGNsb3NlZCBieSByZW1vdGUgc2VydmVyJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGVycm9yID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZW5kJywgZW5kSGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnY29ubmVjdCcsIGNvbm5lY3RIYW5kbGVyKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBQZXJtYW5lbnRseSBhdHRhY2ggdGhpcyBldmVudCBiZWZvcmUgY29ubmVjdGlvbiBpcyBldmVuIGFjcXVpcmVkXG4gICAgICAgICAqIHRlZGlvdXMgc29tZXRpbWUgZW1pdHMgZXJyb3IgZXZlbiBhZnRlciBjb25uZWN0KHdpdGggZXJyb3IpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB3ZSBkb250IGF0dGFjaCB0aGlzIGV2ZW4gdGhhdCB1bmV4cGVjdGVkIGVycm9yIGV2ZW50IHdpbGwgY3Jhc2ggbm9kZSBwcm9jZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIEUuZy4gY29ubmVjdFRpbWVvdXQgaXMgc2V0IGhpZ2hlciB0aGFuIHJlcXVlc3RUaW1lb3V0XG4gICAgICAgICAqL1xuICAgICAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VTT0NLRVQnOlxuICAgICAgICAgICAgY2FzZSAnRUNPTk5SRVNFVCc6XG4gICAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLm9uKCdkZWJ1ZycsIGRlYnVnVGVkaW91cy5sb2cuYmluZChkZWJ1Z1RlZGlvdXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3IuY29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICBjYXNlICdFU09DS0VUJzpcbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY29ubmVjdCBFSE9TVFVOUkVBQ0gnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY29ubmVjdCBFTkVUVU5SRUFDSCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdjb25uZWN0IEVBRERSTk9UQVZBSUwnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZ2V0YWRkcmluZm8gRU5PVEZPVU5EJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnY29ubmVjdCBFQ09OTlJFRlVTRUQnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBjYXNlICdFUl9BQ0NFU1NfREVOSUVEX0VSUk9SJzpcbiAgICAgICAgY2FzZSAnRUxPR0lOJzpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycm9yKTtcbiAgICAgICAgY2FzZSAnRUlOVkFMJzpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICAvLyBEb24ndCBkaXNjb25uZWN0IGEgY29ubmVjdGlvbiB0aGF0IGlzIGFscmVhZHkgZGlzY29ubmVjdGVkXG4gICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5xdWV1ZS5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29ubmVjdGlvbi5vbignZW5kJywgcmVzb2x2ZSk7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiBjbG9zZWQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmxvZ2dlZEluO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHlwZXMgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh1bmRlZmluZWQsICdodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3NzUyJTI4dj1zcWwuMTEwJTI5LmFzcHgnKTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB1bnN1cHBvcnRlZCBNU1NRTCBvcHRpb25zLCBpLmUuLCBMRU5HVEgsIFVOU0lHTkVEIGFuZCBaRVJPRklMTCwgZm9yIHRoZSBpbnRlZ2VyIGRhdGEgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHlwZSBUaGUgYmFzZSBpbnRlZ2VyIGRhdGEgdHlwZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX2xlbmd0aCB8fCBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCB8fCBkYXRhVHlwZS5fdW5zaWduZWQgfHwgZGF0YVR5cGUuX3plcm9maWxsKSB7XG4gICAgICB3YXJuKGBNU1NRTCBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggb3B0aW9ucy4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHR5cGVzOiBbaGV4LCAuLi5dXG4gICAqXG4gICAqIEBzZWUgaGV4IGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL3RlZGlvdXNqcy90ZWRpb3VzL2Jsb2IvbWFzdGVyL3NyYy9kYXRhLXR5cGUudHNcbiAgICovXG5cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubXNzcWwgPSBbNDNdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm1zc3FsID0gWzIzMSwgMTczXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubXNzcWwgPSBbMTc1XTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4Nzc0NSh2PXNxbC4xMTApLmFzcHhcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubXNzcWwgPSBbMzBdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubXNzcWwgPSBbMzRdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm1zc3FsID0gWzM4XTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubXNzcWwgPSBbNDFdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubXNzcWwgPSBbNDBdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5tc3NxbCA9IFsxMDRdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5tc3NxbCA9IFsxNjVdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5tc3NxbCA9IFsxMDZdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5tc3NxbCA9IFsxMDldO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIC8vIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5tc3NxbCA9IFsyNDBdOyAvLyBub3QgeWV0IHN1cHBvcnRlZFxuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubXNzcWwgPSBmYWxzZTtcblxuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09ICd0aW55JykgeyAvLyB0aW55ID0gMl44XG4gICAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIHdpdGggdGhlIGBsZW5ndGhgID0gYHRpbnlgIG9wdGlvbi4gYFZBUkJJTkFSWSgyNTYpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgICByZXR1cm4gJ1ZBUkJJTkFSWSgyNTYpJztcbiAgICAgICAgfVxuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0Igd2l0aCB0aGUgYGxlbmd0aGAgb3B0aW9uLiBgVkFSQklOQVJZKE1BWClgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdWQVJCSU5BUlkoTUFYKSc7XG4gICAgfVxuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICByZXR1cm4gYDB4JHtoZXh9YDtcbiAgICB9XG4gIH1cblxuXG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKCF0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBOVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBCTE9CLnByb3RvdHlwZS5fc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl9iaW5hcnkgPyBCdWZmZXIuZnJvbSh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgU1RSSU5HLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgLy8gVEVYVCBpcyBkZXByZWNhdGVkIGluIG1zc3FsIGFuZCBpdCB3b3VsZCBub3JtYWxseSBiZSBzYXZlZCBhcyBhIG5vbi11bmljb2RlIHN0cmluZy5cbiAgICAgIC8vIFVzaW5nIHVuaWNvZGUgaXMganVzdCBmdXR1cmUgcHJvb2ZcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSAndGlueScpIHsgLy8gdGlueSA9IDJeOFxuICAgICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIHRoZSBgbGVuZ3RoYCA9IGB0aW55YCBvcHRpb24uIGBOVkFSQ0hBUigyNTYpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgICByZXR1cm4gJ05WQVJDSEFSKDI1NiknO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIHRoZSBgbGVuZ3RoYCBvcHRpb24uIGBOVkFSQ0hBUihNQVgpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnTlZBUkNIQVIoTUFYKSc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnQklUJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdDSEFSKDM2KSc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTk9XIGV4dGVuZHMgQmFzZVR5cGVzLk5PVyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0dFVERBVEUoKSc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnREFURVRJTUVPRkZTRVQnO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIC8vIE1TU1FMIGRvZXMgbm90IHN1cHBvcnQgYW55IG9wdGlvbnMgZm9yIHJlYWxcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFJFQUwgd2l0aCBvcHRpb25zLiBQbGFpbiBgUkVBTGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICAvLyBNU1NRTCBkb2VzIG9ubHkgc3VwcG9ydCBsZW5ndGhzIGFzIG9wdGlvbi5cbiAgICAgIC8vIFZhbHVlcyBiZXR3ZWVuIDEtMjQgcmVzdWx0IGluIDcgZGlnaXRzIHByZWNpc2lvbiAoNCBieXRlcyBzdG9yYWdlIHNpemUpXG4gICAgICAvLyBWYWx1ZXMgYmV0d2VlbiAyNS01MyByZXN1bHQgaW4gMTUgZGlnaXRzIHByZWNpc2lvbiAoOCBieXRlcyBzdG9yYWdlIHNpemUpXG4gICAgICAvLyBJZiBkZWNpbWFscyBhcmUgcHJvdmlkZWQgcmVtb3ZlIHRoZXNlIGFuZCBwcmludCBhIHdhcm5pbmdcbiAgICAgIGlmICh0aGlzLl9kZWNpbWFscykge1xuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHdpdGggZGVjaW1hbHMuIFBsYWluIGBGTE9BVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHVuc2lnbmVkLiBgVU5TSUdORURgIHdhcyByZW1vdmVkLicpO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHplcm9maWxsLiBgWkVST0ZJTExgIHdhcyByZW1vdmVkLicpO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnVkFSQ0hBUigyNTUpJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIEJMT0IsXG4gICAgQk9PTEVBTixcbiAgICBFTlVNLFxuICAgIFNUUklORyxcbiAgICBVVUlELFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgTk9XLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgUkVBTCxcbiAgICBGTE9BVCxcbiAgICBURVhUXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKCcuLi9hYnN0cmFjdCcpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubXNzcWw7XG5jb25zdCB7IE1TU3FsUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4vcXVlcnktaW50ZXJmYWNlJyk7XG5cbmNsYXNzIE1zc3FsRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE1TU3FsUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuXG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICAnREVGQVVMVCc6IHRydWUsXG4gICdERUZBVUxUIFZBTFVFUyc6IHRydWUsXG4gICdMSU1JVCBPTiBVUERBVEUnOiB0cnVlLFxuICAnT1JERVIgTlVMTFMnOiBmYWxzZSxcbiAgbG9jazogZmFsc2UsXG4gIHRyYW5zYWN0aW9uczogdHJ1ZSxcbiAgbWlncmF0aW9uczogZmFsc2UsXG4gIHJldHVyblZhbHVlczoge1xuICAgIG91dHB1dDogdHJ1ZVxuICB9LFxuICBzY2hlbWFzOiB0cnVlLFxuICBhdXRvSW5jcmVtZW50OiB7XG4gICAgaWRlbnRpdHlJbnNlcnQ6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICB1cGRhdGU6IGZhbHNlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IGZhbHNlLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogZmFsc2UsXG4gICAgd2hlcmU6IHRydWVcbiAgfSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgdG1wVGFibGVUcmlnZ2VyOiB0cnVlXG59KTtcblxuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9ICcxMi4wLjIwMDAnOyAvLyBTUUwgU2VydmVyIDIwMTQgRXhwcmVzc1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gJ21zc3FsJztcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSAnWyc7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9ICddJztcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1zc3FsRGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgVGFibGVIaW50cyA9IHJlcXVpcmUoJy4uLy4uL3RhYmxlLWhpbnRzJyk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9ycycpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdGhyb3dNZXRob2RVbmRlZmluZWQgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcihgVGhlIG1ldGhvZCBcIiR7bWV0aG9kTmFtZX1cIiBpcyBub3QgZGVmaW5lZCEgUGxlYXNlIGFkZCBpdCB0byB5b3VyIHNxbCBkaWFsZWN0LmApO1xufTtcblxuY2xhc3MgTVNTUUxRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IGNvbGxhdGU6IG51bGwsIC4uLm9wdGlvbnMgfTtcblxuICAgIGNvbnN0IGNvbGxhdGlvbiA9IG9wdGlvbnMuY29sbGF0ZSA/IGBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gIDogJyc7XG5cbiAgICByZXR1cm4gW1xuICAgICAgJ0lGIE5PVCBFWElTVFMgKFNFTEVDVCAqIEZST00gc3lzLmRhdGFiYXNlcyBXSEVSRSBuYW1lID0nLCB3cmFwU2luZ2xlUXVvdGUoZGF0YWJhc2VOYW1lKSwgJyknLFxuICAgICAgJ0JFR0lOJyxcbiAgICAgICdDUkVBVEUgREFUQUJBU0UnLCB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgYCR7Y29sbGF0aW9ufTtgLFxuICAgICAgJ0VORDsnXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ0lGIEVYSVNUUyAoU0VMRUNUICogRlJPTSBzeXMuZGF0YWJhc2VzIFdIRVJFIG5hbWUgPScsIHdyYXBTaW5nbGVRdW90ZShkYXRhYmFzZU5hbWUpLCAnKScsXG4gICAgICAnQkVHSU4nLFxuICAgICAgJ0RST1AgREFUQUJBU0UnLCB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLCAnOycsXG4gICAgICAnRU5EOydcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ0lGIE5PVCBFWElTVFMgKFNFTEVDVCBzY2hlbWFfbmFtZScsXG4gICAgICAnRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEnLFxuICAgICAgJ1dIRVJFIHNjaGVtYV9uYW1lID0nLCB3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKSwgJyknLFxuICAgICAgJ0JFR0lOJyxcbiAgICAgIFwiRVhFQyBzcF9leGVjdXRlc3FsIE4nQ1JFQVRFIFNDSEVNQVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIFwiOydcIixcbiAgICAgICdFTkQ7J1xuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICAvLyBNaW1pY3MgUG9zdGdyZXMgQ0FTQ0FERSwgd2lsbCBkcm9wIG9iamVjdHMgYmVsb25naW5nIHRvIHRoZSBzY2hlbWFcbiAgICBjb25zdCBxdW90ZWRTY2hlbWEgPSB3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKTtcbiAgICByZXR1cm4gW1xuICAgICAgJ0lGIEVYSVNUUyAoU0VMRUNUIHNjaGVtYV9uYW1lJyxcbiAgICAgICdGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YScsXG4gICAgICAnV0hFUkUgc2NoZW1hX25hbWUgPScsIHF1b3RlZFNjaGVtYSwgJyknLFxuICAgICAgJ0JFR0lOJyxcbiAgICAgICdERUNMQVJFIEBpZCBJTlQsIEBtc19zcWwgTlZBUkNIQVIoMjAwMCk7JyxcbiAgICAgICdERUNMQVJFIEBjYXNjYWRlIFRBQkxFICgnLFxuICAgICAgJ2lkIElOVCBOT1QgTlVMTCBJREVOVElUWSBQUklNQVJZIEtFWSwnLFxuICAgICAgJ21zX3NxbCBOVkFSQ0hBUigyMDAwKSBOT1QgTlVMTCApOycsXG4gICAgICAnSU5TRVJUIElOVE8gQGNhc2NhZGUgKCBtc19zcWwgKScsXG4gICAgICBcIlNFTEVDVCBDQVNFIFdIRU4gby50eXBlIElOICgnRicsJ1BLJylcIixcbiAgICAgIFwiVEhFTiBOJ0FMVEVSIFRBQkxFIFsnKyBzLm5hbWUgKyBOJ10uWycgKyBwLm5hbWUgKyBOJ10gRFJPUCBDT05TVFJBSU5UIFsnICsgby5uYW1lICsgTiddJ1wiLFxuICAgICAgXCJFTFNFIE4nRFJPUCBUQUJMRSBbJysgcy5uYW1lICsgTiddLlsnICsgby5uYW1lICsgTiddJyBFTkRcIixcbiAgICAgICdGUk9NIHN5cy5vYmplY3RzIG8nLFxuICAgICAgJ0pPSU4gc3lzLnNjaGVtYXMgcyBvbiBvLnNjaGVtYV9pZCA9IHMuc2NoZW1hX2lkJyxcbiAgICAgICdMRUZUIE9VVEVSIEpPSU4gc3lzLm9iamVjdHMgcCBvbiBvLnBhcmVudF9vYmplY3RfaWQgPSBwLm9iamVjdF9pZCcsXG4gICAgICBcIldIRVJFIG8udHlwZSBJTiAoJ0YnLCAnUEsnLCAnVScpIEFORCBzLm5hbWUgPSBcIiwgcXVvdGVkU2NoZW1hLFxuICAgICAgJ09SREVSIEJZIG8udHlwZSBBU0M7JyxcbiAgICAgICdTRUxFQ1QgVE9QIDEgQGlkID0gaWQsIEBtc19zcWwgPSBtc19zcWwgRlJPTSBAY2FzY2FkZSBPUkRFUiBCWSBpZDsnLFxuICAgICAgJ1dISUxFIEBpZCBJUyBOT1QgTlVMTCcsXG4gICAgICAnQkVHSU4nLFxuICAgICAgJ0JFR0lOIFRSWSBFWEVDIHNwX2V4ZWN1dGVzcWwgQG1zX3NxbDsgRU5EIFRSWScsXG4gICAgICAnQkVHSU4gQ0FUQ0ggQlJFQUs7IFRIUk9XOyBFTkQgQ0FUQ0g7JyxcbiAgICAgICdERUxFVEUgRlJPTSBAY2FzY2FkZSBXSEVSRSBpZCA9IEBpZDsnLFxuICAgICAgJ1NFTEVDVCBAaWQgPSBOVUxMLCBAbXNfc3FsID0gTlVMTDsnLFxuICAgICAgJ1NFTEVDVCBUT1AgMSBAaWQgPSBpZCwgQG1zX3NxbCA9IG1zX3NxbCBGUk9NIEBjYXNjYWRlIE9SREVSIEJZIGlkOycsXG4gICAgICAnRU5EJyxcbiAgICAgIFwiRVhFQyBzcF9leGVjdXRlc3FsIE4nRFJPUCBTQ0hFTUFcIiwgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSwgXCI7J1wiLFxuICAgICAgJ0VORDsnXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBbXG4gICAgICAnU0VMRUNUIFwibmFtZVwiIGFzIFwic2NoZW1hX25hbWVcIiBGUk9NIHN5cy5zY2hlbWFzIGFzIHMnLFxuICAgICAgJ1dIRVJFIFwic1wiLlwibmFtZVwiIE5PVCBJTiAoJyxcbiAgICAgIFwiJ0lORk9STUFUSU9OX1NDSEVNQScsICdkYm8nLCAnZ3Vlc3QnLCAnc3lzJywgJ2FyY2hpdmUnXCIsXG4gICAgICAnKScsICdBTkQnLCAnXCJzXCIuXCJuYW1lXCIgTk9UIExJS0UnLCBcIidkYl8lJ1wiXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgLy8gVXNlcyBzdHJpbmcgbWFuaXB1bGF0aW9uIHRvIGNvbnZlcnQgdGhlIE1TIE1hai5NaW4uUGF0Y2guQnVpbGQgdG8gc2VtdmVyIE1hai5NaW4uUGF0Y2hcbiAgICByZXR1cm4gW1xuICAgICAgJ0RFQ0xBUkUgQG1zX3ZlciBOVkFSQ0hBUigyMCk7JyxcbiAgICAgIFwiU0VUIEBtc192ZXIgPSBSRVZFUlNFKENPTlZFUlQoTlZBUkNIQVIoMjApLCBTRVJWRVJQUk9QRVJUWSgnUHJvZHVjdFZlcnNpb24nKSkpO1wiLFxuICAgICAgXCJTRUxFQ1QgUkVWRVJTRShTVUJTVFJJTkcoQG1zX3ZlciwgQ0hBUklOREVYKCcuJywgQG1zX3ZlcikrMSwgMjApKSBBUyAndmVyc2lvbidcIlxuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdLFxuICAgICAgZm9yZWlnbktleXMgPSB7fSxcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cyA9IFtdO1xuXG4gICAgbGV0IGNvbW1lbnRTdHIgPSAnJztcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGxldCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ0NPTU1FTlQgJykpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKENPTU1FTlQuKikkLyk7XG4gICAgICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50TWF0Y2hbMl0ucmVwbGFjZSgnQ09NTUVOVCcsICcnKS50cmltKCk7XG4gICAgICAgICAgY29tbWVudFN0ciArPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShjb21tZW50VGV4dCwgdGFibGVOYW1lLCBhdHRyKTtcbiAgICAgICAgICAvLyByZW1vdmUgY29tbWVudCByZWxhdGVkIHN1YnN0cmluZyBmcm9tIGRhdGFUeXBlXG4gICAgICAgICAgZGF0YVR5cGUgPSBjb21tZW50TWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpIHtcbiAgICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuXG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgICAgIC8vIE1TU1FMIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgUkVGRVJFTkNFUyBkZWNsYXJhdGlvbnM6IG1vdmUgdG8gdGhlIGVuZFxuICAgICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICcnKX1gKTtcbiAgICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJycpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgICAgLy8gTVNTUUwgZG9lc24ndCBzdXBwb3J0IGlubGluZSBSRUZFUkVOQ0VTIGRlY2xhcmF0aW9uczogbW92ZSB0byB0aGUgZW5kXG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKHBrID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbignLCAnKTtcblxuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oJ18nKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgQ09OU1RSQUlOVCAke1xuICAgICAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKVxuICAgICAgICAgIH0gVU5JUVVFICgke1xuICAgICAgICAgICAgY29sdW1ucy5maWVsZHMubWFwKGZpZWxkID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbignLCAnKVxuICAgICAgICAgIH0pYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBJRiBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGVOYW1lfScsICdVJykgSVMgTlVMTGAsXG4gICAgICBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfSAoJHthdHRyaWJ1dGVzQ2xhdXNlUGFydHMuam9pbignLCAnKX0pYCxcbiAgICAgICc7JyxcbiAgICAgIGNvbW1lbnRTdHJcbiAgICBdKTtcbiAgfVxuXG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGxldCBzcWwgPSBbXG4gICAgICAnU0VMRUNUJyxcbiAgICAgIFwiYy5DT0xVTU5fTkFNRSBBUyAnTmFtZScsXCIsXG4gICAgICBcImMuREFUQV9UWVBFIEFTICdUeXBlJyxcIixcbiAgICAgIFwiYy5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEggQVMgJ0xlbmd0aCcsXCIsXG4gICAgICBcImMuSVNfTlVMTEFCTEUgYXMgJ0lzTnVsbCcsXCIsXG4gICAgICBcIkNPTFVNTl9ERUZBVUxUIEFTICdEZWZhdWx0JyxcIixcbiAgICAgIFwicGsuQ09OU1RSQUlOVF9UWVBFIEFTICdDb25zdHJhaW50JyxcIixcbiAgICAgIFwiQ09MVU1OUFJPUEVSVFkoT0JKRUNUX0lEKGMuVEFCTEVfU0NIRU1BKycuJytjLlRBQkxFX05BTUUpLCBjLkNPTFVNTl9OQU1FLCAnSXNJZGVudGl0eScpIGFzICdJc0lkZW50aXR5JyxcIixcbiAgICAgIFwiQ0FTVChwcm9wLnZhbHVlIEFTIE5WQVJDSEFSKSBBUyAnQ29tbWVudCdcIixcbiAgICAgICdGUk9NJyxcbiAgICAgICdJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIHQnLFxuICAgICAgJ0lOTkVSIEpPSU4nLFxuICAgICAgJ0lORk9STUFUSU9OX1NDSEVNQS5DT0xVTU5TIGMgT04gdC5UQUJMRV9OQU1FID0gYy5UQUJMRV9OQU1FIEFORCB0LlRBQkxFX1NDSEVNQSA9IGMuVEFCTEVfU0NIRU1BJyxcbiAgICAgICdMRUZUIEpPSU4gKFNFTEVDVCB0Yy50YWJsZV9zY2hlbWEsIHRjLnRhYmxlX25hbWUsICcsXG4gICAgICAnY3UuY29sdW1uX25hbWUsIHRjLkNPTlNUUkFJTlRfVFlQRSAnLFxuICAgICAgJ0ZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTIHRjICcsXG4gICAgICAnSk9JTiBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSAgY3UgJyxcbiAgICAgICdPTiB0Yy50YWJsZV9zY2hlbWE9Y3UudGFibGVfc2NoZW1hIGFuZCB0Yy50YWJsZV9uYW1lPWN1LnRhYmxlX25hbWUgJyxcbiAgICAgICdhbmQgdGMuY29uc3RyYWludF9uYW1lPWN1LmNvbnN0cmFpbnRfbmFtZSAnLFxuICAgICAgJ2FuZCB0Yy5DT05TVFJBSU5UX1RZUEU9XFwnUFJJTUFSWSBLRVlcXCcpIHBrICcsXG4gICAgICAnT04gcGsudGFibGVfc2NoZW1hPWMudGFibGVfc2NoZW1hICcsXG4gICAgICAnQU5EIHBrLnRhYmxlX25hbWU9Yy50YWJsZV9uYW1lICcsXG4gICAgICAnQU5EIHBrLmNvbHVtbl9uYW1lPWMuY29sdW1uX25hbWUgJyxcbiAgICAgICdJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIEFTIHNjJyxcbiAgICAgIFwiT04gc2Mub2JqZWN0X2lkID0gb2JqZWN0X2lkKHQudGFibGVfc2NoZW1hICsgJy4nICsgdC50YWJsZV9uYW1lKSBBTkQgc2MubmFtZSA9IGMuY29sdW1uX25hbWVcIixcbiAgICAgICdMRUZUIEpPSU4gc3lzLmV4dGVuZGVkX3Byb3BlcnRpZXMgcHJvcCBPTiBwcm9wLm1ham9yX2lkID0gc2Mub2JqZWN0X2lkJyxcbiAgICAgICdBTkQgcHJvcC5taW5vcl9pZCA9IHNjLmNvbHVtbl9pZCcsXG4gICAgICBcIkFORCBwcm9wLm5hbWUgPSAnTVNfRGVzY3JpcHRpb24nXCIsXG4gICAgICAnV0hFUkUgdC5UQUJMRV9OQU1FID0nLCB3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKVxuICAgIF0uam9pbignICcpO1xuXG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgc3FsICs9IGBBTkQgdC5UQUJMRV9TQ0hFTUEgPSR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYSl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIGBFWEVDIHNwX3JlbmFtZSAke3RoaXMucXVvdGVUYWJsZShiZWZvcmUpfSwgJHt0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpfTtgO1xuICB9XG5cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBUQUJMRV9OQU1FLCBUQUJMRV9TQ0hFTUEgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSc7XCI7XG4gIH1cblxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZVRibCA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBJRiBPQkpFQ1RfSUQoJyR7cXVvdGVUYmx9JywgJ1UnKSBJUyBOT1QgTlVMTGAsXG4gICAgICAnRFJPUCBUQUJMRScsXG4gICAgICBxdW90ZVRibCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICAvLyBGSVhNRTogYXR0cmlidXRlVG9TUUwgU0hPVUxEIGJlIHVzaW5nIGF0dHJpYnV0ZXMgaW4gYWRkQ29sdW1uUXVlcnlcbiAgICAvLyAgICAgICAgYnV0IGluc3RlYWQgd2UgbmVlZCB0byBwYXNzIHRoZSBrZXkgYWxvbmcgYXMgdGhlIGZpZWxkIGhlcmVcbiAgICBkYXRhVHlwZS5maWVsZCA9IGtleTtcbiAgICBsZXQgY29tbWVudFN0ciA9ICcnO1xuXG4gICAgaWYgKGRhdGFUeXBlLmNvbW1lbnQgJiYgXy5pc1N0cmluZyhkYXRhVHlwZS5jb21tZW50KSkge1xuICAgICAgY29tbWVudFN0ciA9IHRoaXMuY29tbWVudFRlbXBsYXRlKGRhdGFUeXBlLmNvbW1lbnQsIHRhYmxlLCBrZXkpO1xuICAgICAgLy8gYXR0cmlidXRlVG9TUUwgd2lsbCB0cnkgdG8gaW5jbHVkZSBgQ09NTUVOVCAnQ29tbWVudCBUZXh0J2Agd2hlbiBpdCByZXR1cm5zIGlmIHRoZSBjb21tZW50IGtleVxuICAgICAgLy8gaXMgcHJlc2VudC4gVGhpcyBpcyBuZWVkZWQgZm9yIGNyZWF0ZVRhYmxlIHN0YXRlbWVudCB3aGVyZSB0aGF0IHBhcnQgaXMgZXh0cmFjdGVkIHdpdGggcmVnZXguXG4gICAgICAvLyBIZXJlIHdlIGNhbiBpbnRlcmNlcHQgdGhlIG9iamVjdCBhbmQgcmVtb3ZlIGNvbW1lbnQgcHJvcGVydHkgc2luY2Ugd2UgaGF2ZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgZGVsZXRlIGRhdGFUeXBlWydjb21tZW50J107XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICAnQUREJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7IGNvbnRleHQ6ICdhZGRDb2x1bW4nIH0pLFxuICAgICAgJzsnLFxuICAgICAgY29tbWVudFN0clxuICAgIF0pO1xuICB9XG5cbiAgY29tbWVudFRlbXBsYXRlKGNvbW1lbnQsIHRhYmxlLCBjb2x1bW4pIHtcbiAgICByZXR1cm4gJyBFWEVDIHNwX2FkZGV4dGVuZGVkcHJvcGVydHkgJyArXG4gICAgICAgIGBAbmFtZSA9IE4nTVNfRGVzY3JpcHRpb24nLCBAdmFsdWUgPSAke3RoaXMuZXNjYXBlKGNvbW1lbnQpfSwgYCArXG4gICAgICAgICdAbGV2ZWwwdHlwZSA9IE5cXCdTY2hlbWFcXCcsIEBsZXZlbDBuYW1lID0gXFwnZGJvXFwnLCAnICtcbiAgICAgICAgYEBsZXZlbDF0eXBlID0gTidUYWJsZScsIEBsZXZlbDFuYW1lID0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZSl9LCBgICtcbiAgICAgICAgYEBsZXZlbDJ0eXBlID0gTidDb2x1bW4nLCBAbGV2ZWwybmFtZSA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKX07YDtcbiAgfVxuXG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdEUk9QIENPTFVNTicsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdLFxuICAgICAgY29uc3RyYWludFN0cmluZyA9IFtdO1xuICAgIGxldCBjb21tZW50U3RyaW5nID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgcXVvdGVkQXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdDT01NRU5UICcpKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IGRlZmluaXRpb24ubWF0Y2goL14oLispIChDT01NRU5ULiopJC8pO1xuICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IGNvbW1lbnRNYXRjaFsyXS5yZXBsYWNlKCdDT01NRU5UJywgJycpLnRyaW0oKTtcbiAgICAgICAgY29tbWVudFN0cmluZyArPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShjb21tZW50VGV4dCwgdGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgLy8gcmVtb3ZlIGNvbW1lbnQgcmVsYXRlZCBzdWJzdHJpbmcgZnJvbSBkYXRhVHlwZVxuICAgICAgICBkZWZpbml0aW9uID0gY29tbWVudE1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICBjb25zdHJhaW50U3RyaW5nLnB1c2goYEZPUkVJR04gS0VZICgke3F1b3RlZEF0dHJOYW1lfSkgJHtkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgJycpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0cmluZy5wdXNoKGAke3F1b3RlZEF0dHJOYW1lfSAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0clN0cmluZy5sZW5ndGggJiYgYEFMVEVSIENPTFVNTiAke2F0dHJTdHJpbmcuam9pbignLCAnKX1gLFxuICAgICAgY29uc3RyYWludFN0cmluZy5sZW5ndGggJiYgYEFERCAke2NvbnN0cmFpbnRTdHJpbmcuam9pbignLCAnKX1gLFxuICAgICAgJzsnLFxuICAgICAgY29tbWVudFN0cmluZ1xuICAgIF0pO1xuICB9XG5cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbmV3TmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdFWEVDIHNwX3JlbmFtZScsXG4gICAgICBgJyR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9LiR7YXR0ckJlZm9yZX0nLGAsXG4gICAgICBgJyR7bmV3TmFtZX0nLGAsXG4gICAgICBcIidDT0xVTU4nXCIsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2hlcywgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gW107XG4gICAgY29uc3QgYWxsUXVlcmllcyA9IFtdO1xuXG4gICAgbGV0IG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSBmYWxzZSxcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gJyc7XG5cbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoYXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGVtcHR5UXVlcnkgPSBgSU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZX0ke291dHB1dEZyYWdtZW50fSBERUZBVUxUIFZBTFVFU2A7XG5cbiAgICBhdHRyVmFsdWVIYXNoZXMuZm9yRWFjaChhdHRyVmFsdWVIYXNoID0+IHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgZW1wdHkgb2JqZWN0cyB3aXRoIHByaW1hcnkga2V5c1xuICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoYXR0clZhbHVlSGFzaCk7XG4gICAgICBjb25zdCBmaXJzdEF0dHIgPSBhdHRyaWJ1dGVzW2ZpZWxkc1swXV07XG4gICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMSAmJiBmaXJzdEF0dHIgJiYgZmlyc3RBdHRyLmF1dG9JbmNyZW1lbnQgJiYgYXR0clZhbHVlSGFzaFtmaWVsZHNbMF1dID09PSBudWxsKSB7XG4gICAgICAgIGFsbFF1ZXJpZXMucHVzaChlbXB0eVF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWwgY2FzZVxuICAgICAgXy5mb3JPd24oYXR0clZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIGF0dHJpYnV0ZXNba2V5XSAmJiBhdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgIG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbGxBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgYXR0cmlidXRlc1trZXldICYmIGF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKGFsbEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXR0clZhbHVlSGFzaGVzLmZvckVhY2goYXR0clZhbHVlSGFzaCA9PiB7XG4gICAgICAgIHR1cGxlcy5wdXNoKGAoJHtcbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLm1hcChrZXkgPT5cbiAgICAgICAgICAgIHRoaXMuZXNjYXBlKGF0dHJWYWx1ZUhhc2hba2V5XSkpLmpvaW4oJywnKVxuICAgICAgICB9KWApO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHF1b3RlZEF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKCcsJyk7XG4gICAgICBhbGxRdWVyaWVzLnB1c2godHVwbGVTdHIgPT4gYElOU0VSVCBJTlRPICR7cXVvdGVkVGFibGV9ICgke3F1b3RlZEF0dHJpYnV0ZXN9KSR7b3V0cHV0RnJhZ21lbnR9IFZBTFVFUyAke3R1cGxlU3RyfTtgKTtcbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBiYXRjaCA9IE1hdGguZmxvb3IoMjUwIC8gKGFsbEF0dHJpYnV0ZXMubGVuZ3RoICsgMSkpICsgMTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgTWF0aC5tYXgodHVwbGVzLmxlbmd0aCwgMSkpIHtcbiAgICAgIGNvbnN0IHR1cGxlU3RyID0gdHVwbGVzLnNsaWNlKG9mZnNldCwgTWF0aC5taW4odHVwbGVzLmxlbmd0aCwgb2Zmc2V0ICsgYmF0Y2gpKTtcbiAgICAgIGxldCBnZW5lcmF0ZWRRdWVyeSA9IGFsbFF1ZXJpZXMubWFwKHYgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdiA6IHYodHVwbGVTdHIpKS5qb2luKCc7Jyk7XG4gICAgICBpZiAobmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlcikge1xuICAgICAgICBnZW5lcmF0ZWRRdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9OOyAke2dlbmVyYXRlZFF1ZXJ5fTsgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPRkY7YDtcbiAgICAgIH1cbiAgICAgIGNvbW1hbmRzLnB1c2goZ2VuZXJhdGVkUXVlcnkpO1xuICAgICAgb2Zmc2V0ICs9IGJhdGNoO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuam9pbignOycpO1xuICB9XG5cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHNxbCA9IHN1cGVyLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBjb25zdCB1cGRhdGVBcmdzID0gYFVQREFURSBUT1AoJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICAgIHNxbC5xdWVyeSA9IHNxbC5xdWVyeS5yZXBsYWNlKCdVUERBVEUnLCB1cGRhdGVBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIHVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCkge1xuICAgIGNvbnN0IHRhcmdldFRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV90YXJnZXRgKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fc291cmNlYCk7XG4gICAgY29uc3QgcHJpbWFyeUtleXNBdHRycyA9IFtdO1xuICAgIGNvbnN0IGlkZW50aXR5QXR0cnMgPSBbXTtcbiAgICBjb25zdCB1bmlxdWVBdHRycyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlTmFtZVF1b3RlZCA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gZmFsc2U7XG5cbiAgICAvL09idGFpbiBwcmltYXJ5S2V5cywgdW5pcXVla2V5cyBhbmQgaWRlbnRpdHkgYXR0cnMgZnJvbSByYXdBdHRyaWJ1dGVzIGFzIG1vZGVsIGlzIG5vdCBwYXNzZWRcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnByaW1hcnlLZXkpIHtcbiAgICAgICAgcHJpbWFyeUtleXNBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS51bmlxdWUpIHtcbiAgICAgICAgdW5pcXVlQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCkge1xuICAgICAgICBpZGVudGl0eUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9BZGQgdW5pcXVlIGluZGV4ZXMgZGVmaW5lZCBieSBpbmRleGVzIG9wdGlvbiB0byB1bmlxdWVBdHRyc1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgbW9kZWwuX2luZGV4ZXMpIHtcbiAgICAgIGlmIChpbmRleC51bmlxdWUgJiYgaW5kZXguZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyA/IGZpZWxkIDogZmllbGQubmFtZSB8fCBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICAgICAgaWYgKCF1bmlxdWVBdHRycy5pbmNsdWRlcyhmaWVsZE5hbWUpICYmIG1vZGVsLnJhd0F0dHJpYnV0ZXNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgdW5pcXVlQXR0cnMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXNRdW90ZWQgPSBpbnNlcnRLZXlzLm1hcChrZXkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSkuam9pbignLCAnKTtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZXNFc2NhcGVkID0gaW5zZXJ0S2V5cy5tYXAoa2V5ID0+IHRoaXMuZXNjYXBlKGluc2VydFZhbHVlc1trZXldKSkuam9pbignLCAnKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZVF1ZXJ5ID0gYFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7IC8vVmlydHVhbCBUYWJsZVxuICAgIGxldCBqb2luQ29uZGl0aW9uO1xuXG4gICAgLy9JREVOVElUWV9JTlNFUlQgQ29uZGl0aW9uXG4gICAgaWRlbnRpdHlBdHRycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodXBkYXRlVmFsdWVzW2tleV0gJiYgdXBkYXRlVmFsdWVzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IHRydWU7XG4gICAgICAgIC8qXG4gICAgICAgICAqIElERU5USVRZX0lOU0VSVCBDb2x1bW4gQ2Fubm90IGJlIHVwZGF0ZWQsIG9ubHkgaW5zZXJ0ZWRcbiAgICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzAxNzYyNTQvMjI1NDM2MFxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vRmlsdGVyIE5VTEwgQ2xhdXNlc1xuICAgIGNvbnN0IGNsYXVzZXMgPSB3aGVyZVtPcC5vcl0uZmlsdGVyKGNsYXVzZSA9PiB7XG4gICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgLypcbiAgICAgICAqIEV4Y2x1ZGUgTlVMTCBDb21wb3NpdGUgUEsvVUsuIFBhcnRpYWwgQ29tcG9zaXRlIGNsYXVzZXMgc2hvdWxkIGFsc28gYmUgZXhjbHVkZWQgYXMgaXQgZG9lc24ndCBndWFyYW50ZWUgYSBzaW5nbGUgcm93XG4gICAgICAgKi9cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXVzZVtrZXldID09PSAndW5kZWZpbmVkJyB8fCBjbGF1c2Vba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBHZW5lcmF0ZSBPTiBjb25kaXRpb24gdXNpbmcgUEsocykuXG4gICAgICogSWYgbm90LCBnZW5lcmF0ZSB1c2luZyBVSyhzKS4gRWxzZSB0aHJvdyBlcnJvclxuICAgICAqL1xuICAgIGNvbnN0IGdldEpvaW5TbmlwcGV0ID0gYXJyYXkgPT4ge1xuICAgICAgcmV0dXJuIGFycmF5Lm1hcChrZXkgPT4ge1xuICAgICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHtzb3VyY2VUYWJsZUFsaWFzfS4ke2tleX1gO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjbGF1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmltYXJ5IEtleSBvciBVbmlxdWUga2V5IHNob3VsZCBiZSBwYXNzZWQgdG8gdXBzZXJ0IHF1ZXJ5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgcHJpbWFyeSBrZXkgYXR0cmlidXRlIGluIGNsYXVzZXMgLS0gTW9kZWwgY2FuIGhhdmUgdHdvIHNlcGFyYXRlIHVuaXF1ZSBrZXlzXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2VzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjbGF1c2VzW2tleV0pO1xuICAgICAgICBpZiAocHJpbWFyeUtleXNBdHRycy5pbmNsdWRlcyhrZXlzWzBdKSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldChwcmltYXJ5S2V5c0F0dHJzKS5qb2luKCcgQU5EICcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWpvaW5Db25kaXRpb24pIHtcbiAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHVuaXF1ZUF0dHJzKS5qb2luKCcgQU5EICcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgSURFTlRJVFlfSU5TRVJUIENvbHVtbiBmcm9tIHVwZGF0ZVxuICAgIGNvbnN0IHVwZGF0ZVNuaXBwZXQgPSB1cGRhdGVLZXlzLmZpbHRlcihrZXkgPT4gIWlkZW50aXR5QXR0cnMuaW5jbHVkZXMoa2V5KSlcbiAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmVzY2FwZSh1cGRhdGVWYWx1ZXNba2V5XSk7XG4gICAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3ZhbHVlfWA7XG4gICAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgY29uc3QgaW5zZXJ0U25pcHBldCA9IGAoJHtpbnNlcnRLZXlzUXVvdGVkfSkgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDtcbiAgICBsZXQgcXVlcnkgPSBgTUVSR0UgSU5UTyAke3RhYmxlTmFtZVF1b3RlZH0gV0lUSChIT0xETE9DSykgQVMgJHt0YXJnZXRUYWJsZUFsaWFzfSBVU0lORyAoJHtzb3VyY2VUYWJsZVF1ZXJ5fSkgQVMgJHtzb3VyY2VUYWJsZUFsaWFzfSgke2luc2VydEtleXNRdW90ZWR9KSBPTiAke2pvaW5Db25kaXRpb259YDtcbiAgICBxdWVyeSArPSBgIFdIRU4gTUFUQ0hFRCBUSEVOIFVQREFURSBTRVQgJHt1cGRhdGVTbmlwcGV0fSBXSEVOIE5PVCBNQVRDSEVEIFRIRU4gSU5TRVJUICR7aW5zZXJ0U25pcHBldH0gT1VUUFVUICRhY3Rpb24sIElOU0VSVEVELio7YDtcbiAgICBpZiAobmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlcikge1xuICAgICAgcXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3RhYmxlTmFtZVF1b3RlZH0gT047ICR7cXVlcnl9IFNFVCBJREVOVElUWV9JTlNFUlQgJHt0YWJsZU5hbWVRdW90ZWR9IE9GRjtgO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cblxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnREVMRVRFJyxcbiAgICAgIG9wdGlvbnMubGltaXQgJiYgYFRPUCgke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgLFxuICAgICAgJ0ZST00nLFxuICAgICAgdGFibGUsXG4gICAgICB3aGVyZUNsYXVzZSAmJiBgV0hFUkUgJHt3aGVyZUNsYXVzZX1gLFxuICAgICAgJzsnLFxuICAgICAgJ1NFTEVDVCBAQFJPV0NPVU5UIEFTIEFGRkVDVEVEUk9XUycsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBFWEVDIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWUgPSBOJyR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JztgO1xuICB9XG5cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBFWEVDIHNwX2hlbHBjb25zdHJhaW50IEBvYmpuYW1lID0gJHt0aGlzLmVzY2FwZSh0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSl9O2A7XG4gIH1cblxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcblxuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oJ18nKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYERST1AgSU5ERVggJHt0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKX0gT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKX1gO1xuICB9XG5cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHNlbGYgcmVmZXJlbnRpYWwgY29uc3RyYWludHNcbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5Nb2RlbCAmJiBhdHRyaWJ1dGUuTW9kZWwudGFibGVOYW1lID09PSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgc2VsZiByZWZlcmVuY2lhbCBjb25zdHJhaW50cywgJ1xuICAgICAgICAgICsgJ3dlIHdpbGwgcmVtb3ZlIGl0IGJ1dCB3ZSByZWNvbW1lbmQgcmVzdHJ1Y3R1cmluZyB5b3VyIHF1ZXJ5Jyk7XG4gICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9ICcnO1xuICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdGVtcGxhdGU7XG5cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcykgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcblxuICAgICAgLy8gZW51bXMgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3FsKCk7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5maWVsZCl9IElOKCR7YXR0cmlidXRlLnZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgICAgfSkuam9pbignLCAnKSB9KSlgO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgTk9UIE5VTEwnO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZS5wcmltYXJ5S2V5ICYmICFVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgTlVMTCc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIElERU5USVRZKDEsMSknO1xuICAgIH1cblxuICAgIC8vIEJsb2JzL3RleHRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdFZhbHVlXG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlICE9PSAnVEVYVCcgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJlxuICAgICAgICBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgVU5JUVVFJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgUFJJTUFSWSBLRVknO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoJ2lkJyl9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQgJiYgdHlwZW9mIGF0dHJpYnV0ZS5jb21tZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7YXR0cmlidXRlLmNvbW1lbnR9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9LFxuICAgICAgZXhpc3RpbmdDb25zdHJhaW50cyA9IFtdO1xuICAgIGxldCBrZXksXG4gICAgICBhdHRyaWJ1dGU7XG5cbiAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoZXhpc3RpbmdDb25zdHJhaW50cy5pbmNsdWRlcyhhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKSkge1xuICAgICAgICAgIC8vIG5vIGNhc2NhZGluZyBjb25zdHJhaW50cyB0byBhIHRhYmxlIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gJyc7XG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmdDb25zdHJhaW50cy5wdXNoKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgLy8gTk9URTogdGhpcyByZWFsbHkganVzdCBkaXNhYmxlcyBjYXNjYWRpbmcgdXBkYXRlcyBmb3IgYWxsXG4gICAgICAgICAgLy8gICAgICAgZGVmaW5pdGlvbnMuIENhbiBiZSBtYWRlIG1vcmUgcm9idXN0IHRvIHN1cHBvcnQgdGhlXG4gICAgICAgICAgLy8gICAgICAgZmV3IGNhc2VzIHdoZXJlIE1TU1FMIGFjdHVhbGx5IHN1cHBvcnRzIHRoZW1cbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgJiYgIWF0dHJpYnV0ZS5maWVsZCkgYXR0cmlidXRlLmZpZWxkID0ga2V5O1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjcmVhdGVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdjcmVhdGVUcmlnZ2VyJyk7XG4gIH1cblxuICBkcm9wVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgnZHJvcFRyaWdnZXInKTtcbiAgfVxuXG4gIHJlbmFtZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ3JlbmFtZVRyaWdnZXInKTtcbiAgfVxuXG4gIGNyZWF0ZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdjcmVhdGVGdW5jdGlvbicpO1xuICB9XG5cbiAgZHJvcEZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdkcm9wRnVuY3Rpb24nKTtcbiAgfVxuXG4gIHJlbmFtZUZ1bmN0aW9uKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdyZW5hbWVGdW5jdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGNvbW1vbiBTUUwgcHJlZml4IGZvciBGb3JlaWduS2V5c1F1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0YWxvZ05hbWVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIF9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KGNhdGFsb2dOYW1lKSB7XG4gICAgcmV0dXJuIGAkeydTRUxFQ1QgJyArXG4gICAgICAgICdjb25zdHJhaW50X25hbWUgPSBPQkouTkFNRSwgJyArXG4gICAgICAgICdjb25zdHJhaW50TmFtZSA9IE9CSi5OQU1FLCAnfSR7XG4gICAgICBjYXRhbG9nTmFtZSA/IGBjb25zdHJhaW50Q2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiAnJ1xuICAgIH1jb25zdHJhaW50U2NoZW1hID0gU0NIRU1BX05BTUUoT0JKLlNDSEVNQV9JRCksIGAgK1xuICAgICAgICAndGFibGVOYW1lID0gVEIuTkFNRSwgJyArXG4gICAgICAgIGB0YWJsZVNjaGVtYSA9IFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCksICR7XG4gICAgICAgICAgY2F0YWxvZ05hbWUgPyBgdGFibGVDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6ICcnXG4gICAgICAgIH1jb2x1bW5OYW1lID0gQ09MLk5BTUUsIGAgK1xuICAgICAgICBgcmVmZXJlbmNlZFRhYmxlU2NoZW1hID0gU0NIRU1BX05BTUUoUlRCLlNDSEVNQV9JRCksICR7XG4gICAgICAgICAgY2F0YWxvZ05hbWUgPyBgcmVmZXJlbmNlZENhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogJydcbiAgICAgICAgfXJlZmVyZW5jZWRUYWJsZU5hbWUgPSBSVEIuTkFNRSwgYCArXG4gICAgICAgICdyZWZlcmVuY2VkQ29sdW1uTmFtZSA9IFJDT0wuTkFNRSAnICtcbiAgICAgICdGUk9NIHN5cy5mb3JlaWduX2tleV9jb2x1bW5zIEZLQyAnICtcbiAgICAgICAgJ0lOTkVSIEpPSU4gc3lzLm9iamVjdHMgT0JKIE9OIE9CSi5PQkpFQ1RfSUQgPSBGS0MuQ09OU1RSQUlOVF9PQkpFQ1RfSUQgJyArXG4gICAgICAgICdJTk5FUiBKT0lOIHN5cy50YWJsZXMgVEIgT04gVEIuT0JKRUNUX0lEID0gRktDLlBBUkVOVF9PQkpFQ1RfSUQgJyArXG4gICAgICAgICdJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIENPTCBPTiBDT0wuQ09MVU1OX0lEID0gUEFSRU5UX0NPTFVNTl9JRCBBTkQgQ09MLk9CSkVDVF9JRCA9IFRCLk9CSkVDVF9JRCAnICtcbiAgICAgICAgJ0lOTkVSIEpPSU4gc3lzLnRhYmxlcyBSVEIgT04gUlRCLk9CSkVDVF9JRCA9IEZLQy5SRUZFUkVOQ0VEX09CSkVDVF9JRCAnICtcbiAgICAgICAgJ0lOTkVSIEpPSU4gc3lzLmNvbHVtbnMgUkNPTCBPTiBSQ09MLkNPTFVNTl9JRCA9IFJFRkVSRU5DRURfQ09MVU1OX0lEIEFORCBSQ09MLk9CSkVDVF9JRCA9IFJUQi5PQkpFQ1RfSUQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIGFsbCBmb3JlaWduIGtleXMgZGV0YWlscyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRhbG9nTmFtZSBkYXRhYmFzZSBuYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBjYXRhbG9nTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBsZXQgc3FsID0gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeChjYXRhbG9nTmFtZSlcbiAgICB9IFdIRVJFIFRCLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YDtcblxuICAgIGlmICh0YWJsZS5zY2hlbWEpIHtcbiAgICAgIHNxbCArPSBgIEFORCBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpfWA7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgdGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeCgpLFxuICAgICAgJ1dIRVJFJyxcbiAgICAgIGBUQi5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWAsXG4gICAgICAnQU5EJyxcbiAgICAgIGBDT0wuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUoYXR0cmlidXRlTmFtZSl9YCxcbiAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCkgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSl9YFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QgSy5UQUJMRV9OQU1FIEFTIHRhYmxlTmFtZSwnLFxuICAgICAgJ0suQ09MVU1OX05BTUUgQVMgY29sdW1uTmFtZSwnLFxuICAgICAgJ0suQ09OU1RSQUlOVF9OQU1FIEFTIGNvbnN0cmFpbnROYW1lJyxcbiAgICAgICdGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UUyBBUyBDJyxcbiAgICAgICdKT0lOIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIEFTIEsnLFxuICAgICAgJ09OIEMuVEFCTEVfTkFNRSA9IEsuVEFCTEVfTkFNRScsXG4gICAgICAnQU5EIEMuQ09OU1RSQUlOVF9DQVRBTE9HID0gSy5DT05TVFJBSU5UX0NBVEFMT0cnLFxuICAgICAgJ0FORCBDLkNPTlNUUkFJTlRfU0NIRU1BID0gSy5DT05TVFJBSU5UX1NDSEVNQScsXG4gICAgICAnQU5EIEMuQ09OU1RSQUlOVF9OQU1FID0gSy5DT05TVFJBSU5UX05BTUUnLFxuICAgICAgJ1dIRVJFIEMuQ09OU1RSQUlOVF9UWVBFID0gXFwnUFJJTUFSWSBLRVlcXCcnLFxuICAgICAgYEFORCBLLkNPTFVNTl9OQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUoYXR0cmlidXRlTmFtZSl9YCxcbiAgICAgIGBBTkQgSy5UQUJMRV9OQU1FID0gJHt0YWJsZU5hbWV9YCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnRFJPUCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0RGVmYXVsdENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QgbmFtZSBGUk9NIHN5cy5kZWZhdWx0X2NvbnN0cmFpbnRzJyxcbiAgICAgIGBXSEVSRSBQQVJFTlRfT0JKRUNUX0lEID0gT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlfScsICdVJylgLFxuICAgICAgYEFORCBQQVJFTlRfQ09MVU1OX0lEID0gKFNFTEVDVCBjb2x1bW5faWQgRlJPTSBzeXMuY29sdW1ucyBXSEVSRSBOQU1FID0gKCcke2F0dHJpYnV0ZU5hbWV9JylgLFxuICAgICAgYEFORCBvYmplY3RfaWQgPSBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGV9JywgJ1UnKSlgLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBkcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnRFJPUCBDT05TVFJBSU5UJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnROYW1lKSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSgpIHtcblxuICB9XG5cbiAgZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygxMCkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuICdCRUdJTiBUUkFOU0FDVElPTjsnO1xuICB9XG5cbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0NPTU1JVCBUUkFOU0FDVElPTjsnO1xuICB9XG5cbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cblxuICAgIHJldHVybiAnUk9MTEJBQ0sgVFJBTlNBQ1RJT047JztcbiAgfVxuXG4gIHNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLCB0YWJsZXMsIG1haW5UYWJsZUFzLCB3aGVyZSkge1xuICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGVBcyB9KTtcblxuICAgIGNvbnN0IGRiVmVyc2lvbiA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uO1xuICAgIGNvbnN0IGlzU1FMU2VydmVyMjAwOCA9IHNlbXZlci52YWxpZChkYlZlcnNpb24pICYmIHNlbXZlci5sdChkYlZlcnNpb24sICcxMS4wLjAnKTtcblxuICAgIGlmIChpc1NRTFNlcnZlcjIwMDggJiYgb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgIC8vIEZvciBlYXJsaWVyIHZlcnNpb25zIG9mIFNRTCBzZXJ2ZXIsIHdlIG5lZWQgdG8gbmVzdCBzZXZlcmFsIHF1ZXJpZXNcbiAgICAgIC8vIGluIG9yZGVyIHRvIGVtdWxhdGUgdGhlIE9GRlNFVCBiZWhhdmlvci5cbiAgICAgIC8vXG4gICAgICAvLyAxLiBUaGUgb3V0ZXJtb3N0IHF1ZXJ5IHNlbGVjdHMgYWxsIGl0ZW1zIGZyb20gdGhlIGlubmVyIHF1ZXJ5IGJsb2NrLlxuICAgICAgLy8gICAgVGhpcyBpcyBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIFNRTCBzZXJ2ZXIgd2l0aCB0aGUgdXNlIG9mIGNvbXB1dGVkXG4gICAgICAvLyAgICBjb2x1bW5zIChlLmcuIFNFTEVDVCBST1dfTlVNQkVSKCkuLi5BUyB4KSBpbiBXSEVSRSBjbGF1c2VzLlxuICAgICAgLy8gMi4gVGhlIG5leHQgcXVlcnkgaGFuZGxlcyB0aGUgTElNSVQgYW5kIE9GRlNFVCBiZWhhdmlvciBieSBnZXR0aW5nXG4gICAgICAvLyAgICB0aGUgVE9QIE4gcm93cyBvZiB0aGUgcXVlcnkgd2hlcmUgdGhlIHJvdyBudW1iZXIgaXMgPiBPRkZTRVRcbiAgICAgIC8vIDMuIFRoZSBpbm5lcm1vc3QgcXVlcnkgaXMgdGhlIGFjdHVhbCBzZXQgd2Ugd2FudCBpbmZvcm1hdGlvbiBmcm9tXG5cbiAgICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBpc1N1YlF1ZXJ5ID0gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uO1xuICAgICAgbGV0IG9yZGVycyA9IHsgbWFpblF1ZXJ5T3JkZXI6IFtdIH07XG4gICAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgICBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBpc1N1YlF1ZXJ5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb3JkZXJzLm1haW5RdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwucHJpbWFyeUtleUZpZWxkKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRtcFRhYmxlID0gbWFpblRhYmxlQXMgfHwgJ09mZnNldFRhYmxlJztcblxuICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICAnU0VMRUNUIFRPUCAxMDAgUEVSQ0VOVCcsXG4gICAgICAgIGF0dHJpYnV0ZXMuam9pbignLCAnKSxcbiAgICAgICAgJ0ZST00gKCcsXG4gICAgICAgIFtcbiAgICAgICAgICAnU0VMRUNUJyxcbiAgICAgICAgICBvcHRpb25zLmxpbWl0ICYmIGBUT1AgJHtvcHRpb25zLmxpbWl0fWAsXG4gICAgICAgICAgJyogRlJPTSAoJyxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnU0VMRUNUIFJPV19OVU1CRVIoKSBPVkVSICgnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnT1JERVIgQlknLFxuICAgICAgICAgICAgICBvcmRlcnMubWFpblF1ZXJ5T3JkZXIuam9pbignLCAnKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGApIGFzIHJvd19udW0sICogRlJPTSAke3RhYmxlc30gQVMgJHt0bXBUYWJsZX1gLFxuICAgICAgICAgICAgd2hlcmUgJiYgYFdIRVJFICR7d2hlcmV9YFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX0gV0hFUkUgcm93X251bSA+ICR7b2Zmc2V0fWBcbiAgICAgICAgXSxcbiAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX1gXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUJyxcbiAgICAgIGlzU1FMU2VydmVyMjAwOCAmJiBvcHRpb25zLmxpbWl0ICYmIGBUT1AgJHtvcHRpb25zLmxpbWl0fWAsXG4gICAgICBhdHRyaWJ1dGVzLmpvaW4oJywgJyksXG4gICAgICBgRlJPTSAke3RhYmxlc31gLFxuICAgICAgbWFpblRhYmxlQXMgJiYgYEFTICR7bWFpblRhYmxlQXN9YCxcbiAgICAgIG9wdGlvbnMudGFibGVIaW50ICYmIFRhYmxlSGludHNbb3B0aW9ucy50YWJsZUhpbnRdICYmIGBXSVRIICgke1RhYmxlSGludHNbb3B0aW9ucy50YWJsZUhpbnRdfSlgXG4gICAgXSk7XG4gIH1cblxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zLCBtb2RlbCkge1xuICAgIC8vIFNraXAgaGFuZGxpbmcgb2YgbGltaXQgYW5kIG9mZnNldCBhcyBwb3N0Zml4ZXMgZm9yIG9sZGVyIFNRTCBTZXJ2ZXIgdmVyc2lvbnNcbiAgICBpZiAoc2VtdmVyLnZhbGlkKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uKSAmJiBzZW12ZXIubHQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sICcxMS4wLjAnKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgaXNTdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb25cbiAgICAgIDogb3B0aW9ucy5zdWJRdWVyeTtcblxuICAgIGxldCBmcmFnbWVudCA9ICcnO1xuICAgIGxldCBvcmRlcnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBpc1N1YlF1ZXJ5KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCB8fCBvcHRpb25zLm9mZnNldCkge1xuICAgICAgaWYgKCFvcHRpb25zLm9yZGVyIHx8ICFvcHRpb25zLm9yZGVyLmxlbmd0aCB8fCBvcHRpb25zLmluY2x1ZGUgJiYgIW9yZGVycy5zdWJRdWVyeU9yZGVyLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0YWJsZVBrRnJhZ21lbnQgPSBgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy50YWJsZUFzIHx8IG1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLnByaW1hcnlLZXlGaWVsZCl9YDtcbiAgICAgICAgaWYgKCFvcHRpb25zLm9yZGVyIHx8ICFvcHRpb25zLm9yZGVyLmxlbmd0aCkge1xuICAgICAgICAgIGZyYWdtZW50ICs9IGAgT1JERVIgQlkgJHt0YWJsZVBrRnJhZ21lbnR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcmRlckZpZWxkTmFtZXMgPSBfLm1hcChvcHRpb25zLm9yZGVyLCBvcmRlciA9PiBvcmRlclswXSk7XG4gICAgICAgICAgY29uc3QgcHJpbWFyeUtleUZpZWxkQWxyZWFkeVByZXNlbnQgPSBfLmluY2x1ZGVzKG9yZGVyRmllbGROYW1lcywgbW9kZWwucHJpbWFyeUtleUZpZWxkKTtcblxuICAgICAgICAgIGlmICghcHJpbWFyeUtleUZpZWxkQWxyZWFkeVByZXNlbnQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ICs9IG9wdGlvbnMub3JkZXIgJiYgIWlzU3ViUXVlcnkgPyAnLCAnIDogJyBPUkRFUiBCWSAnO1xuICAgICAgICAgICAgZnJhZ21lbnQgKz0gdGFibGVQa0ZyYWdtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9mZnNldCl9IFJPV1NgO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxufVxuXG4vLyBwcml2YXRlIG1ldGhvZHNcbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCBcIidcIiksIFwiJ1wiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNU1NRTFF1ZXJ5R2VuZXJhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvcnMnKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZScpO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgdGhhdCBTZXF1ZWxpemUgdXNlcyB0byB0YWxrIHdpdGggTVNTUUwgZGF0YWJhc2VcbiAqL1xuY2xhc3MgTVNTcWxRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgLyoqXG4gICogQSB3cmFwcGVyIHRoYXQgZml4ZXMgTVNTUUwncyBpbmFiaWxpdHkgdG8gY2xlYW5seSByZW1vdmUgY29sdW1ucyBmcm9tIGV4aXN0aW5nIHRhYmxlcyBpZiB0aGV5IGhhdmUgYSBkZWZhdWx0IGNvbnN0cmFpbnQuXG4gICpcbiAgKiBAb3ZlcnJpZGVcbiAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB8fCB7fSB9O1xuXG4gICAgY29uc3QgZmluZENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldERlZmF1bHRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0czBdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZmluZENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHRzMC5sZW5ndGgpIHtcbiAgICAgIC8vIE5vIGRlZmF1bHQgY29uc3RyYWludCBmb3VuZCAtLSB3ZSBjYW4gY2xlYW5seSByZW1vdmUgdGhlIGNvbHVtblxuICAgICAgY29uc3QgZHJvcENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCByZXN1bHRzMFswXS5uYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZmluZEZvcmVpZ25LZXlTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGZpbmRGb3JlaWduS2V5U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIC8vIE5vIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIGZvdW5kLCBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBjb2x1bW5cbiAgICAgIGNvbnN0IGRyb3BGb3JlaWduS2V5U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0c1swXS5jb25zdHJhaW50X25hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcEZvcmVpZ25LZXlTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvL0NoZWNrIGlmIHRoZSBjdXJyZW50IGNvbHVtbiBpcyBhIHByaW1hcnlLZXlcbiAgICBjb25zdCBwcmltYXJ5S2V5Q29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocHJpbWFyeUtleUNvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkcm9wQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdFswXS5jb25zdHJhaW50TmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkocmVtb3ZlU3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCB3aGVyZXMgPSBbXTtcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGlmICghVXRpbHMuaXNXaGVyZUVtcHR5KHdoZXJlKSkge1xuICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgIH1cblxuICAgIC8vIExldHMgY29tYmluZSB1bmlxdWUga2V5cyBhbmQgaW5kZXhlcyBpbnRvIG9uZVxuICAgIGxldCBpbmRleGVzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5tYXAoaXRlbSA9PiBpdGVtLmZpZWxkcyk7XG4gICAgaW5kZXhlcyA9IGluZGV4ZXMuY29uY2F0KE9iamVjdC52YWx1ZXMobW9kZWwuX2luZGV4ZXMpLmZpbHRlcihpdGVtID0+IGl0ZW0udW5pcXVlKS5tYXAoaXRlbSA9PiBpdGVtLmZpZWxkcykpO1xuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICBpZiAoXy5pbnRlcnNlY3Rpb24oYXR0cmlidXRlcywgaW5kZXgpLmxlbmd0aCA9PT0gaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgIHdoZXJlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXgpIHtcbiAgICAgICAgICB3aGVyZVtmaWVsZF0gPSBpbnNlcnRWYWx1ZXNbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGVyZSA9IHsgW09wLm9yXTogd2hlcmVzIH07XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0cy5NU1NxbFF1ZXJ5SW50ZXJmYWNlID0gTVNTcWxRdWVyeUludGVyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5Jyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnbXNzcWwnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcblxuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdzcWw6bXNzcWwnKTtcblxuZnVuY3Rpb24gZ2V0U2NhbGUoYU51bSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhTnVtKSkgcmV0dXJuIDA7XG4gIGxldCBlID0gMTtcbiAgd2hpbGUgKE1hdGgucm91bmQoYU51bSAqIGUpIC8gZSAhPT0gYU51bSkgZSAqPSAxMDtcbiAgcmV0dXJuIE1hdGgubG9nMTAoZSk7XG59XG5cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuICdpZCc7XG4gIH1cblxuICBnZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSwgVFlQRVMpIHtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSB7IHR5cGU6IFRZUEVTLlZhckNoYXIsIHR5cGVPcHRpb25zOiB7fSB9O1xuICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuTlZhckNoYXI7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgPj0gLTIxNDc0ODM2NDggJiYgdmFsdWUgPD0gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuSW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuQmlnSW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLk51bWVyaWM7XG4gICAgICAgIC8vRGVmYXVsdCB0byBhIHJlYXNvbmFibGUgbnVtZXJpYyBwcmVjaXNpb24vc2NhbGUgcGVuZGluZyBtb3JlIHNvcGhpc3RpY2F0ZWQgbG9naWNcbiAgICAgICAgcGFyYW1UeXBlLnR5cGVPcHRpb25zID0geyBwcmVjaXNpb246IDMwLCBzY2FsZTogZ2V0U2NhbGUodmFsdWUpIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5CaXQ7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLlZhckJpbmFyeTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtVHlwZTtcbiAgfVxuXG4gIGFzeW5jIF9ydW4oY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gVFJBTlNBQ1RJT04gU1VQUE9SVFxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKCdCRUdJTiBUUkFOU0FDVElPTicpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmJlZ2luVHJhbnNhY3Rpb24oZXJyb3IgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSwgY29ubmVjdGlvbi5saWIuSVNPTEFUSU9OX0xFVkVMW29wdGlvbnMuaXNvbGF0aW9uTGV2ZWxdKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aCgnQ09NTUlUIFRSQU5TQUNUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29tbWl0VHJhbnNhY3Rpb24oZXJyb3IgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSkpO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKCdST0xMQkFDSyBUUkFOU0FDVElPTicpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnJvbGxiYWNrVHJhbnNhY3Rpb24oZXJyb3IgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoJ1NBVkUgVFJBTlNBQ1RJT04nKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zYXZlVHJhbnNhY3Rpb24oZXJyb3IgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgY29ubmVjdGlvbi5saWIuUmVxdWVzdChzcWwsIChlcnIsIHJvd0NvdW50KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoW3Jvd3MsIHJvd0NvdW50XSkpO1xuXG4gICAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgICBfLmZvck93bihwYXJhbWV0ZXJzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRoaXMuZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUsIGNvbm5lY3Rpb24ubGliLlRZUEVTKTtcbiAgICAgICAgICByZXF1ZXN0LmFkZFBhcmFtZXRlcihrZXksIHBhcmFtVHlwZS50eXBlLCB2YWx1ZSwgcGFyYW1UeXBlLnR5cGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Qub24oJ3JvdycsIGNvbHVtbnMgPT4ge1xuICAgICAgICByb3dzLnB1c2goY29sdW1ucyk7XG4gICAgICB9KTtcblxuICAgICAgY29ubmVjdGlvbi5leGVjU3FsKHJlcXVlc3QpO1xuICAgIH0pO1xuXG4gICAgbGV0IHJvd3MsIHJvd0NvdW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIFtyb3dzLCByb3dDb3VudF0gPSBhd2FpdCBxdWVyeTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5zcWwgPSBzcWw7XG4gICAgICBlcnIucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG5cbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBjb21wbGV0ZSgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm93cykpIHtcbiAgICAgIHJvd3MgPSByb3dzLm1hcChjb2x1bW5zID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICBjb25zdCB0eXBlaWQgPSBjb2x1bW4ubWV0YWRhdGEudHlwZS5pZDtcbiAgICAgICAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldCh0eXBlaWQpO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbHVtbi52YWx1ZTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmICEhcGFyc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2UodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb3dbY29sdW1uLm1ldGFkYXRhLmNvbE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocm93cywgcm93Q291bnQpO1xuICB9XG5cbiAgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ucXVldWUuZW5xdWV1ZSgoKSA9PiB0aGlzLl9ydW4odGhpcy5jb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMpKTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IHt9O1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJpbmRQYXJhbVtrZXldID0gdmFsdWVzW2tleV07XG4gICAgICAgIHJldHVybiBgQCR7a2V5fWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcblxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gVGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgZXhlY3V0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93Q291bnRcbiAgICogQHByaXZhdGVcbiAgICogQGV4YW1wbGVcbiAgICogRXhhbXBsZTpcbiAgICogIHF1ZXJ5LmZvcm1hdFJlc3VsdHMoW1xuICAgKiAgICB7XG4gICAqICAgICAgaWQ6IDEsICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBhdHRyMjogJ3NuYWZ1JywgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIFRhc2tzLmlkOiAxLCAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgICAgVGFza3MudGl0bGU6ICd0YXNrJyAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgfVxuICAgKiAgXSlcbiAgICovXG4gIGZvcm1hdFJlc3VsdHMoZGF0YSwgcm93Q291bnQpIHtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICBpZiAoX3Jlc3VsdC5EZWZhdWx0KSB7XG4gICAgICAgICAgX3Jlc3VsdC5EZWZhdWx0ID0gX3Jlc3VsdC5EZWZhdWx0LnJlcGxhY2UoXCIoJ1wiLCAnJykucmVwbGFjZShcIicpXCIsICcnKS5yZXBsYWNlKC8nL2csICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5Jc051bGwgPT09ICdZRVMnID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuQ29uc3RyYWludCA9PT0gJ1BSSU1BUlkgS0VZJyxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBfcmVzdWx0LklzSWRlbnRpdHkgPT09IDEsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUuaW5jbHVkZXMoJ0NIQVInKVxuICAgICAgICAgICYmIF9yZXN1bHQuTGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfcmVzdWx0Lkxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUgKz0gJyhNQVgpJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZSArPSBgKCR7X3Jlc3VsdC5MZW5ndGh9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm93Q291bnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdID8gZGF0YVswXS5BRkZFQ1RFRFJPV1MgOiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCBkYXRhWzBdLiRhY3Rpb24gPT09ICdJTlNFUlQnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKHJlc3VsdFNldCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKSB7XG4gICAgLy9Db252ZXJ0IHNuYWtlX2Nhc2Uga2V5cyB0byBjYW1lbENhc2UgYXMgaXQncyBnZW5lcmF0ZWQgYnkgc3RvcmVkIHByb2NlZHVyZVxuICAgIHJldHVybiBkYXRhLnNsaWNlKDEpLm1hcChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0cmFpbnRbXy5jYW1lbENhc2Uoa2V5KV0gPSByZXN1bHRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgIH0pO1xuICB9XG5cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgbGV0IG1hdGNoO1xuXG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvVmlvbGF0aW9uIG9mICg/OlVOSVFVRXxQUklNQVJZKSBLRVkgY29uc3RyYWludCAnKFteJ10qKScuIENhbm5vdCBpbnNlcnQgZHVwbGljYXRlIGtleSBpbiBvYmplY3QgJy4qJy4oOj8gVGhlIGR1cGxpY2F0ZSBrZXkgdmFsdWUgaXMgXFwoKC4qKVxcKS4pPy8pO1xuICAgIG1hdGNoID0gbWF0Y2ggfHwgZXJyLm1lc3NhZ2UubWF0Y2goL0Nhbm5vdCBpbnNlcnQgZHVwbGljYXRlIGtleSByb3cgaW4gb2JqZWN0IC4qIHdpdGggdW5pcXVlIGluZGV4ICcoLiopJy8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1ttYXRjaFsxXV07XG4gICAgICBsZXQgbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGVycm9yJztcblxuICAgICAgaWYgKHVuaXF1ZUtleSAmJiAhIXVuaXF1ZUtleS5tc2cpIHtcbiAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2hbM10uc3BsaXQoJywnKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1ttYXRjaFsxXV0gPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgdGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSxcbiAgICAgICAgICAndW5pcXVlIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuREIsXG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAnbm90X3VuaXF1ZSdcbiAgICAgICAgKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgIH1cblxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0ZhaWxlZCBvbiBzdGVwICcoLiopJy5Db3VsZCBub3QgY3JlYXRlIGNvbnN0cmFpbnQuIFNlZSBwcmV2aW91cyBlcnJvcnMuLykgfHxcbiAgICAgIGVyci5tZXNzYWdlLm1hdGNoKC9UaGUgREVMRVRFIHN0YXRlbWVudCBjb25mbGljdGVkIHdpdGggdGhlIFJFRkVSRU5DRSBjb25zdHJhaW50IFwiKC4qKVwiLiBUaGUgY29uZmxpY3Qgb2NjdXJyZWQgaW4gZGF0YWJhc2UgXCIoLiopXCIsIHRhYmxlIFwiKC4qKVwiLCBjb2x1bW4gJyguKiknLi8pIHx8XG4gICAgICBlcnIubWVzc2FnZS5tYXRjaCgvVGhlICg/OklOU0VSVHxNRVJHRXxVUERBVEUpIHN0YXRlbWVudCBjb25mbGljdGVkIHdpdGggdGhlIEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgXCIoLiopXCIuIFRoZSBjb25mbGljdCBvY2N1cnJlZCBpbiBkYXRhYmFzZSBcIiguKilcIiwgdGFibGUgXCIoLiopXCIsIGNvbHVtbiAnKC4qKScuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBmaWVsZHM6IG51bGwsXG4gICAgICAgIGluZGV4OiBtYXRjaFsxXSxcbiAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0NvdWxkIG5vdCBkcm9wIGNvbnN0cmFpbnQuIFNlZSBwcmV2aW91cyBlcnJvcnMuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBjb25zdHJhaW50ID0gZXJyLnNxbC5tYXRjaCgvKD86Y29uc3RyYWludHxpbmRleCkgXFxbKC4rPylcXF0vaSk7XG4gICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludCA/IGNvbnN0cmFpbnRbMV0gOiB1bmRlZmluZWQ7XG4gICAgICBsZXQgdGFibGUgPSBlcnIuc3FsLm1hdGNoKC90YWJsZSBcXFsoLis/KVxcXS9pKTtcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IG1hdGNoWzFdLFxuICAgICAgICBjb25zdHJhaW50LFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlzU2hvd09yRGVzY3JpYmVRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2VsZWN0IGMuY29sdW1uX25hbWUgYXMgJ25hbWUnLCBjLmRhdGFfdHlwZSBhcyAndHlwZScsIGMuaXNfbnVsbGFibGUgYXMgJ2lzbnVsbCdcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnc2VsZWN0IHRhYmxlbmFtZSA9IHQubmFtZSwgbmFtZSA9IGluZC5uYW1lLCcpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2V4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZScpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWUnKTtcbiAgfVxuXG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIC8vIEdyb3VwIGJ5IGluZGV4IG5hbWUsIGFuZCBjb2xsZWN0IGFsbCBmaWVsZHNcbiAgICBkYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgaWYgKCEoaXRlbS5pbmRleF9uYW1lIGluIGFjYykpIHtcbiAgICAgICAgYWNjW2l0ZW0uaW5kZXhfbmFtZV0gPSBpdGVtO1xuICAgICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmluZGV4X2tleXMuc3BsaXQoJywnKS5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgIGxldCBjb2x1bW5OYW1lID0gY29sdW1uLnRyaW0oKTtcbiAgICAgICAgaWYgKGNvbHVtbk5hbWUuaW5jbHVkZXMoJygtKScpKSB7XG4gICAgICAgICAgY29sdW1uTmFtZSA9IGNvbHVtbk5hbWUucmVwbGFjZSgnKC0pJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjW2l0ZW0uaW5kZXhfbmFtZV0uZmllbGRzLnB1c2goe1xuICAgICAgICAgIGF0dHJpYnV0ZTogY29sdW1uTmFtZSxcbiAgICAgICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICBvcmRlcjogY29sdW1uLmluY2x1ZGVzKCcoLSknKSA/ICdERVNDJyA6ICdBU0MnLFxuICAgICAgICAgIGNvbGxhdGU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGl0ZW0uaW5kZXhfa2V5cztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIF8ubWFwKGRhdGEsIGl0ZW0gPT4gKHtcbiAgICAgIHByaW1hcnk6IGl0ZW0uaW5kZXhfbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3BrJyksXG4gICAgICBmaWVsZHM6IGl0ZW0uZmllbGRzLFxuICAgICAgbmFtZTogaXRlbS5pbmRleF9uYW1lLFxuICAgICAgdGFibGVOYW1lOiB1bmRlZmluZWQsXG4gICAgICB1bmlxdWU6IGl0ZW0uaW5kZXhfZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndW5pcXVlJyksXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gIH1cblxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAvLyBhZGQgdGhlIGluc2VydGVkIHJvdyBpZCB0byB0aGUgaW5zdGFuY2VcbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgaWQgPSBudWxsO1xuICAgICAgbGV0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IG51bGw7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdXRvSW5jcmVtZW50QXR0cmlidXRlKSAmJlxuICAgICAgICB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkO1xuXG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdO1xuICAgICAgaWQgPSBpZCB8fCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgJiYgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhc107XG5cbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0gPSBpZDtcblxuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzWzBdKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSByZXN1bHRzWzBdW2tleV07XG4gIFxuICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuICBcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm15c3FsO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjpteXNxbCcpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdteXNxbCcpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBNeVNRTCBDb25uZWN0aW9uIE1hbmFnZXJcbiAqXG4gKiBHZXQgY29ubmVjdGlvbnMsIHZhbGlkYXRlIGFuZCBkaXNjb25uZWN0IHRoZW0uXG4gKiBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHBvb2xpbmcgdXNlIGl0IHRvIGhhbmRsZSBNeVNRTCBzcGVjaWZpYyBjb25uZWN0aW9uc1xuICogVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWRvcmFyZXMvbm9kZS1teXNxbDIgdG8gY29ubmVjdCB3aXRoIE15U1FMIHNlcnZlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZSgnbXlzcWwyJyk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG5cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cblxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cblxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB3aXRoIE15U1FMIGRhdGFiYXNlIGJhc2VkIG9uIGNvbmZpZywgSGFuZGxlIGFueSBlcnJvcnMgaW4gY29ubmVjdGlvblxuICAgKiBTZXQgdGhlIHBvb2wgaGFuZGxlcnMgb24gY29ubmVjdGlvbi5lcnJvclxuICAgKiBBbHNvIHNldCBwcm9wZXIgdGltZXpvbmUgb25jZSBjb25uZWN0aW9uIGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBmbGFnczogJy1GT1VORF9ST1dTJyxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgdGltZXpvbmU6IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUsXG4gICAgICB0eXBlQ2FzdDogQ29ubmVjdGlvbk1hbmFnZXIuX3R5cGVjYXN0LmJpbmQodGhpcyksXG4gICAgICBiaWdOdW1iZXJTdHJpbmdzOiBmYWxzZSxcbiAgICAgIHN1cHBvcnRCaWdOdW1iZXJzOiB0cnVlLFxuICAgICAgLi4uY29uZmlnLmRpYWxlY3RPcHRpb25zXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5saWIuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcblxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgICAvLyBjbGVhbiB1cCBjb25uZWN0ICYgZXJyb3IgZXZlbnQgaWYgdGhlcmUgaXMgZXJyb3JcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAvLyBjbGVhbiB1cCBlcnJvciBldmVudCBpZiBjb25uZWN0ZWRcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkb24ndCB1c2UgY29ubmVjdGlvbi5vbmNlIGZvciBlcnJvciBldmVudCBoYW5kbGluZyBoZXJlXG4gICAgICAgIC8vIG15c3FsMiBlbWl0IGVycm9yIHR3byB0aW1lcyBpbiBjYXNlIGhhbmRzaGFrZSB3YXMgZmFpbGVkXG4gICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHByb3RvY29sX2xvc3QgYW5kIHNlY29uZCBpcyB0aW1lb3V0XG4gICAgICAgIC8vIGlmIHdlIHdpbGwgdXNlIGBvbmNlLmVycm9yYCBub2RlIHByb2Nlc3Mgd2lsbCBjcmFzaCBvbiAybmQgZXJyb3IgZW1pdFxuICAgICAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnY29ubmVjdCcsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiBhY3F1aXJlZCcpO1xuICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VTT0NLRVQnOlxuICAgICAgICAgIGNhc2UgJ0VDT05OUkVTRVQnOlxuICAgICAgICAgIGNhc2UgJ0VQSVBFJzpcbiAgICAgICAgICBjYXNlICdQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1QnOlxuICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICAgIC8vIHNldCB0aW1lem9uZSBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgIC8vIGJ1dCBuYW1lZCB0aW1lem9uZSBhcmUgbm90IGRpcmVjdGx5IHN1cHBvcnRlZCBpbiBteXNxbCwgc28gZ2V0IGl0cyBvZmZzZXQgZmlyc3RcbiAgICAgICAgbGV0IHR6T2Zmc2V0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZTtcbiAgICAgICAgdHpPZmZzZXQgPSAvXFwvLy50ZXN0KHR6T2Zmc2V0KSA/IG1vbWVudFR6LnR6KHR6T2Zmc2V0KS5mb3JtYXQoJ1onKSA6IHR6T2Zmc2V0O1xuICAgICAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gY29ubmVjdGlvbi5xdWVyeShgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgLCBjYikpKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICBjYXNlICdFQ09OTlJFRlVTRUQnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFUl9BQ0NFU1NfREVOSUVEX0VSUk9SJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VOT1RGT1VORCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlICdFSE9TVFVOUkVBQ0gnOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VJTlZBTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICAvLyBEb24ndCBkaXNjb25uZWN0IGNvbm5lY3Rpb25zIHdpdGggQ0xPU0VEIHN0YXRlXG4gICAgaWYgKGNvbm5lY3Rpb24uX2Nsb3NpbmcpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkoY2FsbGJhY2sgPT4gY29ubmVjdGlvbi5lbmQoY2FsbGJhY2spKSgpO1xuICB9XG5cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uXG4gICAgICAmJiAhY29ubmVjdGlvbi5fZmF0YWxFcnJvclxuICAgICAgJiYgIWNvbm5lY3Rpb24uX3Byb3RvY29sRXJyb3JcbiAgICAgICYmICFjb25uZWN0aW9uLl9jbG9zaW5nXG4gICAgICAmJiAhY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveWVkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB3a3ggPSByZXF1aXJlKCd3a3gnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHlwZXMgPT4ge1xuICBCYXNlVHlwZXMuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9ICdodHRwczovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjcvZW4vZGF0YS10eXBlcy5odG1sJztcblxuICAvKipcbiAgICogdHlwZXM6IFtidWZmZXJfdHlwZSwgLi4uXVxuICAgKlxuICAgKiBAc2VlIGJ1ZmZlcl90eXBlIGhlcmUgaHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2MtYXBpLXByZXBhcmVkLXN0YXRlbWVudC10eXBlLWNvZGVzLmh0bWxcbiAgICogQHNlZSBoZXggaGVyZSBodHRwczovL2dpdGh1Yi5jb20vc2lkb3JhcmVzL25vZGUtbXlzcWwyL2Jsb2IvbWFzdGVyL2xpYi9jb25zdGFudHMvdHlwZXMuanNcbiAgICovXG5cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubXlzcWwgPSBbJ0RBVEVUSU1FJ107XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubXlzcWwgPSBbJ1ZBUl9TVFJJTkcnXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubXlzcWwgPSBbJ1NUUklORyddO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5teXNxbCA9IFsnQkxPQiddO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5teXNxbCA9IFsnVElOWSddO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubXlzcWwgPSBbJ1NIT1JUJ107XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubXlzcWwgPSBbJ0lOVDI0J107XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm15c3FsID0gWydMT05HJ107XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubXlzcWwgPSBbJ0xPTkdMT05HJ107XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5teXNxbCA9IFsnRkxPQVQnXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubXlzcWwgPSBbJ1RJTUUnXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm15c3FsID0gWydEQVRFJ107XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm15c3FsID0gWydUSU5ZJ107XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm15c3FsID0gWydUSU5ZQkxPQicsICdCTE9CJywgJ0xPTkdCTE9CJ107XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm15c3FsID0gWydORVdERUNJTUFMJ107XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm15c3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm15c3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm15c3FsID0gWydET1VCTEUnXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5teXNxbCA9IFsnRE9VQkxFJ107XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5teXNxbCA9IFsnR0VPTUVUUlknXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMubXlzcWwgPSBbJ0pTT04nXTtcblxuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBzdXBlci50b1NxbCgpO1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gJyBVTlNJR05FRCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSAnIFpFUk9GSUxMJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID8gYERBVEVUSU1FKCR7dGhpcy5fbGVuZ3RofSlgIDogJ0RBVEVUSU1FJztcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIC8vIEZyYWN0aW9uYWwgREFURVRJTUVzIG9ubHkgc3VwcG9ydGVkIG9uIE15U1FMIDUuNi40K1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW06c3MuU1NTJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW06c3MnKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb21lbnQudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudC50eih2YWx1ZSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgJHt2YWx1ZX0gJHtvcHRpb25zLnRpbWV6b25lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnQ0hBUigzNikgQklOQVJZJztcbiAgICB9XG4gIH1cblxuICBjb25zdCBTVVBQT1JURURfR0VPTUVUUllfVFlQRVMgPSBbJ1BPSU5UJywgJ0xJTkVTVFJJTkcnLCAnUE9MWUdPTiddO1xuXG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgICBzdXBlcih0eXBlLCBzcmlkKTtcbiAgICAgIGlmIChfLmlzRW1wdHkodGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLmtleTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFNVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUy5pbmNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZXMgYXJlOiAke1NVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyKCk7XG4gICAgICAvLyBFbXB0eSBidWZmZXIsIE15U1FMIGRvZXNuJ3Qgc3VwcG9ydCBQT0lOVCBFTVBUWVxuICAgICAgLy8gY2hlY2ssIGh0dHBzOi8vZGV2Lm15c3FsLmNvbS93b3JrbG9nL3Rhc2svP2lkPTIzODFcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBkaXNjYXJkIHRoZSBmaXJzdCA0IGJ5dGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDQpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZSh2YWx1ZSkudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3FsVHlwZTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgRU5VTSgke3RoaXMudmFsdWVzLm1hcCh2YWx1ZSA9PiBvcHRpb25zLmVzY2FwZSh2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSAnd2hlcmUnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIEVOVU0sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBVVUlELFxuICAgIEdFT01FVFJZLFxuICAgIERFQ0lNQUwsXG4gICAgSlNPTjogSlNPTlRZUEVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0Jyk7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5teXNxbDtcbmNvbnN0IHsgTXlTUUxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi9xdWVyeS1pbnRlcmZhY2UnKTtcblxuY2xhc3MgTXlzcWxEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTXlTUUxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5cbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gICdWQUxVRVMgKCknOiB0cnVlLFxuICAnTElNSVQgT04gVVBEQVRFJzogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgZm9yU2hhcmU6ICdMT0NLIElOIFNIQVJFIE1PREUnLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogZmFsc2UsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiAnIElHTk9SRScsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6ICcgT04gRFVQTElDQVRFIEtFWSBVUERBVEUnXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHBhcnNlcjogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiAxXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGNoZWNrOiBmYWxzZVxuICB9LFxuICBpbmRleFZpYUFsdGVyOiB0cnVlLFxuICBpbmRleEhpbnRzOiB0cnVlLFxuICBOVU1FUklDOiB0cnVlLFxuICBHRU9NRVRSWTogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgUkVHRVhQOiB0cnVlXG59KTtcblxuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9ICc1LjcuMCc7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5R2VuZXJhdG9yID0gUXVlcnlHZW5lcmF0b3I7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9ICdteXNxbCc7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdgJztcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBNeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5cbm1vZHVsZS5leHBvcnRzID0gTXlzcWxEaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvcnMnKTtcblxuXG5jb25zdCBKU09OX0ZVTkNUSU9OX1JFR0VYID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG5jb25zdCBKU09OX09QRVJBVE9SX1JFR0VYID0gL15cXHMqKC0+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuY29uc3QgVE9LRU5fQ0FQVFVSRV9SRUdFWCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuY29uc3QgRk9SRUlHTl9LRVlfRklFTERTID0gW1xuICAnQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnRfbmFtZScsXG4gICdDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludE5hbWUnLFxuICAnQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludFNjaGVtYScsXG4gICdDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50Q2F0YWxvZycsXG4gICdUQUJMRV9OQU1FIGFzIHRhYmxlTmFtZScsXG4gICdUQUJMRV9TQ0hFTUEgYXMgdGFibGVTY2hlbWEnLFxuICAnVEFCTEVfU0NIRU1BIGFzIHRhYmxlQ2F0YWxvZycsXG4gICdDT0xVTU5fTkFNRSBhcyBjb2x1bW5OYW1lJyxcbiAgJ1JFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZVNjaGVtYScsXG4gICdSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVDYXRhbG9nJyxcbiAgJ1JFRkVSRU5DRURfVEFCTEVfTkFNRSBhcyByZWZlcmVuY2VkVGFibGVOYW1lJyxcbiAgJ1JFRkVSRU5DRURfQ09MVU1OX05BTUUgYXMgcmVmZXJlbmNlZENvbHVtbk5hbWUnXG5dLmpvaW4oJywnKTtcblxuY29uc3QgdHlwZVdpdGhvdXREZWZhdWx0ID0gbmV3IFNldChbJ0JMT0InLCAnVEVYVCcsICdHRU9NRVRSWScsICdKU09OJ10pO1xuXG5jbGFzcyBNeVNRTFF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuT3BlcmF0b3JNYXAgPSB7XG4gICAgICAuLi50aGlzLk9wZXJhdG9yTWFwLFxuICAgICAgW09wLnJlZ2V4cF06ICdSRUdFWFAnLFxuICAgICAgW09wLm5vdFJlZ2V4cF06ICdOT1QgUkVHRVhQJ1xuICAgIH07XG4gIH1cblxuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0NSRUFURSBEQVRBQkFTRSBJRiBOT1QgRVhJU1RTJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUkFDVEVSIFNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY2hhcnNldCl9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgREVGQVVMVCBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgREFUQUJBU0UgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKX07YDtcbiAgfVxuXG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gJ1NIT1cgVEFCTEVTJztcbiAgfVxuXG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuICdTSE9XIFRBQkxFUyc7XG4gIH1cblxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuICdTRUxFQ1QgVkVSU0lPTigpIGFzIGB2ZXJzaW9uYCc7XG4gIH1cblxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBlbmdpbmU6ICdJbm5vREInLFxuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIHJvd0Zvcm1hdDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXTtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IHt9O1xuICAgIGNvbnN0IGF0dHJTdHIgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkgY29udGludWU7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkge1xuICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuXG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgICAgLy8gTXlTUUwgZG9lc24ndCBzdXBwb3J0IGlubGluZSBSRUZFUkVOQ0VTIGRlY2xhcmF0aW9uczogbW92ZSB0byB0aGUgZW5kXG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJycpfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJycpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgLy8gTXlTUUwgZG9lc24ndCBzdXBwb3J0IGlubGluZSBSRUZFUkVOQ0VTIGRlY2xhcmF0aW9uczogbW92ZSB0byB0aGUgZW5kXG4gICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgYXR0cmlidXRlc0NsYXVzZSA9IGF0dHJTdHIuam9pbignLCAnKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcChwayA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oJywgJyk7XG5cbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKCdfJyl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBVTklRVUUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoZmllbGQgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0NSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTJyxcbiAgICAgIHRhYmxlLFxuICAgICAgYCgke2F0dHJpYnV0ZXNDbGF1c2V9KWAsXG4gICAgICBgRU5HSU5FPSR7b3B0aW9ucy5lbmdpbmV9YCxcbiAgICAgIG9wdGlvbnMuY29tbWVudCAmJiB0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnc3RyaW5nJyAmJiBgQ09NTUVOVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29tbWVudCl9YCxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSU0VUPSR7b3B0aW9ucy5jaGFyc2V0fWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYENPTExBVEUgJHtvcHRpb25zLmNvbGxhdGV9YCxcbiAgICAgIG9wdGlvbnMuaW5pdGlhbEF1dG9JbmNyZW1lbnQgJiYgYEFVVE9fSU5DUkVNRU5UPSR7b3B0aW9ucy5pbml0aWFsQXV0b0luY3JlbWVudH1gLFxuICAgICAgb3B0aW9ucy5yb3dGb3JtYXQgJiYgYFJPV19GT1JNQVQ9JHtvcHRpb25zLnJvd0Zvcm1hdH1gLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKFxuICAgICAgdGhpcy5hZGRTY2hlbWEoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gYFNIT1cgRlVMTCBDT0xVTU5TIEZST00gJHt0YWJsZX07YDtcbiAgfVxuXG4gIHNob3dUYWJsZXNRdWVyeShkYXRhYmFzZSkge1xuICAgIGxldCBxdWVyeSA9ICdTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9IFxcJ0JBU0UgVEFCTEVcXCcnO1xuICAgIGlmIChkYXRhYmFzZSkge1xuICAgICAgcXVlcnkgKz0gYCBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShkYXRhYmFzZSl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgKz0gJyBBTkQgVEFCTEVfU0NIRU1BIE5PVCBJTiAoXFwnTVlTUUxcXCcsIFxcJ0lORk9STUFUSU9OX1NDSEVNQVxcJywgXFwnUEVSRk9STUFOQ0VfU0NIRU1BXFwnLCBcXCdTWVNcXCcpJztcbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG5cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgICdBREQnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgY29udGV4dDogJ2FkZENvbHVtbicsXG4gICAgICAgIHRhYmxlTmFtZTogdGFibGUsXG4gICAgICAgIGZvcmVpZ25LZXk6IGtleVxuICAgICAgfSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdEUk9QJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG4gICAgY29uc3QgY29uc3RyYWludFN0cmluZyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCAnJyk7XG4gICAgICAgIGNvbnN0cmFpbnRTdHJpbmcucHVzaChgRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KSAke2RlZmluaXRpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyaW5nLnB1c2goYFxcYCR7YXR0cmlidXRlTmFtZX1cXGAgXFxgJHthdHRyaWJ1dGVOYW1lfVxcYCAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0clN0cmluZy5sZW5ndGggJiYgYENIQU5HRSAke2F0dHJTdHJpbmcuam9pbignLCAnKX1gLFxuICAgICAgY29uc3RyYWludFN0cmluZy5sZW5ndGggJiYgYEFERCAke2NvbnN0cmFpbnRTdHJpbmcuam9pbignLCAnKX1gLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgIGF0dHJTdHJpbmcucHVzaChgXFxgJHthdHRyQmVmb3JlfVxcYCBcXGAke2F0dHJOYW1lfVxcYCAke2RlZmluaXRpb259YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0NIQU5HRScsXG4gICAgICBhdHRyU3RyaW5nLmpvaW4oJywgJyksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIC8vIFBhcnNlIG5lc3RlZCBvYmplY3RcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoY29uZGl0aW9uID0+XG4gICAgICAgICAgYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbignIEFORCAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbXRoLnBhdGgpIHtcbiAgICAgICAgbGV0IHN0cjtcblxuICAgICAgICAvLyBBbGxvdyBzcGVjaWZ5aW5nIGNvbmRpdGlvbnMgdXNpbmcgdGhlIHNxbGl0ZSBqc29uIGZ1bmN0aW9uc1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbHNvIHN1cHBvcnQganNvbiBwcm9wZXJ0eSBhY2Nlc3NvcnNcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNtdGgudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoJyA9ICVzJywgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoL3RpbWVzdGFtcC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSAnZGF0ZXRpbWUnO1xuICAgICAgfSBlbHNlIGlmIChzbXRoLmpzb24gJiYgL2Jvb2xlYW4vaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZSBjYW5ub3QgYmUgY2FzdGVkIGFzIGJvb2xlYW5zIHdpdGhpbiBhIEpTT04gc3RydWN0dXJlXG4gICAgICAgIHNtdGgudHlwZSA9ICdjaGFyJztcbiAgICAgIH0gZWxzZSBpZiAoL2RvdWJsZSBwcmVjaXNpb24vaS50ZXN0KHNtdGgudHlwZSkgfHwgL2Jvb2xlYW4vaS50ZXN0KHNtdGgudHlwZSkgfHwgL2ludGVnZXIvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gJ2RlY2ltYWwnO1xuICAgICAgfSBlbHNlIGlmICgvdGV4dC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSAnY2hhcic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG5cbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgLy8gdHJ1ZS9mYWxzZSBhcmUgc3RvcmVkIGFzIHN0cmluZ3MgaW4gbXlzcWxcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBudWxsIGlzIHN0b3JlZCBhcyBhIHN0cmluZyBpbiBteXNxbFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgVFJVTkNBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuICB9XG5cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGxldCBsaW1pdCA9ICcnO1xuICAgIGxldCBxdWVyeSA9IGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgbGltaXQgPSBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9YDtcbiAgICB9XG5cbiAgICB3aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG5cbiAgICBpZiAod2hlcmUpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgV0hFUkUgJHt3aGVyZX1gO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeSArIGxpbWl0O1xuICB9XG5cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgU0hPVyBJTkRFWCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhYmFzZSAmJiBgRlJPTSBcXGAke29wdGlvbnMuZGF0YWJhc2V9XFxgYFxuICAgIF0pO1xuICB9XG5cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWE7XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUIENPTlNUUkFJTlRfQ0FUQUxPRyBBUyBjb25zdHJhaW50Q2F0YWxvZywnLFxuICAgICAgJ0NPTlNUUkFJTlRfTkFNRSBBUyBjb25zdHJhaW50TmFtZSwnLFxuICAgICAgJ0NPTlNUUkFJTlRfU0NIRU1BIEFTIGNvbnN0cmFpbnRTY2hlbWEsJyxcbiAgICAgICdDT05TVFJBSU5UX1RZUEUgQVMgY29uc3RyYWludFR5cGUsJyxcbiAgICAgICdUQUJMRV9OQU1FIEFTIHRhYmxlTmFtZSwnLFxuICAgICAgJ1RBQkxFX1NDSEVNQSBBUyB0YWJsZVNjaGVtYScsXG4gICAgICAnZnJvbSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFMnLFxuICAgICAgYFdIRVJFIHRhYmxlX25hbWU9JyR7dGFibGVOYW1lfSdgLFxuICAgICAgY29uc3RyYWludE5hbWUgJiYgYEFORCBjb25zdHJhaW50X25hbWUgPSAnJHtjb25zdHJhaW50TmFtZX0nYCxcbiAgICAgIHNjaGVtYU5hbWUgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAnJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcblxuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oJ18nKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnRFJPUCBJTkRFWCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpLFxuICAgICAgJ09OJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpXG4gICAgXSk7XG4gIH1cblxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmcgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZyh7IGVzY2FwZTogdGhpcy5lc2NhcGUuYmluZCh0aGlzKSB9KTtcbiAgICBsZXQgdGVtcGxhdGUgPSBhdHRyaWJ1dGVTdHJpbmc7XG5cbiAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgTk9UIE5VTEwnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBhdXRvX2luY3JlbWVudCc7XG4gICAgfVxuXG4gICAgLy8gQkxPQi9URVhUL0dFT01FVFJZL0pTT04gY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKCF0eXBlV2l0aG91dERlZmF1bHQuaGFzKGF0dHJpYnV0ZVN0cmluZylcbiAgICAgICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWVcbiAgICAgICYmIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBVTklRVUUnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBQUklNQVJZIEtFWSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuY29tbWVudCl9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmZpcnN0KSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIEZJUlNUJztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hZnRlcikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBBRlRFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5hZnRlcil9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gJ2FkZENvbHVtbicgJiYgb3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgY29uc3QgZmtOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYCR7b3B0aW9ucy50YWJsZU5hbWV9XyR7YXR0ck5hbWV9X2ZvcmVpZ25faWR4YCk7XG5cbiAgICAgICAgdGVtcGxhdGUgKz0gYCwgQUREIENPTlNUUkFJTlQgJHtma05hbWV9IEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSlgO1xuICAgICAgfVxuXG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcignaWQnKX0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBzdGF0bWVtZW50IGlzIGpzb24gZnVuY3Rpb24gb3Igc2ltcGxlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gIHN0bXQgIFRoZSBzdGF0ZW1lbnQgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgIHRydWUgaWYgdGhlIGdpdmVuIHN0YXRlbWVudCBpcyBqc29uIGZ1bmN0aW9uXG4gICAqIEB0aHJvd3MgIHtFcnJvcn0gICAgICAgICB0aHJvdyBpZiB0aGUgc3RhdGVtZW50IGxvb2tzIGxpa2UganNvbiBmdW5jdGlvbiBidXQgaGFzIGludmFsaWQgdG9rZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBKU09OX0ZVTkNUSU9OX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKCcoJyk7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBKU09OX09QRVJBVE9SX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSBUT0tFTl9DQVBUVVJFX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcoJykge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcpJykge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICc7Jykge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnZhbGlkIGpzb24gc3RhdGVtZW50XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiAoaGFzSW52YWxpZFRva2VuIHx8IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlIHN0YXRlbWVudCBoYXMgdmFsaWQganNvbiBmdW5jdGlvblxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgYWxsIGZvcmVpZ24ga2V5cyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHRhYmxlICBUaGUgdGFibGUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc2NoZW1hTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2NoZW1hLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgc2NoZW1hTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUJyxcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgIGBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIHdoZXJlIFRBQkxFX05BTUUgPSAnJHt0YWJsZU5hbWV9J2AsXG4gICAgICBgQU5EIENPTlNUUkFJTlRfTkFNRSE9J1BSSU1BUlknIEFORCBDT05TVFJBSU5UX1NDSEVNQT0nJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgJ0FORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTEwnLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgdGhlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgb2YgYSBnaXZlbiBjb2x1bW4uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gdGFibGUgIFRoZSB0YWJsZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hID8gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSkgOiAnJztcbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW5OYW1lID0gd3JhcFNpbmdsZVF1b3RlKGNvbHVtbk5hbWUpO1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCcsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICAnRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRScsXG4gICAgICAnV0hFUkUgKCcsXG4gICAgICBbXG4gICAgICAgIGBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIFJFRkVSRU5DRURfQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YFxuICAgICAgXSxcbiAgICAgICcpIE9SICgnLFxuICAgICAgW1xuICAgICAgICBgVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIENPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWAsXG4gICAgICAgICdBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMJ1xuICAgICAgXSxcbiAgICAgICcpJ1xuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZW1vdmVzIGEgZm9yZWlnbiBrZXkgZnJvbSBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhYmxlTmFtZSAgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZvcmVpZ25LZXkgVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdEUk9QIEZPUkVJR04gS0VZJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cbn1cblxuLy8gcHJpdmF0ZSBtZXRob2RzXG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICByZXR1cm4gVXRpbHMuYWRkVGlja3MoaWRlbnRpZmllciwgJ1xcJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE15U1FMUXVlcnlHZW5lcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIHRoYXQgU2VxdWVsaXplIHVzZXMgdG8gdGFsayB3aXRoIE15U1FML01hcmlhREIgZGF0YWJhc2VcbiAqL1xuY2xhc3MgTXlTUUxRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIEEgd3JhcHBlciB0aGF0IGZpeGVzIE15U1FMJ3MgaW5hYmlsaXR5IHRvIGNsZWFubHkgcmVtb3ZlIGNvbHVtbnMgZnJvbSBleGlzdGluZyB0YWJsZXMgaWYgdGhleSBoYXZlIGEgZm9yZWlnbiBrZXkgY29uc3RyYWludC5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICAgIH0sIGNvbHVtbk5hbWUpLFxuICAgICAgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfVxuICAgICk7XG5cbiAgICAvL0V4Y2x1ZGUgcHJpbWFyeSBrZXkgY29uc3RyYWludFxuICAgIGlmIChyZXN1bHRzLmxlbmd0aCAmJiByZXN1bHRzWzBdLmNvbnN0cmFpbnRfbmFtZSAhPT0gJ1BSSU1BUlknKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcChjb25zdHJhaW50ID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnRfbmFtZSksXG4gICAgICAgIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH1cbiAgICAgICkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgY29sdW1uTmFtZSksXG4gICAgICB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuXG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIG1vZGVsLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93Q29uc3RyYWludHNRdWVyeShcbiAgICAgIHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICAgIH0sIGNvbnN0cmFpbnROYW1lKTtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsXG4gICAgICB0eXBlOiB0aGlzLnNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UUyB9KTtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1swXTtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKCFjb25zdHJhaW50IHx8ICFjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3IoXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ29uc3RyYWludCAke2NvbnN0cmFpbnROYW1lfSBvbiB0YWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgLFxuICAgICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUgPT09ICdGT1JFSUdOIEtFWScpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlSW5kZXhRdWVyeShjb25zdHJhaW50LnRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50TmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnRzLk15U1FMUXVlcnlJbnRlcmZhY2UgPSBNeVNRTFF1ZXJ5SW50ZXJmYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnknKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuXG5jb25zdCBFUl9EVVBfRU5UUlkgPSAxMDYyO1xuY29uc3QgRVJfREVBRExPQ0sgPSAxMjEzO1xuY29uc3QgRVJfUk9XX0lTX1JFRkVSRU5DRUQgPSAxNDUxO1xuY29uc3QgRVJfTk9fUkVGRVJFTkNFRF9ST1cgPSAxNDUyO1xuXG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3NxbDpteXNxbCcpO1xuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIHsgc2hvd1dhcm5pbmdzOiBmYWxzZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXNfKSA9PiB7XG4gICAgICBpZiAodmFsdWVzX1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmluZFBhcmFtLnB1c2godmFsdWVzX1trZXldKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW0ubGVuZ3RoID4gMCA/IGJpbmRQYXJhbSA6IHVuZGVmaW5lZF07XG4gIH1cblxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2hvd1dhcm5pbmdzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zaG93V2FybmluZ3MgfHwgb3B0aW9ucy5zaG93V2FybmluZ3M7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGRlYnVnKCdwYXJhbWV0ZXJzKCVqKScsIHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvblxuICAgICAgICAgICAgLmV4ZWN1dGUoc3FsLCBwYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKVxuICAgICAgICAgICAgLnNldE1heExpc3RlbmVycygxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvblxuICAgICAgICAgICAgLnF1ZXJ5KHsgc3FsIH0sIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpXG4gICAgICAgICAgICAuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBlcnJvci5lcnJubyA9PT0gRVJfREVBRExPQ0spIHtcbiAgICAgICAgLy8gTXlTUUwgYXV0b21hdGljYWxseSByb2xscy1iYWNrIHRyYW5zYWN0aW9ucyBpbiB0aGUgZXZlbnQgb2YgYSBkZWFkbG9jay5cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugc3RpbGwgaW5pdGlhdGUgYSBtYW51YWwgcm9sbGJhY2sgdG8gZW5zdXJlIHRoZSBjb25uZWN0aW9uIGdldHMgcmVsZWFzZWQgLSBzZWUgIzEzMTAyLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9wdGlvbnMudHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycyAtIHNpbmNlIE15U1FMIGF1dG9tYXRpY2FsbHkgcm9sbGVkIGJhY2ssIHdlJ3JlXG4gICAgICAgICAgLy8gbm90IHRoYXQgd29ycmllZCBhYm91dCB0aGlzIHJlZHVuZGFudCByb2xsYmFjayBmYWlsaW5nLlxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCA9ICdyb2xsYmFjayc7XG4gICAgICB9XG5cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3dXYXJuaW5ncyAmJiByZXN1bHRzICYmIHJlc3VsdHMud2FybmluZ1N0YXR1cyA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nV2FybmluZ3MocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeSBleGVjdXRpb24uXG4gICAqXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICBxdWVyeS5mb3JtYXRSZXN1bHRzKFtcbiAgICogICAge1xuICAgKiAgICAgIGlkOiAxLCAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgYXR0cjI6ICdzbmFmdScsICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBUYXNrcy5pZDogMSwgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICAgIFRhc2tzLnRpdGxlOiAndGFzaycgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgIH1cbiAgICogIF0pXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgcmVzdWx0IG9mIHRoZSBxdWVyeSBleGVjdXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcblxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG5cbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAvLyBoYW5kbGUgYnVsa0NyZWF0ZSBBSSBwcmltYXJ5IGtleVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUmVzdWx0U2V0SGVhZGVyJ1xuICAgICAgICAgICYmIHRoaXMubW9kZWxcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBkYXRhLmFmZmVjdGVkUm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IFt0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZF06IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGVudW1SZWdleCA9IC9eZW51bS9pO1xuICAgICAgICByZXN1bHRbX3Jlc3VsdC5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogZW51bVJlZ2V4LnRlc3QoX3Jlc3VsdC5UeXBlKSA/IF9yZXN1bHQuVHlwZS5yZXBsYWNlKGVudW1SZWdleCwgJ0VOVU0nKSA6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OdWxsID09PSAnWUVTJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleSA9PT0gJ1BSSScsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsICdFeHRyYScpXG4gICAgICAgICAgICAmJiBfcmVzdWx0LkV4dHJhLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRvX2luY3JlbWVudCcsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50ID8gX3Jlc3VsdC5Db21tZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYWZmZWN0ZWRSb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzID09PSAxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIC8vIE15U1FMIHJldHVybnMgcm93IGRhdGEgYW5kIG1ldGFkYXRhIChhZmZlY3RlZCByb3dzIGV0YykgaW4gYSBzaW5nbGUgb2JqZWN0IC0gbGV0J3Mgc3RhbmRhcml6ZSBpdCwgc29ydGFcbiAgICAgIHJldHVybiBbZGF0YSwgZGF0YV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIGxvZ1dhcm5pbmdzKHJlc3VsdHMpIHtcbiAgICBjb25zdCB3YXJuaW5nUmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuKCdTSE9XIFdBUk5JTkdTJyk7XG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgTXlTUUwgV2FybmluZ3MgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgJ2RlZmF1bHQnfSk6IGA7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IF93YXJuaW5nUm93IG9mIHdhcm5pbmdSZXN1bHRzKSB7XG4gICAgICBpZiAoX3dhcm5pbmdSb3cgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgX3dhcm5pbmdSb3dbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX3dhcm5pbmdSZXN1bHQgb2YgX3dhcm5pbmdSb3cpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfd2FybmluZ1Jlc3VsdCwgJ01lc3NhZ2UnKSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goX3dhcm5pbmdSZXN1bHQuTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBfb2JqZWN0S2V5IG9mIF93YXJuaW5nUmVzdWx0LmtleXMoKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChbX29iamVjdEtleSwgX3dhcm5pbmdSZXN1bHRbX29iamVjdEtleV1dLmpvaW4oJzogJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2VxdWVsaXplLmxvZyh3YXJuaW5nTWVzc2FnZSArIG1lc3NhZ2VzLmpvaW4oJzsgJyksIHRoaXMub3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIGNvbnN0IGVyckNvZGUgPSBlcnIuZXJybm8gfHwgZXJyLmNvZGU7XG5cbiAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgIGNhc2UgRVJfRFVQX0VOVFJZOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0R1cGxpY2F0ZSBlbnRyeSAnKFtcXHNcXFNdKiknIGZvciBrZXkgJz8oKC58XFxzKSo/KSc/JC8pO1xuICAgICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICAgIGxldCBtZXNzYWdlID0gJ1ZhbGlkYXRpb24gZXJyb3InO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCctJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpZWxkS2V5ID0gbWF0Y2ggPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmllbGRWYWwgPSBtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1tmaWVsZEtleV07XG5cbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGlmICh1bmlxdWVLZXkubXNnKSBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tmaWVsZEtleV0gPSBmaWVsZFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgICB0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLFxuICAgICAgICAgICAgJ3VuaXF1ZSB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkRCLFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgICAnbm90X3VuaXF1ZSdcbiAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEVSX1JPV19JU19SRUZFUkVOQ0VEOlxuICAgICAgY2FzZSBFUl9OT19SRUZFUkVOQ0VEX1JPVzoge1xuICAgICAgICAvLyBlLmcuIENPTlNUUkFJTlQgYGV4YW1wbGVfY29uc3RyYWludF9uYW1lYCBGT1JFSUdOIEtFWSAoYGV4YW1wbGVfaWRgKSBSRUZFUkVOQ0VTIGBleGFtcGxlc2AgKGBpZGApXG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goXG4gICAgICAgICAgL0NPTlNUUkFJTlQgKFtgXCJdKSguKilcXDEgRk9SRUlHTiBLRVkgXFwoXFwxKC4qKVxcMVxcKSBSRUZFUkVOQ0VTIFxcMSguKilcXDEgXFwoXFwxKC4qKVxcMVxcKS9cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICdgJztcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWF0Y2ggPyBtYXRjaFszXS5zcGxpdChuZXcgUmVnRXhwKGAke3F1b3RlQ2hhcn0sICoke3F1b3RlQ2hhcn1gKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgcmVsdHlwZTogU3RyaW5nKGVyckNvZGUpID09PSBTdHJpbmcoRVJfUk9XX0lTX1JFRkVSRU5DRUQpID8gJ3BhcmVudCcgOiAnY2hpbGQnLFxuICAgICAgICAgIHRhYmxlOiBtYXRjaCA/IG1hdGNoWzRdIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzICYmIGZpZWxkcy5sZW5ndGggJiYgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkc1swXV0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIGluZGV4OiBtYXRjaCA/IG1hdGNoWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgLy8gR3JvdXAgYnkgaW5kZXggbmFtZSwgYW5kIGNvbGxlY3QgYWxsIGZpZWxkc1xuICAgIGRhdGEgPSBkYXRhLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoIShpdGVtLktleV9uYW1lIGluIGFjYykpIHtcbiAgICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdID0gaXRlbTtcbiAgICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdLmZpZWxkc1tpdGVtLlNlcV9pbl9pbmRleCAtIDFdID0ge1xuICAgICAgICBhdHRyaWJ1dGU6IGl0ZW0uQ29sdW1uX25hbWUsXG4gICAgICAgIGxlbmd0aDogaXRlbS5TdWJfcGFydCB8fCB1bmRlZmluZWQsXG4gICAgICAgIG9yZGVyOiBpdGVtLkNvbGxhdGlvbiA9PT0gJ0EnID8gJ0FTQycgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBkZWxldGUgaXRlbS5jb2x1bW5fbmFtZTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gXy5tYXAoZGF0YSwgaXRlbSA9PiAoe1xuICAgICAgcHJpbWFyeTogaXRlbS5LZXlfbmFtZSA9PT0gJ1BSSU1BUlknLFxuICAgICAgZmllbGRzOiBpdGVtLmZpZWxkcyxcbiAgICAgIG5hbWU6IGl0ZW0uS2V5X25hbWUsXG4gICAgICB0YWJsZU5hbWU6IGl0ZW0uVGFibGUsXG4gICAgICB1bmlxdWU6IGl0ZW0uTm9uX3VuaXF1ZSAhPT0gMSxcbiAgICAgIHR5cGU6IGl0ZW0uSW5kZXhfdHlwZVxuICAgIH0pKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RvcmVzID0gbmV3IE1hcCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpYWxlY3QgPT4ge1xuICBpZiAoIXN0b3Jlcy5oYXMoZGlhbGVjdCkpIHtcbiAgICBzdG9yZXMuc2V0KGRpYWxlY3QsIG5ldyBNYXAoKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgc3RvcmVzLmdldChkaWFsZWN0KS5jbGVhcigpO1xuICAgIH0sXG4gICAgcmVmcmVzaChkYXRhVHlwZSkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGRhdGFUeXBlLnR5cGVzW2RpYWxlY3RdKSB7XG4gICAgICAgIHN0b3Jlcy5nZXQoZGlhbGVjdCkuc2V0KHR5cGUsIGRhdGFUeXBlLnBhcnNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCh0eXBlKSB7XG4gICAgICByZXR1cm4gc3RvcmVzLmdldChkaWFsZWN0KS5nZXQodHlwZSk7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOnBnJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgNTQzMjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuXG4gICAgY29uc3QgcGdMaWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZSgncGcnKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUgPyBwZ0xpYi5uYXRpdmUgOiBwZ0xpYjtcblxuICAgIHRoaXMuX2NsZWFyRHluYW1pY09JRHMoKTtcbiAgICB0aGlzLl9jbGVhclR5cGVQYXJzZXIoKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcy5wb3N0Z3Jlcyk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhpcyBhcyBhIG1ldGhvZCBzbyB0aGF0IHRoZSBwYXJzaW5nIG1heSBiZSB1cGRhdGVkIHdoZW4gdGhlIHVzZXIgaGFzIGFkZGVkIGFkZGl0aW9uYWwsIGN1c3RvbSB0eXBlc1xuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBjb25zdCBhcnJheVBhcnNlckJ1aWxkZXIgPSBwYXJzZXIgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlID0+IHRoaXMubGliLnR5cGVzLmFycmF5UGFyc2VyLmNyZWF0ZSh2YWx1ZSwgcGFyc2VyKS5wYXJzZSgpO1xuICAgIH07XG4gICAgY29uc3QgcmFuZ2VQYXJzZXJCdWlsZGVyID0gcGFyc2VyID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PiBkYXRhVHlwZS5wYXJzZSh2YWx1ZSwgeyBwYXJzZXIgfSk7XG4gICAgfTtcblxuICAgIC8vIFNldCByYW5nZSBwYXJzZXJzXG4gICAgaWYgKGRhdGFUeXBlLmtleS50b0xvd2VyQ2FzZSgpID09PSAncmFuZ2UnKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5uYW1lT2lkTWFwKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5uYW1lT2lkTWFwW25hbWVdO1xuICAgICAgICBpZiAoISBlbnRyeS5yYW5nZU9pZCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgcmFuZ2VQYXJzZXIgPSByYW5nZVBhcnNlckJ1aWxkZXIodGhpcy5nZXRUeXBlUGFyc2VyKGVudHJ5Lm9pZCkpO1xuICAgICAgICBjb25zdCBhcnJheVJhbmdlUGFyc2VyID0gYXJyYXlQYXJzZXJCdWlsZGVyKHJhbmdlUGFyc2VyKTtcblxuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoZW50cnkucmFuZ2VPaWQsIHJhbmdlUGFyc2VyKTtcbiAgICAgICAgaWYgKCEgZW50cnkuYXJyYXlSYW5nZU9pZCkgY29udGludWU7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChlbnRyeS5hcnJheVJhbmdlT2lkLCBhcnJheVJhbmdlUGFyc2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgcGFyc2VycyBmb3Igbm9ybWFsIG9yIGVudW0gZGF0YSB0eXBlc1xuICAgIGNvbnN0IHBhcnNlciA9IHZhbHVlID0+IGRhdGFUeXBlLnBhcnNlKHZhbHVlKTtcbiAgICBjb25zdCBhcnJheVBhcnNlciA9IGFycmF5UGFyc2VyQnVpbGRlcihwYXJzZXIpO1xuXG4gICAgLy8gU2V0IGVudW0gcGFyc2Vyc1xuICAgIGlmIChkYXRhVHlwZS5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2VudW0nKSB7XG4gICAgICB0aGlzLmVudW1PaWRzLm9pZHMuZm9yRWFjaChvaWQgPT4ge1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQob2lkLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVudW1PaWRzLmFycmF5T2lkcy5mb3JFYWNoKGFycmF5T2lkID0+IHtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGFycmF5T2lkLCBhcnJheVBhcnNlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZXQgcGFyc2VycyBmb3Igbm9ybWFsIGRhdGEgdHlwZXNcbiAgICBkYXRhVHlwZS50eXBlcy5wb3N0Z3Jlcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgaWYgKCEgdGhpcy5uYW1lT2lkTWFwW25hbWVdKSByZXR1cm47XG4gICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQodGhpcy5uYW1lT2lkTWFwW25hbWVdLm9pZCwgcGFyc2VyKTtcblxuICAgICAgaWYgKCEgdGhpcy5uYW1lT2lkTWFwW25hbWVdLmFycmF5T2lkKSByZXR1cm47XG4gICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQodGhpcy5uYW1lT2lkTWFwW25hbWVdLmFycmF5T2lkLCBhcnJheVBhcnNlcik7XG4gICAgfSk7XG4gIH1cblxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHRoaXMub2lkUGFyc2VyTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0VHlwZVBhcnNlcihvaWQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5vaWRQYXJzZXJNYXAuZ2V0KG9pZCkpIHJldHVybiB0aGlzLm9pZFBhcnNlck1hcC5nZXQob2lkKTtcblxuICAgIHJldHVybiB0aGlzLmxpYi50eXBlcy5nZXRUeXBlUGFyc2VyKG9pZCwgLi4uYXJncyk7XG4gIH1cblxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbmZpZy51c2VyID0gY29uZmlnLnVzZXJuYW1lO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfLnBpY2soY29uZmlnLCBbXG4gICAgICAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ2RhdGFiYXNlJywgJ3BvcnQnXG4gICAgXSk7XG5cbiAgICBjb25uZWN0aW9uQ29uZmlnLnR5cGVzID0ge1xuICAgICAgZ2V0VHlwZVBhcnNlcjogQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFR5cGVQYXJzZXIuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICBfLm1lcmdlKGNvbm5lY3Rpb25Db25maWcsXG4gICAgICAgIF8ucGljayhjb25maWcuZGlhbGVjdE9wdGlvbnMsIFtcbiAgICAgICAgLy8gc2VlIFtodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4zL3N0YXRpYy9ydW50aW1lLWNvbmZpZy1sb2dnaW5nLmh0bWwjR1VDLUFQUExJQ0FUSU9OLU5BTUVdXG4gICAgICAgICAgJ2FwcGxpY2F0aW9uX25hbWUnLFxuICAgICAgICAgIC8vIGNob29zZSB0aGUgU1NMIG1vZGUgd2l0aCB0aGUgUEdTU0xNT0RFIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICAgICAgLy8gb2JqZWN0IGZvcm1hdDogW2h0dHBzOi8vZ2l0aHViLmNvbS9icmlhbmMvbm9kZS1wb3N0Z3Jlcy9ibG9iL2VlMTllNzRmZmE2MzA5YzljNWU4ZTAxNzQ2MjYxYThmNjUxNjYxZjgvbGliL2Nvbm5lY3Rpb24uanMjTDc5XVxuICAgICAgICAgIC8vIHNlZSBhbHNvIFtodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4zL3N0YXRpYy9saWJwcS1zc2wuaHRtbF1cbiAgICAgICAgICAnc3NsJyxcbiAgICAgICAgICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgdmFsdWVzIGFjY2VwdGVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlcixcbiAgICAgICAgICAvLyB5b3UgY2FuIHVzZSBcImF1dG9cIiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGVuY29kaW5nIGZyb20gdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBsb2NhbGUgaW4gdGhlIGNsaWVudCAoTENfQ1RZUEUgZW52aXJvbm1lbnQgdmFyaWFibGUgb24gVW5peCBzeXN0ZW1zKVxuICAgICAgICAgICdjbGllbnRfZW5jb2RpbmcnLFxuICAgICAgICAgIC8vICEhIERPIE5PVCBTRVQgVEhJUyBUTyBUUlVFICEhXG4gICAgICAgICAgLy8gKHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZylcbiAgICAgICAgICAvLyBzZWUgW2h0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvbWVzc2FnZS1pZC9mbGF0L2JjOTU0OWE1MDcwNjA0MDg1MnUyNzYzM2Y0MWliMWU2YjA5ZjgzMzlkODQ1QG1haWwuZ21haWwuY29tI2JjOTU0OWE1MDcwNjA0MDg1MnUyNzYzM2Y0MWliMWU2YjA5ZjgzMzlkODQ1QG1haWwuZ21haWwuY29tXVxuICAgICAgICAgICdiaW5hcnknLFxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGhlbHAgd2l0aCBiYWNrZW5kcyBpbmNvcnJlY3RseSBjb25zaWRlcmluZyBpZGxlIGNsaWVudHMgdG8gYmUgZGVhZCBhbmQgcHJlbWF0dXJlbHkgZGlzY29ubmVjdGluZyB0aGVtLlxuICAgICAgICAgIC8vIHRoaXMgZmVhdHVyZSBoYXMgYmVlbiBhZGRlZCBpbiBwZyBtb2R1bGUgdjYuMC4wLCBjaGVjayBwZy9DSEFOR0VMT0cubWRcbiAgICAgICAgICAna2VlcEFsaXZlJyxcbiAgICAgICAgICAvLyBUaW1lcyBvdXQgcXVlcmllcyBhZnRlciBhIHNldCB0aW1lIGluIG1pbGxpc2Vjb25kcy4gQWRkZWQgaW4gcGcgdjcuM1xuICAgICAgICAgICdzdGF0ZW1lbnRfdGltZW91dCcsXG4gICAgICAgICAgLy8gVGVybWluYXRlIGFueSBzZXNzaW9uIHdpdGggYW4gb3BlbiB0cmFuc2FjdGlvbiB0aGF0IGhhcyBiZWVuIGlkbGUgZm9yIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLiBBZGRlZCBpbiBwZyB2Ny4xNy4wIG9ubHkgc3VwcG9ydGVkIGluIHBvc3RncmVzID49IDEwXG4gICAgICAgICAgJ2lkbGVfaW5fdHJhbnNhY3Rpb25fc2Vzc2lvbl90aW1lb3V0J1xuICAgICAgICBdKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXNwb25kZWQgPSBmYWxzZTtcblxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyB0aGlzLmxpYi5DbGllbnQoY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IHBhcmFtZXRlckhhbmRsZXIgPSBtZXNzYWdlID0+IHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgICBjYXNlICdzZXJ2ZXJfdmVyc2lvbic6XG4gICAgICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHNlbXZlci5jb2VyY2UobWVzc2FnZS5wYXJhbWV0ZXJWYWx1ZSkudmVyc2lvbjtcbiAgICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIudmFsaWQodmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IHZlcnNpb25cbiAgICAgICAgICAgICAgICA6IHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5ncyc6XG4gICAgICAgICAgICBjb25uZWN0aW9uWydzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3MnXSA9IG1lc3NhZ2UucGFyYW1ldGVyVmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5kSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gdGltZW91dCcpO1xuICAgICAgICBpZiAoIXJlc3BvbmRlZCkge1xuICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25UaW1lZE91dEVycm9yKG5ldyBFcnJvcignQ29ubmVjdGlvbiB0aW1lZCBvdXQnKSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZXZlciBoZWFyIGZyb20gdGhlIGNsaWVudC5jb25uZWN0KCkgY2FsbGJhY2sgdGhlIGNvbm5lY3Rpb24gdGltZW91dFxuICAgICAgLy8gbm9kZS1wb3N0Z3JlcyBkb2VzIG5vdCB0cmVhdCB0aGlzIGFzIGFuIGVycm9yIHNpbmNlIG5vIGFjdGl2ZSBxdWVyeSB3YXMgZXZlciBlbWl0dGVkXG4gICAgICBjb25uZWN0aW9uLm9uY2UoJ2VuZCcsIGVuZEhhbmRsZXIpO1xuXG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUpIHtcbiAgICAgICAgLy8gUmVjZWl2ZSB2YXJpb3VzIHNlcnZlciBwYXJhbWV0ZXJzIGZvciBmdXJ0aGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uLm9uKCdwYXJhbWV0ZXJTdGF0dXMnLCBwYXJhbWV0ZXJIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGlvbi5jb25uZWN0KGVyciA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcubmF0aXZlKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhcmFtZXRlciBoYW5kbGVyXG4gICAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdwYXJhbWV0ZXJTdGF0dXMnLCBwYXJhbWV0ZXJIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnRUNPTk5SRUZVU0VEJzpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdFTk9URk9VTkQnOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdFSE9TVFVOUkVBQ0gnOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnRUlOVkFMJzpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnY29ubmVjdGlvbiBhY3F1aXJlZCcpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbGV0IHF1ZXJ5ID0gJyc7XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzICE9PSBmYWxzZSAmJiBjb25uZWN0aW9uWydzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3MnXSAhPT0gJ29uJykge1xuICAgICAgLy8gRGlzYWJsZSBlc2NhcGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvaXNzdWVzLzM1NDUgKHNlY3VyaXR5IGlzc3VlKVxuICAgICAgLy8gc2VlIGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9zdGF0aWMvcnVudGltZS1jb25maWctY29tcGF0aWJsZS5odG1sI0dVQy1TVEFOREFSRC1DT05GT1JNSU5HLVNUUklOR1NcbiAgICAgIHF1ZXJ5ICs9ICdTRVQgc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzPW9uOyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBxdWVyeSArPSBgU0VUIGNsaWVudF9taW5fbWVzc2FnZXMgVE8gJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzfTtgO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgIGNvbnN0IGlzWm9uZSA9ICEhbW9tZW50LnR6LnpvbmUodGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSk7XG4gICAgICBpZiAoaXNab25lKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGBTRVQgVElNRSBaT05FICcke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmV9JztgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkgKz0gYFNFVCBUSU1FIFpPTkUgSU5URVJWQUwgJyR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZX0nIEhPVVIgVE8gTUlOVVRFO2A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBhd2FpdCBjb25uZWN0aW9uLnF1ZXJ5KHF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMubmFtZU9pZE1hcCkubGVuZ3RoID09PSAwICYmXG4gICAgICB0aGlzLmVudW1PaWRzLm9pZHMubGVuZ3RoID09PSAwICYmXG4gICAgICB0aGlzLmVudW1PaWRzLmFycmF5T2lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hEeW5hbWljT0lEcyhjb25uZWN0aW9uKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgbGV0IGEgUG9zdGdyZXMgcmVzdGFydCAob3IgZXJyb3IpIHRvIHRha2UgZG93biB0aGUgd2hvbGUgYXBwXG4gICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICBjb25uZWN0aW9uLl9pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIGRlYnVnKGBjb25uZWN0aW9uIGVycm9yICR7ZXJyb3IuY29kZSB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmIChjb25uZWN0aW9uLl9lbmRpbmcpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IEVORElORyBzdGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkoY2FsbGJhY2sgPT4gY29ubmVjdGlvbi5lbmQoY2FsbGJhY2spKSgpO1xuICB9XG5cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAhY29ubmVjdGlvbi5faW52YWxpZCAmJiAhY29ubmVjdGlvbi5fZW5kaW5nO1xuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hEeW5hbWljT0lEcyhjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb247XG4gICAgY29uc3Qgc3VwcG9ydGVkVmVyc2lvbiA9ICc4LjMuMCc7XG5cbiAgICAvLyBDaGVjayBmb3Igc3VwcG9ydGVkIHZlcnNpb25cbiAgICBpZiAoIChkYXRhYmFzZVZlcnNpb24gJiYgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sIHN1cHBvcnRlZFZlcnNpb24pKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgKGNvbm5lY3Rpb24gfHwgdGhpcy5zZXF1ZWxpemUpLnF1ZXJ5KFxuICAgICAgJ1dJVEggcmFuZ2VzIEFTICgnICtcbiAgICAgICcgIFNFTEVDVCBwZ19yYW5nZS5ybmd0eXBpZCwgcGdfdHlwZS50eXBuYW1lIEFTIHJuZ3R5cG5hbWUsJyArXG4gICAgICAnICAgICAgICAgcGdfdHlwZS50eXBhcnJheSBBUyBybmd0eXBhcnJheSwgcGdfcmFuZ2Uucm5nc3VidHlwZScgK1xuICAgICAgJyAgICBGUk9NIHBnX3JhbmdlIExFRlQgT1VURVIgSk9JTiBwZ190eXBlIE9OIHBnX3R5cGUub2lkID0gcGdfcmFuZ2Uucm5ndHlwaWQnICtcbiAgICAgICcpJyArXG4gICAgICAnU0VMRUNUIHBnX3R5cGUudHlwbmFtZSwgcGdfdHlwZS50eXB0eXBlLCBwZ190eXBlLm9pZCwgcGdfdHlwZS50eXBhcnJheSwnICtcbiAgICAgICcgICAgICAgcmFuZ2VzLnJuZ3R5cG5hbWUsIHJhbmdlcy5ybmd0eXBpZCwgcmFuZ2VzLnJuZ3R5cGFycmF5JyArXG4gICAgICAnICBGUk9NIHBnX3R5cGUgTEVGVCBPVVRFUiBKT0lOIHJhbmdlcyBPTiBwZ190eXBlLm9pZCA9IHJhbmdlcy5ybmdzdWJ0eXBlJyArXG4gICAgICAnIFdIRVJFIChwZ190eXBlLnR5cHR5cGUgSU4oXFwnYlxcJywgXFwnZVxcJykpOydcbiAgICApO1xuXG4gICAgbGV0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkocmVzdWx0cykgPyByZXN1bHRzLnBvcCgpIDogcmVzdWx0cztcblxuICAgIC8vIFdoZW4gc2VhcmNoUGF0aCBpcyBwcmVwZW5kZWQgdGhlbiB0d28gc3RhdGVtZW50cyBhcmUgZXhlY3V0ZWQgYW5kIHRoZSByZXN1bHQgaXNcbiAgICAvLyBhbiBhcnJheSBvZiB0aG9zZSB0d28gc3RhdGVtZW50cy4gRmlyc3Qgb25lIGlzIHRoZSBTRVQgc2VhcmNoX3BhdGggYW5kIHNlY29uZCBpc1xuICAgIC8vIHRoZSBTRUxFQ1QgcXVlcnkgcmVzdWx0LlxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIGlmIChyZXN1bHRbMF0uY29tbWFuZCA9PT0gJ1NFVCcpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld05hbWVPaWRNYXAgPSB7fTtcbiAgICBjb25zdCBuZXdFbnVtT2lkcyA9IHsgb2lkczogW10sIGFycmF5T2lkczogW10gfTtcblxuICAgIGZvciAoY29uc3Qgcm93IG9mIHJlc3VsdC5yb3dzKSB7XG4gICAgICAvLyBNYXBwaW5nIGVudW1zLCBoYW5kbGVkIHNlcGFyYXRlZGx5XG4gICAgICBpZiAocm93LnR5cHR5cGUgPT09ICdlJykge1xuICAgICAgICBuZXdFbnVtT2lkcy5vaWRzLnB1c2gocm93Lm9pZCk7XG4gICAgICAgIGlmIChyb3cudHlwYXJyYXkpIG5ld0VudW1PaWRzLmFycmF5T2lkcy5wdXNoKHJvdy50eXBhcnJheSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXBwaW5nIGJhc2UgdHlwZXMgYW5kIHRoZWlyIGFycmF5c1xuICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0gPSB7IG9pZDogcm93Lm9pZCB9O1xuICAgICAgaWYgKHJvdy50eXBhcnJheSkgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0uYXJyYXlPaWQgPSByb3cudHlwYXJyYXk7XG5cbiAgICAgIC8vIE1hcHBpbmcgcmFuZ2VzKG9mIGJhc2UgdHlwZXMpIGFuZCB0aGVpciBhcnJheXNcbiAgICAgIGlmIChyb3cucm5ndHlwaWQpIHtcbiAgICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0ucmFuZ2VPaWQgPSByb3cucm5ndHlwaWQ7XG4gICAgICAgIGlmIChyb3cucm5ndHlwYXJyYXkpIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLmFycmF5UmFuZ2VPaWQgPSByb3cucm5ndHlwYXJyYXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSBhbGwgT0lEIG1hcHBpbmdzLiBBdm9pZHMgdGVtcG9yYXJ5IGVtcHR5IE9JRCBtYXBwaW5ncy5cbiAgICB0aGlzLm5hbWVPaWRNYXAgPSBuZXdOYW1lT2lkTWFwO1xuICAgIHRoaXMuZW51bU9pZHMgPSBuZXdFbnVtT2lkcztcblxuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzLnBvc3RncmVzKTtcbiAgfVxuXG4gIF9jbGVhckR5bmFtaWNPSURzKCkge1xuICAgIHRoaXMubmFtZU9pZE1hcCA9IHt9O1xuICAgIHRoaXMuZW51bU9pZHMgPSB7IG9pZHM6IFtdLCBhcnJheU9pZHM6IFtdIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHdreCA9IHJlcXVpcmUoJ3dreCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUeXBlcyA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHVuZGVmaW5lZCwgJ2h0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjQvc3RhdGljL2RhdGF0eXBlLmh0bWwnKTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB1bnN1cHBvcnRlZCBQb3N0Z3JlcyBvcHRpb25zLCBpLmUuLCBMRU5HVEgsIFVOU0lHTkVEIGFuZCBaRVJPRklMTCwgZm9yIHRoZSBpbnRlZ2VyIGRhdGEgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHlwZSBUaGUgYmFzZSBpbnRlZ2VyIGRhdGEgdHlwZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX2xlbmd0aCB8fCBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCB8fCBkYXRhVHlwZS5fdW5zaWduZWQgfHwgZGF0YVR5cGUuX3plcm9maWxsKSB7XG4gICAgICB3YXJuKGBQb3N0Z3Jlc1NRTCBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggTEVOR1RILCBVTlNJR05FRCBvciBaRVJPRklMTC4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHR5cGVzOlxuICAgKiB7XG4gICAqICAgb2lkczogW29pZF0sXG4gICAqICAgYXJyYXlfb2lkczogW29pZF1cbiAgICogfVxuICAgKlxuICAgKiBAc2VlIG9pZCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9saWIvcHEvYmxvYi9tYXN0ZXIvb2lkL3R5cGVzLmdvXG4gICAqL1xuXG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLnBvc3RncmVzID0gWyd1dWlkJ107XG4gIEJhc2VUeXBlcy5DSURSLnR5cGVzLnBvc3RncmVzID0gWydjaWRyJ107XG4gIEJhc2VUeXBlcy5JTkVULnR5cGVzLnBvc3RncmVzID0gWydpbmV0J107XG4gIEJhc2VUeXBlcy5NQUNBRERSLnR5cGVzLnBvc3RncmVzID0gWydtYWNhZGRyJ107XG4gIEJhc2VUeXBlcy5UU1ZFQ1RPUi50eXBlcy5wb3N0Z3JlcyA9IFsndHN2ZWN0b3InXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMucG9zdGdyZXMgPSBbJ2pzb24nXTtcbiAgQmFzZVR5cGVzLkpTT05CLnR5cGVzLnBvc3RncmVzID0gWydqc29uYiddO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5wb3N0Z3JlcyA9IFsndGltZSddO1xuXG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICctSW5maW5pdHknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmIHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbG93ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsb3dlciA9PT0gJ2luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgPT09ICctaW5maW5pdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3Nhbml0aXplKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdpbmZpbml0eScpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnLWluZmluaXR5Jykge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5wb3N0Z3JlcyA9IFsnZGF0ZSddO1xuXG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLy8gbnVtZXJpY1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5wb3N0Z3JlcyA9IFsnbnVtZXJpYyddO1xuXG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gJ0JZVEVBJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMucG9zdGdyZXMgPSBbJ3ZhcmNoYXInXTtcblxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKCdQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIG9wdGlvbnMuIFBsYWluIGBURVhUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdURVhUJztcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5wb3N0Z3JlcyA9IFsndGV4dCddO1xuXG4gIGNsYXNzIENJVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5DSVRFWFQge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5DSVRFWFQudHlwZXMucG9zdGdyZXMgPSBbJ2NpdGV4dCddO1xuXG4gIGNsYXNzIENIQVIgZXh0ZW5kcyBCYXNlVHlwZXMuQ0hBUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiAnQllURUEnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMucG9zdGdyZXMgPSBbJ2NoYXInLCAnYnBjaGFyJ107XG5cbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnQk9PTEVBTic7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gQml0IGZpZWxkcyBhcmUgcmV0dXJuZWQgYXMgYnVmZmVyc1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBPbmx5IHRha2UgYWN0aW9uIG9uIHZhbGlkIGJvb2xlYW4gc3RyaW5ncy5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ3QnID8gdHJ1ZSA6IHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnZicgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gT25seSB0YWtlIGFjdGlvbiBvbiB2YWxpZCBib29sZWFuIGludGVnZXJzLlxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSA/IHRydWUgOiB2YWx1ZSA9PT0gMCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBCT09MRUFOLnBhcnNlID0gQk9PTEVBTi5wcm90b3R5cGUuX3Nhbml0aXplO1xuXG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLnBvc3RncmVzID0gWydib29sJ107XG5cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnVElNRVNUQU1QIFdJVEggVElNRSBaT05FJztcbiAgICB9XG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gc3VwZXIudmFsaWRhdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJy1JbmZpbml0eSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEhdmFsdWUgJiYgdmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGxvd2VyID09PSAnaW5maW5pdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gJy1pbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMucG9zdGdyZXMgPSBbJ3RpbWVzdGFtcHR6J107XG5cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBpbnQyXG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLnBvc3RncmVzID0gWydpbnQyJ107XG5cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGludDJcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLnBvc3RncmVzID0gWydpbnQyJ107XG5cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBJTlRFR0VSLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfTtcblxuICAvLyBpbnQ0XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLnBvc3RncmVzID0gWydpbnQ0J107XG5cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gaW50OFxuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLnBvc3RncmVzID0gWydpbnQ4J107XG5cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmbG9hdDRcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMucG9zdGdyZXMgPSBbJ2Zsb2F0NCddO1xuXG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZsb2F0OFxuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLnBvc3RncmVzID0gWydmbG9hdDgnXTtcblxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICAvLyBQT1NUR1JFUyBkb2VzIG9ubHkgc3VwcG9ydCBsZW5ndGhzIGFzIHBhcmFtZXRlci5cbiAgICAgIC8vIFZhbHVlcyBiZXR3ZWVuIDEtMjQgcmVzdWx0IGluIFJFQUxcbiAgICAgIC8vIFZhbHVlcyBiZXR3ZWVuIDI1LTUzIHJlc3VsdCBpbiBET1VCTEUgUFJFQ0lTSU9OXG4gICAgICAvLyBJZiBkZWNpbWFscyBhcmUgcHJvdmlkZWQgcmVtb3ZlIHRoZXNlIGFuZCBwcmludCBhIHdhcm5pbmdcbiAgICAgIGlmICh0aGlzLl9kZWNpbWFscykge1xuICAgICAgICB3YXJuKCdQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgd2l0aCBkZWNpbWFscy4gUGxhaW4gYEZMT0FUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kZWNpbWFscyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICB3YXJuKCdQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgdW5zaWduZWQuIGBVTlNJR05FRGAgd2FzIHJlbW92ZWQuJyk7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB6ZXJvZmlsbC4gYFpFUk9GSUxMYCB3YXMgcmVtb3ZlZC4nKTtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSBGTE9BVC5wYXJzZTsgLy8gRmxvYXQgaGFzIG5vIHNlcGFyYXRlIHR5cGUgaW4gUEdcblxuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKCdQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiAoQllURUEpIHdpdGggb3B0aW9ucy4gUGxhaW4gYEJZVEVBYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdCWVRFQSc7XG4gICAgfVxuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICAvLyBieXRlYSBoZXggZm9ybWF0IGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L3N0YXRpYy9kYXRhdHlwZS1iaW5hcnkuaHRtbFxuICAgICAgcmV0dXJuIGBFJ1xcXFxcXFxceCR7aGV4fSdgO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLnBvc3RncmVzID0gWydieXRlYSddO1xuXG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgaWYgKHRoaXMuc3JpZCkge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5zcmlkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnaGV4Jyk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKGIpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuZXNjYXBlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSl9KWA7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfSlgO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5wb3N0Z3JlcyA9IFsnZ2VvbWV0cnknXTtcblxuXG4gIGNsYXNzIEdFT0dSQVBIWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9HUkFQSFkge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9ICdHRU9HUkFQSFknO1xuICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMudHlwZX1gO1xuICAgICAgICBpZiAodGhpcy5zcmlkKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLnNyaWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBjb25zdCBiID0gQnVmZmVyLmZyb20odmFsdWUsICdoZXgnKTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UoYikudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5lc2NhcGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKX0pYDtcbiAgICB9XG4gICAgYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX0pYDtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuR0VPR1JBUEhZLnR5cGVzLnBvc3RncmVzID0gWydnZW9ncmFwaHknXTtcblxuICBsZXQgaHN0b3JlO1xuXG4gIGNsYXNzIEhTVE9SRSBleHRlbmRzIEJhc2VUeXBlcy5IU1RPUkUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIC8vIEFsbCBkYXRhdHlwZSBmaWxlcyBhcmUgbG9hZGVkIGF0IGltcG9ydCAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb2FkIHRoZSBoc3RvcmUgcGFyc2VyIGJlZm9yZSBhIGhzdG9yZSBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZSgnLi9oc3RvcmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3ZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICAvLyBBbGwgZGF0YXR5cGUgZmlsZXMgYXJlIGxvYWRlZCBhdCBpbXBvcnQgLSBtYWtlIHN1cmUgd2UgZG9uJ3QgbG9hZCB0aGUgaHN0b3JlIHBhcnNlciBiZWZvcmUgYSBoc3RvcmUgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoJy4vaHN0b3JlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHN0b3JlLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIHJldHVybiBgJyR7dGhpcy5fdmFsdWUodmFsdWUpfSdgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICAvLyBBbGwgZGF0YXR5cGUgZmlsZXMgYXJlIGxvYWRlZCBhdCBpbXBvcnQgLSBtYWtlIHN1cmUgd2UgZG9uJ3QgbG9hZCB0aGUgaHN0b3JlIHBhcnNlciBiZWZvcmUgYSBoc3RvcmUgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoJy4vaHN0b3JlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHN0b3JlLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBIU1RPUkUucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4gIEJhc2VUeXBlcy5IU1RPUkUudHlwZXMucG9zdGdyZXMgPSBbJ2hzdG9yZSddO1xuXG4gIGNsYXNzIFJBTkdFIGV4dGVuZHMgQmFzZVR5cGVzLlJBTkdFIHtcbiAgICBfdmFsdWUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUluY2x1c2l2aXR5ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgIGNvbnN0IHZhbHVlc1N0cmluZ2lmaWVkID0gdmFsdWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICd2YWx1ZScpKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luY2x1c2l2ZScpKSB7XG4gICAgICAgICAgICB2YWx1ZUluY2x1c2l2aXR5W2luZGV4XSA9IHZhbHVlLmluY2x1c2l2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggXCJ1bmJvdW5kZWRcIiBib3VuZHMgdW5jaGFuZ2VkXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBBcnJheS5tYXAgZG9lcyBub3QgcHJlc2VydmUgZXh0cmEgYXJyYXkgcHJvcGVydGllc1xuICAgICAgdmFsdWVzU3RyaW5naWZpZWQuaW5jbHVzaXZlID0gdmFsdWVJbmNsdXNpdml0eTtcbiAgICAgIHJldHVybiByYW5nZS5zdHJpbmdpZnkodmFsdWVzU3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nOjoke3RoaXMudG9DYXN0VHlwZSgpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlcywgb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGAke29wdGlvbnMuYmluZFBhcmFtKHZhbHVlKX06OiR7dGhpcy50b0Nhc3RUeXBlKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3Jlcy5zdWJ0eXBlc1t0aGlzLl9zdWJ0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICB0b0Nhc3RUeXBlKCkge1xuICAgICAgcmV0dXJuIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3Jlcy5jYXN0VHlwZXNbdGhpcy5fc3VidHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zID0geyBwYXJzZXI6IHZhbCA9PiB2YWwgfSkge1xuICAgICAgcmV0dXJuIHJhbmdlLnBhcnNlKHZhbHVlLCBvcHRpb25zLnBhcnNlcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpO1xuXG4gIFJBTkdFLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuICBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMgPSB7XG4gICAgc3VidHlwZXM6IHtcbiAgICAgIGludGVnZXI6ICdpbnQ0cmFuZ2UnLFxuICAgICAgZGVjaW1hbDogJ251bXJhbmdlJyxcbiAgICAgIGRhdGU6ICd0c3R6cmFuZ2UnLFxuICAgICAgZGF0ZW9ubHk6ICdkYXRlcmFuZ2UnLFxuICAgICAgYmlnaW50OiAnaW50OHJhbmdlJ1xuICAgIH0sXG4gICAgY2FzdFR5cGVzOiB7XG4gICAgICBpbnRlZ2VyOiAnaW50NCcsXG4gICAgICBkZWNpbWFsOiAnbnVtZXJpYycsXG4gICAgICBkYXRlOiAndGltZXN0YW1wdHonLFxuICAgICAgZGF0ZW9ubHk6ICdkYXRlJyxcbiAgICAgIGJpZ2ludDogJ2ludDgnXG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IFdoeSBhcmUgYmFzZSB0eXBlcyBiZWluZyBtYW5pcHVsYXRlZD8/XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX3ZhbHVlID0gZnVuY3Rpb24gX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmluZFBhcmFtICYmIHRoaXMudHlwZSAmJiB0aGlzLnR5cGUuX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuX3ZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMudHlwZS5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUuZXNjYXBlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fc3RyaW5naWZ5ID0gZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgc3RyID0gYEFSUkFZWyR7dGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKS5qb2luKCcsJyl9XWA7XG5cbiAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICBjb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG4gICAgICBsZXQgY2FzdEtleSA9IHRoaXMudG9TcWwoKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSBpbnN0YW5jZW9mIEJhc2VUeXBlcy5FTlVNKSB7XG4gICAgICAgIGNhc3RLZXkgPSBgJHtVdGlscy5hZGRUaWNrcyhcbiAgICAgICAgICBVdGlscy5nZW5lcmF0ZUVudW1OYW1lKG9wdGlvbnMuZmllbGQuTW9kZWwuZ2V0VGFibGVOYW1lKCksIG9wdGlvbnMuZmllbGQuZmllbGROYW1lKSxcbiAgICAgICAgICAnXCInXG4gICAgICAgICkgfVtdYDtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IGA6OiR7Y2FzdEtleX1gO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX2JpbmRQYXJhbSA9IGZ1bmN0aW9uIF9iaW5kUGFyYW0odmFsdWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykpO1xuICB9O1xuXG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMucG9zdGdyZXMgPSBbbnVsbF07XG5cbiAgcmV0dXJuIHtcbiAgICBERUNJTUFMLFxuICAgIEJMT0IsXG4gICAgU1RSSU5HLFxuICAgIENIQVIsXG4gICAgVEVYVCxcbiAgICBDSVRFWFQsXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBCT09MRUFOLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgUkVBTCxcbiAgICAnRE9VQkxFIFBSRUNJU0lPTic6IERPVUJMRSxcbiAgICBGTE9BVCxcbiAgICBHRU9NRVRSWSxcbiAgICBHRU9HUkFQSFksXG4gICAgSFNUT1JFLFxuICAgIFJBTkdFLFxuICAgIEVOVU1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhzdG9yZSA9IHJlcXVpcmUoJ3BnLWhzdG9yZScpKHsgc2FuaXRpemU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGhzdG9yZS5zdHJpbmdpZnkoZGF0YSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGhzdG9yZS5wYXJzZSh2YWx1ZSk7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0Jyk7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5wb3N0Z3JlcztcbmNvbnN0IHsgUG9zdGdyZXNRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi9xdWVyeS1pbnRlcmZhY2UnKTtcblxuY2xhc3MgUG9zdGdyZXNEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgUG9zdGdyZXNRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5cblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gICdERUZBVUxUIFZBTFVFUyc6IHRydWUsXG4gICdFWENFUFRJT04nOiB0cnVlLFxuICAnT04gRFVQTElDQVRFIEtFWSc6IGZhbHNlLFxuICAnT1JERVIgTlVMTFMnOiB0cnVlLFxuICByZXR1cm5WYWx1ZXM6IHtcbiAgICByZXR1cm5pbmc6IHRydWVcbiAgfSxcbiAgYnVsa0RlZmF1bHQ6IHRydWUsXG4gIHNjaGVtYXM6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGxvY2tPZjogdHJ1ZSxcbiAgbG9ja0tleTogdHJ1ZSxcbiAgbG9ja091dGVySm9pbkZhaWx1cmU6IHRydWUsXG4gIHNraXBMb2NrZWQ6IHRydWUsXG4gIGZvclNoYXJlOiAnRk9SIFNIQVJFJyxcbiAgaW5kZXg6IHtcbiAgICBjb25jdXJyZW50bHk6IHRydWUsXG4gICAgdXNpbmc6IDIsXG4gICAgd2hlcmU6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogdHJ1ZSxcbiAgICBvcGVyYXRvcjogdHJ1ZVxuICB9LFxuICBpbnNlcnRzOiB7XG4gICAgb25Db25mbGljdERvTm90aGluZzogJyBPTiBDT05GTElDVCBETyBOT1RISU5HJyxcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogJyBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUJ1xuICB9LFxuICBOVU1FUklDOiB0cnVlLFxuICBBUlJBWTogdHJ1ZSxcbiAgUkFOR0U6IHRydWUsXG4gIEdFT01FVFJZOiB0cnVlLFxuICBSRUdFWFA6IHRydWUsXG4gIEdFT0dSQVBIWTogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgSlNPTkI6IHRydWUsXG4gIEhTVE9SRTogdHJ1ZSxcbiAgVFNWRUNUT1I6IHRydWUsXG4gIGRlZmVycmFibGVDb25zdHJhaW50czogdHJ1ZSxcbiAgc2VhcmNoUGF0aDogdHJ1ZVxufSk7XG5cblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSAnOS41LjAnO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLm5hbWUgPSAncG9zdGdyZXMnO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBQb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblxubW9kdWxlLmV4cG9ydHMgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXNEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuUG9zdGdyZXNEaWFsZWN0ID0gUG9zdGdyZXNEaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNsYXNzIFBvc3RncmVzUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgc2V0U2VhcmNoUGF0aChzZWFyY2hQYXRoKSB7XG4gICAgcmV0dXJuIGBTRVQgc2VhcmNoX3BhdGggdG8gJHtzZWFyY2hQYXRofTtgO1xuICB9XG5cbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICBkYXRhYmFzZTogdGhpcy5xdW90ZVRhYmxlKGRhdGFiYXNlTmFtZSksXG4gICAgICBlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZyA/IGAgRU5DT0RJTkcgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuZW5jb2RpbmcpfWAgOiAnJyxcbiAgICAgIGNvbGxhdGlvbjogb3B0aW9ucy5jb2xsYXRlID8gYCBMQ19DT0xMQVRFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAgOiAnJyxcbiAgICAgIGN0eXBlOiBvcHRpb25zLmN0eXBlID8gYCBMQ19DVFlQRSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jdHlwZSl9YCA6ICcnLFxuICAgICAgdGVtcGxhdGU6IG9wdGlvbnMudGVtcGxhdGUgPyBgIFRFTVBMQVRFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLnRlbXBsYXRlKX1gIDogJydcbiAgICB9O1xuXG4gICAgcmV0dXJuIGBDUkVBVEUgREFUQUJBU0UgJHt2YWx1ZXMuZGF0YWJhc2V9JHt2YWx1ZXMuZW5jb2Rpbmd9JHt2YWx1ZXMuY29sbGF0aW9ufSR7dmFsdWVzLmN0eXBlfSR7dmFsdWVzLnRlbXBsYXRlfTtgO1xuICB9XG5cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIERBVEFCQVNFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZShkYXRhYmFzZU5hbWUpfTtgO1xuICB9XG5cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IF8uZ2V0KHRoaXMsICdzZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24nLCAwKTtcblxuICAgIGlmIChkYXRhYmFzZVZlcnNpb24gJiYgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sICc5LjIuMCcpKSB7XG4gICAgICByZXR1cm4gYENSRUFURSBTQ0hFTUEgSUYgTk9UIEVYSVNUUyAke3NjaGVtYX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYENSRUFURSBTQ0hFTUEgJHtzY2hlbWF9O2A7XG4gIH1cblxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBgRFJPUCBTQ0hFTUEgSUYgRVhJU1RTICR7c2NoZW1hfSBDQVNDQURFO2A7XG4gIH1cblxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBzY2hlbWFfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YSBXSEVSRSBzY2hlbWFfbmFtZSA8PiAnaW5mb3JtYXRpb25fc2NoZW1hJyBBTkQgc2NoZW1hX25hbWUgIT0gJ3B1YmxpYycgQU5EIHNjaGVtYV9uYW1lICF+IEUnXnBnXyc7XCI7XG4gIH1cblxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuICdTSE9XIFNFUlZFUl9WRVJTSU9OJztcbiAgfVxuXG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy9Qb3N0Z3JlcyA5LjAgZG9lcyBub3Qgc3VwcG9ydCBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUywgOS4xIGFuZCBhYm92ZSBkb1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IF8uZ2V0KHRoaXMsICdzZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24nLCAwKTtcbiAgICBjb25zdCBhdHRyU3RyID0gW107XG4gICAgbGV0IGNvbW1lbnRzID0gJyc7XG4gICAgbGV0IGNvbHVtbkNvbW1lbnRzID0gJyc7XG5cbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMuY29tbWVudCAmJiB0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tbWVudHMgKz0gYDsgQ09NTUVOVCBPTiBUQUJMRSAke3F1b3RlZFRhYmxlfSBJUyAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29tbWVudCl9YDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgcXVvdGVkQXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpO1xuICAgICAgY29uc3QgaSA9IGF0dHJpYnV0ZXNbYXR0cl0uaW5kZXhPZignQ09NTUVOVCAnKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAvLyBNb3ZlIGNvbW1lbnQgdG8gYSBzZXBhcmF0ZSBxdWVyeVxuICAgICAgICBjb25zdCBlc2NhcGVkQ29tbWVudFRleHQgPSB0aGlzLmVzY2FwZShhdHRyaWJ1dGVzW2F0dHJdLnN1YnN0cmluZyhpICsgOCkpO1xuICAgICAgICBjb2x1bW5Db21tZW50cyArPSBgOyBDT01NRU5UIE9OIENPTFVNTiAke3F1b3RlZFRhYmxlfS4ke3F1b3RlZEF0dHJ9IElTICR7ZXNjYXBlZENvbW1lbnRUZXh0fWA7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBhdHRyaWJ1dGVzW2F0dHJdLnN1YnN0cmluZygwLCBpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHIsIGF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgYXR0clN0ci5wdXNoKGAke3F1b3RlZEF0dHJ9ICR7ZGF0YVR5cGV9YCk7XG4gICAgfVxuXG5cbiAgICBsZXQgYXR0cmlidXRlc0NsYXVzZSA9IGF0dHJTdHIuam9pbignLCAnKTtcblxuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIGNvbHVtbnMgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHBrcyA9IF8ucmVkdWNlKGF0dHJpYnV0ZXMsIChhY2MsIGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSkuam9pbignLCcpO1xuXG4gICAgaWYgKHBrcy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFBSSU1BUlkgS0VZICgke3Brc30pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYENSRUFURSBUQUJMRSAke2RhdGFiYXNlVmVyc2lvbiA9PT0gMCB8fCBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgJzkuMS4wJykgPyAnSUYgTk9UIEVYSVNUUyAnIDogJyd9JHtxdW90ZWRUYWJsZX0gKCR7YXR0cmlidXRlc0NsYXVzZX0pJHtjb21tZW50c30ke2NvbHVtbkNvbW1lbnRzfTtgO1xuICB9XG5cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSR7b3B0aW9ucy5jYXNjYWRlID8gJyBDQVNDQURFJyA6ICcnfTtgO1xuICB9XG5cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCB0YWJsZV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBXSEVSRSB0YWJsZV9zY2hlbWEgPSAncHVibGljJyBBTkQgdGFibGVfdHlwZSBMSUtFICclVEFCTEUnIEFORCB0YWJsZV9uYW1lICE9ICdzcGF0aWFsX3JlZl9zeXMnO1wiO1xuICB9XG5cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgaWYgKCFzY2hlbWEpIHNjaGVtYSA9ICdwdWJsaWMnO1xuXG4gICAgcmV0dXJuICdTRUxFQ1QgJyArXG4gICAgICAncGsuY29uc3RyYWludF90eXBlIGFzIFwiQ29uc3RyYWludFwiLCcgK1xuICAgICAgJ2MuY29sdW1uX25hbWUgYXMgXCJGaWVsZFwiLCAnICtcbiAgICAgICdjLmNvbHVtbl9kZWZhdWx0IGFzIFwiRGVmYXVsdFwiLCcgK1xuICAgICAgJ2MuaXNfbnVsbGFibGUgYXMgXCJOdWxsXCIsICcgK1xuICAgICAgJyhDQVNFIFdIRU4gYy51ZHRfbmFtZSA9IFxcJ2hzdG9yZVxcJyBUSEVOIGMudWR0X25hbWUgRUxTRSBjLmRhdGFfdHlwZSBFTkQpIHx8IChDQVNFIFdIRU4gYy5jaGFyYWN0ZXJfbWF4aW11bV9sZW5ndGggSVMgTk9UIE5VTEwgVEhFTiBcXCcoXFwnIHx8IGMuY2hhcmFjdGVyX21heGltdW1fbGVuZ3RoIHx8IFxcJylcXCcgRUxTRSBcXCdcXCcgRU5EKSBhcyBcIlR5cGVcIiwgJyArXG4gICAgICAnKFNFTEVDVCBhcnJheV9hZ2coZS5lbnVtbGFiZWwpIEZST00gcGdfY2F0YWxvZy5wZ190eXBlIHQgSk9JTiBwZ19jYXRhbG9nLnBnX2VudW0gZSBPTiB0Lm9pZD1lLmVudW10eXBpZCBXSEVSRSB0LnR5cG5hbWU9Yy51ZHRfbmFtZSkgQVMgXCJzcGVjaWFsXCIsICcgK1xuICAgICAgJyhTRUxFQ1QgcGdkLmRlc2NyaXB0aW9uIEZST00gcGdfY2F0YWxvZy5wZ19zdGF0aW9fYWxsX3RhYmxlcyBBUyBzdCBJTk5FUiBKT0lOIHBnX2NhdGFsb2cucGdfZGVzY3JpcHRpb24gcGdkIG9uIChwZ2Qub2Jqb2lkPXN0LnJlbGlkKSBXSEVSRSBjLm9yZGluYWxfcG9zaXRpb249cGdkLm9ianN1YmlkIEFORCBjLnRhYmxlX25hbWU9c3QucmVsbmFtZSkgQVMgXCJDb21tZW50XCIgJyArXG4gICAgICAnRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyBjICcgK1xuICAgICAgJ0xFRlQgSk9JTiAoU0VMRUNUIHRjLnRhYmxlX3NjaGVtYSwgdGMudGFibGVfbmFtZSwgJyArXG4gICAgICAnY3UuY29sdW1uX25hbWUsIHRjLmNvbnN0cmFpbnRfdHlwZSAnICtcbiAgICAgICdGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5UQUJMRV9DT05TVFJBSU5UUyB0YyAnICtcbiAgICAgICdKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5LRVlfQ09MVU1OX1VTQUdFICBjdSAnICtcbiAgICAgICdPTiB0Yy50YWJsZV9zY2hlbWE9Y3UudGFibGVfc2NoZW1hIGFuZCB0Yy50YWJsZV9uYW1lPWN1LnRhYmxlX25hbWUgJyArXG4gICAgICAnYW5kIHRjLmNvbnN0cmFpbnRfbmFtZT1jdS5jb25zdHJhaW50X25hbWUgJyArXG4gICAgICAnYW5kIHRjLmNvbnN0cmFpbnRfdHlwZT1cXCdQUklNQVJZIEtFWVxcJykgcGsgJyArXG4gICAgICAnT04gcGsudGFibGVfc2NoZW1hPWMudGFibGVfc2NoZW1hICcgK1xuICAgICAgJ0FORCBway50YWJsZV9uYW1lPWMudGFibGVfbmFtZSAnICtcbiAgICAgICdBTkQgcGsuY29sdW1uX25hbWU9Yy5jb2x1bW5fbmFtZSAnICtcbiAgICAgIGBXSEVSRSBjLnRhYmxlX25hbWUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9IEFORCBjLnRhYmxlX3NjaGVtYSA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hKX0gYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBzdGF0bWVtZW50IGlzIGpzb24gZnVuY3Rpb24gb3Igc2ltcGxlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gIHN0bXQgIFRoZSBzdGF0ZW1lbnQgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgIHRydWUgaWYgdGhlIGdpdmVuIHN0YXRlbWVudCBpcyBqc29uIGZ1bmN0aW9uXG4gICAqIEB0aHJvd3MgIHtFcnJvcn0gICAgICAgICB0aHJvdyBpZiB0aGUgc3RhdGVtZW50IGxvb2tzIGxpa2UganNvbiBmdW5jdGlvbiBidXQgaGFzIGludmFsaWQgdG9rZW5cbiAgICovXG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9zdGF0aWMvZnVuY3Rpb25zLWpzb24uaHRtbFxuICAgIGNvbnN0IGpzb25GdW5jdGlvblJlZ2V4ID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG4gICAgY29uc3QganNvbk9wZXJhdG9yUmVnZXggPSAvXlxccyooLT4+P3wjPj4/fEA+fDxAfFxcP1t8Jl0/fFxcfHsyfXwjLSkvaTtcbiAgICBjb25zdCB0b2tlbkNhcHR1cmVSZWdleCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcblxuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IGpzb25GdW5jdGlvblJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKCcoJyk7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBqc29uT3BlcmF0b3JSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gdG9rZW5DYXB0dXJlUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJygnKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJyknKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJzsnKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGludmFsaWQganNvbiBzdGF0ZW1lbnRcbiAgICBoYXNJbnZhbGlkVG9rZW4gfD0gb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHM7XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiBoYXNJbnZhbGlkVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0cnVlIGlmIHRoZSBzdGF0ZW1lbnQgaGFzIHZhbGlkIGpzb24gZnVuY3Rpb25cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG5cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgLy8gUGFyc2UgbmVzdGVkIG9iamVjdFxuICAgICAgaWYgKHNtdGguY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChzbXRoLmNvbmRpdGlvbnMpLm1hcChjb25kaXRpb24gPT5cbiAgICAgICAgICBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKCcgQU5EICcpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBsZXQgc3RyO1xuXG4gICAgICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgY29uZGl0aW9ucyB1c2luZyB0aGUgcG9zdGdyZXMganNvbiBzeW50YXhcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHNtdGgucGF0aCkpIHtcbiAgICAgICAgICBzdHIgPSBzbXRoLnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxzbyBzdXBwb3J0IGpzb24gcHJvcGVydHkgYWNjZXNzb3JzXG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBfLnRvUGF0aChzbXRoLnBhdGgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhdGhzLnNoaWZ0KCk7XG4gICAgICAgICAgc3RyID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KCcgPSAlcycsIHRoaXMuZXNjYXBlKHNtdGgudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2QuY2FsbCh0aGlzLCBzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG5cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgYXR0cmlidXRlKSB7XG4gICAgY29uc3QgZGJEYXRhVHlwZSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCB7IGNvbnRleHQ6ICdhZGRDb2x1bW4nLCB0YWJsZSwga2V5IH0pO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlLnR5cGUgfHwgYXR0cmlidXRlO1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZSwga2V5LCBkYkRhdGFUeXBlKTtcbiAgICBjb25zdCBxdW90ZWRLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZSkpO1xuXG4gICAgbGV0IHF1ZXJ5ID0gYEFMVEVSIFRBQkxFICR7cXVvdGVkVGFibGV9IEFERCBDT0xVTU4gJHtxdW90ZWRLZXl9ICR7ZGVmaW5pdGlvbn07YDtcblxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucGdFbnVtKHRhYmxlLCBrZXksIGRhdGFUeXBlKSArIHF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUudHlwZSAmJiBkYXRhVHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5wZ0VudW0odGFibGUsIGtleSwgZGF0YVR5cGUudHlwZSkgKyBxdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSkpO1xuICAgIGNvbnN0IHF1b3RlZEF0dHJpYnV0ZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfSBEUk9QIENPTFVNTiAke3F1b3RlZEF0dHJpYnV0ZU5hbWV9O2A7XG4gIH1cblxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHN1YlF1ZXJ5ID0+IGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBBTFRFUiBDT0xVTU4gJHtzdWJRdWVyeX07YDtcbiAgICBjb25zdCBzcWwgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgbGV0IGF0dHJTcWwgPSAnJztcblxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ05PVCBOVUxMJykpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gU0VUIE5PVCBOVUxMYCk7XG5cbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgnTk9UIE5VTEwnLCAnJykudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IERST1AgTk9UIE5VTExgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ0RFRkFVTFQnKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBTRVQgREVGQVVMVCAke2RlZmluaXRpb24ubWF0Y2goL0RFRkFVTFQgKFteO10rKS8pWzFdfWApO1xuXG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLyhERUZBVUxUW147XSspLywgJycpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBEUk9QIERFRkFVTFRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0uc3RhcnRzV2l0aCgnRU5VTSgnKSkge1xuICAgICAgICBhdHRyU3FsICs9IHRoaXMucGdFbnVtKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoL15FTlVNXFwoLitcXCkvLCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCB7IHNjaGVtYTogZmFsc2UgfSkpO1xuICAgICAgICBkZWZpbml0aW9uICs9IGAgVVNJTkcgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9Ojoke3RoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5tYXRjaCgvVU5JUVVFOyokLykpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvVU5JUVVFOyokLywgJycpO1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGBBREQgVU5JUVVFICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSlgKS5yZXBsYWNlKCdBTFRFUiBDT0xVTU4nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCAnJyk7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYEFERCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pICR7ZGVmaW5pdGlvbn1gKS5yZXBsYWNlKCdBTFRFUiBDT0xVTU4nLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBUWVBFICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cblxuICAgICAgc3FsLnB1c2goYXR0clNxbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxbC5qb2luKCcnKTtcbiAgfVxuXG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuXG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJTdHJpbmcucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyQmVmb3JlKX0gVE8gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFTkFNRSBDT0xVTU4gJHthdHRyU3RyaW5nLmpvaW4oJywgJyl9O2A7XG4gIH1cblxuICBmbihmbk5hbWUsIHRhYmxlTmFtZSwgcGFyYW1ldGVycywgYm9keSwgcmV0dXJucywgbGFuZ3VhZ2UpIHtcbiAgICBmbk5hbWUgPSBmbk5hbWUgfHwgJ3Rlc3RmdW5jJztcbiAgICBsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICdwbHBnc3FsJztcbiAgICByZXR1cm5zID0gcmV0dXJucyA/IGBSRVRVUk5TICR7cmV0dXJuc31gIDogJyc7XG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwgJyc7XG5cbiAgICByZXR1cm4gYENSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OIHBnX3RlbXAuJHtmbk5hbWV9KCR7cGFyYW1ldGVyc30pICR7cmV0dXJuc30gQVMgJGZ1bmMkIEJFR0lOICR7Ym9keX0gRU5EOyAkZnVuYyQgTEFOR1VBR0UgJHtsYW5ndWFnZX07IFNFTEVDVCAqIEZST00gcGdfdGVtcC4ke2ZuTmFtZX0oKTtgO1xuICB9XG5cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGBUUlVOQ0FURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zLnJlc3RhcnRJZGVudGl0eSA/ICcgUkVTVEFSVCBJREVOVElUWScgOiAnJyxcbiAgICAgIG9wdGlvbnMuY2FzY2FkZSA/ICcgQ0FTQ0FERScgOiAnJ1xuICAgIF0uam9pbignJyk7XG4gIH1cblxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCA/IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX1gIDogJyc7XG4gICAgbGV0IHByaW1hcnlLZXlzID0gJyc7XG4gICAgbGV0IHByaW1hcnlLZXlzU2VsZWN0aW9uID0gJyc7XG5cbiAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYCBXSEVSRSAke3doZXJlQ2xhdXNlfWA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgTElNSVQgZGVsZXRlIHdpdGhvdXQgYSBtb2RlbC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGtzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKHBrID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrLmZpZWxkKSkuam9pbignLCcpO1xuXG4gICAgICBwcmltYXJ5S2V5cyA9IG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCA+IDEgPyBgKCR7cGtzfSlgIDogcGtzO1xuICAgICAgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSBwa3M7XG5cbiAgICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0YWJsZX0gV0hFUkUgJHtwcmltYXJ5S2V5c30gSU4gKFNFTEVDVCAke3ByaW1hcnlLZXlzU2VsZWN0aW9ufSBGUk9NICR7dGFibGV9JHt3aGVyZUNsYXVzZX0ke2xpbWl0fSlgO1xuICAgIH1cbiAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGFibGV9JHt3aGVyZUNsYXVzZX1gO1xuICB9XG5cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBsZXQgc2NoZW1hSm9pbiA9ICcnO1xuICAgIGxldCBzY2hlbWFXaGVyZSA9ICcnO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1hSm9pbiA9ICcsIHBnX25hbWVzcGFjZSBzJztcbiAgICAgIHNjaGVtYVdoZXJlID0gYCBBTkQgcy5vaWQgPSB0LnJlbG5hbWVzcGFjZSBBTkQgcy5uc3BuYW1lID0gJyR7dGFibGVOYW1lLnNjaGVtYX0nYDtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBBUkNBTkUhXG4gICAgcmV0dXJuICdTRUxFQ1QgaS5yZWxuYW1lIEFTIG5hbWUsIGl4LmluZGlzcHJpbWFyeSBBUyBwcmltYXJ5LCBpeC5pbmRpc3VuaXF1ZSBBUyB1bmlxdWUsIGl4LmluZGtleSBBUyBpbmRrZXksICcgK1xuICAgICAgJ2FycmF5X2FnZyhhLmF0dG51bSkgYXMgY29sdW1uX2luZGV4ZXMsIGFycmF5X2FnZyhhLmF0dG5hbWUpIEFTIGNvbHVtbl9uYW1lcywgcGdfZ2V0X2luZGV4ZGVmKGl4LmluZGV4cmVsaWQpICcgK1xuICAgICAgYEFTIGRlZmluaXRpb24gRlJPTSBwZ19jbGFzcyB0LCBwZ19jbGFzcyBpLCBwZ19pbmRleCBpeCwgcGdfYXR0cmlidXRlIGEke3NjaGVtYUpvaW59IGAgK1xuICAgICAgJ1dIRVJFIHQub2lkID0gaXguaW5kcmVsaWQgQU5EIGkub2lkID0gaXguaW5kZXhyZWxpZCBBTkQgYS5hdHRyZWxpZCA9IHQub2lkIEFORCAnICtcbiAgICAgIGB0LnJlbGtpbmQgPSAncicgYW5kIHQucmVsbmFtZSA9ICcke3RhYmxlTmFtZX0nJHtzY2hlbWFXaGVyZX0gYCArXG4gICAgICAnR1JPVVAgQlkgaS5yZWxuYW1lLCBpeC5pbmRleHJlbGlkLCBpeC5pbmRpc3ByaW1hcnksIGl4LmluZGlzdW5pcXVlLCBpeC5pbmRrZXkgT1JERVIgQlkgaS5yZWxuYW1lOyc7XG4gIH1cblxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICAvL1Bvc3RncmVzIGNvbnZlcnRzIGNhbWVsQ2FzZWQgYWxpYXMgdG8gbG93ZXJjYXNlIHVubGVzcyBxdW90ZWRcbiAgICByZXR1cm4gW1xuICAgICAgJ1NFTEVDVCBjb25zdHJhaW50X2NhdGFsb2cgQVMgXCJjb25zdHJhaW50Q2F0YWxvZ1wiLCcsXG4gICAgICAnY29uc3RyYWludF9zY2hlbWEgQVMgXCJjb25zdHJhaW50U2NoZW1hXCIsJyxcbiAgICAgICdjb25zdHJhaW50X25hbWUgQVMgXCJjb25zdHJhaW50TmFtZVwiLCcsXG4gICAgICAndGFibGVfY2F0YWxvZyBBUyBcInRhYmxlQ2F0YWxvZ1wiLCcsXG4gICAgICAndGFibGVfc2NoZW1hIEFTIFwidGFibGVTY2hlbWFcIiwnLFxuICAgICAgJ3RhYmxlX25hbWUgQVMgXCJ0YWJsZU5hbWVcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfdHlwZSBBUyBcImNvbnN0cmFpbnRUeXBlXCIsJyxcbiAgICAgICdpc19kZWZlcnJhYmxlIEFTIFwiaXNEZWZlcnJhYmxlXCIsJyxcbiAgICAgICdpbml0aWFsbHlfZGVmZXJyZWQgQVMgXCJpbml0aWFsbHlEZWZlcnJlZFwiJyxcbiAgICAgICdmcm9tIElORk9STUFUSU9OX1NDSEVNQS50YWJsZV9jb25zdHJhaW50cycsXG4gICAgICBgV0hFUkUgdGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9JztgXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcblxuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oJ18nKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYERST1AgSU5ERVggSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSl9YDtcbiAgfVxuXG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMpIHtcbiAgICBsZXQgZnJhZ21lbnQgPSAnJztcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGlmIChvcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9ICcgTElNSVQgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgZnJhZ21lbnQgKz0gJyBPRkZTRVQgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKFxuICAgICAgYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fFxuICAgICAgYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgYXR0cmlidXRlLnR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNXG4gICAgKSB7XG4gICAgICBjb25zdCBlbnVtVHlwZSA9IGF0dHJpYnV0ZS50eXBlLnR5cGUgfHwgYXR0cmlidXRlLnR5cGU7XG4gICAgICBsZXQgdmFsdWVzID0gYXR0cmlidXRlLnZhbHVlcztcblxuICAgICAgaWYgKGVudW1UeXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBlbnVtVHlwZS52YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykgJiYgdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHlwZSA9IGBFTlVNKCR7dmFsdWVzLm1hcCh2YWx1ZSA9PiB0aGlzLmVzY2FwZSh2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZKSB7XG4gICAgICAgICAgdHlwZSArPSAnW10nO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlcyBmb3IgRU5VTSBoYXZlbid0IGJlZW4gZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgfVxuXG4gICAgbGV0IHNxbCA9IHR5cGUudG9TdHJpbmcoKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCAnYWxsb3dOdWxsJykgJiYgIWF0dHJpYnV0ZS5hbGxvd051bGwpIHtcbiAgICAgIHNxbCArPSAnIE5PVCBOVUxMJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudElkZW50aXR5KSB7XG4gICAgICAgIHNxbCArPSAnIEdFTkVSQVRFRCBCWSBERUZBVUxUIEFTIElERU5USVRZJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxbCArPSAnIFNFUklBTCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgc3FsICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUsIGF0dHJpYnV0ZSl9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgc3FsICs9ICcgVU5JUVVFJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHNxbCArPSAnIFBSSU1BUlkgS0VZJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGxldCByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpO1xuICAgICAgbGV0IHNjaGVtYTtcblxuICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKCFhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCB8fCB0eXBlb2YgYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgPT0gJ3N0cmluZycpXG4gICAgICAgICYmIG9wdGlvbnMudGFibGVcbiAgICAgICAgJiYgb3B0aW9ucy50YWJsZS5zY2hlbWFcbiAgICAgICkge1xuICAgICAgICBzY2hlbWEgPSBvcHRpb25zLnRhYmxlLnNjaGVtYTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEoe1xuICAgICAgICAgIHRhYmxlTmFtZTogcmVmZXJlbmNlc1RhYmxlLFxuICAgICAgICAgIF9zY2hlbWE6IHNjaGVtYVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZWZlcmVuY2VzS2V5O1xuXG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcignaWQnKTtcbiAgICAgIH1cblxuICAgICAgc3FsICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNUYWJsZX0gKCR7cmVmZXJlbmNlc0tleX0pYDtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICBzcWwgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlKSB7XG4gICAgICAgIHNxbCArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5kZWZlcnJhYmxlKSB7XG4gICAgICAgIHNxbCArPSBgICR7YXR0cmlidXRlLnJlZmVyZW5jZXMuZGVmZXJyYWJsZS50b1N0cmluZyh0aGlzKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCAmJiB0eXBlb2YgYXR0cmlidXRlLmNvbW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5jb250ZXh0ID09PSAnYWRkQ29sdW1uJyB8fCBvcHRpb25zLmNvbnRleHQgPT09ICdjaGFuZ2VDb2x1bW4nKSkge1xuICAgICAgICBjb25zdCBxdW90ZWRBdHRyID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5rZXkpO1xuICAgICAgICBjb25zdCBlc2NhcGVkQ29tbWVudFRleHQgPSB0aGlzLmVzY2FwZShhdHRyaWJ1dGUuY29tbWVudCk7XG4gICAgICAgIHNxbCArPSBgOyBDT01NRU5UIE9OIENPTFVNTiAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlKX0uJHtxdW90ZWRBdHRyfSBJUyAke2VzY2FwZWRDb21tZW50VGV4dH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIGNyZWF0ZVRhYmxlIGV2ZW50IHdoaWNoIGRvZXMgaXQncyBvd24gcGFyc2luZ1xuICAgICAgICAvLyBUT0RPOiBjZW50cmFsaXplIGNyZWF0aW9uIG9mIGNvbW1lbnQgc3RhdGVtZW50cyBoZXJlXG4gICAgICAgIHNxbCArPSBgIENPTU1FTlQgJHthdHRyaWJ1dGUuY29tbWVudH1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICBkZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRlZmVycmFibGUudG9TdHJpbmcodGhpcyk7XG4gIH1cblxuICBzZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgdHlwZSkge1xuICAgIGxldCBjb2x1bW5GcmFnbWVudCA9ICdBTEwnO1xuXG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgIGNvbHVtbkZyYWdtZW50ID0gY29sdW1ucy5tYXAoY29sdW1uID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbikpLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBTRVQgQ09OU1RSQUlOVFMgJHtjb2x1bW5GcmFnbWVudH0gJHt0eXBlfWA7XG4gIH1cblxuICBzZXREZWZlcnJlZFF1ZXJ5KGNvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgJ0RFRkVSUkVEJyk7XG4gIH1cblxuICBzZXRJbW1lZGlhdGVRdWVyeShjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsICdJTU1FRElBVEUnKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgeyBrZXksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNyZWF0ZVRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgZXZlbnRUeXBlLCBmaXJlT25TcGVjLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCBvcHRpb25zQXJyYXkpIHtcbiAgICBjb25zdCBkZWNvZGVkRXZlbnRUeXBlID0gdGhpcy5kZWNvZGVUcmlnZ2VyRXZlbnRUeXBlKGV2ZW50VHlwZSk7XG4gICAgY29uc3QgZXZlbnRTcGVjID0gdGhpcy5leHBhbmRUcmlnZ2VyRXZlbnRTcGVjKGZpcmVPblNwZWMpO1xuICAgIGNvbnN0IGV4cGFuZGVkT3B0aW9ucyA9IHRoaXMuZXhwYW5kT3B0aW9ucyhvcHRpb25zQXJyYXkpO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KGZ1bmN0aW9uUGFyYW1zKTtcblxuICAgIHJldHVybiBgQ1JFQVRFICR7dGhpcy50cmlnZ2VyRXZlbnRUeXBlSXNDb25zdHJhaW50KGV2ZW50VHlwZSl9VFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyaWdnZXJOYW1lKX0gJHtkZWNvZGVkRXZlbnRUeXBlfSAke1xuICAgICAgZXZlbnRTcGVjfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSR7ZXhwYW5kZWRPcHRpb25zID8gYCAke2V4cGFuZGVkT3B0aW9uc31gIDogJyd9IEVYRUNVVEUgUFJPQ0VEVVJFICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pO2A7XG4gIH1cblxuICBkcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIFRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmlnZ2VyTmFtZSl9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFU1RSSUNUO2A7XG4gIH1cblxuICByZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIob2xkVHJpZ2dlck5hbWUpfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRU5BTUUgVE8gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihuZXdUcmlnZ2VyTmFtZSl9O2A7XG4gIH1cblxuICBjcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucykge1xuICAgIGlmICghZnVuY3Rpb25OYW1lIHx8ICFyZXR1cm5UeXBlIHx8ICFsYW5ndWFnZSB8fCAhYm9keSkgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGdW5jdGlvbiBtaXNzaW5nIHNvbWUgcGFyYW1ldGVycy4gRGlkIHlvdSBwYXNzIGZ1bmN0aW9uTmFtZSwgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UgYW5kIGJvZHk/Jyk7XG5cbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIGNvbnN0IHZhcmlhYmxlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy52YXJpYWJsZXMgPyB0aGlzLl9leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdChvcHRpb25zLnZhcmlhYmxlcykgOiAnJztcbiAgICBjb25zdCBleHBhbmRlZE9wdGlvbnNBcnJheSA9IHRoaXMuZXhwYW5kT3B0aW9ucyhvcHRpb25zQXJyYXkpO1xuXG4gICAgY29uc3Qgc3RhdGVtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlID8gJ0NSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OJyA6ICdDUkVBVEUgRlVOQ1RJT04nO1xuXG4gICAgcmV0dXJuIGAke3N0YXRlbWVudH0gJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVUVVJOUyAke3JldHVyblR5cGV9IEFTICRmdW5jJCAke3ZhcmlhYmxlTGlzdH0gQkVHSU4gJHtib2R5fSBFTkQ7ICRmdW5jJCBsYW5ndWFnZSAnJHtsYW5ndWFnZX0nJHtleHBhbmRlZE9wdGlvbnNBcnJheX07YDtcbiAgfVxuXG4gIGRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcykge1xuICAgIGlmICghZnVuY3Rpb25OYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGZ1bmN0aW9uTmFtZScpO1xuICAgIC8vIFJFU1RSSUNUIGlzIChjdXJyZW50bHksIGFzIG9mIDkuMikgZGVmYXVsdCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIHJldHVybiBgRFJPUCBGVU5DVElPTiAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRVNUUklDVDtgO1xuICB9XG5cbiAgcmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSkge1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgcmV0dXJuIGBBTFRFUiBGVU5DVElPTiAke29sZEZ1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRU5BTUUgVE8gJHtuZXdGdW5jdGlvbk5hbWV9O2A7XG4gIH1cblxuICBwZ0VzY2FwZUFuZFF1b3RlKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihVdGlscy5yZW1vdmVUaWNrcyh0aGlzLmVzY2FwZSh2YWwpLCBcIidcIikpO1xuICB9XG5cbiAgX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ19leHBhbmRGdW5jdGlvblBhcmFtTGlzdDogZnVuY3Rpb24gcGFyYW1ldGVycyBhcnJheSByZXF1aXJlZCwgaW5jbHVkaW5nIGFuIGVtcHR5IG9uZSBmb3Igbm8gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1MaXN0ID0gW107XG4gICAgcGFyYW1zLmZvckVhY2goY3VyUGFyYW0gPT4ge1xuICAgICAgY29uc3QgcGFyYW1EZWYgPSBbXTtcbiAgICAgIGlmIChjdXJQYXJhbS50eXBlKSB7XG4gICAgICAgIGlmIChjdXJQYXJhbS5kaXJlY3Rpb24pIHsgcGFyYW1EZWYucHVzaChjdXJQYXJhbS5kaXJlY3Rpb24pOyB9XG4gICAgICAgIGlmIChjdXJQYXJhbS5uYW1lKSB7IHBhcmFtRGVmLnB1c2goY3VyUGFyYW0ubmFtZSk7IH1cbiAgICAgICAgcGFyYW1EZWYucHVzaChjdXJQYXJhbS50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gb3IgdHJpZ2dlciB1c2VkIHdpdGggYSBwYXJhbWV0ZXIgd2l0aG91dCBhbnkgdHlwZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBqb2luZWQgPSBwYXJhbURlZi5qb2luKCcgJyk7XG4gICAgICBpZiAoam9pbmVkKSBwYXJhbUxpc3QucHVzaChqb2luZWQpO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFyYW1MaXN0LmpvaW4oJywgJyk7XG4gIH1cblxuICBfZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3QodmFyaWFibGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhcmlhYmxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0OiBmdW5jdGlvbiB2YXJpYWJsZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYWJsZURlZmluaXRpb25zID0gW107XG4gICAgdmFyaWFibGVzLmZvckVhY2godmFyaWFibGUgPT4ge1xuICAgICAgaWYgKCF2YXJpYWJsZS5uYW1lIHx8ICF2YXJpYWJsZS50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gdmFyaWFibGUgbXVzdCBoYXZlIGEgbmFtZSBhbmQgdHlwZScpO1xuICAgICAgfVxuICAgICAgbGV0IHZhcmlhYmxlRGVmaW5pdGlvbiA9IGBERUNMQVJFICR7dmFyaWFibGUubmFtZX0gJHt2YXJpYWJsZS50eXBlfWA7XG4gICAgICBpZiAodmFyaWFibGUuZGVmYXVsdCkge1xuICAgICAgICB2YXJpYWJsZURlZmluaXRpb24gKz0gYCA6PSAke3ZhcmlhYmxlLmRlZmF1bHR9YDtcbiAgICAgIH1cbiAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbiArPSAnOyc7XG4gICAgICB2YXJpYWJsZURlZmluaXRpb25zLnB1c2godmFyaWFibGVEZWZpbml0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFyaWFibGVEZWZpbml0aW9ucy5qb2luKCcgJyk7XG4gIH1cblxuICBleHBhbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IF8uaXNFbXB0eShvcHRpb25zKSA/XG4gICAgICAnJyA6IG9wdGlvbnMuam9pbignICcpO1xuICB9XG5cbiAgZGVjb2RlVHJpZ2dlckV2ZW50VHlwZShldmVudFNwZWNpZmllcikge1xuICAgIGNvbnN0IEVWRU5UX0RFQ09ERVIgPSB7XG4gICAgICAnYWZ0ZXInOiAnQUZURVInLFxuICAgICAgJ2JlZm9yZSc6ICdCRUZPUkUnLFxuICAgICAgJ2luc3RlYWRfb2YnOiAnSU5TVEVBRCBPRicsXG4gICAgICAnYWZ0ZXJfY29uc3RyYWludCc6ICdBRlRFUidcbiAgICB9O1xuXG4gICAgaWYgKCFFVkVOVF9ERUNPREVSW2V2ZW50U3BlY2lmaWVyXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyaWdnZXIgZXZlbnQgc3BlY2lmaWVkOiAke2V2ZW50U3BlY2lmaWVyfWApO1xuICAgIH1cblxuICAgIHJldHVybiBFVkVOVF9ERUNPREVSW2V2ZW50U3BlY2lmaWVyXTtcbiAgfVxuXG4gIHRyaWdnZXJFdmVudFR5cGVJc0NvbnN0cmFpbnQoZXZlbnRTcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gZXZlbnRTcGVjaWZpZXIgPT09ICdhZnRlcl9jb25zdHJhaW50JyA/ICdDT05TVFJBSU5UICcgOiAnJztcbiAgfVxuXG4gIGV4cGFuZFRyaWdnZXJFdmVudFNwZWMoZmlyZU9uU3BlYykge1xuICAgIGlmIChfLmlzRW1wdHkoZmlyZU9uU3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdGFibGUgY2hhbmdlIGV2ZW50cyBzcGVjaWZpZWQgdG8gdHJpZ2dlciBvbicpO1xuICAgIH1cblxuICAgIHJldHVybiBfLm1hcChmaXJlT25TcGVjLCAoZmlyZVZhbHVlLCBmaXJlS2V5KSA9PiB7XG4gICAgICBjb25zdCBFVkVOVF9NQVAgPSB7XG4gICAgICAgICdpbnNlcnQnOiAnSU5TRVJUJyxcbiAgICAgICAgJ3VwZGF0ZSc6ICdVUERBVEUnLFxuICAgICAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgICAgICd0cnVuY2F0ZSc6ICdUUlVOQ0FURSdcbiAgICAgIH07XG5cbiAgICAgIGlmICghRVZFTlRfTUFQW2ZpcmVWYWx1ZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZVRyaWdnZXJFdmVudFNwZWM6IHVuZGVmaW5lZCB0cmlnZ2VyIGV2ZW50ICR7ZmlyZUtleX1gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGV2ZW50U3BlYyA9IEVWRU5UX01BUFtmaXJlVmFsdWVdO1xuICAgICAgaWYgKGV2ZW50U3BlYyA9PT0gJ1VQREFURScpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlyZVZhbHVlKSAmJiBmaXJlVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV2ZW50U3BlYyArPSBgIE9GICR7ZmlyZVZhbHVlLmpvaW4oJywgJyl9YDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnRTcGVjO1xuICAgIH0pLmpvaW4oJyBPUiAnKTtcbiAgfVxuXG4gIHBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCB0YWJsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBsZXQgZW51bU5hbWUgPSBVdGlscy5hZGRUaWNrcyhVdGlscy5nZW5lcmF0ZUVudW1OYW1lKHRhYmxlRGV0YWlscy50YWJsZU5hbWUsIGF0dHIpLCAnXCInKTtcblxuICAgIC8vIHBnTGlzdEVudW1zIHJlcXVpcmVzIHRoZSBlbnVtIG5hbWUgb25seSwgd2l0aG91dCB0aGUgc2NoZW1hXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1hICE9PSBmYWxzZSAmJiB0YWJsZURldGFpbHMuc2NoZW1hKSB7XG4gICAgICBlbnVtTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlRGV0YWlscy5zY2hlbWEpICsgdGFibGVEZXRhaWxzLmRlbGltaXRlciArIGVudW1OYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBlbnVtTmFtZTtcbiAgfVxuXG4gIHBnTGlzdEVudW1zKHRhYmxlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgZW51bU5hbWUgPSAnJztcbiAgICBjb25zdCB0YWJsZURldGFpbHMgPSB0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICh0YWJsZURldGFpbHMudGFibGVOYW1lICYmIGF0dHJOYW1lKSB7XG4gICAgICBlbnVtTmFtZSA9IGAgQU5EIHQudHlwbmFtZT0ke3RoaXMucGdFbnVtTmFtZSh0YWJsZURldGFpbHMudGFibGVOYW1lLCBhdHRyTmFtZSwgeyBzY2hlbWE6IGZhbHNlIH0pLnJlcGxhY2UoL1wiL2csIFwiJ1wiKX1gO1xuICAgIH1cblxuICAgIHJldHVybiAnU0VMRUNUIHQudHlwbmFtZSBlbnVtX25hbWUsIGFycmF5X2FnZyhlLmVudW1sYWJlbCBPUkRFUiBCWSBlbnVtc29ydG9yZGVyKSBlbnVtX3ZhbHVlIEZST00gcGdfdHlwZSB0ICcgK1xuICAgICAgJ0pPSU4gcGdfZW51bSBlIE9OIHQub2lkID0gZS5lbnVtdHlwaWQgJyArXG4gICAgICAnSk9JTiBwZ19jYXRhbG9nLnBnX25hbWVzcGFjZSBuIE9OIG4ub2lkID0gdC50eXBuYW1lc3BhY2UgJyArXG4gICAgICBgV0hFUkUgbi5uc3BuYW1lID0gJyR7dGFibGVEZXRhaWxzLnNjaGVtYX0nJHtlbnVtTmFtZX0gR1JPVVAgQlkgMWA7XG4gIH1cblxuICBwZ0VudW0odGFibGVOYW1lLCBhdHRyLCBkYXRhVHlwZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0ciwgb3B0aW9ucyk7XG4gICAgbGV0IHZhbHVlcztcblxuICAgIGlmIChkYXRhVHlwZS52YWx1ZXMpIHtcbiAgICAgIHZhbHVlcyA9IGBFTlVNKCR7ZGF0YVR5cGUudmFsdWVzLm1hcCh2YWx1ZSA9PiB0aGlzLmVzY2FwZSh2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcyA9IGRhdGFUeXBlLnRvU3RyaW5nKCkubWF0Y2goL15FTlVNXFwoLitcXCkvKVswXTtcbiAgICB9XG5cbiAgICBsZXQgc3FsID0gYENSRUFURSBUWVBFICR7ZW51bU5hbWV9IEFTICR7dmFsdWVzfTtgO1xuICAgIGlmICghIW9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgc3FsID0gdGhpcy5wZ0VudW1Ecm9wKHRhYmxlTmFtZSwgYXR0cikgKyBzcWw7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICBwZ0VudW1BZGQodGFibGVOYW1lLCBhdHRyLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cik7XG4gICAgbGV0IHNxbCA9IGBBTFRFUiBUWVBFICR7ZW51bU5hbWV9IEFERCBWQUxVRSBgO1xuXG4gICAgaWYgKHNlbXZlci5ndGUodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sICc5LjMuMCcpKSB7XG4gICAgICBzcWwgKz0gJ0lGIE5PVCBFWElTVFMgJztcbiAgICB9XG4gICAgc3FsICs9IHRoaXMuZXNjYXBlKHZhbHVlKTtcblxuICAgIGlmIChvcHRpb25zLmJlZm9yZSkge1xuICAgICAgc3FsICs9IGAgQkVGT1JFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5iZWZvcmUpfWA7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmFmdGVyKSB7XG4gICAgICBzcWwgKz0gYCBBRlRFUiAke3RoaXMuZXNjYXBlKG9wdGlvbnMuYWZ0ZXIpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIHBnRW51bURyb3AodGFibGVOYW1lLCBhdHRyLCBlbnVtTmFtZSkge1xuICAgIGVudW1OYW1lID0gZW51bU5hbWUgfHwgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cik7XG4gICAgcmV0dXJuIGBEUk9QIFRZUEUgSUYgRVhJU1RTICR7ZW51bU5hbWV9OyBgO1xuICB9XG5cbiAgZnJvbUFycmF5KHRleHQpIHtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eey8sICcnKS5yZXBsYWNlKC99JC8sICcnKTtcbiAgICBsZXQgbWF0Y2hlcyA9IHRleHQubWF0Y2goLyhcIig/OlxcXFwufFteXCJcXFxcXFxcXF0pKlwifFteLF0qKSg/OlxccyosXFxzKnxcXHMqJCkvaWcpO1xuXG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIG1hdGNoZXMgPSBtYXRjaGVzLm1hcChtID0+IG0ucmVwbGFjZSgvXCIsJC8sICcnKS5yZXBsYWNlKC8sJC8sICcnKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgJycpKTtcblxuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIGRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHIsIGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKSB7XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJycpO1xuICAgIH1cblxuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnU0VSSUFMJykpIHtcbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnQklHSU5UJykpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdTRVJJQUwnLCAnQklHU0VSSUFMJyk7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnQklHSU5UJywgJycpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnU01BTExJTlQnKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ1NFUklBTCcsICdTTUFMTFNFUklBTCcpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ1NNQUxMSU5UJywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdJTlRFR0VSJywgJycpO1xuICAgICAgfVxuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdOT1QgTlVMTCcsICcnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVR5cGUuc3RhcnRzV2l0aCgnRU5VTSgnKSkge1xuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKC9eRU5VTVxcKC4rXFwpLywgdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cikpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyBhbGwgZm9yZWlnbiBrZXlzIG9mIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFibGVOYW1lICBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiAnU0VMRUNUIGNvbm5hbWUgYXMgY29uc3RyYWludF9uYW1lLCBwZ19jYXRhbG9nLnBnX2dldF9jb25zdHJhaW50ZGVmKHIub2lkLCB0cnVlKSBhcyBjb25kZWYgRlJPTSBwZ19jYXRhbG9nLnBnX2NvbnN0cmFpbnQgciAnICtcbiAgICAgIGBXSEVSRSByLmNvbnJlbGlkID0gKFNFTEVDVCBvaWQgRlJPTSBwZ19jbGFzcyBXSEVSRSByZWxuYW1lID0gJyR7dGFibGVOYW1lfScgTElNSVQgMSkgQU5EIHIuY29udHlwZSA9ICdmJyBPUkRFUiBCWSAxO2A7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgY29tbW9uIFNRTCBwcmVmaXggZm9yIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpIHtcbiAgICByZXR1cm4gJ1NFTEVDVCAnICtcbiAgICAgICdESVNUSU5DVCB0Yy5jb25zdHJhaW50X25hbWUgYXMgY29uc3RyYWludF9uYW1lLCAnICtcbiAgICAgICd0Yy5jb25zdHJhaW50X3NjaGVtYSBhcyBjb25zdHJhaW50X3NjaGVtYSwgJyArXG4gICAgICAndGMuY29uc3RyYWludF9jYXRhbG9nIGFzIGNvbnN0cmFpbnRfY2F0YWxvZywgJyArXG4gICAgICAndGMudGFibGVfbmFtZSBhcyB0YWJsZV9uYW1lLCcgK1xuICAgICAgJ3RjLnRhYmxlX3NjaGVtYSBhcyB0YWJsZV9zY2hlbWEsJyArXG4gICAgICAndGMudGFibGVfY2F0YWxvZyBhcyB0YWJsZV9jYXRhbG9nLCcgK1xuICAgICAgJ2tjdS5jb2x1bW5fbmFtZSBhcyBjb2x1bW5fbmFtZSwnICtcbiAgICAgICdjY3UudGFibGVfc2NoZW1hICBBUyByZWZlcmVuY2VkX3RhYmxlX3NjaGVtYSwnICtcbiAgICAgICdjY3UudGFibGVfY2F0YWxvZyAgQVMgcmVmZXJlbmNlZF90YWJsZV9jYXRhbG9nLCcgK1xuICAgICAgJ2NjdS50YWJsZV9uYW1lICBBUyByZWZlcmVuY2VkX3RhYmxlX25hbWUsJyArXG4gICAgICAnY2N1LmNvbHVtbl9uYW1lIEFTIHJlZmVyZW5jZWRfY29sdW1uX25hbWUgJyArXG4gICAgICAnRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVfY29uc3RyYWludHMgQVMgdGMgJyArXG4gICAgICAnSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEua2V5X2NvbHVtbl91c2FnZSBBUyBrY3UgJyArXG4gICAgICAnT04gdGMuY29uc3RyYWludF9uYW1lID0ga2N1LmNvbnN0cmFpbnRfbmFtZSAnICtcbiAgICAgICdKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5jb25zdHJhaW50X2NvbHVtbl91c2FnZSBBUyBjY3UgJyArXG4gICAgICAnT04gY2N1LmNvbnN0cmFpbnRfbmFtZSA9IHRjLmNvbnN0cmFpbnRfbmFtZSAnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIGFsbCBmb3JlaWduIGtleXMgZGV0YWlscyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBBcyBmb3IgZ2V0Rm9yZWlnbktleXNRdWVyeSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnksIHNvIGFkZCBhIG5ldyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0YWxvZ05hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYU5hbWVcbiAgICovXG4gIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnkodGFibGVOYW1lLCBjYXRhbG9nTmFtZSwgc2NoZW1hTmFtZSkge1xuICAgIHJldHVybiBgJHt0aGlzLl9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KClcbiAgICB9V0hFUkUgY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJyBBTkQgdGMudGFibGVfbmFtZSA9ICcke3RhYmxlTmFtZX0nJHtcbiAgICAgIGNhdGFsb2dOYW1lID8gYCBBTkQgdGMudGFibGVfY2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfSdgIDogJydcbiAgICB9JHtzY2hlbWFOYW1lID8gYCBBTkQgdGMudGFibGVfc2NoZW1hID0gJyR7c2NoZW1hTmFtZX0nYCA6ICcnfWA7XG4gIH1cblxuICBnZXRGb3JlaWduS2V5UmVmZXJlbmNlUXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgIHJldHVybiBgJHt0aGlzLl9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KClcbiAgICB9V0hFUkUgY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJyBBTkQgdGMudGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9JyBBTkQgIGtjdS5jb2x1bW5fbmFtZSA9ICcke2NvbHVtbk5hbWV9JyR7XG4gICAgICBzY2hlbWEgPyBgIEFORCB0Yy50YWJsZV9zY2hlbWEgPSAnJHtzY2hlbWF9J2AgOiAnJ31gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZW1vdmVzIGEgZm9yZWlnbiBrZXkgZnJvbSBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhYmxlTmFtZSAgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZvcmVpZ25LZXkgVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gRFJPUCBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSl9O2A7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb3N0Z3Jlc1F1ZXJ5R2VuZXJhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgdGhhdCBTZXF1ZWxpemUgdXNlcyB0byB0YWxrIHdpdGggUG9zdGdyZXMgZGF0YWJhc2VcbiAqL1xuY2xhc3MgUG9zdGdyZXNRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIEVuc3VyZSBlbnVtIGFuZCB0aGVpciB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgIE5hbWUgb2YgdGFibGUgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIE9iamVjdCByZXByZXNlbnRpbmcgYSBsaXN0IG9mIG5vcm1hbGl6ZWQgdGFibGUgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7TW9kZWx9ICBbbW9kZWxdXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFzeW5jIGVuc3VyZUVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgY29uc3Qga2V5TGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgICBsZXQgc3FsID0gJyc7XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleXNbaV1dO1xuICAgICAgY29uc3QgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fFxuICAgICAgICB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIHR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIC8vQVJSQVkgc3ViIHR5cGUgaXMgRU5VTVxuICAgICAgKSB7XG4gICAgICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdMaXN0RW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGUuZmllbGQgfHwga2V5c1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICAgICAgc3FsLFxuICAgICAgICAgIHsgLi4ub3B0aW9ucywgcGxhaW46IHRydWUsIHJhdzogdHJ1ZSwgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QgfVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHByb21pc2VzID0gW107XG4gICAgbGV0IGVudW1JZHggPSAwO1xuXG4gICAgLy8gVGhpcyBsaXR0bGUgZnVuY3Rpb24gYWxsb3dzIHVzIHRvIHJlLXVzZSB0aGUgc2FtZSBjb2RlIHRoYXQgcHJlcGVuZHMgb3IgYXBwZW5kcyBuZXcgdmFsdWUgdG8gZW51bSBhcnJheVxuICAgIGNvbnN0IGFkZEVudW1WYWx1ZSA9IChmaWVsZCwgdmFsdWUsIHJlbGF0aXZlVmFsdWUsIHBvc2l0aW9uID0gJ2JlZm9yZScsIHNwbGljZVN0YXJ0ID0gcHJvbWlzZXMubGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgIHZhbHVlT3B0aW9ucy5iZWZvcmUgPSBudWxsO1xuICAgICAgdmFsdWVPcHRpb25zLmFmdGVyID0gbnVsbDtcblxuICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgdmFsdWVPcHRpb25zLmFmdGVyID0gcmVsYXRpdmVWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZU9wdGlvbnMuYmVmb3JlID0gcmVsYXRpdmVWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZXMuc3BsaWNlKHNwbGljZVN0YXJ0LCAwLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bUFkZChcbiAgICAgICAgICB0YWJsZU5hbWUsIGZpZWxkLCB2YWx1ZSwgdmFsdWVPcHRpb25zXG4gICAgICAgICksIHZhbHVlT3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleXNbaV1dO1xuICAgICAgY29uc3QgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgY29uc3QgZW51bVR5cGUgPSB0eXBlLnR5cGUgfHwgdHlwZTtcbiAgICAgIGNvbnN0IGZpZWxkID0gYXR0cmlidXRlLmZpZWxkIHx8IGtleXNbaV07XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8XG4gICAgICAgIHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgZW51bVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSAvL0FSUkFZIHN1YiB0eXBlIGlzIEVOVU1cbiAgICAgICkge1xuICAgICAgICAvLyBJZiB0aGUgZW51bSB0eXBlIGRvZXNuJ3QgZXhpc3QgdGhlbiBjcmVhdGUgaXRcbiAgICAgICAgaWYgKCFyZXN1bHRzW2VudW1JZHhdKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW0odGFibGVOYW1lLCBmaWVsZCwgZW51bVR5cGUsIG9wdGlvbnMpLCB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghIXJlc3VsdHNbZW51bUlkeF0gJiYgISFtb2RlbCkge1xuICAgICAgICAgIGNvbnN0IGVudW1WYWxzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocmVzdWx0c1tlbnVtSWR4XS5lbnVtX3ZhbHVlKTtcbiAgICAgICAgICBjb25zdCB2YWxzID0gZW51bVR5cGUudmFsdWVzO1xuXG4gICAgICAgICAgLy8gR29pbmcgdGhyb3VnaCBhbHJlYWR5IGV4aXN0aW5nIHZhbHVlcyBhbGxvd3MgdXMgdG8gbWFrZSBxdWVyaWVzIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlc1xuICAgICAgICAgIC8vIFdlIHdpbGwgcHJlcGVuZCBhbGwgbmV3IHZhbHVlcyBiZXR3ZWVuIHRoZSBvbGQgb25lcywgYnV0IGtlZXAgaW4gbWluZCAtIHdlIGNhbid0IGNoYW5nZSBvcmRlciBvZiBhbHJlYWR5IGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgIC8vIFRoZW4gd2UgYXBwZW5kIHRoZSByZXN0IG9mIG5ldyB2YWx1ZXMgQUZURVIgdGhlIGxhdGVzdCBhbHJlYWR5IGV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgLy8gRS5nLjogWzEsMl0gLT4gWzAsMiwxXSA9PT4gWzEsMCwyXVxuICAgICAgICAgIC8vIEUuZy46IFsxLDIsM10gLT4gWzIsMSwzLDRdID09PiBbMSwyLDMsNF1cbiAgICAgICAgICAvLyBFLmcuOiBbMV0gLT4gWzAsMiwzXSA9PT4gWzEsMCwyLDNdXG4gICAgICAgICAgbGV0IGxhc3RPbGRFbnVtVmFsdWU7XG4gICAgICAgICAgbGV0IHJpZ2h0ZXN0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgICBmb3IgKGxldCBvbGRJbmRleCA9IDA7IG9sZEluZGV4IDwgZW51bVZhbHMubGVuZ3RoOyBvbGRJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbnVtVmFsID0gZW51bVZhbHNbb2xkSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbmV3SWR4ID0gdmFscy5pbmRleE9mKGVudW1WYWwpO1xuICAgICAgICAgICAgbGFzdE9sZEVudW1WYWx1ZSA9IGVudW1WYWw7XG5cbiAgICAgICAgICAgIGlmIChuZXdJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZXNCZWZvcmUgPSB2YWxzLnNsaWNlKDAsIG5ld0lkeCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlc0xlbmd0aCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIHdlIGdvIGluIHJldmVyc2Ugb3JkZXIgc28gd2UgY291bGQgc3RvcCB3aGVuIHdlIG1lZXQgb2xkIHZhbHVlXG4gICAgICAgICAgICBmb3IgKGxldCByZXZlcnNlSWR4ID0gbmV3VmFsdWVzQmVmb3JlLmxlbmd0aCAtIDE7IHJldmVyc2VJZHggPj0gMDsgcmV2ZXJzZUlkeC0tKSB7XG4gICAgICAgICAgICAgIGlmICh+ZW51bVZhbHMuaW5kZXhPZihuZXdWYWx1ZXNCZWZvcmVbcmV2ZXJzZUlkeF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhZGRFbnVtVmFsdWUoZmllbGQsIG5ld1ZhbHVlc0JlZm9yZVtyZXZlcnNlSWR4XSwgbGFzdE9sZEVudW1WYWx1ZSwgJ2JlZm9yZScsIHByb21pc2VzTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgZGV0ZWN0IHRoZSBtb3N0ICdyaWdodCcgcG9zaXRpb24gb2Ygb2xkIHZhbHVlIGluIG5ldyBlbnVtIGFycmF5IHNvIHdlIGNhbiBhcHBlbmQgbmV3IHZhbHVlcyB0byBpdFxuICAgICAgICAgICAgaWYgKG5ld0lkeCA+IHJpZ2h0ZXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgcmlnaHRlc3RQb3NpdGlvbiA9IG5ld0lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdE9sZEVudW1WYWx1ZSAmJiByaWdodGVzdFBvc2l0aW9uIDwgdmFscy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdFbnVtVmFsdWVzID0gdmFscy5zbGljZShyaWdodGVzdFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCByZXZlcnNlSWR4ID0gcmVtYWluaW5nRW51bVZhbHVlcy5sZW5ndGggLSAxOyByZXZlcnNlSWR4ID49IDA7IHJldmVyc2VJZHgtLSkge1xuICAgICAgICAgICAgICBhZGRFbnVtVmFsdWUoZmllbGQsIHJlbWFpbmluZ0VudW1WYWx1ZXNbcmV2ZXJzZUlkeF0sIGxhc3RPbGRFbnVtVmFsdWUsICdhZnRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVudW1JZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21pc2VzXG4gICAgICAucmVkdWNlKGFzeW5jIChwcm9taXNlLCBhc3luY0Z1bmN0aW9uKSA9PiBhd2FpdCBhc3luY0Z1bmN0aW9uKGF3YWl0IHByb21pc2UpLCBQcm9taXNlLnJlc29sdmUoKSk7XG5cbiAgICAvLyBJZiBFTlVNIHByb2Nlc3NlZCwgdGhlbiByZWZyZXNoIE9JRHNcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLl9yZWZyZXNoRHluYW1pY09JRHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVNcbiAgICB9O1xuXG4gICAgLy8gcG9zdGdyZXMgbmVlZHMgc29tZSBzcGVjaWFsIHRyZWF0bWVudCBhcyB0aG9zZSBmaWVsZCBuYW1lcyByZXR1cm5lZCBhcmUgYWxsIGxvd2VyY2FzZVxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgc2FtZSByZXN1bHQgd2l0aCBvdGhlciBkaWFsZWN0cy5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIHF1ZXJ5T3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAoVXRpbHMuY2FtZWxpemVPYmplY3RLZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIHNwZWNpZmllZCBlbnVtIGZyb20gZGF0YWJhc2UgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW51bU5hbWVdICBFbnVtIG5hbWUgdG8gZHJvcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEVudW0oZW51bU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChudWxsLCBudWxsLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRXNjYXBlQW5kUXVvdGUoZW51bU5hbWUpKSxcbiAgICAgIHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYWxsIGVudW1zIGZyb20gZGF0YWJhc2UgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wQWxsRW51bXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgZW51bXMgPSBhd2FpdCB0aGlzLnBnTGlzdEVudW1zKG51bGwsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGVudW1zLm1hcChyZXN1bHQgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AobnVsbCwgbnVsbCwgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VzY2FwZUFuZFF1b3RlKHJlc3VsdC5lbnVtX25hbWUpKSxcbiAgICAgIHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH1cbiAgICApKSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgZW51bXMgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFibGVOYW1lXSAgVGFibGUgd2hvc2UgZW51bSB0byBsaXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHBnTGlzdEVudW1zKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdMaXN0RW51bXModGFibGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsIHBsYWluOiBmYWxzZSwgcmF3OiB0cnVlLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5jZSBwb3N0Z3JlcyBoYXMgYSBzcGVjaWFsIGNhc2UgZm9yIGVudW1zLCB3ZSBzaG91bGQgZHJvcCB0aGUgcmVsYXRlZFxuICAgKiBlbnVtIHR5cGUgd2l0aGluIHRoZSB0YWJsZSBhbmQgYXR0cmlidXRlXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGF3YWl0IHN1cGVyLmRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgaW5zdGFuY2VUYWJsZSA9IHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5nZXRNb2RlbCh0YWJsZU5hbWUsIHsgYXR0cmlidXRlOiAndGFibGVOYW1lJyB9KTtcblxuICAgIGlmICghaW5zdGFuY2VUYWJsZSkge1xuICAgICAgLy8gRG8gbm90aGluZyB3aGVuIG1vZGVsIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRUYWJsZU5hbWUgPSAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hID09PSAncHVibGljJyA/ICcnIDogYCR7b3B0aW9ucy5zY2hlbWF9X2ApICsgdGFibGVOYW1lO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluc3RhbmNlVGFibGUucmF3QXR0cmlidXRlcyk7XG4gICAgY29uc3Qga2V5TGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBpZiAoaW5zdGFuY2VUYWJsZS5yYXdBdHRyaWJ1dGVzW2tleXNbaV1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AoZ2V0VGFibGVOYW1lLCBrZXlzW2ldKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0c1NlYXJjaFBhdGggPSBmYWxzZTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbn1cblxuZXhwb3J0cy5Qb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlID0gUG9zdGdyZXNRdWVyeUludGVyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuXG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3NxbDpwZycpO1xuXG5cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIC8qKlxuICAgKiBSZXdyaXRlIHF1ZXJ5IHdpdGggcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gdmFsdWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFsZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBzdHJpbmdSZXBsYWNlRnVuYyA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9cXDAvZywgJ1xcXFwwJykgOiB2YWx1ZTtcblxuICAgIGxldCBiaW5kUGFyYW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgYmluZFBhcmFtID0gdmFsdWVzLm1hcChzdHJpbmdSZXBsYWNlRnVuYyk7XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRQYXJhbSA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlcykgPT4ge1xuICAgICAgICBpZiAoc2VlbltrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VlbltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaSA9IGkgKyAxO1xuICAgICAgICAgIGJpbmRQYXJhbS5wdXNoKHN0cmluZ1JlcGxhY2VGdW5jKHZhbHVlc1trZXldKSk7XG4gICAgICAgICAgc2VlbltrZXldID0gYCQke2l9YDtcbiAgICAgICAgICByZXR1cm4gYCQke2l9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgfVxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG5cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gdGhpcztcblxuICAgIGlmICghXy5pc0VtcHR5KHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoKSkge1xuICAgICAgc3FsID0gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5zZXRTZWFyY2hQYXRoKHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoKSArIHNxbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIHRoaXMub3B0aW9ucy5pbmNsdWRlQWxpYXNlcykge1xuICAgICAgXy50b1BhaXJzKHRoaXMub3B0aW9ucy5pbmNsdWRlQWxpYXNlcylcbiAgICAgICAgLy8gU29ydGluZyB0byByZXBsYWNlIHRoZSBsb25nZXN0IGFsaWFzZXMgZmlyc3QgdG8gcHJldmVudCBhbGlhcyBjb2xsaXNpb25cbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0ubGVuZ3RoIC0gYVsxXS5sZW5ndGgpXG4gICAgICAgIC5mb3JFYWNoKChbYWxpYXMsIG9yaWdpbmFsXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoXy5lc2NhcGVSZWdFeHAob3JpZ2luYWwpLCAnZycpO1xuXG4gICAgICAgICAgc3FsID0gc3FsLnJlcGxhY2UocmVnLCBhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3FsID0gc3FsO1xuXG4gICAgY29uc3QgcXVlcnkgPSBwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMubGVuZ3RoXG4gICAgICA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm5lY3Rpb24ucXVlcnkoc3FsLCBwYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKSlcbiAgICAgIDogbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubmVjdGlvbi5xdWVyeShzcWwsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG5cbiAgICBsZXQgcXVlcnlSZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgcXVlcnlSZXN1bHQgPSBhd2FpdCBxdWVyeTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHNldCB0aGUgY2xpZW50IHNvIHRoYXQgaXQgd2lsbCBiZSByZWFwZWQgaWYgdGhlIGNvbm5lY3Rpb24gcmVzZXRzIHdoaWxlIGV4ZWN1dGluZ1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcpIHtcbiAgICAgICAgY29ubmVjdGlvbi5faW52YWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVyci5zcWwgPSBzcWw7XG4gICAgICBlcnIucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycik7XG4gICAgfVxuXG4gICAgY29tcGxldGUoKTtcblxuICAgIGxldCByb3dzID0gQXJyYXkuaXNBcnJheShxdWVyeVJlc3VsdClcbiAgICAgID8gcXVlcnlSZXN1bHQucmVkdWNlKChhbGxSb3dzLCByKSA9PiBhbGxSb3dzLmNvbmNhdChyLnJvd3MgfHwgW10pLCBbXSlcbiAgICAgIDogcXVlcnlSZXN1bHQucm93cztcbiAgICBjb25zdCByb3dDb3VudCA9IEFycmF5LmlzQXJyYXkocXVlcnlSZXN1bHQpXG4gICAgICA/IHF1ZXJ5UmVzdWx0LnJlZHVjZShcbiAgICAgICAgKGNvdW50LCByKSA9PiBOdW1iZXIuaXNGaW5pdGUoci5yb3dDb3VudCkgPyBjb3VudCArIHIucm93Q291bnQgOiBjb3VudCxcbiAgICAgICAgMFxuICAgICAgKVxuICAgICAgOiBxdWVyeVJlc3VsdC5yb3dDb3VudCB8fCAwO1xuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiB0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgIHJvd3MgPSByb3dzXG4gICAgICAgIC5tYXAocm93ID0+IF8udG9QYWlycyhyb3cpXG4gICAgICAgICAgLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcuZ2V0KGtleSk7XG4gICAgICAgICAgICBhY2NbbWFwcGluZyB8fCBrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVGFibGVOYW1lUXVlcnkgPSBzcWwuc3RhcnRzV2l0aCgnU0VMRUNUIHRhYmxlX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzJyk7XG4gICAgY29uc3QgaXNSZWxOYW1lUXVlcnkgPSBzcWwuc3RhcnRzV2l0aCgnU0VMRUNUIHJlbG5hbWUgRlJPTSBwZ19jbGFzcyBXSEVSRSBvaWQgSU4nKTtcblxuICAgIGlmIChpc1JlbE5hbWVRdWVyeSkge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICBuYW1lOiByb3cucmVsbmFtZSxcbiAgICAgICAgdGFibGVOYW1lOiByb3cucmVsbmFtZS5zcGxpdCgnXycpWzBdXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChpc1RhYmxlTmFtZVF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IE9iamVjdC52YWx1ZXMocm93KSk7XG4gICAgfVxuXG4gICAgaWYgKHJvd3NbMF0gJiYgcm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKHtcbiAgICAgICAgICBzcWwsXG4gICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICBjb2RlOiAnMjM1MDUnLFxuICAgICAgICAgIGRldGFpbDogcm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgZGVsZXRlIHJvdy5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gL09OIC4qPyAoPzpVU0lORyAuKj9cXHMpP1xcKChbXl0qKVxcKS9naS5leGVjKHJvdy5kZWZpbml0aW9uKVsxXS5zcGxpdCgnLCcpO1xuXG4gICAgICAgIC8vIE1hcCBjb2x1bW4gaW5kZXggaW4gdGFibGUgdG8gY29sdW1uIG5hbWVcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IF8uemlwT2JqZWN0KFxuICAgICAgICAgIHJvdy5jb2x1bW5faW5kZXhlcyxcbiAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyb3cuY29sdW1uX25hbWVzKVxuICAgICAgICApO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbl9pbmRleGVzO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbl9uYW1lcztcblxuICAgICAgICBsZXQgZmllbGQ7XG4gICAgICAgIGxldCBhdHRyaWJ1dGU7XG5cbiAgICAgICAgLy8gSW5ka2V5IGlzIHRoZSBvcmRlciBvZiBhdHRyaWJ1dGVzIGluIHRoZSBpbmRleCwgc3BlY2lmaWVkIGJ5IGEgc3RyaW5nIG9mIGF0dHJpYnV0ZSBpbmRleGVzXG4gICAgICAgIHJvdy5maWVsZHMgPSByb3cuaW5ka2V5LnNwbGl0KCcgJykubWFwKChpbmRLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgZmllbGQgPSBjb2x1bW5zW2luZEtleV07XG4gICAgICAgICAgLy8gZm9yIGZ1bmN0aW9uYWwgaW5kaWNlcyBpbmRLZXkgPSAwXG4gICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6IGZpZWxkLFxuICAgICAgICAgICAgY29sbGF0ZTogYXR0cmlidXRlLm1hdGNoKC9DT0xMQVRFIFwiKC4qPylcIi8pID8gL0NPTExBVEUgXCIoLio/KVwiLy5leGVjKGF0dHJpYnV0ZSlbMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcmRlcjogYXR0cmlidXRlLmluY2x1ZGVzKCdERVNDJykgPyAnREVTQycgOiBhdHRyaWJ1dGUuaW5jbHVkZXMoJ0FTQycpID8gJ0FTQycgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsZW5ndGg6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcihuID0+IG4gIT09IG51bGwpO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBsZXQgZGVmUGFydHM7XG4gICAgICAgIGlmIChyb3cuY29uZGVmICE9PSB1bmRlZmluZWQgJiYgKGRlZlBhcnRzID0gcm93LmNvbmRlZi5tYXRjaCgvRk9SRUlHTiBLRVkgXFwoKC4rKVxcKSBSRUZFUkVOQ0VTICguKylcXCgoLispXFwpKCBPTiAoVVBEQVRFfERFTEVURSkgKENBU0NBREV8UkVTVFJJQ1QpKT8oIE9OIChVUERBVEV8REVMRVRFKSAoQ0FTQ0FERXxSRVNUUklDVCkpPy8pKSkge1xuICAgICAgICAgIHJvdy5pZCA9IHJvdy5jb25zdHJhaW50X25hbWU7XG4gICAgICAgICAgcm93LnRhYmxlID0gZGVmUGFydHNbMl07XG4gICAgICAgICAgcm93LmZyb20gPSBkZWZQYXJ0c1sxXTtcbiAgICAgICAgICByb3cudG8gPSBkZWZQYXJ0c1szXTtcbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBmb3IgKGkgPSA1OyBpIDw9IDg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKC8oVVBEQVRFfERFTEVURSkvLnRlc3QoZGVmUGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgIHJvd1tgb25fJHtkZWZQYXJ0c1tpXS50b0xvd2VyQ2FzZSgpfWBdID0gZGVmUGFydHNbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcm93cztcbiAgICAgIC8vIFBvc3RncmVzIHdpbGwgdHJlYXQgdGFibGVzIGFzIGNhc2UtaW5zZW5zaXRpdmUsIHNvIGZpeCB0aGUgY2FzZVxuICAgICAgLy8gb2YgdGhlIHJldHVybmVkIHZhbHVlcyB0byBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJhdyA9PT0gZmFsc2UgJiYgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBhdHRyc01hcCA9IF8ucmVkdWNlKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgKG0sIHYsIGspID0+IHtcbiAgICAgICAgICBtW2sudG9Mb3dlckNhc2UoKV0gPSBrO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJlc3VsdCA9IHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcmV0dXJuIF8ubWFwS2V5cyhyb3csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBdHRyID0gYXR0cnNNYXBba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0QXR0ciA9PT0gJ3N0cmluZycgJiYgdGFyZ2V0QXR0ciAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRBdHRyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5ERVNDUklCRSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIHJlc3VsdFtyb3cuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IHJvdy5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiByb3cuTnVsbCA9PT0gJ1lFUycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiByb3cuRGVmYXVsdCxcbiAgICAgICAgICBjb21tZW50OiByb3cuQ29tbWVudCxcbiAgICAgICAgICBzcGVjaWFsOiByb3cuc3BlY2lhbCA/IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJvdy5zcGVjaWFsKSA6IFtdLFxuICAgICAgICAgIHByaW1hcnlLZXk6IHJvdy5Db25zdHJhaW50ID09PSAnUFJJTUFSWSBLRVknXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLnR5cGUgPT09ICdCT09MRUFOJykge1xuICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHsgJ2ZhbHNlJzogZmFsc2UsICd0cnVlJzogdHJ1ZSB9W3Jlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZV07XG5cbiAgICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLnJlcGxhY2UoLycvZywgJycpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5pbmNsdWRlcygnOjonKSkge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUuc3BsaXQoJzo6Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRbMV0udG9Mb3dlckNhc2UoKSAhPT0gJ3JlZ2NsYXNzKScpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gc3BsaXRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByb3dzWzBdLnNlcnZlcl92ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dPckRlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkJVTEtVUERBVEUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJvd0NvdW50LCAxMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyb3dzKTtcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuQlVMS0RFTEVURSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChyb3dDb3VudCwgMTApO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByb3dzWzBdKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyb3dzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSByb3dzWzBdW2tleV07XG5cbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcblxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgfHwgcm93cyAmJiAodGhpcy5vcHRpb25zLnBsYWluICYmIHJvd3NbMF0gfHwgcm93cykgfHwgdW5kZWZpbmVkLFxuICAgICAgICByb3dDb3VudFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jvd3MsIHF1ZXJ5UmVzdWx0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHRhYmxlO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgZmllbGRzO1xuICAgIGxldCBlcnJvcnM7XG4gICAgbGV0IG1lc3NhZ2U7XG5cbiAgICBjb25zdCBjb2RlID0gZXJyLmNvZGUgfHwgZXJyLnNxbFN0YXRlO1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBlcnIubWVzc2FnZVByaW1hcnk7XG4gICAgY29uc3QgZXJyRGV0YWlsID0gZXJyLmRldGFpbCB8fCBlcnIubWVzc2FnZURldGFpbDtcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAnMjM1MDMnOlxuICAgICAgICBpbmRleCA9IGVyck1lc3NhZ2UubWF0Y2goL3Zpb2xhdGVzIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgXCIoLis/KVwiLyk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPyBpbmRleFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGFibGUgPSBlcnJNZXNzYWdlLm1hdGNoKC9vbiB0YWJsZSBcIiguKz8pXCIvKTtcbiAgICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlOiBlcnJNZXNzYWdlLCBmaWVsZHM6IG51bGwsIGluZGV4LCB0YWJsZSwgcGFyZW50OiBlcnIgfSk7XG4gICAgICBjYXNlICcyMzUwNSc6XG4gICAgICAgIC8vIHRoZXJlIGFyZSBtdWx0aXBsZSBkaWZmZXJlbnQgZm9ybWF0cyBvZiBlcnJvciBtZXNzYWdlcyBmb3IgdGhpcyBlcnJvciBjb2RlXG4gICAgICAgIC8vIHRoaXMgcmVnZXggc2hvdWxkIGNoZWNrIGF0IGxlYXN0IHR3b1xuICAgICAgICBpZiAoZXJyRGV0YWlsICYmIChtYXRjaCA9IGVyckRldGFpbC5yZXBsYWNlKC9cIi9nLCAnJykubWF0Y2goL0tleSBcXCgoLio/KVxcKT1cXCgoLio/KVxcKS8pKSkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KG1hdGNoWzFdLnNwbGl0KCcsICcpLCBtYXRjaFsyXS5zcGxpdCgnLCAnKSk7XG4gICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgICAgbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGVycm9yJztcblxuICAgICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgICAgICB0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLFxuICAgICAgICAgICAgICAndW5pcXVlIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuREIsXG4gICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgJ25vdF91bmlxdWUnXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgXy5mb3JPd24odGhpcy5tb2RlbC51bmlxdWVLZXlzLCBjb25zdHJhaW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNFcXVhbChjb25zdHJhaW50LmZpZWxkcywgT2JqZWN0LmtleXMoZmllbGRzKSkgJiYgISFjb25zdHJhaW50Lm1zZykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb25zdHJhaW50Lm1zZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnMjNQMDEnOlxuICAgICAgICBtYXRjaCA9IGVyckRldGFpbC5tYXRjaCgvS2V5IFxcKCguKj8pXFwpPVxcKCguKj8pXFwpLyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QobWF0Y2hbMV0uc3BsaXQoJywgJyksIG1hdGNoWzJdLnNwbGl0KCcsICcpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlID0gJ0V4Y2x1c2lvbiBjb25zdHJhaW50IGVycm9yJztcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5FeGNsdXNpb25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgY29uc3RyYWludDogZXJyLmNvbnN0cmFpbnQsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHRhYmxlOiBlcnIudGFibGUsXG4gICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJzQyNzA0JzpcbiAgICAgICAgaWYgKGVyci5zcWwgJiYgLyhDT05TVFJBSU5UfElOREVYKS9naS50ZXN0KGVyci5zcWwpKSB7XG4gICAgICAgICAgbWVzc2FnZSA9ICdVbmtub3duIGNvbnN0cmFpbnQgZXJyb3InO1xuICAgICAgICAgIGluZGV4ID0gZXJyTWVzc2FnZS5tYXRjaCgvKD86Y29uc3RyYWludHxpbmRleCkgXCIoLis/KVwiL2kpO1xuICAgICAgICAgIGluZGV4ID0gaW5kZXggPyBpbmRleFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB0YWJsZSA9IGVyck1lc3NhZ2UubWF0Y2goL3JlbGF0aW9uIFwiKC4rPylcIi9pKTtcbiAgICAgICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IGluZGV4LFxuICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgaXNGb3JlaWduS2V5c1F1ZXJ5KCkge1xuICAgIHJldHVybiAvU0VMRUNUIGNvbm5hbWUgYXMgY29uc3RyYWludF9uYW1lLCBwZ19jYXRhbG9nXFwucGdfZ2V0X2NvbnN0cmFpbnRkZWZcXChyXFwub2lkLCB0cnVlXFwpIGFzIGNvbmRlZiBGUk9NIHBnX2NhdGFsb2dcXC5wZ19jb25zdHJhaW50IHIgV0hFUkUgclxcLmNvbnJlbGlkID0gXFwoU0VMRUNUIG9pZCBGUk9NIHBnX2NsYXNzIFdIRVJFIHJlbG5hbWUgPSAnLionIExJTUlUIDFcXCkgQU5EIHJcXC5jb250eXBlID0gJ2YnIE9SREVSIEJZIDE7Ly50ZXN0KHRoaXMuc3FsKTtcbiAgfVxuXG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuICdpZCc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5UmFuZ2VCb3VuZChib3VuZCkge1xuICBpZiAoYm91bmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJycgO1xuICB9XG4gIGlmIChib3VuZCA9PT0gSW5maW5pdHkgfHwgYm91bmQgPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiBib3VuZC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvdW5kKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSYW5nZUJvdW5kKGJvdW5kLCBwYXJzZVR5cGUpIHtcbiAgaWYgKCFib3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChib3VuZCA9PT0gJ2luZmluaXR5Jykge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAoYm91bmQgPT09ICctaW5maW5pdHknKSB7XG4gICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgfVxuICByZXR1cm4gcGFyc2VUeXBlKGJvdW5kKTtcblxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ3JhbmdlIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuICdlbXB0eSc7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMikgdGhyb3cgbmV3IEVycm9yKCdyYW5nZSBhcnJheSBsZW5ndGggbXVzdCBiZSAwIChlbXB0eSkgb3IgMiAobG93ZXIgYW5kIHVwcGVyIGJvdW5kcyknKTtcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsICdpbmNsdXNpdmUnKSkge1xuICAgIGlmIChkYXRhLmluY2x1c2l2ZSA9PT0gZmFsc2UpIGRhdGEuaW5jbHVzaXZlID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgZWxzZSBpZiAoIWRhdGEuaW5jbHVzaXZlKSBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCBmYWxzZV07XG4gICAgZWxzZSBpZiAoZGF0YS5pbmNsdXNpdmUgPT09IHRydWUpIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIHRydWVdO1xuICB9IGVsc2Uge1xuICAgIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIGZhbHNlXTtcbiAgfVxuXG4gIF8uZWFjaChkYXRhLCAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5jbHVzaXZlJykpIGRhdGEuaW5jbHVzaXZlW2luZGV4XSA9ICEhdmFsdWUuaW5jbHVzaXZlO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ3ZhbHVlJykpIGRhdGFbaW5kZXhdID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBsb3dlckJvdW5kID0gc3RyaW5naWZ5UmFuZ2VCb3VuZChkYXRhWzBdKTtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IHN0cmluZ2lmeVJhbmdlQm91bmQoZGF0YVsxXSk7XG5cbiAgcmV0dXJuIGAkeyhkYXRhLmluY2x1c2l2ZVswXSA/ICdbJyA6ICcoJykgKyBsb3dlckJvdW5kfSwke3VwcGVyQm91bmR9JHtkYXRhLmluY2x1c2l2ZVsxXSA/ICddJyA6ICcpJ31gO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIHBhcnNlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKHZhbHVlID09PSAnZW1wdHknKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHZhbHVlXG4gICAgLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKVxuICAgIC5zcGxpdCgnLCcsIDIpO1xuXG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyKSByZXR1cm4gdmFsdWU7XG5cbiAgcmVzdWx0ID0gcmVzdWx0Lm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHBhcnNlUmFuZ2VCb3VuZChpdGVtLCBwYXJzZXIpLFxuICAgICAgaW5jbHVzaXZlOiBpbmRleCA9PT0gMCA/IHZhbHVlWzBdID09PSAnWycgOiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ10nXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnY29ubmVjdGlvbjpzcWxpdGUnKTtcbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5zcWxpdGU7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZSgnLi4vcGFyc2VyU3RvcmUnKSgnc3FsaXRlJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuXG4gICAgLy8gV2UgYXR0ZW1wdCB0byBwYXJzZSBmaWxlIGxvY2F0aW9uIGZyb20gYSBjb25uZWN0aW9uIHVyaVxuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3QgbWF0Y2ggc2VxdWVsaXplIGRlZmF1bHQgaG9zdC5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0ID09PSAnbG9jYWxob3N0Jykge1xuICAgICAgZGVsZXRlIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb25zID0ge307XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZSgnc3FsaXRlMycpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzKTtcbiAgfVxuXG4gIGFzeW5jIF9vblByb2Nlc3NFeGl0KCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jb25uZWN0aW9ucylcbiAgICAgICAgLm1hcChjb25uZWN0aW9uID0+IHByb21pc2lmeShjYWxsYmFjayA9PiB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25dLmNsb3NlKGNhbGxiYWNrKSkoKSlcbiAgICApO1xuICAgIHJldHVybiBzdXBlci5fb25Qcm9jZXNzRXhpdC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoaXMgYXMgYSBtZXRob2Qgc28gdGhhdCB0aGUgcGFyc2luZyBtYXkgYmUgdXBkYXRlZCB3aGVuIHRoZSB1c2VyIGhhcyBhZGRlZCBhZGRpdGlvbmFsLCBjdXN0b20gdHlwZXNcbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cblxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cblxuICBhc3luYyBnZXRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnV1aWQgPSBvcHRpb25zLnV1aWQgfHwgJ2RlZmF1bHQnO1xuICAgIG9wdGlvbnMuc3RvcmFnZSA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RvcmFnZSB8fCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3QgfHwgJzptZW1vcnk6JztcbiAgICBvcHRpb25zLmluTWVtb3J5ID0gb3B0aW9ucy5zdG9yYWdlID09PSAnOm1lbW9yeTonID8gMSA6IDA7XG5cbiAgICBjb25zdCBkaWFsZWN0T3B0aW9ucyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnM7XG4gICAgY29uc3QgZGVmYXVsdFJlYWRXcml0ZU1vZGUgPSB0aGlzLmxpYi5PUEVOX1JFQURXUklURSB8IHRoaXMubGliLk9QRU5fQ1JFQVRFO1xuXG4gICAgb3B0aW9ucy5yZWFkV3JpdGVNb2RlID0gZGlhbGVjdE9wdGlvbnMgJiYgZGlhbGVjdE9wdGlvbnMubW9kZSB8fCBkZWZhdWx0UmVhZFdyaXRlTW9kZTtcblxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pbk1lbW9yeSAmJiAob3B0aW9ucy5yZWFkV3JpdGVNb2RlICYgdGhpcy5saWIuT1BFTl9DUkVBVEUpICE9PSAwKSB7XG4gICAgICAvLyBhdXRvbWF0aWMgcGF0aCBwcm92aXNpb24gZm9yIGBvcHRpb25zLnN0b3JhZ2VgXG4gICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMuc3RvcmFnZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSA9IG5ldyB0aGlzLmxpYi5EYXRhYmFzZShcbiAgICAgICAgb3B0aW9ucy5zdG9yYWdlLFxuICAgICAgICBvcHRpb25zLnJlYWRXcml0ZU1vZGUsXG4gICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICBkZWJ1ZyhgY29ubmVjdGlvbiBhY3F1aXJlZCAke29wdGlvbnMudXVpZH1gKTtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcucGFzc3dvcmQpIHtcbiAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gZGVmaW5lIGFuZCB1c2UgcGFzc3dvcmQgZm9yIHNxbGl0ZSBlbmNyeXB0aW9uIHBsdWdpbiBsaWtlIHNxbGNpcGhlclxuICAgICAgY29ubmVjdGlvbi5ydW4oYFBSQUdNQSBLRVk9JHt0aGlzLnNlcXVlbGl6ZS5lc2NhcGUodGhpcy5zZXF1ZWxpemUuY29uZmlnLnBhc3N3b3JkKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZm9yZWlnbktleXMgIT09IGZhbHNlKSB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGRlZmluZSBhbmQgdXNlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIHVubGVzc1xuICAgICAgLy8gZXhwbGljaXRseSBkaXNhbGxvd2VkLiBJdCdzIHN0aWxsIG9wdC1pbiBwZXIgcmVsYXRpb25cbiAgICAgIGNvbm5lY3Rpb24ucnVuKCdQUkFHTUEgRk9SRUlHTl9LRVlTPU9OJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICByZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uLCBmb3JjZSkge1xuICAgIGlmIChjb25uZWN0aW9uLmZpbGVuYW1lID09PSAnOm1lbW9yeTonICYmIGZvcmNlICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICBpZiAoY29ubmVjdGlvbi51dWlkKSB7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICBkZWJ1ZyhgY29ubmVjdGlvbiByZWxlYXNlZCAke2Nvbm5lY3Rpb24udXVpZH1gKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udXVpZF07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUeXBlcyA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHVuZGVmaW5lZCwgJ2h0dHBzOi8vd3d3LnNxbGl0ZS5vcmcvZGF0YXR5cGUzLmh0bWwnKTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB1bnN1cHBvcnRlZCBTUUxpdGUgb3B0aW9ucywgaS5lLiwgVU5TSUdORUQgYW5kIFpFUk9GSUxMLCBmb3IgdGhlIGludGVnZXIgZGF0YSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFUeXBlIFRoZSBiYXNlIGludGVnZXIgZGF0YSB0eXBlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5femVyb2ZpbGwgfHwgZGF0YVR5cGUuX3Vuc2lnbmVkKSB7XG4gICAgICB3YXJuKGBTUUxpdGUgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIFVOU0lHTkVEIG9yIFpFUk9GSUxMLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3NxbGl0ZS5vcmcvZGF0YXR5cGUzLmh0bWxcbiAgICovXG5cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMuc3FsaXRlID0gWydEQVRFVElNRSddO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLnNxbGl0ZSA9IFsnVkFSQ0hBUicsICdWQVJDSEFSIEJJTkFSWSddO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5zcWxpdGUgPSBbJ0NIQVInLCAnQ0hBUiBCSU5BUlknXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMuc3FsaXRlID0gWydURVhUJ107XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLnNxbGl0ZSA9IFsnVElOWUlOVCddO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMuc3FsaXRlID0gWydTTUFMTElOVCddO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLnNxbGl0ZSA9IFsnTUVESVVNSU5UJ107XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLnNxbGl0ZSA9IFsnSU5URUdFUiddO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLnNxbGl0ZSA9IFsnQklHSU5UJ107XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5zcWxpdGUgPSBbJ0ZMT0FUJ107XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLnNxbGl0ZSA9IFsnVElNRSddO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMuc3FsaXRlID0gWydEQVRFJ107XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLnNxbGl0ZSA9IFsnVElOWUlOVCddO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5zcWxpdGUgPSBbJ1RJTllCTE9CJywgJ0JMT0InLCAnTE9OR0JMT0InXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMuc3FsaXRlID0gWydERUNJTUFMJ107XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLnNxbGl0ZSA9IFsnVVVJRCddO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5zcWxpdGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMuc3FsaXRlID0gWydSRUFMJ107XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMuc3FsaXRlID0gWydET1VCTEUgUFJFQ0lTSU9OJ107XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5zcWxpdGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMuc3FsaXRlID0gWydKU09OJywgJ0pTT05CJ107XG5cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGEpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZGF0ZS5pbmNsdWRlcygnKycpKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0LiBEYXRlcyBpbnNlcnRlZCBieSBzZXF1ZWxpemUgPCAyLjBkZXYxMiB3aWxsIG5vdCBoYXZlIGEgdGltZXN0YW1wIHNldFxuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSArIG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpOyAvLyBXZSBhbHJlYWR5IGhhdmUgYSB0aW1lem9uZSBzdG9yZWQgaW4gdGhlIHN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgVkFSQ0hBUiBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybignU1FMaXRlIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIG9wdGlvbnMuIFBsYWluIGBURVhUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdURVhUJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBDSVRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuQ0lURVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnVEVYVCBDT0xMQVRFIE5PQ0FTRSc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgQ0hBUiBleHRlbmRzIEJhc2VUeXBlcy5DSEFSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBDSEFSIEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIE5VTUJFUiBleHRlbmRzIEJhc2VUeXBlcy5OVU1CRVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSAnIFVOU0lHTkVEJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICByZXN1bHQgKz0gJyBaRVJPRklMTCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fbGVuZ3RofWA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVjaW1hbHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9kZWNpbWFsc31gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBNRURJVU1JTlQgZXh0ZW5kcyBCYXNlVHlwZXMuTUVESVVNSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgfVxuXG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICB9XG5cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHsgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICdOYU4nKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnLUluZmluaXR5Jykge1xuICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBmbG9hdGluZyBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTF0pIHtcbiAgICBmbG9hdGluZy5wYXJzZSA9IHBhcnNlRmxvYXRpbmc7XG4gIH1cblxuXG4gIGZvciAoY29uc3QgbnVtIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMLCBUSU5ZSU5ULCBTTUFMTElOVCwgTUVESVVNSU5ULCBJTlRFR0VSLCBCSUdJTlRdKSB7XG4gICAgbnVtLnByb3RvdHlwZS50b1NxbCA9IE5VTUJFUi5wcm90b3R5cGUudG9TcWw7XG4gIH1cblxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdURVhUJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgU1RSSU5HLFxuICAgIENIQVIsXG4gICAgTlVNQkVSLFxuICAgIEZMT0FULFxuICAgIFJFQUwsXG4gICAgJ0RPVUJMRSBQUkVDSVNJT04nOiBET1VCTEUsXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBNRURJVU1JTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgVEVYVCxcbiAgICBFTlVNLFxuICAgIEpTT046IEpTT05UWVBFLFxuICAgIENJVEVYVFxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QnKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLnNxbGl0ZTtcbmNvbnN0IHsgU1FMaXRlUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4vcXVlcnktaW50ZXJmYWNlJyk7XG5cbmNsYXNzIFNxbGl0ZURpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG5cbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblxuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gICdERUZBVUxUJzogZmFsc2UsXG4gICdERUZBVUxUIFZBTFVFUyc6IHRydWUsXG4gICdVTklPTiBBTEwnOiBmYWxzZSxcbiAgJ1JJR0hUIEpPSU4nOiBmYWxzZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6ICcgT1IgSUdOT1JFJyxcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogJyBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUJ1xuICB9LFxuICBpbmRleDoge1xuICAgIHVzaW5nOiBmYWxzZSxcbiAgICB3aGVyZTogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiB0cnVlXG4gIH0sXG4gIHRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIHR5cGU6IHRydWVcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBhZGRDb25zdHJhaW50OiBmYWxzZSxcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2VcbiAgfSxcbiAgam9pblRhYmxlRGVwZW5kZW50OiBmYWxzZSxcbiAgZ3JvdXBlZExpbWl0OiBmYWxzZSxcbiAgSlNPTjogdHJ1ZVxufSk7XG5cblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gJzMuOC4wJztcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gJ3NxbGl0ZSc7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnYCc7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblxubW9kdWxlLmV4cG9ydHMgPSBTcWxpdGVEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuU3FsaXRlRGlhbGVjdCA9IFNxbGl0ZURpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gU3FsaXRlRGlhbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90cmFuc2FjdGlvbicpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgTXlTcWxRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL215c3FsL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvcicpO1xuXG5jbGFzcyBTUUxpdGVRdWVyeUdlbmVyYXRvciBleHRlbmRzIE15U3FsUXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT0ndGFibGUnIGFuZCBuYW1lIT0nc3FsaXRlX3NlcXVlbmNlJztcIjtcbiAgfVxuXG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT0ndGFibGUnIGFuZCBuYW1lIT0nc3FsaXRlX3NlcXVlbmNlJztcIjtcbiAgfVxuXG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gJ1NFTEVDVCBzcWxpdGVfdmVyc2lvbigpIGFzIGB2ZXJzaW9uYCc7XG4gIH1cblxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXTtcbiAgICBjb25zdCBuZWVkc011bHRpcGxlUHJpbWFyeUtleXMgPSBPYmplY3QudmFsdWVzKGF0dHJpYnV0ZXMpLmZpbHRlcihkZWZpbml0aW9uID0+IGRlZmluaXRpb24uaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgYXR0ckFycmF5ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQXV0b0luY3JlbWVudCA9IGRhdGFUeXBlLmluY2x1ZGVzKCdBVVRPSU5DUkVNRU5UJyk7XG5cbiAgICAgICAgbGV0IGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGU7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkge1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnSU5UJykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgSU5URUdFUiBpcyBhbGxvd2VkIGZvciBwcmltYXJ5IGtleSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2lzc3Vlcy85NjkgKG5vIGxlbmdodCwgdW5zaWduZWQgZXRjKVxuICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBjb250YWluc0F1dG9JbmNyZW1lbnQgPyAnSU5URUdFUiBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5UJyA6ICdJTlRFR0VSIFBSSU1BUlkgS0VZJztcblxuICAgICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCcgUkVGRVJFTkNFUycpKSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nICs9IGRhdGFUeXBlLnN1YnN0cihkYXRhVHlwZS5pbmRleE9mKCcgUkVGRVJFTkNFUycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVlZHNNdWx0aXBsZVByaW1hcnlLZXlzKSB7XG4gICAgICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdOT1QgTlVMTCcpKSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGUucmVwbGFjZSgnIFBSSU1BUlkgS0VZJywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZS5yZXBsYWNlKCdQUklNQVJZIEtFWScsICdOT1QgTlVMTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyQXJyYXkucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZVN0cmluZ31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBhdHRyU3RyID0gYXR0ckFycmF5LmpvaW4oJywgJyk7XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAocGsgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKCcsICcpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgY29sdW1ucyA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgYXR0clN0ciArPSBgLCBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKGZpZWxkID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJTdHIgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3FsID0gYENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICR7dGFibGV9ICgke2F0dHJTdHJ9KTtgO1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKTtcbiAgfVxuXG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHN0YXRtZW1lbnQgaXMganNvbiBmdW5jdGlvbiBvciBzaW1wbGUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgc3RtdCAgVGhlIHN0YXRlbWVudCB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RhdGVtZW50IGlzIGpzb24gZnVuY3Rpb25cbiAgICogQHRocm93cyAge0Vycm9yfSAgICAgICAgIHRocm93IGlmIHRoZSBzdGF0ZW1lbnQgbG9va3MgbGlrZSBqc29uIGZ1bmN0aW9uIGJ1dCBoYXMgaW52YWxpZCB0b2tlblxuICAgKi9cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9zcWxpdGUub3JnL2pzb24xLmh0bWxcbiAgICBjb25zdCBqc29uRnVuY3Rpb25SZWdleCA9IC9eXFxzKihqc29uKD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuICAgIGNvbnN0IHRva2VuQ2FwdHVyZVJlZ2V4ID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0ganNvbkZ1bmN0aW9uUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoJygnKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IHRva2VuQ2FwdHVyZVJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcoJykge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICcpJykge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09ICc7Jykge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnZhbGlkIGpzb24gc3RhdGVtZW50XG4gICAgaGFzSW52YWxpZFRva2VuIHw9IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzO1xuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgaGFzSW52YWxpZFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhdGVtZW50IGhhcyB2YWxpZCBqc29uIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuXG4gIC8vc3FsaXRlIGNhbid0IGNhc3QgdG8gZGF0ZXRpbWUgc28gd2UgbmVlZCB0byBjb252ZXJ0IGRhdGUgdmFsdWVzIHRvIHRoZWlyIElTTyBzdHJpbmdzXG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWVbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB2YWwudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKC90aW1lc3RhbXAvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gJ2RhdGV0aW1lJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQWJzdHJhY3RRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUuaGFuZGxlU2VxdWVsaXplTWV0aG9kLmNhbGwodGhpcywgc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuXG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGF0dHJpYnV0ZXNba2V5XSA9IGRhdGFUeXBlO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIHsgY29udGV4dDogJ2FkZENvbHVtbicgfSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX0gJHtmaWVsZHNba2V5XX1gO1xuXG4gICAgY29uc3Qgc3FsID0gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gQUREICR7YXR0cmlidXRlfTtgO1xuXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpO1xuICB9XG5cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiAnU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT1cXCd0YWJsZVxcJyBhbmQgbmFtZSE9XFwnc3FsaXRlX3NlcXVlbmNlXFwnOyc7XG4gIH1cblxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgYXR0clZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChhdHRyVmFsdWVIYXNoLCBvcHRpb25zLm9taXROdWxsLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtIHx8IHRoaXMuYmluZFBhcmFtKGJpbmQpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJWYWx1ZUhhc2gpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0clZhbHVlSGFzaFtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdVUERBVEUnIH0pfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ1VQREFURScgfSwgYmluZFBhcmFtKX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcXVlcnk7XG4gICAgY29uc3Qgd2hlcmVPcHRpb25zID0geyAuLi5vcHRpb25zLCBiaW5kUGFyYW0gfTtcblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBxdWVyeSA9IGBVUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oJywnKX0gV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfSBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IGBVUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oJywnKX0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBxdWVyeSwgYmluZCB9O1xuICB9XG5cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zLnJlc3RhcnRJZGVudGl0eSA/IGA7IERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKCdzcWxpdGVfc2VxdWVuY2UnKX0gV0hFUkUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcignbmFtZScpfSA9ICR7VXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3ModGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksICdgJyksIFwiJ1wiKX07YCA6ICcnXG4gICAgXS5qb2luKCcnKTtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGBXSEVSRSAke3doZXJlQ2xhdXNlfWA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYFdIRVJFIHJvd2lkIElOIChTRUxFQ1Qgcm93aWQgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3doZXJlQ2xhdXNlfSBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt3aGVyZUNsYXVzZX1gO1xuICB9XG5cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgY29uc3QgZmllbGROYW1lID0gZGF0YVR5cGUuZmllbGQgfHwgbmFtZTtcblxuICAgICAgaWYgKF8uaXNPYmplY3QoZGF0YVR5cGUpKSB7XG4gICAgICAgIGxldCBzcWwgPSBkYXRhVHlwZS50eXBlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgJ2FsbG93TnVsbCcpICYmICFkYXRhVHlwZS5hbGxvd051bGwpIHtcbiAgICAgICAgICBzcWwgKz0gJyBOT1QgTlVMTCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGRhdGFUeXBlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRob3JvdWdobHkgY2hlY2sgdGhhdCBEYXRhVHlwZXMuTk9XIHdpbGwgcHJvcGVybHlcbiAgICAgICAgICAvLyBnZXQgcG9wdWxhdGVkIG9uIGFsbCBkYXRhYmFzZXMgYXMgREVGQVVMVCB2YWx1ZVxuICAgICAgICAgIC8vIGkuZS4gbXlzcWwgcmVxdWlyZXM6IERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVBcbiAgICAgICAgICBzcWwgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoZGF0YVR5cGUuZGVmYXVsdFZhbHVlLCBkYXRhVHlwZSl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhVHlwZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBzcWwgKz0gJyBVTklRVUUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLnByaW1hcnlLZXkpIHtcbiAgICAgICAgICBzcWwgKz0gJyBQUklNQVJZIEtFWSc7XG5cbiAgICAgICAgICBpZiAoZGF0YVR5cGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgICAgc3FsICs9ICcgQVVUT0lOQ1JFTUVOVCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUoZGF0YVR5cGUucmVmZXJlbmNlcy5tb2RlbCk7XG5cbiAgICAgICAgICBsZXQgcmVmZXJlbmNlc0tleTtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhVHlwZS5yZWZlcmVuY2VzLmtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcignaWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcWwgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1RhYmxlfSAoJHtyZWZlcmVuY2VzS2V5fSlgO1xuXG4gICAgICAgICAgaWYgKGRhdGFUeXBlLm9uRGVsZXRlKSB7XG4gICAgICAgICAgICBzcWwgKz0gYCBPTiBERUxFVEUgJHtkYXRhVHlwZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRhdGFUeXBlLm9uVXBkYXRlKSB7XG4gICAgICAgICAgICBzcWwgKz0gYCBPTiBVUERBVEUgJHtkYXRhVHlwZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IHNxbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gZGF0YVR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBQUkFHTUEgSU5ERVhfTElTVCgke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSlgO1xuICB9XG5cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGxldCBzcWwgPSBgU0VMRUNUIHNxbCBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdGJsX25hbWU9JyR7dGFibGVOYW1lfSdgO1xuXG4gICAgaWYgKGNvbnN0cmFpbnROYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgc3FsIExJS0UgJyUke2NvbnN0cmFpbnROYW1lfSUnYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7c3FsfTtgO1xuICB9XG5cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKCdfJyl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBEUk9QIElOREVYIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9YDtcbiAgfVxuXG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB7XG4gICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXIsXG4gICAgICB0YWJsZU5hbWVcbiAgICB9O1xuICAgIHJldHVybiBgUFJBR01BIFRBQkxFX0lORk8oJHt0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEodGFibGUpKX0pO2A7XG4gIH1cblxuICBkZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1Qgc3FsIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0nJHt0YWJsZU5hbWV9JztgO1xuICB9XG5cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG5cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG5cbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cblxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oJywgJyk7XG5cbiAgICAvLyBUZW1wb3JhcnkgdGFibGUgY2Fubm90IHdvcmsgZm9yIGZvcmVpZ24ga2V5cy5cbiAgICByZXR1cm4gYCR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KGJhY2t1cFRhYmxlTmFtZSwgYXR0cmlidXRlcylcbiAgICB9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtgXG4gICAgICArIGBEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTske1xuICAgICAgICB0aGlzLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgfUlOU0VSVCBJTlRPICR7cXVvdGVkVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YFxuICAgICAgKyBgRFJPUCBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YDtcbiAgfVxuXG4gIF9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZVRhYmxlU3FsKSB7XG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcblxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcblxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKCcsICcpO1xuXG4gICAgcmV0dXJuIGAke2NyZWF0ZVRhYmxlU3FsXG4gICAgICAucmVwbGFjZShgQ1JFQVRFIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfWAsIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9YClcbiAgICAgIC5yZXBsYWNlKGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWUucmVwbGFjZSgvYC9nLCAnXCInKX1gLCBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfWApXG4gICAgfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07YFxuICAgICAgKyBgRFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07YFxuICAgICAgKyBgQUxURVIgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFJFTkFNRSBUTyAke3F1b3RlZFRhYmxlTmFtZX07YDtcbiAgfVxuXG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIGF0dHJpYnV0ZXMpIHtcblxuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG5cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG5cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lc0ltcG9ydCA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChhdHRyID0+XG4gICAgICBhdHRyTmFtZUFmdGVyID09PSBhdHRyID8gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ck5hbWVCZWZvcmUpfSBBUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWAgOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKVxuICAgICkuam9pbignLCAnKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lc0V4cG9ydCA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKCcsICcpO1xuXG4gICAgLy8gVGVtcG9yYXJ5IHRhYmxlcyBkb24ndCBzdXBwb3J0IGZvcmVpZ24ga2V5cywgc28gY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdGFibGUgd2lsbCBub3QgYWxsb3cgZm9yZWlnbiBrZXlzIHRvIGJlIHByZXNlcnZlZFxuICAgIHJldHVybiBgJHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkoYmFja3VwVGFibGVOYW1lLCBhdHRyaWJ1dGVzKVxuICAgIH1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXNJbXBvcnR9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O2BcbiAgICAgICsgYERST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9OyR7XG4gICAgICAgIHRoaXMuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICB9SU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzRXhwb3J0fSBGUk9NICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgXG4gICAgICArIGBEUk9QIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgO1xuICB9XG5cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYEJFR0lOICR7dHJhbnNhY3Rpb24ub3B0aW9ucy50eXBlfSBUUkFOU0FDVElPTjtgO1xuICB9XG5cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRVBFQVRBQkxFX1JFQUQ6XG4gICAgICAgIHJldHVybiAnLS0gU1FMaXRlIGlzIG5vdCBhYmxlIHRvIGNob29zZSB0aGUgaXNvbGF0aW9uIGxldmVsIFJFUEVBVEFCTEUgUkVBRC4nO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfVU5DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiAnUFJBR01BIHJlYWRfdW5jb21taXR0ZWQgPSBPTjsnO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfQ09NTUlUVEVEOlxuICAgICAgICByZXR1cm4gJ1BSQUdNQSByZWFkX3VuY29tbWl0dGVkID0gT0ZGOyc7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuU0VSSUFMSVpBQkxFOlxuICAgICAgICByZXR1cm4gJy0tIFNRTGl0ZVxcJ3MgZGVmYXVsdCBpc29sYXRpb24gbGV2ZWwgaXMgU0VSSUFMSVpBQkxFLiBOb3RoaW5nIHRvIGRvLic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaXNvbGF0aW9uIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKSB7XG4gICAgcmV0dXJuIHNxbC5yZXBsYWNlKC9ERUZBVUxUICc/ZmFsc2UnPy9nLCAnREVGQVVMVCAwJykucmVwbGFjZSgvREVGQVVMVCAnP3RydWUnPy9nLCAnREVGQVVMVCAxJyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgYWxsIGZvcmVpZ24ga2V5cyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhYmxlTmFtZSAgVGhlIG5hbWUgb2YgdGhlIHRhYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFBSQUdNQSBmb3JlaWduX2tleV9saXN0KCR7dGFibGVOYW1lfSlgO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU1FMaXRlUXVlcnlHZW5lcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UnKTtcbmNvbnN0IHsgY2xvbmVEZWVwIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgdGhhdCBTZXF1ZWxpemUgdXNlcyB0byB0YWxrIHdpdGggU1FMaXRlIGRhdGFiYXNlXG4gKi9cbmNsYXNzIFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICAvKipcbiAgICogQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIHJlbW92ZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICAgKiBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gICAqIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGhvdXQgdGhlIG9ic29sZXRlIGNvbHVtbi5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcykgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciB0aGF0IGZpeGVzIFNRTGl0ZSdzIGluYWJpbGl0eSB0byBjaGFuZ2UgY29sdW1ucyBmcm9tIGV4aXN0aW5nIHRhYmxlcy5cbiAgICogSXQgd2lsbCBjcmVhdGUgYSBiYWNrdXAgb2YgdGhlIHRhYmxlLCBkcm9wIHRoZSB0YWJsZSBhZnRlcndhcmRzIGFuZCBjcmVhdGUgYVxuICAgKiBuZXcgdGFibGUgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCB3aXRoIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgcmVzcGVjdGl2ZSBjb2x1bW4uXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgZGF0YVR5cGVPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24oZmllbGRzW2F0dHJpYnV0ZU5hbWVdLCB0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucykpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdCgnOycpLmZpbHRlcihxID0+IHEgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcykgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciB0aGF0IGZpeGVzIFNRTGl0ZSdzIGluYWJpbGl0eSB0byByZW5hbWUgY29sdW1ucyBmcm9tIGV4aXN0aW5nIHRhYmxlcy5cbiAgICogSXQgd2lsbCBjcmVhdGUgYSBiYWNrdXAgb2YgdGhlIHRhYmxlLCBkcm9wIHRoZSB0YWJsZSBhZnRlcndhcmRzIGFuZCBjcmVhdGUgYVxuICAgKiBuZXcgdGFibGUgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCB3aXRoIGEgcmVuYW1lZCB2ZXJzaW9uIG9mIHRoZSByZXNwZWN0aXZlIGNvbHVtbi5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyByZW5hbWVDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgb3B0aW9ucyk7XG5cbiAgICBmaWVsZHNbYXR0ck5hbWVBZnRlcl0gPSB7IC4uLmZpZWxkc1thdHRyTmFtZUJlZm9yZV0gfTtcbiAgICBkZWxldGUgZmllbGRzW2F0dHJOYW1lQmVmb3JlXTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3JlYXRlVGFibGVTcWw7XG5cbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2hvd0NvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgLy8gc3FsaXRlIGNhbid0IHNob3cgb25seSBvbmUgY29uc3RyYWludCwgc28gd2UgZmluZCBoZXJlIHRoZSBvbmUgdG8gcmVtb3ZlXG4gICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzLmZpbmQoY29uc3RhaW50ID0+IGNvbnN0YWludC5jb25zdHJhaW50TmFtZSA9PT0gY29uc3RyYWludE5hbWUpO1xuXG4gICAgaWYgKCFjb25zdHJhaW50KSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ29uc3RyYWludCAke2NvbnN0cmFpbnROYW1lfSBvbiB0YWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50TmFtZSxcbiAgICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRhYmxlU3FsID0gY29uc3RyYWludC5zcWw7XG4gICAgY29uc3RyYWludC5jb25zdHJhaW50TmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgIGxldCBjb25zdHJhaW50U25pcHBldCA9IGAsIENPTlNUUkFJTlQgJHtjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lfSAke2NvbnN0cmFpbnQuY29uc3RyYWludFR5cGV9ICR7Y29uc3RyYWludC5jb25zdHJhaW50Q29uZGl0aW9ufWA7XG5cbiAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50VHlwZSA9PT0gJ0ZPUkVJR04gS0VZJykge1xuICAgICAgY29uc3QgcmVmZXJlbmNlVGFibGVOYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZVRhYmxlKGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVOYW1lKTtcbiAgICAgIGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzID0gY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMubWFwKGNvbHVtbk5hbWUgPT4gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoY29sdW1uTmFtZSkpO1xuICAgICAgY29uc3QgcmVmZXJlbmNlVGFibGVLZXlzID0gY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMuam9pbignLCAnKTtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZVRhYmxlTmFtZX0gKCR7cmVmZXJlbmNlVGFibGVLZXlzfSlgO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBVUERBVEUgJHtjb25zdHJhaW50LnVwZGF0ZUFjdGlvbn1gO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBERUxFVEUgJHtjb25zdHJhaW50LmRlbGV0ZUFjdGlvbn1gO1xuICAgIH1cblxuICAgIGNyZWF0ZVRhYmxlU3FsID0gY3JlYXRlVGFibGVTcWwucmVwbGFjZShjb25zdHJhaW50U25pcHBldCwgJycpO1xuICAgIGNyZWF0ZVRhYmxlU3FsICs9ICc7JztcblxuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5fYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmaWVsZHMsIGNyZWF0ZVRhYmxlU3FsKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBhZGRDb25zdHJhaW50KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGRzIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy5maWVsZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50IHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLnR5cGUnKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgY29uc3QgY29uc3RyYWludFNuaXBwZXQgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVzY3JpYmVDcmVhdGVUYWJsZVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVDcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSk7XG5cbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRlc2NyaWJlQ3JlYXRlVGFibGVTcWwsIHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QsIHJhdzogdHJ1ZSB9KTtcbiAgICBsZXQgc3FsID0gY29uc3RyYWludHNbMF0uc3FsO1xuICAgIGNvbnN0IGluZGV4ID0gc3FsLmxlbmd0aCAtIDE7XG4gICAgLy9SZXBsYWNlIGVuZGluZyAnKScgd2l0aCBjb25zdHJhaW50IHNuaXBwZXQgLSBTaW11bGF0ZXMgU3RyaW5nLnJlcGxhY2VBdFxuICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDMxMDk0XG4gICAgY29uc3QgY3JlYXRlVGFibGVTcWwgPSBgJHtzcWwuc3Vic3RyKDAsIGluZGV4KX0sICR7Y29uc3RyYWludFNuaXBwZXR9KSR7c3FsLnN1YnN0cihpbmRleCArIDEpfTtgO1xuXG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5fYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmaWVsZHMsIGNyZWF0ZVRhYmxlU3FsKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgZGF0YWJhc2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcChyb3cgPT4gKHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIGNvbHVtbk5hbWU6IHJvdy5mcm9tLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlTmFtZTogcm93LnRhYmxlLFxuICAgICAgcmVmZXJlbmNlZENvbHVtbk5hbWU6IHJvdy50byxcbiAgICAgIHRhYmxlQ2F0YWxvZzogZGF0YWJhc2UsXG4gICAgICByZWZlcmVuY2VkVGFibGVDYXRhbG9nOiBkYXRhYmFzZVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGRyb3BBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG5cbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zaG93QWxsVGFibGVzKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KCdQUkFHTUEgZm9yZWlnbl9rZXlzID0gT0ZGJywgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5fZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSgnUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9OJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBkZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSBudWxsO1xuICAgIGxldCBzY2hlbWFEZWxpbWl0ZXIgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYSB8fCBudWxsO1xuICAgICAgc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ29iamVjdCcgJiYgdGFibGVOYW1lICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKTtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLkRFU0NSSUJFIH07XG4gICAgY29uc3Qgc3FsSW5kZXhlcyA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgICAgLypcbiAgICAgICAqIElmIG5vIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgcXVlcnksIHRoZW4gdGhlIHRhYmxlIG5hbWUgbWF5IGJlIHdyb25nLlxuICAgICAgICogUXVlcnkgZ2VuZXJhdG9ycyB0aGF0IHVzZSBpbmZvcm1hdGlvbl9zY2hlbWEgZm9yIHJldHJpZXZpbmcgdGFibGUgaW5mbyB3aWxsIGp1c3QgcmV0dXJuIGFuIGVtcHR5IHJlc3VsdCBzZXQsXG4gICAgICAgKiBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBsaWtlIGJ1aWx0LWlucyBkbyAoZS5nLiBERVNDUklCRSBvbiBNeVNxbCkuXG4gICAgICAgKi9cbiAgICAgIGlmIChfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWxJbmRleGVzLCBvcHRpb25zKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFbcHJvcF0udW5pcXVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICBpZiAoaW5kZXgudW5pcXVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFbZmllbGQuYXR0cmlidXRlXS51bmlxdWUgPSBpbmRleC51bmlxdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gYXdhaXQgdGhpcy5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXkgb2YgZm9yZWlnbktleXMpIHtcbiAgICAgICAgZGF0YVtmb3JlaWduS2V5LmNvbHVtbk5hbWVdLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgICAgbW9kZWw6IGZvcmVpZ25LZXkucmVmZXJlbmNlZFRhYmxlTmFtZSxcbiAgICAgICAgICBrZXk6IGZvcmVpZ25LZXkucmVmZXJlbmNlZENvbHVtbk5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUub3JpZ2luYWwgJiYgZS5vcmlnaW5hbC5jb2RlID09PSAnRVJfTk9fU1VDSF9UQUJMRScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuU1FMaXRlUXVlcnlJbnRlcmZhY2UgPSBTUUxpdGVRdWVyeUludGVyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdzcWxpdGUnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcblxuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdzcWw6c3FsaXRlJyk7XG5cblxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gJ2xhc3RJRCc7XG4gIH1cblxuICAvKipcbiAgICogcmV3cml0ZSBxdWVyeSB3aXRoIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcWxcbiAgICogQHBhcmFtIHtBcnJheXxvYmplY3R9IHZhbHVlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhbGVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgbGV0IGJpbmRQYXJhbTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBiaW5kUGFyYW0gPSB7fTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGJpbmRQYXJhbVtgJCR7aSArIDF9YF0gPSB2O1xuICAgICAgfSk7XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRQYXJhbSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgICAgYmluZFBhcmFtW2AkJHtrfWBdID0gdmFsdWVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfVxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG5cbiAgX2NvbGxlY3RNb2RlbHMoaW5jbHVkZSwgcHJlZml4KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG5cbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBfaW5jbHVkZSBvZiBpbmNsdWRlKSB7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAga2V5ID0gX2luY2x1ZGUuYXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gYCR7cHJlZml4fS4ke19pbmNsdWRlLmFzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2tleV0gPSBfaW5jbHVkZS5tb2RlbDtcblxuICAgICAgICBpZiAoX2luY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgICAgIF8ubWVyZ2UocmV0LCB0aGlzLl9jb2xsZWN0TW9kZWxzKF9pbmNsdWRlLmluY2x1ZGUsIGtleSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIF9oYW5kbGVRdWVyeVJlc3BvbnNlKG1ldGFEYXRhLCBjb2x1bW5UeXBlcywgZXJyLCByZXN1bHRzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyLnNxbCA9IHRoaXMuc3FsO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcblxuICAgIC8vIGFkZCB0aGUgaW5zZXJ0ZWQgcm93IGlkIHRvIHRoZSBpbnN0YW5jZVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAvLyBoYW5kbGUgYnVsa0NyZWF0ZSBBSSBwcmltYXJ5IGtleVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWV0YURhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1N0YXRlbWVudCdcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldIC0gbWV0YURhdGEuY2hhbmdlcyArIDE7XG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgbWV0YURhdGEuY2hhbmdlczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IFt0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZF06IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByZXN1bHRzLm1hcChyb3cgPT4gcm93Lm5hbWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHM7XG4gICAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uc3FsKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VDb25zdHJhaW50c0Zyb21TcWwocmVzdWx0c1swXS5zcWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJhdykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgYSBtYXAgb2YgcHJlZml4IHN0cmluZ3MgdG8gbW9kZWxzLCBlLmcuIHVzZXIucHJvamVjdHMgLT4gUHJvamVjdCBtb2RlbFxuICAgICAgY29uc3QgcHJlZml4ZXMgPSB0aGlzLl9jb2xsZWN0TW9kZWxzKHRoaXMub3B0aW9ucy5pbmNsdWRlKTtcblxuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIHJldHVybiBfLm1hcFZhbHVlcyhyZXN1bHQsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgICBpZiAobmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0aW5kID0gbmFtZS5sYXN0SW5kZXhPZignLicpO1xuXG4gICAgICAgICAgICBtb2RlbCA9IHByZWZpeGVzW25hbWUuc3Vic3RyKDAsIGxhc3RpbmQpXTtcblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKGxhc3RpbmQgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwgPSB0aGlzLm9wdGlvbnMubW9kZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdGFibGVOYW1lID0gbW9kZWwuZ2V0VGFibGVOYW1lKCkudG9TdHJpbmcoKS5yZXBsYWNlKC9gL2csICcnKTtcbiAgICAgICAgICBjb25zdCB0YWJsZVR5cGVzID0gY29sdW1uVHlwZXNbdGFibGVOYW1lXSB8fCB7fTtcblxuICAgICAgICAgIGlmICh0YWJsZVR5cGVzICYmICEobmFtZSBpbiB0YWJsZVR5cGVzKSkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbHVtbiBpcyBhbGlhc2VkXG4gICAgICAgICAgICBfLmZvck93bihtb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGtleSAmJiBhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlLmZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWJsZVR5cGVzLCBuYW1lKVxuICAgICAgICAgICAgPyB0aGlzLmFwcGx5UGFyc2Vycyh0YWJsZVR5cGVzW25hbWVdLCB2YWx1ZSlcbiAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dPckRlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIElOREVYX0xJU1QnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShyZXN1bHRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgSU5ERVhfSU5GTycpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgVEFCTEVfSU5GTycpKSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBzcWxpdGUgd2F5IG9mIGdldHRpbmcgdGhlIG1ldGFkYXRhIG9mIGEgdGFibGVcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBsZXQgZGVmYXVsdFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKF9yZXN1bHQuZGZsdF92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbHVtbiBzY2hlbWEgb21pdHMgYW55IFwiREVGQVVMVCAuLi5cIlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChfcmVzdWx0LmRmbHRfdmFsdWUgPT09ICdOVUxMJykge1xuICAgICAgICAgIC8vIENvbHVtbiBzY2hlbWEgaXMgYSBcIkRFRkFVTFQgTlVMTFwiXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBfcmVzdWx0LmRmbHRfdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LnR5cGUsXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lm5vdG51bGwgPT09IDAsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQucGsgIT09IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0W19yZXN1bHQubmFtZV0udHlwZSA9PT0gJ1RJTllJTlQoMSknKSB7XG4gICAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID0geyAnMCc6IGZhbHNlLCAnMSc6IHRydWUgfVtyZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID0gcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlLnJlcGxhY2UoLycvZywgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBmb3JlaWduX2tleXM7JykpIHtcbiAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBmb3JlaWduX2tleXMnKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIGZvcmVpZ25fa2V5X2xpc3QnKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmIChbUXVlcnlUeXBlcy5CVUxLVVBEQVRFLCBRdWVyeVR5cGVzLkJVTEtERUxFVEVdLmluY2x1ZGVzKHRoaXMub3B0aW9ucy50eXBlKSkge1xuICAgICAgcmV0dXJuIG1ldGFEYXRhLmNoYW5nZXM7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5WRVJTSU9OKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuUkFXKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdHMsIG1ldGFEYXRhXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgbnVsbF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzSW5zZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIG1ldGFEYXRhLmNoYW5nZXNdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgbWV0aG9kID0gdGhpcy5nZXREYXRhYmFzZU1ldGhvZCgpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubi5zZXJpYWxpemUoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uVHlwZXMgPSB7fTtcbiAgICAgIGNvbnN0IGV4ZWN1dGVTcWwgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzcWwuc3RhcnRzV2l0aCgnLS0gJykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcztcbiAgICAgICAgLy8gY2Fubm90IHVzZSBhcnJvdyBmdW5jdGlvbiBoZXJlIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnRcbiAgICAgICAgZnVuY3Rpb24gYWZ0ZXJFeGVjdXRlKGV4ZWN1dGlvbkVycm9yLCByZXN1bHRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAvLyBgdGhpc2AgaXMgcGFzc2VkIGZyb20gc3FsaXRlLCB3ZSBoYXZlIG5vIGNvbnRyb2wgb3ZlciB0aGlzLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICAgICAgICAgICAgcmVzb2x2ZShxdWVyeS5faGFuZGxlUXVlcnlSZXNwb25zZSh0aGlzLCBjb2x1bW5UeXBlcywgZXhlY3V0aW9uRXJyb3IsIHJlc3VsdHMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmFtZXRlcnMpIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgY29ublttZXRob2RdKHNxbCwgcGFyYW1ldGVycywgYWZ0ZXJFeGVjdXRlKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmdldERhdGFiYXNlTWV0aG9kKCkgPT09ICdhbGwnKSB7XG4gICAgICAgIGxldCB0YWJsZU5hbWVzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnRhYmxlTmFtZXMpIHtcbiAgICAgICAgICB0YWJsZU5hbWVzID0gdGhpcy5vcHRpb25zLnRhYmxlTmFtZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoL0ZST00gYCguKj8pYC9pLmV4ZWModGhpcy5zcWwpKSB7XG4gICAgICAgICAgdGFibGVOYW1lcy5wdXNoKC9GUk9NIGAoLio/KWAvaS5leGVjKHRoaXMuc3FsKVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1ldGFkYXRhIGZvciB0aGUgdGFibGUsIHRoZXJlJ3Mgbm8gbmVlZCB0byBhc2sgZm9yIGl0IGFnYWluXG4gICAgICAgIHRhYmxlTmFtZXMgPSB0YWJsZU5hbWVzLmZpbHRlcih0YWJsZU5hbWUgPT4gISh0YWJsZU5hbWUgaW4gY29sdW1uVHlwZXMpICYmIHRhYmxlTmFtZSAhPT0gJ3NxbGl0ZV9tYXN0ZXInKTtcblxuICAgICAgICBpZiAoIXRhYmxlTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTcWwoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0YWJsZU5hbWVzLm1hcCh0YWJsZU5hbWUgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS5yZXBsYWNlKC9gL2csICcnKTtcbiAgICAgICAgICAgIGNvbHVtblR5cGVzW3RhYmxlTmFtZV0gPSB7fTtcblxuICAgICAgICAgICAgY29ubi5hbGwoYFBSQUdNQSB0YWJsZV9pbmZvKFxcYCR7dGFibGVOYW1lfVxcYClgLCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgY29sdW1uVHlwZXNbdGFibGVOYW1lXVtyZXN1bHQubmFtZV0gPSByZXN1bHQudHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlU3FsKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgcGFyc2VDb25zdHJhaW50c0Zyb21TcWwoc3FsKSB7XG4gICAgbGV0IGNvbnN0cmFpbnRzID0gc3FsLnNwbGl0KCdDT05TVFJBSU5UICcpO1xuICAgIGxldCByZWZlcmVuY2VUYWJsZU5hbWUsIHJlZmVyZW5jZVRhYmxlS2V5cywgdXBkYXRlQWN0aW9uLCBkZWxldGVBY3Rpb247XG4gICAgY29uc3RyYWludHMuc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubWFwKGNvbnN0cmFpbnRTcWwgPT4ge1xuICAgICAgLy9QYXJzZSBmb3JlaWduIGtleSBzbmlwcGV0c1xuICAgICAgaWYgKGNvbnN0cmFpbnRTcWwuaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICAvL1BhcnNlIG91dCB0aGUgY29uc3RyYWludCBjb25kaXRpb24gZm9ybSBzcWwgc3RyaW5nXG4gICAgICAgIHVwZGF0ZUFjdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL09OIFVQREFURSAoQ0FTQ0FERXxTRVQgTlVMTHxSRVNUUklDVHxOTyBBQ1RJT058U0VUIERFRkFVTFQpezF9Lyk7XG4gICAgICAgIGRlbGV0ZUFjdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL09OIERFTEVURSAoQ0FTQ0FERXxTRVQgTlVMTHxSRVNUUklDVHxOTyBBQ1RJT058U0VUIERFRkFVTFQpezF9Lyk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZUFjdGlvbikge1xuICAgICAgICAgIHVwZGF0ZUFjdGlvbiA9IHVwZGF0ZUFjdGlvblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxldGVBY3Rpb24pIHtcbiAgICAgICAgICBkZWxldGVBY3Rpb24gPSBkZWxldGVBY3Rpb25bMV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWZlcmVuY2VzUmVnZXggPSAvUkVGRVJFTkNFUy4rXFwoKD86W14pKF0rfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqXFwpLztcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlQ29uZGl0aW9ucyA9IGNvbnN0cmFpbnRTcWwubWF0Y2gocmVmZXJlbmNlc1JlZ2V4KVswXS5zcGxpdCgnICcpO1xuICAgICAgICByZWZlcmVuY2VUYWJsZU5hbWUgPSBVdGlscy5yZW1vdmVUaWNrcyhyZWZlcmVuY2VDb25kaXRpb25zWzFdKTtcbiAgICAgICAgbGV0IGNvbHVtbk5hbWVzID0gcmVmZXJlbmNlQ29uZGl0aW9uc1syXTtcbiAgICAgICAgY29sdW1uTmFtZXMgPSBjb2x1bW5OYW1lcy5yZXBsYWNlKC9cXCh8XFwpL2csICcnKS5zcGxpdCgnLCAnKTtcbiAgICAgICAgcmVmZXJlbmNlVGFibGVLZXlzID0gY29sdW1uTmFtZXMubWFwKGNvbHVtbiA9PiBVdGlscy5yZW1vdmVUaWNrcyhjb2x1bW4pKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29uc3RyYWludENvbmRpdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL1xcKCg/OlteKShdK3xcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKlxcKS8pWzBdO1xuICAgICAgY29uc3RyYWludFNxbCA9IGNvbnN0cmFpbnRTcWwucmVwbGFjZSgvXFwoLitcXCkvLCAnJyk7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludFNxbC5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAoY29uc3RyYWludFsxXSA9PT0gJ1BSSU1BUlknIHx8IGNvbnN0cmFpbnRbMV0gPT09ICdGT1JFSUdOJykge1xuICAgICAgICBjb25zdHJhaW50WzFdICs9ICcgS0VZJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RyYWludE5hbWU6IFV0aWxzLnJlbW92ZVRpY2tzKGNvbnN0cmFpbnRbMF0pLFxuICAgICAgICBjb25zdHJhaW50VHlwZTogY29uc3RyYWludFsxXSxcbiAgICAgICAgdXBkYXRlQWN0aW9uLFxuICAgICAgICBkZWxldGVBY3Rpb24sXG4gICAgICAgIHNxbDogc3FsLnJlcGxhY2UoL1wiL2csICdgJyksIC8vU3FsaXRlIHJldHVybnMgZG91YmxlIHF1b3RlcyBmb3IgdGFibGUgbmFtZVxuICAgICAgICBjb25zdHJhaW50Q29uZGl0aW9uLFxuICAgICAgICByZWZlcmVuY2VUYWJsZU5hbWUsXG4gICAgICAgIHJlZmVyZW5jZVRhYmxlS2V5c1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgfVxuXG4gIGFwcGx5UGFyc2Vycyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlLmluY2x1ZGVzKCcoJykpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHBhcnRcbiAgICAgIHR5cGUgPSB0eXBlLnN1YnN0cigwLCB0eXBlLmluZGV4T2YoJygnKSk7XG4gICAgfVxuICAgIHR5cGUgPSB0eXBlLnJlcGxhY2UoJ1VOU0lHTkVEJywgJycpLnJlcGxhY2UoJ1pFUk9GSUxMJywgJycpO1xuICAgIHR5cGUgPSB0eXBlLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHBhcnNlKSB7XG4gICAgICByZXR1cm4gcGFyc2UodmFsdWUsIHsgdGltZXpvbmU6IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZvcm1hdEVycm9yKGVycikge1xuXG4gICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgY2FzZSAnU1FMSVRFX0NPTlNUUkFJTlQnOiB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcygnRk9SRUlHTiBLRVkgY29uc3RyYWludCBmYWlsZWQnKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcblxuICAgICAgICAvLyBTcWxpdGUgcHJlIDIuMiBiZWhhdmlvciAtIEVycm9yOiBTUUxJVEVfQ09OU1RSQUlOVDogY29sdW1ucyB4LCB5IGFyZSBub3QgdW5pcXVlXG4gICAgICAgIGxldCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9jb2x1bW5zICguKj8pIGFyZS8pO1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBmaWVsZHMgPSBtYXRjaFsxXS5zcGxpdCgnLCAnKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIFNxbGl0ZSBwb3N0IDIuMiBiZWhhdmlvciAtIEVycm9yOiBTUUxJVEVfQ09OU1RSQUlOVDogVU5JUVVFIGNvbnN0cmFpbnQgZmFpbGVkOiB0YWJsZS54LCB0YWJsZS55XG4gICAgICAgICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvVU5JUVVFIGNvbnN0cmFpbnQgZmFpbGVkOiAoLiopLyk7XG4gICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSBtYXRjaFsxXS5zcGxpdCgnLCAnKS5tYXAoY29sdW1uV2l0aFRhYmxlID0+IGNvbHVtbldpdGhUYWJsZS5zcGxpdCgnLicpWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBlcnJvcic7XG5cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgICB0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLFxuICAgICAgICAgICAgJ3VuaXF1ZSB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkRCLFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRdLFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAgICdub3RfdW5pcXVlJ1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgICBfLmZvck93bih0aGlzLm1vZGVsLnVuaXF1ZUtleXMsIGNvbnN0cmFpbnQgPT4ge1xuICAgICAgICAgICAgaWYgKF8uaXNFcXVhbChjb25zdHJhaW50LmZpZWxkcywgZmllbGRzKSAmJiAhIWNvbnN0cmFpbnQubXNnKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb25zdHJhaW50Lm1zZztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSAnU1FMSVRFX0JVU1knOlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5UaW1lb3V0RXJyb3IoZXJyKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIC8vIFNxbGl0ZSByZXR1cm5zIGluZGV4ZXMgc28gdGhlIG9uZSB0aGF0IHdhcyBkZWZpbmVkIGxhc3QgaXMgcmV0dXJuZWQgZmlyc3QuIExldHMgcmV2ZXJzZSB0aGF0IVxuICAgIHJldHVybiBQcm9taXNlLmFsbChkYXRhLnJldmVyc2UoKS5tYXAoYXN5bmMgaXRlbSA9PiB7XG4gICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgaXRlbS5wcmltYXJ5ID0gZmFsc2U7XG4gICAgICBpdGVtLnVuaXF1ZSA9ICEhaXRlbS51bmlxdWU7XG4gICAgICBpdGVtLmNvbnN0cmFpbnROYW1lID0gaXRlbS5uYW1lO1xuICAgICAgY29uc3QgY29sdW1ucyA9IGF3YWl0IHRoaXMucnVuKGBQUkFHTUEgSU5ERVhfSU5GTyhcXGAke2l0ZW0ubmFtZX1cXGApYCk7XG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICAgIGl0ZW0uZmllbGRzW2NvbHVtbi5zZXFub10gPSB7XG4gICAgICAgICAgYXR0cmlidXRlOiBjb2x1bW4ubmFtZSxcbiAgICAgICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICBvcmRlcjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pKTtcbiAgfVxuXG4gIGdldERhdGFiYXNlTWV0aG9kKCkge1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSB8fCB0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnQ1JFQVRFIFRFTVBPUkFSWSBUQUJMRScudG9Mb3dlckNhc2UoKSkgfHwgdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURSkge1xuICAgICAgcmV0dXJuICdydW4nO1xuICAgIH1cbiAgICByZXR1cm4gJ2FsbCc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIEEgd3JhcHBlciBmb3IgbXVsdGlwbGUgRXJyb3JzXG4gKlxuICogQHBhcmFtIHtFcnJvcltdfSBbZXJyb3JzXSBBcnJheSBvZiBlcnJvcnNcbiAqXG4gKiBAcHJvcGVydHkgZXJyb3JzIHtFcnJvcltdfVxuICovXG5jbGFzcyBBZ2dyZWdhdGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5uYW1lID0gJ0FnZ3JlZ2F0ZUVycm9yJztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgQWdncmVnYXRlRXJyb3Igb2Y6XFxuJHtcbiAgICAgIHRoaXMuZXJyb3JzLm1hcChlcnJvciA9PlxuICAgICAgICBlcnJvciA9PT0gdGhpc1xuICAgICAgICAgID8gJ1tDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl0nXG4gICAgICAgICAgOiBlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yXG4gICAgICAgICAgICA/IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXFxuJC8sICcnKS5yZXBsYWNlKC9eL21nLCAnICAnKVxuICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL14vbWcsICcgICAgJykuc3Vic3RyaW5nKDIpXG4gICAgICAgIFxuICAgICAgKS5qb2luKCdcXG4nKVxuICAgIH1cXG5gO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGFuIGFzc29jaWF0aW9uIGlzIGltcHJvcGVybHkgY29uc3RydWN0ZWQgKHNlZSBtZXNzYWdlIGZvciBkZXRhaWxzKVxuICovXG5jbGFzcyBBc3NvY2lhdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVBc3NvY2lhdGlvbkVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc29jaWF0aW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2VxdWVsaXplIHByb3ZpZGVzIGEgaG9zdCBvZiBjdXN0b20gZXJyb3IgY2xhc3NlcywgdG8gYWxsb3cgeW91IHRvIGRvIGVhc2llciBkZWJ1Z2dpbmcuIEFsbCBvZiB0aGVzZSBlcnJvcnMgYXJlIGV4cG9zZWQgb24gdGhlIHNlcXVlbGl6ZSBvYmplY3QgYW5kIHRoZSBzZXF1ZWxpemUgY29uc3RydWN0b3IuXG4gKiBBbGwgc2VxdWVsaXplIGVycm9ycyBpbmhlcml0IGZyb20gdGhlIGJhc2UgSlMgZXJyb3Igb2JqZWN0LlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBlcnJvcnMgY2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGBTZXF1ZWxpemUuVmFsaWRhdGlvbkVycm9yYFxuICogVGhlIEJhc2UgRXJyb3IgYWxsIFNlcXVlbGl6ZSBFcnJvcnMgaW5oZXJpdCBmcm9tLlxuICovXG5jbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQmFzZUVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYnVsayBvcGVyYXRpb24gZmFpbHMsIGl0IHJlcHJlc2VudCBwZXIgcmVjb3JkIGxldmVsIGVycm9yLlxuICogVXNlZCB3aXRoIEFnZ3JlZ2F0ZUVycm9yXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gIGVycm9yICAgRXJyb3IgZm9yIGEgZ2l2ZW4gcmVjb3JkL2luc3RhbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVjb3JkICBEQU8gaW5zdGFuY2UgdGhhdCBlcnJvciBiZWxvbmdzIHRvXG4gKi9cbmNsYXNzIEJ1bGtSZWNvcmRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCByZWNvcmQpIHtcbiAgICBzdXBlcihlcnJvci5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQnVsa1JlY29yZEVycm9yJztcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yO1xuICAgIHRoaXMucmVjb3JkID0gcmVjb3JkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVsa1JlY29yZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFsbCBjb25uZWN0aW9uIHJlbGF0ZWQgZXJyb3JzLlxuICovXG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQgPyBwYXJlbnQubWVzc2FnZSA6ICcnKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQ29ubmVjdGlvbkVycm9yJztcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBzcGVjaWZpYyBlcnJvciB3aGljaCB0cmlnZ2VyZWQgdGhpcyBvbmVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtFcnJvcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLm9yaWdpbmFsID0gcGFyZW50O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBpcyByZWZ1c2VkIGR1ZSB0byBpbnN1ZmZpY2llbnQgcHJpdmlsZWdlc1xuICovXG5jbGFzcyBBY2Nlc3NEZW5pZWRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUFjY2Vzc0RlbmllZEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2Vzc0RlbmllZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBjb25uZWN0aW9uIGlzIG5vdCBhY3F1aXJlZCBkdWUgdG8gdGltZW91dFxuICovXG5jbGFzcyBDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBpcyByZWZ1c2VkXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25SZWZ1c2VkRXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVDb25uZWN0aW9uUmVmdXNlZEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25SZWZ1c2VkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIHRpbWVzIG91dFxuICovXG5jbGFzcyBDb25uZWN0aW9uVGltZWRPdXRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUNvbm5lY3Rpb25UaW1lZE91dEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25UaW1lZE91dEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBoYXMgYSBob3N0bmFtZSB0aGF0IHdhcyBub3QgZm91bmRcbiAqL1xuY2xhc3MgSG9zdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVIb3N0Tm90Rm91bmRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIb3N0Tm90Rm91bmRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgaGFzIGEgaG9zdG5hbWUgdGhhdCB3YXMgbm90IHJlYWNoYWJsZVxuICovXG5jbGFzcyBIb3N0Tm90UmVhY2hhYmxlRXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVIb3N0Tm90UmVhY2hhYmxlRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSG9zdE5vdFJlYWNoYWJsZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBoYXMgaW52YWxpZCB2YWx1ZXMgZm9yIGFueSBvZiB0aGUgY29ubmVjdGlvbiBwYXJhbWV0ZXJzXG4gKi9cbmNsYXNzIEludmFsaWRDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVJbnZhbGlkQ29ubmVjdGlvbkVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludmFsaWRDb25uZWN0aW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFiYXNlIHJlbGF0ZWQgZXJyb3JzLlxuICovXG5jbGFzcyBEYXRhYmFzZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50Lm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVEYXRhYmFzZUVycm9yJztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIFNRTCB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcWwgPSBwYXJlbnQuc3FsO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgc3FsIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyZW50LnBhcmFtZXRlcnM7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhYmFzZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhYmFzZUVycm9yID0gcmVxdWlyZSgnLi8uLi9kYXRhYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGFuIGV4Y2x1c2lvbiBjb25zdHJhaW50IGlzIHZpb2xhdGVkIGluIHRoZSBkYXRhYmFzZVxuICovXG5jbGFzcyBFeGNsdXNpb25Db25zdHJhaW50RXJyb3IgZXh0ZW5kcyBEYXRhYmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6ICcnIH07XG5cbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcic7XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCAnJztcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBvcHRpb25zLmNvbnN0cmFpbnQ7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YWJhc2VFcnJvciA9IHJlcXVpcmUoJy4vLi4vZGF0YWJhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQgaW4gdGhlIGRhdGFiYXNlXG4gKi9cbmNsYXNzIEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3IgZXh0ZW5kcyBEYXRhYmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6ICcnIH07XG5cbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3InO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgJ0RhdGFiYXNlIEVycm9yJztcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMucmVsdHlwZSA9IG9wdGlvbnMucmVsdHlwZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFiYXNlRXJyb3IgPSByZXF1aXJlKCcuLy4uL2RhdGFiYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBkYXRhYmFzZSBxdWVyeSB0aW1lcyBvdXQgYmVjYXVzZSBvZiBhIGRlYWRsb2NrXG4gKi9cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIERhdGFiYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVUaW1lb3V0RXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZW91dEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhYmFzZUVycm9yID0gcmVxdWlyZSgnLi8uLi9kYXRhYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGNvbnN0cmFpbnQgbmFtZSBpcyBub3QgZm91bmQgaW4gdGhlIGRhdGFiYXNlXG4gKi9cbmNsYXNzIFVua25vd25Db25zdHJhaW50RXJyb3IgZXh0ZW5kcyBEYXRhYmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6ICcnIH07XG5cbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVVua25vd25Db25zdHJhaW50RXJyb3InO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8ICdUaGUgc3BlY2lmaWVkIGNvbnN0cmFpbnQgZG9lcyBub3QgZXhpc3QnO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG9wdGlvbnMuY29uc3RyYWludDtcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVW5rbm93bkNvbnN0cmFpbnRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gaW5jbHVkZSBzdGF0ZW1lbnQgaXMgaW1wcm9wZXJseSBjb25zdHJ1Y3RlZCAoc2VlIG1lc3NhZ2UgZm9yIGRldGFpbHMpXG4gKi9cbmNsYXNzIEVhZ2VyTG9hZGluZ0Vycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVFYWdlckxvYWRpbmdFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFYWdlckxvYWRpbmdFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSByZWNvcmQgd2FzIG5vdCBmb3VuZCwgVXN1YWxseSB1c2VkIHdpdGggcmVqZWN0T25FbXB0eSBtb2RlIChzZWUgbWVzc2FnZSBmb3IgZGV0YWlscylcbiAqL1xuY2xhc3MgRW1wdHlSZXN1bHRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplRW1wdHlSZXN1bHRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbXB0eVJlc3VsdEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG5leHBvcnRzLkFnZ3JlZ2F0ZUVycm9yID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUtZXJyb3InKTtcbmV4cG9ydHMuQXN5bmNRdWV1ZUVycm9yID0gcmVxdWlyZSgnLi4vZGlhbGVjdHMvbXNzcWwvYXN5bmMtcXVldWUnKS5Bc3luY1F1ZXVlRXJyb3I7XG5leHBvcnRzLkFzc29jaWF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9uLWVycm9yJyk7XG5leHBvcnRzLkJ1bGtSZWNvcmRFcnJvciA9IHJlcXVpcmUoJy4vYnVsay1yZWNvcmQtZXJyb3InKTtcbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLWVycm9yJyk7XG5leHBvcnRzLkRhdGFiYXNlRXJyb3IgPSByZXF1aXJlKCcuL2RhdGFiYXNlLWVycm9yJyk7XG5leHBvcnRzLkVhZ2VyTG9hZGluZ0Vycm9yID0gcmVxdWlyZSgnLi9lYWdlci1sb2FkaW5nLWVycm9yJyk7XG5leHBvcnRzLkVtcHR5UmVzdWx0RXJyb3IgPSByZXF1aXJlKCcuL2VtcHR5LXJlc3VsdC1lcnJvcicpO1xuZXhwb3J0cy5JbnN0YW5jZUVycm9yID0gcmVxdWlyZSgnLi9pbnN0YW5jZS1lcnJvcicpO1xuZXhwb3J0cy5PcHRpbWlzdGljTG9ja0Vycm9yID0gcmVxdWlyZSgnLi9vcHRpbWlzdGljLWxvY2stZXJyb3InKTtcbmV4cG9ydHMuUXVlcnlFcnJvciA9IHJlcXVpcmUoJy4vcXVlcnktZXJyb3InKTtcbmV4cG9ydHMuU2VxdWVsaXplU2NvcGVFcnJvciA9IHJlcXVpcmUoJy4vc2VxdWVsaXplLXNjb3BlLWVycm9yJyk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbi1lcnJvcicpO1xuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3JJdGVtID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbTtcblxuZXhwb3J0cy5BY2Nlc3NEZW5pZWRFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yJyk7XG5leHBvcnRzLkNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yJyk7XG5leHBvcnRzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yJyk7XG5leHBvcnRzLkNvbm5lY3Rpb25UaW1lZE91dEVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tdGltZWQtb3V0LWVycm9yJyk7XG5leHBvcnRzLkhvc3ROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2hvc3Qtbm90LWZvdW5kLWVycm9yJyk7XG5leHBvcnRzLkhvc3ROb3RSZWFjaGFibGVFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3InKTtcbmV4cG9ydHMuSW52YWxpZENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3InKTtcblxuZXhwb3J0cy5FeGNsdXNpb25Db25zdHJhaW50RXJyb3IgPSByZXF1aXJlKCcuL2RhdGFiYXNlL2V4Y2x1c2lvbi1jb25zdHJhaW50LWVycm9yJyk7XG5leHBvcnRzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3IgPSByZXF1aXJlKCcuL2RhdGFiYXNlL2ZvcmVpZ24ta2V5LWNvbnN0cmFpbnQtZXJyb3InKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gcmVxdWlyZSgnLi9kYXRhYmFzZS90aW1lb3V0LWVycm9yJyk7XG5leHBvcnRzLlVua25vd25Db25zdHJhaW50RXJyb3IgPSByZXF1aXJlKCcuL2RhdGFiYXNlL3Vua25vd24tY29uc3RyYWludC1lcnJvcicpO1xuXG5leHBvcnRzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvciA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNvbWUgcHJvYmxlbSBvY2N1cnJlZCB3aXRoIEluc3RhbmNlIG1ldGhvZHMgKHNlZSBtZXNzYWdlIGZvciBkZXRhaWxzKVxuICovXG5jbGFzcyBJbnN0YW5jZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVJbnN0YW5jZUVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluc3RhbmNlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgc3RhbGUgbW9kZWwgaW5zdGFuY2VcbiAqL1xuY2xhc3MgT3B0aW1pc3RpY0xvY2tFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgYEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgc3RhbGUgbW9kZWwgaW5zdGFuY2U6ICR7b3B0aW9ucy5tb2RlbE5hbWV9YDtcbiAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVPcHRpbWlzdGljTG9ja0Vycm9yJztcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgb24gd2hpY2ggdGhlIHVwZGF0ZSB3YXMgYXR0ZW1wdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kZWxOYW1lID0gb3B0aW9ucy5tb2RlbE5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlcyBvZiB0aGUgYXR0ZW1wdGVkIHVwZGF0ZVxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLndoZXJlID0gb3B0aW9ucy53aGVyZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wdGltaXN0aWNMb2NrRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgcXVlcnkgaXMgcGFzc2VkIGludmFsaWQgb3B0aW9ucyAoc2VlIG1lc3NhZ2UgZm9yIGRldGFpbHMpXG4gKi9cbmNsYXNzIFF1ZXJ5RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVF1ZXJ5RXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnlFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogU2NvcGUgRXJyb3IuIFRocm93biB3aGVuIHRoZSBzZXF1ZWxpemUgY2Fubm90IHF1ZXJ5IHRoZSBzcGVjaWZpZWQgc2NvcGUuXG4gKi9cbmNsYXNzIFNlcXVlbGl6ZVNjb3BlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVTY29wZUVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcXVlbGl6ZVNjb3BlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gRXJyb3IuIFRocm93biB3aGVuIHRoZSBzZXF1ZWxpemUgdmFsaWRhdGlvbiBoYXMgZmFpbGVkLiBUaGUgZXJyb3IgY29udGFpbnMgYW4gYGVycm9yc2AgcHJvcGVydHksXG4gKiB3aGljaCBpcyBhbiBhcnJheSB3aXRoIDEgb3IgbW9yZSBWYWxpZGF0aW9uRXJyb3JJdGVtcywgb25lIGZvciBlYWNoIHZhbGlkYXRpb24gdGhhdCBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtBcnJheX0gW2Vycm9yc10gQXJyYXkgb2YgVmFsaWRhdGlvbkVycm9ySXRlbSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHZhbGlkYXRpb24gZXJyb3JzXG4gKlxuICogQHByb3BlcnR5IGVycm9ycyB7VmFsaWRhdGlvbkVycm9ySXRlbXNbXX1cbiAqL1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVZhbGlkYXRpb25FcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1ZhbGlkYXRpb24gRXJyb3InO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge1ZhbGlkYXRpb25FcnJvckl0ZW1bXX1cbiAgICAgKi9cbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycyB8fCBbXTtcblxuICAgIC8vIFVzZSBwcm92aWRlZCBlcnJvciBtZXNzYWdlIGlmIGF2YWlsYWJsZS4uLlxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gICAgICAvLyAuLi4gb3RoZXJ3aXNlIGNyZWF0ZSBhIGNvbmNhdGVuYXRlZCBtZXNzYWdlIG91dCBvZiBleGlzdGluZyBlcnJvcnMuXG4gICAgfSBlbHNlIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwICYmIHRoaXMuZXJyb3JzWzBdLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuZXJyb3JzLm1hcChlcnIgPT4gYCR7ZXJyLnR5cGUgfHwgZXJyLm9yaWdpbn06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbignLFxcbicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB2YWxpZGF0aW9uIGVycm9yIGl0ZW1zIGZvciB0aGUgcGF0aCAvIGZpZWxkIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gYmUgY2hlY2tlZCBmb3IgZXJyb3IgaXRlbXNcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5PFZhbGlkYXRpb25FcnJvckl0ZW0+fSBWYWxpZGF0aW9uIGVycm9yIGl0ZW1zIGZvciB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICovXG4gIGdldChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JzLnJlZHVjZSgocmVkdWNlZCwgZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvci5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgIHJlZHVjZWQucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICB9LCBbXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0aW9uIEVycm9yIEl0ZW1cbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYFZhbGlkYXRpb25FcnJvci5lcnJvcnNgIHByb3BlcnR5LlxuICovXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3JJdGVtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmFsaWRhdGlvbkVycm9yIGl0ZW0uIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYFZhbGlkYXRpb25FcnJvci5lcnJvcnNgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIEFuIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUaGUgdHlwZS9vcmlnaW4gb2YgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoXSBUaGUgZmllbGQgdGhhdCB0cmlnZ2VyZWQgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gVGhlIHZhbHVlIHRoYXQgZ2VuZXJhdGVkIHRoZSBlcnJvclxuICAgKiBAcGFyYW0ge01vZGVsfSBbaW5zdGFuY2VdIHRoZSBEQU8gaW5zdGFuY2UgdGhhdCBjYXVzZWQgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0b3JLZXldIGEgdmFsaWRhdGlvbiBcImtleVwiLCB1c2VkIGZvciBpZGVudGlmaWNhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZuTmFtZV0gcHJvcGVydHkgbmFtZSBvZiB0aGUgQlVJTFQtSU4gdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgY2F1c2VkIHRoZSB2YWxpZGF0aW9uIGVycm9yIChlLmcuIFwiaW5cIiBvciBcImxlblwiKSwgaWYgYXBwbGljYWJsZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbZm5BcmdzXSBwYXJhbWV0ZXJzIHVzZWQgd2l0aCB0aGUgQlVJTFQtSU4gdmFsaWRhdG9yIGZ1bmN0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlLCBwYXRoLCB2YWx1ZSwgaW5zdGFuY2UsIHZhbGlkYXRvcktleSwgZm5OYW1lLCBmbkFyZ3MpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlL29yaWdpbiBvZiB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0aGF0IHRyaWdnZXJlZCB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHRoYXQgZ2VuZXJhdGVkIHRoZSBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IG51bGw7XG5cbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgREFPIGluc3RhbmNlIHRoYXQgY2F1c2VkIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TW9kZWwgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSB2YWxpZGF0aW9uIFwia2V5XCIsIHVzZWQgZm9yIGlkZW50aWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRvcktleSA9IHZhbGlkYXRvcktleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgbmFtZSBvZiB0aGUgQlVJTFQtSU4gdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgY2F1c2VkIHRoZSB2YWxpZGF0aW9uIGVycm9yIChlLmcuIFwiaW5cIiBvciBcImxlblwiKSwgaWYgYXBwbGljYWJsZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3JOYW1lID0gZm5OYW1lIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXJzIHVzZWQgd2l0aCB0aGUgQlVJTFQtSU4gdmFsaWRhdG9yIGZ1bmN0aW9uLCBpZiBhcHBsaWNhYmxlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3JBcmdzID0gZm5BcmdzIHx8IFtdO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnNbIHR5cGUgXSkge1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VUeXBlID0gYCR7dHlwZX1gLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBjb25zdCByZWFsVHlwZSA9IFZhbGlkYXRpb25FcnJvckl0ZW0uVHlwZVN0cmluZ01hcFsgbG93ZXJjYXNlVHlwZSBdO1xuXG4gICAgICAgIGlmIChyZWFsVHlwZSAmJiBWYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnNbIHJlYWxUeXBlIF0pIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbiA9IHJlYWxUeXBlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGRvZXNuJ3QgbmVlZCBjYXB0dXJlU3RhY2tUcmFjZSBiZWNhdXNlIGl0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgRXJyb3JcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gYSBsb3dlcmNhc2UsIHRyaW1tZWQgc3RyaW5nIFwia2V5XCIgdGhhdCBpZGVudGlmaWVzIHRoZSB2YWxpZGF0b3IuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBzdHJpbmcgd2lsbCBiZSBlbXB0eSBpZiB0aGUgaW5zdGFuY2UgaGFzIG5laXRoZXIgYSB2YWxpZCBgdmFsaWRhdG9yS2V5YCBwcm9wZXJ0eSBub3IgYSB2YWxpZCBgdmFsaWRhdG9yTmFtZWAgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtICAge2Jvb2xlYW59IFt1c2VUeXBlQXNOUz10cnVlXSAgICAgIGNvbnRyb2xzIHdoZXRoZXIgdGhlIHJldHVybmVkIHZhbHVlIGlzIFwibmFtZXNwYWNlXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkIGlmIHRoZSB2YWxpZGF0b3IncyBgdHlwZWAgaXMgbm90IG9uZSBvZiBWYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnNcbiAgICogQHBhcmFtICAge3N0cmluZ30gIFtOU1NlcGFyYXRvcj0nLiddICAgICAgIGEgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29uY2F0ZW5hdGluZyB0aGUgbmFtZXNwYWNlLCBtdXN0IGJlIG5vdCBiZSBlbXB0eSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIFwiLlwiIChmdWxsc3RvcCkuIG9ubHkgdXNlZCBhbmQgdmFsaWRhdGVkIGlmIHVzZVR5cGVBc05TIGlzIFRSVUUuXG4gICAqIEB0aHJvd3MgIHtFcnJvcn0gICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd24gaWYgTlNTZXBhcmF0b3IgaXMgZm91bmQgdG8gYmUgaW52YWxpZC5cbiAgICogQHJldHVybnMgIHtzdHJpbmd9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRWYWxpZGF0b3JLZXkodXNlVHlwZUFzTlMsIE5TU2VwYXJhdG9yKSB7XG4gICAgY29uc3QgdXNlVEFOUyA9IHVzZVR5cGVBc05TID09PSB1bmRlZmluZWQgfHwgISF1c2VUeXBlQXNOUztcbiAgICBjb25zdCBOU1NlcCA9IE5TU2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLicgOiBOU1NlcGFyYXRvcjtcblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLm9yaWdpbjtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnZhbGlkYXRvcktleSB8fCB0aGlzLnZhbGlkYXRvck5hbWU7XG4gICAgY29uc3QgdXNlTlMgPSB1c2VUQU5TICYmIHR5cGUgJiYgVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zWyB0eXBlIF07XG5cbiAgICBpZiAodXNlTlMgJiYgKHR5cGVvZiBOU1NlcCAhPT0gJ3N0cmluZycgfHwgIU5TU2VwLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuYW1lc3BhY2Ugc2VwYXJhdG9yIGdpdmVuLCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICh1c2VOUyA/IFt0eXBlLCBrZXldLmpvaW4oTlNTZXApIDoga2V5KS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW0gdGhhdCBkZWZpbmVzIHZhbGlkIFZhbGlkYXRpb25FcnJvckl0ZW0gYG9yaWdpbmAgdmFsdWVzXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSBDT1JFICAgICAgIHtzdHJpbmd9ICBzcGVjaWZpZXMgZXJyb3JzIHRoYXQgb3JpZ2luYXRlIGZyb20gdGhlIHNlcXVlbGl6ZSBcImNvcmVcIlxuICogQHByb3BlcnR5IERCICAgICAgICAge3N0cmluZ30gIHNwZWNpZmllcyB2YWxpZGF0aW9uIGVycm9ycyB0aGF0IG9yaWdpbmF0ZSBmcm9tIHRoZSBzdG9yYWdlIGVuZ2luZVxuICogQHByb3BlcnR5IEZVTkNUSU9OICAge3N0cmluZ30gIHNwZWNpZmllcyB2YWxpZGF0aW9uIGVycm9ycyB0aGF0IG9yaWdpbmF0ZSBmcm9tIHZhbGlkYXRvciBmdW5jdGlvbnMgKGJvdGggYnVpbHQtaW4gYW5kIGN1c3RvbSkgZGVmaW5lZCBmb3IgYSBnaXZlbiBhdHRyaWJ1dGVcbiAqL1xuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zID0ge1xuICBDT1JFOiAnQ09SRScsXG4gIERCOiAnREInLFxuICBGVU5DVElPTjogJ0ZVTkNUSU9OJ1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGBWYWxpZGF0aW9uRXJyb3JJdGVtYCBjbGFzc1xuICogdGhhdCBtYXBzIGN1cnJlbnQgYHR5cGVgIHN0cmluZ3MgKGFzIGdpdmVuIHRvIFZhbGlkYXRpb25FcnJvckl0ZW0uY29uc3RydWN0b3IoKSkgdG9cbiAqIG91ciBuZXcgYG9yaWdpbmAgdmFsdWVzLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cblZhbGlkYXRpb25FcnJvckl0ZW0uVHlwZVN0cmluZ01hcCA9IHtcbiAgJ25vdG51bGwgdmlvbGF0aW9uJzogJ0NPUkUnLFxuICAnc3RyaW5nIHZpb2xhdGlvbic6ICdDT1JFJyxcbiAgJ3VuaXF1ZSB2aW9sYXRpb24nOiAnREInLFxuICAndmFsaWRhdGlvbiBlcnJvcic6ICdGVU5DVElPTidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMuVmFsaWRhdGlvbkVycm9ySXRlbSA9IFZhbGlkYXRpb25FcnJvckl0ZW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vdmFsaWRhdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgdW5pcXVlIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQgaW4gdGhlIGRhdGFiYXNlXG4gKi9cbmNsYXNzIFVuaXF1ZUNvbnN0cmFpbnRFcnJvciBleHRlbmRzIFZhbGlkYXRpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiAnJyB9O1xuICAgIG9wdGlvbnMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8ICdWYWxpZGF0aW9uIEVycm9yJztcbiAgICBvcHRpb25zLmVycm9ycyA9IG9wdGlvbnMuZXJyb3JzIHx8IHt9O1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSwgb3B0aW9ucy5lcnJvcnMpO1xuXG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVVuaXF1ZUNvbnN0cmFpbnRFcnJvcic7XG4gICAgdGhpcy5lcnJvcnMgPSBvcHRpb25zLmVycm9ycztcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy5vcmlnaW5hbCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuc3FsID0gb3B0aW9ucy5wYXJlbnQuc3FsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlQ29uc3RyYWludEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnaG9va3MnKTtcblxuY29uc3QgaG9va1R5cGVzID0ge1xuICBiZWZvcmVWYWxpZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJWYWxpZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgdmFsaWRhdGlvbkZhaWxlZDogeyBwYXJhbXM6IDMgfSxcbiAgYmVmb3JlQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlckNyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlRGVzdHJveTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJEZXN0cm95OiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVSZXN0b3JlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclJlc3RvcmU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVVwZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJVcGRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVNhdmU6IHsgcGFyYW1zOiAyLCBwcm94aWVzOiBbJ2JlZm9yZVVwZGF0ZScsICdiZWZvcmVDcmVhdGUnXSB9LFxuICBhZnRlclNhdmU6IHsgcGFyYW1zOiAyLCBwcm94aWVzOiBbJ2FmdGVyVXBkYXRlJywgJ2FmdGVyQ3JlYXRlJ10gfSxcbiAgYmVmb3JlVXBzZXJ0OiB7IHBhcmFtczogMiB9LFxuICBhZnRlclVwc2VydDogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQnVsa0NyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJCdWxrQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVCdWxrRGVzdHJveTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrRGVzdHJveTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1Jlc3RvcmU6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1Jlc3RvcmU6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtVcGRhdGU6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa1VwZGF0ZTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRmluZEFmdGVyT3B0aW9uczogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJGaW5kOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVDb3VudDogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlRGVmaW5lOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckRlZmluZTogeyBwYXJhbXM6IDEsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlSW5pdDogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJJbml0OiB7IHBhcmFtczogMSwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVBc3NvY2lhdGU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlIH0sXG4gIGFmdGVyQXNzb2NpYXRlOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSB9LFxuICBiZWZvcmVDb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckNvbm5lY3Q6IHsgcGFyYW1zOiAyLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZURpc2Nvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyRGlzY29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJTeW5jOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlUXVlcnk6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyUXVlcnk6IHsgcGFyYW1zOiAyIH1cbn07XG5leHBvcnRzLmhvb2tzID0gaG9va1R5cGVzO1xuXG5cbi8qKlxuICogZ2V0IGFycmF5IG9mIGN1cnJlbnQgaG9vayBhbmQgaXRzIHByb3hpZXMgY29tYmluZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9va1R5cGUgYW55IGhvb2sgdHlwZSBAc2VlIHtAbGluayBob29rVHlwZXN9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0UHJveGllZEhvb2tzID0gaG9va1R5cGUgPT5cbiAgaG9va1R5cGVzW2hvb2tUeXBlXS5wcm94aWVzXG4gICAgPyBob29rVHlwZXNbaG9va1R5cGVdLnByb3hpZXMuY29uY2F0KGhvb2tUeXBlKVxuICAgIDogW2hvb2tUeXBlXVxuO1xuXG5mdW5jdGlvbiBnZXRIb29rcyhob29rZWQsIGhvb2tUeXBlKSB7XG4gIHJldHVybiAoaG9va2VkLm9wdGlvbnMuaG9va3MgfHwge30pW2hvb2tUeXBlXSB8fCBbXTtcbn1cblxuY29uc3QgSG9va3MgPSB7XG4gIC8qKlxuICAgKiBQcm9jZXNzIHVzZXIgc3VwcGxpZWQgaG9va3MgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaG9va3MgaG9va3MgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAgICovXG4gIF9zZXR1cEhvb2tzKGhvb2tzKSB7XG4gICAgdGhpcy5vcHRpb25zLmhvb2tzID0ge307XG4gICAgXy5tYXAoaG9va3MgfHwge30sIChob29rc0FycmF5LCBob29rTmFtZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhvb2tzQXJyYXkpKSBob29rc0FycmF5ID0gW2hvb2tzQXJyYXldO1xuICAgICAgaG9va3NBcnJheS5mb3JFYWNoKGhvb2tGbiA9PiB0aGlzLmFkZEhvb2soaG9va05hbWUsIGhvb2tGbikpO1xuICAgIH0pO1xuICB9LFxuXG4gIGFzeW5jIHJ1bkhvb2tzKGhvb2tzLCAuLi5ob29rQXJncykge1xuICAgIGlmICghaG9va3MpIHRocm93IG5ldyBFcnJvcigncnVuSG9va3MgcmVxdWlyZXMgYXQgbGVhc3QgMSBhcmd1bWVudCcpO1xuXG4gICAgbGV0IGhvb2tUeXBlO1xuXG4gICAgaWYgKHR5cGVvZiBob29rcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhvb2tUeXBlID0gaG9va3M7XG4gICAgICBob29rcyA9IGdldEhvb2tzKHRoaXMsIGhvb2tUeXBlKTtcblxuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplKSB7XG4gICAgICAgIGhvb2tzID0gaG9va3MuY29uY2F0KGdldEhvb2tzKHRoaXMuc2VxdWVsaXplLCBob29rVHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShob29rcykpIHtcbiAgICAgIGhvb2tzID0gW2hvb2tzXTtcbiAgICB9XG5cbiAgICAvLyBzeW5jaHJvbm91cyBob29rc1xuICAgIGlmIChob29rVHlwZXNbaG9va1R5cGVdICYmIGhvb2tUeXBlc1tob29rVHlwZV0uc3luYykge1xuICAgICAgZm9yIChsZXQgaG9vayBvZiBob29rcykge1xuICAgICAgICBpZiAodHlwZW9mIGhvb2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaG9vayA9IGhvb2suZm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZyhgcnVubmluZyBob29rKHN5bmMpICR7aG9va1R5cGV9YCk7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgaG9va0FyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFzeW5jaHJvbm91cyBob29rcyAoZGVmYXVsdClcbiAgICBmb3IgKGxldCBob29rIG9mIGhvb2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGhvb2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGhvb2sgPSBob29rLmZuO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhgcnVubmluZyBob29rICR7aG9va1R5cGV9YCk7XG4gICAgICBhd2FpdCBob29rLmFwcGx5KHRoaXMsIGhvb2tBcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhIGhvb2sgdG8gdGhlIG1vZGVsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBob29rVHlwZSBob29rIG5hbWUgQHNlZSB7QGxpbmsgaG9va1R5cGVzfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gW25hbWVdIFByb3ZpZGUgYSBuYW1lIGZvciB0aGUgaG9vayBmdW5jdGlvbi4gSXQgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBob29rIGxhdGVyIG9yIHRvIG9yZGVyIGhvb2tzIGJhc2VkIG9uIHNvbWUgc29ydCBvZiBwcmlvcml0eSBzeXN0ZW0gaW4gdGhlIGZ1dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgIGZuIFRoZSBob29rIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICAgKi9cbiAgYWRkSG9vayhob29rVHlwZSwgbmFtZSwgZm4pIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuID0gbmFtZTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGRlYnVnKGBhZGRpbmcgaG9vayAke2hvb2tUeXBlfWApO1xuICAgIC8vIGNoZWNrIGZvciBwcm94aWVzLCBhZGQgdGhlbSB0b29cbiAgICBob29rVHlwZSA9IGdldFByb3hpZWRIb29rcyhob29rVHlwZSk7XG5cbiAgICBob29rVHlwZS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3QgaG9va3MgPSBnZXRIb29rcyh0aGlzLCB0eXBlKTtcbiAgICAgIGhvb2tzLnB1c2gobmFtZSA/IHsgbmFtZSwgZm4gfSA6IGZuKTtcbiAgICAgIHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXSA9IGhvb2tzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBob29rIGZyb20gdGhlIG1vZGVsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rVHlwZSBAc2VlIHtAbGluayBob29rVHlwZXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBuYW1lIG5hbWUgb2YgaG9vayBvciBmdW5jdGlvbiByZWZlcmVuY2Ugd2hpY2ggd2FzIGF0dGFjaGVkXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICAgKi9cbiAgcmVtb3ZlSG9vayhob29rVHlwZSwgbmFtZSkge1xuICAgIGNvbnN0IGlzUmVmZXJlbmNlID0gdHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaGFzSG9vayhob29rVHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRlYnVnKGByZW1vdmluZyBob29rICR7aG9va1R5cGV9YCk7XG5cbiAgICAvLyBjaGVjayBmb3IgcHJveGllcywgYWRkIHRoZW0gdG9vXG4gICAgaG9va1R5cGUgPSBnZXRQcm94aWVkSG9va3MoaG9va1R5cGUpO1xuXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGhvb2tUeXBlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0gPSB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0uZmlsdGVyKGhvb2sgPT4ge1xuICAgICAgICBpZiAoaXNSZWZlcmVuY2UgJiYgdHlwZW9mIGhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaG9vayAhPT0gbmFtZTsgLy8gY2hlY2sgaWYgc2FtZSBtZXRob2RcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVmZXJlbmNlICYmIHR5cGVvZiBob29rID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiBob29rLm5hbWUgIT09IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgbW9kZSBoYXMgYW55IGhvb2tzIG9mIHRoaXMgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9va1R5cGUgQHNlZSB7QGxpbmsgaG9va1R5cGVzfVxuICAgKlxuICAgKiBAYWxpYXMgaGFzSG9va3NcbiAgICpcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gICAqL1xuICBoYXNIb29rKGhvb2tUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ob29rc1tob29rVHlwZV0gJiYgISF0aGlzLm9wdGlvbnMuaG9va3NbaG9va1R5cGVdLmxlbmd0aDtcbiAgfVxufTtcbkhvb2tzLmhhc0hvb2tzID0gSG9va3MuaGFzSG9vaztcblxuXG5mdW5jdGlvbiBhcHBseVRvKHRhcmdldCwgaXNNb2RlbCA9IGZhbHNlKSB7XG4gIF8ubWl4aW4odGFyZ2V0LCBIb29rcyk7XG5cbiAgZm9yIChjb25zdCBob29rIG9mIE9iamVjdC5rZXlzKGhvb2tUeXBlcykpIHtcbiAgICBpZiAoaXNNb2RlbCAmJiBob29rVHlwZXNbaG9va10ubm9Nb2RlbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhcmdldFtob29rXSA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRIb29rKGhvb2ssIG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG59XG5leHBvcnRzLmFwcGx5VG8gPSBhcHBseVRvO1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgdmFsaWRhdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVWYWxpZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJWYWxpZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIHdoZW4gdmFsaWRhdGlvbiBmYWlsc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zLCBlcnJvci4gRXJyb3IgaXMgdGhlXG4gKiBTZXF1ZWxpemVWYWxpZGF0aW9uRXJyb3IuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IsIGl0IHdpbGwgcmVwbGFjZSB0aGUgb3JpZ2luYWwgdmFsaWRhdGlvbiBlcnJvci5cbiAqIEBuYW1lIHZhbGlkYXRpb25GYWlsZWRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgY3JlYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVDcmVhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBjcmVhdGluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyQ3JlYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGNyZWF0aW5nIG9yIHVwZGF0aW5nIGEgc2luZ2xlIGluc3RhbmNlLCBJdCBwcm94aWVzIGBiZWZvcmVDcmVhdGVgIGFuZCBgYmVmb3JlVXBkYXRlYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZVNhdmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgdXBzZXJ0aW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlVXBzZXJ0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgdXBzZXJ0aW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIHJlc3VsdCBvZiB1cHNlcnQoKSwgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJVcHNlcnRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAgKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgY3JlYXRpbmcgb3IgdXBkYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2UsIEl0IHByb3hpZXMgYGFmdGVyQ3JlYXRlYCBhbmQgYGFmdGVyVXBkYXRlYFxuICpcbiAgKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICAqIEBuYW1lIGFmdGVyU2F2ZVxuICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAgKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGRlc3Ryb3lpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICpcbiAqIEBuYW1lIGJlZm9yZURlc3Ryb3lcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBkZXN0cm95aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBhZnRlckRlc3Ryb3lcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgcmVzdG9yaW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBiZWZvcmVSZXN0b3JlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgcmVzdG9yaW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBhZnRlclJlc3RvcmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgdXBkYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlVXBkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgdXBkYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJVcGRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgY3JlYXRpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUJ1bGtDcmVhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBjcmVhdGluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlcywgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJCdWxrQ3JlYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGRlc3Ryb3lpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKlxuICogQG5hbWUgYmVmb3JlQnVsa0Rlc3Ryb3lcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBkZXN0cm95aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICpcbiAqIEBuYW1lIGFmdGVyQnVsa0Rlc3Ryb3lcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgcmVzdG9yaW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICpcbiAqIEBuYW1lIGJlZm9yZUJ1bGtSZXN0b3JlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgcmVzdG9yaW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICpcbiAqIEBuYW1lIGFmdGVyQnVsa1Jlc3RvcmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgdXBkYXRpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVCdWxrVXBkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgdXBkYXRpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlckJ1bGtVcGRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBmaW5kIChzZWxlY3QpIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlRmluZFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGZpbmQgKHNlbGVjdCkgcXVlcnksIGFmdGVyIGFueSB7IGluY2x1ZGU6IHthbGw6IC4uLn0gfSBvcHRpb25zIGFyZSBleHBhbmRlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGxcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBmaW5kIChzZWxlY3QpIHF1ZXJ5LCBhZnRlciBhbGwgb3B0aW9uIHBhcnNpbmcgaXMgY29tcGxldGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgYSBmaW5kIChzZWxlY3QpIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UocyksIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyRmluZFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGNvdW50IHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlQ291bnRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBkZWZpbmUgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZURlZmluZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGEgZGVmaW5lIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBmYWN0b3J5XG4gKiBAbmFtZSBhZnRlckRlZmluZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBTZXF1ZWxpemUoKSBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggY29uZmlnLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVJbml0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgU2VxdWVsaXplKCkgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHNlcXVlbGl6ZVxuICogQG5hbWUgYWZ0ZXJJbml0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgY29ubmVjdGlvbiBpcyBjcmVhdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggY29uZmlnIHBhc3NlZCB0byBjb25uZWN0aW9uXG4gKiBAbmFtZSBiZWZvcmVDb25uZWN0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGNyZWF0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCB0aGUgY29ubmVjdGlvbiBvYmplY3QgYW5kIHRoZSBjb25maWcgcGFzc2VkIHRvIGNvbm5lY3Rpb25cbiAqIEBuYW1lIGFmdGVyQ29ubmVjdFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGNvbm5lY3Rpb24gb2JqZWN0XG4gKiBAbmFtZSBiZWZvcmVEaXNjb25uZWN0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uIG9iamVjdFxuICogQG5hbWUgYWZ0ZXJEaXNjb25uZWN0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIE1vZGVsLnN5bmMgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIE1vZGVsLnN5bmNcbiAqIEBuYW1lIGJlZm9yZVN5bmNcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBNb2RlbC5zeW5jIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zIHBhc3NlZCB0byBNb2RlbC5zeW5jXG4gKiBAbmFtZSBhZnRlclN5bmNcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAgKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIHNlcXVlbGl6ZS5zeW5jIGNhbGxcbiAqXG4gICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIHNlcXVlbGl6ZS5zeW5jXG4gICogQG5hbWUgYmVmb3JlQnVsa1N5bmNcbiAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICovXG5cbi8qKlxuICAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBzZXF1ZWxpemUuc3luYyBjYWxsXG4gKlxuICAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zIHBhc3NlZCB0byBzZXF1ZWxpemUuc3luY1xuICAqIEBuYW1lIGFmdGVyQnVsa1N5bmNcbiAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gZW51bSBvZiBpbmRleCBoaW50cyB0byBiZSB1c2VkIGluIG15c3FsIGZvciBxdWVyeWluZyB3aXRoIGluZGV4IGhpbnRzXG4gKlxuICogQHByb3BlcnR5IFVTRVxuICogQHByb3BlcnR5IEZPUkNFXG4gKiBAcHJvcGVydHkgSUdOT1JFXG4gKi9cbmNvbnN0IEluZGV4SGludHMgPSBtb2R1bGUuZXhwb3J0cyA9IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBVU0U6ICdVU0UnLFxuICBGT1JDRTogJ0ZPUkNFJyxcbiAgSUdOT1JFOiAnSUdOT1JFJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGEtdHlwZXMnKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8nKTtcbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhcycpLnZhbGlkYXRvcjtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogSW5zdGFuY2UgVmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7SW5zdGFuY2V9IG1vZGVsSW5zdGFuY2UgVGhlIG1vZGVsIGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQSBkaWN0aW9uYXJ5IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBJbnN0YW5jZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLy8gYXNzaWduIGRlZmluZWQgYW5kIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmZpZWxkcyAmJiAhb3B0aW9ucy5za2lwKSB7XG4gICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXMobW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSwgb3B0aW9ucy5maWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMubW9kZWxJbnN0YW5jZSA9IG1vZGVsSW5zdGFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VzIGEgcmVmZXJlbmNlIHRvIHZhbGlkYXRvci5qcy4gVGhpcyBhbGxvd3MgeW91IHRvIGFkZCBjdXN0b20gdmFsaWRhdGlvbnMgdXNpbmcgYHZhbGlkYXRvci5leHRlbmRgXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWxpZGF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuXG4gICAgLyoqXG4gICAgICogIEFsbCBlcnJvcnMgd2lsbCBiZSBzdG9yZWQgaGVyZSBmcm9tIHRoZSB2YWxpZGF0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheX0gV2lsbCBjb250YWluIGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIGF0dHJpYnV0ZXMgd2hpY2ggd2lsbFxuICAgICAqICAgYmUgQXJyYXlzIG9mIEVycm9ycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHZhbGlkYXRpb25zIGFyZSBpbiBwcm9ncmVzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pblByb2dyZXNzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBWYWxpZGF0aW9uIG1vZHVsZSwgaW52b2tlIHRvIHN0YXJ0IHRoZSBkYW5jZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfdmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaW5Qcm9ncmVzcykgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0aW9ucyBhbHJlYWR5IGluIHByb2dyZXNzLicpO1xuXG4gICAgdGhpcy5pblByb2dyZXNzID0gdHJ1ZTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKSxcbiAgICAgIHRoaXMuX2N1c3RvbVZhbGlkYXRvcnMoKVxuICAgIF0pO1xuXG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvcihudWxsLCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSB0aGUgVmFsaWRhdGlvbiBzZXF1ZW5jZSBhbmQgcnVuIHZhbGlkYXRpb24gaG9va3MgaWYgZGVmaW5lZFxuICAgKiAgIC0gQmVmb3JlIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcbiAgICogICAtIFZhbGlkYXRpb25cbiAgICogICAtIE9uIHZhbGlkYXRpb24gc3VjY2VzczogQWZ0ZXIgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBmYWlsdXJlOiBWYWxpZGF0aW9uIEZhaWxlZCBNb2RlbCBIb29rc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiBhd2FpdCAodGhpcy5vcHRpb25zLmhvb2tzID8gdGhpcy5fdmFsaWRhdGVBbmRSdW5Ib29rcygpIDogdGhpcy5fdmFsaWRhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIHRoZSBWYWxpZGF0aW9uIHNlcXVlbmNlIGFuZCBydW4gaG9va3NcbiAgICogICAtIEJlZm9yZSBWYWxpZGF0aW9uIE1vZGVsIEhvb2tzXG4gICAqICAgLSBWYWxpZGF0aW9uXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIHN1Y2Nlc3M6IEFmdGVyIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcbiAgICogICAtIE9uIHZhbGlkYXRpb24gZmFpbHVyZTogVmFsaWRhdGlvbiBGYWlsZWQgTW9kZWwgSG9va3NcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfdmFsaWRhdGVBbmRSdW5Ib29rcygpIHtcbiAgICBjb25zdCBydW5Ib29rcyA9IHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5ydW5Ib29rcy5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgYXdhaXQgcnVuSG9va3MoJ2JlZm9yZVZhbGlkYXRlJywgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG5ld0Vycm9yID0gYXdhaXQgcnVuSG9va3MoJ3ZhbGlkYXRpb25GYWlsZWQnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3RXJyb3IgfHwgZXJyb3I7XG4gICAgfVxuXG4gICAgYXdhaXQgcnVuSG9va3MoJ2FmdGVyVmFsaWRhdGUnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxJbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHJ1biBhbGwgdGhlIHZhbGlkYXRvcnMgZGVmaW5lZCBwZXIgYXR0cmlidXRlIChidWlsdC1pbiB2YWxpZGF0b3JzIGFuZCBjdXN0b20gdmFsaWRhdG9ycylcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKSB7XG4gICAgLy8gcHJvbWlzaWZ5IGFsbCBhdHRyaWJ1dGUgaW52b2NhdGlvbnNcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG5cbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS5yYXdBdHRyaWJ1dGVzLCAocmF3QXR0cmlidXRlLCBmaWVsZCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tb2RlbEluc3RhbmNlLmRhdGFWYWx1ZXNbZmllbGRdO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJhd0F0dHJpYnV0ZS5fYXV0b0dlbmVyYXRlZCAmJiAhcmF3QXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgLy8gcGVyZm9ybSB2YWxpZGF0aW9ucyBiYXNlZCBvbiBzY2hlbWFcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzLCBmaWVsZCkpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIHJhd0F0dHJpYnV0ZS5hbGxvd051bGwpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZGF0b3JzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHJ1biBhbGwgdGhlIGN1c3RvbSB2YWxpZGF0b3JzIGRlZmluZWQgaW4gdGhlIG1vZGVsJ3Mgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2N1c3RvbVZhbGlkYXRvcnMoKSB7XG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgIF8uZWFjaCh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy52YWxpZGF0ZSwgKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKHZhbGlkYXRvclR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFscHJvbSA9IHRoaXMuX2ludm9rZUN1c3RvbVZhbGlkYXRvcih2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUpXG4gICAgICAgIC8vIGVycm9ycyBhcmUgaGFuZGxlZCBpbiBzZXR0bGluZywgc3R1YiB0aGlzXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICAgIHZhbGlkYXRvcnMucHVzaCh2YWxwcm9tKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZGF0b3JzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHNpbmdsZSBhdHRyaWJ1dGUgd2l0aCBhbGwgdGhlIGRlZmluZWQgYnVpbHQtaW4gdmFsaWRhdG9ycyBhbmQgY3VzdG9tIHZhbGlkYXRvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55dGhpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd051bGwgV2hldGhlciBvciBub3QgdGhlIHNjaGVtYSBhbGxvd3MgbnVsbCB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSwgd2lsbCBhbHdheXMgcmVzb2x2ZSwgYXV0byBwb3B1bGF0ZXMgZXJyb3Igb24gdGhpcy5lcnJvciBsb2NhbCBvYmplY3QuXG4gICAqL1xuICBhc3luYyBfc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgYWxsb3dOdWxsKSB7XG4gICAgLy8gSWYgdmFsdWUgaXMgbnVsbCBhbmQgYWxsb3dOdWxsIGlzIGZhbHNlLCBubyB2YWxpZGF0b3JzIHNob3VsZCBydW4gKHNlZSAjOTE0MylcbiAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpICYmICFhbGxvd051bGwpIHtcbiAgICAgIC8vIFRoZSBzY2hlbWEgdmFsaWRhdG9yIChfdmFsaWRhdGVTY2hlbWEpIGhhcyBhbHJlYWR5IGdlbmVyYXRlZCB0aGUgdmFsaWRhdGlvbiBlcnJvci4gTm90aGluZyB0byBkbyBoZXJlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb21pc2lmeSBlYWNoIHZhbGlkYXRvclxuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzW2ZpZWxkXSwgKHRlc3QsIHZhbGlkYXRvclR5cGUpID0+IHtcblxuICAgICAgaWYgKHZhbGlkYXRvclR5cGUgPT09ICdpc1VybCcgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzVVJMJyB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNFbWFpbCcpIHtcbiAgICAgICAgLy8gUHJlc2VydmUgYmFja3dhcmRzIGNvbXBhdC4gVmFsaWRhdG9yLmpzIG5vdyBleHBlY3RzIHRoZSBzZWNvbmQgcGFyYW0gdG8gaXNVUkwgYW5kIGlzRW1haWwgdG8gYmUgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ29iamVjdCcgJiYgdGVzdCAhPT0gbnVsbCAmJiB0ZXN0Lm1zZykge1xuICAgICAgICAgIHRlc3QgPSB7XG4gICAgICAgICAgICBtc2c6IHRlc3QubXNnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGVzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEN1c3RvbSB2YWxpZGF0b3JzIHNob3VsZCBhbHdheXMgcnVuLCBleGNlcHQgaWYgdmFsdWUgaXMgbnVsbCBhbmQgYWxsb3dOdWxsIGlzIGZhbHNlIChzZWUgIzkxNDMpXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX2ludm9rZUN1c3RvbVZhbGlkYXRvcih0ZXN0LCB2YWxpZGF0b3JUeXBlLCB0cnVlLCB2YWx1ZSwgZmllbGQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB2YWx1ZSBpcyBudWxsLCBidWlsdC1pbiB2YWxpZGF0b3JzIHNob3VsZCBub3QgcnVuIChvbmx5IGN1c3RvbSB2YWxpZGF0b3JzIGhhdmUgdG8gcnVuKSAoc2VlICM5MTM0KS5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdG9yUHJvbWlzZSA9IHRoaXMuX2ludm9rZUJ1aWx0aW5WYWxpZGF0b3IodmFsdWUsIHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcbiAgICAgIC8vIGVycm9ycyBhcmUgaGFuZGxlZCBpbiBzZXR0bGluZywgc3R1YiB0aGlzXG4gICAgICB2YWxpZGF0b3JQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh2YWxpZGF0b3JQcm9taXNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlXG4gICAgICAuYWxsKHZhbGlkYXRvcnMubWFwKHZhbGlkYXRvciA9PiB2YWxpZGF0b3IuY2F0Y2gocmVqZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgaXNCdWlsdEluID0gISFyZWplY3Rpb24udmFsaWRhdG9yTmFtZTtcbiAgICAgICAgdGhpcy5fcHVzaEVycm9yKGlzQnVpbHRJbiwgZmllbGQsIHJlamVjdGlvbiwgdmFsdWUsIHJlamVjdGlvbi52YWxpZGF0b3JOYW1lLCByZWplY3Rpb24udmFsaWRhdG9yQXJncyk7XG4gICAgICB9KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW5kIGludm9rZSBhIGN1c3RvbSB2YWxpZGF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbGlkYXRvciBUaGUgY3VzdG9tIHZhbGlkYXRvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgdGhlIGN1c3RvbSB2YWxpZGF0b3IgdHlwZSAobmFtZSkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0QXR0ckRlZmluZWQgU2V0IHRvIHRydWUgaWYgY3VzdG9tIHZhbGlkYXRvciB3YXMgZGVmaW5lZCBmcm9tIHRoZSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHsqfSBvcHRWYWx1ZSB2YWx1ZSBmb3IgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRGaWVsZCBmaWVsZCBmb3IgYXR0cmlidXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UuXG4gICAqL1xuICBhc3luYyBfaW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSwgb3B0QXR0ckRlZmluZWQsIG9wdFZhbHVlLCBvcHRGaWVsZCkge1xuICAgIGxldCBpc0FzeW5jID0gZmFsc2U7XG5cbiAgICBjb25zdCB2YWxpZGF0b3JBcml0eSA9IHZhbGlkYXRvci5sZW5ndGg7XG4gICAgLy8gY2hlY2sgaWYgdmFsaWRhdG9yIGlzIGFzeW5jIGFuZCByZXF1aXJlcyBhIGNhbGxiYWNrXG4gICAgbGV0IGFzeW5jQXJpdHkgPSAxO1xuICAgIGxldCBlcnJvcktleSA9IHZhbGlkYXRvclR5cGU7XG4gICAgbGV0IGludm9rZUFyZ3M7XG4gICAgaWYgKG9wdEF0dHJEZWZpbmVkKSB7XG4gICAgICBhc3luY0FyaXR5ID0gMjtcbiAgICAgIGludm9rZUFyZ3MgPSBvcHRWYWx1ZTtcbiAgICAgIGVycm9yS2V5ID0gb3B0RmllbGQ7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0b3JBcml0eSA9PT0gYXN5bmNBcml0eSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkodmFsaWRhdG9yLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KHZhbGlkYXRvci5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZSkpKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXJyb3IoZmFsc2UsIGVycm9yS2V5LCBlLCBvcHRWYWx1ZSwgdmFsaWRhdG9yVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB2YWxpZGF0b3IuY2FsbCh0aGlzLm1vZGVsSW5zdGFuY2UsIGludm9rZUFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoRXJyb3IoZmFsc2UsIGVycm9yS2V5LCBlLCBvcHRWYWx1ZSwgdmFsaWRhdG9yVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW5kIGludm9rZSBhIGJ1aWxkLWluIHZhbGlkYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnl0aGluZy5cbiAgICogQHBhcmFtIHsqfSB0ZXN0IFRoZSB0ZXN0IGNhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JUeXBlIE9uZSBvZiBrbm93biB0byBTZXF1ZWxpemUgdmFsaWRhdG9ycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBzcGVjaWZpYyBrZXlzIHRvIGludm9rZSB0aGUgdmFsaWRhdG9yLlxuICAgKi9cbiAgYXN5bmMgX2ludm9rZUJ1aWx0aW5WYWxpZGF0b3IodmFsdWUsIHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKSB7XG4gICAgLy8gQ2FzdCB2YWx1ZSBhcyBzdHJpbmcgdG8gcGFzcyBuZXcgVmFsaWRhdG9yLmpzIHN0cmluZyByZXF1aXJlbWVudFxuICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcbiAgICAvLyBjaGVjayBpZiBWYWxpZGF0b3Iga25vd3MgdGhhdCBraW5kIG9mIHZhbGlkYXRpb24gdGVzdFxuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uOiAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRhdG9yQXJncyA9IHRoaXMuX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcblxuICAgIGlmICghdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdKHZhbHVlU3RyaW5nLCAuLi52YWxpZGF0b3JBcmdzKSkge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGVzdC5tc2cgfHwgYFZhbGlkYXRpb24gJHt2YWxpZGF0b3JUeXBlfSBvbiAke2ZpZWxkfSBmYWlsZWRgKSwgeyB2YWxpZGF0b3JOYW1lOiB2YWxpZGF0b3JUeXBlLCB2YWxpZGF0b3JBcmdzIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGV4dHJhY3QgYXJndW1lbnRzIGZvciB0aGUgdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHRlc3QgVGhlIHRlc3QgY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgT25lIG9mIGtub3duIHRvIFNlcXVlbGl6ZSB2YWxpZGF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2V4dHJhY3RWYWxpZGF0b3JBcmdzKHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKSB7XG4gICAgbGV0IHZhbGlkYXRvckFyZ3MgPSB0ZXN0LmFyZ3MgfHwgdGVzdDtcbiAgICBjb25zdCBpc0xvY2FsaXplZFZhbGlkYXRvciA9IHR5cGVvZiB2YWxpZGF0b3JBcmdzICE9PSAnc3RyaW5nJyAmJiAodmFsaWRhdG9yVHlwZSA9PT0gJ2lzQWxwaGEnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc0FscGhhbnVtZXJpYycgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzTW9iaWxlUGhvbmUnKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JBcmdzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvclR5cGUgPT09ICdpc0ltbXV0YWJsZScpIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFt2YWxpZGF0b3JBcmdzLCBmaWVsZCwgdGhpcy5tb2RlbEluc3RhbmNlXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbGl6ZWRWYWxpZGF0b3IgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzSVAnKSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvckFyZ3MgPSBbdmFsaWRhdG9yQXJnc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRvckFyZ3MgPSB2YWxpZGF0b3JBcmdzLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yQXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHZhbGlkYXRlIGEgc2luZ2xlIGZpZWxkIGFnYWluc3QgaXRzIHNjaGVtYSBkZWZpbml0aW9uIChpc251bGwpLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmF3QXR0cmlidXRlIEFzIGRlZmluZWQgaW4gdGhlIFNjaGVtYS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIGFueXRoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlU2NoZW1hKHJhd0F0dHJpYnV0ZSwgZmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKHJhd0F0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpLmZpbmQoYXNzb2NpYXRpb24gPT4gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gJiYgYXNzb2NpYXRpb24uZm9yZWlnbktleSA9PT0gcmF3QXR0cmlidXRlLmZpZWxkTmFtZSk7XG4gICAgICBpZiAoIWFzc29jaWF0aW9uIHx8ICF0aGlzLm1vZGVsSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3IpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSB0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9yc1tmaWVsZF07XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IF8uZ2V0KHZhbGlkYXRvcnMsICdub3ROdWxsLm1zZycsIGAke3RoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lfS4ke2ZpZWxkfSBjYW5ub3QgYmUgbnVsbGApO1xuXG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgZXJyTXNnLFxuICAgICAgICAgICdub3ROdWxsIFZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5DT1JFLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMubW9kZWxJbnN0YW5jZSxcbiAgICAgICAgICAnaXNfbnVsbCdcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlNUUklORyB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5URVhUIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkNJVEVYVCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IF8uaXNPYmplY3QodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgYCR7ZmllbGR9IGNhbm5vdCBiZSBhbiBhcnJheSBvciBhbiBvYmplY3RgLFxuICAgICAgICAgICdzdHJpbmcgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkNPUkUsXG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy5tb2RlbEluc3RhbmNlLFxuICAgICAgICAgICdub3RfYV9zdHJpbmcnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhbGwgZXJyb3JzIHJldGFpbmluZyB0aGUgb3JpZ2luYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgaXNCdWlsdGluICAgLSBEZXRlcm1pbmVzIGlmIGVycm9yIGlzIGZyb20gYnVpbHRpbiB2YWxpZGF0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgZXJyb3JLZXkgICAgLSBuYW1lIG9mIGludmFsaWQgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0ge0Vycm9yfHN0cmluZ30gIHJhd0Vycm9yICAgIC0gVGhlIG9yaWdpbmFsIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlICAgICAgIC0gVGhlIGRhdGEgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIGZuTmFtZSAgICAgIC0gTmFtZSBvZiB0aGUgdmFsaWRhdG9yLCBpZiBhbnlcbiAgICogQHBhcmFtIHtBcnJheX0gICAgICAgICBmbkFyZ3MgICAgICAtIEFyZ3VtZW50cyBmb3IgdGhlIHZhbGlkYXRvciBbZnVuY3Rpb25dLCBpZiBhbnlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wdXNoRXJyb3IoaXNCdWlsdGluLCBlcnJvcktleSwgcmF3RXJyb3IsIHZhbHVlLCBmbk5hbWUsIGZuQXJncykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSByYXdFcnJvci5tZXNzYWdlIHx8IHJhd0Vycm9yIHx8ICdWYWxpZGF0aW9uIGVycm9yJztcbiAgICBjb25zdCBlcnJvciA9IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgbWVzc2FnZSxcbiAgICAgICdWYWxpZGF0aW9uIGVycm9yJywgLy8gc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkZVTkNUSU9OLFxuICAgICAgZXJyb3JLZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIHRoaXMubW9kZWxJbnN0YW5jZSxcbiAgICAgIGZuTmFtZSxcbiAgICAgIGlzQnVpbHRpbiA/IGZuTmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgIGlzQnVpbHRpbiA/IGZuQXJncyA6IHVuZGVmaW5lZFxuICAgICk7XG5cbiAgICBlcnJvcltJbnN0YW5jZVZhbGlkYXRvci5SQVdfS0VZX05BTUVdID0gcmF3RXJyb3I7XG5cbiAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgZXJyb3Iga2V5IGZvciBhcmd1bWVudHMgYXMgcGFzc2VkIGJ5IGN1c3RvbSB2YWxpZGF0b3JzXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkluc3RhbmNlVmFsaWRhdG9yLlJBV19LRVlfTkFNRSA9ICdvcmlnaW5hbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zdGFuY2VWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5JbnN0YW5jZVZhbGlkYXRvciA9IEluc3RhbmNlVmFsaWRhdG9yO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEluc3RhbmNlVmFsaWRhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUb3Bvc29ydCA9IHJlcXVpcmUoJ3RvcG9zb3J0LWNsYXNzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNsYXNzIE1vZGVsTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gIH1cblxuICBhZGRNb2RlbChtb2RlbCkge1xuICAgIHRoaXMubW9kZWxzLnB1c2gobW9kZWwpO1xuICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsc1ttb2RlbC5uYW1lXSA9IG1vZGVsO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgcmVtb3ZlTW9kZWwobW9kZWxUb1JlbW92ZSkge1xuICAgIHRoaXMubW9kZWxzID0gdGhpcy5tb2RlbHMuZmlsdGVyKG1vZGVsID0+IG1vZGVsLm5hbWUgIT09IG1vZGVsVG9SZW1vdmUubmFtZSk7XG5cbiAgICBkZWxldGUgdGhpcy5zZXF1ZWxpemUubW9kZWxzW21vZGVsVG9SZW1vdmUubmFtZV07XG4gIH1cblxuICBnZXRNb2RlbChhZ2FpbnN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xuICAgICAgYXR0cmlidXRlOiAnbmFtZSdcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLm1vZGVscy5maW5kKG1vZGVsID0+IG1vZGVsW29wdGlvbnMuYXR0cmlidXRlXSA9PT0gYWdhaW5zdCk7XG4gIH1cblxuICBnZXQgYWxsKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgTW9kZWxzIGluIGFuIG9yZGVyIHN1aXRhYmxlIGZvciBlLmcuIGNyZWF0aW5nIHRhYmxlcy5cbiAgICogV2lsbCB0YWtlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIGludG8gYWNjb3VudCBzbyB0aGF0IGRlcGVuZGVuY2llcyBhcmUgdmlzaXRlZCBiZWZvcmUgZGVwZW5kZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3IgbWV0aG9kIHRvIGV4ZWN1dGUgb24gZWFjaCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvckVhY2hNb2RlbChpdGVyYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZGVscyA9IHt9O1xuICAgIGNvbnN0IHNvcnRlciA9IG5ldyBUb3Bvc29ydCgpO1xuICAgIGxldCBzb3J0ZWQ7XG4gICAgbGV0IGRlcDtcblxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbHMpIHtcbiAgICAgIGxldCBkZXBzID0gW107XG4gICAgICBsZXQgdGFibGVOYW1lID0gbW9kZWwuZ2V0VGFibGVOYW1lKCk7XG5cbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsc1t0YWJsZU5hbWVdID0gbW9kZWw7XG5cbiAgICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF0dHJOYW1lKSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBkZXAgPSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbDtcblxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoZGVwKSkge1xuICAgICAgICAgICAgICBkZXAgPSBgJHtkZXAuc2NoZW1hfS4ke2RlcC50YWJsZU5hbWV9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlcHMgPSBkZXBzLmZpbHRlcihkZXAgPT4gdGFibGVOYW1lICE9PSBkZXApO1xuXG4gICAgICBzb3J0ZXIuYWRkKHRhYmxlTmFtZSwgZGVwcyk7XG4gICAgfVxuXG4gICAgc29ydGVkID0gc29ydGVyLnNvcnQoKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBzb3J0ZWQgPSBzb3J0ZWQucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkKSB7XG4gICAgICBpdGVyYXRvcihtb2RlbHNbbmFtZV0sIG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLk1vZGVsTWFuYWdlciA9IE1vZGVsTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBNb2RlbE1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgRG90dGllID0gcmVxdWlyZSgnZG90dGllJyk7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvJyk7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55Jyk7XG5jb25zdCBJbnN0YW5jZVZhbGlkYXRvciA9IHJlcXVpcmUoJy4vaW5zdGFuY2UtdmFsaWRhdG9yJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi9xdWVyeS10eXBlcycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvYmFzZScpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2hhcy1tYW55Jyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGEtdHlwZXMnKTtcbmNvbnN0IEhvb2tzID0gcmVxdWlyZSgnLi9ob29rcycpO1xuY29uc3QgYXNzb2NpYXRpb25zTWl4aW4gPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9taXhpbicpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuL29wZXJhdG9ycycpO1xuY29uc3QgeyBub0RvdWJsZU5lc3RlZEdyb3VwIH0gPSByZXF1aXJlKCcuL3V0aWxzL2RlcHJlY2F0aW9ucycpO1xuXG5cbi8vIFRoaXMgbGlzdCB3aWxsIHF1aWNrbHkgYmVjb21lIGRhdGVkLCBidXQgZmFpbGluZyB0byBtYWludGFpbiB0aGlzIGxpc3QganVzdCBtZWFuc1xuLy8gd2Ugd29uJ3QgdGhyb3cgYSB3YXJuaW5nIHdoZW4gd2Ugc2hvdWxkLiBBdCBsZWFzdCBtb3N0IGNvbW1vbiBjYXNlcyB3aWxsIGZvcmV2ZXIgYmUgY292ZXJlZFxuLy8gc28gd2Ugc3RvcCB0aHJvd2luZyBlcnJvbmVvdXMgd2FybmluZ3Mgd2hlbiB3ZSBzaG91bGRuJ3QuXG5jb25zdCB2YWxpZFF1ZXJ5S2V5d29yZHMgPSBuZXcgU2V0KFsnd2hlcmUnLCAnYXR0cmlidXRlcycsICdwYXJhbm9pZCcsICdpbmNsdWRlJywgJ29yZGVyJywgJ2xpbWl0JywgJ29mZnNldCcsXG4gICd0cmFuc2FjdGlvbicsICdsb2NrJywgJ3JhdycsICdsb2dnaW5nJywgJ2JlbmNobWFyaycsICdoYXZpbmcnLCAnc2VhcmNoUGF0aCcsICdyZWplY3RPbkVtcHR5JywgJ3BsYWluJyxcbiAgJ3Njb3BlJywgJ2dyb3VwJywgJ3Rocm91Z2gnLCAnZGVmYXVsdHMnLCAnZGlzdGluY3QnLCAncHJpbWFyeScsICdleGNlcHRpb24nLCAndHlwZScsICdob29rcycsICdmb3JjZScsXG4gICduYW1lJ10pO1xuXG4vLyBMaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgbm90IGJlIGltcGxpY2l0bHkgcGFzc2VkIGludG8gc3VicXVlcmllcy9pbmNsdWRlcy5cbmNvbnN0IG5vbkNhc2NhZGluZ09wdGlvbnMgPSBbJ2luY2x1ZGUnLCAnYXR0cmlidXRlcycsICdvcmlnaW5hbEF0dHJpYnV0ZXMnLCAnb3JkZXInLCAnd2hlcmUnLCAnbGltaXQnLCAnb2Zmc2V0JywgJ3BsYWluJywgJ2dyb3VwJywgJ2hhdmluZyddO1xuXG4vKipcbiAqIEEgTW9kZWwgcmVwcmVzZW50cyBhIHRhYmxlIGluIHRoZSBkYXRhYmFzZS4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgZGF0YWJhc2Ugcm93LlxuICpcbiAqIE1vZGVsIGluc3RhbmNlcyBvcGVyYXRlIHdpdGggdGhlIGNvbmNlcHQgb2YgYSBgZGF0YVZhbHVlc2AgcHJvcGVydHksIHdoaWNoIHN0b3JlcyB0aGUgYWN0dWFsIHZhbHVlcyByZXByZXNlbnRlZCBieSB0aGUgaW5zdGFuY2UuXG4gKiBCeSBkZWZhdWx0LCB0aGUgdmFsdWVzIGZyb20gZGF0YVZhbHVlcyBjYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIHRoZSBJbnN0YW5jZSwgdGhhdCBpczpcbiAqIGBgYGpzXG4gKiBpbnN0YW5jZS5maWVsZFxuICogLy8gaXMgdGhlIHNhbWUgYXNcbiAqIGluc3RhbmNlLmdldCgnZmllbGQnKVxuICogLy8gaXMgdGhlIHNhbWUgYXNcbiAqIGluc3RhbmNlLmdldERhdGFWYWx1ZSgnZmllbGQnKVxuICogYGBgXG4gKiBIb3dldmVyLCBpZiBnZXR0ZXJzIGFuZC9vciBzZXR0ZXJzIGFyZSBkZWZpbmVkIGZvciBgZmllbGRgIHRoZXkgd2lsbCBiZSBpbnZva2VkLCBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGUgdmFsdWUgZnJvbSBgZGF0YVZhbHVlc2AuXG4gKiBBY2Nlc3NpbmcgcHJvcGVydGllcyBkaXJlY3RseSBvciB1c2luZyBgZ2V0YCBpcyBwcmVmZXJyZWQgZm9yIHJlZ3VsYXIgdXNlLCBgZ2V0RGF0YVZhbHVlYCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjdXN0b20gZ2V0dGVycy5cbiAqXG4gKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUjZGVmaW5lfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gKiBAbWl4ZXMgSG9va3NcbiAqL1xuY2xhc3MgTW9kZWwge1xuICBzdGF0aWMgZ2V0IHF1ZXJ5SW50ZXJmYWNlKCkge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBxdWVyeUdlbmVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUludGVyZmFjZS5xdWVyeUdlbmVyYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgc2VxdWVsaXplIGluc3RhbmNlXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZX1cbiAgICpcbiAgICogQHByb3BlcnR5IHNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplfVxuICAgKi9cbiAgZ2V0IHNlcXVlbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zZXF1ZWxpemU7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgbmV3IG1vZGVsIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFt2YWx1ZXM9e31dIGFuIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc10gaW5zdGFuY2UgY29uc3RydWN0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yYXc9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB2YWx1ZXMgd2lsbCBpZ25vcmUgZmllbGQgYW5kIHZpcnR1YWwgc2V0dGVycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc05ld1JlY29yZD10cnVlXSBJcyB0aGlzIGEgbmV3IHJlY29yZFxuICAgKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmluY2x1ZGVdIGFuIGFycmF5IG9mIGluY2x1ZGUgb3B0aW9ucyAtIFVzZWQgdG8gYnVpbGQgcHJlZmV0Y2hlZC9pbmNsdWRlZCBtb2RlbCBpbnN0YW5jZXMuIFNlZSBgc2V0YFxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWVzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBpc05ld1JlY29yZDogdHJ1ZSxcbiAgICAgIF9zY2hlbWE6IHRoaXMuY29uc3RydWN0b3IuX3NjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHRoaXMuY29uc3RydWN0b3IuX3NjaGVtYURlbGltaXRlcixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcChhdHRyaWJ1dGUgPT4gQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpID8gYXR0cmlidXRlWzFdIDogYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhVmFsdWVzID0ge307XG4gICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0ge307XG4gICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGluc3RhbmNlIGhhcyBub3QgeWV0IGJlZW4gcGVyc2lzdGVkIHRvIHRoZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlzTmV3UmVjb3JkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc05ld1JlY29yZCA9IG9wdGlvbnMuaXNOZXdSZWNvcmQ7XG5cbiAgICB0aGlzLl9pbml0VmFsdWVzKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cblxuICBfaW5pdFZhbHVlcyh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmYXVsdHM7XG4gICAgbGV0IGtleTtcblxuICAgIHZhbHVlcyA9IHsgLi4udmFsdWVzIH07XG5cbiAgICBpZiAob3B0aW9ucy5pc05ld1JlY29yZCkge1xuICAgICAgZGVmYXVsdHMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc0RlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgZGVmYXVsdHMgPSBfLm1hcFZhbHVlcyh0aGlzLmNvbnN0cnVjdG9yLl9kZWZhdWx0VmFsdWVzLCB2YWx1ZUZuID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlRm4oKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgPyB2YWx1ZSA6IF8uY2xvbmVEZWVwKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBpZCB0byBudWxsIGlmIG5vdCBwYXNzZWQgYXMgdmFsdWUsIGEgbmV3bHkgY3JlYXRlZCBkYW8gaGFzIG5vIGlkXG4gICAgICAvLyByZW1vdmluZyB0aGlzIGJyZWFrcyBidWxrQ3JlYXRlXG4gICAgICAvLyBkbyBhZnRlciBkZWZhdWx0IHZhbHVlcyBzaW5jZSBpdCBtaWdodCBoYXZlIFVVSUQgYXMgYSBkZWZhdWx0IHZhbHVlXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5mb3JFYWNoKHByaW1hcnlLZXlBdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRzLCBwcmltYXJ5S2V5QXR0cmlidXRlKSkge1xuICAgICAgICAgICAgZGVmYXVsdHNbcHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgICB9XG5cbiAgICAgIGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1trZXldLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldCh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzIHNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSB0aGlzIG1ldGhvZFxuICBzdGF0aWMgX3BhcmFub2lkQ2xhdXNlKG1vZGVsLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBBcHBseSBvbiBlYWNoIGluY2x1ZGVcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBoYW5kbGVkIGJlZm9yZSBoYW5kbGluZyB3aGVyZSBjb25kaXRpb25zIGJlY2F1c2Ugb2YgbG9naWMgd2l0aCByZXR1cm5zXG4gICAgLy8gb3RoZXJ3aXNlIHRoaXMgY29kZSB3aWxsIG5ldmVyIHJ1biBvbiBpbmNsdWRlcyBvZiBhIGFscmVhZHkgY29uZGl0aW9uYWJsZSB3aGVyZVxuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fcGFyYW5vaWRDbGF1c2UoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgcGFyYW5vaWQgd2hlbiBncm91cGVkTGltaXQgaXMgdXNlZFxuICAgIGlmIChfLmdldChvcHRpb25zLCAnZ3JvdXBlZExpbWl0Lm9uLm9wdGlvbnMucGFyYW5vaWQnKSkge1xuICAgICAgY29uc3QgdGhyb3VnaE1vZGVsID0gXy5nZXQob3B0aW9ucywgJ2dyb3VwZWRMaW1pdC5vbi50aHJvdWdoLm1vZGVsJyk7XG4gICAgICBpZiAodGhyb3VnaE1vZGVsKSB7XG4gICAgICAgIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2ggPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aHJvdWdoTW9kZWwsIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbW9kZWwub3B0aW9ucy50aW1lc3RhbXBzIHx8ICFtb2RlbC5vcHRpb25zLnBhcmFub2lkIHx8IG9wdGlvbnMucGFyYW5vaWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIG1vZGVsIGlzIG5vdCBwYXJhbm9pZCwgbm90aGluZyB0byBkbyBoZXJlO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXRPYmplY3QgPSB7fTtcblxuICAgIGxldCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcblxuICAgIGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSB8fCB7XG4gICAgICBbT3AuZXFdOiBudWxsXG4gICAgfTtcblxuICAgIGRlbGV0ZWRBdE9iamVjdFtkZWxldGVkQXRBdHRyaWJ1dGUuZmllbGQgfHwgZGVsZXRlZEF0Q29sXSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChVdGlscy5pc1doZXJlRW1wdHkob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSBkZWxldGVkQXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB7IFtPcC5hbmRdOiBbZGVsZXRlZEF0T2JqZWN0LCBvcHRpb25zLndoZXJlXSB9O1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgc3RhdGljIF9hZGREZWZhdWx0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCB0YWlsID0ge307XG4gICAgbGV0IGhlYWQgPSB7fTtcblxuICAgIC8vIEFkZCBpZCBpZiBubyBwcmltYXJ5IGtleSB3YXMgbWFudWFsbHkgYWRkZWQgdG8gZGVmaW5pdGlvblxuICAgIC8vIENhbid0IHVzZSB0aGlzLnByaW1hcnlLZXlzIGhlcmUsIHNpbmNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJlZm9yZSBQS3MgYXJlIGlkZW50aWZpZWRcbiAgICBpZiAoIV8uc29tZSh0aGlzLnJhd0F0dHJpYnV0ZXMsICdwcmltYXJ5S2V5JykpIHtcbiAgICAgIGlmICgnaWQnIGluIHRoaXMucmF3QXR0cmlidXRlcykge1xuICAgICAgICAvLyBTb21ldGhpbmcgaXMgZmlzaHkgaGVyZSFcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGNvbHVtbiBjYWxsZWQgJ2lkJyB3YXMgYWRkZWQgdG8gdGhlIGF0dHJpYnV0ZXMgb2YgJyR7dGhpcy50YWJsZU5hbWV9JyBidXQgbm90IG1hcmtlZCB3aXRoICdwcmltYXJ5S2V5OiB0cnVlJ2ApO1xuICAgICAgfVxuXG4gICAgICBoZWFkID0ge1xuICAgICAgICBpZDoge1xuICAgICAgICAgIHR5cGU6IG5ldyBEYXRhVHlwZXMuSU5URUdFUigpLFxuICAgICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgICAgcHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlLFxuICAgICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgIHRhaWxbdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZV0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5JTlRFR0VSLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDAsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1Jhd0F0dHJpYnV0ZXMgPSB7XG4gICAgICAuLi5oZWFkLFxuICAgICAgLi4udGhpcy5yYXdBdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBfLmVhY2godGFpbCwgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBpZiAobmV3UmF3QXR0cmlidXRlc1thdHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1Jhd0F0dHJpYnV0ZXNbYXR0cl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmF3QXR0cmlidXRlcyA9IG5ld1Jhd0F0dHJpYnV0ZXM7XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMucHJpbWFyeUtleXMpLmxlbmd0aCkge1xuICAgICAgdGhpcy5wcmltYXJ5S2V5cy5pZCA9IHRoaXMucmF3QXR0cmlidXRlcy5pZDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2ZpbmRBdXRvSW5jcmVtZW50QXR0cmlidXRlKCkge1xuICAgIHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IG51bGw7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucmF3QXR0cmlidXRlcywgbmFtZSkpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEluc3RhbmNlIGRlZmluaXRpb24uIE9ubHkgb25lIGF1dG9pbmNyZW1lbnQgZmllbGQgYWxsb3dlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHNlbGYpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSkgcmV0dXJuO1xuXG4gICAgLy8gaWYgaW5jbHVkZSBpcyBub3QgYW4gYXJyYXksIHdyYXAgaW4gYW4gYXJyYXlcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlKSkge1xuICAgICAgb3B0aW9ucy5pbmNsdWRlID0gW29wdGlvbnMuaW5jbHVkZV07XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMuaW5jbHVkZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFsbCBpbmNsdWRlZCBlbGVtZW50cyB0byB7IG1vZGVsOiBNb2RlbCB9IGZvcm1cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUubWFwKGluY2x1ZGUgPT4gdGhpcy5fY29uZm9ybUluY2x1ZGUoaW5jbHVkZSwgc2VsZikpO1xuICB9XG5cbiAgc3RhdGljIF90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLCBzZWxmKSB7XG4gICAgaWYgKHNlbGYgJiYgdHlwZW9mIGluY2x1ZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLmFzc29jaWF0aW9ucywgaW5jbHVkZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NvY2lhdGlvbiB3aXRoIGFsaWFzIFwiJHtpbmNsdWRlfVwiIGRvZXMgbm90IGV4aXN0IG9uICR7c2VsZi5uYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYXNzb2NpYXRpb25zW2luY2x1ZGVdO1xuICAgIH1cbiAgICByZXR1cm4gaW5jbHVkZTtcbiAgfVxuXG4gIHN0YXRpYyBfY29uZm9ybUluY2x1ZGUoaW5jbHVkZSwgc2VsZikge1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBsZXQgbW9kZWw7XG5cbiAgICAgIGlmIChpbmNsdWRlLl9wc2V1ZG8pIHJldHVybiBpbmNsdWRlO1xuXG4gICAgICBpbmNsdWRlID0gdGhpcy5fdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZSwgc2VsZik7XG5cbiAgICAgIGlmIChpbmNsdWRlIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgaWYgKHNlbGYgJiYgaW5jbHVkZS50YXJnZXQubmFtZSA9PT0gc2VsZi5uYW1lKSB7XG4gICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLnNvdXJjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbW9kZWwsIGFzc29jaWF0aW9uOiBpbmNsdWRlLCBhczogaW5jbHVkZS5hcyB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZS5wcm90b3R5cGUgJiYgaW5jbHVkZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICByZXR1cm4geyBtb2RlbDogaW5jbHVkZSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGluY2x1ZGUpKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgaW5jbHVkZS5hc3NvY2lhdGlvbiA9IHRoaXMuX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUuYXNzb2NpYXRpb24sIHNlbGYpO1xuXG4gICAgICAgICAgaWYgKHNlbGYgJiYgaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW5jbHVkZS5tb2RlbCkgaW5jbHVkZS5tb2RlbCA9IG1vZGVsO1xuICAgICAgICAgIGlmICghaW5jbHVkZS5hcykgaW5jbHVkZS5hcyA9IGluY2x1ZGUuYXNzb2NpYXRpb24uYXM7XG5cbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSwgbW9kZWwpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY2x1ZGUubW9kZWwpIHtcbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZS5hbGwpIHtcbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY2x1ZGUgdW5leHBlY3RlZC4gRWxlbWVudCBoYXMgdG8gYmUgZWl0aGVyIGEgTW9kZWwsIGFuIEFzc29jaWF0aW9uIG9yIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIHN0YXRpYyBfZXhwYW5kSW5jbHVkZUFsbEVsZW1lbnQoaW5jbHVkZXMsIGluY2x1ZGUpIHtcbiAgICAvLyBjaGVjayAnYWxsJyBhdHRyaWJ1dGUgcHJvdmlkZWQgaXMgdmFsaWRcbiAgICBsZXQgYWxsID0gaW5jbHVkZS5hbGw7XG4gICAgZGVsZXRlIGluY2x1ZGUuYWxsO1xuXG4gICAgaWYgKGFsbCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbCkpIHtcbiAgICAgICAgYWxsID0gW2FsbF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbGlkVHlwZXMgPSB7XG4gICAgICAgIEJlbG9uZ3NUbzogdHJ1ZSxcbiAgICAgICAgSGFzT25lOiB0cnVlLFxuICAgICAgICBIYXNNYW55OiB0cnVlLFxuICAgICAgICBPbmU6IFsnQmVsb25nc1RvJywgJ0hhc09uZSddLFxuICAgICAgICBIYXM6IFsnSGFzT25lJywgJ0hhc01hbnknXSxcbiAgICAgICAgTWFueTogWydIYXNNYW55J11cbiAgICAgIH07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhbGxbaV07XG4gICAgICAgIGlmICh0eXBlID09PSAnQWxsJykge1xuICAgICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlcyA9IHZhbGlkVHlwZXNbdHlwZV07XG4gICAgICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGBpbmNsdWRlIGFsbCAnJHt0eXBlfScgaXMgbm90IHZhbGlkIC0gbXVzdCBiZSBCZWxvbmdzVG8sIEhhc09uZSwgSGFzTWFueSwgT25lLCBIYXMsIE1hbnkgb3IgQWxsYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAvLyByZXBsYWNlIHR5cGUgcGxhY2Vob2xkZXIgZS5nLiAnT25lJyB3aXRoIGl0cyBjb25zdGl0dWVudCB0eXBlcyBlLmcuICdIYXNPbmUnLCAnQmVsb25nc1RvJ1xuICAgICAgICAgIGFsbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghYWxsLmluY2x1ZGVzKHR5cGVzW2pdKSkge1xuICAgICAgICAgICAgICBhbGwudW5zaGlmdCh0eXBlc1tqXSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgYWxsIGFzc29jaWF0aW9ucyBvZiB0eXBlcyBzcGVjaWZpZWQgdG8gaW5jbHVkZXNcbiAgICBjb25zdCBuZXN0ZWQgPSBpbmNsdWRlLm5lc3RlZDtcbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBkZWxldGUgaW5jbHVkZS5uZXN0ZWQ7XG5cbiAgICAgIGlmICghaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgIGluY2x1ZGUuaW5jbHVkZSA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpbmNsdWRlLmluY2x1ZGUpKSB7XG4gICAgICAgIGluY2x1ZGUuaW5jbHVkZSA9IFtpbmNsdWRlLmluY2x1ZGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVzZWQgPSBbXTtcbiAgICAoZnVuY3Rpb24gYWRkQWxsSW5jbHVkZXMocGFyZW50LCBpbmNsdWRlcykge1xuICAgICAgXy5mb3JFYWNoKHBhcmVudC5hc3NvY2lhdGlvbnMsIGFzc29jaWF0aW9uID0+IHtcbiAgICAgICAgaWYgKGFsbCAhPT0gdHJ1ZSAmJiAhYWxsLmluY2x1ZGVzKGFzc29jaWF0aW9uLmFzc29jaWF0aW9uVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBtb2RlbCBhbHJlYWR5IGluY2x1ZGVkLCBhbmQgc2tpcCBpZiBzb1xuICAgICAgICBjb25zdCBtb2RlbCA9IGFzc29jaWF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgYXMgPSBhc3NvY2lhdGlvbi5vcHRpb25zLmFzO1xuXG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHsgbW9kZWwgfTtcbiAgICAgICAgaWYgKGFzKSB7XG4gICAgICAgICAgLy8gV2Ugb25seSBhZGQgJ2FzJyB0byB0aGUgcHJlZGljYXRlIGlmIGl0IGFjdHVhbGx5IGV4aXN0c1xuICAgICAgICAgIHByZWRpY2F0ZS5hcyA9IGFzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc29tZShpbmNsdWRlcywgcHJlZGljYXRlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgaWYgcmVjdXJzaW5nIG92ZXIgYSBtb2RlbCBhbHJlYWR5IG5lc3RlZFxuICAgICAgICBpZiAobmVzdGVkICYmIHVzZWQuaW5jbHVkZXMobW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVzZWQucHVzaChwYXJlbnQpO1xuXG4gICAgICAgIC8vIGluY2x1ZGUgdGhpcyBtb2RlbFxuICAgICAgICBjb25zdCB0aGlzSW5jbHVkZSA9IFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKTtcbiAgICAgICAgdGhpc0luY2x1ZGUubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgaWYgKGFzKSB7XG4gICAgICAgICAgdGhpc0luY2x1ZGUuYXMgPSBhcztcbiAgICAgICAgfVxuICAgICAgICBpbmNsdWRlcy5wdXNoKHRoaXNJbmNsdWRlKTtcblxuICAgICAgICAvLyBydW4gcmVjdXJzaXZlbHkgaWYgbmVzdGVkXG4gICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICBhZGRBbGxJbmNsdWRlcyhtb2RlbCwgdGhpc0luY2x1ZGUuaW5jbHVkZSk7XG4gICAgICAgICAgaWYgKHRoaXNJbmNsdWRlLmluY2x1ZGUubGVuZ3RoID09PSAwKSBkZWxldGUgdGhpc0luY2x1ZGUuaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1c2VkLnBvcCgpO1xuICAgIH0pKHRoaXMsIGluY2x1ZGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBfdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMsIHRhYmxlTmFtZXMpIHtcbiAgICBpZiAoIW9wdGlvbnMubW9kZWwpIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG4gICAgdGFibGVOYW1lcyA9IHRhYmxlTmFtZXMgfHwge307XG4gICAgb3B0aW9ucy5pbmNsdWRlTmFtZXMgPSBbXTtcbiAgICBvcHRpb25zLmluY2x1ZGVNYXAgPSB7fTtcblxuICAgIC8qIExlZ2FjeSAqL1xuICAgIG9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gPSBmYWxzZTtcbiAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSBmYWxzZTtcblxuICAgIGlmICghb3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIG9wdGlvbnMudG9wTW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgICAgb3B0aW9ucy50b3BMaW1pdCA9IG9wdGlvbnMubGltaXQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlLm1hcChpbmNsdWRlID0+IHtcbiAgICAgIGluY2x1ZGUgPSB0aGlzLl9jb25mb3JtSW5jbHVkZShpbmNsdWRlKTtcbiAgICAgIGluY2x1ZGUucGFyZW50ID0gb3B0aW9ucztcbiAgICAgIGluY2x1ZGUudG9wTGltaXQgPSBvcHRpb25zLnRvcExpbWl0O1xuXG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudC5jYWxsKG9wdGlvbnMubW9kZWwsIGluY2x1ZGUsIHRhYmxlTmFtZXMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluY2x1ZGUuZHVwbGljYXRpbmcgPSBpbmNsdWRlLmFzc29jaWF0aW9uLmlzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaW5jbHVkZS5oYXNEdXBsaWNhdGluZyA9IGluY2x1ZGUuaGFzRHVwbGljYXRpbmcgfHwgaW5jbHVkZS5kdXBsaWNhdGluZztcbiAgICAgIGluY2x1ZGUuaGFzUmVxdWlyZWQgPSBpbmNsdWRlLmhhc1JlcXVpcmVkIHx8IGluY2x1ZGUucmVxdWlyZWQ7XG5cbiAgICAgIG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgPSBvcHRpb25zLmhhc0R1cGxpY2F0aW5nIHx8IGluY2x1ZGUuaGFzRHVwbGljYXRpbmc7XG4gICAgICBvcHRpb25zLmhhc1JlcXVpcmVkID0gb3B0aW9ucy5oYXNSZXF1aXJlZCB8fCBpbmNsdWRlLnJlcXVpcmVkO1xuXG4gICAgICBvcHRpb25zLmhhc1doZXJlID0gb3B0aW9ucy5oYXNXaGVyZSB8fCBpbmNsdWRlLmhhc1doZXJlIHx8ICEhaW5jbHVkZS53aGVyZTtcbiAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgaW5jbHVkZS5oYXNQYXJlbnRXaGVyZSA9IG9wdGlvbnMuaGFzUGFyZW50V2hlcmUgfHwgISFvcHRpb25zLndoZXJlO1xuICAgICAgaW5jbHVkZS5oYXNQYXJlbnRSZXF1aXJlZCA9IG9wdGlvbnMuaGFzUGFyZW50UmVxdWlyZWQgfHwgISFvcHRpb25zLnJlcXVpcmVkO1xuXG4gICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5oYXNEdXBsaWNhdGluZyAmJiBvcHRpb25zLnRvcExpbWl0KSB7XG4gICAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGZhbHNlO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBpbmNsdWRlLmhhc1JlcXVpcmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLmhhc1JlcXVpcmVkO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnkgfHwgZmFsc2U7XG4gICAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGluY2x1ZGUuc3ViUXVlcnk7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeSB8fCBpbmNsdWRlLmhhc1BhcmVudFJlcXVpcmVkICYmIGluY2x1ZGUuaGFzUmVxdWlyZWQgJiYgIWluY2x1ZGUuc2VwYXJhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5pbmNsdWRlTWFwW2luY2x1ZGUuYXNdID0gaW5jbHVkZTtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzLnB1c2goaW5jbHVkZS5hcyk7XG5cbiAgICAgIC8vIFNldCB0b3AgbGV2ZWwgb3B0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMudG9wTW9kZWwgPT09IG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5zdWJRdWVyeSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudG9wTGltaXQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkpIHtcbiAgICAgICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlLmhhc0R1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogTGVnYWN5ICovXG4gICAgICBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IGluY2x1ZGUuaGFzSW5jbHVkZVdoZXJlIHx8ICEhaW5jbHVkZS53aGVyZTtcbiAgICAgIG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkID0gb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgaW5jbHVkZS5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgISFpbmNsdWRlLnJlcXVpcmVkO1xuXG4gICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5pc011bHRpQXNzb2NpYXRpb24gfHwgaW5jbHVkZS5oYXNNdWx0aUFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uIHx8IGluY2x1ZGUuaGFzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG9wTW9kZWwgPT09IG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5zdWJRdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgc3RhdGljIF92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudChpbmNsdWRlLCB0YWJsZU5hbWVzLCBvcHRpb25zKSB7XG4gICAgdGFibGVOYW1lc1tpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpXSA9IHRydWU7XG5cbiAgICBpZiAoaW5jbHVkZS5hdHRyaWJ1dGVzICYmICFvcHRpb25zLnJhdykge1xuICAgICAgaW5jbHVkZS5tb2RlbC5fZXhwYW5kQXR0cmlidXRlcyhpbmNsdWRlKTtcblxuICAgICAgaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMgPSBpbmNsdWRlLm1vZGVsLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhpbmNsdWRlLmF0dHJpYnV0ZXMpO1xuXG4gICAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcblxuICAgICAgaWYgKGluY2x1ZGUuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgXy5lYWNoKGluY2x1ZGUubW9kZWwucHJpbWFyeUtleXMsIChhdHRyLCBrZXkpID0+IHtcbiAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBwcmltYXJ5IGtleSBpZiBpdCdzIG5vdCBhbHJlYWR5IGluY2x1ZGVkIC0gdGFrZSBpbnRvIGFjY291bnQgdGhhdCB0aGUgcGsgbWlnaHQgYmUgYWxpYXNlZCAoZHVlIHRvIGEgLmZpZWxkIHByb3ApXG4gICAgICAgICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMuc29tZShpbmNsdWRlQXR0ciA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ci5maWVsZCAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGluY2x1ZGVBdHRyKSAmJiBpbmNsdWRlQXR0clswXSA9PT0gYXR0ci5maWVsZCAmJiBpbmNsdWRlQXR0clsxXSA9PT0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVBdHRyID09PSBrZXk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcy51bnNoaWZ0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuXG4gICAgLy8gcHNldWRvIGluY2x1ZGUganVzdCBuZWVkZWQgdGhlIGF0dHJpYnV0ZSBsb2dpYywgcmV0dXJuXG4gICAgaWYgKGluY2x1ZGUuX3BzZXVkbykge1xuICAgICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5jbHVkZS5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgTW9kZWwgaXMgYWN0dWFsbHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgTW9kZWwgLSBvciBpdCdzIGEgcHNldWRvIGluY2x1ZGVcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb24gfHwgdGhpcy5fZ2V0SW5jbHVkZWRBc3NvY2lhdGlvbihpbmNsdWRlLm1vZGVsLCBpbmNsdWRlLmFzKTtcblxuICAgIGluY2x1ZGUuYXNzb2NpYXRpb24gPSBhc3NvY2lhdGlvbjtcbiAgICBpbmNsdWRlLmFzID0gYXNzb2NpYXRpb24uYXM7XG5cbiAgICAvLyBJZiB0aHJvdWdoLCB3ZSBjcmVhdGUgYSBwc2V1ZG8gY2hpbGQgaW5jbHVkZSwgdG8gZWFzZSBvdXIgcGFyc2luZyBsYXRlciBvblxuICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2ggJiYgT2JqZWN0KGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkge1xuICAgICAgaWYgKCFpbmNsdWRlLmluY2x1ZGUpIGluY2x1ZGUuaW5jbHVkZSA9IFtdO1xuICAgICAgY29uc3QgdGhyb3VnaCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaDtcblxuICAgICAgaW5jbHVkZS50aHJvdWdoID0gXy5kZWZhdWx0cyhpbmNsdWRlLnRocm91Z2ggfHwge30sIHtcbiAgICAgICAgbW9kZWw6IHRocm91Z2gubW9kZWwsXG4gICAgICAgIGFzOiB0aHJvdWdoLm1vZGVsLm5hbWUsXG4gICAgICAgIGFzc29jaWF0aW9uOiB7XG4gICAgICAgICAgaXNTaW5nbGVBc3NvY2lhdGlvbjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBfcHNldWRvOiB0cnVlLFxuICAgICAgICBwYXJlbnQ6IGluY2x1ZGVcbiAgICAgIH0pO1xuXG5cbiAgICAgIGlmICh0aHJvdWdoLnNjb3BlKSB7XG4gICAgICAgIGluY2x1ZGUudGhyb3VnaC53aGVyZSA9IGluY2x1ZGUudGhyb3VnaC53aGVyZSA/IHsgW09wLmFuZF06IFtpbmNsdWRlLnRocm91Z2gud2hlcmUsIHRocm91Z2guc2NvcGVdIH0gOiB0aHJvdWdoLnNjb3BlO1xuICAgICAgfVxuXG4gICAgICBpbmNsdWRlLmluY2x1ZGUucHVzaChpbmNsdWRlLnRocm91Z2gpO1xuICAgICAgdGFibGVOYW1lc1t0aHJvdWdoLnRhYmxlTmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGluY2x1ZGUubW9kZWwgbWF5IGJlIHRoZSBtYWluIG1vZGVsLCB3aGlsZSB0aGUgYXNzb2NpYXRpb24gdGFyZ2V0IG1heSBiZSBzY29wZWQgLSB0aHVzIHdlIG5lZWQgdG8gbG9vayBhdCBhc3NvY2lhdGlvbi50YXJnZXQvc291cmNlXG4gICAgbGV0IG1vZGVsO1xuICAgIGlmIChpbmNsdWRlLm1vZGVsLnNjb3BlZCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gSWYgdGhlIHBhc3NlZCBtb2RlbCBpcyBhbHJlYWR5IHNjb3BlZCwga2VlcCB0aGF0XG4gICAgICBtb2RlbCA9IGluY2x1ZGUubW9kZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIG1vZGVsIHRoYXQgd2FzIG9yaWdpbmFsbHkgcGFzc2VkIHRvIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSBpbmNsdWRlLm1vZGVsLm5hbWUgPyBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldCA6IGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlO1xuICAgIH1cblxuICAgIG1vZGVsLl9pbmplY3RTY29wZShpbmNsdWRlKTtcblxuICAgIC8vIFRoaXMgY2hlY2sgc2hvdWxkIGhhcHBlbiBhZnRlciBpbmplY3RpbmcgdGhlIHNjb3BlLCBzaW5jZSB0aGUgc2NvcGUgbWF5IGNvbnRhaW4gYSAuYXR0cmlidXRlc1xuICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbmNsdWRlLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG5cbiAgICBpZiAoaW5jbHVkZS5yZXF1aXJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmNsdWRlLnJlcXVpcmVkID0gISFpbmNsdWRlLndoZXJlO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKSB7XG4gICAgICBpbmNsdWRlLndoZXJlID0gaW5jbHVkZS53aGVyZSA/IHsgW09wLmFuZF06IFtpbmNsdWRlLndoZXJlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlXSB9IDogaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS5saW1pdCAmJiBpbmNsdWRlLnNlcGFyYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluY2x1ZGUuc2VwYXJhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlID09PSB0cnVlKSB7XG4gICAgICBpZiAoIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgSGFzTWFueSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IEhhc01hbnkgYXNzb2NpYXRpb25zIHN1cHBvcnQgaW5jbHVkZS5zZXBhcmF0ZScpO1xuICAgICAgfVxuXG4gICAgICBpbmNsdWRlLmR1cGxpY2F0aW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICAgICYmIG9wdGlvbnMuYXR0cmlidXRlcy5sZW5ndGhcbiAgICAgICAgJiYgIV8uZmxhdHRlbkRlcHRoKG9wdGlvbnMuYXR0cmlidXRlcywgMikuaW5jbHVkZXMoYXNzb2NpYXRpb24uc291cmNlS2V5KVxuICAgICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy5wdXNoKGFzc29jaWF0aW9uLnNvdXJjZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzXG4gICAgICAgICYmIGluY2x1ZGUuYXR0cmlidXRlcy5sZW5ndGhcbiAgICAgICAgJiYgIV8uZmxhdHRlbkRlcHRoKGluY2x1ZGUuYXR0cmlidXRlcywgMikuaW5jbHVkZXMoYXNzb2NpYXRpb24uZm9yZWlnbktleSlcbiAgICAgICkge1xuICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMucHVzaChhc3NvY2lhdGlvbi5mb3JlaWduS2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBjaGlsZCBpbmNsdWRlc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5jbHVkZSwgJ2luY2x1ZGUnKSkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzLmNhbGwoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSwgdGFibGVOYW1lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluY2x1ZGU7XG4gIH1cblxuICBzdGF0aWMgX2dldEluY2x1ZGVkQXNzb2NpYXRpb24odGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb25zID0gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0TW9kZWwpO1xuICAgIGxldCBhc3NvY2lhdGlvbiA9IG51bGw7XG4gICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgbm90IGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IWApO1xuICAgIH1cbiAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYXNzb2NpYXRpb24gPSB0aGlzLmdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKTtcbiAgICAgIGlmIChhc3NvY2lhdGlvbikge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0QWxpYXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBbGlhc2VzID0gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0TW9kZWwpLm1hcChhc3NvY2lhdGlvbiA9PiBhc3NvY2lhdGlvbi5hcyk7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gdXNpbmcgYW4gYWxpYXMuIGAgK1xuICAgICAgICAgIGBZb3UndmUgaW5jbHVkZWQgYW4gYWxpYXMgKCR7dGFyZ2V0QWxpYXN9KSwgYnV0IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBhbGlhcyhlcykgZGVmaW5lZCBpbiB5b3VyIGFzc29jaWF0aW9uICgke2V4aXN0aW5nQWxpYXNlcy5qb2luKCcsICcpfSkuYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IHVzaW5nIGFuIGFsaWFzLiBgICtcbiAgICAgICAgJ1lvdSBtdXN0IHVzZSB0aGUgXFwnYXNcXCcga2V5d29yZCB0byBzcGVjaWZ5IHRoZSBhbGlhcyB3aXRoaW4geW91ciBpbmNsdWRlIHN0YXRlbWVudC4nKTtcbiAgICB9XG4gICAgYXNzb2NpYXRpb24gPSB0aGlzLmdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKTtcbiAgICBpZiAoIWFzc29jaWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IG11bHRpcGxlIHRpbWVzLiBgICtcbiAgICAgICAgJ1RvIGlkZW50aWZ5IHRoZSBjb3JyZWN0IGFzc29jaWF0aW9uLCB5b3UgbXVzdCB1c2UgdGhlIFxcJ2FzXFwnIGtleXdvcmQgdG8gc3BlY2lmeSB0aGUgYWxpYXMgb2YgdGhlIGFzc29jaWF0aW9uIHlvdSB3YW50IHRvIGluY2x1ZGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfVxuXG5cbiAgc3RhdGljIF9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbmNsdWRlcyA9IG9wdGlvbnMuaW5jbHVkZTtcbiAgICBpZiAoIWluY2x1ZGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGluY2x1ZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaW5jbHVkZSA9IGluY2x1ZGVzW2luZGV4XTtcblxuICAgICAgaWYgKGluY2x1ZGUuYWxsKSB7XG4gICAgICAgIGluY2x1ZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbEVsZW1lbnQoaW5jbHVkZXMsIGluY2x1ZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluY2x1ZGVzLmZvckVhY2goaW5jbHVkZSA9PiB7XG4gICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsLmNhbGwoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgX2NvbmZvcm1JbmRleChpbmRleCkge1xuICAgIGlmICghaW5kZXguZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmaWVsZHNcIiBwcm9wZXJ0eSBmb3IgaW5kZXggZGVmaW5pdGlvbicpO1xuICAgIH1cblxuICAgIGluZGV4ID0gXy5kZWZhdWx0cyhpbmRleCwge1xuICAgICAgdHlwZTogJycsXG4gICAgICBwYXJzZXI6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChpbmRleC50eXBlICYmIGluZGV4LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3VuaXF1ZScpIHtcbiAgICAgIGluZGV4LnVuaXF1ZSA9IHRydWU7XG4gICAgICBkZWxldGUgaW5kZXgudHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuXG4gIHN0YXRpYyBfdW5pcUluY2x1ZGVzKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSkgcmV0dXJuO1xuXG4gICAgb3B0aW9ucy5pbmNsdWRlID0gXyhvcHRpb25zLmluY2x1ZGUpXG4gICAgICAuZ3JvdXBCeShpbmNsdWRlID0+IGAke2luY2x1ZGUubW9kZWwgJiYgaW5jbHVkZS5tb2RlbC5uYW1lfS0ke2luY2x1ZGUuYXN9YClcbiAgICAgIC5tYXAoaW5jbHVkZXMgPT4gdGhpcy5fYXNzaWduT3B0aW9ucyguLi5pbmNsdWRlcykpXG4gICAgICAudmFsdWUoKTtcbiAgfVxuXG4gIHN0YXRpYyBfYmFzZU1lcmdlKC4uLmFyZ3MpIHtcbiAgICBfLmFzc2lnbldpdGgoLi4uYXJncyk7XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGFyZ3NbMF0sIHRoaXMpO1xuICAgIHRoaXMuX3VuaXFJbmNsdWRlcyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuXG4gIHN0YXRpYyBfbWVyZ2VGdW5jdGlvbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9ialZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIF8udW5pb24ob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ3doZXJlJyB8fCBrZXkgPT09ICdoYXZpbmcnKSB7XG4gICAgICBpZiAoc3JjVmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgc3JjVmFsdWUgPSB7IFtPcC5hbmRdOiBzcmNWYWx1ZSB9O1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvYmpWYWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnYXR0cmlidXRlcycgJiYgXy5pc1BsYWluT2JqZWN0KG9ialZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gXy5hc3NpZ25XaXRoKG9ialZhbHVlLCBzcmNWYWx1ZSwgKG9ialZhbHVlLCBzcmNWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShzcmNWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXy51bmlvbihvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBvc3NpYmxlIG9iamVjdC9hcnJheSB0byBjbG9uZSwgd2UgdHJ5IGl0LlxuICAgIC8vIE90aGVyd2lzZSwgd2UgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSB3aGVuIGl0J3Mgbm90IHVuZGVmaW5lZCxcbiAgICAvLyBvciB0aGUgcmVzdWx0aW5nIG9iamVjdCBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gVXRpbHMuY2xvbmVEZWVwKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNyY1ZhbHVlID09PSB1bmRlZmluZWQgPyBvYmpWYWx1ZSA6IHNyY1ZhbHVlO1xuICB9XG5cbiAgc3RhdGljIF9hc3NpZ25PcHRpb25zKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZU1lcmdlKC4uLmFyZ3MsIHRoaXMuX21lcmdlRnVuY3Rpb24pO1xuICB9XG5cbiAgc3RhdGljIF9kZWZhdWx0c09wdGlvbnModGFyZ2V0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VNZXJnZSh0YXJnZXQsIG9wdHMsIChzcmNWYWx1ZSwgb2JqVmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX21lcmdlRnVuY3Rpb24ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBtb2RlbCwgcmVwcmVzZW50aW5nIGEgdGFibGUgaW4gdGhlIERCLCB3aXRoIGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIFRoZSB0YWJsZSBjb2x1bW5zIGFyZSBkZWZpbmVkIGJ5IHRoZSBoYXNoIHRoYXQgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiBFYWNoIGF0dHJpYnV0ZSBvZiB0aGUgaGFzaCByZXByZXNlbnRzIGEgY29sdW1uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBQcm9qZWN0LmluaXQoe1xuICAgKiAgIGNvbHVtbkE6IHtcbiAgICogICAgIHR5cGU6IFNlcXVlbGl6ZS5CT09MRUFOLFxuICAgKiAgICAgdmFsaWRhdGU6IHtcbiAgICogICAgICAgaXM6IFsnW2Etel0nLCdpJ10sICAgICAgICAvLyB3aWxsIG9ubHkgYWxsb3cgbGV0dGVyc1xuICAgKiAgICAgICBtYXg6IDIzLCAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgdmFsdWVzIDw9IDIzXG4gICAqICAgICAgIGlzSW46IHtcbiAgICogICAgICAgICBhcmdzOiBbWydlbicsICd6aCddXSxcbiAgICogICAgICAgICBtc2c6IFwiTXVzdCBiZSBFbmdsaXNoIG9yIENoaW5lc2VcIlxuICAgKiAgICAgICB9XG4gICAqICAgICB9LFxuICAgKiAgICAgZmllbGQ6ICdjb2x1bW5fYSdcbiAgICogICAgIC8vIE90aGVyIGF0dHJpYnV0ZXMgaGVyZVxuICAgKiAgIH0sXG4gICAqICAgY29sdW1uQjogU2VxdWVsaXplLlNUUklORyxcbiAgICogICBjb2x1bW5DOiAnTVkgVkVSWSBPV04gQ09MVU1OIFRZUEUnXG4gICAqIH0sIHtzZXF1ZWxpemV9KVxuICAgKlxuICAgKiBzZXF1ZWxpemUubW9kZWxzLm1vZGVsTmFtZSAvLyBUaGUgbW9kZWwgd2lsbCBub3cgYmUgYXZhaWxhYmxlIGluIG1vZGVscyB1bmRlciB0aGUgY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIDxhIGhyZWY9XCIvbWFzdGVyL21hbnVhbC9tb2RlbC1iYXNpY3MuaHRtbFwiPk1vZGVsIEJhc2ljczwvYT4gZ3VpZGVcbiAgICpcbiAgICogQHNlZVxuICAgKiA8YSBocmVmPVwiL21hc3Rlci9tYW51YWwvbW9kZWwtYmFzaWNzLmh0bWxcIj5Ib29rczwvYT4gZ3VpZGVcbiAgICpcbiAgICogQHNlZVxuICAgKiA8YSBocmVmPVwiL21hc3Rlci9tYW51YWwvdmFsaWRhdGlvbnMtYW5kLWNvbnN0cmFpbnRzLmh0bWxcIi8+VmFsaWRhdGlvbnMgJiBDb25zdHJhaW50czwvYT4gZ3VpZGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyBBbiBvYmplY3QsIHdoZXJlIGVhY2ggYXR0cmlidXRlIGlzIGEgY29sdW1uIG9mIHRoZSB0YWJsZS4gRWFjaCBjb2x1bW4gY2FuIGJlIGVpdGhlciBhIERhdGFUeXBlLCBhIHN0cmluZyBvciBhIHR5cGUtZGVzY3JpcHRpb24gb2JqZWN0LCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGRlc2NyaWJlZCBiZWxvdzpcbiAgICogQHBhcmFtIHtzdHJpbmd8RGF0YVR5cGVzfG9iamVjdH0gYXR0cmlidXRlcy5jb2x1bW4gVGhlIGRlc2NyaXB0aW9uIG9mIGEgZGF0YWJhc2UgY29sdW1uXG4gICAqIEBwYXJhbSB7c3RyaW5nfERhdGFUeXBlc30gICAgICAgIGF0dHJpYnV0ZXMuY29sdW1uLnR5cGUgQSBzdHJpbmcgb3IgYSBkYXRhIHR5cGVcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmFsbG93TnVsbD10cnVlXSBJZiBmYWxzZSwgdGhlIGNvbHVtbiB3aWxsIGhhdmUgYSBOT1QgTlVMTCBjb25zdHJhaW50LCBhbmQgYSBub3QgbnVsbCB2YWxpZGF0aW9uIHdpbGwgYmUgcnVuIGJlZm9yZSBhbiBpbnN0YW5jZSBpcyBzYXZlZC5cbiAgICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmRlZmF1bHRWYWx1ZT1udWxsXSBBIGxpdGVyYWwgZGVmYXVsdCB2YWx1ZSwgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uLCBvciBhbiBTUUwgZnVuY3Rpb24gKHNlZSBgc2VxdWVsaXplLmZuYClcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnVuaXF1ZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGNvbHVtbiB3aWxsIGdldCBhIHVuaXF1ZSBjb25zdHJhaW50LiBJZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGNvbHVtbiB3aWxsIGJlIHBhcnQgb2YgYSBjb21wb3NpdGUgdW5pcXVlIGluZGV4LiBJZiBtdWx0aXBsZSBjb2x1bW5zIGhhdmUgdGhlIHNhbWUgc3RyaW5nLCB0aGV5IHdpbGwgYmUgcGFydCBvZiB0aGUgc2FtZSB1bmlxdWUgaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnByaW1hcnlLZXk9ZmFsc2VdIElmIHRydWUsIHRoaXMgYXR0cmlidXRlIHdpbGwgYmUgbWFya2VkIGFzIHByaW1hcnkga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5maWVsZD1udWxsXSBJZiBzZXQsIHNlcXVlbGl6ZSB3aWxsIG1hcCB0aGUgYXR0cmlidXRlIG5hbWUgdG8gYSBkaWZmZXJlbnQgbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmF1dG9JbmNyZW1lbnQ9ZmFsc2VdIElmIHRydWUsIHRoaXMgY29sdW1uIHdpbGwgYmUgc2V0IHRvIGF1dG8gaW5jcmVtZW50XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5hdXRvSW5jcmVtZW50SWRlbnRpdHk9ZmFsc2VdIElmIHRydWUsIGNvbWJpbmVkIHdpdGggYXV0b0luY3JlbWVudD10cnVlLCB3aWxsIHVzZSBQb3N0Z3JlcyBgR0VORVJBVEVEIEJZIERFRkFVTFQgQVMgSURFTlRJVFlgIGluc3RlYWQgb2YgYFNFUklBTGAuIFBvc3RncmVzIDEwKyBvbmx5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uY29tbWVudD1udWxsXSBDb21tZW50IGZvciB0aGlzIGNvbHVtblxuICAgKiBAcGFyYW0ge3N0cmluZ3xNb2RlbH0gICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ucmVmZXJlbmNlcz1udWxsXSBBbiBvYmplY3Qgd2l0aCByZWZlcmVuY2UgY29uZmlndXJhdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8TW9kZWx9ICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnJlZmVyZW5jZXMubW9kZWxdIElmIHRoaXMgY29sdW1uIHJlZmVyZW5jZXMgYW5vdGhlciB0YWJsZSwgcHJvdmlkZSBpdCBoZXJlIGFzIGEgTW9kZWwsIG9yIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5yZWZlcmVuY2VzLmtleT0naWQnXSBUaGUgY29sdW1uIG9mIHRoZSBmb3JlaWduIHRhYmxlIHRoYXQgdGhpcyBjb2x1bW4gcmVmZXJlbmNlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ub25VcGRhdGVdIFdoYXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZSByZWZlcmVuY2VkIGtleSBpcyB1cGRhdGVkLiBPbmUgb2YgQ0FTQ0FERSwgUkVTVFJJQ1QsIFNFVCBERUZBVUxULCBTRVQgTlVMTCBvciBOTyBBQ1RJT05cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLm9uRGVsZXRlXSBXaGF0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgcmVmZXJlbmNlZCBrZXkgaXMgZGVsZXRlZC4gT25lIG9mIENBU0NBREUsIFJFU1RSSUNULCBTRVQgREVGQVVMVCwgU0VUIE5VTEwgb3IgTk8gQUNUSU9OXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5nZXRdIFByb3ZpZGUgYSBjdXN0b20gZ2V0dGVyIGZvciB0aGlzIGNvbHVtbi4gVXNlIGB0aGlzLmdldERhdGFWYWx1ZShTdHJpbmcpYCB0byBtYW5pcHVsYXRlIHRoZSB1bmRlcmx5aW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnNldF0gUHJvdmlkZSBhIGN1c3RvbSBzZXR0ZXIgZm9yIHRoaXMgY29sdW1uLiBVc2UgYHRoaXMuc2V0RGF0YVZhbHVlKFN0cmluZywgVmFsdWUpYCB0byBtYW5pcHVsYXRlIHRoZSB1bmRlcmx5aW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnZhbGlkYXRlXSBBbiBvYmplY3Qgb2YgdmFsaWRhdGlvbnMgdG8gZXhlY3V0ZSBmb3IgdGhpcyBjb2x1bW4gZXZlcnkgdGltZSB0aGUgbW9kZWwgaXMgc2F2ZWQuIENhbiBiZSBlaXRoZXIgdGhlIG5hbWUgb2YgYSB2YWxpZGF0aW9uIHByb3ZpZGVkIGJ5IHZhbGlkYXRvci5qcywgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IGV4dGVuZGluZyB2YWxpZGF0b3IuanMgKHNlZSB0aGUgYERBT1ZhbGlkYXRvcmAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlscyksIG9yIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIEN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBhbmQgdGhlIGluc3RhbmNlIGl0c2VsZiBhcyB0aGUgYHRoaXNgIGJpbmRpbmcsIGFuZCBjYW4gcG9zc2libHkgdGFrZSBhIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudCwgdG8gc2lnbmFsIHRoYXQgdGhleSBhcmUgYXN5bmNocm9ub3VzLiBJZiB0aGUgdmFsaWRhdG9yIGlzIHN5bmMsIGl0IHNob3VsZCB0aHJvdyBpbiB0aGUgY2FzZSBvZiBhIGZhaWxlZCB2YWxpZGF0aW9uOyBpZiBpdCBpcyBhc3luYywgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IgdGV4dC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgb3B0aW9ucyBUaGVzZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgU2VxdWVsaXplIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VxdWVsaXplIERlZmluZSB0aGUgc2VxdWVsaXplIGluc3RhbmNlIHRvIGF0dGFjaCB0byB0aGUgbmV3IE1vZGVsLiBUaHJvdyBlcnJvciBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5tb2RlbE5hbWVdIFNldCBuYW1lIG9mIHRoZSBtb2RlbC4gQnkgZGVmYXVsdCBpdHMgc2FtZSBhcyBDbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5kZWZhdWx0U2NvcGU9e31dIERlZmluZSB0aGUgZGVmYXVsdCBzZWFyY2ggc2NvcGUgdG8gdXNlIGZvciB0aGlzIG1vZGVsLiBTY29wZXMgaGF2ZSB0aGUgc2FtZSBmb3JtIGFzIHRoZSBvcHRpb25zIHBhc3NlZCB0byBmaW5kIC8gZmluZEFsbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5zY29wZXNdIE1vcmUgc2NvcGVzLCBkZWZpbmVkIGluIHRoZSBzYW1lIHdheSBhcyBkZWZhdWx0U2NvcGUgYWJvdmUuIFNlZSBgTW9kZWwuc2NvcGVgIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBzY29wZXMgYXJlIGRlZmluZWQsIGFuZCB3aGF0IHlvdSBjYW4gZG8gd2l0aCB0aGVtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLm9taXROdWxsXSBEb24ndCBwZXJzaXN0IG51bGwgdmFsdWVzLiBUaGlzIG1lYW5zIHRoYXQgYWxsIGNvbHVtbnMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIG5vdCBiZSBzYXZlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy50aW1lc3RhbXBzPXRydWVdIEFkZHMgY3JlYXRlZEF0IGFuZCB1cGRhdGVkQXQgdGltZXN0YW1wcyB0byB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLnBhcmFub2lkPWZhbHNlXSBDYWxsaW5nIGBkZXN0cm95YCB3aWxsIG5vdCBkZWxldGUgdGhlIG1vZGVsLCBidXQgaW5zdGVhZCBzZXQgYSBgZGVsZXRlZEF0YCB0aW1lc3RhbXAgaWYgdGhpcyBpcyB0cnVlLiBOZWVkcyBgdGltZXN0YW1wcz10cnVlYCB0byB3b3JrXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLnVuZGVyc2NvcmVkPWZhbHNlXSBBZGQgdW5kZXJzY29yZWQgZmllbGQgdG8gYWxsIGF0dHJpYnV0ZXMsIHRoaXMgY292ZXJzIHVzZXIgZGVmaW5lZCBhdHRyaWJ1dGVzLCB0aW1lc3RhbXBzIGFuZCBmb3JlaWduIGtleXMuIFdpbGwgbm90IGFmZmVjdCBhdHRyaWJ1dGVzIHdpdGggZXhwbGljaXRseSBzZXQgYGZpZWxkYCBvcHRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMuZnJlZXplVGFibGVOYW1lPWZhbHNlXSBJZiBmcmVlemVUYWJsZU5hbWUgaXMgdHJ1ZSwgc2VxdWVsaXplIHdpbGwgbm90IHRyeSB0byBhbHRlciB0aGUgbW9kZWwgbmFtZSB0byBnZXQgdGhlIHRhYmxlIG5hbWUuIE90aGVyd2lzZSwgdGhlIG1vZGVsIG5hbWUgd2lsbCBiZSBwbHVyYWxpemVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLm5hbWVdIEFuIG9iamVjdCB3aXRoIHR3byBhdHRyaWJ1dGVzLCBgc2luZ3VsYXJgIGFuZCBgcGx1cmFsYCwgd2hpY2ggYXJlIHVzZWQgd2hlbiB0aGlzIG1vZGVsIGlzIGFzc29jaWF0ZWQgdG8gb3RoZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5uYW1lLnNpbmd1bGFyPVV0aWxzLnNpbmd1bGFyaXplKG1vZGVsTmFtZSldIFNpbmd1bGFyIG5hbWUgZm9yIG1vZGVsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLm5hbWUucGx1cmFsPVV0aWxzLnBsdXJhbGl6ZShtb2RlbE5hbWUpXSBQbHVyYWwgbmFtZSBmb3IgbW9kZWxcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc10gaW5kZXhlcyBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10ubmFtZV0gVGhlIG5hbWUgb2YgdGhlIGluZGV4LiBEZWZhdWx0cyB0byBtb2RlbCBuYW1lICsgXyArIGZpZWxkcyBjb25jYXRlbmF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLnR5cGVdIEluZGV4IHR5cGUuIE9ubHkgdXNlZCBieSBteXNxbC4gT25lIG9mIGBVTklRVUVgLCBgRlVMTFRFWFRgIGFuZCBgU1BBVElBTGBcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLnVzaW5nXSBUaGUgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgaW5kZXggYnkgKGBVU0lOR2Agc3RhdGVtZW50IGluIFNRTCkuIEJUUkVFIGFuZCBIQVNIIGFyZSBzdXBwb3J0ZWQgYnkgbXlzcWwgYW5kIHBvc3RncmVzLCBhbmQgcG9zdGdyZXMgYWRkaXRpb25hbGx5IHN1cHBvcnRzIEdJU1QgYW5kIEdJTi5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5kZXhlc1tdLm9wZXJhdG9yXSBTcGVjaWZ5IGluZGV4IG9wZXJhdG9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10udW5pcXVlPWZhbHNlXSBTaG91bGQgdGhlIGluZGV4IGJ5IHVuaXF1ZT8gQ2FuIGFsc28gYmUgdHJpZ2dlcmVkIGJ5IHNldHRpbmcgdHlwZSB0byBgVU5JUVVFYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10uY29uY3VycmVudGx5PWZhbHNlXSBQb3N0Z3Jlc1NRTCB3aWxsIGJ1aWxkIHRoZSBpbmRleCB3aXRob3V0IHRha2luZyBhbnkgd3JpdGUgbG9ja3MuIFBvc3RncmVzIG9ubHlcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8b2JqZWN0Pn0gICAgW29wdGlvbnMuaW5kZXhlc1tdLmZpZWxkc10gQW4gYXJyYXkgb2YgdGhlIGZpZWxkcyB0byBpbmRleC4gRWFjaCBmaWVsZCBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGZpZWxkLCBhIHNlcXVlbGl6ZSBvYmplY3QgKGUuZyBgc2VxdWVsaXplLmZuYCksIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczogYGF0dHJpYnV0ZWAgKGZpZWxkIG5hbWUpLCBgbGVuZ3RoYCAoY3JlYXRlIGEgcHJlZml4IGluZGV4IG9mIGxlbmd0aCBjaGFycyksIGBvcmRlcmAgKHRoZSBkaXJlY3Rpb24gdGhlIGNvbHVtbiBzaG91bGQgYmUgc29ydGVkIGluKSwgYGNvbGxhdGVgICh0aGUgY29sbGF0aW9uIChzb3J0IG9yZGVyKSBmb3IgdGhlIGNvbHVtbilcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gICAgICAgICAgW29wdGlvbnMuY3JlYXRlZEF0XSBPdmVycmlkZSB0aGUgbmFtZSBvZiB0aGUgY3JlYXRlZEF0IGF0dHJpYnV0ZSBpZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgb3IgZGlzYWJsZSBpdCBpZiBmYWxzZS4gVGltZXN0YW1wcyBtdXN0IGJlIHRydWUuIFVuZGVyc2NvcmVkIGZpZWxkIHdpbGwgYmUgc2V0IHdpdGggdW5kZXJzY29yZWQgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gICAgICAgICAgW29wdGlvbnMudXBkYXRlZEF0XSBPdmVycmlkZSB0aGUgbmFtZSBvZiB0aGUgdXBkYXRlZEF0IGF0dHJpYnV0ZSBpZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgb3IgZGlzYWJsZSBpdCBpZiBmYWxzZS4gVGltZXN0YW1wcyBtdXN0IGJlIHRydWUuIFVuZGVyc2NvcmVkIGZpZWxkIHdpbGwgYmUgc2V0IHdpdGggdW5kZXJzY29yZWQgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gICAgICAgICAgW29wdGlvbnMuZGVsZXRlZEF0XSBPdmVycmlkZSB0aGUgbmFtZSBvZiB0aGUgZGVsZXRlZEF0IGF0dHJpYnV0ZSBpZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgb3IgZGlzYWJsZSBpdCBpZiBmYWxzZS4gVGltZXN0YW1wcyBtdXN0IGJlIHRydWUuIFVuZGVyc2NvcmVkIGZpZWxkIHdpbGwgYmUgc2V0IHdpdGggdW5kZXJzY29yZWQgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMudGFibGVOYW1lXSBEZWZhdWx0cyB0byBwbHVyYWxpemVkIG1vZGVsIG5hbWUsIHVubGVzcyBmcmVlemVUYWJsZU5hbWUgaXMgdHJ1ZSwgaW4gd2hpY2ggY2FzZSBpdCB1c2VzIG1vZGVsIG5hbWUgdmVyYmF0aW1cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuc2NoZW1hPSdwdWJsaWMnXSBzY2hlbWFcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuZW5naW5lXSBTcGVjaWZ5IGVuZ2luZSBmb3IgbW9kZWwncyB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5jaGFyc2V0XSBTcGVjaWZ5IGNoYXJzZXQgZm9yIG1vZGVsJ3MgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuY29tbWVudF0gU3BlY2lmeSBjb21tZW50IGZvciBtb2RlbCdzIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmNvbGxhdGVdIFNwZWNpZnkgY29sbGF0aW9uIGZvciBtb2RlbCdzIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluaXRpYWxBdXRvSW5jcmVtZW50XSBTZXQgdGhlIGluaXRpYWwgQVVUT19JTkNSRU1FTlQgdmFsdWUgZm9yIHRoZSB0YWJsZSBpbiBNeVNRTC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaG9va3NdIEFuIG9iamVjdCBvZiBob29rIGZ1bmN0aW9uIHRoYXQgYXJlIGNhbGxlZCBiZWZvcmUgYW5kIGFmdGVyIGNlcnRhaW4gbGlmZWN5Y2xlIGV2ZW50cy4gVGhlIHBvc3NpYmxlIGhvb2tzIGFyZTogYmVmb3JlVmFsaWRhdGUsIGFmdGVyVmFsaWRhdGUsIHZhbGlkYXRpb25GYWlsZWQsIGJlZm9yZUJ1bGtDcmVhdGUsIGJlZm9yZUJ1bGtEZXN0cm95LCBiZWZvcmVCdWxrVXBkYXRlLCBiZWZvcmVDcmVhdGUsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVwZGF0ZSwgYWZ0ZXJDcmVhdGUsIGJlZm9yZVNhdmUsIGFmdGVyRGVzdHJveSwgYWZ0ZXJVcGRhdGUsIGFmdGVyQnVsa0NyZWF0ZSwgYWZ0ZXJTYXZlLCBhZnRlckJ1bGtEZXN0cm95IGFuZCBhZnRlckJ1bGtVcGRhdGUuIFNlZSBIb29rcyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob29rIGZ1bmN0aW9ucyBhbmQgdGhlaXIgc2lnbmF0dXJlcy4gRWFjaCBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24sIG9yIGFuIGFycmF5IG9mIGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMudmFsaWRhdGVdIEFuIG9iamVjdCBvZiBtb2RlbCB3aWRlIHZhbGlkYXRpb25zLiBWYWxpZGF0aW9ucyBoYXZlIGFjY2VzcyB0byBhbGwgbW9kZWwgdmFsdWVzIHZpYSBgdGhpc2AuIElmIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb24gdGFrZXMgYW4gYXJndW1lbnQsIGl0IGlzIGFzc3VtZWQgdG8gYmUgYXN5bmMsIGFuZCBpcyBjYWxsZWQgd2l0aCBhIGNhbGxiYWNrIHRoYXQgYWNjZXB0cyBhbiBvcHRpb25hbCBlcnJvci5cbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfVxuICAgKi9cbiAgc3RhdGljIGluaXQoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFvcHRpb25zLnNlcXVlbGl6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTZXF1ZWxpemUgaW5zdGFuY2UgcGFzc2VkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXF1ZWxpemUgPSBvcHRpb25zLnNlcXVlbGl6ZTtcblxuICAgIGNvbnN0IGdsb2JhbE9wdGlvbnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLm1lcmdlKF8uY2xvbmVEZWVwKGdsb2JhbE9wdGlvbnMuZGVmaW5lKSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMubW9kZWxOYW1lKSB7XG4gICAgICBvcHRpb25zLm1vZGVsTmFtZSA9IHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVXRpbHMubWVyZ2Uoe1xuICAgICAgbmFtZToge1xuICAgICAgICBwbHVyYWw6IFV0aWxzLnBsdXJhbGl6ZShvcHRpb25zLm1vZGVsTmFtZSksXG4gICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZShvcHRpb25zLm1vZGVsTmFtZSlcbiAgICAgIH0sXG4gICAgICBpbmRleGVzOiBbXSxcbiAgICAgIG9taXROdWxsOiBnbG9iYWxPcHRpb25zLm9taXROdWxsLFxuICAgICAgc2NoZW1hOiBnbG9iYWxPcHRpb25zLnNjaGVtYVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2JlZm9yZURlZmluZScsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kZWxOYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHsgdmFsdWU6IG9wdGlvbnMubW9kZWxOYW1lIH0pO1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5tb2RlbE5hbWU7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0aW1lc3RhbXBzOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHt9LFxuICAgICAgZnJlZXplVGFibGVOYW1lOiBmYWxzZSxcbiAgICAgIHVuZGVyc2NvcmVkOiBmYWxzZSxcbiAgICAgIHBhcmFub2lkOiBmYWxzZSxcbiAgICAgIHJlamVjdE9uRW1wdHk6IGZhbHNlLFxuICAgICAgd2hlcmVDb2xsZWN0aW9uOiBudWxsLFxuICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgc2NoZW1hRGVsaW1pdGVyOiAnJyxcbiAgICAgIGRlZmF1bHRTY29wZToge30sXG4gICAgICBzY29wZXM6IHt9LFxuICAgICAgaW5kZXhlczogW10sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIC8vIGlmIHlvdSBjYWxsIFwiZGVmaW5lXCIgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIG1vZGVsTmFtZSwgZG8gbm90IGNsdXR0ZXIgdGhlIGZhY3RvcnlcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuaXNEZWZpbmVkKHRoaXMubmFtZSkpIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5yZW1vdmVNb2RlbCh0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwodGhpcy5uYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9zZXR1cEhvb2tzKG9wdGlvbnMuaG9va3MpO1xuXG4gICAgdGhpcy51bmRlcnNjb3JlZCA9IHRoaXMub3B0aW9ucy51bmRlcnNjb3JlZDtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnRhYmxlTmFtZSkge1xuICAgICAgdGhpcy50YWJsZU5hbWUgPSB0aGlzLm9wdGlvbnMuZnJlZXplVGFibGVOYW1lID8gdGhpcy5uYW1lIDogVXRpbHMudW5kZXJzY29yZWRJZihVdGlscy5wbHVyYWxpemUodGhpcy5uYW1lKSwgdGhpcy51bmRlcnNjb3JlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFibGVOYW1lID0gdGhpcy5vcHRpb25zLnRhYmxlTmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zY2hlbWEgPSB0aGlzLm9wdGlvbnMuc2NoZW1hO1xuICAgIHRoaXMuX3NjaGVtYURlbGltaXRlciA9IHRoaXMub3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXI7XG5cbiAgICAvLyBlcnJvciBjaGVjayBvcHRpb25zXG4gICAgXy5lYWNoKG9wdGlvbnMudmFsaWRhdGUsICh2YWxpZGF0b3IsIHZhbGlkYXRvclR5cGUpID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgdmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIG1vZGVsIHZhbGlkYXRvciBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYSBmaWVsZC4gTW9kZWw6ICR7dGhpcy5uYW1lfSwgZmllbGQvdmFsaWRhdGlvbiBuYW1lOiAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVtYmVycyBvZiB0aGUgdmFsaWRhdGUgb3B0aW9uIG11c3QgYmUgZnVuY3Rpb25zLiBNb2RlbDogJHt0aGlzLm5hbWV9LCBlcnJvciB3aXRoIHZhbGlkYXRlIG1lbWJlciAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJhd0F0dHJpYnV0ZXMgPSBfLm1hcFZhbHVlcyhhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBuYW1lKSA9PiB7XG4gICAgICBhdHRyaWJ1dGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZGF0YXR5cGUgZm9yIGF0dHJpYnV0ZSBcIiR7dGhpcy5uYW1lfS4ke25hbWV9XCJgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgIT09IGZhbHNlICYmIF8uZ2V0KGF0dHJpYnV0ZSwgJ3ZhbGlkYXRlLm5vdE51bGwnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGVmaW5pdGlvbiBmb3IgXCIke3RoaXMubmFtZX0uJHtuYW1lfVwiLCBcIm5vdE51bGxcIiB2YWxpZGF0b3IgaXMgb25seSBhbGxvd2VkIHdpdGggXCJhbGxvd051bGw6ZmFsc2VcImApO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5nZXQoYXR0cmlidXRlLCAncmVmZXJlbmNlcy5tb2RlbC5wcm90b3R5cGUnKSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsID0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZSgpO1xuICAgIHRoaXMuX2luZGV4ZXMgPSB0aGlzLm9wdGlvbnMuaW5kZXhlc1xuICAgICAgLm1hcChpbmRleCA9PiBVdGlscy5uYW1lSW5kZXgodGhpcy5fY29uZm9ybUluZGV4KGluZGV4KSwgdGFibGVOYW1lKSk7XG5cbiAgICB0aGlzLnByaW1hcnlLZXlzID0ge307XG4gICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIC8vIHNldHVwIG5hbWVzIG9mIHRpbWVzdGFtcCBhdHRyaWJ1dGVzXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ2NyZWF0ZWRBdCcsICd1cGRhdGVkQXQnLCAnZGVsZXRlZEF0J10pIHtcbiAgICAgICAgaWYgKCFbJ3VuZGVmaW5lZCcsICdzdHJpbmcnLCAnYm9vbGVhbiddLmluY2x1ZGVzKHR5cGVvZiB0aGlzLm9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciBcIiR7a2V5fVwiIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYm9vbGVhbiwgZ290ICR7dHlwZW9mIHRoaXMub3B0aW9uc1trZXldfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNba2V5XSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciBcIiR7a2V5fVwiIG9wdGlvbiBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0ID1cbiAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmNyZWF0ZWRBdCA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMuY3JlYXRlZEF0IDogJ2NyZWF0ZWRBdCc7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ID1cbiAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZWRBdCA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMudXBkYXRlZEF0IDogJ3VwZGF0ZWRBdCc7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbm9pZCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCA9XG4gICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVkQXQgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCA6ICdkZWxldGVkQXQnO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXR1cCBuYW1lIGZvciB2ZXJzaW9uIGF0dHJpYnV0ZVxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyc2lvbikge1xuICAgICAgdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMudmVyc2lvbiA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMudmVyc2lvbiA6ICd2ZXJzaW9uJztcbiAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5faGFzUmVhZE9ubHlBdHRyaWJ1dGVzID0gdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLnNpemUgPiAwO1xuXG4gICAgLy8gQWRkIGhlYWQgYW5kIHRhaWwgZGVmYXVsdCBhdHRyaWJ1dGVzIChpZCwgdGltZXN0YW1wcylcbiAgICB0aGlzLl9hZGREZWZhdWx0QXR0cmlidXRlcygpO1xuICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLl9maW5kQXV0b0luY3JlbWVudEF0dHJpYnV0ZSgpO1xuXG4gICAgdGhpcy5fc2NvcGUgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlO1xuICAgIHRoaXMuX3Njb3BlTmFtZXMgPSBbJ2RlZmF1bHRTY29wZSddO1xuXG4gICAgdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmFkZE1vZGVsKHRoaXMpO1xuICAgIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdhZnRlckRlZmluZScsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgcmVmcmVzaEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuaXB1bGF0aW9uID0ge307XG5cbiAgICB0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycyA9IHt9O1xuICAgIHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzID0ge307XG5cbiAgICBbJ2dldCcsICdzZXQnXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgb3B0ID0gYCR7dHlwZX10ZXJNZXRob2RzYDtcbiAgICAgIGNvbnN0IGZ1bmNzID0geyAuLi50aGlzLm9wdGlvbnNbb3B0XSB9O1xuICAgICAgY29uc3QgX2N1c3RvbSA9IHR5cGUgPT09ICdnZXQnID8gdGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMgOiB0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycztcblxuICAgICAgXy5lYWNoKGZ1bmNzLCAobWV0aG9kLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgX2N1c3RvbVthdHRyaWJ1dGVdID0gbWV0aG9kO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZ2V0Jykge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyaWJ1dGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF8uZWFjaCh0aGlzLnJhd0F0dHJpYnV0ZXMsIChvcHRpb25zLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCB0eXBlKSkge1xuICAgICAgICAgIF9jdXN0b21bYXR0cmlidXRlXSA9IG9wdGlvbnNbdHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2dldCcpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnc2V0Jykge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfLmVhY2goZnVuY3MsIChmY3QsIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV0pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV0gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXVt0eXBlXSA9IGZjdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZGF0YVR5cGVDaGFuZ2VzID0ge307XG4gICAgdGhpcy5fZGF0YVR5cGVTYW5pdGl6ZXJzID0ge307XG5cbiAgICB0aGlzLl9oYXNCb29sZWFuQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0RhdGVBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgdGhpcy5fanNvbkF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlcyA9IHt9O1xuICAgIHRoaXMucHJvdG90eXBlLnZhbGlkYXRvcnMgPSB7fTtcblxuICAgIHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwID0ge307XG5cbiAgICB0aGlzLnByaW1hcnlLZXlzID0ge307XG4gICAgdGhpcy51bmlxdWVLZXlzID0ge307XG5cbiAgICBfLmVhY2godGhpcy5yYXdBdHRyaWJ1dGVzLCAoZGVmaW5pdGlvbiwgbmFtZSkgPT4ge1xuICAgICAgZGVmaW5pdGlvbi50eXBlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplRGF0YVR5cGUoZGVmaW5pdGlvbi50eXBlKTtcblxuICAgICAgZGVmaW5pdGlvbi5Nb2RlbCA9IHRoaXM7XG4gICAgICBkZWZpbml0aW9uLmZpZWxkTmFtZSA9IG5hbWU7XG4gICAgICBkZWZpbml0aW9uLl9tb2RlbEF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLmZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbi5maWVsZCA9IFV0aWxzLnVuZGVyc2NvcmVkSWYobmFtZSwgdGhpcy51bmRlcnNjb3JlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnByaW1hcnlLZXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5S2V5c1tuYW1lXSA9IGRlZmluaXRpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2RlZmluaXRpb24uZmllbGRdID0gZGVmaW5pdGlvbjtcblxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZS5fc2FuaXRpemUpIHtcbiAgICAgICAgdGhpcy5fZGF0YVR5cGVTYW5pdGl6ZXJzW25hbWVdID0gZGVmaW5pdGlvbi50eXBlLl9zYW5pdGl6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZS5faXNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2RhdGFUeXBlQ2hhbmdlc1tuYW1lXSA9IGRlZmluaXRpb24udHlwZS5faXNDaGFuZ2VkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkJPT0xFQU4pIHtcbiAgICAgICAgdGhpcy5faGFzQm9vbGVhbkF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURSB8fCBkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURU9OTFkpIHtcbiAgICAgICAgdGhpcy5faGFzRGF0ZUF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICB0aGlzLl9qc29uQXR0cmlidXRlcy5hZGQobmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5WSVJUVUFMKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCAnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlc1tuYW1lXSA9ICgpID0+IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmluaXRpb24uZGVmYXVsdFZhbHVlLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sICd1bmlxdWUnKSAmJiBkZWZpbml0aW9uLnVuaXF1ZSkge1xuICAgICAgICBsZXQgaWR4TmFtZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBkZWZpbml0aW9uLnVuaXF1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbi51bmlxdWUsICduYW1lJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGRlZmluaXRpb24udW5pcXVlLm5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24udW5pcXVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlkeE5hbWUgPSBkZWZpbml0aW9uLnVuaXF1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHhOYW1lID0gYCR7dGhpcy50YWJsZU5hbWV9XyR7bmFtZX1fdW5pcXVlYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMudW5pcXVlS2V5c1tpZHhOYW1lXSB8fCB7IGZpZWxkczogW10gfTtcblxuICAgICAgICBpZHguZmllbGRzLnB1c2goZGVmaW5pdGlvbi5maWVsZCk7XG4gICAgICAgIGlkeC5tc2cgPSBpZHgubXNnIHx8IGRlZmluaXRpb24udW5pcXVlLm1zZyB8fCBudWxsO1xuICAgICAgICBpZHgubmFtZSA9IGlkeE5hbWUgfHwgZmFsc2U7XG4gICAgICAgIGlkeC5jb2x1bW4gPSBuYW1lO1xuICAgICAgICBpZHguY3VzdG9tSW5kZXggPSBkZWZpbml0aW9uLnVuaXF1ZSAhPT0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnVuaXF1ZUtleXNbaWR4TmFtZV0gPSBpZHg7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgJ3ZhbGlkYXRlJykpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUudmFsaWRhdG9yc1tuYW1lXSA9IGRlZmluaXRpb24udmFsaWRhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLmluZGV4ID09PSB0cnVlICYmIGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OQikge1xuICAgICAgICB0aGlzLl9pbmRleGVzLnB1c2goXG4gICAgICAgICAgVXRpbHMubmFtZUluZGV4KFxuICAgICAgICAgICAgdGhpcy5fY29uZm9ybUluZGV4KHtcbiAgICAgICAgICAgICAgZmllbGRzOiBbZGVmaW5pdGlvbi5maWVsZCB8fCBuYW1lXSxcbiAgICAgICAgICAgICAgdXNpbmc6ICdnaW4nXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMuZ2V0VGFibGVOYW1lKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgZGVsZXRlIGRlZmluaXRpb24uaW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZmllbGQgdG8gYXR0cmlidXRlIG5hbWVzXG4gICAgdGhpcy5maWVsZEF0dHJpYnV0ZU1hcCA9IF8ucmVkdWNlKHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwLCAobWFwLCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZS5maWVsZE5hbWUpIHtcbiAgICAgICAgbWFwW2tleV0gPSB2YWx1ZS5maWVsZE5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcblxuICAgIHRoaXMuX2hhc0pzb25BdHRyaWJ1dGVzID0gISF0aGlzLl9qc29uQXR0cmlidXRlcy5zaXplO1xuXG4gICAgdGhpcy5faGFzVmlydHVhbEF0dHJpYnV0ZXMgPSAhIXRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLnNpemU7XG5cbiAgICB0aGlzLl9oYXNEZWZhdWx0VmFsdWVzID0gIV8uaXNFbXB0eSh0aGlzLl9kZWZhdWx0VmFsdWVzKTtcblxuICAgIHRoaXMudGFibGVBdHRyaWJ1dGVzID0gXy5vbWl0QnkodGhpcy5yYXdBdHRyaWJ1dGVzLCAoX2EsIGtleSkgPT4gdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGtleSkpO1xuXG4gICAgdGhpcy5wcm90b3R5cGUuX2hhc0N1c3RvbUdldHRlcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycykubGVuZ3RoO1xuICAgIHRoaXMucHJvdG90eXBlLl9oYXNDdXN0b21TZXR0ZXJzID0gT2JqZWN0LmtleXModGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnMpLmxlbmd0aDtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGF0dHJpYnV0ZU1hbmlwdWxhdGlvbikpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTW9kZWwucHJvdG90eXBlLCBrZXkpKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgTm90IG92ZXJyaWRpbmcgYnVpbHQtaW4gbWV0aG9kIGZyb20gbW9kZWwgYXR0cmlidXRlOiAke2tleX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIGtleSwgYXR0cmlidXRlTWFuaXB1bGF0aW9uW2tleV0pO1xuICAgIH1cblxuICAgIHRoaXMucHJvdG90eXBlLnJhd0F0dHJpYnV0ZXMgPSB0aGlzLnJhd0F0dHJpYnV0ZXM7XG4gICAgdGhpcy5wcm90b3R5cGUuX2lzQXR0cmlidXRlID0ga2V5ID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnByb3RvdHlwZS5yYXdBdHRyaWJ1dGVzLCBrZXkpO1xuXG4gICAgLy8gUHJpbWFyeSBrZXkgY29udmVuaWVuY2UgY29uc3RpYWJsZXNcbiAgICB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5wcmltYXJ5S2V5cyk7XG4gICAgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlID0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlc1swXTtcbiAgICBpZiAodGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlKSB7XG4gICAgICB0aGlzLnByaW1hcnlLZXlGaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkIHx8IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYXNQcmltYXJ5S2V5cyA9IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoID4gMDtcbiAgICB0aGlzLl9pc1ByaW1hcnlLZXkgPSBrZXkgPT4gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhdHRyaWJ1dGUgZnJvbSBtb2RlbCBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgbmFtZSBvZiBhdHRyaWJ1dGUgdG8gcmVtb3ZlXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGRlbGV0ZSB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogU3luYyB0aGlzIE1vZGVsIHRvIHRoZSBEQiwgdGhhdCBpcyBjcmVhdGUgdGhlIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIHN5bmMgb3B0aW9uc1xuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUjc3luY30gZm9yIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN5bmMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRpb25zLmhvb2tzO1xuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMudGFibGVBdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHJhd0F0dHJpYnV0ZXMgPSB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcDtcblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVTeW5jJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyk7XG5cbiAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgdGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5hbHRlcikge1xuICAgICAgY29uc3QgdGFibGVJbmZvcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5xdWVyeUludGVyZmFjZS5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyksXG4gICAgICAgIHRoaXMucXVlcnlJbnRlcmZhY2UuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB0YWJsZUluZm9zWzBdO1xuICAgICAgLy8gVXNlIGZvciBhbHRlciBmb3JlaWduIGtleXNcbiAgICAgIGNvbnN0IGZvcmVpZ25LZXlSZWZlcmVuY2VzID0gdGFibGVJbmZvc1sxXTtcbiAgICAgIGNvbnN0IHJlbW92ZWRDb25zdHJhaW50cyA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbk5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBjb2x1bW5OYW1lKSkgY29udGludWU7XG4gICAgICAgIGlmICghY29sdW1uc1tjb2x1bW5OYW1lXSAmJiAhY29sdW1uc1thdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLmZpZWxkXSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYWRkQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlc1tjb2x1bW5OYW1lXS5maWVsZCB8fCBjb2x1bW5OYW1lLCBhdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbHRlciA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucy5hbHRlciA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5hbHRlci5kcm9wICE9PSBmYWxzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbk5hbWUgaW4gY29sdW1ucykge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbHVtbnMsIGNvbHVtbk5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlID0gcmF3QXR0cmlidXRlc1tjb2x1bW5OYW1lXTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGUucHJpbWFyeUtleSkgY29udGludWU7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yZWlnbiBrZXlzLiBJZiBpdCdzIGEgZm9yZWlnbiBrZXksIGl0IHNob3VsZCByZW1vdmUgY29uc3RyYWludCBmaXJzdC5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gY3VycmVudEF0dHJpYnV0ZS5yZWZlcmVuY2VzO1xuICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLnNjaGVtYTtcbiAgICAgICAgICAgIC8vIEZpbmQgZXhpc3RlZCBmb3JlaWduIGtleXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleVJlZmVyZW5jZSBvZiBmb3JlaWduS2V5UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50TmFtZSA9IGZvcmVpZ25LZXlSZWZlcmVuY2UuY29uc3RyYWludE5hbWU7XG4gICAgICAgICAgICAgIGlmICghIWNvbnN0cmFpbnROYW1lXG4gICAgICAgICAgICAgICAgJiYgZm9yZWlnbktleVJlZmVyZW5jZS50YWJsZUNhdGFsb2cgPT09IGRhdGFiYXNlXG4gICAgICAgICAgICAgICAgJiYgKHNjaGVtYSA/IGZvcmVpZ25LZXlSZWZlcmVuY2UudGFibGVTY2hlbWEgPT09IHNjaGVtYSA6IHRydWUpXG4gICAgICAgICAgICAgICAgJiYgZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkVGFibGVOYW1lID09PSByZWZlcmVuY2VzLm1vZGVsXG4gICAgICAgICAgICAgICAgJiYgZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkQ29sdW1uTmFtZSA9PT0gcmVmZXJlbmNlcy5rZXlcbiAgICAgICAgICAgICAgICAmJiAoc2NoZW1hID8gZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkVGFibGVTY2hlbWEgPT09IHNjaGVtYSA6IHRydWUpXG4gICAgICAgICAgICAgICAgJiYgIXJlbW92ZWRDb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29uc3RyYWludCBvbiBmb3JlaWduIGtleXMuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRDb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgY3VycmVudEF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGluZGV4ZXMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnNob3dJbmRleCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGluZGV4ZXMgPSB0aGlzLl9pbmRleGVzLmZpbHRlcihpdGVtMSA9PlxuICAgICAgIWluZGV4ZXMuc29tZShpdGVtMiA9PiBpdGVtMS5uYW1lID09PSBpdGVtMi5uYW1lKVxuICAgICkuc29ydCgoaW5kZXgxLCBpbmRleDIpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09ICdwb3N0Z3JlcycpIHtcbiAgICAgIC8vIG1vdmUgY29uY3VycmVudCBpbmRleGVzIHRvIHRoZSBib3R0b20gdG8gYXZvaWQgd2VpcmQgZGVhZGxvY2tzXG4gICAgICAgIGlmIChpbmRleDEuY29uY3VycmVudGx5ID09PSB0cnVlKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGluZGV4Mi5jb25jdXJyZW50bHkgPT09IHRydWUpIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYWRkSW5kZXgodGFibGVOYW1lLCB7IC4uLm9wdGlvbnMsIC4uLmluZGV4IH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlclN5bmMnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIHRoZSB0YWJsZSByZXByZXNlbnRlZCBieSB0aGlzIE1vZGVsXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zXSBkcm9wIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuY2FzY2FkZT1mYWxzZV0gICBBbHNvIGRyb3AgYWxsIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoaXMgdGFibGUsIHN1Y2ggYXMgdmlld3MuIE9ubHkgd29ya3MgaW4gcG9zdGdyZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZHJvcChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZHJvcFRhYmxlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRyb3BTY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNjaGVtYSB0byB0aGlzIG1vZGVsLiBGb3IgcG9zdGdyZXMsIHRoaXMgd2lsbCBhY3R1YWxseSBwbGFjZSB0aGUgc2NoZW1hIGluIGZyb250IG9mIHRoZSB0YWJsZSBuYW1lIC0gYFwic2NoZW1hXCIuXCJ0YWJsZU5hbWVcImAsXG4gICAqIHdoaWxlIHRoZSBzY2hlbWEgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIHRhYmxlIG5hbWUgZm9yIG15c3FsIGFuZCBzcWxpdGUgLSBgJ3NjaGVtYS50YWJsZW5hbWUnYC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHVzZSBjYXNlcyB3aGVyZSB0aGUgc2FtZSBtb2RlbCBpcyBuZWVkZWQgaW4gbXVsdGlwbGUgc2NoZW1hcy4gSW4gc3VjaCBhIHVzZSBjYXNlIGl0IGlzIGltcG9ydGFudFxuICAgKiB0byBjYWxsIGBtb2RlbC5zY2hlbWEoc2NoZW1hLCBbb3B0aW9uc10pLnN5bmMoKWAgZm9yIGVhY2ggbW9kZWwgdG8gZW5zdXJlIHRoZSBtb2RlbHMgYXJlIGNyZWF0ZWQgaW4gdGhlIGNvcnJlY3Qgc2NoZW1hLlxuICAgKlxuICAgKiBJZiBhIHNpbmdsZSBkZWZhdWx0IHNjaGVtYSBwZXIgbW9kZWwgaXMgbmVlZGVkLCBzZXQgdGhlIGBvcHRpb25zLnNjaGVtYT0nc2NoZW1hJ2AgcGFyYW1ldGVyIGR1cmluZyB0aGUgYGRlZmluZSgpYCBjYWxsXG4gICAqIGZvciB0aGUgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIHNjaGVtYSBUaGUgbmFtZSBvZiB0aGUgc2NoZW1hXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zXSBzY2hlbWEgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXI9Jy4nXSBUaGUgY2hhcmFjdGVyKHMpIHRoYXQgc2VwYXJhdGVzIHRoZSBzY2hlbWEgbmFtZSBmcm9tIHRoZSB0YWJsZSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUjZGVmaW5lfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBzZXR0aW5nIGEgZGVmYXVsdCBzY2hlbWEuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH1cbiAgICovXG4gIHN0YXRpYyBzY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBjbG9uZSA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsICduYW1lJywgeyB2YWx1ZTogdGhpcy5uYW1lIH0pO1xuXG4gICAgY2xvbmUuX3NjaGVtYSA9IHNjaGVtYTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNsb25lLl9zY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNjaGVtYURlbGltaXRlcikge1xuICAgICAgICBjbG9uZS5fc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFibGUgbmFtZSBvZiB0aGUgbW9kZWwsIHRha2luZyBzY2hlbWEgaW50byBhY2NvdW50LiBUaGUgbWV0aG9kIHdpbGwgcmV0dXJuIFRoZSBuYW1lIGFzIGEgc3RyaW5nIGlmIHRoZSBtb2RlbCBoYXMgbm8gc2NoZW1hLFxuICAgKiBvciBhbiBvYmplY3Qgd2l0aCBgdGFibGVOYW1lYCwgYHNjaGVtYWAgYW5kIGBkZWxpbWl0ZXJgIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldFRhYmxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRTY2hlbWEodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVuLXNjb3BlZCBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9XG4gICAqL1xuICBzdGF0aWMgdW5zY29wZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc2NvcGUgdG8gdGhlIG1vZGVsLiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBhZGRpbmcgc2NvcGVzIHdpdGggaW5jbHVkZXMsIHdoZW4gdGhlIG1vZGVsIHlvdSB3YW50IHRvIGluY2x1ZGUgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGUgdGltZSB0aGlzIG1vZGVsIGlzIGRlZmluZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgc2NvcGUgd2l0aCB0aGF0IG5hbWUgYWxyZWFkeSBleGlzdHMuIFBhc3MgYG92ZXJyaWRlOiB0cnVlYCBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2lsZW5jZSB0aGlzIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2NvcGUuIFVzZSBgZGVmYXVsdFNjb3BlYCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY29wZVxuICAgKiBAcGFyYW0ge29iamVjdHxGdW5jdGlvbn0gc2NvcGUgc2NvcGUgb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnNdIHNjb3BlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLm92ZXJyaWRlPWZhbHNlXSBvdmVycmlkZSBvbGQgc2NvcGUgaWYgYWxyZWFkeSBkZWZpbmVkXG4gICAqL1xuICBzdGF0aWMgYWRkU2NvcGUobmFtZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyBvdmVycmlkZTogZmFsc2UsIC4uLm9wdGlvbnMgfTtcblxuICAgIGlmICgobmFtZSA9PT0gJ2RlZmF1bHRTY29wZScgJiYgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZSkubGVuZ3RoID4gMCB8fCBuYW1lIGluIHRoaXMub3B0aW9ucy5zY29wZXMpICYmIG9wdGlvbnMub3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzY29wZSAke25hbWV9IGFscmVhZHkgZXhpc3RzLiBQYXNzIHsgb3ZlcnJpZGU6IHRydWUgfSBhcyBvcHRpb25zIHRvIHNpbGVuY2UgdGhpcyBlcnJvcmApO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnZGVmYXVsdFNjb3BlJykge1xuICAgICAgdGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZSA9IHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY29wZXNbbmFtZV0gPSBzY29wZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSBzY29wZSBjcmVhdGVkIGluIGBkZWZpbmVgIHRvIHRoZSBtb2RlbC5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+aG93IHRvIGNyZWF0ZSBzY29wZXM8L2NhcHRpb24+XG4gICAqIGNvbnN0IE1vZGVsID0gc2VxdWVsaXplLmRlZmluZSgnbW9kZWwnLCBhdHRyaWJ1dGVzLCB7XG4gICAqICAgZGVmYXVsdFNjb3BlOiB7XG4gICAqICAgICB3aGVyZToge1xuICAgKiAgICAgICB1c2VybmFtZTogJ2RhbidcbiAgICogICAgIH0sXG4gICAqICAgICBsaW1pdDogMTJcbiAgICogICB9LFxuICAgKiAgIHNjb3Blczoge1xuICAgKiAgICAgaXNBTGllOiB7XG4gICAqICAgICAgIHdoZXJlOiB7XG4gICAqICAgICAgICAgc3R1ZmY6ICdjYWtlJ1xuICAgKiAgICAgICB9XG4gICAqICAgICB9LFxuICAgKiAgICAgY29tcGxleEZ1bmN0aW9uOiBmdW5jdGlvbihlbWFpbCwgYWNjZXNzTGV2ZWwpIHtcbiAgICogICAgICAgcmV0dXJuIHtcbiAgICogICAgICAgICB3aGVyZToge1xuICAgKiAgICAgICAgICAgZW1haWw6IHtcbiAgICogICAgICAgICAgICAgW09wLmxpa2VdOiBlbWFpbFxuICAgKiAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgIGFjY2Vzc19sZXZlbCB7XG4gICAqICAgICAgICAgICAgIFtPcC5ndGVdOiBhY2Nlc3NMZXZlbFxuICAgKiAgICAgICAgICAgfVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogIyBBcyB5b3UgaGF2ZSBkZWZpbmVkIGEgZGVmYXVsdCBzY29wZSwgZXZlcnkgdGltZSB5b3UgZG8gTW9kZWwuZmluZCwgdGhlIGRlZmF1bHQgc2NvcGUgaXMgYXBwZW5kZWQgdG8geW91ciBxdWVyeS4gSGVyZSdzIGEgY291cGxlIG9mIGV4YW1wbGVzOlxuICAgKlxuICAgKiBNb2RlbC5maW5kQWxsKCkgLy8gV0hFUkUgdXNlcm5hbWUgPSAnZGFuJ1xuICAgKiBNb2RlbC5maW5kQWxsKHsgd2hlcmU6IHsgYWdlOiB7IFtPcC5ndF06IDEyIH0gfSB9KSAvLyBXSEVSRSBhZ2UgPiAxMiBBTkQgdXNlcm5hbWUgPSAnZGFuJ1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5UbyBpbnZva2Ugc2NvcGUgZnVuY3Rpb25zIHlvdSBjYW4gZG88L2NhcHRpb24+XG4gICAqIE1vZGVsLnNjb3BlKHsgbWV0aG9kOiBbJ2NvbXBsZXhGdW5jdGlvbicsICdkYW5Ac2VxdWVsaXplLmNvbScsIDQyXX0pLmZpbmRBbGwoKVxuICAgKiAvLyBXSEVSRSBlbWFpbCBsaWtlICdkYW5Ac2VxdWVsaXplLmNvbSUnIEFORCBhY2Nlc3NfbGV2ZWwgPj0gNDJcbiAgICpcbiAgICogQHBhcmFtIHs/QXJyYXl8b2JqZWN0fHN0cmluZ30gW29wdGlvbl0gVGhlIHNjb3BlKHMpIHRvIGFwcGx5LiBTY29wZXMgY2FuIGVpdGhlciBiZSBwYXNzZWQgYXMgY29uc2VjdXRpdmUgYXJndW1lbnRzLCBvciBhcyBhbiBhcnJheSBvZiBhcmd1bWVudHMuIFRvIGFwcGx5IHNpbXBsZSBzY29wZXMgYW5kIHNjb3BlIGZ1bmN0aW9ucyB3aXRoIG5vIGFyZ3VtZW50cywgcGFzcyB0aGVtIGFzIHN0cmluZ3MuIEZvciBzY29wZSBmdW5jdGlvbiwgcGFzcyBhbiBvYmplY3QsIHdpdGggYSBgbWV0aG9kYCBwcm9wZXJ0eS4gVGhlIHZhbHVlIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcsIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgdGFrZSBhbnkgYXJndW1lbnRzLCBvciBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCwgYW5kIGNvbnNlY3V0aXZlIGVsZW1lbnRzIGFyZSBhcmd1bWVudHMgdG8gdGhhdCBtZXRob2QuIFBhc3MgbnVsbCB0byByZW1vdmUgYWxsIHNjb3BlcywgaW5jbHVkaW5nIHRoZSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9IEEgcmVmZXJlbmNlIHRvIHRoZSBtb2RlbCwgd2l0aCB0aGUgc2NvcGUocykgYXBwbGllZC4gQ2FsbGluZyBzY29wZSBhZ2FpbiBvbiB0aGUgcmV0dXJuZWQgbW9kZWwgd2lsbCBjbGVhciB0aGUgcHJldmlvdXMgc2NvcGUuXG4gICAqL1xuICBzdGF0aWMgc2NvcGUob3B0aW9uKSB7XG4gICAgY29uc3Qgc2VsZiA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7fTtcbiAgICBsZXQgc2NvcGU7XG4gICAgbGV0IHNjb3BlTmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnbmFtZScsIHsgdmFsdWU6IHRoaXMubmFtZSB9KTtcblxuICAgIHNlbGYuX3Njb3BlID0ge307XG4gICAgc2VsZi5fc2NvcGVOYW1lcyA9IFtdO1xuICAgIHNlbGYuc2NvcGVkID0gdHJ1ZTtcblxuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gXy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICBzY29wZSA9IG51bGw7XG4gICAgICBzY29wZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbikpIHtcbiAgICAgICAgaWYgKG9wdGlvbi5tZXRob2QpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb24ubWV0aG9kKSAmJiAhIXNlbGYub3B0aW9ucy5zY29wZXNbb3B0aW9uLm1ldGhvZFswXV0pIHtcbiAgICAgICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbi5tZXRob2RbMF07XG4gICAgICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXS5hcHBseShzZWxmLCBvcHRpb24ubWV0aG9kLnNsaWNlKDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc2VsZi5vcHRpb25zLnNjb3Blc1tvcHRpb24ubWV0aG9kXSkge1xuICAgICAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uLm1ldGhvZDtcbiAgICAgICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdLmFwcGx5KHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZSA9IG9wdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRpb24gPT09ICdkZWZhdWx0U2NvcGUnICYmIF8uaXNQbGFpbk9iamVjdChzZWxmLm9wdGlvbnMuZGVmYXVsdFNjb3BlKSkge1xuICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5kZWZhdWx0U2NvcGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZU5hbWUgPSBvcHRpb247XG4gICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHNjb3BlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2NvcGUgPSBzY29wZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZSkge1xuICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoc2NvcGUsIHRoaXMpO1xuICAgICAgICAvLyBjbG9uZSBzY29wZSBzbyBpdCBkb2Vzbid0IGdldCBtb2RpZmllZFxuICAgICAgICB0aGlzLl9hc3NpZ25PcHRpb25zKHNlbGYuX3Njb3BlLCBVdGlscy5jbG9uZURlZXAoc2NvcGUpKTtcbiAgICAgICAgc2VsZi5fc2NvcGVOYW1lcy5wdXNoKHNjb3BlTmFtZSA/IHNjb3BlTmFtZSA6ICdkZWZhdWx0U2NvcGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuU2VxdWVsaXplU2NvcGVFcnJvcihgSW52YWxpZCBzY29wZSAke3Njb3BlTmFtZX0gY2FsbGVkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgbXVsdGlwbGUgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TaW1wbGUgc2VhcmNoIHVzaW5nIEFORCBhbmQgPTwvY2FwdGlvbj5cbiAgICogTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IHtcbiAgICogICAgIGF0dHIxOiA0MixcbiAgICogICAgIGF0dHIyOiAnY2FrZSdcbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqICMgV0hFUkUgYXR0cjEgPSA0MiBBTkQgYXR0cjIgPSAnY2FrZSdcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VXNpbmcgZ3JlYXRlciB0aGFuLCBsZXNzIHRoYW4gZXRjLjwvY2FwdGlvbj5cbiAgICogY29uc3Qge2d0LCBsdGUsIG5lLCBpbjogb3BJbn0gPSBTZXF1ZWxpemUuT3A7XG4gICAqXG4gICAqIE1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiB7XG4gICAqICAgICBhdHRyMToge1xuICAgKiAgICAgICBbZ3RdOiA1MFxuICAgKiAgICAgfSxcbiAgICogICAgIGF0dHIyOiB7XG4gICAqICAgICAgIFtsdGVdOiA0NVxuICAgKiAgICAgfSxcbiAgICogICAgIGF0dHIzOiB7XG4gICAqICAgICAgIFtvcEluXTogWzEsMiwzXVxuICAgKiAgICAgfSxcbiAgICogICAgIGF0dHI0OiB7XG4gICAqICAgICAgIFtuZV06IDVcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqICMgV0hFUkUgYXR0cjEgPiA1MCBBTkQgYXR0cjIgPD0gNDUgQU5EIGF0dHIzIElOICgxLDIsMykgQU5EIGF0dHI0ICE9IDVcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UXVlcmllcyB1c2luZyBPUjwvY2FwdGlvbj5cbiAgICogY29uc3Qge29yLCBhbmQsIGd0LCBsdH0gPSBTZXF1ZWxpemUuT3A7XG4gICAqXG4gICAqIE1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiB7XG4gICAqICAgICBuYW1lOiAnYSBwcm9qZWN0JyxcbiAgICogICAgIFtvcl06IFtcbiAgICogICAgICAge2lkOiBbMSwgMiwgM119LFxuICAgKiAgICAgICB7XG4gICAqICAgICAgICAgW2FuZF06IFtcbiAgICogICAgICAgICAgIHtpZDoge1tndF06IDEwfX0sXG4gICAqICAgICAgICAgICB7aWQ6IHtbbHRdOiAxMDB9fVxuICAgKiAgICAgICAgIF1cbiAgICogICAgICAgfVxuICAgKiAgICAgXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqICMgV0hFUkUgYE1vZGVsYC5gbmFtZWAgPSAnYSBwcm9qZWN0JyBBTkQgKGBNb2RlbGAuYGlkYCBJTiAoMSwgMiwgMykgT1IgKGBNb2RlbGAuYGlkYCA+IDEwIEFORCBgTW9kZWxgLmBpZGAgPCAxMDApKTtcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgT3BlcmF0b3JzfSBmb3IgcG9zc2libGUgb3BlcmF0b3JzXG4gICAqIF9fQWxpYXNfXzogX2FsbF9cbiAgICpcbiAgICogVGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBNb2RlbCBpbnN0YW5jZXMgaWYgdGhlIHF1ZXJ5IHN1Y2NlZWRzLl9cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9uc10gQSBoYXNoIG9mIG9wdGlvbnMgdG8gZGVzY3JpYmUgdGhlIHNjb3BlIG9mIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy53aGVyZV0gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gZGVzY3JpYmUgeW91ciBzZWFyY2guIFNlZSBhYm92ZSBmb3IgZXhhbXBsZXMuXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz58b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuYXR0cmlidXRlc10gQSBsaXN0IG9mIHRoZSBhdHRyaWJ1dGVzIHRoYXQgeW91IHdhbnQgdG8gc2VsZWN0LCBvciBhbiBvYmplY3Qgd2l0aCBgaW5jbHVkZWAgYW5kIGBleGNsdWRlYCBrZXlzLiBUbyByZW5hbWUgYW4gYXR0cmlidXRlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXksIHdpdGggdHdvIGVsZW1lbnRzIC0gdGhlIGZpcnN0IGlzIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIERCIChvciBzb21lIGtpbmQgb2YgZXhwcmVzc2lvbiBzdWNoIGFzIGBTZXF1ZWxpemUubGl0ZXJhbGAsIGBTZXF1ZWxpemUuZm5gIGFuZCBzbyBvbiksIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBuYW1lIHlvdSB3YW50IHRoZSBhdHRyaWJ1dGUgdG8gaGF2ZSBpbiB0aGUgcmV0dXJuZWQgaW5zdGFuY2VcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVdIFNlbGVjdCBhbGwgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsLCBwbHVzIHNvbWUgYWRkaXRpb25hbCBvbmVzLiBVc2VmdWwgZm9yIGFnZ3JlZ2F0aW9ucywgZS5nLiBgeyBhdHRyaWJ1dGVzOiB7IGluY2x1ZGU6IFtbc2VxdWVsaXplLmZuKCdDT1VOVCcsIHNlcXVlbGl6ZS5jb2woJ2lkJykpLCAndG90YWwnXV0gfWBcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5hdHRyaWJ1dGVzLmV4Y2x1ZGVdIFNlbGVjdCBhbGwgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsLCBleGNlcHQgc29tZSBmZXcuIFVzZWZ1bCBmb3Igc2VjdXJpdHkgcHVycG9zZXMgZS5nLiBgeyBhdHRyaWJ1dGVzOiB7IGV4Y2x1ZGU6IFsncGFzc3dvcmQnXSB9IH1gXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMucGFyYW5vaWQ9dHJ1ZV0gSWYgdHJ1ZSwgb25seSBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgcmV0dXJuZWQuIElmIGZhbHNlLCBib3RoIGRlbGV0ZWQgYW5kIG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSByZXR1cm5lZC4gT25seSBhcHBsaWVzIGlmIGBvcHRpb25zLnBhcmFub2lkYCBpcyB0cnVlIGZvciB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSAge0FycmF5PG9iamVjdHxNb2RlbHxzdHJpbmc+fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZV0gQSBsaXN0IG9mIGFzc29jaWF0aW9ucyB0byBlYWdlcmx5IGxvYWQgdXNpbmcgYSBsZWZ0IGpvaW4uIFN1cHBvcnRlZCBpcyBlaXRoZXIgYHsgaW5jbHVkZTogWyBNb2RlbDEsIE1vZGVsMiwgLi4uXX1gIG9yIGB7IGluY2x1ZGU6IFt7IG1vZGVsOiBNb2RlbDEsIGFzOiAnQWxpYXMnIH1dfWAgb3IgYHsgaW5jbHVkZTogWydBbGlhcyddfWAuIElmIHlvdXIgYXNzb2NpYXRpb24gYXJlIHNldCB1cCB3aXRoIGFuIGBhc2AgKGVnLiBgWC5oYXNNYW55KFksIHsgYXM6ICdaIH1gLCB5b3UgbmVlZCB0byBzcGVjaWZ5IFogaW4gdGhlIGFzIGF0dHJpYnV0ZSB3aGVuIGVhZ2VyIGxvYWRpbmcgWSkuXG4gICAqIEBwYXJhbSAge01vZGVsfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLm1vZGVsXSBUaGUgbW9kZWwgeW91IHdhbnQgdG8gZWFnZXJseSBsb2FkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmFzXSBUaGUgYWxpYXMgb2YgdGhlIHJlbGF0aW9uLCBpbiBjYXNlIHRoZSBtb2RlbCB5b3Ugd2FudCB0byBlYWdlcmx5IGxvYWQgaXMgYWxpYXNlZC4gRm9yIGBoYXNPbmVgIC8gYGJlbG9uZ3NUb2AsIHRoaXMgc2hvdWxkIGJlIHRoZSBzaW5ndWxhciBuYW1lLCBhbmQgZm9yIGBoYXNNYW55YCwgaXQgc2hvdWxkIGJlIHRoZSBwbHVyYWxcbiAgICogQHBhcmFtICB7QXNzb2NpYXRpb259ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uYXNzb2NpYXRpb25dIFRoZSBhc3NvY2lhdGlvbiB5b3Ugd2FudCB0byBlYWdlcmx5IGxvYWQuIChUaGlzIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgcHJvdmlkaW5nIGEgbW9kZWwvYXMgcGFpcilcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ud2hlcmVdIFdoZXJlIGNsYXVzZXMgdG8gYXBwbHkgdG8gdGhlIGNoaWxkIG1vZGVscy4gTm90ZSB0aGF0IHRoaXMgY29udmVydHMgdGhlIGVhZ2VyIGxvYWQgdG8gYW4gaW5uZXIgam9pbiwgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBgcmVxdWlyZWQ6IGZhbHNlYFxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5vcj1mYWxzZV0gV2hldGhlciB0byBiaW5kIHRoZSBPTiBhbmQgV0hFUkUgY2xhdXNlIHRvZ2V0aGVyIGJ5IE9SIGluc3RlYWQgb2YgQU5ELlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5vbl0gU3VwcGx5IHlvdXIgb3duIE9OIGNvbmRpdGlvbiBmb3IgdGhlIGpvaW4uXG4gICAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmF0dHJpYnV0ZXNdIEEgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNlbGVjdCBmcm9tIHRoZSBjaGlsZCBtb2RlbFxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5yZXF1aXJlZF0gSWYgdHJ1ZSwgY29udmVydHMgdG8gYW4gaW5uZXIgam9pbiwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgcGFyZW50IG1vZGVsIHdpbGwgb25seSBiZSBsb2FkZWQgaWYgaXQgaGFzIGFueSBtYXRjaGluZyBjaGlsZHJlbi4gVHJ1ZSBpZiBgaW5jbHVkZS53aGVyZWAgaXMgc2V0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnJpZ2h0XSBJZiB0cnVlLCBjb252ZXJ0cyB0byBhIHJpZ2h0IGpvaW4gaWYgZGlhbGVjdCBzdXBwb3J0IGl0LiBJZ25vcmVkIGlmIGBpbmNsdWRlLnJlcXVpcmVkYCBpcyB0cnVlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5zZXBhcmF0ZV0gSWYgdHJ1ZSwgcnVucyBhIHNlcGFyYXRlIHF1ZXJ5IHRvIGZldGNoIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlcywgb25seSBzdXBwb3J0ZWQgZm9yIGhhc01hbnkgYXNzb2NpYXRpb25zXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmxpbWl0XSBMaW1pdCB0aGUgam9pbmVkIHJvd3MsIG9ubHkgc3VwcG9ydGVkIHdpdGggaW5jbHVkZS5zZXBhcmF0ZT10cnVlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnRocm91Z2guYXNdIFRoZSBhbGlhcyBmb3IgdGhlIGpvaW4gbW9kZWwsIGluIGNhc2UgeW91IHdhbnQgdG8gZ2l2ZSBpdCBhIGRpZmZlcmVudCBuYW1lIHRoYW4gdGhlIGRlZmF1bHQgb25lLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS50aHJvdWdoLndoZXJlXSBGaWx0ZXIgb24gdGhlIGpvaW4gbW9kZWwgZm9yIGJlbG9uZ3NUb01hbnkgcmVsYXRpb25zXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnRocm91Z2guYXR0cmlidXRlc10gQSBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gc2VsZWN0IGZyb20gdGhlIGpvaW4gbW9kZWwgZm9yIGJlbG9uZ3NUb01hbnkgcmVsYXRpb25zXG4gICAqIEBwYXJhbSAge0FycmF5PG9iamVjdHxNb2RlbHxzdHJpbmc+fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLmluY2x1ZGVdIExvYWQgZnVydGhlciBuZXN0ZWQgcmVsYXRlZCBtb2RlbHNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uZHVwbGljYXRpbmddIE1hcmsgdGhlIGluY2x1ZGUgYXMgZHVwbGljYXRpbmcsIHdpbGwgcHJldmVudCBhIHN1YnF1ZXJ5IGZyb20gYmVpbmcgdXNlZC5cbiAgICogQHBhcmFtICB7QXJyYXl8U2VxdWVsaXplLmZufFNlcXVlbGl6ZS5jb2x8U2VxdWVsaXplLmxpdGVyYWx9ICAgICAgICBbb3B0aW9ucy5vcmRlcl0gU3BlY2lmaWVzIGFuIG9yZGVyaW5nLiBVc2luZyBhbiBhcnJheSwgeW91IGNhbiBwcm92aWRlIHNldmVyYWwgY29sdW1ucyAvIGZ1bmN0aW9ucyB0byBvcmRlciBieS4gRWFjaCBlbGVtZW50IGNhbiBiZSBmdXJ0aGVyIHdyYXBwZWQgaW4gYSB0d28tZWxlbWVudCBhcnJheS4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGNvbHVtbiAvIGZ1bmN0aW9uIHRvIG9yZGVyIGJ5LCB0aGUgc2Vjb25kIGlzIHRoZSBkaXJlY3Rpb24uIEZvciBleGFtcGxlOiBgb3JkZXI6IFtbJ25hbWUnLCAnREVTQyddXWAuIEluIHRoaXMgd2F5IHRoZSBjb2x1bW4gd2lsbCBiZSBlc2NhcGVkLCBidXQgdGhlIGRpcmVjdGlvbiB3aWxsIG5vdC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5saW1pdF0gTGltaXQgZm9yIHJlc3VsdFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLm9mZnNldF0gT2Zmc2V0IGZvciByZXN1bHRcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMubG9ja10gTG9jayB0aGUgc2VsZWN0ZWQgcm93cy4gUG9zc2libGUgb3B0aW9ucyBhcmUgdHJhbnNhY3Rpb24uTE9DSy5VUERBVEUgYW5kIHRyYW5zYWN0aW9uLkxPQ0suU0hBUkUuIFBvc3RncmVzIGFsc28gc3VwcG9ydHMgdHJhbnNhY3Rpb24uTE9DSy5LRVlfU0hBUkUsIHRyYW5zYWN0aW9uLkxPQ0suTk9fS0VZX1VQREFURSBhbmQgc3BlY2lmaWMgbW9kZWwgbG9ja3Mgd2l0aCBqb2lucy5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5za2lwTG9ja2VkXSBTa2lwIGxvY2tlZCByb3dzLiBPbmx5IHN1cHBvcnRlZCBpbiBQb3N0Z3Jlcy5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5yYXddIFJldHVybiByYXcgcmVzdWx0LiBTZWUgc2VxdWVsaXplLnF1ZXJ5IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaGF2aW5nXSBIYXZpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtICB7Ym9vbGVhbnxFcnJvcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5yZWplY3RPbkVtcHR5PWZhbHNlXSBUaHJvd3MgYW4gZXJyb3Igd2hlbiBubyByZWNvcmRzIGZvdW5kXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZSNxdWVyeX1cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TW9kZWw+Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kQWxsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuUXVlcnlFcnJvcignVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQWxsIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlF1ZXJ5RXJyb3IoJ1RoZSBhdHRyaWJ1dGVzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mIGNvbHVtbiBuYW1lcyBvciBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndhcm5PbkludmFsaWRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcykpO1xuXG4gICAgY29uc3QgdGFibGVOYW1lcyA9IHt9O1xuXG4gICAgdGFibGVOYW1lc1t0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKV0gPSB0cnVlO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgaG9va3M6IHRydWUgfSk7XG5cbiAgICAvLyBzZXQgcmVqZWN0T25FbXB0eSBvcHRpb24sIGRlZmF1bHRzIHRvIG1vZGVsIG9wdGlvbnNcbiAgICBvcHRpb25zLnJlamVjdE9uRW1wdHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3JlamVjdE9uRW1wdHknKVxuICAgICAgPyBvcHRpb25zLnJlamVjdE9uRW1wdHlcbiAgICAgIDogdGhpcy5vcHRpb25zLnJlamVjdE9uRW1wdHk7XG5cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVGaW5kJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICB0aGlzLl9leHBhbmRBdHRyaWJ1dGVzKG9wdGlvbnMpO1xuICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyA9IHRoaXMuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBvcHRpb25zLmhhc0pvaW4gPSB0cnVlO1xuXG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucywgdGFibGVOYW1lcyk7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCByYXcsIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHdlIGluY2x1ZGUgdGhlIHByaW1hcnkga2V5IGZvciBkZS1kdXBsaWNhdGlvblxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgICAgJiYgIW9wdGlvbnMucmF3XG4gICAgICAgICYmIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSlcbiAgICAgICAgJiYgKCFvcHRpb25zLmdyb3VwIHx8ICFvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbilcbiAgICAgICkge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5jb25jYXQob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIG9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzID0gdGhpcy5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICAvLyB3aGVyZUNvbGxlY3Rpb24gaXMgdXNlZCBmb3Igbm9uLXByaW1hcnkga2V5IHVwZGF0ZXNcbiAgICB0aGlzLm9wdGlvbnMud2hlcmVDb2xsZWN0aW9uID0gb3B0aW9ucy53aGVyZSB8fCBudWxsO1xuXG4gICAgVXRpbHMubWFwRmluZGVyT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcblxuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHRhYmxlTmFtZXM6IE9iamVjdC5rZXlzKHRhYmxlTmFtZXMpIH07XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2Uuc2VsZWN0KHRoaXMsIHRoaXMuZ2V0VGFibGVOYW1lKHNlbGVjdE9wdGlvbnMpLCBzZWxlY3RPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJGaW5kJywgcmVzdWx0cywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy9yZWplY3RPbkVtcHR5IG1vZGVcbiAgICBpZiAoXy5pc0VtcHR5KHJlc3VsdHMpICYmIG9wdGlvbnMucmVqZWN0T25FbXB0eSkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlamVjdE9uRW1wdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IG9wdGlvbnMucmVqZWN0T25FbXB0eSgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlamVjdE9uRW1wdHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG9wdGlvbnMucmVqZWN0T25FbXB0eTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRW1wdHlSZXN1bHRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBNb2RlbC5fZmluZFNlcGFyYXRlKHJlc3VsdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIHdhcm5PbkludmFsaWRPcHRpb25zKG9wdGlvbnMsIHZhbGlkQ29sdW1uTmFtZXMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVucmVjb2duaXplZE9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoayA9PiAhdmFsaWRRdWVyeUtleXdvcmRzLmhhcyhrKSk7XG4gICAgY29uc3QgdW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcyA9IF8uaW50ZXJzZWN0aW9uKHVucmVjb2duaXplZE9wdGlvbnMsIHZhbGlkQ29sdW1uTmFtZXMpO1xuICAgIGlmICghb3B0aW9ucy53aGVyZSAmJiB1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBNb2RlbCBhdHRyaWJ1dGVzICgke3VuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMuam9pbignLCAnKX0pIHBhc3NlZCBpbnRvIGZpbmRlciBtZXRob2Qgb3B0aW9ucyBvZiBtb2RlbCAke3RoaXMubmFtZX0sIGJ1dCB0aGUgb3B0aW9ucy53aGVyZSBvYmplY3QgaXMgZW1wdHkuIERpZCB5b3UgZm9yZ2V0IHRvIHVzZSBvcHRpb25zLndoZXJlP2ApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfaW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGlmICghdGhpcy5faGFzVmlydHVhbEF0dHJpYnV0ZXMpIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIGlmICghYXR0cmlidXRlcyB8fCAhQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkgcmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGUpXG4gICAgICAgICYmIHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdLnR5cGUuZmllbGRzXG4gICAgICApIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdLnR5cGUuZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVzID0gXy51bmlxKGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgX2ZpbmRTZXBhcmF0ZShyZXN1bHRzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUgfHwgb3B0aW9ucy5yYXcgfHwgIXJlc3VsdHMpIHJldHVybiByZXN1bHRzO1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSByZXN1bHRzO1xuICAgIGlmIChvcHRpb25zLnBsYWluKSByZXN1bHRzID0gW3Jlc3VsdHNdO1xuXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkgcmV0dXJuIG9yaWdpbmFsO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5pbmNsdWRlLm1hcChhc3luYyBpbmNsdWRlID0+IHtcbiAgICAgIGlmICghaW5jbHVkZS5zZXBhcmF0ZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgTW9kZWwuX2ZpbmRTZXBhcmF0ZShcbiAgICAgICAgICByZXN1bHRzLnJlZHVjZSgobWVtbywgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYXNzb2NpYXRpb25zID0gcmVzdWx0LmdldChpbmNsdWRlLmFzc29jaWF0aW9uLmFzKTtcblxuICAgICAgICAgICAgLy8gTWlnaHQgYmUgYW4gZW1wdHkgYmVsb25nc1RvIHJlbGF0aW9uXG4gICAgICAgICAgICBpZiAoIWFzc29jaWF0aW9ucykgcmV0dXJuIG1lbW87XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGFycmF5IHNvIHdlIGNhbiBjb25jYXQgbm8gbWF0dGVyIGlmIGl0J3MgMToxIG9yIDpNXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNzb2NpYXRpb25zKSkgYXNzb2NpYXRpb25zID0gW2Fzc29jaWF0aW9uc107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhc3NvY2lhdGlvbnMubGVuZ3RoOyBpICE9PSBsZW47ICsraSkge1xuICAgICAgICAgICAgICBtZW1vLnB1c2goYXNzb2NpYXRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIC4uLl8ub21pdChvcHRpb25zLCAnaW5jbHVkZScsICdhdHRyaWJ1dGVzJywgJ29yZGVyJywgJ3doZXJlJywgJ2xpbWl0JywgJ29mZnNldCcsICdwbGFpbicsICdzY29wZScpLFxuICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZS5pbmNsdWRlIHx8IFtdXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXAgPSBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLmdldChyZXN1bHRzLCB7XG5cbiAgICAgICAgLi4uXy5vbWl0KG9wdGlvbnMsIG5vbkNhc2NhZGluZ09wdGlvbnMpLFxuICAgICAgICAuLi5fLm9taXQoaW5jbHVkZSwgWydwYXJlbnQnLCAnYXNzb2NpYXRpb24nLCAnYXMnLCAnb3JpZ2luYWxBdHRyaWJ1dGVzJ10pXG4gICAgICB9KTtcblxuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgIGluY2x1ZGUuYXNzb2NpYXRpb24uYXMsXG4gICAgICAgICAgbWFwW3Jlc3VsdC5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkpXSxcbiAgICAgICAgICB7IHJhdzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgYSBzaW5nbGUgaW5zdGFuY2UgYnkgaXRzIHByaW1hcnkga2V5Ll9cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ3xCdWZmZXJ9ICAgICAgcGFyYW0gVGhlIHZhbHVlIG9mIHRoZSBkZXNpcmVkIGluc3RhbmNlJ3MgcHJpbWFyeSBrZXkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgIFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgICAgICAgICAgICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9ICAgICAgICAgICBmb3IgYSBmdWxsIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnMsIE5vdGUgdGhhdCBvcHRpb25zLndoZXJlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kQnlQayhwYXJhbSwgb3B0aW9ucykge1xuICAgIC8vIHJldHVybiBQcm9taXNlIHJlc29sdmVkIHdpdGggbnVsbCBpZiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgIGlmIChbbnVsbCwgdW5kZWZpbmVkXS5pbmNsdWRlcyhwYXJhbSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihwYXJhbSkpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICAgIFt0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBwYXJhbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCBwYXNzZWQgdG8gZmluZEJ5UGsgaXMgaW52YWxpZDogJHtwYXJhbX1gKTtcbiAgICB9XG5cbiAgICAvLyBCeXBhc3MgYSBwb3NzaWJsZSBvdmVybG9hZGVkIGZpbmRPbmVcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgYSBzaW5nbGUgaW5zdGFuY2UuIFJldHVybnMgdGhlIGZpcnN0IGluc3RhbmNlIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgY2FuIGJlIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIFtvcHRpb25zXSBBIGhhc2ggb2Ygb3B0aW9ucyB0byBkZXNjcmliZSB0aGUgc2NvcGUgb2YgdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9IGZvciBhbiBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsfG51bGw+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRPbmUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRPbmUgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWUnKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZVNpbmdsZUNvbHVtbnMgPSBfLmNoYWluKHRoaXMudW5pcXVlS2V5cykudmFsdWVzKCkuZmlsdGVyKGMgPT4gYy5maWVsZHMubGVuZ3RoID09PSAxKS5tYXAoJ2NvbHVtbicpLnZhbHVlKCk7XG5cbiAgICAgIC8vIERvbid0IGFkZCBsaW1pdCBpZiBxdWVyeWluZyBkaXJlY3RseSBvbiB0aGUgcGsgb3IgYSB1bmlxdWUgY29sdW1uXG4gICAgICBpZiAoIW9wdGlvbnMud2hlcmUgfHwgIV8uc29tZShvcHRpb25zLndoZXJlLCAodmFsdWUsIGtleSkgPT5cbiAgICAgICAgKGtleSA9PT0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlIHx8IHVuaXF1ZVNpbmdsZUNvbHVtbnMuaW5jbHVkZXMoa2V5KSkgJiZcbiAgICAgICAgICAoVXRpbHMuaXNQcmltaXRpdmUodmFsdWUpIHx8IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpXG4gICAgICApKSB7XG4gICAgICAgIG9wdGlvbnMubGltaXQgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ5cGFzcyBhIHBvc3NpYmxlIG92ZXJsb2FkZWQgZmluZEFsbC5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kQWxsKF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgcGxhaW46IHRydWVcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFuIGFnZ3JlZ2F0aW9uIG1ldGhvZCBvbiB0aGUgc3BlY2lmaWVkIGZpZWxkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBhdHRyaWJ1dGUgVGhlIGF0dHJpYnV0ZSB0byBhZ2dyZWdhdGUgb3Zlci4gQ2FuIGJlIGEgZmllbGQgbmFtZSBvciAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbiBUaGUgZnVuY3Rpb24gdG8gdXNlIGZvciBhZ2dyZWdhdGlvbiwgZS5nLiBzdW0sIG1heCBldGMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9uc10gUXVlcnkgb3B0aW9ucy4gU2VlIHNlcXVlbGl6ZS5xdWVyeSBmb3IgZnVsbCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9ucy53aGVyZV0gQSBoYXNoIG9mIHNlYXJjaCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0ge0RhdGFUeXBlc3xzdHJpbmd9IFtvcHRpb25zLmRhdGFUeXBlXSBUaGUgdHlwZSBvZiB0aGUgcmVzdWx0LiBJZiBgZmllbGRgIGlzIGEgZmllbGQgaW4gdGhpcyBNb2RlbCwgdGhlIGRlZmF1bHQgd2lsbCBiZSB0aGUgdHlwZSBvZiB0aGF0IGZpZWxkLCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gZmxvYXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5kaXN0aW5jdF0gQXBwbGllcyBESVNUSU5DVCB0byB0aGUgZmllbGQgYmVpbmcgYWdncmVnYXRlZCBvdmVyXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259ICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5wbGFpbl0gV2hlbiBgdHJ1ZWAsIHRoZSBmaXJzdCByZXR1cm5lZCB2YWx1ZSBvZiBgYWdncmVnYXRlRnVuY3Rpb25gIGlzIGNhc3QgdG8gYGRhdGFUeXBlYCBhbmQgcmV0dXJuZWQuIElmIGFkZGl0aW9uYWwgYXR0cmlidXRlcyBhcmUgc3BlY2lmaWVkLCBhbG9uZyB3aXRoIGBncm91cGAgY2xhdXNlcywgc2V0IGBwbGFpbmAgdG8gYGZhbHNlYCB0byByZXR1cm4gYWxsIHZhbHVlcyBvZiBhbGwgcmV0dXJuZWQgcm93cy4gIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEYXRhVHlwZXN8b2JqZWN0Pn0gUmV0dXJucyB0aGUgYWdncmVnYXRlIHJlc3VsdCBjYXN0IHRvIGBvcHRpb25zLmRhdGFUeXBlYCwgdW5sZXNzIGBvcHRpb25zLnBsYWluYCBpcyBmYWxzZSwgaW4gd2hpY2ggY2FzZSB0aGUgY29tcGxldGUgZGF0YSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYWdncmVnYXRlKGF0dHJpYnV0ZSwgYWdncmVnYXRlRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBwcmVzZXJ2ZSBhdHRyaWJ1dGVzIGhlcmUgYXMgdGhlIGBpbmplY3RTY29wZWAgY2FsbCB3b3VsZCBpbmplY3Qgbm9uIGFnZ3JlZ2F0ZSBjb2x1bW5zLlxuICAgIGNvbnN0IHByZXZBdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHByZXZBdHRyaWJ1dGVzO1xuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0ck9wdGlvbnMgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICBjb25zdCBmaWVsZCA9IGF0dHJPcHRpb25zICYmIGF0dHJPcHRpb25zLmZpZWxkIHx8IGF0dHJpYnV0ZTtcbiAgICBsZXQgYWdncmVnYXRlQ29sdW1uID0gdGhpcy5zZXF1ZWxpemUuY29sKGZpZWxkKTtcblxuICAgIGlmIChvcHRpb25zLmRpc3RpbmN0KSB7XG4gICAgICBhZ2dyZWdhdGVDb2x1bW4gPSB0aGlzLnNlcXVlbGl6ZS5mbignRElTVElOQ1QnLCBhZ2dyZWdhdGVDb2x1bW4pO1xuICAgIH1cblxuICAgIGxldCB7IGdyb3VwIH0gPSBvcHRpb25zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwKSAmJiBBcnJheS5pc0FycmF5KGdyb3VwWzBdKSkge1xuICAgICAgbm9Eb3VibGVOZXN0ZWRHcm91cCgpO1xuICAgICAgZ3JvdXAgPSBfLmZsYXR0ZW4oZ3JvdXApO1xuICAgIH1cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBfLnVuaW9uQnkoXG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICBncm91cCxcbiAgICAgIFtbdGhpcy5zZXF1ZWxpemUuZm4oYWdncmVnYXRlRnVuY3Rpb24sIGFnZ3JlZ2F0ZUNvbHVtbiksIGFnZ3JlZ2F0ZUZ1bmN0aW9uXV0sXG4gICAgICBhID0+IEFycmF5LmlzQXJyYXkoYSkgPyBhWzFdIDogYVxuICAgICk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZGF0YVR5cGUpIHtcbiAgICAgIGlmIChhdHRyT3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gYXR0ck9wdGlvbnMudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSBGTE9BVCBhcyBmYWxsYmFja1xuICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gbmV3IERhdGFUeXBlcy5GTE9BVCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmRhdGFUeXBlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplRGF0YVR5cGUob3B0aW9ucy5kYXRhVHlwZSk7XG4gICAgfVxuXG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmF3U2VsZWN0KHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zLCBhZ2dyZWdhdGVGdW5jdGlvbiwgdGhpcyk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvdW50IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBtYXRjaGluZyB0aGUgcHJvdmlkZWQgd2hlcmUgY2xhdXNlLlxuICAgKlxuICAgKiBJZiB5b3UgcHJvdmlkZSBhbiBgaW5jbHVkZWAgb3B0aW9uLCB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIGFzc29jaWF0aW9ucyB3aWxsIGJlIGNvdW50ZWQgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICBbb3B0aW9uc10gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgIFtvcHRpb25zLndoZXJlXSBBIGhhc2ggb2Ygc2VhcmNoIGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgW29wdGlvbnMuaW5jbHVkZV0gSW5jbHVkZSBvcHRpb25zLiBTZWUgYGZpbmRgIGZvciBkZXRhaWxzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgW29wdGlvbnMucGFyYW5vaWQ9dHJ1ZV0gU2V0IGB0cnVlYCB0byBjb3VudCBvbmx5IG5vbi1kZWxldGVkIHJlY29yZHMuIENhbiBiZSB1c2VkIG9uIG1vZGVscyB3aXRoIGBwYXJhbm9pZGAgZW5hYmxlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmRpc3RpbmN0XSBBcHBseSBDT1VOVChESVNUSU5DVChjb2wpKSBvbiBwcmltYXJ5IGtleSBvciBvbiBvcHRpb25zLmNvbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBbb3B0aW9ucy5jb2xdIENvbHVtbiBvbiB3aGljaCBDT1VOVCgpIHNob3VsZCBiZSBhcHBsaWVkXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgW29wdGlvbnMuYXR0cmlidXRlc10gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBncm91cGBcbiAgICogQHBhcmFtIHtBcnJheX0gICAgICAgICBbb3B0aW9ucy5ncm91cF0gRm9yIGNyZWF0aW5nIGNvbXBsZXggY291bnRzLiBXaWxsIHJldHVybiBtdWx0aXBsZSByb3dzIGFzIG5lZWRlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY291bnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywgeyBob29rczogdHJ1ZSB9KTtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUNvdW50Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBjb2wgPSBvcHRpb25zLmNvbCB8fCAnKic7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgY29sID0gYCR7dGhpcy5uYW1lfS4ke29wdGlvbnMuY29sIHx8IHRoaXMucHJpbWFyeUtleUZpZWxkfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRpc3RpbmN0ICYmIGNvbCA9PT0gJyonKSB7XG4gICAgICBjb2wgPSB0aGlzLnByaW1hcnlLZXlGaWVsZDtcbiAgICB9XG4gICAgb3B0aW9ucy5wbGFpbiA9ICFvcHRpb25zLmdyb3VwO1xuICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGVzLklOVEVHRVIoKTtcbiAgICBvcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzID0gZmFsc2U7XG5cbiAgICAvLyBObyBsaW1pdCwgb2Zmc2V0IG9yIG9yZGVyIGZvciB0aGUgb3B0aW9ucyBtYXggYmUgZ2l2ZW4gdG8gY291bnQoKVxuICAgIC8vIFNldCB0aGVtIHRvIG51bGwgdG8gcHJldmVudCBzY29wZXMgc2V0dGluZyB0aG9zZSB2YWx1ZXNcbiAgICBvcHRpb25zLmxpbWl0ID0gbnVsbDtcbiAgICBvcHRpb25zLm9mZnNldCA9IG51bGw7XG4gICAgb3B0aW9ucy5vcmRlciA9IG51bGw7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoY29sLCAnY291bnQnLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCB0aGUgcm93cyBtYXRjaGluZyB5b3VyIHF1ZXJ5LCB3aXRoaW4gYSBzcGVjaWZpZWQgb2Zmc2V0IC8gbGltaXQsIGFuZCBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIG1hdGNoaW5nIHlvdXIgcXVlcnkuIFRoaXMgaXMgdmVyeSB1c2VmdWwgZm9yIHBhZ2luZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBNb2RlbC5maW5kQW5kQ291bnRBbGwoe1xuICAgKiAgIHdoZXJlOiAuLi4sXG4gICAqICAgbGltaXQ6IDEyLFxuICAgKiAgIG9mZnNldDogMTJcbiAgICogfSk7XG4gICAqXG4gICAqICMgSW4gdGhlIGFib3ZlIGV4YW1wbGUsIGByZXN1bHQucm93c2Agd2lsbCBjb250YWluIHJvd3MgMTMgdGhyb3VnaCAyNCwgd2hpbGUgYHJlc3VsdC5jb3VudGAgd2lsbCByZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIHRoYXQgbWF0Y2hlZCB5b3VyIHF1ZXJ5LlxuICAgKlxuICAgKiAjIFdoZW4geW91IGFkZCBpbmNsdWRlcywgb25seSB0aG9zZSB3aGljaCBhcmUgcmVxdWlyZWQgKGVpdGhlciBiZWNhdXNlIHRoZXkgaGF2ZSBhIHdoZXJlIGNsYXVzZSwgb3IgYmVjYXVzZSBgcmVxdWlyZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUgb24gdGhlIGluY2x1ZGUpIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvdW50IHBhcnQuXG4gICAqXG4gICAqICMgU3VwcG9zZSB5b3Ugd2FudCB0byBmaW5kIGFsbCB1c2VycyB3aG8gaGF2ZSBhIHByb2ZpbGUgYXR0YWNoZWQ6XG4gICAqXG4gICAqIFVzZXIuZmluZEFuZENvdW50QWxsKHtcbiAgICogICBpbmNsdWRlOiBbXG4gICAqICAgICAgeyBtb2RlbDogUHJvZmlsZSwgcmVxdWlyZWQ6IHRydWV9XG4gICAqICAgXSxcbiAgICogICBsaW1pdDogM1xuICAgKiB9KTtcbiAgICpcbiAgICogIyBCZWNhdXNlIHRoZSBpbmNsdWRlIGZvciBgUHJvZmlsZWAgaGFzIGByZXF1aXJlZGAgc2V0IGl0IHdpbGwgcmVzdWx0IGluIGFuIGlubmVyIGpvaW4sIGFuZCBvbmx5IHRoZSB1c2VycyB3aG8gaGF2ZSBhIHByb2ZpbGUgd2lsbCBiZSBjb3VudGVkLiBJZiB3ZSByZW1vdmUgYHJlcXVpcmVkYCBmcm9tIHRoZSBpbmNsdWRlLCBib3RoIHVzZXJzIHdpdGggYW5kIHdpdGhvdXQgcHJvZmlsZXMgd2lsbCBiZSBjb3VudGVkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIGZpbmRBbGwgb3B0aW9uc1xuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSBmb3IgYSBzcGVjaWZpY2F0aW9uIG9mIGZpbmQgYW5kIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuY291bnR9IGZvciBhIHNwZWNpZmljYXRpb24gb2YgY291bnQgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7Y291bnQ6IG51bWJlciwgcm93czogTW9kZWxbXX0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRBbmRDb3VudEFsbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZEFuZENvdW50QWxsIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY291bnRPcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgaWYgKGNvdW50T3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb3VudE9wdGlvbnMuYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBbY291bnQsIHJvd3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5jb3VudChjb3VudE9wdGlvbnMpLFxuICAgICAgdGhpcy5maW5kQWxsKG9wdGlvbnMpXG4gICAgXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY291bnQsXG4gICAgICByb3dzOiBjb3VudCA9PT0gMCA/IFtdIDogcm93c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgbWF4aW11bSB2YWx1ZSBvZiBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgYXR0cmlidXRlIC8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSBhZ2dyZWdhdGVcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuYWdncmVnYXRlfSBmb3Igb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBtYXgoZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsICdtYXgnLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGZpZWxkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBhdHRyaWJ1dGUgLyBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIGFnZ3JlZ2F0ZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5hZ2dyZWdhdGV9IGZvciBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIG1pbihmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgJ21pbicsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHN1bSBvZiBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgYXR0cmlidXRlIC8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSBhZ2dyZWdhdGVcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuYWdncmVnYXRlfSBmb3Igb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN1bShmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgJ3N1bScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG5ldyBtb2RlbCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IHZhbHVlcyBBbiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzIG9yIGFuIGFycmF5IG9mIHN1Y2guIElmIGFuIGFycmF5LCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgaW5zdGFuY2VzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXSBJbnN0YW5jZSBidWlsZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmF3PWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgdmFsdWVzIHdpbGwgaWdub3JlIGZpZWxkIGFuZCB2aXJ0dWFsIHNldHRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNOZXdSZWNvcmQ9dHJ1ZV0gSXMgdGhpcyBuZXcgcmVjb3JkXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMuaW5jbHVkZV0gYW4gYXJyYXkgb2YgaW5jbHVkZSBvcHRpb25zIC0gVXNlZCB0byBidWlsZCBwcmVmZXRjaGVkL2luY2x1ZGVkIG1vZGVsIGluc3RhbmNlcy4gU2VlIGBzZXRgXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbHxBcnJheTxNb2RlbD59XG4gICAqL1xuICBzdGF0aWMgYnVpbGQodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVsa0J1aWxkKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgYnVsa0J1aWxkKHZhbHVlU2V0cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IGlzTmV3UmVjb3JkOiB0cnVlLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcChhdHRyaWJ1dGUgPT4gQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpID8gYXR0cmlidXRlWzFdIDogYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVTZXRzLm1hcCh2YWx1ZXMgPT4gdGhpcy5idWlsZCh2YWx1ZXMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBuZXcgbW9kZWwgaW5zdGFuY2UgYW5kIGNhbGxzIHNhdmUgb24gaXQuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmJ1aWxkfVxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5zYXZlfVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgdmFsdWVzICAgICAgICAgICAgICAgICAgICAgICBIYXNoIG9mIGRhdGEgdmFsdWVzIHRvIGNyZWF0ZSBuZXcgcmVjb3JkIHdpdGhcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgQnVpbGQgYW5kIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnJhdz1mYWxzZV0gICAgICAgICAgSWYgc2V0IHRvIHRydWUsIHZhbHVlcyB3aWxsIGlnbm9yZSBmaWVsZCBhbmQgdmlydHVhbCBzZXR0ZXJzLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaXNOZXdSZWNvcmQ9dHJ1ZV0gICBJcyB0aGlzIG5ldyByZWNvcmRcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVdICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5jbHVkZSBvcHRpb25zIC0gVXNlZCB0byBidWlsZCBwcmVmZXRjaGVkL2luY2x1ZGVkIG1vZGVsIGluc3RhbmNlcy4gU2VlIGBzZXRgXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSAgICAgICBbb3B0aW9ucy5maWVsZHNdICAgICAgICAgICAgIEFuIG9wdGlvbmFsIGFycmF5IG9mIHN0cmluZ3MsIHJlcHJlc2VudGluZyBkYXRhYmFzZSBjb2x1bW5zLiBJZiBmaWVsZHMgaXMgcHJvdmlkZWQsIG9ubHkgdGhvc2UgY29sdW1ucyB3aWxsIGJlIHZhbGlkYXRlZCBhbmQgc2F2ZWQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdICAgICAgIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy52YWxpZGF0ZT10cnVlXSAgICAgIElmIGZhbHNlLCB2YWxpZGF0aW9ucyB3b24ndCBiZSBydW4uXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgIFJ1biBiZWZvcmUgYW5kIGFmdGVyIGNyZWF0ZSAvIHVwZGF0ZSArIHZhbGlkYXRlIGhvb2tzXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58QXJyYXl9ICBbb3B0aW9ucy5yZXR1cm5pbmc9dHJ1ZV0gICAgIEFwcGVuZHMgUkVUVVJOSU5HIDxtb2RlbCBjb2x1bW5zPiB0byBnZXQgYmFjayBhbGwgZGVmaW5lZCB2YWx1ZXM7IGlmIGFuIGFycmF5IG9mIGNvbHVtbiBuYW1lcywgYXBwZW5kIFJFVFVSTklORyA8Y29sdW1ucz4gdG8gZ2V0IGJhY2sgc3BlY2lmaWMgY29sdW1ucyAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMgfHwge30pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYnVpbGQodmFsdWVzLCB7XG4gICAgICBpc05ld1JlY29yZDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuZmllbGRzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgcmF3OiBvcHRpb25zLnJhdyxcbiAgICAgIHNpbGVudDogb3B0aW9ucy5zaWxlbnRcbiAgICB9KS5zYXZlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSByb3cgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSwgb3IgYnVpbGQgKGJ1dCBkb24ndCBzYXZlKSB0aGUgcm93IGlmIG5vbmUgaXMgZm91bmQuXG4gICAqIFRoZSBzdWNjZXNzZnVsIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSB3aWxsIGJlIChpbnN0YW5jZSwgYnVpbHQpXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9wdGlvbnMgZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9wdGlvbnMud2hlcmUgQSBoYXNoIG9mIHNlYXJjaCBhdHRyaWJ1dGVzLiBJZiBgd2hlcmVgIGlzIGEgcGxhaW4gb2JqZWN0IGl0IHdpbGwgYmUgYXBwZW5kZWQgd2l0aCBkZWZhdWx0cyB0byBidWlsZCBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuZGVmYXVsdHNdIERlZmF1bHQgdmFsdWVzIHRvIHVzZSBpZiBidWlsZGluZyBhIG5ldyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsLGJvb2xlYW4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRPckJ1aWxkKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ01pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZE9yQnVpbGQuICcgK1xuICAgICAgICAnUGxlYXNlIG5vdGUgdGhhdCB0aGUgQVBJIGhhcyBjaGFuZ2VkLCBhbmQgaXMgbm93IG9wdGlvbnMgb25seSAoYW4gb2JqZWN0IHdpdGggd2hlcmUsIGRlZmF1bHRzIGtleXMsIHRyYW5zYWN0aW9uIGV0Yy4pJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVzO1xuXG4gICAgbGV0IGluc3RhbmNlID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0geyAuLi5vcHRpb25zLmRlZmF1bHRzIH07XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlID0gdGhpcy5idWlsZCh2YWx1ZXMsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gW2luc3RhbmNlLCB0cnVlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2luc3RhbmNlLCBmYWxzZV07XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHJvdyB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LCBvciBidWlsZCBhbmQgc2F2ZSB0aGUgcm93IGlmIG5vbmUgaXMgZm91bmRcbiAgICogVGhlIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIHRoZSBwcm9taXNlIHdpbGwgYmUgKGluc3RhbmNlLCBjcmVhdGVkKVxuICAgKlxuICAgKiBJZiBubyB0cmFuc2FjdGlvbiBpcyBwYXNzZWQgaW4gdGhlIGBvcHRpb25zYCBvYmplY3QsIGEgbmV3IHRyYW5zYWN0aW9uIHdpbGwgYmUgY3JlYXRlZCBpbnRlcm5hbGx5LCB0byBwcmV2ZW50IHRoZSByYWNlIGNvbmRpdGlvbiB3aGVyZSBhIG1hdGNoaW5nIHJvdyBpcyBjcmVhdGVkIGJ5IGFub3RoZXIgY29ubmVjdGlvbiBhZnRlciB0aGUgZmluZCBidXQgYmVmb3JlIHRoZSBpbnNlcnQgY2FsbC5cbiAgICogSG93ZXZlciwgaXQgaXMgbm90IGFsd2F5cyBwb3NzaWJsZSB0byBoYW5kbGUgdGhpcyBjYXNlIGluIFNRTGl0ZSwgc3BlY2lmaWNhbGx5IGlmIG9uZSB0cmFuc2FjdGlvbiBpbnNlcnRzIGFuZCBhbm90aGVyIHRyaWVzIHRvIHNlbGVjdCBiZWZvcmUgdGhlIGZpcnN0IG9uZSBoYXMgY29tbWl0dGVkLiBJbiB0aGlzIGNhc2UsIGFuIGluc3RhbmNlIG9mIHNlcXVlbGl6ZS4gVGltZW91dEVycm9yIHdpbGwgYmUgdGhyb3duIGluc3RlYWQuXG4gICAqIElmIGEgdHJhbnNhY3Rpb24gaXMgY3JlYXRlZCwgYSBzYXZlcG9pbnQgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQsIGFuZCBhbnkgdW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIHdpbGwgYmUgaGFuZGxlZCBpbnRlcm5hbGx5LlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSBmb3IgYSBmdWxsIHNwZWNpZmljYXRpb24gb2YgZmluZCBhbmQgb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBvcHRpb25zIGZpbmQgYW5kIGNyZWF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIG9wdGlvbnMud2hlcmUgd2hlcmUgQSBoYXNoIG9mIHNlYXJjaCBhdHRyaWJ1dGVzLiBJZiBgd2hlcmVgIGlzIGEgcGxhaW4gb2JqZWN0IGl0IHdpbGwgYmUgYXBwZW5kZWQgd2l0aCBkZWZhdWx0cyB0byBidWlsZCBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW29wdGlvbnMuZGVmYXVsdHNdIERlZmF1bHQgdmFsdWVzIHRvIHVzZSBpZiBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsLGJvb2xlYW4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRPckNyZWF0ZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRPckNyZWF0ZS4gJyArXG4gICAgICAgICdQbGVhc2Ugbm90ZSB0aGF0IHRoZSBBUEkgaGFzIGNoYW5nZWQsIGFuZCBpcyBub3cgb3B0aW9ucyBvbmx5IChhbiBvYmplY3Qgd2l0aCB3aGVyZSwgZGVmYXVsdHMga2V5cywgdHJhbnNhY3Rpb24gZXRjLiknXG4gICAgICApO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZGVmYXVsdHMpO1xuICAgICAgY29uc3QgdW5rbm93bkRlZmF1bHRzID0gZGVmYXVsdHMuZmlsdGVyKG5hbWUgPT4gIXRoaXMucmF3QXR0cmlidXRlc1tuYW1lXSk7XG5cbiAgICAgIGlmICh1bmtub3duRGVmYXVsdHMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBVbmtub3duIGF0dHJpYnV0ZXMgKCR7dW5rbm93bkRlZmF1bHRzfSkgcGFzc2VkIHRvIGRlZmF1bHRzIG9wdGlvbiBvZiBmaW5kT3JDcmVhdGVgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldCgndHJhbnNhY3Rpb24nKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludGVybmFsVHJhbnNhY3Rpb24gPSAhb3B0aW9ucy50cmFuc2FjdGlvbjtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCB0cmFuc2FjdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUudHJhbnNhY3Rpb24ob3B0aW9ucyk7XG4gICAgICB0cmFuc2FjdGlvbiA9IHQ7XG4gICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcblxuICAgICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRPbmUoVXRpbHMuZGVmYXVsdHMoeyB0cmFuc2FjdGlvbiB9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoZm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtmb3VuZCwgZmFsc2VdO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSB7IC4uLm9wdGlvbnMuZGVmYXVsdHMgfTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5leGNlcHRpb24gPSB0cnVlO1xuICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVhdGVkID0gYXdhaXQgdGhpcy5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGNyZWF0ZWQuZ2V0KHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcXVlcnkgcmV0dXJuZWQgYW4gZW1wdHkgcmVzdWx0IGZvciB0aGUgcHJpbWFyeSBrZXksIHdlIGtub3cgdGhhdCB0aGlzIHdhcyBhY3R1YWxseSBhIHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2NyZWF0ZWQsIHRydWVdO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IpKSB0aHJvdyBlcnI7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZFdoZXJlID0gVXRpbHMuZmxhdHRlbk9iamVjdERlZXAob3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZFdoZXJlS2V5cyA9IE9iamVjdC5rZXlzKGZsYXR0ZW5lZFdoZXJlKS5tYXAobmFtZSA9PiBfLmxhc3QobmFtZS5zcGxpdCgnLicpKSk7XG4gICAgICAgIGNvbnN0IHdoZXJlRmllbGRzID0gZmxhdHRlbmVkV2hlcmVLZXlzLm1hcChuYW1lID0+IF8uZ2V0KHRoaXMucmF3QXR0cmlidXRlcywgYCR7bmFtZX0uZmllbGRgLCBuYW1lKSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmRlZmF1bHRzICYmIE9iamVjdC5rZXlzKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgLmZpbHRlcihuYW1lID0+IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXSlcbiAgICAgICAgICAubWFwKG5hbWUgPT4gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdLmZpZWxkIHx8IG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGVyckZpZWxkS2V5cyA9IE9iamVjdC5rZXlzKGVyci5maWVsZHMpO1xuICAgICAgICBjb25zdCBlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMgPSBVdGlscy5pbnRlcnNlY3RzKGVyckZpZWxkS2V5cywgd2hlcmVGaWVsZHMpO1xuICAgICAgICBpZiAoZGVmYXVsdEZpZWxkcyAmJiAhZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzICYmIFV0aWxzLmludGVyc2VjdHMoZXJyRmllbGRLZXlzLCBkZWZhdWx0RmllbGRzKSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMpIHtcbiAgICAgICAgICBfLmVhY2goZXJyLmZpZWxkcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldLmZpZWxkTmFtZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpICE9PSBvcHRpb25zLndoZXJlW25hbWVdLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0jZmluZE9yQ3JlYXRlOiB2YWx1ZSB1c2VkIGZvciAke25hbWV9IHdhcyBub3QgZXF1YWwgZm9yIGJvdGggdGhlIGZpbmQgYW5kIHRoZSBjcmVhdGUgY2FsbHMsICcke29wdGlvbnMud2hlcmVbbmFtZV19JyB2cyAnJHt2YWx1ZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21lb25lIG11c3QgaGF2ZSBjcmVhdGVkIGEgbWF0Y2hpbmcgaW5zdGFuY2UgaW5zaWRlIHRoZSBzYW1lIHRyYW5zYWN0aW9uIHNpbmNlIHdlIGxhc3QgZGlkIGEgZmluZC4gTGV0J3MgZmluZCBpdCFcbiAgICAgICAgY29uc3Qgb3RoZXJDcmVhdGVkID0gYXdhaXQgdGhpcy5maW5kT25lKFV0aWxzLmRlZmF1bHRzKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbjogaW50ZXJuYWxUcmFuc2FjdGlvbiA/IG51bGwgOiB0cmFuc2FjdGlvblxuICAgICAgICB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrLCBpZGVhbGx5IHdlIGNhdWdodCB0aGlzIGF0IHRoZSBkZWZhdWx0RmVpbGRzL2Vyci5maWVsZHMgY2hlY2tcbiAgICAgICAgLy8gQnV0IGlmIHdlIGRpZG4ndCBhbmQgaW5zdGFuY2UgaXMgbnVsbCwgd2Ugd2lsbCB0aHJvd1xuICAgICAgICBpZiAob3RoZXJDcmVhdGVkID09PSBudWxsKSB0aHJvdyBlcnI7XG5cbiAgICAgICAgcmV0dXJuIFtvdGhlckNyZWF0ZWQsIGZhbHNlXTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGludGVybmFsVHJhbnNhY3Rpb24gJiYgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgbW9yZSBwZXJmb3JtYW50IGZpbmRPckNyZWF0ZSB0aGF0IHdpbGwgbm90IHdvcmsgdW5kZXIgYSB0cmFuc2FjdGlvbiAoYXQgbGVhc3Qgbm90IGluIHBvc3RncmVzKVxuICAgKiBXaWxsIGV4ZWN1dGUgYSBmaW5kIGNhbGwsIGlmIGVtcHR5IHRoZW4gYXR0ZW1wdCB0byBjcmVhdGUsIGlmIHVuaXF1ZSBjb25zdHJhaW50IHRoZW4gYXR0ZW1wdCB0byBmaW5kIGFnYWluXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9IGZvciBhIGZ1bGwgc3BlY2lmaWNhdGlvbiBvZiBmaW5kIGFuZCBvcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy53aGVyZSBBIGhhc2ggb2Ygc2VhcmNoIGF0dHJpYnV0ZXMuIElmIGB3aGVyZWAgaXMgYSBwbGFpbiBvYmplY3QgaXQgd2lsbCBiZSBhcHBlbmRlZCB3aXRoIGRlZmF1bHRzIHRvIGJ1aWxkIGEgbmV3IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZGVmYXVsdHNdIERlZmF1bHQgdmFsdWVzIHRvIHVzZSBpZiBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbCxib29sZWFuPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kQ3JlYXRlRmluZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRDcmVhdGVGaW5kLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcyA9IHsgLi4ub3B0aW9ucy5kZWZhdWx0cyB9O1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgfVxuXG5cbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoZm91bmQpIHJldHVybiBbZm91bmQsIGZhbHNlXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjcmVhdGVkID0gYXdhaXQgdGhpcy5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBbY3JlYXRlZCwgdHJ1ZV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKSkgdGhyb3cgZXJyO1xuICAgICAgY29uc3QgZm91bmRBZ2FpbiA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBbZm91bmRBZ2FpbiwgZmFsc2VdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgb3IgdXBkYXRlIGEgc2luZ2xlIHJvdy4gQW4gdXBkYXRlIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYSByb3cgd2hpY2ggbWF0Y2hlcyB0aGUgc3VwcGxpZWQgdmFsdWVzIG9uIGVpdGhlciB0aGUgcHJpbWFyeSBrZXkgb3IgYSB1bmlxdWUga2V5IGlzIGZvdW5kLiBOb3RlIHRoYXQgdGhlIHVuaXF1ZSBpbmRleCBtdXN0IGJlIGRlZmluZWQgaW4geW91ciBzZXF1ZWxpemUgbW9kZWwgYW5kIG5vdCBqdXN0IGluIHRoZSB0YWJsZS4gT3RoZXJ3aXNlIHlvdSBtYXkgZXhwZXJpZW5jZSBhIHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbiwgYmVjYXVzZSBzZXF1ZWxpemUgZmFpbHMgdG8gaWRlbnRpZnkgdGhlIHJvdyB0aGF0IHNob3VsZCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiAqKkltcGxlbWVudGF0aW9uIGRldGFpbHM6KipcbiAgICpcbiAgICogKiBNeVNRTCAtIEltcGxlbWVudGVkIHdpdGggT04gRFVQTElDQVRFIEtFWSBVUERBVEVgXG4gICAqICogUG9zdGdyZVNRTCAtIEltcGxlbWVudGVkIHdpdGggT04gQ09ORkxJQ1QgRE8gVVBEQVRFLiBJZiB1cGRhdGUgZGF0YSBjb250YWlucyBQSyBmaWVsZCwgdGhlbiBQSyBpcyBzZWxlY3RlZCBhcyB0aGUgZGVmYXVsdCBjb25mbGljdCBrZXkuIE90aGVyd2lzZSBmaXJzdCB1bmlxdWUgY29uc3RyYWludC9pbmRleCB3aWxsIGJlIHNlbGVjdGVkLCB3aGljaCBjYW4gc2F0aXNmeSBjb25mbGljdCBrZXkgcmVxdWlyZW1lbnRzLlxuICAgKiAqIFNRTGl0ZSAtIEltcGxlbWVudGVkIHdpdGggT04gQ09ORkxJQ1QgRE8gVVBEQVRFXG4gICAqICogTVNTUUwgLSBJbXBsZW1lbnRlZCBhcyBhIHNpbmdsZSBxdWVyeSB1c2luZyBgTUVSR0VgIGFuZCBgV0hFTiAoTk9UKSBNQVRDSEVEIFRIRU5gXG4gICAqXG4gICAqICoqTm90ZSoqIHRoYXQgUG9zdGdyZXMvU1FMaXRlIHJldHVybnMgbnVsbCBmb3IgY3JlYXRlZCwgbm8gbWF0dGVyIGlmIHRoZSByb3cgd2FzIGNyZWF0ZWQgb3IgdXBkYXRlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHZhbHVlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoIG9mIHZhbHVlcyB0byB1cHNlcnRcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0IG9wdGlvbnNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy52YWxpZGF0ZT10cnVlXSAgICAgICAgICAgICAgICAgICAgICAgUnVuIHZhbGlkYXRpb25zIGJlZm9yZSB0aGUgcm93IGlzIGluc2VydGVkXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgW29wdGlvbnMuZmllbGRzPU9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcyldIFRoZSBmaWVsZHMgdG8gaW5zZXJ0IC8gdXBkYXRlLiBEZWZhdWx0cyB0byBhbGwgY2hhbmdlZCBmaWVsZHNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgICAgICAgICAgICAgICAgICAgUnVuIGJlZm9yZSAvIGFmdGVyIHVwc2VydCBob29rcz9cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5yZXR1cm5pbmc9dHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSwgZmV0Y2hlcyBiYWNrIGF1dG8gZ2VuZXJhdGVkIHZhbHVlc1xuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICAgICAgICAgICAgICAgICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gICAgICAgICAgICAgICAgICBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxbTW9kZWwsIGJvb2xlYW4gfCBudWxsXT59IHJldHVybnMgYW4gYXJyYXkgd2l0aCB0d28gZWxlbWVudHMsIHRoZSBmaXJzdCBiZWluZyB0aGUgbmV3IHJlY29yZCBhbmQgdGhlIHNlY29uZCBiZWluZyBgdHJ1ZWAgaWYgaXQgd2FzIGp1c3QgY3JlYXRlZCBvciBgZmFsc2VgIGlmIGl0IGFscmVhZHkgZXhpc3RlZCAoZXhjZXB0IG9uIFBvc3RncmVzIGFuZCBTUUxpdGUsIHdoaWNoIGNhbid0IGRldGVjdCB0aGlzIGFuZCB3aWxsIGFsd2F5cyByZXR1cm4gYG51bGxgIGluc3RlYWQgb2YgYSBib29sZWFuKS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyB1cHNlcnQodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgcmV0dXJuaW5nOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHRydWUsXG4gICAgICAuLi5VdGlscy5jbG9uZURlZXAob3B0aW9ucylcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICBjb25zdCBoYXNQcmltYXJ5ID0gdGhpcy5wcmltYXJ5S2V5RmllbGQgaW4gdmFsdWVzIHx8IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSBpbiB2YWx1ZXM7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkKHZhbHVlcyk7XG5cbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gQXJyYXkuZnJvbShpbnN0YW5jZS5fY2hhbmdlZCk7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBjaGFuZ2VkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBhd2FpdCBpbnN0YW5jZS52YWxpZGF0ZShvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gTWFwIGZpZWxkIG5hbWVzXG4gICAgY29uc3QgdXBkYXRlZERhdGFWYWx1ZXMgPSBfLnBpY2soaW5zdGFuY2UuZGF0YVZhbHVlcywgY2hhbmdlZCk7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKGluc3RhbmNlLmRhdGFWYWx1ZXMsIE9iamVjdC5rZXlzKGluc3RhbmNlLnJhd0F0dHJpYnV0ZXMpLCB0aGlzKTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModXBkYXRlZERhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzLCB0aGlzKTtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcblxuICAgIC8vIEF0dGFjaCBjcmVhdGVkQXRcbiAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhdXBkYXRlVmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1tjcmVhdGVkQXRBdHRyXS5maWVsZCB8fCBjcmVhdGVkQXRBdHRyO1xuICAgICAgaW5zZXJ0VmFsdWVzW2ZpZWxkXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAoY3JlYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhaW5zZXJ0VmFsdWVzW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t1cGRhdGVkQXRBdHRyXS5maWVsZCB8fCB1cGRhdGVkQXRBdHRyO1xuICAgICAgaW5zZXJ0VmFsdWVzW2ZpZWxkXSA9IHVwZGF0ZVZhbHVlc1tmaWVsZF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhZGRzIGEgbnVsbCB2YWx1ZSBmb3IgdGhlIHByaW1hcnkga2V5LCBpZiBub25lIHdhcyBnaXZlbiBieSB0aGUgdXNlci5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGF0IGJlY2F1c2Ugb2Ygc29tZSBQb3N0Z3JlcyB0ZWNobmljYWxpdGllcy5cbiAgICBpZiAoIWhhc1ByaW1hcnkgJiYgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlICYmICF0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIGRlbGV0ZSBpbnNlcnRWYWx1ZXNbdGhpcy5wcmltYXJ5S2V5RmllbGRdO1xuICAgICAgZGVsZXRlIHVwZGF0ZVZhbHVlc1t0aGlzLnByaW1hcnlLZXlGaWVsZF07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZVVwc2VydCcsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UudXBzZXJ0KHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgaW5zdGFuY2Uud2hlcmUoKSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBbcmVjb3JkXSA9IHJlc3VsdDtcbiAgICByZWNvcmQuaXNOZXdSZWNvcmQgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlclVwc2VydCcsIHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgaW5zZXJ0IG11bHRpcGxlIGluc3RhbmNlcyBpbiBidWxrLlxuICAgKlxuICAgKiBUaGUgc3VjY2VzcyBoYW5kbGVyIGlzIHBhc3NlZCBhbiBhcnJheSBvZiBpbnN0YW5jZXMsIGJ1dCBwbGVhc2Ugbm90aWNlIHRoYXQgdGhlc2UgbWF5IG5vdCBjb21wbGV0ZWx5IHJlcHJlc2VudCB0aGUgc3RhdGUgb2YgdGhlIHJvd3MgaW4gdGhlIERCLiBUaGlzIGlzIGJlY2F1c2UgTXlTUUxcbiAgICogYW5kIFNRTGl0ZSBkbyBub3QgbWFrZSBpdCBlYXN5IHRvIG9idGFpbiBiYWNrIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIElEcyBhbmQgb3RoZXIgZGVmYXVsdCB2YWx1ZXMgaW4gYSB3YXkgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIG11bHRpcGxlIHJlY29yZHMuXG4gICAqIFRvIG9idGFpbiBJbnN0YW5jZXMgZm9yIHRoZSBuZXdseSBjcmVhdGVkIHZhbHVlcywgeW91IHdpbGwgbmVlZCB0byBxdWVyeSBmb3IgdGhlbSBhZ2Fpbi5cbiAgICpcbiAgICogSWYgdmFsaWRhdGlvbiBmYWlscywgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBhcnJheS1saWtlIEFnZ3JlZ2F0ZUVycm9yXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICByZWNvcmRzICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0IG9mIG9iamVjdHMgKGtleS92YWx1ZSBwYWlycykgdG8gY3JlYXRlIGluc3RhbmNlcyBmcm9tXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICAgICBCdWxrIGNyZWF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICBbb3B0aW9ucy5maWVsZHNdICAgICAgICAgICAgICAgICBGaWVsZHMgdG8gaW5zZXJ0IChkZWZhdWx0cyB0byBhbGwgZmllbGRzKVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMudmFsaWRhdGU9ZmFsc2VdICAgICAgICAgU2hvdWxkIGVhY2ggcm93IGJlIHN1YmplY3QgdG8gdmFsaWRhdGlvbiBiZWZvcmUgaXQgaXMgaW5zZXJ0ZWQuIFRoZSB3aG9sZSBpbnNlcnQgd2lsbCBmYWlsIGlmIG9uZSByb3cgZmFpbHMgdmFsaWRhdGlvblxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICAgICAgUnVuIGJlZm9yZSAvIGFmdGVyIGJ1bGsgY3JlYXRlIGhvb2tzP1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaW5kaXZpZHVhbEhvb2tzPWZhbHNlXSAgUnVuIGJlZm9yZSAvIGFmdGVyIGNyZWF0ZSBob29rcyBmb3IgZWFjaCBpbmRpdmlkdWFsIEluc3RhbmNlPyBCdWxrQ3JlYXRlIGhvb2tzIHdpbGwgc3RpbGwgYmUgcnVuIGlmIG9wdGlvbnMuaG9va3MgaXMgdHJ1ZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXM9ZmFsc2VdIElnbm9yZSBkdXBsaWNhdGUgdmFsdWVzIGZvciBwcmltYXJ5IGtleXM/IChub3Qgc3VwcG9ydGVkIGJ5IE1TU1FMIG9yIFBvc3RncmVzIDwgOS41KVxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgW29wdGlvbnMudXBkYXRlT25EdXBsaWNhdGVdICAgICAgRmllbGRzIHRvIHVwZGF0ZSBpZiByb3cga2V5IGFscmVhZHkgZXhpc3RzIChvbiBkdXBsaWNhdGUga2V5IHVwZGF0ZSk/IChvbmx5IHN1cHBvcnRlZCBieSBNeVNRTCwgTWFyaWFEQiwgU1FMaXRlID49IDMuMjQuMCAmIFBvc3RncmVzID49IDkuNSkuIEJ5IGRlZmF1bHQsIGFsbCBmaWVsZHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICAgICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58QXJyYXl9ICBbb3B0aW9ucy5yZXR1cm5pbmc9ZmFsc2VdICAgICAgICBJZiB0cnVlLCBhcHBlbmQgUkVUVVJOSU5HIDxtb2RlbCBjb2x1bW5zPiB0byBnZXQgYmFjayBhbGwgZGVmaW5lZCB2YWx1ZXM7IGlmIGFuIGFycmF5IG9mIGNvbHVtbiBuYW1lcywgYXBwZW5kIFJFVFVSTklORyA8Y29sdW1ucz4gdG8gZ2V0IGJhY2sgc3BlY2lmaWMgY29sdW1ucyAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gICAgIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1vZGVsPj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYnVsa0NyZWF0ZShyZWNvcmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZGlhbGVjdCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdDtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcblxuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlcyA9IHJlY29yZHMubWFwKHZhbHVlcyA9PiB0aGlzLmJ1aWxkKHZhbHVlcywgeyBpc05ld1JlY29yZDogdHJ1ZSwgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlIH0pKTtcblxuICAgIGNvbnN0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUgPSBhc3luYyAoaW5zdGFuY2VzLCBvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgICBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzICYmIFsnbXNzcWwnXS5pbmNsdWRlcyhkaWFsZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGlhbGVjdH0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgaWdub3JlRHVwbGljYXRlcyBvcHRpb24uYCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSAmJiAoZGlhbGVjdCAhPT0gJ215c3FsJyAmJiBkaWFsZWN0ICE9PSAnbWFyaWFkYicgJiYgZGlhbGVjdCAhPT0gJ3NxbGl0ZScgJiYgZGlhbGVjdCAhPT0gJ3Bvc3RncmVzJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RpYWxlY3R9IGRvZXMgbm90IHN1cHBvcnQgdGhlIHVwZGF0ZU9uRHVwbGljYXRlIG9wdGlvbi5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuXG4gICAgICBvcHRpb25zLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzIHx8IE9iamVjdC5rZXlzKG1vZGVsLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG5cbiAgICAgIGlmIChvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkgJiYgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gXy5pbnRlcnNlY3Rpb24oXG4gICAgICAgICAgICBfLndpdGhvdXQoT2JqZWN0LmtleXMobW9kZWwudGFibGVBdHRyaWJ1dGVzKSwgY3JlYXRlZEF0QXR0ciksXG4gICAgICAgICAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZU9uRHVwbGljYXRlIG9wdGlvbiBvbmx5IHN1cHBvcnRzIG5vbi1lbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLnJ1bkhvb2tzKCdiZWZvcmVCdWxrQ3JlYXRlJywgaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIFZhbGlkYXRlXG4gICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgaW5zdGFuY2UgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS52YWxpZGF0ZSh2YWxpZGF0ZU9wdGlvbnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5CdWxrUmVjb3JkRXJyb3IoZXJyLCBpbnN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnNraXA7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5BZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kaXZpZHVhbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgaG9va3M6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5maWVsZHM7XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmluZGl2aWR1YWxIb29rcztcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaWdub3JlRHVwbGljYXRlcztcblxuICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5kaXZpZHVhbE9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlICYmIG9wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLmluY2x1ZGUuZmlsdGVyKGluY2x1ZGUgPT4gaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbykubWFwKGFzeW5jIGluY2x1ZGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGluc3RhbmNlLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlcy5wdXNoKGFzc29jaWF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbkluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKVxuICAgICAgICAgICAgICAub21pdChbJ2Fzc29jaWF0aW9uJ10pXG4gICAgICAgICAgICAgIC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nXG4gICAgICAgICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcyA9IGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoYXNzb2NpYXRpb25JbnN0YW5jZXMsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzW2lkeF07XG4gICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcFtpZHhdO1xuXG4gICAgICAgICAgICAgIGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24uc2V0KGluc3RhbmNlLCBhc3NvY2lhdGlvbkluc3RhbmNlLCB7IHNhdmU6IGZhbHNlLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBpbiBvbmUgcXVlcnlcbiAgICAgICAgLy8gUmVjcmVhdGUgcmVjb3JkcyBmcm9tIGluc3RhbmNlcyB0byByZXByZXNlbnQgYW55IGNoYW5nZXMgbWFkZSBpbiBob29rcyBvciB2YWxpZGF0aW9uXG4gICAgICAgIHJlY29yZHMgPSBpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBpbnN0YW5jZS5kYXRhVmFsdWVzO1xuXG4gICAgICAgICAgLy8gc2V0IGNyZWF0ZWRBdC91cGRhdGVkQXQgYXR0cmlidXRlc1xuICAgICAgICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICF2YWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgICAgICAgIHZhbHVlc1tjcmVhdGVkQXRBdHRyXSA9IG5vdztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMoY3JlYXRlZEF0QXR0cikpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChjcmVhdGVkQXRBdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIXZhbHVlc1t1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgICAgICAgdmFsdWVzW3VwZGF0ZWRBdEF0dHJdID0gbm93O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG91dCA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh2YWx1ZXMsIG9wdGlvbnMuZmllbGRzLCBtb2RlbCk7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgbW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBkZWxldGUgb3V0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1hcCBhdHRyaWJ1dGVzIHRvIGZpZWxkcyBmb3Igc2VyaWFsIGlkZW50aWZpY2F0aW9uXG4gICAgICAgIGNvbnN0IGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gbW9kZWwudGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgfHwgYXR0cl0gPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwIHVwZGF0ZU9uRHVwbGljYXRlIGF0dHJpYnV0ZXMgdG8gZmllbGRzXG4gICAgICAgIGlmIChvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICAgICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKGF0dHIgPT4gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCB8fCBhdHRyKTtcbiAgICAgICAgICAvLyBHZXQgcHJpbWFyeSBrZXlzIGZvciBwb3N0Z3JlcyB0byBlbmFibGUgdXBkYXRlT25EdXBsaWNhdGVcbiAgICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBfLmNoYWluKG1vZGVsLnByaW1hcnlLZXlzKS52YWx1ZXMoKS5tYXAoJ2ZpZWxkJykudmFsdWUoKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobW9kZWwudW5pcXVlS2V5cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gXy5jaGFpbihtb2RlbC51bmlxdWVLZXlzKS52YWx1ZXMoKS5maWx0ZXIoYyA9PiBjLmZpZWxkcy5sZW5ndGggPj0gMSkubWFwKGMgPT4gYy5maWVsZHMpLnJlZHVjZShjID0+IGNbMF0pLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwIHJldHVybmluZyBhdHRyaWJ1dGVzIHRvIGZpZWxkc1xuICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLnJldHVybmluZykpIHtcbiAgICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IG9wdGlvbnMucmV0dXJuaW5nLm1hcChhdHRyID0+IF8uZ2V0KG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0sICdmaWVsZCcsIGF0dHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2RlbC5xdWVyeUludGVyZmFjZS5idWxrSW5zZXJ0KG1vZGVsLmdldFRhYmxlTmFtZShvcHRpb25zKSwgcmVjb3Jkcywgb3B0aW9ucywgZmllbGRNYXBwZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGtleSA9PT0gbW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldChtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlKSAmJlxuICAgICAgICAgICAgICAgIFsnbXlzcWwnLCAnbWFyaWFkYicsICdzcWxpdGUnXS5pbmNsdWRlcyhkaWFsZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBxdWVyeS5qcyBmb3IgdGhlc2UgREJzIGlzIGJsaW5kLCBpdCBhdXRvaW5jcmVtZW50cyB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcmltYXJ5a2V5IHZhbHVlLCBldmVuIGlmIGl0IHdhcyBzZXQgbWFudWFsbHkuIEFsc28sIGl0IGNhblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBtb3JlIHJlc3VsdHMgdGhhbiBpbnN0YW5jZXMsIGJ1Zz8uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSByZXN1bHRba2V5XTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQobW9kZWwucmF3QXR0cmlidXRlcywgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUgJiYgb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLmluY2x1ZGUuZmlsdGVyKGluY2x1ZGUgPT4gIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvIHx8XG4gICAgICAgICAgaW5jbHVkZS5wYXJlbnQgJiYgaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkubWFwKGFzeW5jIGluY2x1ZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcCA9IFtdO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBhc3NvY2lhdGVkID0gaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc29jaWF0ZWQpKSBhc3NvY2lhdGVkID0gW2Fzc29jaWF0ZWRdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2Ugb2YgYXNzb2NpYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkge1xuICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZS5zZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5LCBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkgfHwgaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhc3NvY2lhdGlvbkluc3RhbmNlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZXMucHVzaChhc3NvY2lhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbkluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKVxuICAgICAgICAgICAgLm9taXQoWydhc3NvY2lhdGlvbiddKVxuICAgICAgICAgICAgLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZ1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcblxuICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcyA9IGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoYXNzb2NpYXRpb25JbnN0YW5jZXMsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlU2V0cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlc1tpZHhdO1xuICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXBbaWR4XTtcblxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleV06IGluc3RhbmNlLmdldChpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleV06IGFzc29jaWF0aW9uSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uSW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgICAgICAgICAgICAuLi5pbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2guc2NvcGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLl9hdXRvR2VuZXJhdGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSB8fFxuICAgICAgICAgICAgICAgICAgICBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWVzW2F0dHJdID0gYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWVTZXRzLnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGhyb3VnaE9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSlcbiAgICAgICAgICAgICAgLm9taXQoWydhc3NvY2lhdGlvbicsICdhdHRyaWJ1dGVzJ10pXG4gICAgICAgICAgICAgIC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nXG4gICAgICAgICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgICAgICB0aHJvdWdoT3B0aW9ucy5tb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsO1xuICAgICAgICAgICAgY29uc3QgdGhyb3VnaEluc3RhbmNlcyA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsLmJ1bGtCdWlsZCh2YWx1ZVNldHMsIHRocm91Z2hPcHRpb25zKTtcblxuICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZSh0aHJvdWdoSW5zdGFuY2VzLCB0aHJvdWdoT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hcCBmaWVsZHMgYmFjayB0byBhdHRyaWJ1dGVzXG4gICAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiZcbiAgICAgICAgICAgICAgaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgIG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0cl0gPSBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICAgICAgZGVsZXRlIGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0gPSBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgICAgIGluc3RhbmNlLmNoYW5nZWQoYXR0ciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTmV3UmVjb3JkID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLnJ1bkhvb2tzKCdhZnRlckJ1bGtDcmVhdGUnLCBpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydW5jYXRlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIG1vZGVsLiBUaGlzIGlzIGEgY29udmVuaWVudCBtZXRob2QgZm9yIE1vZGVsLmRlc3Ryb3koeyB0cnVuY2F0ZTogdHJ1ZSB9KS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBbb3B0aW9uc10gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIE1vZGVsLmRlc3Ryb3kgaW4gYWRkaXRpb24gdG8gdHJ1bmNhdGVcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5jYXNjYWRlID0gZmFsc2VdIFRydW5jYXRlcyBhbGwgdGFibGVzIHRoYXQgaGF2ZSBmb3JlaWduLWtleSByZWZlcmVuY2VzIHRvIHRoZSBuYW1lZCB0YWJsZSwgb3IgdG8gYW55IHRhYmxlcyBhZGRlZCB0byB0aGUgZ3JvdXAgZHVlIHRvIENBU0NBREUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgW29wdGlvbnMucmVzdGFydElkZW50aXR5PWZhbHNlXSBBdXRvbWF0aWNhbGx5IHJlc3RhcnQgc2VxdWVuY2VzIG93bmVkIGJ5IGNvbHVtbnMgb2YgdGhlIHRydW5jYXRlZCB0YWJsZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5kZXN0cm95fSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHRydW5jYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgPSB0cnVlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIG11bHRpcGxlIGluc3RhbmNlcywgb3Igc2V0IHRoZWlyIGRlbGV0ZWRBdCB0aW1lc3RhbXAgdG8gdGhlIGN1cnJlbnQgdGltZSBpZiBgcGFyYW5vaWRgIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95IG9wdGlvbnNcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBbb3B0aW9ucy53aGVyZV0gICAgICAgICAgICAgICAgIEZpbHRlciB0aGUgZGVzdHJveVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgICAgUnVuIGJlZm9yZSAvIGFmdGVyIGJ1bGsgZGVzdHJveSBob29rcz9cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5pbmRpdmlkdWFsSG9va3M9ZmFsc2VdIElmIHNldCB0byB0cnVlLCBkZXN0cm95IHdpbGwgU0VMRUNUIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSB3aGVyZSBwYXJhbWV0ZXIgYW5kIHdpbGwgZXhlY3V0ZSBiZWZvcmUgLyBhZnRlciBkZXN0cm95IGhvb2tzIG9uIGVhY2ggcm93XG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgW29wdGlvbnMubGltaXRdICAgICAgICAgICAgICAgICBIb3cgbWFueSByb3dzIHRvIGRlbGV0ZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmZvcmNlPWZhbHNlXSAgICAgICAgICAgRGVsZXRlIGluc3RlYWQgb2Ygc2V0dGluZyBkZWxldGVkQXQgdG8gY3VycmVudCB0aW1lc3RhbXAgKG9ubHkgYXBwbGljYWJsZSBpZiBgcGFyYW5vaWRgIGlzIGVuYWJsZWQpXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMudHJ1bmNhdGU9ZmFsc2VdICAgICAgICBJZiBzZXQgdG8gdHJ1ZSwgZGlhbGVjdHMgdGhhdCBzdXBwb3J0IGl0IHdpbGwgdXNlIFRSVU5DQVRFIGluc3RlYWQgb2YgREVMRVRFIEZST00uIElmIGEgdGFibGUgaXMgdHJ1bmNhdGVkIHRoZSB3aGVyZSBhbmQgbGltaXQgb3B0aW9ucyBhcmUgaWdub3JlZFxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmNhc2NhZGU9ZmFsc2VdICAgICAgICAgT25seSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggVFJVTkNBVEUuIFRydW5jYXRlcyAgYWxsIHRhYmxlcyB0aGF0IGhhdmUgZm9yZWlnbi1rZXkgcmVmZXJlbmNlcyB0byB0aGUgbmFtZWQgdGFibGUsIG9yIHRvIGFueSB0YWJsZXMgYWRkZWQgdG8gdGhlIGdyb3VwIGR1ZSB0byBDQVNDQURFLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLnJlc3RhcnRJZGVudGl0eT1mYWxzZV0gT25seSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggVFJVTkNBVEUuIEF1dG9tYXRpY2FsbHkgcmVzdGFydCBzZXF1ZW5jZXMgb3duZWQgYnkgY29sdW1ucyBvZiB0aGUgdHJ1bmNhdGVkIHRhYmxlLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IFRoZSBudW1iZXIgb2YgZGVzdHJveWVkIHJvd3NcbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgIShvcHRpb25zLndoZXJlIHx8IG9wdGlvbnMudHJ1bmNhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgd2hlcmUgb3IgdHJ1bmNhdGUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiBtb2RlbC5kZXN0cm95LicpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy50cnVuY2F0ZSAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMud2hlcmUpICYmICEob3B0aW9ucy53aGVyZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGxhaW4gb2JqZWN0LCBhcnJheSBvciBzZXF1ZWxpemUgbWV0aG9kIGluIHRoZSBvcHRpb25zLndoZXJlIHBhcmFtZXRlciBvZiBtb2RlbC5kZXN0cm95LicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIGNhc2NhZGU6IGZhbHNlLFxuICAgICAgcmVzdGFydElkZW50aXR5OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLREVMRVRFO1xuXG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuXG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUJ1bGtEZXN0cm95Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgLy8gR2V0IGRhb3MgYW5kIHJ1biBiZWZvcmVEZXN0cm95IGhvb2sgb24gZWFjaCByZWNvcmQgaW5kaXZpZHVhbGx5XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoeyB3aGVyZTogb3B0aW9ucy53aGVyZSwgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZywgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyayB9KTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVEZXN0cm95JywgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgLy8gUnVuIGRlbGV0ZSBxdWVyeSAob3IgdXBkYXRlIGlmIHBhcmFub2lkKVxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiAhb3B0aW9ucy5mb3JjZSkge1xuICAgICAgLy8gU2V0IHF1ZXJ5IHR5cGUgYXBwcm9wcmlhdGVseSB3aGVuIHJ1bm5pbmcgc29mdCBkZWxldGVcbiAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcblxuICAgICAgY29uc3QgYXR0clZhbHVlSGFzaCA9IHt9O1xuICAgICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XS5maWVsZDtcbiAgICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgICBbZmllbGRdOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbFxuICAgICAgfTtcblxuXG4gICAgICBhdHRyVmFsdWVIYXNoW2ZpZWxkXSA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBhdHRyVmFsdWVIYXNoLCBPYmplY3QuYXNzaWduKHdoZXJlLCBvcHRpb25zLndoZXJlKSwgb3B0aW9ucywgdGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrRGVsZXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyRGVzdHJveSBob29rIG9uIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5ydW5Ib29rcygnYWZ0ZXJEZXN0cm95JywgaW5zdGFuY2UsIG9wdGlvbnMpKVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJCdWxrRGVzdHJveScsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgbXVsdGlwbGUgaW5zdGFuY2VzIGlmIGBwYXJhbm9pZGAgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIFtvcHRpb25zLndoZXJlXSAgICAgICAgICAgICAgICAgRmlsdGVyIHRoZSByZXN0b3JlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICAgICBSdW4gYmVmb3JlIC8gYWZ0ZXIgYnVsayByZXN0b3JlIGhvb2tzP1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmluZGl2aWR1YWxIb29rcz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHJlc3RvcmUgd2lsbCBmaW5kIGFsbCByZWNvcmRzIHdpdGhpbiB0aGUgd2hlcmUgcGFyYW1ldGVyIGFuZCB3aWxsIGV4ZWN1dGUgYmVmb3JlIC8gYWZ0ZXIgYnVsa1Jlc3RvcmUgaG9va3Mgb24gZWFjaCByb3dcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICBbb3B0aW9ucy5saW1pdF0gICAgICAgICAgICAgICAgIEhvdyBtYW55IHJvd3MgdG8gdW5kZWxldGUgKG9ubHkgZm9yIG15c3FsKVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXRpYyBhc3luYyByZXN0b3JlKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIGlzIG5vdCBwYXJhbm9pZCcpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5SQVc7XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUJ1bGtSZXN0b3JlJywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgbGV0IGluc3RhbmNlcztcbiAgICAvLyBHZXQgZGFvcyBhbmQgcnVuIGJlZm9yZVJlc3RvcmUgaG9vayBvbiBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHlcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7IHdoZXJlOiBvcHRpb25zLndoZXJlLCB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbiwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLCBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrLCBwYXJhbm9pZDogZmFsc2UgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5ydW5Ib29rcygnYmVmb3JlUmVzdG9yZScsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICAvLyBSdW4gdW5kZWxldGUgcXVlcnlcbiAgICBjb25zdCBhdHRyVmFsdWVIYXNoID0ge307XG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG5cbiAgICBhdHRyVmFsdWVIYXNoW2RlbGV0ZWRBdEF0dHJpYnV0ZS5maWVsZCB8fCBkZWxldGVkQXRDb2xdID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlO1xuICAgIG9wdGlvbnMub21pdE51bGwgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgLy8gUnVuIGFmdGVyRGVzdHJveSBob29rIG9uIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5ydW5Ib29rcygnYWZ0ZXJSZXN0b3JlJywgaW5zdGFuY2UsIG9wdGlvbnMpKVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJCdWxrUmVzdG9yZScsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgdGhhdCBtYXRjaCB0aGUgd2hlcmUgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIHZhbHVlcyAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCBvZiB2YWx1ZXMgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICBvcHRpb25zLndoZXJlICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgdG8gZGVzY3JpYmUgdGhlIHNjb3BlIG9mIHRoZSBzZWFyY2guXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5wYXJhbm9pZD10cnVlXSAgICAgICAgIElmIHRydWUsIG9ubHkgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHVwZGF0ZWQuIElmIGZhbHNlLCBib3RoIGRlbGV0ZWQgYW5kIG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSB1cGRhdGVkLiBPbmx5IGFwcGxpZXMgaWYgYG9wdGlvbnMucGFyYW5vaWRgIGlzIHRydWUgZm9yIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIFtvcHRpb25zLmZpZWxkc10gICAgICAgICAgICAgICAgRmllbGRzIHRvIHVwZGF0ZSAoZGVmYXVsdHMgdG8gYWxsIGZpZWxkcylcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnZhbGlkYXRlPXRydWVdICAgICAgICAgU2hvdWxkIGVhY2ggcm93IGJlIHN1YmplY3QgdG8gdmFsaWRhdGlvbiBiZWZvcmUgaXQgaXMgaW5zZXJ0ZWQuIFRoZSB3aG9sZSBpbnNlcnQgd2lsbCBmYWlsIGlmIG9uZSByb3cgZmFpbHMgdmFsaWRhdGlvblxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICAgICBSdW4gYmVmb3JlIC8gYWZ0ZXIgYnVsayB1cGRhdGUgaG9va3M/XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5zaWRlRWZmZWN0cz10cnVlXSAgICAgIFdoZXRoZXIgb3Igbm90IHRvIHVwZGF0ZSB0aGUgc2lkZSBlZmZlY3RzIG9mIGFueSB2aXJ0dWFsIHNldHRlcnMuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5pbmRpdmlkdWFsSG9va3M9ZmFsc2VdIFJ1biBiZWZvcmUgLyBhZnRlciB1cGRhdGUgaG9va3M/LiBJZiB0cnVlLCB0aGlzIHdpbGwgZXhlY3V0ZSBhIFNFTEVDVCBmb2xsb3dlZCBieSBpbmRpdmlkdWFsIFVQREFURXMuIEEgc2VsZWN0IGlzIG5lZWRlZCwgYmVjYXVzZSB0aGUgcm93IGRhdGEgbmVlZHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBob29rc1xuICAgKiBAcGFyYW0gIHtib29sZWFufEFycmF5fSAgW29wdGlvbnMucmV0dXJuaW5nPWZhbHNlXSAgICAgICBJZiB0cnVlLCBhcHBlbmQgUkVUVVJOSU5HIDxtb2RlbCBjb2x1bW5zPiB0byBnZXQgYmFjayBhbGwgZGVmaW5lZCB2YWx1ZXM7IGlmIGFuIGFycmF5IG9mIGNvbHVtbiBuYW1lcywgYXBwZW5kIFJFVFVSTklORyA8Y29sdW1ucz4gdG8gZ2V0IGJhY2sgc3BlY2lmaWMgY29sdW1ucyAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgIFtvcHRpb25zLmxpbWl0XSAgICAgICAgICAgICAgICAgSG93IG1hbnkgcm93cyB0byB1cGRhdGUgKG9ubHkgZm9yIG15c3FsIGFuZCBtYXJpYWRiLCBpbXBsZW1lbnRlZCBhcyBUT1AobikgZm9yIE1TU1FMOyBmb3Igc3FsaXRlIGl0IGlzIHN1cHBvcnRlZCBvbmx5IHdoZW4gcm93aWQgaXMgcHJlc2VudClcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnNpbGVudD1mYWxzZV0gICAgICAgICAgSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8bnVtYmVyLG51bWJlcj4+fSAgVGhlIHByb21pc2UgcmV0dXJucyBhbiBhcnJheSB3aXRoIG9uZSBvciB0d28gZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGFsd2F5cyB0aGUgbnVtYmVyXG4gICAqIG9mIGFmZmVjdGVkIHJvd3MsIHdoaWxlIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgYWN0dWFsIGFmZmVjdGVkIHJvd3MgKG9ubHkgc3VwcG9ydGVkIGluIHBvc3RncmVzIHdpdGggYG9wdGlvbnMucmV0dXJuaW5nYCB0cnVlKS5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBhc3luYyB1cGRhdGUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIHRoaXMuX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgdmFsaWRhdGU6IHRydWUsXG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICByZXR1cm5pbmc6IGZhbHNlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgc2lkZUVmZmVjdHM6IHRydWVcbiAgICB9KSk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG5cbiAgICAvLyBDbG9uZSB2YWx1ZXMgc28gaXQgZG9lc24ndCBnZXQgbW9kaWZpZWQgZm9yIGNhbGxlciBzY29wZSBhbmQgaWdub3JlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICB2YWx1ZXMgPSBfLm9taXRCeSh2YWx1ZXMsIHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQpO1xuXG4gICAgLy8gUmVtb3ZlIHZhbHVlcyB0aGF0IGFyZSBub3QgaW4gdGhlIG9wdGlvbnMuZmllbGRzXG4gICAgaWYgKG9wdGlvbnMuZmllbGRzICYmIG9wdGlvbnMuZmllbGRzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlcykpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24oT2JqZWN0LmtleXModmFsdWVzKSwgT2JqZWN0LmtleXModGhpcy50YWJsZUF0dHJpYnV0ZXMpKTtcbiAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHZhbHVlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KSB8fCBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG5cbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuICAgIGxldCB2YWx1ZXNVc2U7XG4gICAgLy8gVmFsaWRhdGVcbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkKHZhbHVlcyk7XG4gICAgICBidWlsZC5zZXQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQsIHZhbHVlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0sIHsgcmF3OiB0cnVlIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaWRlRWZmZWN0cykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgXy5waWNrKGJ1aWxkLmdldCgpLCBidWlsZC5jaGFuZ2VkKCkpKTtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaW9uKG9wdGlvbnMuZmllbGRzLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugd2FudCB0byBza2lwIHZhbGlkYXRpb25zIGZvciBhbGwgb3RoZXIgZmllbGRzXG4gICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKSwgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXdhaXQgYnVpbGQudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gXy5waWNrKGF0dHJpYnV0ZXMuZGF0YVZhbHVlcywgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB2YWx1ZXM7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVCdWxrVXBkYXRlJywgb3B0aW9ucyk7XG4gICAgICB2YWx1ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIHZhbHVlc1VzZSA9IHZhbHVlcztcblxuICAgIC8vIEdldCBpbnN0YW5jZXMgYW5kIHJ1biBiZWZvcmVVcGRhdGUgaG9vayBvbiBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHlcbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIGxldCB1cGRhdGVEb25lUm93QnlSb3cgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7XG4gICAgICAgIHdoZXJlOiBvcHRpb25zLndoZXJlLFxuICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrLFxuICAgICAgICBwYXJhbm9pZDogb3B0aW9ucy5wYXJhbm9pZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFJ1biBiZWZvcmVVcGRhdGUgaG9va3Mgb24gZWFjaCByZWNvcmQgYW5kIGNoZWNrIHdoZXRoZXIgYmVmb3JlVXBkYXRlIGhvb2sgY2hhbmdlcyB2YWx1ZXMgdW5pZm9ybWx5XG4gICAgICAgIC8vIGkuZS4gd2hldGhlciB0aGV5IGNoYW5nZSB2YWx1ZXMgZm9yIGVhY2ggcmVjb3JkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICBsZXQgY2hhbmdlZFZhbHVlcztcbiAgICAgICAgbGV0IGRpZmZlcmVudCA9IGZhbHNlO1xuXG4gICAgICAgIGluc3RhbmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgaW5zdGFuY2UgPT4ge1xuICAgICAgICAgIC8vIFJlY29yZCB1cGRhdGVzIGluIGluc3RhbmNlcyBkYXRhVmFsdWVzXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZS5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgICAgICAgIC8vIFNldCB0aGUgY2hhbmdlZCBmaWVsZHMgb24gdGhlIGluc3RhbmNlXG4gICAgICAgICAgXy5mb3JJbih2YWx1ZXNVc2UsIChuZXdWYWx1ZSwgYXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldERhdGFWYWx1ZShhdHRyLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBSdW4gYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVVcGRhdGUnLCBpbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNDaGFuZ2VkVmFsdWVzID0ge307XG4gICAgICAgICAgICBfLmZvckluKGluc3RhbmNlLmRhdGFWYWx1ZXMsIChuZXdWYWx1ZSwgYXR0cikgPT4ge1xuICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzQ2hhbmdlZFZhbHVlc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRWYWx1ZXMgPSB0aGlzQ2hhbmdlZFZhbHVlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpZmZlcmVudCA9ICFfLmlzRXF1YWwoY2hhbmdlZFZhbHVlcywgdGhpc0NoYW5nZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZWRWYWx1ZXMpO1xuICAgICAgICAgIC8vIEhvb2tzIGRvIG5vdCBjaGFuZ2UgdmFsdWVzIG9yIGNoYW5nZSB0aGVtIHVuaWZvcm1seVxuICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSG9va3MgY2hhbmdlIHZhbHVlcyAtIHJlY29yZCBjaGFuZ2VzIGluIHZhbHVlc1VzZSBzbyB0aGV5IGFyZSBleGVjdXRlZFxuICAgICAgICAgICAgdmFsdWVzVXNlID0gY2hhbmdlZFZhbHVlcztcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlvbihvcHRpb25zLmZpZWxkcywga2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kaXZpZHVhbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgIGhvb2tzOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmluZGl2aWR1YWxIb29rcztcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnNhdmUoaW5kaXZpZHVhbE9wdGlvbnMpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB1cGRhdGVEb25lUm93QnlSb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHVwZGF0ZURvbmVSb3dCeVJvdykge1xuICAgICAgcmVzdWx0ID0gW2luc3RhbmNlcy5sZW5ndGgsIGluc3RhbmNlc107XG4gICAgfSBlbHNlIGlmIChfLmlzRW1wdHkodmFsdWVzVXNlKVxuICAgICAgIHx8IE9iamVjdC5rZXlzKHZhbHVlc1VzZSkubGVuZ3RoID09PSAxICYmIHZhbHVlc1VzZVt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0pIHtcbiAgICAgIC8vIG9ubHkgdXBkYXRlZEF0IGlzIGJlaW5nIHBhc3NlZCwgdGhlbiBza2lwIHVwZGF0ZVxuICAgICAgcmVzdWx0ID0gWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNVc2UgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModmFsdWVzVXNlLCBvcHRpb25zLmZpZWxkcywgdGhpcyk7XG4gICAgICBvcHRpb25zID0gVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5oYXNUcmlnZ2VyIDogZmFsc2U7XG5cbiAgICAgIGNvbnN0IGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzVXNlLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmVzdWx0ID0gW2FmZmVjdGVkUm93cy5sZW5ndGgsIGFmZmVjdGVkUm93c107XG4gICAgICAgIGluc3RhbmNlcyA9IGFmZmVjdGVkUm93cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFthZmZlY3RlZFJvd3NdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLnJ1bkhvb2tzKCdhZnRlclVwZGF0ZScsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgICAgcmVzdWx0WzFdID0gaW5zdGFuY2VzO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB2YWx1ZXM7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlckJ1bGtVcGRhdGUnLCBvcHRpb25zKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGEgZGVzY3JpYmUgcXVlcnkgb24gdGhlIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjaGVtYV0gc2NoZW1hIG5hbWUgdG8gc2VhcmNoIHRhYmxlIGluXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gcXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gaGFzaCBvZiBhdHRyaWJ1dGVzIGFuZCB0aGVpciB0eXBlc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlc2NyaWJlKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlc2NyaWJlVGFibGUodGhpcy50YWJsZU5hbWUsIHsgc2NoZW1hOiBzY2hlbWEgfHwgdGhpcy5fc2NoZW1hIHx8IHVuZGVmaW5lZCwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBfZ2V0RGVmYXVsdFRpbWVzdGFtcChhdHRyKSB7XG4gICAgaWYgKCEhdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmICEhdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLnRvRGVmYXVsdFZhbHVlKHRoaXMucmF3QXR0cmlidXRlc1thdHRyXS5kZWZhdWx0VmFsdWUsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGF0aWMgX2V4cGFuZEF0dHJpYnV0ZXMob3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcy5leGNsdWRlKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5maWx0ZXIoZWxlbSA9PiAhb3B0aW9ucy5hdHRyaWJ1dGVzLmV4Y2x1ZGUuaW5jbHVkZXMoZWxlbSkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZSkge1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KG9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgLy8gSW5qZWN0IF9zY29wZSBpbnRvIG9wdGlvbnMuXG4gIHN0YXRpYyBfaW5qZWN0U2NvcGUob3B0aW9ucykge1xuICAgIGNvbnN0IHNjb3BlID0gVXRpbHMuY2xvbmVEZWVwKHRoaXMuX3Njb3BlKTtcbiAgICB0aGlzLl9kZWZhdWx0c09wdGlvbnMob3B0aW9ucywgc2NvcGUpO1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgc3RhdGljIGhhc0FsaWFzKGFsaWFzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmFzc29jaWF0aW9ucywgYWxpYXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdmFsdWUgb2Ygb25lIG9yIG1vcmUgY29sdW1ucy4gVGhpcyBpcyBkb25lIGluIHRoZSBkYXRhYmFzZSwgd2hpY2ggbWVhbnMgaXQgZG9lcyBub3QgdXNlIHRoZSB2YWx1ZXMgY3VycmVudGx5IHN0b3JlZCBvbiB0aGUgSW5zdGFuY2UuIFRoZSBpbmNyZW1lbnQgaXMgZG9uZSB1c2luZyBhXG4gICAqIGBgYCBTRVQgY29sdW1uID0gY29sdW1uICsgWCBXSEVSRSBmb28gPSAnYmFyJyBgYGAgcXVlcnkuIFRvIGdldCB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBhbiBpbmNyZW1lbnQgaW50byB0aGUgSW5zdGFuY2UgeW91IHNob3VsZCBkbyBhIHJlbG9hZC5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+aW5jcmVtZW50IG51bWJlciBieSAxPC9jYXB0aW9uPlxuICAgKiBNb2RlbC5pbmNyZW1lbnQoJ251bWJlcicsIHsgd2hlcmU6IHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+aW5jcmVtZW50IG51bWJlciBhbmQgY291bnQgYnkgMjwvY2FwdGlvbj5cbiAgICogTW9kZWwuaW5jcmVtZW50KFsnbnVtYmVyJywgJ2NvdW50J10sIHsgYnk6IDIsIHdoZXJlOiB7IGZvbzogJ2JhcicgfSB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+aW5jcmVtZW50IGFuc3dlciBieSA0MiwgYW5kIGRlY3JlbWVudCB0cmllcyBieSAxPC9jYXB0aW9uPlxuICAgKiAvLyBgYnlgIGlzIGlnbm9yZWQsIGFzIGVhY2ggY29sdW1uIGhhcyBpdHMgb3duIHZhbHVlXG4gICAqIE1vZGVsLmluY3JlbWVudCh7IGFuc3dlcjogNDIsIHRyaWVzOiAtMX0sIHsgYnk6IDIsIHdoZXJlOiB7IGZvbzogJ2JhcicgfSB9KTtcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjcmVsb2FkfVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8b2JqZWN0fSAgZmllbGRzICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgdGhhdCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIG9mIGBieWAgZ2l2ZW4gaW4gb3B0aW9ucy4gSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZSBzYW1lIGlzIHRydWUgZm9yIGVhY2ggY29sdW1uLiBJZiBhbmQgb2JqZWN0IGlzIHByb3ZpZGVkLCBlYWNoIGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgZ2l2ZW4uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCBvcHRpb25zXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICBvcHRpb25zLndoZXJlICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMgaGFzaFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgW29wdGlvbnMuYnk9MV0gICAgICAgICAgICAgICBUaGUgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgW29wdGlvbnMuc2lsZW50PWZhbHNlXSAgICAgICBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgICAgICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsW10sP251bWJlcj59IHJldHVybnMgYW4gYXJyYXkgb2YgYWZmZWN0ZWQgcm93cyBhbmQgYWZmZWN0ZWQgY291bnQgd2l0aCBgb3B0aW9ucy5yZXR1cm5pbmdgIHRydWUsIHdoZW5ldmVyIHN1cHBvcnRlZCBieSBkaWFsZWN0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgZmllbGRzID09PSAnc3RyaW5nJykgZmllbGRzID0gW2ZpZWxkc107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgZmllbGRzID0gZmllbGRzLm1hcChmID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmF3QXR0cmlidXRlc1tmXSAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICE9PSBmKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIHRoaXMuX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBieTogMSxcbiAgICAgIHdoZXJlOiB7fSxcbiAgICAgIGluY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGlzU3VidHJhY3Rpb24gPSAhb3B0aW9ucy5pbmNyZW1lbnQ7XG5cbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgY29uc3Qgd2hlcmUgPSB7IC4uLm9wdGlvbnMud2hlcmUgfTtcblxuICAgIC8vIEEgcGxhaW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSBmaWVsZHMgdG8gYmUgaW5jcmVtZW50ZWQgYW5kIHdob3NlIHZhbHVlcyBhcmVcbiAgICAvLyB0aGUgYW1vdW50cyB0byBiZSBpbmNyZW1lbnRlZCBieS5cbiAgICBsZXQgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGRbZmllbGRdID0gb3B0aW9ucy5ieTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGBmaWVsZHNgIGFyZ3VtZW50IGlzIG5vdCBhbiBhcnJheSwgdGhlbiB3ZSBhc3N1bWUgaXQgYWxyZWFkeSBoYXMgdGhlXG4gICAgICAvLyBmb3JtIG5lY2Vzc2FyeSB0byBiZSBwbGFjZWQgZGlyZWN0bHkgaW4gdGhlIGBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZGAgdmFyaWFibGUuXG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IGZpZWxkcztcbiAgICB9XG5cbiAgICAvLyBJZiBvcHRpbWlzdGljIGxvY2tpbmcgaXMgZW5hYmxlZCwgd2UgY2FuIHRha2UgYWR2YW50YWdlIHRoYXQgdGhpcyBpcyBhblxuICAgIC8vIGluY3JlbWVudC9kZWNyZW1lbnQgb3BlcmF0aW9uIGFuZCBzZW5kIGl0IGhlcmUgYXMgd2VsbC4gV2UgcHV0IGAtMWAgZm9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGJlY2F1c2UgaXQgd2lsbCBiZSBzdWJ0cmFjdGVkLCBnZXR0aW5nIGAtKC0xKWAgd2hpY2ggaXMgYCsxYFxuICAgIGlmICh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKSB7XG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFt0aGlzLl92ZXJzaW9uQXR0cmlidXRlXSA9IGlzU3VidHJhY3Rpb24gPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQgPSB7fTtcblxuICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIHVwZGF0ZWRBdEF0dHIgJiYgIWluY3JlbWVudEFtb3VudHNCeUZpZWxkW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucmF3QXR0cmlidXRlc1t1cGRhdGVkQXRBdHRyXS5maWVsZCB8fCB1cGRhdGVkQXRBdHRyO1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWRbYXR0ck5hbWVdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKTtcbiAgICBsZXQgYWZmZWN0ZWRSb3dzO1xuICAgIGlmIChpc1N1YnRyYWN0aW9uKSB7XG4gICAgICBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlY3JlbWVudChcbiAgICAgICAgdGhpcywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmluY3JlbWVudChcbiAgICAgICAgdGhpcywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgcmV0dXJuIFthZmZlY3RlZFJvd3MsIGFmZmVjdGVkUm93cy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiBbYWZmZWN0ZWRSb3dzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyZW1lbnQgdGhlIHZhbHVlIG9mIG9uZSBvciBtb3JlIGNvbHVtbnMuIFRoaXMgaXMgZG9uZSBpbiB0aGUgZGF0YWJhc2UsIHdoaWNoIG1lYW5zIGl0IGRvZXMgbm90IHVzZSB0aGUgdmFsdWVzIGN1cnJlbnRseSBzdG9yZWQgb24gdGhlIEluc3RhbmNlLiBUaGUgZGVjcmVtZW50IGlzIGRvbmUgdXNpbmcgYVxuICAgKiBgYGBzcWwgU0VUIGNvbHVtbiA9IGNvbHVtbiAtIFggV0hFUkUgZm9vID0gJ2JhcidgYGAgcXVlcnkuIFRvIGdldCB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBhIGRlY3JlbWVudCBpbnRvIHRoZSBJbnN0YW5jZSB5b3Ugc2hvdWxkIGRvIGEgcmVsb2FkLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5kZWNyZW1lbnQgbnVtYmVyIGJ5IDE8L2NhcHRpb24+XG4gICAqIE1vZGVsLmRlY3JlbWVudCgnbnVtYmVyJywgeyB3aGVyZTogeyBmb286ICdiYXInIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5kZWNyZW1lbnQgbnVtYmVyIGFuZCBjb3VudCBieSAyPC9jYXB0aW9uPlxuICAgKiBNb2RlbC5kZWNyZW1lbnQoWydudW1iZXInLCAnY291bnQnXSwgeyBieTogMiwgd2hlcmU6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5kZWNyZW1lbnQgYW5zd2VyIGJ5IDQyLCBhbmQgZGVjcmVtZW50IHRyaWVzIGJ5IC0xPC9jYXB0aW9uPlxuICAgKiAvLyBgYnlgIGlzIGlnbm9yZWQsIHNpbmNlIGVhY2ggY29sdW1uIGhhcyBpdHMgb3duIHZhbHVlXG4gICAqIE1vZGVsLmRlY3JlbWVudCh7IGFuc3dlcjogNDIsIHRyaWVzOiAtMX0sIHsgYnk6IDIsIHdoZXJlOiB7IGZvbzogJ2JhcicgfSB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl8b2JqZWN0fSBmaWVsZHMgSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoYXQgY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBvZiBgYnlgIGdpdmVuIGluIG9wdGlvbnMuIElmIGFuIGFycmF5IGlzIHByb3ZpZGVkLCB0aGUgc2FtZSBpcyB0cnVlIGZvciBlYWNoIGNvbHVtbi4gSWYgYW5kIG9iamVjdCBpcyBwcm92aWRlZCwgZWFjaCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIGdpdmVuLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBkZWNyZW1lbnQgb3B0aW9ucywgc2ltaWxhciB0byBpbmNyZW1lbnRcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuaW5jcmVtZW50fVxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNyZWxvYWR9XG4gICAqIEBzaW5jZSA0LjM2LjBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxbXSw/bnVtYmVyPn0gcmV0dXJucyBhbiBhcnJheSBvZiBhZmZlY3RlZCByb3dzIGFuZCBhZmZlY3RlZCBjb3VudCB3aXRoIGBvcHRpb25zLnJldHVybmluZ2AgdHJ1ZSwgd2hlbmV2ZXIgc3VwcG9ydGVkIGJ5IGRpYWxlY3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50KGZpZWxkcywge1xuICAgICAgYnk6IDEsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaW5jcmVtZW50OiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIF9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKSB7XG4gICAgYXNzZXJ0KG9wdGlvbnMgJiYgb3B0aW9ucy53aGVyZSwgJ01pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlcicpO1xuICAgIGFzc2VydChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLndoZXJlKSB8fCBvcHRpb25zLndoZXJlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kLFxuICAgICAgJ0V4cGVjdGVkIHBsYWluIG9iamVjdCwgYXJyYXkgb3Igc2VxdWVsaXplIG1ldGhvZCBpbiB0aGUgb3B0aW9ucy53aGVyZSBwYXJhbWV0ZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcXVlcnkgZm9yIHRoaXMgaW5zdGFuY2UsIHVzZSB3aXRoIGBvcHRpb25zLndoZXJlYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja1ZlcnNpb249ZmFsc2VdIGluY2x1ZGUgdmVyc2lvbiBhdHRyaWJ1dGUgaW4gd2hlcmUgaGFzaFxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgd2hlcmUoY2hlY2tWZXJzaW9uKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLnJlZHVjZSgocmVzdWx0LCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGVdID0gdGhpcy5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgaWYgKF8uc2l6ZSh3aGVyZSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMud2hlcmVDb2xsZWN0aW9uO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uQXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3ZlcnNpb25BdHRyaWJ1dGU7XG4gICAgaWYgKGNoZWNrVmVyc2lvbiAmJiB2ZXJzaW9uQXR0cikge1xuICAgICAgd2hlcmVbdmVyc2lvbkF0dHJdID0gdGhpcy5nZXQodmVyc2lvbkF0dHIsIHsgcmF3OiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMubWFwV2hlcmVGaWVsZE5hbWVzKHdoZXJlLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW29iamVjdCBTZXF1ZWxpemVJbnN0YW5jZToke3RoaXMuY29uc3RydWN0b3IubmFtZX1dYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBrZXkgdG8gbG9vayBpbiBpbnN0YW5jZSBkYXRhIHN0b3JlXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBnZXREYXRhVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdW5kZXJseWluZyBkYXRhIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkga2V5IHRvIHNldCBpbiBpbnN0YW5jZSBkYXRhIHN0b3JlXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBuZXcgdmFsdWUgZm9yIGdpdmVuIGtleVxuICAgKlxuICAgKi9cbiAgc2V0RGF0YVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV07XG5cbiAgICBpZiAoIV8uaXNFcXVhbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkpIHtcbiAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVZhbHVlc1trZXldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSWYgbm8ga2V5IGlzIGdpdmVuLCByZXR1cm5zIGFsbCB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlLCBhbHNvIGludm9raW5nIHZpcnR1YWwgZ2V0dGVycy5cbiAgICpcbiAgICogSWYga2V5IGlzIGdpdmVuIGFuZCBhIGZpZWxkIG9yIHZpcnR1YWwgZ2V0dGVyIGlzIHByZXNlbnQgZm9yIHRoZSBrZXkgaXQgd2lsbCBjYWxsIHRoYXQgZ2V0dGVyIC0gZWxzZSBpdCB3aWxsIHJldHVybiB0aGUgdmFsdWUgZm9yIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBba2V5XSBrZXkgdG8gZ2V0IHZhbHVlIG9mXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdIGdldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGxhaW49ZmFsc2VdIElmIHNldCB0byB0cnVlLCBpbmNsdWRlZCBpbnN0YW5jZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBwbGFpbiBvYmplY3RzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmF3PWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgZmllbGQgYW5kIHZpcnR1YWwgc2V0dGVycyB3aWxsIGJlIGlnbm9yZWRcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdHxhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGtleTtcbiAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fY3VzdG9tR2V0dGVycywga2V5KSAmJiAhb3B0aW9ucy5yYXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbUdldHRlcnNba2V5XS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBsYWluICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YVZhbHVlc1trZXldKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XS5tYXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UuZ2V0KG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhVmFsdWVzW2tleV0gaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XS5nZXQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5faGFzQ3VzdG9tR2V0dGVyc1xuICAgICAgfHwgb3B0aW9ucy5wbGFpbiAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGVcbiAgICAgIHx8IG9wdGlvbnMuY2xvbmVcbiAgICApIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgICAgbGV0IF9rZXk7XG5cbiAgICAgIGlmICh0aGlzLl9oYXNDdXN0b21HZXR0ZXJzKSB7XG4gICAgICAgIGZvciAoX2tleSBpbiB0aGlzLl9jdXN0b21HZXR0ZXJzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAmJiAhdGhpcy5fb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKF9rZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2N1c3RvbUdldHRlcnMsIF9rZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXNbX2tleV0gPSB0aGlzLmdldChfa2V5LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChfa2V5IGluIHRoaXMuZGF0YVZhbHVlcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIF9rZXkpXG4gICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZGF0YVZhbHVlcywgX2tleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFsdWVzW19rZXldID0gdGhpcy5nZXQoX2tleSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpcyB1c2VkIHRvIHVwZGF0ZSB2YWx1ZXMgb24gdGhlIGluc3RhbmNlICh0aGUgc2VxdWVsaXplIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZSB0aGF0IGlzLCByZW1lbWJlciB0aGF0IG5vdGhpbmcgd2lsbCBiZSBwZXJzaXN0ZWQgYmVmb3JlIHlvdSBhY3R1YWxseSBjYWxsIGBzYXZlYCkuXG4gICAqIEluIGl0cyBtb3N0IGJhc2ljIGZvcm0gYHNldGAgd2lsbCB1cGRhdGUgYSB2YWx1ZSBzdG9yZWQgaW4gdGhlIHVuZGVybHlpbmcgYGRhdGFWYWx1ZXNgIG9iamVjdC4gSG93ZXZlciwgaWYgYSBjdXN0b20gc2V0dGVyIGZ1bmN0aW9uIGlzIGRlZmluZWQgZm9yIHRoZSBrZXksIHRoYXQgZnVuY3Rpb25cbiAgICogd2lsbCBiZSBjYWxsZWQgaW5zdGVhZC4gVG8gYnlwYXNzIHRoZSBzZXR0ZXIsIHlvdSBjYW4gcGFzcyBgcmF3OiB0cnVlYCBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAqXG4gICAqIElmIHNldCBpcyBjYWxsZWQgd2l0aCBhbiBvYmplY3QsIGl0IHdpbGwgbG9vcCBvdmVyIHRoZSBvYmplY3QsIGFuZCBjYWxsIHNldCByZWN1cnNpdmVseSBmb3IgZWFjaCBrZXksIHZhbHVlIHBhaXIuIElmIHlvdSBzZXQgcmF3IHRvIHRydWUsIHRoZSB1bmRlcmx5aW5nIGRhdGFWYWx1ZXMgd2lsbCBlaXRoZXIgYmVcbiAgICogc2V0IGRpcmVjdGx5IHRvIHRoZSBvYmplY3QgcGFzc2VkLCBvciB1c2VkIHRvIGV4dGVuZCBkYXRhVmFsdWVzLCBpZiBkYXRhVmFsdWVzIGFscmVhZHkgY29udGFpbiB2YWx1ZXMuXG4gICAqXG4gICAqIFdoZW4gc2V0IGlzIGNhbGxlZCwgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBmaWVsZCBpcyBzdG9yZWQgYW5kIHNldHMgYSBjaGFuZ2VkIGZsYWcoc2VlIGBjaGFuZ2VkYCkuXG4gICAqXG4gICAqIFNldCBjYW4gYWxzbyBiZSB1c2VkIHRvIGJ1aWxkIGluc3RhbmNlcyBmb3IgYXNzb2NpYXRpb25zLCBpZiB5b3UgaGF2ZSB2YWx1ZXMgZm9yIHRob3NlLlxuICAgKiBXaGVuIHVzaW5nIHNldCB3aXRoIGFzc29jaWF0aW9ucyB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IGtleSBtYXRjaGVzIHRoZSBhbGlhcyBvZiB0aGUgYXNzb2NpYXRpb25cbiAgICogd2hpbGUgYWxzbyBtYWtpbmcgc3VyZSB0aGF0IHRoZSBwcm9wZXIgaW5jbHVkZSBvcHRpb25zIGhhdmUgYmVlbiBzZXQgKGZyb20gLmJ1aWxkKCkgb3IgLmZpbmRPbmUoKSlcbiAgICpcbiAgICogSWYgY2FsbGVkIHdpdGggYSBkb3Quc2VwYXJhdGVkIGtleSBvbiBhIEpTT04vSlNPTkIgYXR0cmlidXRlIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBuZXN0ZWQgYW5kIGZsYWcgdGhlIGVudGlyZSBvYmplY3QgYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaW5jbHVkZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBrZXkga2V5IHRvIHNldCwgaXQgY2FuIGJlIHN0cmluZyBvciBvYmplY3QuIFdoZW4gc3RyaW5nIGl0IHdpbGwgc2V0IHRoYXQga2V5LCBmb3Igb2JqZWN0IGl0IHdpbGwgbG9vcCBvdmVyIGFsbCBvYmplY3QgcHJvcGVydGllcyBuZCBzZXQgdGhlbS5cbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIHZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmF3PWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgZmllbGQgYW5kIHZpcnR1YWwgc2V0dGVycyB3aWxsIGJlIGlnbm9yZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNldD1mYWxzZV0gQ2xlYXIgYWxsIHByZXZpb3VzbHkgc2V0IGRhdGEgdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH1cbiAgICovXG4gIHNldChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgb3JpZ2luYWxWYWx1ZTtcblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IGtleTtcbiAgICAgIG9wdGlvbnMgPSB2YWx1ZSB8fCB7fTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZChrZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiByYXcsIGFuZCB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGluY2x1ZGVzIG9yIHNwZWNpYWwgYXR0cmlidXRlcywganVzdCBzZXQgaXQgc3RyYWlnaHQgb24gdGhlIGRhdGFWYWx1ZXMgb2JqZWN0XG4gICAgICBpZiAob3B0aW9ucy5yYXcgJiYgISh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSkgJiYgIShvcHRpb25zICYmIG9wdGlvbnMuYXR0cmlidXRlcykgJiYgIXRoaXMuY29uc3RydWN0b3IuX2hhc0RhdGVBdHRyaWJ1dGVzICYmICF0aGlzLmNvbnN0cnVjdG9yLl9oYXNCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kYXRhVmFsdWVzKS5sZW5ndGgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhdGFWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmF3LCAuY2hhbmdlZCgpIHNob3VsZG4ndCBiZSB0cnVlXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IHsgLi4udGhpcy5kYXRhVmFsdWVzIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb29wIGFuZCBjYWxsIHNldFxuICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgY29uc3Qgc2V0S2V5cyA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlc1trXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zZXQoaywgdmFsdWVzW2tdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldEtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzVmlydHVhbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHNldEtleXModGhpcy5jb25zdHJ1Y3Rvci5fdmlydHVhbEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMpIHtcbiAgICAgICAgICAgIHNldEtleXModGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnJhdykge1xuICAgICAgICAgIC8vIElmIHJhdywgLmNoYW5nZWQoKSBzaG91bGRuJ3QgYmUgdHJ1ZVxuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IHsgLi4udGhpcy5kYXRhVmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge307XG4gICAgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgb3JpZ2luYWxWYWx1ZSA9IHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgIH1cblxuICAgIC8vIElmIG5vdCByYXcsIGFuZCB0aGVyZSdzIGEgY3VzdG9tIHNldHRlclxuICAgIGlmICghb3B0aW9ucy5yYXcgJiYgdGhpcy5fY3VzdG9tU2V0dGVyc1trZXldKSB7XG4gICAgICB0aGlzLl9jdXN0b21TZXR0ZXJzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgIC8vIGN1c3RvbSBzZXR0ZXIgc2hvdWxkIGhhdmUgY2hhbmdlZCB2YWx1ZSwgZ2V0IHRoYXQgY2hhbmdlZCB2YWx1ZVxuICAgICAgLy8gVE9ETzogdjUgbWFrZSBzZXR0ZXJzIHJldHVybiBuZXcgdmFsdWUgaW5zdGVhZCBvZiBjaGFuZ2luZyBpbnRlcm5hbCBzdG9yZVxuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICAgIGlmICghXy5pc0VxdWFsKG5ld1ZhbHVlLCBvcmlnaW5hbFZhbHVlKSkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGluY2x1ZGVkIG1vZGVscywgYW5kIGlmIHRoaXMga2V5IG1hdGNoZXMgdGhlIGluY2x1ZGUgbW9kZWwgbmFtZXMvYWxpYXNlc1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgLy8gUGFzcyBpdCBvbiB0byB0aGUgaW5jbHVkZSBoYW5kbGVyXG4gICAgICAgIHRoaXMuX3NldEluY2x1ZGUoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gQnVuY2ggb2Ygc3R1ZmYgd2Ugd29uJ3QgZG8gd2hlbiBpdCdzIHJhd1xuICAgICAgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgICAvLyBJZiBhdHRyaWJ1dGUgaXMgbm90IGluIG1vZGVsIGRlZmluaXRpb24sIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMuX2lzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fanNvbkF0dHJpYnV0ZXMuaGFzKGtleS5zcGxpdCgnLicpWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNOZXN0ZWRWYWx1ZSA9IERvdHRpZS5nZXQodGhpcy5kYXRhVmFsdWVzLCBrZXkpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldmlvdXNOZXN0ZWRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIERvdHRpZS5zZXQodGhpcy5kYXRhVmFsdWVzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkKGtleS5zcGxpdCgnLicpWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhdHRlbXB0aW5nIHRvIHNldCBwcmltYXJ5IGtleSBhbmQgcHJpbWFyeSBrZXkgaXMgYWxyZWFkeSBkZWZpbmVkLCByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc1ByaW1hcnlLZXlzICYmIG9yaWdpbmFsVmFsdWUgJiYgdGhpcy5jb25zdHJ1Y3Rvci5faXNQcmltYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gc2V0IHJlYWQgb25seSBhdHRyaWJ1dGVzLCByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuY29uc3RydWN0b3IuX2hhc1JlYWRPbmx5QXR0cmlidXRlcyAmJiB0aGlzLmNvbnN0cnVjdG9yLl9yZWFkT25seUF0dHJpYnV0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgZGF0YSB0eXBlIHNhbml0aXplclxuICAgICAgaWYgKFxuICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKVxuICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVTYW5pdGl6ZXJzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZVNhbml0aXplcnNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIGFuZCBub3QgcmF3XG4gICAgICBpZiAoXG4gICAgICAgICFvcHRpb25zLnJhdyAmJlxuICAgICAgICAoXG4gICAgICAgICAgLy8gVHJ1ZSB3aGVuIHNlcXVlbGl6ZSBtZXRob2RcbiAgICAgICAgICAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHxcbiAgICAgICAgICAvLyBDaGVjayBmb3IgZGF0YSB0eXBlIHR5cGUgY29tcGFyYXRvcnNcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBvcHRpb25zKSB8fCAvLyBDaGVjayBkZWZhdWx0XG4gICAgICAgICAgIXRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldICYmICFfLmlzRXF1YWwodmFsdWUsIG9yaWdpbmFsVmFsdWUpKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV0gPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGRhdGEgdmFsdWVcbiAgICAgIHRoaXMuZGF0YVZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlcyh1cGRhdGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHVwZGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGNoYW5nZWQgaXMgY2FsbGVkIHdpdGggYSBzdHJpbmcgaXQgd2lsbCByZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdmFsdWUgb2YgdGhhdCBrZXkgaW4gYGRhdGFWYWx1ZXNgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSB2YWx1ZSBpbiBgX3ByZXZpb3VzRGF0YVZhbHVlc2AuXG4gICAqXG4gICAqIElmIGNoYW5nZWQgaXMgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIGl0IHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGtleXMgdGhhdCBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIElmIGNoYW5nZWQgaXMgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQgYW5kIG5vIGtleXMgaGF2ZSBjaGFuZ2VkLCBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIGEgcHJvcGVydHkgZnJvbSBhIG5lc3RlZCAoZm9yIGV4YW1wbGUgSlNPTikgcHJvcGVydHlcbiAgICogd2FzIGVkaXRlZCBtYW51YWxseSwgeW91IG11c3QgY2FsbCBgY2hhbmdlZCgna2V5JywgdHJ1ZSlgIG1hbnVhbGx5IGluIHRoZXNlIGNhc2VzLlxuICAgKiBXcml0aW5nIGFuIGVudGlyZWx5IG5ldyBvYmplY3QgKGVnLiBkZWVwIGNsb25lZCkgd2lsbCBiZSBkZXRlY3RlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IG1kbCA9IGF3YWl0IE15TW9kZWwuZmluZE9uZSgpO1xuICAgKiBtZGwubXlKc29uRmllbGQuYSA9IDE7XG4gICAqIGNvbnNvbGUubG9nKG1kbC5jaGFuZ2VkKCkpID0+IGZhbHNlXG4gICAqIG1kbC5zYXZlKCk7IC8vIHRoaXMgd2lsbCBub3Qgc2F2ZSBhbnl0aGluZ1xuICAgKiBtZGwuY2hhbmdlZCgnbXlKc29uRmllbGQnLCB0cnVlKTtcbiAgICogY29uc29sZS5sb2cobWRsLmNoYW5nZWQoKSkgPT4gWydteUpzb25GaWVsZCddXG4gICAqIG1kbC5zYXZlKCk7IC8vIHdpbGwgc2F2ZVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIGtleSB0byBjaGVjayBvciBjaGFuZ2Ugc3RhdHVzIG9mXG4gICAqIEBwYXJhbSB7YW55fSBbdmFsdWVdIHZhbHVlIHRvIHNldFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxBcnJheX1cbiAgICovXG4gIGNoYW5nZWQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2NoYW5nZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY2hhbmdlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY2hhbmdlZC5hZGQoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzIHZhbHVlIGZvciBrZXkgZnJvbSBgX3ByZXZpb3VzRGF0YVZhbHVlc2AuXG4gICAqXG4gICAqIElmIGNhbGxlZCB3aXRob3V0IGEga2V5LCByZXR1cm5zIHRoZSBwcmV2aW91cyB2YWx1ZXMgZm9yIGFsbCB2YWx1ZXMgd2hpY2ggaGF2ZSBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBrZXkgdG8gZ2V0IHByZXZpb3VzIHZhbHVlIG9mXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl8QXJyYXk8YW55Pn1cbiAgICovXG4gIHByZXZpb3VzKGtleSkge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy5waWNrQnkodGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzLCAodmFsdWUsIGtleSkgPT4gdGhpcy5jaGFuZ2VkKGtleSkpO1xuICB9XG5cbiAgX3NldEluY2x1ZGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXTtcbiAgICBpZiAodmFsdWVbMF0gaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UuZGF0YVZhbHVlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5jbHVkZSA9IHRoaXMuX29wdGlvbnMuaW5jbHVkZU1hcFtrZXldO1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICBjb25zdCBhY2Nlc3NvciA9IGtleTtcbiAgICBjb25zdCBwcmltYXJ5S2V5QXR0cmlidXRlID0gaW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IGNoaWxkT3B0aW9ucyA9IHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0aGlzLmlzTmV3UmVjb3JkLFxuICAgICAgaW5jbHVkZTogaW5jbHVkZS5pbmNsdWRlLFxuICAgICAgaW5jbHVkZU5hbWVzOiBpbmNsdWRlLmluY2x1ZGVOYW1lcyxcbiAgICAgIGluY2x1ZGVNYXA6IGluY2x1ZGUuaW5jbHVkZU1hcCxcbiAgICAgIGluY2x1ZGVWYWxpZGF0ZWQ6IHRydWUsXG4gICAgICByYXc6IG9wdGlvbnMucmF3LFxuICAgICAgYXR0cmlidXRlczogaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXNcbiAgICB9O1xuICAgIGxldCBpc0VtcHR5O1xuXG4gICAgaWYgKGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgfHwgaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlzRW1wdHkgPSB2YWx1ZSAmJiB2YWx1ZVtwcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgdGhpc1thY2Nlc3Nvcl0gPSB0aGlzLmRhdGFWYWx1ZXNbYWNjZXNzb3JdID0gaXNFbXB0eSA/IG51bGwgOiBpbmNsdWRlLm1vZGVsLmJ1aWxkKHZhbHVlLCBjaGlsZE9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNFbXB0eSA9IHZhbHVlWzBdICYmIHZhbHVlWzBdW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBudWxsO1xuICAgICAgICB0aGlzW2FjY2Vzc29yXSA9IHRoaXMuZGF0YVZhbHVlc1thY2Nlc3Nvcl0gPSBpc0VtcHR5ID8gW10gOiBpbmNsdWRlLm1vZGVsLmJ1bGtCdWlsZCh2YWx1ZSwgY2hpbGRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoaXMgaW5zdGFuY2UsIGFuZCBpZiB0aGUgdmFsaWRhdGlvbiBwYXNzZXMsIHBlcnNpc3RzIGl0IHRvIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2F2ZWQgaW5zdGFuY2UgKG9yIHJlamVjdHMgd2l0aCBhIGBTZXF1ZWxpemUuVmFsaWRhdGlvbkVycm9yYCwgd2hpY2ggd2lsbCBoYXZlIGEgcHJvcGVydHkgZm9yIGVhY2ggb2YgdGhlIGZpZWxkcyBmb3Igd2hpY2ggdGhlIHZhbGlkYXRpb24gZmFpbGVkLCB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGZvciB0aGF0IGZpZWxkKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgb3B0aW1pemVkIHRvIHBlcmZvcm0gYW4gVVBEQVRFIG9ubHkgaW50byB0aGUgZmllbGRzIHRoYXQgY2hhbmdlZC4gSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgbm8gU1FMIHF1ZXJ5IHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXdhcmUgb2YgZWFnZXIgbG9hZGVkIGFzc29jaWF0aW9ucy4gSW4gb3RoZXIgd29yZHMsIGlmIHNvbWUgb3RoZXIgbW9kZWwgaW5zdGFuY2UgKGNoaWxkKSB3YXMgZWFnZXIgbG9hZGVkIHdpdGggdGhpcyBpbnN0YW5jZSAocGFyZW50KSwgYW5kIHlvdSBjaGFuZ2Ugc29tZXRoaW5nIGluIHRoZSBjaGlsZCwgY2FsbGluZyBgc2F2ZSgpYCB3aWxsIHNpbXBseSBpZ25vcmUgdGhlIGNoYW5nZSB0aGF0IGhhcHBlbmVkIG9uIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW29wdGlvbnNdIHNhdmUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSAgICBbb3B0aW9ucy5maWVsZHNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIHN0cmluZ3MsIHJlcHJlc2VudGluZyBkYXRhYmFzZSBjb2x1bW5zLiBJZiBmaWVsZHMgaXMgcHJvdmlkZWQsIG9ubHkgdGhvc2UgY29sdW1ucyB3aWxsIGJlIHZhbGlkYXRlZCBhbmQgc2F2ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLnNpbGVudD1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMudmFsaWRhdGU9dHJ1ZV0gSWYgZmFsc2UsIHZhbGlkYXRpb25zIHdvbid0IGJlIHJ1bi5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gUnVuIGJlZm9yZSBhbmQgYWZ0ZXIgY3JlYXRlIC8gdXBkYXRlICsgdmFsaWRhdGUgaG9va3NcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5yZXR1cm5pbmddIEFwcGVuZCBSRVRVUk5JTkcgKiB0byBnZXQgYmFjayBhdXRvIGdlbmVyYXRlZCB2YWx1ZXMgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIGFzeW5jIHNhdmUob3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGFyZ3VtZW50IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIHRoZSBvcHRpb25zIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24odGhpcy5jaGFuZ2VkKCksIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWFyeUtleU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgcHJpbWFyeUtleUF0dHJpYnV0ZSA9IHByaW1hcnlLZXlOYW1lICYmIHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1twcmltYXJ5S2V5TmFtZV07XG4gICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgIGNvbnN0IHZlcnNpb25BdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdmVyc2lvbkF0dHJpYnV0ZTtcbiAgICBjb25zdCBob29rID0gdGhpcy5pc05ld1JlY29yZCA/ICdDcmVhdGUnIDogJ1VwZGF0ZSc7XG4gICAgY29uc3Qgd2FzTmV3UmVjb3JkID0gdGhpcy5pc05ld1JlY29yZDtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICBsZXQgdXBkYXRlZEF0QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuXG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgb3B0aW9ucy5maWVsZHMubGVuZ3RoID49IDEgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbkF0dHIgJiYgb3B0aW9ucy5maWVsZHMubGVuZ3RoID49IDEgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHZlcnNpb25BdHRyKSkge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh2ZXJzaW9uQXR0cik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2lsZW50ID09PSB0cnVlICYmICEodGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLmdldCh1cGRhdGVkQXRBdHRyLCB7IHJhdzogdHJ1ZSB9KSkpIHtcbiAgICAgIC8vIFVwZGF0ZUF0QXR0ciBtaWdodCBoYXZlIGJlZW4gYWRkZWQgYXMgYSByZXN1bHQgb2YgT2JqZWN0LmtleXMoTW9kZWwucmF3QXR0cmlidXRlcykuIEluIHRoYXQgY2FzZSB3ZSBoYXZlIHRvIHJlbW92ZSBpdCBhZ2FpblxuICAgICAgXy5yZW1vdmUob3B0aW9ucy5maWVsZHMsIHZhbCA9PiB2YWwgPT09IHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgdXBkYXRlZEF0QXR0ciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkID09PSB0cnVlKSB7XG4gICAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMoY3JlYXRlZEF0QXR0cikpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChjcmVhdGVkQXRBdHRyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgcHJpbWFyeUtleUF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHByaW1hcnlLZXlOYW1lKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy51bnNoaWZ0KHByaW1hcnlLZXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcmltYXJ5S2V5TmFtZSAmJiB0aGlzLmdldChwcmltYXJ5S2V5TmFtZSwgeyByYXc6IHRydWUgfSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhdHRlbXB0ZWQgdG8gc2F2ZSBhbiBpbnN0YW5jZSB3aXRoIG5vIHByaW1hcnkga2V5LCB0aGlzIGlzIG5vdCBhbGxvd2VkIHNpbmNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIGdsb2JhbCB1cGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5zaWxlbnQgJiYgb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgIHRoaXMuZGF0YVZhbHVlc1t1cGRhdGVkQXRBdHRyXSA9IHRoaXMuY29uc3RydWN0b3IuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkICYmIGNyZWF0ZWRBdEF0dHIgJiYgIXRoaXMuZGF0YVZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgdGhpcy5kYXRhVmFsdWVzW2NyZWF0ZWRBdEF0dHJdID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0RGVmYXVsdFRpbWVzdGFtcChjcmVhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGVcbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZShvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGNvbnN0IGJlZm9yZUhvb2tWYWx1ZXMgPSBfLnBpY2sodGhpcy5kYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgICBsZXQgaWdub3JlQ2hhbmdlZCA9IF8uZGlmZmVyZW5jZSh0aGlzLmNoYW5nZWQoKSwgb3B0aW9ucy5maWVsZHMpOyAvLyBJbiBjYXNlIG9mIHVwZGF0ZSB3aGVyZSBpdCdzIG9ubHkgc3VwcG9zZWQgdG8gdXBkYXRlIHRoZSBwYXNzZWQgdmFsdWVzIGFuZCB0aGUgaG9vayB2YWx1ZXNcbiAgICAgIGxldCBob29rQ2hhbmdlZDtcbiAgICAgIGxldCBhZnRlckhvb2tWYWx1ZXM7XG5cbiAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmIG9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIGlnbm9yZUNoYW5nZWQgPSBfLndpdGhvdXQoaWdub3JlQ2hhbmdlZCwgdXBkYXRlZEF0QXR0cik7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoYGJlZm9yZSR7aG9va31gLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRGaWVsZHMgJiYgIXRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgYWZ0ZXJIb29rVmFsdWVzID0gXy5waWNrKHRoaXMuZGF0YVZhbHVlcywgXy5kaWZmZXJlbmNlKHRoaXMuY2hhbmdlZCgpLCBpZ25vcmVDaGFuZ2VkKSk7XG5cbiAgICAgICAgaG9va0NoYW5nZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYWZ0ZXJIb29rVmFsdWVzKSkge1xuICAgICAgICAgIGlmIChhZnRlckhvb2tWYWx1ZXNba2V5XSAhPT0gYmVmb3JlSG9va1ZhbHVlc1trZXldKSB7XG4gICAgICAgICAgICBob29rQ2hhbmdlZC5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaXEob3B0aW9ucy5maWVsZHMuY29uY2F0KGhvb2tDaGFuZ2VkKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChob29rQ2hhbmdlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgICAgIC8vIFZhbGlkYXRlIGFnYWluXG5cbiAgICAgICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSwgaG9va0NoYW5nZWQpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc2tpcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWVsZHMubGVuZ3RoICYmIHRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX29wdGlvbnMuaW5jbHVkZS5maWx0ZXIoaW5jbHVkZSA9PiBpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvKS5tYXAoYXN5bmMgaW5jbHVkZSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHJldHVybjtcblxuICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKVxuICAgICAgICAgIC5vbWl0KFsnYXNzb2NpYXRpb24nXSlcbiAgICAgICAgICAuZGVmYXVsdHMoe1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgICAgICBwYXJlbnRSZWNvcmQ6IHRoaXNcbiAgICAgICAgICB9KS52YWx1ZSgpO1xuXG4gICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuXG4gICAgICAgIGF3YWl0IHRoaXNbaW5jbHVkZS5hc3NvY2lhdGlvbi5hY2Nlc3NvcnMuc2V0XShpbnN0YW5jZSwgeyBzYXZlOiBmYWxzZSwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nIH0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFsRmllbGRzID0gb3B0aW9ucy5maWVsZHMuZmlsdGVyKGZpZWxkID0+ICF0aGlzLmNvbnN0cnVjdG9yLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoZmllbGQpKTtcbiAgICBpZiAoIXJlYWxGaWVsZHMubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIXRoaXMuY2hhbmdlZCgpICYmICF0aGlzLmlzTmV3UmVjb3JkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IHZlcnNpb25GaWVsZE5hbWUgPSBfLmdldCh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbdmVyc2lvbkF0dHJdLCAnZmllbGQnKSB8fCB2ZXJzaW9uQXR0cjtcbiAgICBjb25zdCB2YWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModGhpcy5kYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgbGV0IHF1ZXJ5ID0gbnVsbDtcbiAgICBsZXQgYXJncyA9IFtdO1xuICAgIGxldCB3aGVyZTtcblxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICBxdWVyeSA9ICdpbnNlcnQnO1xuICAgICAgYXJncyA9IFt0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzLCBvcHRpb25zXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmUgPSB0aGlzLndoZXJlKHRydWUpO1xuICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgIHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXSA9IHBhcnNlSW50KHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXSwgMTApICsgMTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5ID0gJ3VwZGF0ZSc7XG4gICAgICBhcmdzID0gW3RoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXMsIHdoZXJlLCBvcHRpb25zXTtcbiAgICB9XG5cbiAgICBjb25zdCBbcmVzdWx0LCByb3dzVXBkYXRlZF0gPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnF1ZXJ5SW50ZXJmYWNlW3F1ZXJ5XSguLi5hcmdzKTtcbiAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgIC8vIENoZWNrIHRvIHNlZSB0aGF0IGEgcm93IHdhcyB1cGRhdGVkLCBvdGhlcndpc2UgaXQncyBhbiBvcHRpbWlzdGljIGxvY2tpbmcgZXJyb3IuXG4gICAgICBpZiAocm93c1VwZGF0ZWQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuT3B0aW1pc3RpY0xvY2tFcnJvcih7XG4gICAgICAgICAgbW9kZWxOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHdoZXJlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmRhdGFWYWx1ZXNbdmVyc2lvbkF0dHJdID0gdmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYW5zZmVyIGRhdGFiYXNlIGdlbmVyYXRlZCB2YWx1ZXMgKGRlZmF1bHRzLCBhdXRvaW5jcmVtZW50LCBldGMpXG4gICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiZcbiAgICAgICAgICB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyXG4gICAgICApIHtcbiAgICAgICAgdmFsdWVzW2F0dHJdID0gdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgIGRlbGV0ZSB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIHJlc3VsdC5kYXRhVmFsdWVzKTtcblxuICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgaWYgKHdhc05ld1JlY29yZCAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHRoaXMuX29wdGlvbnMuaW5jbHVkZS5maWx0ZXIoaW5jbHVkZSA9PiAhKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gfHxcbiAgICAgICAgICBpbmNsdWRlLnBhcmVudCAmJiBpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKS5tYXAoYXN5bmMgaW5jbHVkZSA9PiB7XG4gICAgICAgICAgbGV0IGluc3RhbmNlcyA9IHRoaXMuZ2V0KGluY2x1ZGUuYXMpO1xuXG4gICAgICAgICAgaWYgKCFpbnN0YW5jZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG5cbiAgICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKVxuICAgICAgICAgICAgLm9taXQoWydhc3NvY2lhdGlvbiddKVxuICAgICAgICAgICAgLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgICAgICAgcGFyZW50UmVjb3JkOiB0aGlzXG4gICAgICAgICAgICB9KS52YWx1ZSgpO1xuXG4gICAgICAgICAgLy8gSW5zdGFuY2VzIHdpbGwgYmUgdXBkYXRlZCBpbiBwbGFjZSBzbyB3ZSBjYW4gc2FmZWx5IHRyZWF0IEhhc09uZSBsaWtlIGEgSGFzTWFueVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSB7XG4gICAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMwID0ge1xuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXldOiB0aGlzLmdldCh0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5XTogaW5zdGFuY2UuZ2V0KGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdmFsdWVzIGRlZmluZWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgLi4uaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyhpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5fYXV0b0dlbmVyYXRlZCB8fFxuICAgICAgICAgICAgICAgICAgICBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMwW2F0dHJdID0gaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsLmNyZWF0ZSh2YWx1ZXMwLCBpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5LCB0aGlzLmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoYGFmdGVyJHtob29rfWAsIHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGQgb2Ygb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHJlc3VsdC5fcHJldmlvdXNEYXRhVmFsdWVzW2ZpZWxkXSA9IHJlc3VsdC5kYXRhVmFsdWVzW2ZpZWxkXTtcbiAgICAgIHRoaXMuY2hhbmdlZChmaWVsZCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmlzTmV3UmVjb3JkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4tcGxhY2UsIGkuZS4gdXBkYXRlIHRoZSBvYmplY3Qgd2l0aCBjdXJyZW50IGRhdGEgZnJvbSB0aGUgREIgYW5kIHJldHVybiB0aGUgc2FtZSBvYmplY3QuXG4gICAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gZG9pbmcgYSBgZmluZChJbnN0YW5jZS5pZClgLCBiZWNhdXNlIHRoYXQgd291bGQgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2UuIFdpdGggdGhpcyBtZXRob2QsXG4gICAqIGFsbCByZWZlcmVuY2VzIHRvIHRoZSBJbnN0YW5jZSBhcmUgdXBkYXRlZCB3aXRoIHRoZSBuZXcgZGF0YSBhbmQgbm8gbmV3IG9iamVjdHMgYXJlIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgb24gdG8gYE1vZGVsLmZpbmRgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBhc3luYyByZWxvYWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyh7XG4gICAgICB3aGVyZTogdGhpcy53aGVyZSgpXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgaW5jbHVkZTogdGhpcy5fb3B0aW9ucy5pbmNsdWRlIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVsb2FkZWQgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKCFyZWxvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5JbnN0YW5jZUVycm9yKFxuICAgICAgICAnSW5zdGFuY2UgY291bGQgbm90IGJlIHJlbG9hZGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgYW55bW9yZSAoZmluZCBjYWxsIHJldHVybmVkIG51bGwpJ1xuICAgICAgKTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBvcHRpb25zIG9mIHRoZSBpbnN0YW5jZVxuICAgIHRoaXMuX29wdGlvbnMgPSByZWxvYWRlZC5fb3B0aW9ucztcbiAgICAvLyByZS1zZXQgaW5zdGFuY2UgdmFsdWVzXG4gICAgdGhpcy5zZXQocmVsb2FkZWQuZGF0YVZhbHVlcywge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcmVzZXQ6IHRydWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgKiBWYWxpZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGluc3RhbmNlIGFjY29yZGluZyB0byB2YWxpZGF0aW9uIHJ1bGVzIHNldCBpbiB0aGUgbW9kZWwgZGVmaW5pdGlvbi5cbiAgKlxuICAqIFRoZSBwcm9taXNlIGZ1bGZpbGxzIGlmIGFuZCBvbmx5IGlmIHZhbGlkYXRpb24gc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlIGl0IHJlamVjdHMgYW4gRXJyb3IgaW5zdGFuY2UgY29udGFpbmluZyB7IGZpZWxkIG5hbWUgOiBbZXJyb3IgbXNnc10gfSBlbnRyaWVzLlxuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgdmFsaWRhdG9yXG4gICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuc2tpcF0gQW4gYXJyYXkgb2Ygc3RyaW5ncy4gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgaW4gdGhpcyBhcnJheSB3aWxsIG5vdCBiZSB2YWxpZGF0ZWRcbiAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5maWVsZHNdIEFuIGFycmF5IG9mIHN0cmluZ3MuIE9ubHkgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgaW4gdGhpcyBhcnJheSB3aWxsIGJlIHZhbGlkYXRlZFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaG9va3M9dHJ1ZV0gUnVuIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsaWRhdGUgaG9va3NcbiAgKlxuICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAqL1xuICBhc3luYyB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJbnN0YW5jZVZhbGlkYXRvcih0aGlzLCBvcHRpb25zKS52YWxpZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBgc2V0YCBhbmQgdGhlbiBjYWxsaW5nIGBzYXZlYCBidXQgaXQgb25seSBzYXZlcyB0aGVcbiAgICogZXhhY3QgdmFsdWVzIHBhc3NlZCB0byBpdCwgbWFraW5nIGl0IG1vcmUgYXRvbWljIGFuZCBzYWZlci5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjc2V0fVxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNzYXZlfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFNlZSBgc2V0YFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBTZWUgYHNhdmVgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIGFzeW5jIHVwZGF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAvLyBDbG9uZSB2YWx1ZXMgc28gaXQgZG9lc24ndCBnZXQgbW9kaWZpZWQgZm9yIGNhbGxlciBzY29wZSBhbmQgaWdub3JlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICB2YWx1ZXMgPSBfLm9taXRCeSh2YWx1ZXMsIHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgY2hhbmdlZEJlZm9yZSA9IHRoaXMuY2hhbmdlZCgpIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIG9wdGlvbnMgPSB7IGZpZWxkczogb3B0aW9ucyB9O1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBzZXRPcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIHNldE9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMuc2V0KHZhbHVlcywgc2V0T3B0aW9ucyk7XG5cbiAgICAvLyBOb3cgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoaWNoIGZpZWxkcyB3ZXJlIGFjdHVhbGx5IGFmZmVjdGVkIGJ5IHRoZSBzZXR0ZXIuXG4gICAgY29uc3Qgc2lkZUVmZmVjdHMgPSBfLndpdGhvdXQodGhpcy5jaGFuZ2VkKCksIC4uLmNoYW5nZWRCZWZvcmUpO1xuICAgIGNvbnN0IGZpZWxkcyA9IF8udW5pb24oT2JqZWN0LmtleXModmFsdWVzKSwgc2lkZUVmZmVjdHMpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbihmaWVsZHMsIHRoaXMuY2hhbmdlZCgpKTtcbiAgICAgIG9wdGlvbnMuZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNhdmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZS4gRGVwZW5kaW5nIG9uIHlvdXIgc2V0dGluZyBmb3IgcGFyYW5vaWQsIHRoZSByb3cgd2lsbCBlaXRoZXIgYmUgY29tcGxldGVseSBkZWxldGVkLCBvciBoYXZlIGl0cyBkZWxldGVkQXQgdGltZXN0YW1wIHNldCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9ucz17fV0gZGVzdHJveSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLmZvcmNlPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgcGFyYW5vaWQgbW9kZWxzIHdpbGwgYWN0dWFsbHkgYmUgZGVsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZGVzdHJveShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcygnYmVmb3JlRGVzdHJveScsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB3aGVyZSA9IHRoaXMud2hlcmUodHJ1ZSk7XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiBvcHRpb25zLmZvcmNlID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgJ2RlZmF1bHRWYWx1ZScpXG4gICAgICAgID8gYXR0cmlidXRlLmRlZmF1bHRWYWx1ZVxuICAgICAgICA6IG51bGw7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmdldERhdGFWYWx1ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGNvbnN0IHVuZGVmaW5lZE9yTnVsbCA9IGN1cnJlbnRWYWx1ZSA9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSA9PSBudWxsO1xuICAgICAgaWYgKHVuZGVmaW5lZE9yTnVsbCB8fCBfLmlzRXF1YWwoY3VycmVudFZhbHVlLCBkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIHRpbWVzdGFtcCBpZiBpdCB3YXNuJ3QgYWxyZWFkeSBzZXRcbiAgICAgICAgdGhpcy5zZXREYXRhVmFsdWUoYXR0cmlidXRlTmFtZSwgbmV3IERhdGUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2F2ZSh7IC4uLm9wdGlvbnMsIGhvb2tzOiBmYWxzZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5xdWVyeUludGVyZmFjZS5kZWxldGUodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHdoZXJlLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuREVMRVRFLCBsaW1pdDogbnVsbCwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcygnYWZ0ZXJEZXN0cm95JywgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgYSBpbnN0YW5jZSBpcyBcInNvZnQgZGVsZXRlZFwiLiAgVGhpcyBpc1xuICAgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGlmIHRoZSBpbXBsZW1lbnRlciByZW5hbWVkIHRoZSBgZGVsZXRlZEF0YCBhdHRyaWJ1dGVcbiAgICogdG8gc29tZXRoaW5nIGRpZmZlcmVudC4gIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGBwYXJhbm9pZGAgdG8gYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1NvZnREZWxldGVkKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9kZWwgaXMgbm90IHBhcmFub2lkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICBjb25zdCBkZWxldGVkQXQgPSB0aGlzLmdldCh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkgfHwgbnVsbDtcbiAgICBjb25zdCBpc1NldCA9IGRlbGV0ZWRBdCAhPT0gZGVmYXVsdFZhbHVlO1xuXG4gICAgcmV0dXJuIGlzU2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGhlIHJvdyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaW5zdGFuY2UuIE9ubHkgYXZhaWxhYmxlIGZvciBwYXJhbm9pZCBtb2RlbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtvcHRpb25zPXt9XSByZXN0b3JlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByZXN0b3JlKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIGlzIG5vdCBwYXJhbm9pZCcpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcygnYmVmb3JlUmVzdG9yZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcblxuICAgIHRoaXMuc2V0RGF0YVZhbHVlKGRlbGV0ZWRBdENvbCwgZGVsZXRlZEF0RGVmYXVsdFZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhdmUoeyAuLi5vcHRpb25zLCBob29rczogZmFsc2UsIG9taXROdWxsOiBmYWxzZSB9KTtcbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKCdhZnRlclJlc3RvcmUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSB2YWx1ZSBvZiBvbmUgb3IgbW9yZSBjb2x1bW5zLiBUaGlzIGlzIGRvbmUgaW4gdGhlIGRhdGFiYXNlLCB3aGljaCBtZWFucyBpdCBkb2VzIG5vdCB1c2UgdGhlIHZhbHVlcyBjdXJyZW50bHkgc3RvcmVkIG9uIHRoZSBJbnN0YW5jZS4gVGhlIGluY3JlbWVudCBpcyBkb25lIHVzaW5nIGFcbiAgICogYGBgc3FsXG4gICAqIFNFVCBjb2x1bW4gPSBjb2x1bW4gKyBYXG4gICAqIGBgYFxuICAgKiBxdWVyeS4gVGhlIHVwZGF0ZWQgaW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZCBieSBkZWZhdWx0IGluIFBvc3RncmVzLiBIb3dldmVyLCBpbiBvdGhlciBkaWFsZWN0cywgeW91IHdpbGwgbmVlZCB0byBkbyBhIHJlbG9hZCB0byBnZXQgdGhlIG5ldyB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGluc3RhbmNlLmluY3JlbWVudCgnbnVtYmVyJykgLy8gaW5jcmVtZW50IG51bWJlciBieSAxXG4gICAqXG4gICAqIGluc3RhbmNlLmluY3JlbWVudChbJ251bWJlcicsICdjb3VudCddLCB7IGJ5OiAyIH0pIC8vIGluY3JlbWVudCBudW1iZXIgYW5kIGNvdW50IGJ5IDJcbiAgICpcbiAgICogLy8gaW5jcmVtZW50IGFuc3dlciBieSA0MiwgYW5kIHRyaWVzIGJ5IDEuXG4gICAqIC8vIGBieWAgaXMgaWdub3JlZCwgc2luY2UgZWFjaCBjb2x1bW4gaGFzIGl0cyBvd24gdmFsdWVcbiAgICogaW5zdGFuY2UuaW5jcmVtZW50KHsgYW5zd2VyOiA0MiwgdHJpZXM6IDF9LCB7IGJ5OiAyIH0pXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3JlbG9hZH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl8b2JqZWN0fSBmaWVsZHMgSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoYXQgY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBvZiBgYnlgIGdpdmVuIGluIG9wdGlvbnMuIElmIGFuIGFycmF5IGlzIHByb3ZpZGVkLCB0aGUgc2FtZSBpcyB0cnVlIGZvciBlYWNoIGNvbHVtbi4gSWYgYW5kIG9iamVjdCBpcyBwcm92aWRlZCwgZWFjaCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIGdpdmVuLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJ5PTFdIFRoZSBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2lsZW50PWZhbHNlXSBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVybmluZz10cnVlXSBBcHBlbmQgUkVUVVJOSU5HICogdG8gZ2V0IGJhY2sgYXV0byBnZW5lcmF0ZWQgdmFsdWVzIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgYXN5bmMgaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLndoZXJlKCk7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMud2hlcmUgPSB7IC4uLm9wdGlvbnMud2hlcmUsIC4uLmlkZW50aWZpZXIgfTtcbiAgICBvcHRpb25zLmluc3RhbmNlID0gdGhpcztcblxuICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IuaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyZW1lbnQgdGhlIHZhbHVlIG9mIG9uZSBvciBtb3JlIGNvbHVtbnMuIFRoaXMgaXMgZG9uZSBpbiB0aGUgZGF0YWJhc2UsIHdoaWNoIG1lYW5zIGl0IGRvZXMgbm90IHVzZSB0aGUgdmFsdWVzIGN1cnJlbnRseSBzdG9yZWQgb24gdGhlIEluc3RhbmNlLiBUaGUgZGVjcmVtZW50IGlzIGRvbmUgdXNpbmcgYVxuICAgKiBgYGBzcWxcbiAgICogU0VUIGNvbHVtbiA9IGNvbHVtbiAtIFhcbiAgICogYGBgXG4gICAqIHF1ZXJ5LiBUaGUgdXBkYXRlZCBpbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkIGJ5IGRlZmF1bHQgaW4gUG9zdGdyZXMuIEhvd2V2ZXIsIGluIG90aGVyIGRpYWxlY3RzLCB5b3Ugd2lsbCBuZWVkIHRvIGRvIGEgcmVsb2FkIHRvIGdldCB0aGUgbmV3IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW5zdGFuY2UuZGVjcmVtZW50KCdudW1iZXInKSAvLyBkZWNyZW1lbnQgbnVtYmVyIGJ5IDFcbiAgICpcbiAgICogaW5zdGFuY2UuZGVjcmVtZW50KFsnbnVtYmVyJywgJ2NvdW50J10sIHsgYnk6IDIgfSkgLy8gZGVjcmVtZW50IG51bWJlciBhbmQgY291bnQgYnkgMlxuICAgKlxuICAgKiAvLyBkZWNyZW1lbnQgYW5zd2VyIGJ5IDQyLCBhbmQgdHJpZXMgYnkgMS5cbiAgICogLy8gYGJ5YCBpcyBpZ25vcmVkLCBzaW5jZSBlYWNoIGNvbHVtbiBoYXMgaXRzIG93biB2YWx1ZVxuICAgKiBpbnN0YW5jZS5kZWNyZW1lbnQoeyBhbnN3ZXI6IDQyLCB0cmllczogMX0sIHsgYnk6IDIgfSlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjcmVsb2FkfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheXxvYmplY3R9IGZpZWxkcyBJZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgdGhhdCBjb2x1bW4gaXMgZGVjcmVtZW50ZWQgYnkgdGhlIHZhbHVlIG9mIGBieWAgZ2l2ZW4gaW4gb3B0aW9ucy4gSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZSBzYW1lIGlzIHRydWUgZm9yIGVhY2ggY29sdW1uLiBJZiBhbmQgb2JqZWN0IGlzIHByb3ZpZGVkLCBlYWNoIGNvbHVtbiBpcyBkZWNyZW1lbnRlZCBieSB0aGUgdmFsdWUgZ2l2ZW5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW29wdGlvbnNdIGRlY3JlbWVudCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgIFtvcHRpb25zLmJ5PTFdIFRoZSBudW1iZXIgdG8gZGVjcmVtZW50IGJ5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLnNpbGVudD1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5yZXR1cm5pbmc9dHJ1ZV0gQXBwZW5kIFJFVFVSTklORyAqIHRvIGdldCBiYWNrIGF1dG8gZ2VuZXJhdGVkIHZhbHVlcyAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkZWNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50KGZpZWxkcywge1xuICAgICAgYnk6IDEsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaW5jcmVtZW50OiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBhbmQgYG90aGVyYCBJbnN0YW5jZSByZWZlciB0byB0aGUgc2FtZSByb3dcbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gb3RoZXIgT3RoZXIgaW5zdGFuY2UgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFvdGhlciB8fCAhb3RoZXIuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMuZXZlcnkoYXR0cmlidXRlID0+IHRoaXMuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IG90aGVyLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIGlzIGVxdWFsIHRvIG9uZSBvZiBgb3RoZXJzYCBieSBjYWxsaW5nIGVxdWFsc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE1vZGVsPn0gb3RoZXJzIEFuIGFycmF5IG9mIGluc3RhbmNlcyB0byBjaGVjayBhZ2FpbnN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzT25lT2Yob3RoZXJzKSB7XG4gICAgcmV0dXJuIG90aGVycy5zb21lKG90aGVyID0+IHRoaXMuZXF1YWxzKG90aGVyKSk7XG4gIH1cblxuICBzZXRWYWxpZGF0b3JzKGF0dHJpYnV0ZSwgdmFsaWRhdG9ycykge1xuICAgIHRoaXMudmFsaWRhdG9yc1thdHRyaWJ1dGVdID0gdmFsaWRhdG9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBpbnN0YW5jZSB0byBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAqIFByb3hpZXMgdG8gY2FsbGluZyBgZ2V0YCB3aXRoIG5vIGtleXMuXG4gICAqIFRoaXMgbWVhbnMgZ2V0IGFsbCB2YWx1ZXMgZ290dGVuIGZyb20gdGhlIERCLCBhbmQgYXBwbHkgYWxsIGN1c3RvbSBnZXR0ZXJzLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNnZXR9XG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIF8uY2xvbmVEZWVwKFxuICAgICAgdGhpcy5nZXQoe1xuICAgICAgICBwbGFpbjogdHJ1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSAxOm0gYXNzb2NpYXRpb24gYmV0d2VlbiB0aGlzICh0aGUgc291cmNlKSBhbmQgdGhlIHByb3ZpZGVkIHRhcmdldC5cbiAgICogVGhlIGZvcmVpZ24ga2V5IGlzIGFkZGVkIG9uIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICAgICAgdGFyZ2V0IFRhcmdldCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zXSBoYXNNYW55IGFzc29jaWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy5ob29rcz1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcnVuIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIHdoZW4gYW4gYXNzb2NpYXRlZCBtb2RlbCBpcyBkZWxldGVkIGJlY2F1c2Ugb2YgYSBjYXNjYWRlLiBGb3IgZXhhbXBsZSBpZiBgVXNlci5oYXNPbmUoUHJvZmlsZSwge29uRGVsZXRlOiAnY2FzY2FkZScsIGhvb2tzOnRydWV9KWAsIHRoZSBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyBmb3IgcHJvZmlsZSB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBpcyBkZWxldGVkLiBPdGhlcndpc2UgdGhlIHByb2ZpbGUgd2lsbCBiZSBkZWxldGVkIHdpdGhvdXQgaW52b2tpbmcgYW55IGhvb2tzXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgW29wdGlvbnMuYXNdIFRoZSBhbGlhcyBvZiB0aGlzIG1vZGVsLiBJZiB5b3UgcHJvdmlkZSBhIHN0cmluZywgaXQgc2hvdWxkIGJlIHBsdXJhbCwgYW5kIHdpbGwgYmUgc2luZ3VsYXJpemVkIHVzaW5nIG5vZGUuaW5mbGVjdGlvbi4gSWYgeW91IHdhbnQgdG8gY29udHJvbCB0aGUgc2luZ3VsYXIgdmVyc2lvbiB5b3Vyc2VsZiwgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBgcGx1cmFsYCBhbmQgYHNpbmd1bGFyYCBrZXlzLiBTZWUgYWxzbyB0aGUgYG5hbWVgIG9wdGlvbiBwYXNzZWQgdG8gYHNlcXVlbGl6ZS5kZWZpbmVgLiBJZiB5b3UgY3JlYXRlIG11bHRpcGxlIGFzc29jaWF0aW9ucyBiZXR3ZWVuIHRoZSBzYW1lIHRhYmxlcywgeW91IHNob3VsZCBwcm92aWRlIGFuIGFsaWFzIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtLiBJZiB5b3UgcHJvdmlkZSBhbiBhbGlhcyB3aGVuIGNyZWF0aW5nIHRoZSBhc3NvY2lhdGlvbiwgeW91IHNob3VsZCBwcm92aWRlIHRoZSBzYW1lIGFsaWFzIHdoZW4gZWFnZXIgbG9hZGluZyBhbmQgd2hlbiBnZXR0aW5nIGFzc29jaWF0ZWQgbW9kZWxzLiBEZWZhdWx0cyB0byB0aGUgcGx1cmFsaXplZCBuYW1lIG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgIFtvcHRpb25zLmZvcmVpZ25LZXldIFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBpbiB0aGUgdGFyZ2V0IHRhYmxlIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIGZvcmVpZ24gY29sdW1uIChzZWUgYFNlcXVlbGl6ZS5kZWZpbmVgIGZvciBzeW50YXgpLiBXaGVuIHVzaW5nIGFuIG9iamVjdCwgeW91IGNhbiBhZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gc2V0IHRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHNvdXJjZSArIHByaW1hcnkga2V5IG9mIHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgIFtvcHRpb25zLnNvdXJjZUtleV0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIHVzZSBhcyB0aGUga2V5IGZvciB0aGUgYXNzb2NpYXRpb24gaW4gdGhlIHNvdXJjZSB0YWJsZS4gRGVmYXVsdHMgdG8gdGhlIHByaW1hcnkga2V5IG9mIHRoZSBzb3VyY2UgdGFibGVcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9ucy5zY29wZV0gQSBrZXkvdmFsdWUgc2V0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhc3NvY2lhdGlvbiBjcmVhdGUgYW5kIGZpbmQgZGVmYXVsdHMgb24gdGhlIHRhcmdldC4gKHNxbGl0ZSBub3Qgc3VwcG9ydGVkIGZvciBOOk0pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgW29wdGlvbnMub25EZWxldGU9J1NFVCZuYnNwO05VTEx8Q0FTQ0FERSddIFNFVCBOVUxMIGlmIGZvcmVpZ25LZXkgYWxsb3dzIG51bGxzLCBDQVNDQURFIGlmIG90aGVyd2lzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgIFtvcHRpb25zLm9uVXBkYXRlPSdDQVNDQURFJ10gU2V0IGBPTiBVUERBVEVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMuY29uc3RyYWludHM9dHJ1ZV0gU2hvdWxkIG9uIHVwZGF0ZSBhbmQgb24gZGVsZXRlIGNvbnN0cmFpbnRzIGJlIGVuYWJsZWQgb24gdGhlIGZvcmVpZ24ga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7SGFzTWFueX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogVXNlci5oYXNNYW55KFByb2ZpbGUpIC8vIFRoaXMgd2lsbCBhZGQgdXNlcklkIHRvIHRoZSBwcm9maWxlIHRhYmxlXG4gICAqL1xuICBzdGF0aWMgaGFzTWFueSh0YXJnZXQsIG9wdGlvbnMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIE46TSBhc3NvY2lhdGlvbiB3aXRoIGEgam9pbiB0YWJsZS4gRGVmaW5pbmcgYHRocm91Z2hgIGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgICAgIHRhcmdldCBUYXJnZXQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICBvcHRpb25zIGJlbG9uZ3NUb01hbnkgYXNzb2NpYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLmhvb2tzPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBydW4gYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3Mgd2hlbiBhbiBhc3NvY2lhdGVkIG1vZGVsIGlzIGRlbGV0ZWQgYmVjYXVzZSBvZiBhIGNhc2NhZGUuIEZvciBleGFtcGxlIGlmIGBVc2VyLmhhc09uZShQcm9maWxlLCB7b25EZWxldGU6ICdjYXNjYWRlJywgaG9va3M6dHJ1ZX0pYCwgdGhlIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIGZvciBwcm9maWxlIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGlzIGRlbGV0ZWQuIE90aGVyd2lzZSB0aGUgcHJvZmlsZSB3aWxsIGJlIGRlbGV0ZWQgd2l0aG91dCBpbnZva2luZyBhbnkgaG9va3NcbiAgICogQHBhcmFtIHtNb2RlbHxzdHJpbmd8b2JqZWN0fSBvcHRpb25zLnRocm91Z2ggVGhlIG5hbWUgb2YgdGhlIHRhYmxlIHRoYXQgaXMgdXNlZCB0byBqb2luIHNvdXJjZSBhbmQgdGFyZ2V0IGluIG46bSBhc3NvY2lhdGlvbnMuIENhbiBhbHNvIGJlIGEgc2VxdWVsaXplIG1vZGVsIGlmIHlvdSB3YW50IHRvIGRlZmluZSB0aGUganVuY3Rpb24gdGFibGUgeW91cnNlbGYgYW5kIGFkZCBleHRyYSBhdHRyaWJ1dGVzIHRvIGl0LlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgICAgIFtvcHRpb25zLnRocm91Z2gubW9kZWxdIFRoZSBtb2RlbCB1c2VkIHRvIGpvaW4gYm90aCBzaWRlcyBvZiB0aGUgTjpNIGFzc29jaWF0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zLnRocm91Z2guc2NvcGVdIEEga2V5L3ZhbHVlIHNldCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXNzb2NpYXRpb24gY3JlYXRlIGFuZCBmaW5kIGRlZmF1bHRzIG9uIHRoZSB0aHJvdWdoIG1vZGVsLiAoUmVtZW1iZXIgdG8gYWRkIHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSB0aHJvdWdoIG1vZGVsKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLnRocm91Z2gudW5pcXVlPXRydWVdIElmIHRydWUgYSB1bmlxdWUga2V5IHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20gdGhlIGZvcmVpZ24ga2V5cyB1c2VkIChtaWdodCB3YW50IHRvIHR1cm4gdGhpcyBvZmYgYW5kIGNyZWF0ZSBzcGVjaWZpYyB1bmlxdWUga2V5cyB3aGVuIHVzaW5nIHNjb3BlcylcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICBbb3B0aW9ucy5hc10gVGhlIGFsaWFzIG9mIHRoaXMgYXNzb2NpYXRpb24uIElmIHlvdSBwcm92aWRlIGEgc3RyaW5nLCBpdCBzaG91bGQgYmUgcGx1cmFsLCBhbmQgd2lsbCBiZSBzaW5ndWxhcml6ZWQgdXNpbmcgbm9kZS5pbmZsZWN0aW9uLiBJZiB5b3Ugd2FudCB0byBjb250cm9sIHRoZSBzaW5ndWxhciB2ZXJzaW9uIHlvdXJzZWxmLCBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGBwbHVyYWxgIGFuZCBgc2luZ3VsYXJgIGtleXMuIFNlZSBhbHNvIHRoZSBgbmFtZWAgb3B0aW9uIHBhc3NlZCB0byBgc2VxdWVsaXplLmRlZmluZWAuIElmIHlvdSBjcmVhdGUgbXVsdGlwbGUgYXNzb2NpYXRpb25zIGJldHdlZW4gdGhlIHNhbWUgdGFibGVzLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYW4gYWxpYXMgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZW0uIElmIHlvdSBwcm92aWRlIGFuIGFsaWFzIHdoZW4gY3JlYXRpbmcgdGhlIGFzc29jaWF0aW9uLCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIHNhbWUgYWxpYXMgd2hlbiBlYWdlciBsb2FkaW5nIGFuZCB3aGVuIGdldHRpbmcgYXNzb2NpYXRlZCBtb2RlbHMuIERlZmF1bHRzIHRvIHRoZSBwbHVyYWxpemVkIG5hbWUgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgW29wdGlvbnMuZm9yZWlnbktleV0gVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGluIHRoZSBqb2luIHRhYmxlIChyZXByZXNlbnRpbmcgdGhlIHNvdXJjZSBtb2RlbCkgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciB0aGUgZm9yZWlnbiBjb2x1bW4gKHNlZSBgU2VxdWVsaXplLmRlZmluZWAgZm9yIHN5bnRheCkuIFdoZW4gdXNpbmcgYW4gb2JqZWN0LCB5b3UgY2FuIGFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbi4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2Ygc291cmNlICsgcHJpbWFyeSBrZXkgb2Ygc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgW29wdGlvbnMub3RoZXJLZXldIFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBpbiB0aGUgam9pbiB0YWJsZSAocmVwcmVzZW50aW5nIHRoZSB0YXJnZXQgbW9kZWwpIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIG90aGVyIGNvbHVtbiAoc2VlIGBTZXF1ZWxpemUuZGVmaW5lYCBmb3Igc3ludGF4KS4gV2hlbiB1c2luZyBhbiBvYmplY3QsIHlvdSBjYW4gYWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uLiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiB0YXJnZXQgKyBwcmltYXJ5IGtleSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9ucy5zY29wZV0gQSBrZXkvdmFsdWUgc2V0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhc3NvY2lhdGlvbiBjcmVhdGUgYW5kIGZpbmQgZGVmYXVsdHMgb24gdGhlIHRhcmdldC4gKHNxbGl0ZSBub3Qgc3VwcG9ydGVkIGZvciBOOk0pXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMudGltZXN0YW1wcz1zZXF1ZWxpemUub3B0aW9ucy50aW1lc3RhbXBzXSBTaG91bGQgdGhlIGpvaW4gbW9kZWwgaGF2ZSB0aW1lc3RhbXBzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgW29wdGlvbnMub25EZWxldGU9J1NFVCZuYnNwO05VTEx8Q0FTQ0FERSddIENhc2NhZGUgaWYgdGhpcyBpcyBhIG46bSwgYW5kIHNldCBudWxsIGlmIGl0IGlzIGEgMTptXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgW29wdGlvbnMub25VcGRhdGU9J0NBU0NBREUnXSBTZXRzIGBPTiBVUERBVEVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMuY29uc3RyYWludHM9dHJ1ZV0gU2hvdWxkIG9uIHVwZGF0ZSBhbmQgb24gZGVsZXRlIGNvbnN0cmFpbnRzIGJlIGVuYWJsZWQgb24gdGhlIGZvcmVpZ24ga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QmVsb25nc1RvTWFueX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQXV0b21hZ2ljYWxseSBnZW5lcmF0ZWQgam9pbiBtb2RlbFxuICAgKiBVc2VyLmJlbG9uZ3NUb01hbnkoUHJvamVjdCwgeyB0aHJvdWdoOiAnVXNlclByb2plY3RzJyB9KVxuICAgKiBQcm9qZWN0LmJlbG9uZ3NUb01hbnkoVXNlciwgeyB0aHJvdWdoOiAnVXNlclByb2plY3RzJyB9KVxuICAgKlxuICAgKiAvLyBKb2luIG1vZGVsIHdpdGggYWRkaXRpb25hbCBhdHRyaWJ1dGVzXG4gICAqIGNvbnN0IFVzZXJQcm9qZWN0cyA9IHNlcXVlbGl6ZS5kZWZpbmUoJ1VzZXJQcm9qZWN0cycsIHtcbiAgICogICBzdGFydGVkOiBTZXF1ZWxpemUuQk9PTEVBTlxuICAgKiB9KVxuICAgKiBVc2VyLmJlbG9uZ3NUb01hbnkoUHJvamVjdCwgeyB0aHJvdWdoOiBVc2VyUHJvamVjdHMgfSlcbiAgICogUHJvamVjdC5iZWxvbmdzVG9NYW55KFVzZXIsIHsgdGhyb3VnaDogVXNlclByb2plY3RzIH0pXG4gICAqL1xuICBzdGF0aWMgYmVsb25nc1RvTWFueSh0YXJnZXQsIG9wdGlvbnMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3NvY2lhdGlvbiBiZXR3ZWVuIHRoaXMgKHRoZSBzb3VyY2UpIGFuZCB0aGUgcHJvdmlkZWQgdGFyZ2V0LiBUaGUgZm9yZWlnbiBrZXkgaXMgYWRkZWQgb24gdGhlIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgIHRhcmdldCBUYXJnZXQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zXSBoYXNPbmUgYXNzb2NpYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaG9va3M9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHJ1biBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyB3aGVuIGFuIGFzc29jaWF0ZWQgbW9kZWwgaXMgZGVsZXRlZCBiZWNhdXNlIG9mIGEgY2FzY2FkZS4gRm9yIGV4YW1wbGUgaWYgYFVzZXIuaGFzT25lKFByb2ZpbGUsIHtvbkRlbGV0ZTogJ2Nhc2NhZGUnLCBob29rczp0cnVlfSlgLCB0aGUgYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3MgZm9yIHByb2ZpbGUgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgaXMgZGVsZXRlZC4gT3RoZXJ3aXNlIHRoZSBwcm9maWxlIHdpbGwgYmUgZGVsZXRlZCB3aXRob3V0IGludm9raW5nIGFueSBob29rc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMuYXNdIFRoZSBhbGlhcyBvZiB0aGlzIG1vZGVsLCBpbiBzaW5ndWxhciBmb3JtLiBTZWUgYWxzbyB0aGUgYG5hbWVgIG9wdGlvbiBwYXNzZWQgdG8gYHNlcXVlbGl6ZS5kZWZpbmVgLiBJZiB5b3UgY3JlYXRlIG11bHRpcGxlIGFzc29jaWF0aW9ucyBiZXR3ZWVuIHRoZSBzYW1lIHRhYmxlcywgeW91IHNob3VsZCBwcm92aWRlIGFuIGFsaWFzIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtLiBJZiB5b3UgcHJvdmlkZSBhbiBhbGlhcyB3aGVuIGNyZWF0aW5nIHRoZSBhc3NvY2lhdGlvbiwgeW91IHNob3VsZCBwcm92aWRlIHRoZSBzYW1lIGFsaWFzIHdoZW4gZWFnZXIgbG9hZGluZyBhbmQgd2hlbiBnZXR0aW5nIGFzc29jaWF0ZWQgbW9kZWxzLiBEZWZhdWx0cyB0byB0aGUgc2luZ3VsYXJpemVkIG5hbWUgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICBbb3B0aW9ucy5mb3JlaWduS2V5XSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgYXR0cmlidXRlIGluIHRoZSB0YXJnZXQgbW9kZWwgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciB0aGUgZm9yZWlnbiBjb2x1bW4gKHNlZSBgU2VxdWVsaXplLmRlZmluZWAgZm9yIHN5bnRheCkuIFdoZW4gdXNpbmcgYW4gb2JqZWN0LCB5b3UgY2FuIGFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbi4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2Ygc291cmNlICsgcHJpbWFyeSBrZXkgb2Ygc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5zb3VyY2VLZXldIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gdXNlIGFzIHRoZSBrZXkgZm9yIHRoZSBhc3NvY2lhdGlvbiBpbiB0aGUgc291cmNlIHRhYmxlLiBEZWZhdWx0cyB0byB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIHNvdXJjZSB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMub25EZWxldGU9J1NFVCZuYnNwO05VTEx8Q0FTQ0FERSddIFNFVCBOVUxMIGlmIGZvcmVpZ25LZXkgYWxsb3dzIG51bGxzLCBDQVNDQURFIGlmIG90aGVyd2lzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMub25VcGRhdGU9J0NBU0NBREUnXSBTZXRzICdPTiBVUERBVEUnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5jb25zdHJhaW50cz10cnVlXSBTaG91bGQgb24gdXBkYXRlIGFuZCBvbiBkZWxldGUgY29uc3RyYWludHMgYmUgZW5hYmxlZCBvbiB0aGUgZm9yZWlnbiBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy51bmlxdWVLZXldIFRoZSBjdXN0b20gbmFtZSBmb3IgdW5pcXVlIGNvbnN0cmFpbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtIYXNPbmV9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFVzZXIuaGFzT25lKFByb2ZpbGUpIC8vIFRoaXMgd2lsbCBhZGQgdXNlcklkIHRvIHRoZSBwcm9maWxlIHRhYmxlXG4gICAqL1xuICBzdGF0aWMgaGFzT25lKHRhcmdldCwgb3B0aW9ucykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzc29jaWF0aW9uIGJldHdlZW4gdGhpcyAodGhlIHNvdXJjZSkgYW5kIHRoZSBwcm92aWRlZCB0YXJnZXQuIFRoZSBmb3JlaWduIGtleSBpcyBhZGRlZCBvbiB0aGUgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgdGFyZ2V0IFRoZSB0YXJnZXQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zXSBiZWxvbmdzVG8gYXNzb2NpYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaG9va3M9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHJ1biBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyB3aGVuIGFuIGFzc29jaWF0ZWQgbW9kZWwgaXMgZGVsZXRlZCBiZWNhdXNlIG9mIGEgY2FzY2FkZS4gRm9yIGV4YW1wbGUgaWYgYFVzZXIuaGFzT25lKFByb2ZpbGUsIHtvbkRlbGV0ZTogJ2Nhc2NhZGUnLCBob29rczp0cnVlfSlgLCB0aGUgYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3MgZm9yIHByb2ZpbGUgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgaXMgZGVsZXRlZC4gT3RoZXJ3aXNlIHRoZSBwcm9maWxlIHdpbGwgYmUgZGVsZXRlZCB3aXRob3V0IGludm9raW5nIGFueSBob29rc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMuYXNdIFRoZSBhbGlhcyBvZiB0aGlzIG1vZGVsLCBpbiBzaW5ndWxhciBmb3JtLiBTZWUgYWxzbyB0aGUgYG5hbWVgIG9wdGlvbiBwYXNzZWQgdG8gYHNlcXVlbGl6ZS5kZWZpbmVgLiBJZiB5b3UgY3JlYXRlIG11bHRpcGxlIGFzc29jaWF0aW9ucyBiZXR3ZWVuIHRoZSBzYW1lIHRhYmxlcywgeW91IHNob3VsZCBwcm92aWRlIGFuIGFsaWFzIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtLiBJZiB5b3UgcHJvdmlkZSBhbiBhbGlhcyB3aGVuIGNyZWF0aW5nIHRoZSBhc3NvY2lhdGlvbiwgeW91IHNob3VsZCBwcm92aWRlIHRoZSBzYW1lIGFsaWFzIHdoZW4gZWFnZXIgbG9hZGluZyBhbmQgd2hlbiBnZXR0aW5nIGFzc29jaWF0ZWQgbW9kZWxzLiBEZWZhdWx0cyB0byB0aGUgc2luZ3VsYXJpemVkIG5hbWUgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICBbb3B0aW9ucy5mb3JlaWduS2V5XSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgYXR0cmlidXRlIGluIHRoZSBzb3VyY2UgdGFibGUgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciB0aGUgZm9yZWlnbiBjb2x1bW4gKHNlZSBgU2VxdWVsaXplLmRlZmluZWAgZm9yIHN5bnRheCkuIFdoZW4gdXNpbmcgYW4gb2JqZWN0LCB5b3UgY2FuIGFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbi4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgdGFyZ2V0ICsgcHJpbWFyeSBrZXkgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy50YXJnZXRLZXldIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gdXNlIGFzIHRoZSBrZXkgZm9yIHRoZSBhc3NvY2lhdGlvbiBpbiB0aGUgdGFyZ2V0IHRhYmxlLiBEZWZhdWx0cyB0byB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIHRhcmdldCB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMub25EZWxldGU9J1NFVCZuYnNwO05VTEx8Tk8mbmJzcDtBQ1RJT04nXSBTRVQgTlVMTCBpZiBmb3JlaWduS2V5IGFsbG93cyBudWxscywgTk8gQUNUSU9OIGlmIG90aGVyd2lzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMub25VcGRhdGU9J0NBU0NBREUnXSBTZXRzICdPTiBVUERBVEUnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5jb25zdHJhaW50cz10cnVlXSBTaG91bGQgb24gdXBkYXRlIGFuZCBvbiBkZWxldGUgY29uc3RyYWludHMgYmUgZW5hYmxlZCBvbiB0aGUgZm9yZWlnbiBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCZWxvbmdzVG99XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFByb2ZpbGUuYmVsb25nc1RvKFVzZXIpIC8vIFRoaXMgd2lsbCBhZGQgdXNlcklkIHRvIHRoZSBwcm9maWxlIHRhYmxlXG4gICAqL1xuICBzdGF0aWMgYmVsb25nc1RvKHRhcmdldCwgb3B0aW9ucykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuXG5PYmplY3QuYXNzaWduKE1vZGVsLCBhc3NvY2lhdGlvbnNNaXhpbik7XG5Ib29rcy5hcHBseVRvKE1vZGVsLCB0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcbiIsIlxuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBPcGVyYXRvciBzeW1ib2xzIHRvIGJlIHVzZWQgd2hlbiBxdWVyeWluZyBkYXRhXG4gKlxuICogQHNlZSB7QGxpbmsgTW9kZWwjd2hlcmV9XG4gKlxuICogQHByb3BlcnR5IGVxXG4gKiBAcHJvcGVydHkgbmVcbiAqIEBwcm9wZXJ0eSBndGVcbiAqIEBwcm9wZXJ0eSBndFxuICogQHByb3BlcnR5IGx0ZVxuICogQHByb3BlcnR5IGx0XG4gKiBAcHJvcGVydHkgbm90XG4gKiBAcHJvcGVydHkgaXNcbiAqIEBwcm9wZXJ0eSBpblxuICogQHByb3BlcnR5IG5vdEluXG4gKiBAcHJvcGVydHkgbGlrZVxuICogQHByb3BlcnR5IG5vdExpa2VcbiAqIEBwcm9wZXJ0eSBpTGlrZVxuICogQHByb3BlcnR5IG5vdElMaWtlXG4gKiBAcHJvcGVydHkgc3RhcnRzV2l0aFxuICogQHByb3BlcnR5IGVuZHNXaXRoXG4gKiBAcHJvcGVydHkgc3Vic3RyaW5nXG4gKiBAcHJvcGVydHkgcmVnZXhwXG4gKiBAcHJvcGVydHkgbm90UmVnZXhwXG4gKiBAcHJvcGVydHkgaVJlZ2V4cFxuICogQHByb3BlcnR5IG5vdElSZWdleHBcbiAqIEBwcm9wZXJ0eSBiZXR3ZWVuXG4gKiBAcHJvcGVydHkgbm90QmV0d2VlblxuICogQHByb3BlcnR5IG92ZXJsYXBcbiAqIEBwcm9wZXJ0eSBjb250YWluc1xuICogQHByb3BlcnR5IGNvbnRhaW5lZFxuICogQHByb3BlcnR5IGFkamFjZW50XG4gKiBAcHJvcGVydHkgc3RyaWN0TGVmdFxuICogQHByb3BlcnR5IHN0cmljdFJpZ2h0XG4gKiBAcHJvcGVydHkgbm9FeHRlbmRSaWdodFxuICogQHByb3BlcnR5IG5vRXh0ZW5kTGVmdFxuICogQHByb3BlcnR5IGFuZFxuICogQHByb3BlcnR5IG9yXG4gKiBAcHJvcGVydHkgYW55XG4gKiBAcHJvcGVydHkgYWxsXG4gKiBAcHJvcGVydHkgdmFsdWVzXG4gKiBAcHJvcGVydHkgY29sXG4gKiBAcHJvcGVydHkgcGxhY2Vob2xkZXJcbiAqIEBwcm9wZXJ0eSBqb2luXG4gKi9cbmNvbnN0IE9wID0ge1xuICBlcTogU3ltYm9sLmZvcignZXEnKSxcbiAgbmU6IFN5bWJvbC5mb3IoJ25lJyksXG4gIGd0ZTogU3ltYm9sLmZvcignZ3RlJyksXG4gIGd0OiBTeW1ib2wuZm9yKCdndCcpLFxuICBsdGU6IFN5bWJvbC5mb3IoJ2x0ZScpLFxuICBsdDogU3ltYm9sLmZvcignbHQnKSxcbiAgbm90OiBTeW1ib2wuZm9yKCdub3QnKSxcbiAgaXM6IFN5bWJvbC5mb3IoJ2lzJyksXG4gIGluOiBTeW1ib2wuZm9yKCdpbicpLFxuICBub3RJbjogU3ltYm9sLmZvcignbm90SW4nKSxcbiAgbGlrZTogU3ltYm9sLmZvcignbGlrZScpLFxuICBub3RMaWtlOiBTeW1ib2wuZm9yKCdub3RMaWtlJyksXG4gIGlMaWtlOiBTeW1ib2wuZm9yKCdpTGlrZScpLFxuICBub3RJTGlrZTogU3ltYm9sLmZvcignbm90SUxpa2UnKSxcbiAgc3RhcnRzV2l0aDogU3ltYm9sLmZvcignc3RhcnRzV2l0aCcpLFxuICBlbmRzV2l0aDogU3ltYm9sLmZvcignZW5kc1dpdGgnKSxcbiAgc3Vic3RyaW5nOiBTeW1ib2wuZm9yKCdzdWJzdHJpbmcnKSxcbiAgcmVnZXhwOiBTeW1ib2wuZm9yKCdyZWdleHAnKSxcbiAgbm90UmVnZXhwOiBTeW1ib2wuZm9yKCdub3RSZWdleHAnKSxcbiAgaVJlZ2V4cDogU3ltYm9sLmZvcignaVJlZ2V4cCcpLFxuICBub3RJUmVnZXhwOiBTeW1ib2wuZm9yKCdub3RJUmVnZXhwJyksXG4gIGJldHdlZW46IFN5bWJvbC5mb3IoJ2JldHdlZW4nKSxcbiAgbm90QmV0d2VlbjogU3ltYm9sLmZvcignbm90QmV0d2VlbicpLFxuICBvdmVybGFwOiBTeW1ib2wuZm9yKCdvdmVybGFwJyksXG4gIGNvbnRhaW5zOiBTeW1ib2wuZm9yKCdjb250YWlucycpLFxuICBjb250YWluZWQ6IFN5bWJvbC5mb3IoJ2NvbnRhaW5lZCcpLFxuICBhZGphY2VudDogU3ltYm9sLmZvcignYWRqYWNlbnQnKSxcbiAgc3RyaWN0TGVmdDogU3ltYm9sLmZvcignc3RyaWN0TGVmdCcpLFxuICBzdHJpY3RSaWdodDogU3ltYm9sLmZvcignc3RyaWN0UmlnaHQnKSxcbiAgbm9FeHRlbmRSaWdodDogU3ltYm9sLmZvcignbm9FeHRlbmRSaWdodCcpLFxuICBub0V4dGVuZExlZnQ6IFN5bWJvbC5mb3IoJ25vRXh0ZW5kTGVmdCcpLFxuICBhbmQ6IFN5bWJvbC5mb3IoJ2FuZCcpLFxuICBvcjogU3ltYm9sLmZvcignb3InKSxcbiAgYW55OiBTeW1ib2wuZm9yKCdhbnknKSxcbiAgYWxsOiBTeW1ib2wuZm9yKCdhbGwnKSxcbiAgdmFsdWVzOiBTeW1ib2wuZm9yKCd2YWx1ZXMnKSxcbiAgY29sOiBTeW1ib2wuZm9yKCdjb2wnKSxcbiAgcGxhY2Vob2xkZXI6IFN5bWJvbC5mb3IoJ3BsYWNlaG9sZGVyJyksXG4gIGpvaW46IFN5bWJvbC5mb3IoJ2pvaW4nKSxcbiAgbWF0Y2g6IFN5bWJvbC5mb3IoJ21hdGNoJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3A7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gZW51bSBvZiBxdWVyeSB0eXBlcyB1c2VkIGJ5IGBzZXF1ZWxpemUucXVlcnlgXG4gKlxuICogQHNlZSB7QGxpbmsgU2VxdWVsaXplI3F1ZXJ5fVxuICpcbiAqIEBwcm9wZXJ0eSBTRUxFQ1RcbiAqIEBwcm9wZXJ0eSBJTlNFUlRcbiAqIEBwcm9wZXJ0eSBVUERBVEVcbiAqIEBwcm9wZXJ0eSBCVUxLVVBEQVRFXG4gKiBAcHJvcGVydHkgQlVMS0RFTEVURVxuICogQHByb3BlcnR5IERFTEVURVxuICogQHByb3BlcnR5IFVQU0VSVFxuICogQHByb3BlcnR5IFZFUlNJT05cbiAqIEBwcm9wZXJ0eSBTSE9XVEFCTEVTXG4gKiBAcHJvcGVydHkgU0hPV0lOREVYRVNcbiAqIEBwcm9wZXJ0eSBERVNDUklCRVxuICogQHByb3BlcnR5IFJBV1xuICogQHByb3BlcnR5IEZPUkVJR05LRVlTXG4gKiBAcHJvcGVydHkgU0hPV0NPTlNUUkFJTlRTXG4gKi9cbmNvbnN0IFF1ZXJ5VHlwZXMgPSBtb2R1bGUuZXhwb3J0cyA9IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBTRUxFQ1Q6ICdTRUxFQ1QnLFxuICBJTlNFUlQ6ICdJTlNFUlQnLFxuICBVUERBVEU6ICdVUERBVEUnLFxuICBCVUxLVVBEQVRFOiAnQlVMS1VQREFURScsXG4gIEJVTEtERUxFVEU6ICdCVUxLREVMRVRFJyxcbiAgREVMRVRFOiAnREVMRVRFJyxcbiAgVVBTRVJUOiAnVVBTRVJUJyxcbiAgVkVSU0lPTjogJ1ZFUlNJT04nLFxuICBTSE9XVEFCTEVTOiAnU0hPV1RBQkxFUycsXG4gIFNIT1dJTkRFWEVTOiAnU0hPV0lOREVYRVMnLFxuICBERVNDUklCRTogJ0RFU0NSSUJFJyxcbiAgUkFXOiAnUkFXJyxcbiAgRk9SRUlHTktFWVM6ICdGT1JFSUdOS0VZUycsXG4gIFNIT1dDT05TVFJBSU5UUzogJ1NIT1dDT05TVFJBSU5UUydcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHJldHJ5ID0gcmVxdWlyZSgncmV0cnktYXMtcHJvbWlzZWQnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgRGVmZXJyYWJsZSA9IHJlcXVpcmUoJy4vZGVmZXJyYWJsZScpO1xuY29uc3QgTW9kZWxNYW5hZ2VyID0gcmVxdWlyZSgnLi9tb2RlbC1tYW5hZ2VyJyk7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBUYWJsZUhpbnRzID0gcmVxdWlyZSgnLi90YWJsZS1oaW50cycpO1xuY29uc3QgSW5kZXhIaW50cyA9IHJlcXVpcmUoJy4vaW5kZXgtaGludHMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBIb29rcyA9IHJlcXVpcmUoJy4vaG9va3MnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvaW5kZXgnKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhcycpLnZhbGlkYXRvcjtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMnKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvZGVwcmVjYXRpb25zJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBjbGFzcywgdGhlIGVudHJ5IHBvaW50IHRvIHNlcXVlbGl6ZS5cbiAqL1xuY2xhc3MgU2VxdWVsaXplIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIHNlcXVlbGl6ZSB3aXRoIG5hbWUgb2YgZGF0YWJhc2UsIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gd2l0aG91dCBwYXNzd29yZCAvIHdpdGggYmxhbmsgcGFzc3dvcmRcbiAgICogY29uc3Qgc2VxdWVsaXplID0gbmV3IFNlcXVlbGl6ZSgnZGF0YWJhc2UnLCAndXNlcm5hbWUnLCBudWxsLCB7XG4gICAqICAgZGlhbGVjdDogJ215c3FsJ1xuICAgKiB9KVxuICAgKlxuICAgKiAvLyB3aXRoIHBhc3N3b3JkIGFuZCBvcHRpb25zXG4gICAqIGNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoJ215X2RhdGFiYXNlJywgJ2pvaG4nLCAnZG9lJywge1xuICAgKiAgIGRpYWxlY3Q6ICdwb3N0Z3JlcydcbiAgICogfSlcbiAgICpcbiAgICogLy8gd2l0aCBkYXRhYmFzZSwgdXNlcm5hbWUsIGFuZCBwYXNzd29yZCBpbiB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICogY29uc3Qgc2VxdWVsaXplID0gbmV3IFNlcXVlbGl6ZSh7IGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQsIGRpYWxlY3Q6ICdtc3NxbCcgfSk7XG4gICAqXG4gICAqIC8vIHdpdGggdXJpXG4gICAqIGNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoJ215c3FsOi8vbG9jYWxob3N0OjMzMDYvZGF0YWJhc2UnLCB7fSlcbiAgICpcbiAgICogLy8gb3B0aW9uIGV4YW1wbGVzXG4gICAqIGNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoJ2RhdGFiYXNlJywgJ3VzZXJuYW1lJywgJ3Bhc3N3b3JkJywge1xuICAgKiAgIC8vIHRoZSBzcWwgZGlhbGVjdCBvZiB0aGUgZGF0YWJhc2VcbiAgICogICAvLyBjdXJyZW50bHkgc3VwcG9ydGVkOiAnbXlzcWwnLCAnc3FsaXRlJywgJ3Bvc3RncmVzJywgJ21zc3FsJ1xuICAgKiAgIGRpYWxlY3Q6ICdteXNxbCcsXG4gICAqXG4gICAqICAgLy8gY3VzdG9tIGhvc3Q7IGRlZmF1bHQ6IGxvY2FsaG9zdFxuICAgKiAgIGhvc3Q6ICdteS5zZXJ2ZXIudGxkJyxcbiAgICogICAvLyBmb3IgcG9zdGdyZXMsIHlvdSBjYW4gYWxzbyBzcGVjaWZ5IGFuIGFic29sdXRlIHBhdGggdG8gYSBkaXJlY3RvcnlcbiAgICogICAvLyBjb250YWluaW5nIGEgVU5JWCBzb2NrZXQgdG8gY29ubmVjdCBvdmVyXG4gICAqICAgLy8gaG9zdDogJy9zb2NrZXRzL3BzcWxfc29ja2V0cycuXG4gICAqXG4gICAqICAgLy8gY3VzdG9tIHBvcnQ7IGRlZmF1bHQ6IGRpYWxlY3QgZGVmYXVsdFxuICAgKiAgIHBvcnQ6IDEyMzQ1LFxuICAgKlxuICAgKiAgIC8vIGN1c3RvbSBwcm90b2NvbDsgZGVmYXVsdDogJ3RjcCdcbiAgICogICAvLyBwb3N0Z3JlcyBvbmx5LCB1c2VmdWwgZm9yIEhlcm9rdVxuICAgKiAgIHByb3RvY29sOiBudWxsLFxuICAgKlxuICAgKiAgIC8vIGRpc2FibGUgbG9nZ2luZyBvciBwcm92aWRlIGEgY3VzdG9tIGxvZ2dpbmcgZnVuY3Rpb247IGRlZmF1bHQ6IGNvbnNvbGUubG9nXG4gICAqICAgbG9nZ2luZzogZmFsc2UsXG4gICAqXG4gICAqICAgLy8geW91IGNhbiBhbHNvIHBhc3MgYW55IGRpYWxlY3Qgb3B0aW9ucyB0byB0aGUgdW5kZXJseWluZyBkaWFsZWN0IGxpYnJhcnlcbiAgICogICAvLyAtIGRlZmF1bHQgaXMgZW1wdHlcbiAgICogICAvLyAtIGN1cnJlbnRseSBzdXBwb3J0ZWQ6ICdteXNxbCcsICdwb3N0Z3JlcycsICdtc3NxbCdcbiAgICogICBkaWFsZWN0T3B0aW9uczoge1xuICAgKiAgICAgc29ja2V0UGF0aDogJy9BcHBsaWNhdGlvbnMvTUFNUC90bXAvbXlzcWwvbXlzcWwuc29jaycsXG4gICAqICAgICBzdXBwb3J0QmlnTnVtYmVyczogdHJ1ZSxcbiAgICogICAgIGJpZ051bWJlclN0cmluZ3M6IHRydWVcbiAgICogICB9LFxuICAgKlxuICAgKiAgIC8vIHRoZSBzdG9yYWdlIGVuZ2luZSBmb3Igc3FsaXRlXG4gICAqICAgLy8gLSBkZWZhdWx0ICc6bWVtb3J5OidcbiAgICogICBzdG9yYWdlOiAncGF0aC90by9kYXRhYmFzZS5zcWxpdGUnLFxuICAgKlxuICAgKiAgIC8vIGRpc2FibGUgaW5zZXJ0aW5nIHVuZGVmaW5lZCB2YWx1ZXMgYXMgTlVMTFxuICAgKiAgIC8vIC0gZGVmYXVsdDogZmFsc2VcbiAgICogICBvbWl0TnVsbDogdHJ1ZSxcbiAgICpcbiAgICogICAvLyBhIGZsYWcgZm9yIHVzaW5nIGEgbmF0aXZlIGxpYnJhcnkgb3Igbm90LlxuICAgKiAgIC8vIGluIHRoZSBjYXNlIG9mICdwZycgLS0gc2V0IHRoaXMgdG8gdHJ1ZSB3aWxsIGFsbG93IFNTTCBzdXBwb3J0XG4gICAqICAgLy8gLSBkZWZhdWx0OiBmYWxzZVxuICAgKiAgIG5hdGl2ZTogdHJ1ZSxcbiAgICpcbiAgICogICAvLyBTcGVjaWZ5IG9wdGlvbnMsIHdoaWNoIGFyZSB1c2VkIHdoZW4gc2VxdWVsaXplLmRlZmluZSBpcyBjYWxsZWQuXG4gICAqICAgLy8gVGhlIGZvbGxvd2luZyBleGFtcGxlOlxuICAgKiAgIC8vICAgZGVmaW5lOiB7IHRpbWVzdGFtcHM6IGZhbHNlIH1cbiAgICogICAvLyBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXM6XG4gICAqICAgLy8gICBNb2RlbC5pbml0KGF0dHJpYnV0ZXMsIHsgdGltZXN0YW1wczogZmFsc2UgfSk7XG4gICAqICAgLy8gICBzZXF1ZWxpemUuZGVmaW5lKG5hbWUsIGF0dHJpYnV0ZXMsIHsgdGltZXN0YW1wczogZmFsc2UgfSk7XG4gICAqICAgLy8gc28gZGVmaW5pbmcgdGhlIHRpbWVzdGFtcHMgZm9yIGVhY2ggbW9kZWwgd2lsbCBiZSBub3QgbmVjZXNzYXJ5XG4gICAqICAgZGVmaW5lOiB7XG4gICAqICAgICB1bmRlcnNjb3JlZDogZmFsc2UsXG4gICAqICAgICBmcmVlemVUYWJsZU5hbWU6IGZhbHNlLFxuICAgKiAgICAgY2hhcnNldDogJ3V0ZjgnLFxuICAgKiAgICAgZGlhbGVjdE9wdGlvbnM6IHtcbiAgICogICAgICAgY29sbGF0ZTogJ3V0ZjhfZ2VuZXJhbF9jaSdcbiAgICogICAgIH0sXG4gICAqICAgICB0aW1lc3RhbXBzOiB0cnVlXG4gICAqICAgfSxcbiAgICpcbiAgICogICAvLyBzaW1pbGFyIGZvciBzeW5jOiB5b3UgY2FuIGRlZmluZSB0aGlzIHRvIGFsd2F5cyBmb3JjZSBzeW5jIGZvciBtb2RlbHNcbiAgICogICBzeW5jOiB7IGZvcmNlOiB0cnVlIH0sXG4gICAqXG4gICAqICAgLy8gcG9vbCBjb25maWd1cmF0aW9uIHVzZWQgdG8gcG9vbCBkYXRhYmFzZSBjb25uZWN0aW9uc1xuICAgKiAgIHBvb2w6IHtcbiAgICogICAgIG1heDogNSxcbiAgICogICAgIGlkbGU6IDMwMDAwLFxuICAgKiAgICAgYWNxdWlyZTogNjAwMDAsXG4gICAqICAgfSxcbiAgICpcbiAgICogICAvLyBpc29sYXRpb24gbGV2ZWwgb2YgZWFjaCB0cmFuc2FjdGlvblxuICAgKiAgIC8vIGRlZmF1bHRzIHRvIGRpYWxlY3QgZGVmYXVsdFxuICAgKiAgIGlzb2xhdGlvbkxldmVsOiBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFUEVBVEFCTEVfUkVBRFxuICAgKiB9KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbZGF0YWJhc2VdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbdXNlcm5hbWU9bnVsbF0gVGhlIHVzZXJuYW1lIHdoaWNoIGlzIHVzZWQgdG8gYXV0aGVudGljYXRlIGFnYWluc3QgdGhlIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbcGFzc3dvcmQ9bnVsbF0gVGhlIHBhc3N3b3JkIHdoaWNoIGlzIHVzZWQgdG8gYXV0aGVudGljYXRlIGFnYWluc3QgdGhlIGRhdGFiYXNlLiBTdXBwb3J0cyBTUUxDaXBoZXIgZW5jcnlwdGlvbiBmb3IgU1FMaXRlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuaG9zdD0nbG9jYWxob3N0J10gVGhlIGhvc3Qgb2YgdGhlIHJlbGF0aW9uYWwgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvcnQ9XSBUaGUgcG9ydCBvZiB0aGUgcmVsYXRpb25hbCBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMudXNlcm5hbWU9bnVsbF0gVGhlIHVzZXJuYW1lIHdoaWNoIGlzIHVzZWQgdG8gYXV0aGVudGljYXRlIGFnYWluc3QgdGhlIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5wYXNzd29yZD1udWxsXSBUaGUgcGFzc3dvcmQgd2hpY2ggaXMgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCB0aGUgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmRhdGFiYXNlPW51bGxdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5kaWFsZWN0XSBUaGUgZGlhbGVjdCBvZiB0aGUgZGF0YWJhc2UgeW91IGFyZSBjb25uZWN0aW5nIHRvLiBPbmUgb2YgbXlzcWwsIHBvc3RncmVzLCBzcWxpdGUgYW5kIG1zc3FsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5kaWFsZWN0TW9kdWxlPW51bGxdIElmIHNwZWNpZmllZCwgdXNlIHRoaXMgZGlhbGVjdCBsaWJyYXJ5LiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdXNlIHBnLmpzIGluc3RlYWQgb2YgcGcgd2hlbiBjb25uZWN0aW5nIHRvIGEgcGcgZGF0YWJhc2UsIHlvdSBzaG91bGQgc3BlY2lmeSAncmVxdWlyZShcInBnLmpzXCIpJyBoZXJlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmRpYWxlY3RNb2R1bGVQYXRoPW51bGxdIElmIHNwZWNpZmllZCwgbG9hZCB0aGUgZGlhbGVjdCBsaWJyYXJ5IGZyb20gdGhpcyBwYXRoLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdXNlIHBnLmpzIGluc3RlYWQgb2YgcGcgd2hlbiBjb25uZWN0aW5nIHRvIGEgcGcgZGF0YWJhc2UsIHlvdSBzaG91bGQgc3BlY2lmeSAnL3BhdGgvdG8vcGcuanMnIGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuZGlhbGVjdE9wdGlvbnNdIEFuIG9iamVjdCBvZiBhZGRpdGlvbmFsIG9wdGlvbnMsIHdoaWNoIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIGNvbm5lY3Rpb24gbGlicmFyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5zdG9yYWdlXSBPbmx5IHVzZWQgYnkgc3FsaXRlLiBEZWZhdWx0cyB0byAnOm1lbW9yeTonXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnByb3RvY29sPSd0Y3AnXSBUaGUgcHJvdG9jb2wgb2YgdGhlIHJlbGF0aW9uYWwgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLmRlZmluZT17fV0gRGVmYXVsdCBvcHRpb25zIGZvciBtb2RlbCBkZWZpbml0aW9ucy4gU2VlIHtAbGluayBNb2RlbC5pbml0fS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMucXVlcnk9e31dIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VxdWVsaXplLnF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnNjaGVtYT1udWxsXSBBIHNjaGVtYSB0byB1c2VcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuc2V0PXt9XSBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcXVlbGl6ZS5zZXRcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuc3luYz17fV0gRGVmYXVsdCBvcHRpb25zIGZvciBzZXF1ZWxpemUuc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy50aW1lem9uZT0nKzAwOjAwJ10gVGhlIHRpbWV6b25lIHVzZWQgd2hlbiBjb252ZXJ0aW5nIGEgZGF0ZSBmcm9tIHRoZSBkYXRhYmFzZSBpbnRvIGEgSmF2YVNjcmlwdCBkYXRlLiBUaGUgdGltZXpvbmUgaXMgYWxzbyB1c2VkIHRvIFNFVCBUSU1FWk9ORSB3aGVuIGNvbm5lY3RpbmcgdG8gdGhlIHNlcnZlciwgdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBOT1csIENVUlJFTlRfVElNRVNUQU1QIGFuZCBvdGhlciB0aW1lIHJlbGF0ZWQgZnVuY3Rpb25zIGhhdmUgaW4gdGhlIHJpZ2h0IHRpbWV6b25lLiBGb3IgYmVzdCBjcm9zcyBwbGF0Zm9ybSBwZXJmb3JtYW5jZSB1c2UgdGhlIGZvcm1hdCArLy1ISDpNTS4gV2lsbCBhbHNvIGFjY2VwdCBzdHJpbmcgdmVyc2lvbnMgb2YgdGltZXpvbmVzIHVzZWQgYnkgbW9tZW50LmpzIChlLmcuICdBbWVyaWNhL0xvc19BbmdlbGVzJyk7IHRoaXMgaXMgdXNlZnVsIHRvIGNhcHR1cmUgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzPSd3YXJuaW5nJ10gVGhlIFBvc3RncmVTUUwgYGNsaWVudF9taW5fbWVzc2FnZXNgIHNlc3Npb24gcGFyYW1ldGVyLiBTZXQgdG8gYGZhbHNlYCB0byBub3Qgb3ZlcnJpZGUgdGhlIGRhdGFiYXNlJ3MgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5ncz10cnVlXSBUaGUgUG9zdGdyZVNRTCBgc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzYCBzZXNzaW9uIHBhcmFtZXRlci4gU2V0IHRvIGBmYWxzZWAgdG8gbm90IHNldCB0aGUgb3B0aW9uLiBXQVJOSU5HOiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgbWF5IGV4cG9zZSB2dWxuZXJhYmlsaXRpZXMgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1jb25zb2xlLmxvZ10gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgZXZlcnkgdGltZSBTZXF1ZWxpemUgd291bGQgbG9nIHNvbWV0aGluZy4gRnVuY3Rpb24gbWF5IHJlY2VpdmUgbXVsdGlwbGUgcGFyYW1ldGVycyBidXQgb25seSBmaXJzdCBvbmUgaXMgcHJpbnRlZCBieSBgY29uc29sZS5sb2dgLiBUbyBwcmludCBhbGwgdmFsdWVzIHVzZSBgKC4uLm1zZykgPT4gY29uc29sZS5sb2cobXNnKWBcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMub21pdE51bGw9ZmFsc2VdIEEgZmxhZyB0aGF0IGRlZmluZXMgaWYgbnVsbCB2YWx1ZXMgc2hvdWxkIGJlIHBhc3NlZCBhcyB2YWx1ZXMgdG8gQ1JFQVRFL1VQREFURSBTUUwgcXVlcmllcyBvciBub3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLm5hdGl2ZT1mYWxzZV0gQSBmbGFnIHRoYXQgZGVmaW5lcyBpZiBuYXRpdmUgbGlicmFyeSBzaGFsbCBiZSB1c2VkIG9yIG5vdC4gQ3VycmVudGx5IG9ubHkgaGFzIGFuIGVmZmVjdCBmb3IgcG9zdGdyZXNcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMucmVwbGljYXRpb249ZmFsc2VdIFVzZSByZWFkIC8gd3JpdGUgcmVwbGljYXRpb24uIFRvIGVuYWJsZSByZXBsaWNhdGlvbiwgcGFzcyBhbiBvYmplY3QsIHdpdGggdHdvIHByb3BlcnRpZXMsIHJlYWQgYW5kIHdyaXRlLiBXcml0ZSBzaG91bGQgYmUgYW4gb2JqZWN0IChhIHNpbmdsZSBzZXJ2ZXIgZm9yIGhhbmRsaW5nIHdyaXRlcyksIGFuZCByZWFkIGFuIGFycmF5IG9mIG9iamVjdCAoc2V2ZXJhbCBzZXJ2ZXJzIHRvIGhhbmRsZSByZWFkcykuIEVhY2ggcmVhZC93cml0ZSBzZXJ2ZXIgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwb3J0YCwgYHVzZXJuYW1lYCwgYHBhc3N3b3JkYCwgYGRhdGFiYXNlYFxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5wb29sXSBzZXF1ZWxpemUgY29ubmVjdGlvbiBwb29sIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5tYXg9NV0gTWF4aW11bSBudW1iZXIgb2YgY29ubmVjdGlvbiBpbiBwb29sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wubWluPTBdIE1pbmltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb24gaW4gcG9vbFxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLmlkbGU9MTAwMDBdIFRoZSBtYXhpbXVtIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBhIGNvbm5lY3Rpb24gY2FuIGJlIGlkbGUgYmVmb3JlIGJlaW5nIHJlbGVhc2VkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLmFjcXVpcmU9NjAwMDBdIFRoZSBtYXhpbXVtIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBwb29sIHdpbGwgdHJ5IHRvIGdldCBjb25uZWN0aW9uIGJlZm9yZSB0aHJvd2luZyBlcnJvclxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLmV2aWN0PTEwMDBdIFRoZSB0aW1lIGludGVydmFsLCBpbiBtaWxsaXNlY29uZHMsIGFmdGVyIHdoaWNoIHNlcXVlbGl6ZS1wb29sIHdpbGwgcmVtb3ZlIGlkbGUgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnBvb2wudmFsaWRhdGVdIEEgZnVuY3Rpb24gdGhhdCB2YWxpZGF0ZXMgYSBjb25uZWN0aW9uLiBDYWxsZWQgd2l0aCBjbGllbnQuIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIGNoZWNrcyB0aGF0IGNsaWVudCBpcyBhbiBvYmplY3QsIGFuZCB0aGF0IGl0cyBzdGF0ZSBpcyBub3QgZGlzY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wubWF4VXNlcz1JbmZpbml0eV0gVGhlIG51bWJlciBvZiB0aW1lcyBhIGNvbm5lY3Rpb24gY2FuIGJlIHVzZWQgYmVmb3JlIGRpc2NhcmRpbmcgaXQgZm9yIGEgcmVwbGFjZW1lbnQsIFtgdXNlZCBmb3IgZXZlbnR1YWwgY2x1c3RlciByZWJhbGFuY2luZ2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplLXBvb2wpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzPXRydWVdIFNldCB0byBgZmFsc2VgIHRvIG1ha2UgdGFibGUgbmFtZXMgYW5kIGF0dHJpYnV0ZXMgY2FzZS1pbnNlbnNpdGl2ZSBvbiBQb3N0Z3JlcyBhbmQgc2tpcCBkb3VibGUgcXVvdGluZyBvZiB0aGVtLiAgV0FSTklORzogU2V0dGluZyB0aGlzIHRvIGZhbHNlIG1heSBleHBvc2UgdnVsbmVyYWJpbGl0aWVzIGFuZCBpcyBub3QgcmVjb21tZW5kZWQhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnRyYW5zYWN0aW9uVHlwZT0nREVGRVJSRUQnXSBTZXQgdGhlIGRlZmF1bHQgdHJhbnNhY3Rpb24gdHlwZS4gU2VlIGBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uVFlQRVNgIGZvciBwb3NzaWJsZSBvcHRpb25zLiBTcWxpdGUgb25seS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuaXNvbGF0aW9uTGV2ZWxdIFNldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvbiBpc29sYXRpb24gbGV2ZWwuIFNlZSBgU2VxdWVsaXplLlRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFNgIGZvciBwb3NzaWJsZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5yZXRyeV0gU2V0IG9mIGZsYWdzIHRoYXQgY29udHJvbCB3aGVuIGEgcXVlcnkgaXMgYXV0b21hdGljYWxseSByZXRyaWVkLiBBY2NlcHRzIGFsbCBvcHRpb25zIGZvciBbYHJldHJ5LWFzLXByb21pc2VkYF0oaHR0cHM6Ly9naXRodWIuY29tL21pY2toYW5zZW4vcmV0cnktYXMtcHJvbWlzZWQpLlxuICAgKiBAcGFyYW0ge0FycmF5fSAgICBbb3B0aW9ucy5yZXRyeS5tYXRjaF0gT25seSByZXRyeSBhIHF1ZXJ5IGlmIHRoZSBlcnJvciBtYXRjaGVzIG9uZSBvZiB0aGVzZSBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5yZXRyeS5tYXhdIEhvdyBtYW55IHRpbWVzIGEgZmFpbGluZyBxdWVyeSBpcyBhdXRvbWF0aWNhbGx5IHJldHJpZWQuICBTZXQgdG8gMCB0byBkaXNhYmxlIHJldHJ5aW5nIG9uIFNRTF9CVVNZIGVycm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy50eXBlVmFsaWRhdGlvbj1mYWxzZV0gUnVuIGJ1aWx0LWluIHR5cGUgdmFsaWRhdG9ycyBvbiBpbnNlcnQgYW5kIHVwZGF0ZSwgYW5kIHNlbGVjdCB3aXRoIHdoZXJlIGNsYXVzZSwgZS5nLiB2YWxpZGF0ZSB0aGF0IGFyZ3VtZW50cyBwYXNzZWQgdG8gaW50ZWdlciBmaWVsZHMgYXJlIGludGVnZXItbGlrZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMub3BlcmF0b3JzQWxpYXNlc10gU3RyaW5nIGJhc2VkIG9wZXJhdG9yIGFsaWFzLiBQYXNzIG9iamVjdCB0byBsaW1pdCBzZXQgb2YgYWxpYXNlZCBvcGVyYXRvcnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLmhvb2tzXSBBbiBvYmplY3Qgb2YgZ2xvYmFsIGhvb2sgZnVuY3Rpb25zIHRoYXQgYXJlIGNhbGxlZCBiZWZvcmUgYW5kIGFmdGVyIGNlcnRhaW4gbGlmZWN5Y2xlIGV2ZW50cy4gR2xvYmFsIGhvb2tzIHdpbGwgcnVuIGFmdGVyIGFueSBtb2RlbC1zcGVjaWZpYyBob29rcyBkZWZpbmVkIGZvciB0aGUgc2FtZSBldmVudCAoU2VlIGBTZXF1ZWxpemUuTW9kZWwuaW5pdCgpYCBmb3IgYSBsaXN0KS4gIEFkZGl0aW9uYWxseSwgYGJlZm9yZUNvbm5lY3QoKWAsIGBhZnRlckNvbm5lY3QoKWAsIGBiZWZvcmVEaXNjb25uZWN0KClgLCBhbmQgYGFmdGVyRGlzY29ubmVjdCgpYCBob29rcyBtYXkgYmUgZGVmaW5lZCBoZXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5taW5pZnlBbGlhc2VzPWZhbHNlXSBBIGZsYWcgdGhhdCBkZWZpbmVzIGlmIGFsaWFzZXMgc2hvdWxkIGJlIG1pbmlmaWVkIChtb3N0bHkgdXNlZnVsIHRvIGF2b2lkIFBvc3RncmVzIGFsaWFzIGNoYXJhY3RlciBsaW1pdCBvZiA2NClcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMubG9nUXVlcnlQYXJhbWV0ZXJzPWZhbHNlXSBBIGZsYWcgdGhhdCBkZWZpbmVzIGlmIHNob3cgYmluZCBwYXJhbWV0ZXJzIGluIGxvZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY29uZmlnO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRhdGFiYXNlID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gbmV3IFNlcXVlbGl6ZSh7IC4uLiBvcHRpb25zIH0pXG4gICAgICBvcHRpb25zID0gZGF0YWJhc2U7XG4gICAgICBjb25maWcgPSBfLnBpY2sob3B0aW9ucywgJ2hvc3QnLCAncG9ydCcsICdkYXRhYmFzZScsICd1c2VybmFtZScsICdwYXNzd29yZCcpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGF0YWJhc2UgPT09ICdzdHJpbmcnIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIHVzZXJuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gbmV3IFNlcXVlbGl6ZShVUkksIHsgLi4uIG9wdGlvbnMgfSlcblxuICAgICAgY29uZmlnID0ge307XG4gICAgICBvcHRpb25zID0gdXNlcm5hbWUgfHwge307XG5cbiAgICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnBhcnNlKGFyZ3VtZW50c1swXSwgdHJ1ZSk7XG5cbiAgICAgIG9wdGlvbnMuZGlhbGVjdCA9IHVybFBhcnRzLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpO1xuICAgICAgb3B0aW9ucy5ob3N0ID0gdXJsUGFydHMuaG9zdG5hbWU7XG5cbiAgICAgIGlmIChvcHRpb25zLmRpYWxlY3QgPT09ICdzcWxpdGUnICYmIHVybFBhcnRzLnBhdGhuYW1lICYmICF1cmxQYXJ0cy5wYXRobmFtZS5zdGFydHNXaXRoKCcvOm1lbW9yeScpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VQYXRoID0gcGF0aC5qb2luKG9wdGlvbnMuaG9zdCwgdXJsUGFydHMucGF0aG5hbWUpO1xuICAgICAgICBvcHRpb25zLnN0b3JhZ2UgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5zdG9yYWdlIHx8IHN0b3JhZ2VQYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybFBhcnRzLnBhdGhuYW1lKSB7XG4gICAgICAgIGNvbmZpZy5kYXRhYmFzZSA9IHVybFBhcnRzLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxQYXJ0cy5wb3J0KSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IHVybFBhcnRzLnBvcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxQYXJ0cy5hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGhQYXJ0cyA9IHVybFBhcnRzLmF1dGguc3BsaXQoJzonKTtcblxuICAgICAgICBjb25maWcudXNlcm5hbWUgPSBhdXRoUGFydHNbMF07XG5cbiAgICAgICAgaWYgKGF1dGhQYXJ0cy5sZW5ndGggPiAxKVxuICAgICAgICAgIGNvbmZpZy5wYXNzd29yZCA9IGF1dGhQYXJ0cy5zbGljZSgxKS5qb2luKCc6Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeSkge1xuICAgICAgICAvLyBBbGxvdyBob3N0IHF1ZXJ5IGFyZ3VtZW50IHRvIG92ZXJyaWRlIHRoZSB1cmwgaG9zdC5cbiAgICAgICAgLy8gRW5hYmxlcyBzcGVjaWZ5aW5nIGRvbWFpbiBzb2NrZXQgaG9zdHMgd2hpY2ggY2Fubm90IGJlIHNwZWNpZmllZCB2aWEgdGhlIHR5cGljYWxcbiAgICAgICAgLy8gaG9zdCBwYXJ0IG9mIGEgdXJsLlxuICAgICAgICBpZiAodXJsUGFydHMucXVlcnkuaG9zdCkge1xuICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IHVybFBhcnRzLnF1ZXJ5Lmhvc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5kaWFsZWN0T3B0aW9ucywgdXJsUGFydHMucXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMgPSB1cmxQYXJ0cy5xdWVyeTtcbiAgICAgICAgICBpZiAodXJsUGFydHMucXVlcnkub3B0aW9ucykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IEpTT04ucGFyc2UodXJsUGFydHMucXVlcnkub3B0aW9ucyk7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyA9IG87XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIHN0cmluZyBpcyBub3QgYSB2YWxpZCBKU09OXG4gICAgICAgICAgICAgIC8vIGFuIHRodXMgZG9lcyBub3QgbmVlZCBhbnkgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBTZXF1ZWxpemUoZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgeyAuLi4gb3B0aW9ucyB9KVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBjb25maWcgPSB7IGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQgfTtcbiAgICB9XG5cbiAgICBTZXF1ZWxpemUucnVuSG9va3MoJ2JlZm9yZUluaXQnLCBjb25maWcsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgZGlhbGVjdDogbnVsbCxcbiAgICAgIGRpYWxlY3RNb2R1bGU6IG51bGwsXG4gICAgICBkaWFsZWN0TW9kdWxlUGF0aDogbnVsbCxcbiAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgcHJvdG9jb2w6ICd0Y3AnLFxuICAgICAgZGVmaW5lOiB7fSxcbiAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgIHN5bmM6IHt9LFxuICAgICAgdGltZXpvbmU6ICcrMDA6MDAnLFxuICAgICAgY2xpZW50TWluTWVzc2FnZXM6ICd3YXJuaW5nJyxcbiAgICAgIHN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3M6IHRydWUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgbG9nZ2luZzogY29uc29sZS5sb2csXG4gICAgICBvbWl0TnVsbDogZmFsc2UsXG4gICAgICBuYXRpdmU6IGZhbHNlLFxuICAgICAgcmVwbGljYXRpb246IGZhbHNlLFxuICAgICAgc3NsOiB1bmRlZmluZWQsXG4gICAgICBwb29sOiB7fSxcbiAgICAgIHF1b3RlSWRlbnRpZmllcnM6IHRydWUsXG4gICAgICBob29rczoge30sXG4gICAgICByZXRyeToge1xuICAgICAgICBtYXg6IDUsXG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgJ1NRTElURV9CVVNZOiBkYXRhYmFzZSBpcyBsb2NrZWQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvblR5cGU6IFRyYW5zYWN0aW9uLlRZUEVTLkRFRkVSUkVELFxuICAgICAgaXNvbGF0aW9uTGV2ZWw6IG51bGwsXG4gICAgICBkYXRhYmFzZVZlcnNpb246IDAsXG4gICAgICB0eXBlVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBiZW5jaG1hcms6IGZhbHNlLFxuICAgICAgbWluaWZ5QWxpYXNlczogZmFsc2UsXG4gICAgICBsb2dRdWVyeVBhcmFtZXRlcnM6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaWFsZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpYWxlY3QgbmVlZHMgdG8gYmUgZXhwbGljaXRseSBzdXBwbGllZCBhcyBvZiB2NC4wLjAnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgPT09ICdwb3N0Z3Jlc3FsJykge1xuICAgICAgdGhpcy5vcHRpb25zLmRpYWxlY3QgPSAncG9zdGdyZXMnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCA9PT0gJ3NxbGl0ZScgJiYgdGhpcy5vcHRpb25zLnRpbWV6b25lICE9PSAnKzAwOjAwJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXR0aW5nIGEgY3VzdG9tIHRpbWV6b25lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgU1FMaXRlLCBkYXRlcyBhcmUgYWx3YXlzIHJldHVybmVkIGFzIFVUQy4gUGxlYXNlIHJlbW92ZSB0aGUgY3VzdG9tIHRpbWV6b25lIHBhcmFtZXRlci4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5vcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR1cEhvb2tzKG9wdGlvbnMuaG9va3MpO1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlIHx8IHRoaXMub3B0aW9ucy5kYXRhYmFzZSxcbiAgICAgIHVzZXJuYW1lOiBjb25maWcudXNlcm5hbWUgfHwgdGhpcy5vcHRpb25zLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCB8fCB0aGlzLm9wdGlvbnMucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0IHx8IHRoaXMub3B0aW9ucy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQgfHwgdGhpcy5vcHRpb25zLnBvcnQsXG4gICAgICBwb29sOiB0aGlzLm9wdGlvbnMucG9vbCxcbiAgICAgIHByb3RvY29sOiB0aGlzLm9wdGlvbnMucHJvdG9jb2wsXG4gICAgICBuYXRpdmU6IHRoaXMub3B0aW9ucy5uYXRpdmUsXG4gICAgICBzc2w6IHRoaXMub3B0aW9ucy5zc2wsXG4gICAgICByZXBsaWNhdGlvbjogdGhpcy5vcHRpb25zLnJlcGxpY2F0aW9uLFxuICAgICAgZGlhbGVjdE1vZHVsZTogdGhpcy5vcHRpb25zLmRpYWxlY3RNb2R1bGUsXG4gICAgICBkaWFsZWN0TW9kdWxlUGF0aDogdGhpcy5vcHRpb25zLmRpYWxlY3RNb2R1bGVQYXRoLFxuICAgICAga2VlcERlZmF1bHRUaW1lem9uZTogdGhpcy5vcHRpb25zLmtlZXBEZWZhdWx0VGltZXpvbmUsXG4gICAgICBkaWFsZWN0T3B0aW9uczogdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zXG4gICAgfTtcblxuICAgIGxldCBEaWFsZWN0O1xuICAgIC8vIFJlcXVpcmluZyB0aGUgZGlhbGVjdCBpbiBhIHN3aXRjaC1jYXNlIHRvIGtlZXAgdGhlXG4gICAgLy8gcmVxdWlyZSBjYWxscyBzdGF0aWMuIChCcm93c2VyaWZ5IGZpeClcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0RGlhbGVjdCgpKSB7XG4gICAgICBjYXNlICdtYXJpYWRiJzpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbWFyaWFkYicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21zc3FsJzpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbXNzcWwnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdteXNxbCc6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKCcuL2RpYWxlY3RzL215c3FsJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zdGdyZXMnOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9wb3N0Z3JlcycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NxbGl0ZSc6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKCcuL2RpYWxlY3RzL3NxbGl0ZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRpYWxlY3QgJHt0aGlzLmdldERpYWxlY3QoKX0gaXMgbm90IHN1cHBvcnRlZC4gU3VwcG9ydGVkIGRpYWxlY3RzOiBtc3NxbCwgbWFyaWFkYiwgbXlzcWwsIHBvc3RncmVzLCBhbmQgc3FsaXRlLmApO1xuICAgIH1cblxuICAgIHRoaXMuZGlhbGVjdCA9IG5ldyBEaWFsZWN0KHRoaXMpO1xuICAgIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci50eXBlVmFsaWRhdGlvbiA9IG9wdGlvbnMudHlwZVZhbGlkYXRpb247XG5cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzKSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vU3RyaW5nT3BlcmF0b3JzKCk7XG4gICAgICB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3Iuc2V0T3BlcmF0b3JzQWxpYXNlcyh0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMgPT09ICdib29sZWFuJykge1xuICAgICAgZGVwcmVjYXRpb25zLm5vQm9vbE9wZXJhdG9yQWxpYXNlcygpO1xuICAgIH1cblxuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSB0aGlzLmRpYWxlY3QucXVlcnlJbnRlcmZhY2U7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlbHMgYXJlIHN0b3JlZCBoZXJlIHVuZGVyIHRoZSBuYW1lIGdpdmVuIHRvIGBzZXF1ZWxpemUuZGVmaW5lYFxuICAgICAqL1xuICAgIHRoaXMubW9kZWxzID0ge307XG4gICAgdGhpcy5tb2RlbE1hbmFnZXIgPSBuZXcgTW9kZWxNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXI7XG5cbiAgICBTZXF1ZWxpemUucnVuSG9va3MoJ2FmdGVySW5pdCcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggZGF0YSB0eXBlcyBhbmQgcGFyc2Vycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZnJlc2hUeXBlcygpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGRpYWxlY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzcGVjaWZpZWQgZGlhbGVjdC5cbiAgICovXG4gIGdldERpYWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kaWFsZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGFiYXNlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkYXRhYmFzZSBuYW1lLlxuICAgKi9cbiAgZ2V0RGF0YWJhc2VOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFF1ZXJ5SW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UXVlcnlJbnRlcmZhY2V9IEFuIGluc3RhbmNlIChzaW5nbGV0b24pIG9mIFF1ZXJ5SW50ZXJmYWNlLlxuICAgKi9cbiAgZ2V0UXVlcnlJbnRlcmZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJbnRlcmZhY2U7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgbmV3IG1vZGVsLCByZXByZXNlbnRpbmcgYSB0YWJsZSBpbiB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIFRoZSB0YWJsZSBjb2x1bW5zIGFyZSBkZWZpbmVkIGJ5IHRoZSBvYmplY3QgdGhhdCBpcyBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBFYWNoIGtleSBvZiB0aGUgb2JqZWN0IHJlcHJlc2VudHMgYSBjb2x1bW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwuIFRoZSBtb2RlbCB3aWxsIGJlIHN0b3JlZCBpbiBgc2VxdWVsaXplLm1vZGVsc2AgdW5kZXIgdGhpcyBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIEFuIG9iamVjdCwgd2hlcmUgZWFjaCBhdHRyaWJ1dGUgaXMgYSBjb2x1bW4gb2YgdGhlIHRhYmxlLiBTZWUge0BsaW5rIE1vZGVsLmluaXR9XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlc2Ugb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIFNlcXVlbGl6ZSBjb25zdHJ1Y3RvciBhbmQgcGFzc2VkIHRvIE1vZGVsLmluaXQoKVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5pbml0fSBmb3IgYSBtb3JlIGNvbXByZWhlbnNpdmUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgYG9wdGlvbnNgIGFuZCBgYXR0cmlidXRlc2Agb2JqZWN0cy5cbiAgICogQHNlZVxuICAgKiA8YSBocmVmPVwiL21hc3Rlci9tYW51YWwvbW9kZWwtYmFzaWNzLmh0bWxcIj5Nb2RlbCBCYXNpY3M8L2E+IGd1aWRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH0gTmV3bHkgZGVmaW5lZCBtb2RlbFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBzZXF1ZWxpemUuZGVmaW5lKCdtb2RlbE5hbWUnLCB7XG4gICAqICAgY29sdW1uQToge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuQk9PTEVBTixcbiAgICogICAgICAgdmFsaWRhdGU6IHtcbiAgICogICAgICAgICBpczogW1wiW2Etel1cIiwnaSddLCAgICAgICAgLy8gd2lsbCBvbmx5IGFsbG93IGxldHRlcnNcbiAgICogICAgICAgICBtYXg6IDIzLCAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgdmFsdWVzIDw9IDIzXG4gICAqICAgICAgICAgaXNJbjoge1xuICAgKiAgICAgICAgICAgYXJnczogW1snZW4nLCAnemgnXV0sXG4gICAqICAgICAgICAgICBtc2c6IFwiTXVzdCBiZSBFbmdsaXNoIG9yIENoaW5lc2VcIlxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfSxcbiAgICogICAgICAgZmllbGQ6ICdjb2x1bW5fYSdcbiAgICogICB9LFxuICAgKiAgIGNvbHVtbkI6IFNlcXVlbGl6ZS5TVFJJTkcsXG4gICAqICAgY29sdW1uQzogJ01ZIFZFUlkgT1dOIENPTFVNTiBUWVBFJ1xuICAgKiB9KTtcbiAgICpcbiAgICogc2VxdWVsaXplLm1vZGVscy5tb2RlbE5hbWUgLy8gVGhlIG1vZGVsIHdpbGwgbm93IGJlIGF2YWlsYWJsZSBpbiBtb2RlbHMgdW5kZXIgdGhlIG5hbWUgZ2l2ZW4gdG8gZGVmaW5lXG4gICAqL1xuICBkZWZpbmUobW9kZWxOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLm1vZGVsTmFtZSA9IG1vZGVsTmFtZTtcbiAgICBvcHRpb25zLnNlcXVlbGl6ZSA9IHRoaXM7XG5cbiAgICBjb25zdCBtb2RlbCA9IGNsYXNzIGV4dGVuZHMgTW9kZWwge307XG5cbiAgICBtb2RlbC5pbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgTW9kZWwgd2hpY2ggaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWUgVGhlIG5hbWUgb2YgYSBtb2RlbCBkZWZpbmVkIHdpdGggU2VxdWVsaXplLmRlZmluZVxuICAgKlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1vZGVsIGlzIG5vdCBkZWZpbmVkICh0aGF0IGlzLCBpZiBzZXF1ZWxpemUjaXNEZWZpbmVkIHJldHVybnMgZmFsc2UpXG4gICAqIEByZXR1cm5zIHtNb2RlbH0gU3BlY2lmaWVkIG1vZGVsXG4gICAqL1xuICBtb2RlbChtb2RlbE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNEZWZpbmVkKG1vZGVsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttb2RlbE5hbWV9IGhhcyBub3QgYmVlbiBkZWZpbmVkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kZWxNYW5hZ2VyLmdldE1vZGVsKG1vZGVsTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGRlZmluZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZSBUaGUgbmFtZSBvZiBhIG1vZGVsIGRlZmluZWQgd2l0aCBTZXF1ZWxpemUuZGVmaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgbW9kZWwgaXMgYWxyZWFkeSBkZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIGlzRGVmaW5lZChtb2RlbE5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMuZmluZChtb2RlbCA9PiBtb2RlbC5uYW1lID09PSBtb2RlbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBxdWVyeSBvbiB0aGUgREIsIG9wdGlvbmFsbHkgYnlwYXNzaW5nIGFsbCB0aGUgU2VxdWVsaXplIGdvb2RuZXNzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHdvIGFyZ3VtZW50czogYW4gYXJyYXkgb2YgcmVzdWx0cywgYW5kIGEgbWV0YWRhdGEgb2JqZWN0LCBjb250YWluaW5nIG51bWJlciBvZiBhZmZlY3RlZCByb3dzIGV0Yy5cbiAgICpcbiAgICogSWYgeW91IGFyZSBydW5uaW5nIGEgdHlwZSBvZiBxdWVyeSB3aGVyZSB5b3UgZG9uJ3QgbmVlZCB0aGUgbWV0YWRhdGEsIGZvciBleGFtcGxlIGEgYFNFTEVDVGAgcXVlcnksIHlvdSBjYW4gcGFzcyBpbiBhIHF1ZXJ5IHR5cGUgdG8gbWFrZSBzZXF1ZWxpemUgZm9ybWF0IHRoZSByZXN1bHRzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBbcmVzdWx0cywgbWV0YWRhdGFdID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KCdTRUxFQ1QuLi4nKTsgLy8gUmF3IHF1ZXJ5IC0gdXNlIGFycmF5IGRlc3RydWN0dXJpbmdcbiAgICpcbiAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IHNlcXVlbGl6ZS5xdWVyeSgnU0VMRUNULi4uJywgeyB0eXBlOiBzZXF1ZWxpemUuUXVlcnlUeXBlcy5TRUxFQ1QgfSk7IC8vIFNFTEVDVCBxdWVyeSAtIG5vIGRlc3RydWN0dXJpbmdcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBzcWxcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zPXt9XSBRdWVyeSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMucmF3XSBJZiB0cnVlLCBzZXF1ZWxpemUgd2lsbCBub3QgdHJ5IHRvIGZvcm1hdCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnksIG9yIGJ1aWxkIGFuIGluc3RhbmNlIG9mIGEgbW9kZWwgZnJvbSB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259ICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbj1udWxsXSBUaGUgdHJhbnNhY3Rpb24gdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIGV4ZWN1dGVkIHVuZGVyXG4gICAqIEBwYXJhbSB7UXVlcnlUeXBlc30gICAgICBbb3B0aW9ucy50eXBlPSdSQVcnXSBUaGUgdHlwZSBvZiBxdWVyeSB5b3UgYXJlIGV4ZWN1dGluZy4gVGhlIHF1ZXJ5IHR5cGUgYWZmZWN0cyBob3cgcmVzdWx0cyBhcmUgZm9ybWF0dGVkIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgYmFjay4gVGhlIHR5cGUgaXMgYSBzdHJpbmcsIGJ1dCBgU2VxdWVsaXplLlF1ZXJ5VHlwZXNgIGlzIHByb3ZpZGVkIGFzIGNvbnZlbmllbmNlIHNob3J0Y3V0cy5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLm5lc3Q9ZmFsc2VdIElmIHRydWUsIHRyYW5zZm9ybXMgb2JqZWN0cyB3aXRoIGAuYCBzZXBhcmF0ZWQgcHJvcGVydHkgbmFtZXMgaW50byBuZXN0ZWQgb2JqZWN0cyB1c2luZyBbZG90dGllLmpzXShodHRwczovL2dpdGh1Yi5jb20vbWlja2hhbnNlbi9kb3R0aWUuanMpLiBGb3IgZXhhbXBsZSB7ICd1c2VyLnVzZXJuYW1lJzogJ2pvaG4nIH0gYmVjb21lcyB7IHVzZXI6IHsgdXNlcm5hbWU6ICdqb2huJyB9fS4gV2hlbiBgbmVzdGAgaXMgdHJ1ZSwgdGhlIHF1ZXJ5IHR5cGUgaXMgYXNzdW1lZCB0byBiZSBgJ1NFTEVDVCdgLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMucGxhaW49ZmFsc2VdIFNldHMgdGhlIHF1ZXJ5IHR5cGUgdG8gYFNFTEVDVGAgYW5kIHJldHVybiBhIHNpbmdsZSByb3dcbiAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl9ICAgIFtvcHRpb25zLnJlcGxhY2VtZW50c10gRWl0aGVyIGFuIG9iamVjdCBvZiBuYW1lZCBwYXJhbWV0ZXIgcmVwbGFjZW1lbnRzIGluIHRoZSBmb3JtYXQgYDpwYXJhbWAgb3IgYW4gYXJyYXkgb2YgdW5uYW1lZCByZXBsYWNlbWVudHMgdG8gcmVwbGFjZSBgP2AgaW4geW91ciBTUUwuXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSAgICBbb3B0aW9ucy5iaW5kXSBFaXRoZXIgYW4gb2JqZWN0IG9mIG5hbWVkIGJpbmQgcGFyYW1ldGVyIGluIHRoZSBmb3JtYXQgYF9wYXJhbWAgb3IgYW4gYXJyYXkgb2YgdW5uYW1lZCBiaW5kIHBhcmFtZXRlciB0byByZXBsYWNlIGAkMSwgJDIsIC4uLmAgaW4geW91ciBTUUwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy51c2VNYXN0ZXI9ZmFsc2VdIEZvcmNlIHRoZSBxdWVyeSB0byB1c2UgdGhlIHdyaXRlIHBvb2wsIHJlZ2FyZGxlc3Mgb2YgdGhlIHF1ZXJ5IHR5cGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgIFtvcHRpb25zLmluc3RhbmNlXSBBIHNlcXVlbGl6ZSBtb2RlbCBpbnN0YW5jZSB3aG9zZSBNb2RlbCBpcyB0byBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBxdWVyeSByZXN1bHRcbiAgICogQHBhcmFtIHt0eXBlb2YgTW9kZWx9ICAgIFtvcHRpb25zLm1vZGVsXSBBIHNlcXVlbGl6ZSBtb2RlbCB1c2VkIHRvIGJ1aWxkIHRoZSByZXR1cm5lZCBtb2RlbCBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zLnJldHJ5XSBTZXQgb2YgZmxhZ3MgdGhhdCBjb250cm9sIHdoZW4gYSBxdWVyeSBpcyBhdXRvbWF0aWNhbGx5IHJldHJpZWQuIEFjY2VwdHMgYWxsIG9wdGlvbnMgZm9yIFtgcmV0cnktYXMtcHJvbWlzZWRgXShodHRwczovL2dpdGh1Yi5jb20vbWlja2hhbnNlbi9yZXRyeS1hcy1wcm9taXNlZCkuXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICBbb3B0aW9ucy5yZXRyeS5tYXRjaF0gT25seSByZXRyeSBhIHF1ZXJ5IGlmIHRoZSBlcnJvciBtYXRjaGVzIG9uZSBvZiB0aGVzZSBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ9ICAgICAgICAgW29wdGlvbnMucmV0cnkubWF4XSBIb3cgbWFueSB0aW1lcyBhIGZhaWxpbmcgcXVlcnkgaXMgYXV0b21hdGljYWxseSByZXRyaWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuc3VwcG9ydHNTZWFyY2hQYXRoXSBJZiBmYWxzZSBkbyBub3QgcHJlcGVuZCB0aGUgcXVlcnkgd2l0aCB0aGUgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5tYXBUb01vZGVsPWZhbHNlXSBNYXAgcmV0dXJuZWQgZmllbGRzIHRvIG1vZGVsJ3MgZmllbGRzIGlmIGBvcHRpb25zLm1vZGVsYCBvciBgb3B0aW9ucy5pbnN0YW5jZWAgaXMgcHJlc2VudC4gTWFwcGluZyB3aWxsIG9jY3VyIGJlZm9yZSBidWlsZGluZyB0aGUgbW9kZWwgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9ucy5maWVsZE1hcF0gTWFwIHJldHVybmVkIGZpZWxkcyB0byBhcmJpdHJhcnkgbmFtZXMgZm9yIGBTRUxFQ1RgIHF1ZXJ5IHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKiBAc2VlIHtAbGluayBNb2RlbC5idWlsZH0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaW5zdGFuY2Ugb3B0aW9uLlxuICAgKi9cblxuICBhc3luYyBxdWVyeShzcWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMucXVlcnksIC4uLm9wdGlvbnMgfTtcblxuICAgIGlmIChvcHRpb25zLmluc3RhbmNlICYmICFvcHRpb25zLm1vZGVsKSB7XG4gICAgICBvcHRpb25zLm1vZGVsID0gb3B0aW9ucy5pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5zdGFuY2UgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBtYXAgcmF3IGZpZWxkcyB0byBtb2RlbCBhdHRyaWJ1dGVzXG4gICAgaWYgKG9wdGlvbnMubWFwVG9Nb2RlbCkge1xuICAgICAgb3B0aW9ucy5maWVsZE1hcCA9IF8uZ2V0KG9wdGlvbnMsICdtb2RlbC5maWVsZEF0dHJpYnV0ZU1hcCcsIHt9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgbG9nZ2luZzogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucywgJ2xvZ2dpbmcnKSA/IHRoaXMub3B0aW9ucy5sb2dnaW5nIDogY29uc29sZS5sb2csXG4gICAgICBzZWFyY2hQYXRoOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLCAnc2VhcmNoUGF0aCcpID8gdGhpcy5vcHRpb25zLnNlYXJjaFBhdGggOiAnREVGQVVMVCdcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICBpZiAob3B0aW9ucy5tb2RlbCB8fCBvcHRpb25zLm5lc3QgfHwgb3B0aW9ucy5wbGFpbikge1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlNFTEVDVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuUkFXO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vaWYgZGlhbGVjdCBkb2Vzbid0IHN1cHBvcnQgc2VhcmNoX3BhdGggb3IgZGlhbGVjdCBvcHRpb25cbiAgICAvL3RvIHByZXBlbmQgc2VhcmNoUGF0aCBpcyBub3QgdHJ1ZSBkZWxldGUgdGhlIHNlYXJjaFBhdGggb3B0aW9uXG4gICAgaWYgKFxuICAgICAgIXRoaXMuZGlhbGVjdC5zdXBwb3J0cy5zZWFyY2hQYXRoIHx8XG4gICAgICAhdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zIHx8XG4gICAgICAhdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zLnByZXBlbmRTZWFyY2hQYXRoIHx8XG4gICAgICBvcHRpb25zLnN1cHBvcnRzU2VhcmNoUGF0aCA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnNlYXJjaFBhdGg7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICAvL2lmIHVzZXIgd2FudHMgdG8gYWx3YXlzIHByZXBlbmQgc2VhcmNoUGF0aCAoZGlhbGVjdE9wdGlvbnMucHJlcHJlbmRTZWFyY2hQYXRoID0gdHJ1ZSlcbiAgICAgIC8vdGhlbiBzZXQgdG8gREVGQVVMVCBpZiBub25lIGlzIHByb3ZpZGVkXG4gICAgICBvcHRpb25zLnNlYXJjaFBhdGggPSAnREVGQVVMVCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzcWwgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoc3FsLnZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGBzcWwudmFsdWVzYCBhbmQgYG9wdGlvbnMucmVwbGFjZW1lbnRzYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlcGxhY2VtZW50cyA9IHNxbC52YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcWwuYmluZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBgc3FsLmJpbmRgIGFuZCBgb3B0aW9ucy5iaW5kYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmJpbmQgPSBzcWwuYmluZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNxbC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNxbCA9IHNxbC5xdWVyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzcWwgPSBzcWwudHJpbSgpO1xuXG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzICYmIG9wdGlvbnMuYmluZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGByZXBsYWNlbWVudHNgIGFuZCBgYmluZGAgY2Fubm90IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlcGxhY2VtZW50cykpIHtcbiAgICAgICAgc3FsID0gVXRpbHMuZm9ybWF0KFtzcWxdLmNvbmNhdChvcHRpb25zLnJlcGxhY2VtZW50cyksIHRoaXMub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxbCA9IFV0aWxzLmZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIG9wdGlvbnMucmVwbGFjZW1lbnRzLCB0aGlzLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJpbmRQYXJhbWV0ZXJzO1xuXG4gICAgaWYgKG9wdGlvbnMuYmluZCkge1xuICAgICAgW3NxbCwgYmluZFBhcmFtZXRlcnNdID0gdGhpcy5kaWFsZWN0LlF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgb3B0aW9ucy5iaW5kLCB0aGlzLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgJiYgIW9wdGlvbnMuY29tcGxldGVzVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7b3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZH0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgdHJhbnNhY3Rpb24oJHtvcHRpb25zLnRyYW5zYWN0aW9uLmlkfSksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSBpdC4gKFRoZSByZWplY3RlZCBxdWVyeSBpcyBhdHRhY2hlZCBhcyB0aGUgJ3NxbCcgcHJvcGVydHkgb2YgdGhpcyBlcnJvcilgKTtcbiAgICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmV0cnlPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMucmV0cnksIC4uLm9wdGlvbnMucmV0cnkgfTtcblxuICAgIHJldHVybiByZXRyeShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdW5kZWZpbmVkICYmIFNlcXVlbGl6ZS5fY2xzKSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSBTZXF1ZWxpemUuX2Nscy5nZXQoJ3RyYW5zYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrVHJhbnNhY3Rpb24oKTtcblxuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IChvcHRpb25zLnRyYW5zYWN0aW9uID8gb3B0aW9ucy50cmFuc2FjdGlvbi5jb25uZWN0aW9uIDogdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKG9wdGlvbnMpKTtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IHRoaXMuZGlhbGVjdC5RdWVyeShjb25uZWN0aW9uLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlUXVlcnknLCBvcHRpb25zLCBxdWVyeSk7XG4gICAgICAgIGNoZWNrVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHF1ZXJ5LnJ1bihzcWwsIGJpbmRQYXJhbWV0ZXJzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyUXVlcnknLCBvcHRpb25zLCBxdWVyeSk7XG4gICAgICAgIGlmICghb3B0aW9ucy50cmFuc2FjdGlvbikge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCByZXRyeU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBxdWVyeSB3aGljaCB3b3VsZCBzZXQgYW4gZW52aXJvbm1lbnQgb3IgdXNlciB2YXJpYWJsZS4gVGhlIHZhcmlhYmxlcyBhcmUgc2V0IHBlciBjb25uZWN0aW9uLCBzbyB0aGlzIGZ1bmN0aW9uIG5lZWRzIGEgdHJhbnNhY3Rpb24uXG4gICAqIE9ubHkgd29ya3MgZm9yIE15U1FMLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgIHZhcmlhYmxlcyBPYmplY3Qgd2l0aCBtdWx0aXBsZSB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgW29wdGlvbnNdIHF1ZXJ5IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259ICAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgZXhlY3V0ZWQgdW5kZXJcbiAgICpcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNldCh2YXJpYWJsZXMsIG9wdGlvbnMpIHtcblxuICAgIC8vIFByZXBhcmUgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucy5zZXQsIC4uLnR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgIT09ICdteXNxbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2VxdWVsaXplLnNldCBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbXlzcWwnKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnRyYW5zYWN0aW9uIHx8ICEob3B0aW9ucy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMudHJhbnNhY3Rpb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBzb21lIG9wdGlvbnMsIHNpbmNlIHRoaXMgaXNuJ3QgYSBTRUxFQ1RcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG4gICAgb3B0aW9ucy50eXBlID0gJ1NFVCc7XG5cbiAgICAvLyBHZW5lcmF0ZSBTUUwgUXVlcnlcbiAgICBjb25zdCBxdWVyeSA9XG4gICAgICBgU0VUICR7XG4gICAgICAgIF8ubWFwKHZhcmlhYmxlcywgKHYsIGspID0+IGBAJHtrfSA6PSAke3R5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGBcIiR7dn1cImAgOiB2fWApLmpvaW4oJywgJyl9YDtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGUgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBzdHJpbmcgdmFsdWUgdG8gZXNjYXBlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmVzY2FwZSh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGFiYXNlIHNjaGVtYS5cbiAgICpcbiAgICogKipOb3RlOioqIHRoaXMgaXMgYSBzY2hlbWEgaW4gdGhlIFtwb3N0Z3JlcyBzZW5zZSBvZiB0aGUgd29yZF0oaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMS9zdGF0aWMvZGRsLXNjaGVtYXMuaHRtbCksXG4gICAqIG5vdCBhIGRhdGFiYXNlIHRhYmxlLiBJbiBteXNxbCBhbmQgc3FsaXRlLCB0aGlzIGNvbW1hbmQgd2lsbCBkbyBub3RoaW5nLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5zY2hlbWF9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWEgTmFtZSBvZiB0aGUgc2NoZW1hXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYWxsIGRlZmluZWQgc2NoZW1hc1xuICAgKlxuICAgKiAqKk5vdGU6KiogdGhpcyBpcyBhIHNjaGVtYSBpbiB0aGUgW3Bvc3RncmVzIHNlbnNlIG9mIHRoZSB3b3JkXShodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4xL3N0YXRpYy9kZGwtc2NoZW1hcy5odG1sKSxcbiAgICogbm90IGEgZGF0YWJhc2UgdGFibGUuIEluIG15c3FsIGFuZCBzcWxpdGUsIHRoaXMgd2lsbCBzaG93IGFsbCB0YWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHNob3dBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLnNob3dBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYSBzaW5nbGUgc2NoZW1hXG4gICAqXG4gICAqICoqTm90ZToqKiB0aGlzIGlzIGEgc2NoZW1hIGluIHRoZSBbcG9zdGdyZXMgc2Vuc2Ugb2YgdGhlIHdvcmRdKGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjEvc3RhdGljL2RkbC1zY2hlbWFzLmh0bWwpLFxuICAgKiBub3QgYSBkYXRhYmFzZSB0YWJsZS4gSW4gbXlzcWwgYW5kIHNxbGl0ZSwgdGhpcyBkcm9wIGEgdGFibGUgbWF0Y2hpbmcgdGhlIHNjaGVtYSBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWEgTmFtZSBvZiB0aGUgc2NoZW1hXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgc2NoZW1hcy5cbiAgICpcbiAgICogKipOb3RlOioqIHRoaXMgaXMgYSBzY2hlbWEgaW4gdGhlIFtwb3N0Z3JlcyBzZW5zZSBvZiB0aGUgd29yZF0oaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMS9zdGF0aWMvZGRsLXNjaGVtYXMuaHRtbCksXG4gICAqIG5vdCBhIGRhdGFiYXNlIHRhYmxlLiBJbiBteXNxbCBhbmQgc3FsaXRlLCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIGRyb3AgYWxsIHRhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEFsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZHJvcEFsbFNjaGVtYXMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3luYyBhbGwgZGVmaW5lZCBtb2RlbHMgdG8gdGhlIERCLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHN5bmMgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPWZhbHNlXSBJZiBmb3JjZSBpcyB0cnVlLCBlYWNoIE1vZGVsIHdpbGwgcnVuIGBEUk9QIFRBQkxFIElGIEVYSVNUU2AsIGJlZm9yZSBpdCB0cmllcyB0byBjcmVhdGUgaXRzIG93biB0YWJsZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMubWF0Y2hdIE1hdGNoIGEgcmVnZXggYWdhaW5zdCB0aGUgZGF0YWJhc2UgbmFtZSBiZWZvcmUgc3luY2luZywgYSBzYWZldHkgY2hlY2sgZm9yIGNhc2VzIHdoZXJlIGZvcmNlOiB0cnVlIGlzIHVzZWQgaW4gdGVzdHMgYnV0IG5vdCBsaXZlIGNvZGVcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWNvbnNvbGUubG9nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNjaGVtYT0ncHVibGljJ10gVGhlIHNjaGVtYSB0aGF0IHRoZSB0YWJsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4uIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIGVhY2ggdGFibGUgaW4gc2VxdWVsaXplLmRlZmluZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhvb2tzPXRydWVdIElmIGhvb2tzIGlzIHRydWUgdGhlbiBiZWZvcmVTeW5jLCBhZnRlclN5bmMsIGJlZm9yZUJ1bGtTeW5jLCBhZnRlckJ1bGtTeW5jIGhvb2tzIHdpbGwgYmUgY2FsbGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxvYmplY3R9IFtvcHRpb25zLmFsdGVyPWZhbHNlXSBBbHRlcnMgdGFibGVzIHRvIGZpdCBtb2RlbHMuIFByb3ZpZGUgYW4gb2JqZWN0IGZvciBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiB1c2UuIElmIG5vdCBmdXJ0aGVyIGNvbmZpZ3VyZWQgZGVsZXRlcyBkYXRhIGluIGNvbHVtbnMgdGhhdCB3ZXJlIHJlbW92ZWQgb3IgaGFkIHRoZWlyIHR5cGUgY2hhbmdlZCBpbiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWx0ZXIuZHJvcD10cnVlXSBQcmV2ZW50cyBhbnkgZHJvcCBzdGF0ZW1lbnRzIHdoaWxlIGFsdGVyaW5nIGEgdGFibGUgd2hlbiBzZXQgdG8gYGZhbHNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHN5bmMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi50aGlzLm9wdGlvbnMuc3luYyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBob29rczogb3B0aW9ucyA/IG9wdGlvbnMuaG9va3MgIT09IGZhbHNlIDogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5tYXRjaCkge1xuICAgICAgaWYgKCFvcHRpb25zLm1hdGNoLnRlc3QodGhpcy5jb25maWcuZGF0YWJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgXCIke3RoaXMuY29uZmlnLmRhdGFiYXNlfVwiIGRvZXMgbm90IG1hdGNoIHN5bmMgbWF0Y2ggcGFyYW1ldGVyIFwiJHtvcHRpb25zLm1hdGNofVwiYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUJ1bGtTeW5jJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG1vZGVscyA9IFtdO1xuXG4gICAgLy8gVG9wb2xvZ2ljYWxseSBzb3J0IGJ5IGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzIHRvIGdpdmUgdXMgYW4gYXBwcm9wcmlhdGVcbiAgICAvLyBjcmVhdGlvbiBvcmRlclxuICAgIHRoaXMubW9kZWxNYW5hZ2VyLmZvckVhY2hNb2RlbChtb2RlbCA9PiB7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWxzLnB1c2gobW9kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gREIgc2hvdWxkIHRocm93IGFuIFNRTCBlcnJvciBpZiByZWZlcmVuY2luZyBub24tZXhpc3RlbnQgdGFibGVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG5vIG1vZGVscyBkZWZpbmVkLCBqdXN0IGF1dGhlbnRpY2F0ZVxuICAgIGlmICghbW9kZWxzLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzKSBhd2FpdCBtb2RlbC5zeW5jKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJCdWxrU3luYycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZSBhbGwgdGFibGVzIGRlZmluZWQgdGhyb3VnaCB0aGUgc2VxdWVsaXplIG1vZGVscy5cbiAgICogVGhpcyBpcyBkb25lIGJ5IGNhbGxpbmcgYE1vZGVsLnRydW5jYXRlKClgIG9uIGVhY2ggbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIE1vZGVsLmRlc3Ryb3kgaW4gYWRkaXRpb24gdG8gdHJ1bmNhdGVcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLnRydW5jYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgdHJ1bmNhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IG1vZGVscyA9IFtdO1xuXG4gICAgdGhpcy5tb2RlbE1hbmFnZXIuZm9yRWFjaE1vZGVsKG1vZGVsID0+IHtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbHMucHVzaChtb2RlbCk7XG4gICAgICB9XG4gICAgfSwgeyByZXZlcnNlOiBmYWxzZSB9KTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2FzY2FkZSkge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiBtb2RlbHMpIGF3YWl0IG1vZGVsLnRydW5jYXRlKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChtb2RlbHMubWFwKG1vZGVsID0+IG1vZGVsLnRydW5jYXRlKG9wdGlvbnMpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYWxsIHRhYmxlcyBkZWZpbmVkIHRocm91Z2ggdGhpcyBzZXF1ZWxpemUgaW5zdGFuY2UuXG4gICAqIFRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIE1vZGVsLmRyb3Agb24gZWFjaCBtb2RlbC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZHJvcH0gZm9yIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gZWFjaCBjYWxsIHRvIE1vZGVsLmRyb3BcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbHMgPSBbXTtcblxuICAgIHRoaXMubW9kZWxNYW5hZ2VyLmZvckVhY2hNb2RlbChtb2RlbCA9PiB7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWxzLnB1c2gobW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHsgcmV2ZXJzZTogZmFsc2UgfSk7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vZGVscykgYXdhaXQgbW9kZWwuZHJvcChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHRoZSBjb25uZWN0aW9uIGJ5IHRyeWluZyB0byBhdXRoZW50aWNhdGUuIEl0IHJ1bnMgYFNFTEVDVCAxKzEgQVMgcmVzdWx0YCBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBxdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcGxhaW46IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy5xdWVyeSgnU0VMRUNUIDErMSBBUyByZXN1bHQnLCBvcHRpb25zKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5jIGRhdGFiYXNlVmVyc2lvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kYXRhYmFzZVZlcnNpb24ob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmbiBmb3IgcmFuZG9tIGJhc2VkIG9uIHRoZSBkaWFsZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuZm59XG4gICAqL1xuICByYW5kb20oKSB7XG4gICAgY29uc3QgZGlhID0gdGhpcy5nZXREaWFsZWN0KCk7XG4gICAgaWYgKGRpYSA9PT0gJ3Bvc3RncmVzJyB8fCBkaWEgPT09ICdzcWxpdGUnKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbignUkFORE9NJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZuKCdSQU5EJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZGF0YWJhc2UgZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgaW4gc2VhcmNoIHF1ZXJpZXMsIGJvdGggaW4gd2hlcmUgYW5kIG9yZGVyIHBhcnRzLCBhbmQgYXMgZGVmYXVsdCB2YWx1ZXMgaW4gY29sdW1uIGRlZmluaXRpb25zLlxuICAgKiBJZiB5b3Ugd2FudCB0byByZWZlciB0byBjb2x1bW5zIGluIHlvdXIgZnVuY3Rpb24sIHlvdSBzaG91bGQgdXNlIGBzZXF1ZWxpemUuY29sYCwgc28gdGhhdCB0aGUgY29sdW1ucyBhcmUgcHJvcGVybHkgaW50ZXJwcmV0ZWQgYXMgY29sdW1ucyBhbmQgbm90IGEgc3RyaW5ncy5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplLmRlZmluZX1cbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplLmNvbH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBjYWxsXG4gICAqIEBwYXJhbSB7YW55fSBhcmdzIEFsbCBmdXJ0aGVyIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuZm59XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgYSB1c2VyJ3MgdXNlcm5hbWUgdG8gdXBwZXIgY2FzZTwvY2FwdGlvbj5cbiAgICogaW5zdGFuY2UudXBkYXRlKHtcbiAgICogICB1c2VybmFtZTogc2VxdWVsaXplLmZuKCd1cHBlcicsIHNlcXVlbGl6ZS5jb2woJ3VzZXJuYW1lJykpXG4gICAqIH0pO1xuICAgKi9cbiAgc3RhdGljIGZuKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5GbihmbiwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBhIGNvbHVtbiBpbiB0aGUgREIsIHRoaXMgYWxsb3dzIHJlZmVyZW5jaW5nIGFub3RoZXIgY29sdW1uIGluIHlvdXIgcXVlcnkuIFRoaXMgaXMgb2Z0ZW4gdXNlZnVsIGluIGNvbmp1bmN0aW9uIHdpdGggYHNlcXVlbGl6ZS5mbmAsIHNpbmNlIHJhdyBzdHJpbmcgYXJndW1lbnRzIHRvIGZuIHdpbGwgYmUgZXNjYXBlZC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplI2ZufVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW5cbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5jb2x9XG4gICAqL1xuICBzdGF0aWMgY29sKGNvbCkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuQ29sKGNvbCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgY2FsbCB0byB0aGUgY2FzdCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbCBUaGUgdmFsdWUgdG8gY2FzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSB0byBjYXN0IGl0IHRvXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUuY2FzdH1cbiAgICovXG4gIHN0YXRpYyBjYXN0KHZhbCwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuQ2FzdCh2YWwsIHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGxpdGVyYWwsIGkuZS4gc29tZXRoaW5nIHRoYXQgd2lsbCBub3QgYmUgZXNjYXBlZC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbCBsaXRlcmFsIHZhbHVlXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUubGl0ZXJhbH1cbiAgICovXG4gIHN0YXRpYyBsaXRlcmFsKHZhbCkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbCh2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIEFORCBxdWVyeVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKlxuICAgKiBAcGFyYW0gey4uLnN0cmluZ3xvYmplY3R9IGFyZ3MgRWFjaCBhcmd1bWVudCB3aWxsIGJlIGpvaW5lZCBieSBBTkRcbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5hbmR9XG4gICAqL1xuICBzdGF0aWMgYW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4geyBbT3AuYW5kXTogYXJncyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIE9SIHF1ZXJ5XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqXG4gICAqIEBwYXJhbSB7Li4uc3RyaW5nfG9iamVjdH0gYXJncyBFYWNoIGFyZ3VtZW50IHdpbGwgYmUgam9pbmVkIGJ5IE9SXG4gICAqIEBzaW5jZSB2Mi4wLjAtZGV2M1xuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemUub3J9XG4gICAqL1xuICBzdGF0aWMgb3IoLi4uYXJncykge1xuICAgIHJldHVybiB7IFtPcC5vcl06IGFyZ3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgbmVzdGVkIHdoZXJlIGNvbmRpdGlvbnMgZm9yIHBvc3RncmVzL3NxbGl0ZS9teXNxbCBqc29uIGRhdGEtdHlwZS5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjb25kaXRpb25zT3JQYXRoIEEgaGFzaCBjb250YWluaW5nIHN0cmluZ3MvbnVtYmVycyBvciBvdGhlciBuZXN0ZWQgaGFzaCwgYSBzdHJpbmcgdXNpbmcgZG90IG5vdGF0aW9uIG9yIGEgc3RyaW5nIHVzaW5nIHBvc3RncmVzL3NxbGl0ZS9teXNxbCBqc29uIHN5bnRheC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IFt2YWx1ZV0gQW4gb3B0aW9uYWwgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LiBQcm9kdWNlcyBhIHN0cmluZyBvZiB0aGUgZm9ybSBcIjxqc29uIHBhdGg+ID0gJzx2YWx1ZT4nXCIuXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5qc29ufVxuICAgKi9cbiAgc3RhdGljIGpzb24oY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkpzb24oY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgd2F5IG9mIHNwZWNpZnlpbmcgYXR0ciA9IGNvbmRpdGlvbi5cbiAgICpcbiAgICogVGhlIGF0dHIgY2FuIGVpdGhlciBiZSBhbiBvYmplY3QgdGFrZW4gZnJvbSBgTW9kZWwucmF3QXR0cmlidXRlc2AgKGZvciBleGFtcGxlIGBNb2RlbC5yYXdBdHRyaWJ1dGVzLmlkYCBvciBgTW9kZWwucmF3QXR0cmlidXRlcy5uYW1lYCkuIFRoZVxuICAgKiBhdHRyaWJ1dGUgc2hvdWxkIGJlIGRlZmluZWQgaW4geW91ciBtb2RlbCBkZWZpbml0aW9uLiBUaGUgYXR0cmlidXRlIGNhbiBhbHNvIGJlIGFuIG9iamVjdCBmcm9tIG9uZSBvZiB0aGUgc2VxdWVsaXplIHV0aWxpdHkgZnVuY3Rpb25zIChgc2VxdWVsaXplLmZuYCwgYHNlcXVlbGl6ZS5jb2xgIGV0Yy4pXG4gICAqXG4gICAqIEZvciBzdHJpbmcgYXR0cmlidXRlcywgdXNlIHRoZSByZWd1bGFyIGB7IHdoZXJlOiB7IGF0dHI6IHNvbWV0aGluZyB9fWAgc3ludGF4LiBJZiB5b3UgZG9uJ3Qgd2FudCB5b3VyIHN0cmluZyB0byBiZSBlc2NhcGVkLCB1c2UgYHNlcXVlbGl6ZS5saXRlcmFsYC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHIgVGhlIGF0dHJpYnV0ZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBhbiBhdHRyaWJ1dGUgb2JqZWN0IGZyb20gYE1vZGVsLnJhd0F0dHJpYnV0ZXNgIG9yIGEgc2VxdWVsaXplIG9iamVjdCwgZm9yIGV4YW1wbGUgYW4gaW5zdGFuY2Ugb2YgYHNlcXVlbGl6ZS5mbmAuIEZvciBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZXMsIHVzZSB0aGUgUE9KTyBzeW50YXhcbiAgICogQHBhcmFtIHtzeW1ib2x9IFtjb21wYXJhdG9yPSdPcC5lcSddIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbG9naWMgVGhlIGNvbmRpdGlvbi4gQ2FuIGJlIGJvdGggYSBzaW1wbHkgdHlwZSwgb3IgYSBmdXJ0aGVyIGNvbmRpdGlvbiAoYG9yYCwgYGFuZGAsIGAubGl0ZXJhbGAgZXRjLilcbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqL1xuICBzdGF0aWMgd2hlcmUoYXR0ciwgY29tcGFyYXRvciwgbG9naWMpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLldoZXJlKGF0dHIsIGNvbXBhcmF0b3IsIGxvZ2ljKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIHRyYW5zYWN0aW9uLiBXaGVuIHVzaW5nIHRyYW5zYWN0aW9ucywgeW91IHNob3VsZCBwYXNzIHRoZSB0cmFuc2FjdGlvbiBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudCBpbiBvcmRlciBmb3IgdGhlIHF1ZXJ5IHRvIGhhcHBlbiB1bmRlciB0aGF0IHRyYW5zYWN0aW9uIEBzZWUge0BsaW5rIFRyYW5zYWN0aW9ufVxuICAgKlxuICAgKiBJZiB5b3UgaGF2ZSBbQ0xTXShodHRwczovL2dpdGh1Yi5jb20vSmVmZi1MZXdpcy9jbHMtaG9va2VkKSBlbmFibGVkLCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHBhc3NlZCB0byBhbnkgcXVlcnkgdGhhdCBydW5zIHdpdGhpbiB0aGUgY2FsbGJhY2tcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdHJ5IHtcbiAgICogICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbigpO1xuICAgKiAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRPbmUoLi4uLCB7IHRyYW5zYWN0aW9uIH0pO1xuICAgKiAgIGF3YWl0IHVzZXIudXBkYXRlKC4uLiwgeyB0cmFuc2FjdGlvbiB9KTtcbiAgICogICBhd2FpdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcbiAgICogfSBjYXRjaCB7XG4gICAqICAgYXdhaXQgdHJhbnNhY3Rpb24ucm9sbGJhY2soKVxuICAgKiB9XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc3ludGF4IGZvciBhdXRvbWF0aWNhbGx5IGNvbW1pdHRpbmcgb3Igcm9sbGluZyBiYWNrIGJhc2VkIG9uIHRoZSBwcm9taXNlIGNoYWluIHJlc29sdXRpb24gaXMgYWxzbyBzdXBwb3J0ZWQ8L2NhcHRpb24+XG4gICAqXG4gICAqIHRyeSB7XG4gICAqICAgYXdhaXQgc2VxdWVsaXplLnRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uID0+IHsgLy8gTm90ZSB0aGF0IHdlIHBhc3MgYSBjYWxsYmFjayByYXRoZXIgdGhhbiBhd2FpdGluZyB0aGUgY2FsbCB3aXRoIG5vIGFyZ3VtZW50c1xuICAgKiAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSguLi4sIHt0cmFuc2FjdGlvbn0pO1xuICAgKiAgICAgYXdhaXQgdXNlci51cGRhdGUoLi4uLCB7dHJhbnNhY3Rpb259KTtcbiAgICogICB9KTtcbiAgICogICAvLyBDb21taXR0ZWRcbiAgICogfSBjYXRjaChlcnIpIHtcbiAgICogICAvLyBSb2xsZWQgYmFja1xuICAgKiAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICogfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5UbyBlbmFibGUgQ0xTLCBhZGQgaXQgZG8geW91ciBwcm9qZWN0LCBjcmVhdGUgYSBuYW1lc3BhY2UgYW5kIHNldCBpdCBvbiB0aGUgc2VxdWVsaXplIGNvbnN0cnVjdG9yOjwvY2FwdGlvbj5cbiAgICpcbiAgICogY29uc3QgY2xzID0gcmVxdWlyZSgnY2xzLWhvb2tlZCcpO1xuICAgKiBjb25zdCBuYW1lc3BhY2UgPSBjbHMuY3JlYXRlTmFtZXNwYWNlKCcuLi4uJyk7XG4gICAqIGNvbnN0IFNlcXVlbGl6ZSA9IHJlcXVpcmUoJ3NlcXVlbGl6ZScpO1xuICAgKiBTZXF1ZWxpemUudXNlQ0xTKG5hbWVzcGFjZSk7XG4gICAqXG4gICAqIC8vIE5vdGUsIHRoYXQgQ0xTIGlzIGVuYWJsZWQgZm9yIGFsbCBzZXF1ZWxpemUgaW5zdGFuY2VzLCBhbmQgYWxsIGluc3RhbmNlcyB3aWxsIHNoYXJlIHRoZSBzYW1lIG5hbWVzcGFjZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9uc10gVHJhbnNhY3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy50eXBlPSdERUZFUlJFRCddIFNlZSBgU2VxdWVsaXplLlRyYW5zYWN0aW9uLlRZUEVTYCBmb3IgcG9zc2libGUgb3B0aW9ucy4gU3FsaXRlIG9ubHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmlzb2xhdGlvbkxldmVsXSBTZWUgYFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTYCBmb3IgcG9zc2libGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5kZWZlcnJhYmxlXSBTZXRzIHRoZSBjb25zdHJhaW50cyB0byBiZSBkZWZlcnJlZCBvciBpbW1lZGlhdGVseSBjaGVja2VkLiBTZWUgYFNlcXVlbGl6ZS5EZWZlcnJhYmxlYC4gUG9zdGdyZVNRTCBPbmx5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbYXV0b0NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIHRyYW5zYWN0aW9uIG9iamVjdCwgYW5kIHNob3VsZCByZXR1cm4gYSBwcm9taXNlLiBJZiB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCwgdGhlIHRyYW5zYWN0aW9uIGNvbW1pdHM7IGlmIHRoZSBwcm9taXNlIHJlamVjdHMsIHRoZSB0cmFuc2FjdGlvbiByb2xscyBiYWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgdHJhbnNhY3Rpb24ob3B0aW9ucywgYXV0b0NhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhdXRvQ2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmICghYXV0b0NhbGxiYWNrKSB7XG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi5wcmVwYXJlRW52aXJvbm1lbnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIGF1dG9DYWxsYmFjayBwcm92aWRlZFxuICAgIHJldHVybiBTZXF1ZWxpemUuX2Nsc1J1bihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5wcmVwYXJlRW52aXJvbm1lbnQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0b0NhbGxiYWNrKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBjb25uZWN0aW9uLCBldmVuIGlmIHdlIGRvbid0IG5lZWQgdG8gcm9sbGJhY2tcbiAgICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNsZWFudXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjApIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIENMUyAoQ29udGludWF0aW9uIExvY2FsIFN0b3JhZ2UpIHdpdGggU2VxdWVsaXplLiBXaXRoIENvbnRpbnVhdGlvblxuICAgKiBMb2NhbCBTdG9yYWdlLCBhbGwgcXVlcmllcyB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNhbGxiYWNrIHdpbGxcbiAgICogYXV0b21hdGljYWxseSByZWNlaXZlIHRoZSB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIENMUyBuYW1lc3BhY2UgcHJvdmlkZWQgaXMgc3RvcmVkIGFzIGBTZXF1ZWxpemUuX2Nsc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5zIENMUyBuYW1lc3BhY2VcbiAgICogQHJldHVybnMge29iamVjdH0gU2VxdWVsaXplIGNvbnN0cnVjdG9yXG4gICAqL1xuICBzdGF0aWMgdXNlQ0xTKG5zKSB7XG4gICAgLy8gY2hlY2sgYG5zYCBpcyB2YWxpZCBDTFMgbmFtZXNwYWNlXG4gICAgaWYgKCFucyB8fCB0eXBlb2YgbnMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBucy5iaW5kICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBucy5ydW4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIENMUyBuYW1lc3BhY2UnKTtcblxuICAgIC8vIHNhdmUgbmFtZXNwYWNlIGFzIGBTZXF1ZWxpemUuX2Nsc2BcbiAgICB0aGlzLl9jbHMgPSBucztcblxuICAgIC8vIHJldHVybiBTZXF1ZWxpemUgZm9yIGNoYWluaW5nXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGZ1bmN0aW9uIGluIENMUyBjb250ZXh0LlxuICAgKiBJZiBubyBDTFMgY29udGV4dCBpbiB1c2UsIGp1c3QgcnVucyB0aGUgZnVuY3Rpb24gbm9ybWFsbHlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gcnVuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm4gdmFsdWUgb2YgZnVuY3Rpb25cbiAgICovXG4gIHN0YXRpYyBfY2xzUnVuKGZuKSB7XG4gICAgY29uc3QgbnMgPSBTZXF1ZWxpemUuX2NscztcbiAgICBpZiAoIW5zKSByZXR1cm4gZm4oKTtcblxuICAgIGxldCByZXM7XG4gICAgbnMucnVuKGNvbnRleHQgPT4gcmVzID0gZm4oY29udGV4dCkpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBsb2coLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zO1xuXG4gICAgY29uc3QgbGFzdCA9IF8ubGFzdChhcmdzKTtcblxuICAgIGlmIChsYXN0ICYmIF8uaXNQbGFpbk9iamVjdChsYXN0KSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdCwgJ2xvZ2dpbmcnKSkge1xuICAgICAgb3B0aW9ucyA9IGxhc3Q7XG5cbiAgICAgIC8vIHJlbW92ZSBvcHRpb25zIGZyb20gc2V0IG9mIGxvZ2dlZCBhcmd1bWVudHMgaWYgb3B0aW9ucy5sb2dnaW5nIGlzIGVxdWFsIHRvIGNvbnNvbGUubG9nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZyA9PT0gY29uc29sZS5sb2cpIHtcbiAgICAgICAgYXJncy5zcGxpY2UoYXJncy5sZW5ndGggLSAxLCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2dnaW5nKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIG9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWNvbmQgYXJndW1lbnQgaXMgc3FsLXRpbWluZ3MsIHdoZW4gYmVuY2htYXJraW5nIG9wdGlvbiBlbmFibGVkXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuYmVuY2htYXJrIHx8IG9wdGlvbnMuYmVuY2htYXJrKSAmJiBvcHRpb25zLmxvZ2dpbmcgPT09IGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGFyZ3MgPSBbYCR7YXJnc1swXX0gRWxhcHNlZCB0aW1lOiAke2FyZ3NbMV19bXNgXTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5sb2dnaW5nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSBhbGwgY29ubmVjdGlvbnMgdXNlZCBieSB0aGlzIHNlcXVlbGl6ZSBpbnN0YW5jZSwgYW5kIGZyZWUgYWxsIHJlZmVyZW5jZXMgc28gdGhlIGluc3RhbmNlIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICpcbiAgICogTm9ybWFsbHkgdGhpcyBpcyBkb25lIG9uIHByb2Nlc3MgZXhpdCwgc28geW91IG9ubHkgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGlmIHlvdSBhcmUgY3JlYXRpbmcgbXVsdGlwbGUgaW5zdGFuY2VzLCBhbmQgd2FudFxuICAgKiB0byBnYXJiYWdlIGNvbGxlY3Qgc29tZSBvZiB0aGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlKCk7XG4gIH1cblxuICBub3JtYWxpemVEYXRhVHlwZShUeXBlKSB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgVHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUeXBlKCkgOiBUeXBlO1xuICAgIGNvbnN0IGRpYWxlY3RUeXBlcyA9IHRoaXMuZGlhbGVjdC5EYXRhVHlwZXMgfHwge307XG5cbiAgICBpZiAoZGlhbGVjdFR5cGVzW3R5cGUua2V5XSkge1xuICAgICAgdHlwZSA9IGRpYWxlY3RUeXBlc1t0eXBlLmtleV0uZXh0ZW5kKHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZKSB7XG4gICAgICBpZiAoIXR5cGUudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FSUkFZIGlzIG1pc3NpbmcgdHlwZSBkZWZpbml0aW9uIGZvciBpdHMgdmFsdWVzLicpO1xuICAgICAgfVxuICAgICAgaWYgKGRpYWxlY3RUeXBlc1t0eXBlLnR5cGUua2V5XSkge1xuICAgICAgICB0eXBlLnR5cGUgPSBkaWFsZWN0VHlwZXNbdHlwZS50eXBlLmtleV0uZXh0ZW5kKHR5cGUudHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0geyB0eXBlOiBhdHRyaWJ1dGUgfTtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJpYnV0ZS50eXBlKSByZXR1cm4gYXR0cmlidXRlO1xuXG4gICAgYXR0cmlidXRlLnR5cGUgPSB0aGlzLm5vcm1hbGl6ZURhdGFUeXBlKGF0dHJpYnV0ZS50eXBlKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAoXG4gICAgICAgIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPT09IERhdGFUeXBlcy5OT1cgfHxcbiAgICAgICAgICBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID09PSBEYXRhVHlwZXMuVVVJRFYxIHx8XG4gICAgICAgICAgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9PT0gRGF0YVR5cGVzLlVVSURWNFxuICAgICAgKSkge1xuICAgICAgICBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID0gbmV3IGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgLy8gVGhlIEVOVU0gaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIHR5cGUgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhbHVlc1xuICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlLnR5cGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUub3B0aW9ucy52YWx1ZXMgPSBhdHRyaWJ1dGUudmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdHRyaWJ1dGUudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlcyBmb3IgRU5VTSBoYXZlIG5vdCBiZWVuIGRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgfVxufVxuXG4vLyBBbGlhc2VzXG5TZXF1ZWxpemUucHJvdG90eXBlLmZuID0gU2VxdWVsaXplLmZuO1xuU2VxdWVsaXplLnByb3RvdHlwZS5jb2wgPSBTZXF1ZWxpemUuY29sO1xuU2VxdWVsaXplLnByb3RvdHlwZS5jYXN0ID0gU2VxdWVsaXplLmNhc3Q7XG5TZXF1ZWxpemUucHJvdG90eXBlLmxpdGVyYWwgPSBTZXF1ZWxpemUubGl0ZXJhbDtcblNlcXVlbGl6ZS5wcm90b3R5cGUuYW5kID0gU2VxdWVsaXplLmFuZDtcblNlcXVlbGl6ZS5wcm90b3R5cGUub3IgPSBTZXF1ZWxpemUub3I7XG5TZXF1ZWxpemUucHJvdG90eXBlLmpzb24gPSBTZXF1ZWxpemUuanNvbjtcblNlcXVlbGl6ZS5wcm90b3R5cGUud2hlcmUgPSBTZXF1ZWxpemUud2hlcmU7XG5TZXF1ZWxpemUucHJvdG90eXBlLnZhbGlkYXRlID0gU2VxdWVsaXplLnByb3RvdHlwZS5hdXRoZW50aWNhdGU7XG5cbi8qKlxuICogU2VxdWVsaXplIHZlcnNpb24gbnVtYmVyLlxuICovXG5TZXF1ZWxpemUudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cblNlcXVlbGl6ZS5vcHRpb25zID0geyBob29rczoge30gfTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5TZXF1ZWxpemUuVXRpbHMgPSBVdGlscztcblxuLyoqXG4gKiBPcGVyYXRvcnMgc3ltYm9scyB0byBiZSB1c2VkIGZvciBxdWVyeWluZyBkYXRhXG4gKlxuICogQHNlZSAge0BsaW5rIE9wZXJhdG9yc31cbiAqL1xuU2VxdWVsaXplLk9wID0gT3A7XG5cbi8qKlxuICogQXZhaWxhYmxlIHRhYmxlIGhpbnRzIHRvIGJlIHVzZWQgZm9yIHF1ZXJ5aW5nIGRhdGEgaW4gbXNzcWwgZm9yIHRhYmxlIGhpbnRzXG4gKlxuICogQHNlZSB7QGxpbmsgVGFibGVIaW50c31cbiAqL1xuU2VxdWVsaXplLlRhYmxlSGludHMgPSBUYWJsZUhpbnRzO1xuXG4vKipcbiAqIEF2YWlsYWJsZSBpbmRleCBoaW50cyB0byBiZSB1c2VkIGZvciBxdWVyeWluZyBkYXRhIGluIG15c3FsIGZvciBpbmRleCBoaW50c1xuICpcbiAqIEBzZWUge0BsaW5rIEluZGV4SGludHN9XG4gKi9cblNlcXVlbGl6ZS5JbmRleEhpbnRzID0gSW5kZXhIaW50cztcblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byB0aGUgc2VxdWVsaXplIHRyYW5zYWN0aW9uIGNsYXNzLiBVc2UgdGhpcyB0byBhY2Nlc3MgaXNvbGF0aW9uTGV2ZWxzIGFuZCB0eXBlcyB3aGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb25cbiAqXG4gKiBAc2VlIHtAbGluayBUcmFuc2FjdGlvbn1cbiAqIEBzZWUge0BsaW5rIFNlcXVlbGl6ZS50cmFuc2FjdGlvbn1cbiAqL1xuU2VxdWVsaXplLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gU2VxdWVsaXplIGNvbnN0cnVjdG9yIGZyb20gc2VxdWVsaXplLiBVc2VmdWwgZm9yIGFjY2Vzc2luZyBEYXRhVHlwZXMsIEVycm9ycyBldGMuXG4gKlxuICogQHNlZSB7QGxpbmsgU2VxdWVsaXplfVxuICovXG5TZXF1ZWxpemUucHJvdG90eXBlLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcblxuLyoqXG4gKiBBdmFpbGFibGUgcXVlcnkgdHlwZXMgZm9yIHVzZSB3aXRoIGBzZXF1ZWxpemUucXVlcnlgXG4gKlxuICogQHNlZSB7QGxpbmsgUXVlcnlUeXBlc31cbiAqL1xuU2VxdWVsaXplLnByb3RvdHlwZS5RdWVyeVR5cGVzID0gU2VxdWVsaXplLlF1ZXJ5VHlwZXMgPSBRdWVyeVR5cGVzO1xuXG4vKipcbiAqIEV4cG9zZXMgdGhlIHZhbGlkYXRvci5qcyBvYmplY3QsIHNvIHlvdSBjYW4gZXh0ZW5kIGl0IHdpdGggY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBUaGUgdmFsaWRhdG9yIGlzIGV4cG9zZWQgYm90aCBvbiB0aGUgaW5zdGFuY2UsIGFuZCBvbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qc1xuICovXG5TZXF1ZWxpemUucHJvdG90eXBlLlZhbGlkYXRvciA9IFNlcXVlbGl6ZS5WYWxpZGF0b3IgPSBWYWxpZGF0b3I7XG5cblNlcXVlbGl6ZS5Nb2RlbCA9IE1vZGVsO1xuXG5TZXF1ZWxpemUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuZm9yIChjb25zdCBkYXRhVHlwZSBpbiBEYXRhVHlwZXMpIHtcbiAgU2VxdWVsaXplW2RhdGFUeXBlXSA9IERhdGFUeXBlc1tkYXRhVHlwZV07XG59XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gdGhlIGRlZmVycmFibGUgY29sbGVjdGlvbi4gVXNlIHRoaXMgdG8gYWNjZXNzIHRoZSBkaWZmZXJlbnQgZGVmZXJyYWJsZSBvcHRpb25zLlxuICpcbiAqIEBzZWUge0BsaW5rIFRyYW5zYWN0aW9uLkRlZmVycmFibGV9XG4gKiBAc2VlIHtAbGluayBTZXF1ZWxpemUjdHJhbnNhY3Rpb259XG4gKi9cblNlcXVlbGl6ZS5EZWZlcnJhYmxlID0gRGVmZXJyYWJsZTtcblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byB0aGUgc2VxdWVsaXplIGFzc29jaWF0aW9uIGNsYXNzLlxuICpcbiAqIEBzZWUge0BsaW5rIEFzc29jaWF0aW9ufVxuICovXG5TZXF1ZWxpemUucHJvdG90eXBlLkFzc29jaWF0aW9uID0gU2VxdWVsaXplLkFzc29jaWF0aW9uID0gQXNzb2NpYXRpb247XG5cbi8qKlxuICogUHJvdmlkZSBhbHRlcm5hdGl2ZSB2ZXJzaW9uIG9mIGBpbmZsZWN0aW9uYCBtb2R1bGUgdG8gYmUgdXNlZCBieSBgVXRpbHMucGx1cmFsaXplYCBldGMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IF9pbmZsZWN0aW9uIC0gYGluZmxlY3Rpb25gIG1vZHVsZVxuICovXG5TZXF1ZWxpemUudXNlSW5mbGVjdGlvbiA9IFV0aWxzLnVzZUluZmxlY3Rpb247XG5cbi8qKlxuICogQWxsb3cgaG9va3MgdG8gYmUgZGVmaW5lZCBvbiBTZXF1ZWxpemUgKyBvbiBzZXF1ZWxpemUgaW5zdGFuY2UgYXMgdW5pdmVyc2FsIGhvb2tzIHRvIHJ1biBvbiBhbGwgbW9kZWxzXG4gKiBhbmQgb24gU2VxdWVsaXplL3NlcXVlbGl6ZSBtZXRob2RzIGUuZy4gU2VxdWVsaXplKCksIFNlcXVlbGl6ZSNkZWZpbmUoKVxuICovXG5Ib29rcy5hcHBseVRvKFNlcXVlbGl6ZSk7XG5Ib29rcy5hcHBseVRvKFNlcXVlbGl6ZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEV4cG9zZSB2YXJpb3VzIGVycm9ycyBhdmFpbGFibGVcbiAqL1xuXG4vLyBleHBvc2UgYWxpYXMgdG8gQmFzZUVycm9yXG5TZXF1ZWxpemUuRXJyb3IgPSBzZXF1ZWxpemVFcnJvcnMuQmFzZUVycm9yO1xuXG5mb3IgKGNvbnN0IGVycm9yIG9mIE9iamVjdC5rZXlzKHNlcXVlbGl6ZUVycm9ycykpIHtcbiAgU2VxdWVsaXplW2Vycm9yXSA9IHNlcXVlbGl6ZUVycm9yc1tlcnJvcl07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVsaXplO1xubW9kdWxlLmV4cG9ydHMuU2VxdWVsaXplID0gU2VxdWVsaXplO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFNlcXVlbGl6ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi91dGlscy9sb2dnZXInKTtcblxuZnVuY3Rpb24gYXJyYXlUb0xpc3QoYXJyYXksIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoc3FsLCB2YWwsIGkpID0+IHtcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgc3FsICs9ICcsICc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHNxbCArPSBgKCR7YXJyYXlUb0xpc3QodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3FsICs9IGVzY2FwZSh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9LCAnJyk7XG59XG5leHBvcnRzLmFycmF5VG9MaXN0ID0gYXJyYXlUb0xpc3Q7XG5cbmZ1bmN0aW9uIGVzY2FwZSh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpIHtcbiAgbGV0IHByZXBlbmROID0gZmFsc2U7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ05VTEwnO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIC8vIFNRTGl0ZSBkb2Vzbid0IGhhdmUgdHJ1ZS9mYWxzZSBzdXBwb3J0LiBNeVNRTCBhbGlhc2VzIHRydWUvZmFsc2UgdG8gMS8wXG4gICAgLy8gZm9yIHVzLiBQb3N0Z3JlcyBhY3R1YWxseSBoYXMgYSBib29sZWFuIHR5cGUgd2l0aCB0cnVlL2ZhbHNlIGxpdGVyYWxzLFxuICAgIC8vIGJ1dCBzZXF1ZWxpemUgZG9lc24ndCB1c2UgaXQgeWV0LlxuICAgICAgaWYgKGRpYWxlY3QgPT09ICdzcWxpdGUnIHx8IGRpYWxlY3QgPT09ICdtc3NxbCcpIHtcbiAgICAgICAgcmV0dXJuICshIXZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoISF2YWwpLnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIC8vIEluIG1zc3FsLCBwcmVwZW5kIE4gdG8gYWxsIHF1b3RlZCB2YWxzIHdoaWNoIGFyZSBvcmlnaW5hbGx5IGEgc3RyaW5nIChmb3JcbiAgICAvLyB1bmljb2RlIGNvbXBhdGliaWxpdHkpXG4gICAgICBwcmVwZW5kTiA9IGRpYWxlY3QgPT09ICdtc3NxbCc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gZGF0YVR5cGVzW2RpYWxlY3RdLkRBVEUucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwsIHsgdGltZXpvbmU6IHRpbWVab25lIH0pO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgaWYgKGRhdGFUeXBlc1tkaWFsZWN0XS5CTE9CKSB7XG4gICAgICByZXR1cm4gZGF0YVR5cGVzW2RpYWxlY3RdLkJMT0IucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhVHlwZXMuQkxPQi5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgcGFydGlhbEVzY2FwZSA9IGVzY1ZhbCA9PiBlc2NhcGUoZXNjVmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KTtcbiAgICBpZiAoZGlhbGVjdCA9PT0gJ3Bvc3RncmVzJyAmJiAhZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZGF0YVR5cGVzLkFSUkFZLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsLCB7IGVzY2FwZTogcGFydGlhbEVzY2FwZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG9MaXN0KHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCk7XG4gIH1cblxuICBpZiAoIXZhbC5yZXBsYWNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlICR7bG9nZ2VyLmluc3BlY3QodmFsKX1gKTtcbiAgfVxuXG4gIGlmIChkaWFsZWN0ID09PSAncG9zdGdyZXMnIHx8IGRpYWxlY3QgPT09ICdzcWxpdGUnIHx8IGRpYWxlY3QgPT09ICdtc3NxbCcpIHtcbiAgICAvLyBodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOC4yL3N0YXRpYy9zcWwtc3ludGF4LWxleGljYWwuaHRtbCNTUUwtU1lOVEFYLVNUUklOR1NcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS82MDM1NzIvMTMwNTk4XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgXCInJ1wiKTtcblxuICAgIGlmIChkaWFsZWN0ID09PSAncG9zdGdyZXMnKSB7XG4gICAgICAvLyBudWxsIGNoYXJhY3RlciBpcyBub3QgYWxsb3dlZCBpbiBQb3N0Z3Jlc1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvW1xcMFxcblxcclxcYlxcdFxcXFwnXCJcXHgxYV0vZywgcyA9PiB7XG4gICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAnXFwwJzogcmV0dXJuICdcXFxcMCc7XG4gICAgICAgIGNhc2UgJ1xcbic6IHJldHVybiAnXFxcXG4nO1xuICAgICAgICBjYXNlICdcXHInOiByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgY2FzZSAnXFxiJzogcmV0dXJuICdcXFxcYic7XG4gICAgICAgIGNhc2UgJ1xcdCc6IHJldHVybiAnXFxcXHQnO1xuICAgICAgICBjYXNlICdcXHgxYSc6IHJldHVybiAnXFxcXFonO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gYFxcXFwke3N9YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYCR7KHByZXBlbmROID8gXCJOJ1wiIDogXCInXCIpICsgdmFsfSdgO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG5cbmZ1bmN0aW9uIGZvcm1hdChzcWwsIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QpIHtcbiAgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlcyk7XG5cbiAgaWYgKHR5cGVvZiBzcWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNRTCBzdHJpbmcgcHJvdmlkZWQ6ICR7c3FsfWApO1xuICB9XG5cbiAgcmV0dXJuIHNxbC5yZXBsYWNlKC9cXD8vZywgbWF0Y2ggPT4ge1xuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGUodmFsdWVzLnNoaWZ0KCksIHRpbWVab25lLCBkaWFsZWN0LCB0cnVlKTtcbiAgfSk7XG59XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcblxuZnVuY3Rpb24gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCkge1xuICByZXR1cm4gc3FsLnJlcGxhY2UoLzorKD8hXFxkKShcXHcrKS9nLCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICgncG9zdGdyZXMnID09PSBkaWFsZWN0ICYmICc6OicgPT09IHZhbHVlLnNsaWNlKDAsIDIpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBlc2NhcGUodmFsdWVzW2tleV0sIHRpbWVab25lLCBkaWFsZWN0LCB0cnVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lZCBwYXJhbWV0ZXIgXCIke3ZhbHVlfVwiIGhhcyBubyB2YWx1ZSBpbiB0aGUgZ2l2ZW4gb2JqZWN0LmApO1xuICB9KTtcbn1cbmV4cG9ydHMuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzID0gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVudW0gb2YgdGFibGUgaGludHMgdG8gYmUgdXNlZCBpbiBtc3NxbCBmb3IgcXVlcnlpbmcgd2l0aCB0YWJsZSBoaW50c1xuICpcbiAqIEBwcm9wZXJ0eSBOT0xPQ0tcbiAqIEBwcm9wZXJ0eSBSRUFEVU5DT01NSVRURURcbiAqIEBwcm9wZXJ0eSBVUERMT0NLXG4gKiBAcHJvcGVydHkgUkVQRUFUQUJMRVJFQURcbiAqIEBwcm9wZXJ0eSBTRVJJQUxJWkFCTEVcbiAqIEBwcm9wZXJ0eSBSRUFEQ09NTUlUVEVEXG4gKiBAcHJvcGVydHkgVEFCTE9DS1xuICogQHByb3BlcnR5IFRBQkxPQ0tYXG4gKiBAcHJvcGVydHkgUEFHTE9DS1xuICogQHByb3BlcnR5IFJPV0xPQ0tcbiAqIEBwcm9wZXJ0eSBOT1dBSVRcbiAqIEBwcm9wZXJ0eSBSRUFEUEFTVFxuICogQHByb3BlcnR5IFhMT0NLXG4gKiBAcHJvcGVydHkgU05BUFNIT1RcbiAqIEBwcm9wZXJ0eSBOT0VYUEFORFxuICovXG5jb25zdCBUYWJsZUhpbnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgTk9MT0NLOiAnTk9MT0NLJyxcbiAgUkVBRFVOQ09NTUlUVEVEOiAnUkVBRFVOQ09NTUlUVEVEJyxcbiAgVVBETE9DSzogJ1VQRExPQ0snLFxuICBSRVBFQVRBQkxFUkVBRDogJ1JFUEVBVEFCTEVSRUFEJyxcbiAgU0VSSUFMSVpBQkxFOiAnU0VSSUFMSVpBQkxFJyxcbiAgUkVBRENPTU1JVFRFRDogJ1JFQURDT01NSVRURUQnLFxuICBUQUJMT0NLOiAnVEFCTE9DSycsXG4gIFRBQkxPQ0tYOiAnVEFCTE9DS1gnLFxuICBQQUdMT0NLOiAnUEFHTE9DSycsXG4gIFJPV0xPQ0s6ICdST1dMT0NLJyxcbiAgTk9XQUlUOiAnTk9XQUlUJyxcbiAgUkVBRFBBU1Q6ICdSRUFEUEFTVCcsXG4gIFhMT0NLOiAnWExPQ0snLFxuICBTTkFQU0hPVDogJ1NOQVBTSE9UJyxcbiAgTk9FWFBBTkQ6ICdOT0VYUEFORCdcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIHRyYW5zYWN0aW9uIG9iamVjdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGEgcnVubmluZyB0cmFuc2FjdGlvbi5cbiAqIEl0IGlzIGNyZWF0ZWQgYnkgY2FsbGluZyBgU2VxdWVsaXplLnRyYW5zYWN0aW9uKClgLlxuICogVG8gcnVuIGEgcXVlcnkgdW5kZXIgYSB0cmFuc2FjdGlvbiwgeW91IHNob3VsZCBwYXNzIHRoZSB0cmFuc2FjdGlvbiBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKiBAc2VlIHtAbGluayBTZXF1ZWxpemUudHJhbnNhY3Rpb259XG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtTZXF1ZWxpemV9IHNlcXVlbGl6ZSBBIGNvbmZpZ3VyZWQgc2VxdWVsaXplIEluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnR5cGVdIFNldHMgdGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uLiBTcWxpdGUgb25seVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaXNvbGF0aW9uTGV2ZWxdIFNldHMgdGhlIGlzb2xhdGlvbiBsZXZlbCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZlcnJhYmxlXSBTZXRzIHRoZSBjb25zdHJhaW50cyB0byBiZSBkZWZlcnJlZCBvciBpbW1lZGlhdGVseSBjaGVja2VkLiBQb3N0Z3JlU1FMIG9ubHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuc2F2ZXBvaW50cyA9IFtdO1xuICAgIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MgPSBbXTtcblxuICAgIC8vIGdldCBkaWFsZWN0IHNwZWNpZmljIHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAgICBjb25zdCBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQgPSB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmdlbmVyYXRlVHJhbnNhY3Rpb25JZDtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IHNlcXVlbGl6ZS5vcHRpb25zLnRyYW5zYWN0aW9uVHlwZSxcbiAgICAgIGlzb2xhdGlvbkxldmVsOiBzZXF1ZWxpemUub3B0aW9ucy5pc29sYXRpb25MZXZlbCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb247XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnBhcmVudC5pZDtcbiAgICAgIHRoaXMucGFyZW50LnNhdmVwb2ludHMucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMuaWR9LXNwLSR7dGhpcy5wYXJlbnQuc2F2ZXBvaW50cy5sZW5ndGh9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZCA9IHRoaXMubmFtZSA9IGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ29tbWl0IHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNvbW1pdCgpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBjYW5ub3QgYmUgY29tbWl0dGVkIGJlY2F1c2UgaXQgaGFzIGJlZW4gZmluaXNoZWQgd2l0aCBzdGF0ZTogJHt0aGlzLmZpbmlzaGVkfWApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5jb21taXRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmZpbmlzaGVkID0gJ2NvbW1pdCc7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLl9hZnRlckNvbW1pdEhvb2tzKSB7XG4gICAgICAgIGF3YWl0IGhvb2suYXBwbHkodGhpcywgW3RoaXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm9sbGJhY2sgKGFib3J0KSB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyByb2xsYmFjaygpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcm9sbGVkIGJhY2sgYmVjYXVzZSBpdCBoYXMgYmVlbiBmaW5pc2hlZCB3aXRoIHN0YXRlOiAke3RoaXMuZmluaXNoZWR9YCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gY2Fubm90IGJlIHJvbGxlZCBiYWNrIGJlY2F1c2UgaXQgbmV2ZXIgc3RhcnRlZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpc1xuICAgICAgICAuc2VxdWVsaXplXG4gICAgICAgIC5nZXRRdWVyeUludGVyZmFjZSgpXG4gICAgICAgIC5yb2xsYmFja1RyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gYWNxdWlyZSBhIGNvbm5lY3Rpb24gdG8gdXNlIGFuZCBzZXQgdGhlIGNvcnJlY3Qgb3B0aW9ucyBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICogV2Ugc2hvdWxkIGVuc3VyZSBhbGwgb2YgdGhlIGVudmlyb25tZW50IHRoYXQncyBzZXQgdXAgaXMgY2xlYW5lZCB1cCBpbiBgY2xlYW51cCgpYCBiZWxvdy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VDTFMgRGVmYXVsdHMgdG8gdHJ1ZTogVXNlIENMUyAoQ29udGludWF0aW9uIExvY2FsIFN0b3JhZ2UpIHdpdGggU2VxdWVsaXplLiBXaXRoIENMUywgYWxsIHF1ZXJpZXMgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjYWxsYmFjayB3aWxsIGF1dG9tYXRpY2FsbHkgcmVjZWl2ZSB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHByZXBhcmVFbnZpcm9ubWVudCh1c2VDTFMpIHtcbiAgICBsZXQgY29ubmVjdGlvblByb21pc2U7XG5cbiAgICBpZiAodXNlQ0xTID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUNMUyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25uZWN0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhcmVudC5jb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWNxdWlyZU9wdGlvbnMgPSB7IHV1aWQ6IHRoaXMuaWQgfTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgYWNxdWlyZU9wdGlvbnMudHlwZSA9ICdTRUxFQ1QnO1xuICAgICAgfVxuICAgICAgY29ubmVjdGlvblByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKGFjcXVpcmVPcHRpb25zKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBjb25uZWN0aW9uUHJvbWlzZTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuY29ubmVjdGlvbi51dWlkID0gdGhpcy5pZDtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmJlZ2luKCk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNldERlZmVycmFibGUoKTtcbiAgICB9IGNhdGNoIChzZXR1cEVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5yb2xsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgc2V0dXBFcnI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5zYWZlLWZpbmFsbHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXNlQ0xTICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuc2V0KCd0cmFuc2FjdGlvbicsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBzZXREZWZlcnJhYmxlKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVmZXJyYWJsZSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXNcbiAgICAgICAgLnNlcXVlbGl6ZVxuICAgICAgICAuZ2V0UXVlcnlJbnRlcmZhY2UoKVxuICAgICAgICAuZGVmZXJDb25zdHJhaW50cyh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGJlZ2luKCkge1xuICAgIGNvbnN0IHF1ZXJ5SW50ZXJmYWNlID0gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKTtcblxuICAgIGlmICggdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5zdXBwb3J0cy5zZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbiApIHtcbiAgICAgIGF3YWl0IHF1ZXJ5SW50ZXJmYWNlLnN0YXJ0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHJldHVybiBxdWVyeUludGVyZmFjZS5zZXRJc29sYXRpb25MZXZlbCh0aGlzLCB0aGlzLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYXdhaXQgcXVlcnlJbnRlcmZhY2Uuc2V0SXNvbGF0aW9uTGV2ZWwodGhpcywgdGhpcy5vcHRpb25zLmlzb2xhdGlvbkxldmVsLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHF1ZXJ5SW50ZXJmYWNlLnN0YXJ0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIGNsZWFudXAoKSB7XG4gICAgLy8gRG9uJ3QgcmVsZWFzZSB0aGUgY29ubmVjdGlvbiBpZiB0aGVyZSdzIGEgcGFyZW50IHRyYW5zYWN0aW9uIG9yXG4gICAgLy8gaWYgd2UndmUgYWxyZWFkeSBjbGVhbmVkIHVwXG4gICAgaWYgKHRoaXMucGFyZW50IHx8IHRoaXMuY29ubmVjdGlvbi51dWlkID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHRoaXMuX2NsZWFyQ2xzKCk7XG4gICAgY29uc3QgcmVzID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIucmVsZWFzZUNvbm5lY3Rpb24odGhpcy5jb25uZWN0aW9uKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24udXVpZCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgX2NsZWFyQ2xzKCkge1xuICAgIGNvbnN0IGNscyA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHM7XG5cbiAgICBpZiAoY2xzKSB7XG4gICAgICBpZiAoY2xzLmdldCgndHJhbnNhY3Rpb24nKSA9PT0gdGhpcykge1xuICAgICAgICBjbHMuc2V0KCd0cmFuc2FjdGlvbicsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgYSB0cmFuc2FjdGlvbiBpcyBjb21taXR0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGNvbW1pdHRlZCB0cmFuc2FjdGlvblxuICAgKiBAbmFtZSBhZnRlckNvbW1pdFxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLlRyYW5zYWN0aW9uXG4gICAqL1xuICBhZnRlckNvbW1pdChmbikge1xuICAgIGlmICghZm4gfHwgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZm5cIiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fYWZ0ZXJDb21taXRIb29rcy5wdXNoKGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlcyBjYW4gYmUgc2V0IHBlci10cmFuc2FjdGlvbiBieSBwYXNzaW5nIGBvcHRpb25zLnR5cGVgIHRvIGBzZXF1ZWxpemUudHJhbnNhY3Rpb25gLlxuICAgKiBEZWZhdWx0IHRvIGBERUZFUlJFRGAgYnV0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdHlwZSBieSBwYXNzaW5nIGBvcHRpb25zLnRyYW5zYWN0aW9uVHlwZWAgaW4gYG5ldyBTZXF1ZWxpemVgLlxuICAgKiBTcWxpdGUgb25seS5cbiAgICpcbiAgICogUGFzcyBpbiB0aGUgZGVzaXJlZCBsZXZlbCBhcyB0aGUgZmlyc3QgYXJndW1lbnQ6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRyeSB7XG4gICAqICAgYXdhaXQgc2VxdWVsaXplLnRyYW5zYWN0aW9uKHsgdHlwZTogU2VxdWVsaXplLlRyYW5zYWN0aW9uLlRZUEVTLkVYQ0xVU0lWRSB9LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAqICAgICAgLy8geW91ciB0cmFuc2FjdGlvbnNcbiAgICogICB9KTtcbiAgICogICAvLyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBjb21taXR0ZWQuIERvIHNvbWV0aGluZyBhZnRlciB0aGUgY29tbWl0IGlmIHJlcXVpcmVkLlxuICAgKiB9IGNhdGNoKGVycikge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBlcnIuXG4gICAqIH1cbiAgICpcbiAgICogQHByb3BlcnR5IERFRkVSUkVEXG4gICAqIEBwcm9wZXJ0eSBJTU1FRElBVEVcbiAgICogQHByb3BlcnR5IEVYQ0xVU0lWRVxuICAgKi9cbiAgc3RhdGljIGdldCBUWVBFUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgREVGRVJSRUQ6ICdERUZFUlJFRCcsXG4gICAgICBJTU1FRElBVEU6ICdJTU1FRElBVEUnLFxuICAgICAgRVhDTFVTSVZFOiAnRVhDTFVTSVZFJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSXNvbGF0aW9uIGxldmVscyBjYW4gYmUgc2V0IHBlci10cmFuc2FjdGlvbiBieSBwYXNzaW5nIGBvcHRpb25zLmlzb2xhdGlvbkxldmVsYCB0byBgc2VxdWVsaXplLnRyYW5zYWN0aW9uYC5cbiAgICogU2VxdWVsaXplIHVzZXMgdGhlIGRlZmF1bHQgaXNvbGF0aW9uIGxldmVsIG9mIHRoZSBkYXRhYmFzZSwgeW91IGNhbiBvdmVycmlkZSB0aGlzIGJ5IHBhc3NpbmcgYG9wdGlvbnMuaXNvbGF0aW9uTGV2ZWxgIGluIFNlcXVlbGl6ZSBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKlxuICAgKiBQYXNzIGluIHRoZSBkZXNpcmVkIGxldmVsIGFzIHRoZSBmaXJzdCBhcmd1bWVudDpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdHJ5IHtcbiAgICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXF1ZWxpemUudHJhbnNhY3Rpb24oe2lzb2xhdGlvbkxldmVsOiBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5TRVJJQUxJWkFCTEV9LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAqICAgICAvLyB5b3VyIHRyYW5zYWN0aW9uc1xuICAgKiAgIH0pO1xuICAgKiAgIC8vIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGNvbW1pdHRlZC4gRG8gc29tZXRoaW5nIGFmdGVyIHRoZSBjb21taXQgaWYgcmVxdWlyZWQuXG4gICAqIH0gY2F0Y2goZXJyKSB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGVyci5cbiAgICogfVxuICAgKlxuICAgKiBAcHJvcGVydHkgUkVBRF9VTkNPTU1JVFRFRFxuICAgKiBAcHJvcGVydHkgUkVBRF9DT01NSVRURURcbiAgICogQHByb3BlcnR5IFJFUEVBVEFCTEVfUkVBRFxuICAgKiBAcHJvcGVydHkgU0VSSUFMSVpBQkxFXG4gICAqL1xuICBzdGF0aWMgZ2V0IElTT0xBVElPTl9MRVZFTFMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJFQURfVU5DT01NSVRURUQ6ICdSRUFEIFVOQ09NTUlUVEVEJyxcbiAgICAgIFJFQURfQ09NTUlUVEVEOiAnUkVBRCBDT01NSVRURUQnLFxuICAgICAgUkVQRUFUQUJMRV9SRUFEOiAnUkVQRUFUQUJMRSBSRUFEJyxcbiAgICAgIFNFUklBTElaQUJMRTogJ1NFUklBTElaQUJMRSdcbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogUG9zc2libGUgb3B0aW9ucyBmb3Igcm93IGxvY2tpbmcuIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgZmluZGAgY2FsbHM6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHQxIGlzIGEgdHJhbnNhY3Rpb25cbiAgICogTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IC4uLixcbiAgICogICB0cmFuc2FjdGlvbjogdDEsXG4gICAqICAgbG9jazogdDEuTE9DSy4uLlxuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UG9zdGdyZXMgYWxzbyBzdXBwb3J0cyBzcGVjaWZpYyBsb2NrcyB3aGlsZSBlYWdlciBsb2FkaW5nIGJ5IHVzaW5nIE9GOjwvY2FwdGlvbj5cbiAgICogVXNlck1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiAuLi4sXG4gICAqICAgaW5jbHVkZTogW1Rhc2tNb2RlbCwgLi4uXSxcbiAgICogICB0cmFuc2FjdGlvbjogdDEsXG4gICAqICAgbG9jazoge1xuICAgKiAgICAgbGV2ZWw6IHQxLkxPQ0suLi4sXG4gICAqICAgICBvZjogVXNlck1vZGVsXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogIyBVc2VyTW9kZWwgd2lsbCBiZSBsb2NrZWQgYnV0IFRhc2tNb2RlbCB3b24ndCFcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+WW91IGNhbiBhbHNvIHNraXAgbG9ja2VkIHJvd3M6PC9jYXB0aW9uPlxuICAgKiAvLyB0MSBpcyBhIHRyYW5zYWN0aW9uXG4gICAqIE1vZGVsLmZpbmRBbGwoe1xuICAgKiAgIHdoZXJlOiAuLi4sXG4gICAqICAgdHJhbnNhY3Rpb246IHQxLFxuICAgKiAgIGxvY2s6IHRydWUsXG4gICAqICAgc2tpcExvY2tlZDogdHJ1ZVxuICAgKiB9KTtcbiAgICogIyBUaGUgcXVlcnkgd2lsbCBub3cgcmV0dXJuIGFueSByb3dzIHRoYXQgYXJlbid0IGxvY2tlZCBieSBhbm90aGVyIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSBVUERBVEVcbiAgICogQHByb3BlcnR5IFNIQVJFXG4gICAqIEBwcm9wZXJ0eSBLRVlfU0hBUkUgUG9zdGdyZXMgOS4zKyBvbmx5XG4gICAqIEBwcm9wZXJ0eSBOT19LRVlfVVBEQVRFIFBvc3RncmVzIDkuMysgb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBMT0NLKCkge1xuICAgIHJldHVybiB7XG4gICAgICBVUERBVEU6ICdVUERBVEUnLFxuICAgICAgU0hBUkU6ICdTSEFSRScsXG4gICAgICBLRVlfU0hBUkU6ICdLRVkgU0hBUkUnLFxuICAgICAgTk9fS0VZX1VQREFURTogJ05PIEtFWSBVUERBVEUnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbGVhc2Ugc2VlIHtAbGluayBUcmFuc2FjdGlvbi5MT0NLfVxuICAgKi9cbiAgZ2V0IExPQ0soKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLkxPQ0s7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcbm1vZHVsZS5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNhY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZSgnLi9zcWwtc3RyaW5nJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2gvX2Jhc2VJc05hdGl2ZScpO1xuY29uc3QgdXVpZHYxID0gcmVxdWlyZSgndXVpZCcpLnYxO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuY29uc3Qgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMnKTtcbmNvbnN0IG9wZXJhdG9yc1NldCA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhvcGVyYXRvcnMpKTtcblxubGV0IGluZmxlY3Rpb24gPSByZXF1aXJlKCdpbmZsZWN0aW9uJyk7XG5cbmV4cG9ydHMuY2xhc3NUb0ludm9rYWJsZSA9IHJlcXVpcmUoJy4vdXRpbHMvY2xhc3MtdG8taW52b2thYmxlJykuY2xhc3NUb0ludm9rYWJsZTtcbmV4cG9ydHMuam9pblNRTEZyYWdtZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvam9pbi1zcWwtZnJhZ21lbnRzJykuam9pblNRTEZyYWdtZW50cztcblxuZnVuY3Rpb24gdXNlSW5mbGVjdGlvbihfaW5mbGVjdGlvbikge1xuICBpbmZsZWN0aW9uID0gX2luZmxlY3Rpb247XG59XG5leHBvcnRzLnVzZUluZmxlY3Rpb24gPSB1c2VJbmZsZWN0aW9uO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZUlmKHN0ciwgY29uZGl0aW9uKSB7XG4gIGxldCByZXN1bHQgPSBzdHI7XG5cbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJlc3VsdCA9IGNhbWVsaXplKHN0cik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jYW1lbGl6ZUlmID0gY2FtZWxpemVJZjtcblxuZnVuY3Rpb24gdW5kZXJzY29yZWRJZihzdHIsIGNvbmRpdGlvbikge1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuXG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXN1bHQgPSB1bmRlcnNjb3JlKHN0cik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51bmRlcnNjb3JlZElmID0gdW5kZXJzY29yZWRJZjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG4vLyBTYW1lIGNvbmNlcHQgYXMgXy5tZXJnZSwgYnV0IGRvbid0IG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYXNzaWduZWRcbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMoYSwgYikge1xuICByZXR1cm4gXy5tZXJnZVdpdGgoYSwgYiwgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkgPT4ge1xuICAgIC8vIElmIGl0J3MgYW4gb2JqZWN0LCBsZXQgXyBoYW5kbGUgaXQgdGhpcyB0aW1lLCB3ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9iamVjdFZhbHVlKSAmJiBvYmplY3RWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBfLmlzTmF0aXZlIGluY2x1ZGVzIGEgY2hlY2sgZm9yIGNvcmUtanMgYW5kIHRocm93cyBhbiBlcnJvciBpZiBwcmVzZW50LlxuICAgICAgLy8gRGVwZW5kaW5nIG9uIF9iYXNlSXNOYXRpdmUgYnlwYXNzZXMgdGhlIGNvcmUtanMgY2hlY2suXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9iamVjdFZhbHVlKSAmJiBiYXNlSXNOYXRpdmUob2JqZWN0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VWYWx1ZSB8fCBvYmplY3RWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5tZXJnZURlZmF1bHRzID0gbWVyZ2VEZWZhdWx0cztcblxuLy8gQW4gYWx0ZXJuYXRpdmUgdG8gXy5tZXJnZSwgd2hpY2ggZG9lc24ndCBjbG9uZSBpdHMgYXJndW1lbnRzXG4vLyBDbG9uaW5nIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSBvcHRpb25zIGFyZ3VtZW50cyBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRvIHNlcXVlbGl6ZVxuLy8gbW9kZWxzIC0gd2hpY2ggYWdhaW4gcmVmZXJlbmNlIGRhdGFiYXNlIGxpYnMgd2hpY2ggZG9uJ3QgbGlrZSB0byBiZSBjbG9uZWQgKGluIHBhcnRpY3VsYXIgcGctbmF0aXZlKVxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3VtZW50cykge1xuICAgIF8uZm9yT3duKG9iaiwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghcmVzdWx0W2tleV0pIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUuY29uY2F0KHJlc3VsdFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuXG5mdW5jdGlvbiBzcGxpY2VTdHIoc3RyLCBpbmRleCwgY291bnQsIGFkZCkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIGluZGV4KSArIGFkZCArIHN0ci5zbGljZShpbmRleCArIGNvdW50KTtcbn1cbmV4cG9ydHMuc3BsaWNlU3RyID0gc3BsaWNlU3RyO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvWy1fXFxzXSsoLik/L2csIChtYXRjaCwgYykgPT4gYy50b1VwcGVyQ2FzZSgpKTtcbn1cbmV4cG9ydHMuY2FtZWxpemUgPSBjYW1lbGl6ZTtcblxuZnVuY3Rpb24gdW5kZXJzY29yZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24udW5kZXJzY29yZShzdHIpO1xufVxuZXhwb3J0cy51bmRlcnNjb3JlID0gdW5kZXJzY29yZTtcblxuZnVuY3Rpb24gc2luZ3VsYXJpemUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKHN0cik7XG59XG5leHBvcnRzLnNpbmd1bGFyaXplID0gc2luZ3VsYXJpemU7XG5cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24ucGx1cmFsaXplKHN0cik7XG59XG5leHBvcnRzLnBsdXJhbGl6ZSA9IHBsdXJhbGl6ZTtcblxuZnVuY3Rpb24gZm9ybWF0KGFyciwgZGlhbGVjdCkge1xuICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgYXJyYXkgYmVhY3VzZSBmb3JtYXQgbW9kaWZpZXMgdGhlIHBhc3NlZCBhcmdzXG4gIHJldHVybiBTcWxTdHJpbmcuZm9ybWF0KGFyclswXSwgYXJyLnNsaWNlKDEpLCB0aW1lWm9uZSwgZGlhbGVjdCk7XG59XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcblxuZnVuY3Rpb24gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgcGFyYW1ldGVycywgZGlhbGVjdCkge1xuICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gIHJldHVybiBTcWxTdHJpbmcuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgcGFyYW1ldGVycywgdGltZVpvbmUsIGRpYWxlY3QpO1xufVxuZXhwb3J0cy5mb3JtYXROYW1lZFBhcmFtZXRlcnMgPSBmb3JtYXROYW1lZFBhcmFtZXRlcnM7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcChvYmosIG9ubHlQbGFpbikge1xuICBvYmogPSBvYmogfHwge307XG4gIHJldHVybiBfLmNsb25lRGVlcFdpdGgob2JqLCBlbGVtID0+IHtcbiAgICAvLyBEbyBub3QgdHJ5IHRvIGN1c3RvbWl6ZSBjbG9uaW5nIG9mIGFycmF5cyBvciBQT0pPc1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW0pIHx8IF8uaXNQbGFpbk9iamVjdChlbGVtKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBzcGVjaWZpZWQgdG8gY2xvbmUgb25seSBwbGFpbiBvYmplY3RzICYgYXJyYXlzLCB3ZSBpZ25vcmUgZXZlcnloaW5nIGVsc2VcbiAgICAvLyBJbiBhbnkgY2FzZSwgZG9uJ3QgY2xvbmUgc3R1ZmYgdGhhdCdzIGFuIG9iamVjdCwgYnV0IG5vdCBhIHBsYWluIG9uZSAtIGZ4IGV4YW1wbGUgc2VxdWVsaXplIG1vZGVscyBhbmQgaW5zdGFuY2VzXG4gICAgaWYgKG9ubHlQbGFpbiB8fCB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIC8vIFByZXNlcnZlIHNwZWNpYWwgZGF0YS10eXBlcyBsaWtlIGBmbmAgYWNyb3NzIGNsb25lcy4gXy5nZXQoKSBpcyB1c2VkIGZvciBjaGVja2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgaWYgKGVsZW0gJiYgdHlwZW9mIGVsZW0uY2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBlbGVtLmNsb25lKCk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMuY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuXG4vKiBFeHBhbmQgYW5kIG5vcm1hbGl6ZSBmaW5kZXIgb3B0aW9ucyAqL1xuZnVuY3Rpb24gbWFwRmluZGVyT3B0aW9ucyhvcHRpb25zLCBNb2RlbCkge1xuICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IE1vZGVsLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5maWx0ZXIodiA9PiAhTW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyh2KSk7XG4gIH1cblxuICBtYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIE1vZGVsKTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMubWFwRmluZGVyT3B0aW9ucyA9IG1hcEZpbmRlck9wdGlvbnM7XG5cbi8qIFVzZWQgdG8gbWFwIGZpZWxkIG5hbWVzIGluIGF0dHJpYnV0ZXMgYW5kIHdoZXJlIGNvbmRpdGlvbnMgKi9cbmZ1bmN0aW9uIG1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgTW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoYXR0ciA9PiB7XG4gICAgICAvLyBPYmplY3QgbG9va3VwcyB3aWxsIGZvcmNlIGFueSB2YXJpYWJsZSB0byBzdHJpbmdzLCB3ZSBkb24ndCB3YW50IHRoYXQgZm9yIHNwZWNpYWwgb2JqZWN0cyBldGNcbiAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gJ3N0cmluZycpIHJldHVybiBhdHRyO1xuICAgICAgLy8gTWFwIGF0dHJpYnV0ZXMgdG8gYWxpYXNlZCBzeW50YXggYXR0cmlidXRlc1xuICAgICAgaWYgKE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgYXR0ciAhPT0gTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCkge1xuICAgICAgICByZXR1cm4gW01vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQsIGF0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy53aGVyZSAmJiBfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICBvcHRpb25zLndoZXJlID0gbWFwV2hlcmVGaWVsZE5hbWVzKG9wdGlvbnMud2hlcmUsIE1vZGVsKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5tYXBPcHRpb25GaWVsZE5hbWVzID0gbWFwT3B0aW9uRmllbGROYW1lcztcblxuZnVuY3Rpb24gbWFwV2hlcmVGaWVsZE5hbWVzKGF0dHJpYnV0ZXMsIE1vZGVsKSB7XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgZ2V0Q29tcGxleEtleXMoYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgICAgY29uc3QgcmF3QXR0cmlidXRlID0gTW9kZWwucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuXG4gICAgICBpZiAocmF3QXR0cmlidXRlICYmIHJhd0F0dHJpYnV0ZS5maWVsZCAhPT0gcmF3QXR0cmlidXRlLmZpZWxkTmFtZSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3Jhd0F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlc1thdHRyaWJ1dGVdKVxuICAgICAgICAmJiAhKHJhd0F0dHJpYnV0ZSAmJiAoXG4gICAgICAgICAgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSFNUT1JFXG4gICAgICAgICAgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikpKSB7IC8vIFByZXZlbnQgcmVuYW1pbmcgb2YgSFNUT1JFICYgSlNPTiBmaWVsZHNcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gbWFwT3B0aW9uRmllbGROYW1lcyh7XG4gICAgICAgICAgd2hlcmU6IGF0dHJpYnV0ZXNbYXR0cmlidXRlXVxuICAgICAgICB9LCBNb2RlbCkud2hlcmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXNbYXR0cmlidXRlXSkpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdLmZvckVhY2goKHdoZXJlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qod2hlcmUpKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV1baW5kZXhdID0gbWFwV2hlcmVGaWVsZE5hbWVzKHdoZXJlLCBNb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5leHBvcnRzLm1hcFdoZXJlRmllbGROYW1lcyA9IG1hcFdoZXJlRmllbGROYW1lcztcblxuLyogVXNlZCB0byBtYXAgZmllbGQgbmFtZXMgaW4gdmFsdWVzICovXG5mdW5jdGlvbiBtYXBWYWx1ZUZpZWxkTmFtZXMoZGF0YVZhbHVlcywgZmllbGRzLCBNb2RlbCkge1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcblxuICBmb3IgKGNvbnN0IGF0dHIgb2YgZmllbGRzKSB7XG4gICAgaWYgKGRhdGFWYWx1ZXNbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiAhTW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhhdHRyKSkge1xuICAgICAgLy8gRmllbGQgbmFtZSBtYXBwaW5nXG4gICAgICBpZiAoTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSAmJiBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmIE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHIpIHtcbiAgICAgICAgdmFsdWVzW01vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdID0gZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1thdHRyXSA9IGRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMubWFwVmFsdWVGaWVsZE5hbWVzID0gbWFwVmFsdWVGaWVsZE5hbWVzO1xuXG5mdW5jdGlvbiBpc0NvbFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJyQnICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnJCc7XG59XG5leHBvcnRzLmlzQ29sU3RyaW5nID0gaXNDb2xTdHJpbmc7XG5cbmZ1bmN0aW9uIGNhblRyZWF0QXJyYXlBc0FuZChhcnIpIHtcbiAgcmV0dXJuIGFyci5zb21lKGFyZyA9PiBfLmlzUGxhaW5PYmplY3QoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBXaGVyZSk7XG59XG5leHBvcnRzLmNhblRyZWF0QXJyYXlBc0FuZCA9IGNhblRyZWF0QXJyYXlBc0FuZDtcblxuZnVuY3Rpb24gY29tYmluZVRhYmxlTmFtZXModGFibGVOYW1lMSwgdGFibGVOYW1lMikge1xuICByZXR1cm4gdGFibGVOYW1lMS50b0xvd2VyQ2FzZSgpIDwgdGFibGVOYW1lMi50b0xvd2VyQ2FzZSgpID8gdGFibGVOYW1lMSArIHRhYmxlTmFtZTIgOiB0YWJsZU5hbWUyICsgdGFibGVOYW1lMTtcbn1cbmV4cG9ydHMuY29tYmluZVRhYmxlTmFtZXMgPSBjb21iaW5lVGFibGVOYW1lcztcblxuZnVuY3Rpb24gdG9EZWZhdWx0VmFsdWUodmFsdWUsIGRpYWxlY3QpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHRtcCA9IHZhbHVlKCk7XG4gICAgaWYgKHRtcCBpbnN0YW5jZW9mIERhdGFUeXBlcy5BQlNUUkFDVCkge1xuICAgICAgcmV0dXJuIHRtcC50b1NxbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdG1wO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjEpIHtcbiAgICByZXR1cm4gdXVpZHYxKCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWNCkge1xuICAgIHJldHVybiB1dWlkdjQoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuTk9XKSB7XG4gICAgcmV0dXJuIG5vdyhkaWFsZWN0KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB7IC4uLnZhbHVlIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy50b0RlZmF1bHRWYWx1ZSA9IHRvRGVmYXVsdFZhbHVlO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBleGlzdHMgYW5kIGNhbiBiZSBkZXNjcmliZWRcbiAqIGluIGEgZGIgc2NoZW1hIHVzaW5nIHRoZSBERUZBVUxUIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZSBBbnkgZGVmYXVsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSB5ZXMgLyBuby5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZVNjaGVtYWJsZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBUT0RPIHRoaXMgd2lsbCBiZSBzY2hlbWFibGUgd2hlbiBhbGwgc3VwcG9ydGVkIGRiXG4gIC8vIGhhdmUgYmVlbiBub3JtYWxpemVkIGZvciB0aGlzIGNhc2VcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLk5PVykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFYxIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5kZWZhdWx0VmFsdWVTY2hlbWFibGUgPSBkZWZhdWx0VmFsdWVTY2hlbWFibGU7XG5cbmZ1bmN0aW9uIHJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChoYXNoLCBvbWl0TnVsbCwgb3B0aW9ucykge1xuICBsZXQgcmVzdWx0ID0gaGFzaDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hbGxvd051bGwgPSBvcHRpb25zLmFsbG93TnVsbCB8fCBbXTtcblxuICBpZiAob21pdE51bGwpIHtcbiAgICBjb25zdCBfaGFzaCA9IHt9O1xuXG4gICAgXy5mb3JJbihoYXNoLCAodmFsLCBrZXkpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmFsbG93TnVsbC5pbmNsdWRlcyhrZXkpIHx8IGtleS5lbmRzV2l0aCgnSWQnKSB8fCB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX2hhc2hba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdCA9IF9oYXNoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoID0gcmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoO1xuXG5jb25zdCBkaWFsZWN0cyA9IG5ldyBTZXQoWydtYXJpYWRiJywgJ215c3FsJywgJ3Bvc3RncmVzJywgJ3NxbGl0ZScsICdtc3NxbCddKTtcblxuZnVuY3Rpb24gbm93KGRpYWxlY3QpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XG4gIGlmICghZGlhbGVjdHMuaGFzKGRpYWxlY3QpKSB7XG4gICAgZC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG5leHBvcnRzLm5vdyA9IG5vdztcblxuLy8gTm90ZTogVXNlIHRoZSBgcXVvdGVJZGVudGlmaWVyKClgIGFuZCBgZXNjYXBlKClgIG1ldGhvZHMgb24gdGhlXG4vLyBgUXVlcnlJbnRlcmZhY2VgIGluc3RlYWQgZm9yIG1vcmUgcG9ydGFibGUgY29kZS5cblxuY29uc3QgVElDS19DSEFSID0gJ2AnO1xuZXhwb3J0cy5USUNLX0NIQVIgPSBUSUNLX0NIQVI7XG5cbmZ1bmN0aW9uIGFkZFRpY2tzKHMsIHRpY2tDaGFyKSB7XG4gIHRpY2tDaGFyID0gdGlja0NoYXIgfHwgVElDS19DSEFSO1xuICByZXR1cm4gdGlja0NoYXIgKyByZW1vdmVUaWNrcyhzLCB0aWNrQ2hhcikgKyB0aWNrQ2hhcjtcbn1cbmV4cG9ydHMuYWRkVGlja3MgPSBhZGRUaWNrcztcblxuZnVuY3Rpb24gcmVtb3ZlVGlja3MocywgdGlja0NoYXIpIHtcbiAgdGlja0NoYXIgPSB0aWNrQ2hhciB8fCBUSUNLX0NIQVI7XG4gIHJldHVybiBzLnJlcGxhY2UobmV3IFJlZ0V4cCh0aWNrQ2hhciwgJ2cnKSwgJycpO1xufVxuZXhwb3J0cy5yZW1vdmVUaWNrcyA9IHJlbW92ZVRpY2tzO1xuXG4vKipcbiAqIFJlY2VpdmVzIGEgdHJlZS1saWtlIG9iamVjdCBhbmQgcmV0dXJucyBhIHBsYWluIG9iamVjdCB3aGljaCBkZXB0aCBpcyAxLlxuICpcbiAqIC0gSW5wdXQ6XG4gKlxuICogIHtcbiAqICAgIG5hbWU6ICdKb2huJyxcbiAqICAgIGFkZHJlc3M6IHtcbiAqICAgICAgc3RyZWV0OiAnRmFrZSBTdC4gMTIzJyxcbiAqICAgICAgY29vcmRpbmF0ZXM6IHtcbiAqICAgICAgICBsb25naXR1ZGU6IDU1LjY3Nzk2MjcsXG4gKiAgICAgICAgbGF0aXR1ZGU6IDEyLjU5NjQzMTNcbiAqICAgICAgfVxuICogICAgfVxuICogIH1cbiAqXG4gKiAtIE91dHB1dDpcbiAqXG4gKiAge1xuICogICAgbmFtZTogJ0pvaG4nLFxuICogICAgYWRkcmVzcy5zdHJlZXQ6ICdGYWtlIFN0LiAxMjMnLFxuICogICAgYWRkcmVzcy5jb29yZGluYXRlcy5sYXRpdHVkZTogNTUuNjc3OTYyNyxcbiAqICAgIGFkZHJlc3MuY29vcmRpbmF0ZXMubG9uZ2l0dWRlOiAxMi41OTY0MzEzXG4gKiAgfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSBhbiBPYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3R9IGEgZmxhdHRlbmVkIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbk9iamVjdERlZXAodmFsdWUpIHtcbiAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IGZsYXR0ZW5lZE9iaiA9IHt9O1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5PYmplY3Qob2JqLCBzdWJQYXRoKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBwYXRoVG9Qcm9wZXJ0eSA9IHN1YlBhdGggPyBgJHtzdWJQYXRofS4ke2tleX1gIDoga2V5O1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgZmxhdHRlbk9iamVjdChvYmpba2V5XSwgcGF0aFRvUHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkT2JqW3BhdGhUb1Byb3BlcnR5XSA9IF8uZ2V0KG9iaiwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmxhdHRlbmVkT2JqO1xuICB9XG5cbiAgcmV0dXJuIGZsYXR0ZW5PYmplY3QodmFsdWUsIHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmZsYXR0ZW5PYmplY3REZWVwID0gZmxhdHRlbk9iamVjdERlZXA7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHJlcHJlc2VudGluZyBTUUwgZnVuY3Rpb25zLCBhbmQgY29sdW1ucyB0aGF0IHNob3VsZCBiZSBlc2NhcGVkLlxuICogUGxlYXNlIGRvIG5vdCB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5LCB1c2UgU2VxdWVsaXplLmZuIGFuZCBTZXF1ZWxpemUuY29sIGluc3RlYWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2VxdWVsaXplTWV0aG9kIHt9XG5leHBvcnRzLlNlcXVlbGl6ZU1ldGhvZCA9IFNlcXVlbGl6ZU1ldGhvZDtcblxuY2xhc3MgRm4gZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3RvcihmbiwgYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBGbih0aGlzLmZuLCB0aGlzLmFyZ3MpO1xuICB9XG59XG5leHBvcnRzLkZuID0gRm47XG5cbmNsYXNzIENvbCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGNvbCwgLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29sID0gYXJncztcbiAgICB9XG4gICAgdGhpcy5jb2wgPSBjb2w7XG4gIH1cbn1cbmV4cG9ydHMuQ29sID0gQ29sO1xuXG5jbGFzcyBDYXN0IGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IodmFsLCB0eXBlLCBqc29uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB0aGlzLnR5cGUgPSAodHlwZSB8fCAnJykudHJpbSgpO1xuICAgIHRoaXMuanNvbiA9IGpzb24gfHwgZmFsc2U7XG4gIH1cbn1cbmV4cG9ydHMuQ2FzdCA9IENhc3Q7XG5cbmNsYXNzIExpdGVyYWwgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICB9XG59XG5leHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xuXG5jbGFzcyBKc29uIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmRpdGlvbnNPclBhdGgpKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvbnMgPSBjb25kaXRpb25zT3JQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdGggPSBjb25kaXRpb25zT3JQYXRoO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuSnNvbiA9IEpzb247XG5cbmNsYXNzIFdoZXJlIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlLCBjb21wYXJhdG9yLCBsb2dpYykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGxvZ2ljID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2ljID0gY29tcGFyYXRvcjtcbiAgICAgIGNvbXBhcmF0b3IgPSAnPSc7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gIH1cbn1cbmV4cG9ydHMuV2hlcmUgPSBXaGVyZTtcblxuLy9Db2xsZWN0aW9uIG9mIGhlbHBlciBtZXRob2RzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBzeW1ib2wgb3BlcmF0b3JzXG5cbi8qKlxuICogZ2V0T3BlcmF0b3JzXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheTxzeW1ib2w+fSBBbGwgb3BlcmF0b3JzIHByb3BlcnRpZXMgb2Ygb2JqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRPcGVyYXRvcnMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikuZmlsdGVyKHMgPT4gb3BlcmF0b3JzU2V0LmhhcyhzKSk7XG59XG5leHBvcnRzLmdldE9wZXJhdG9ycyA9IGdldE9wZXJhdG9ycztcblxuLyoqXG4gKiBnZXRDb21wbGV4S2V5c1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nfHN5bWJvbD59IEFsbCBrZXlzIGluY2x1ZGluZyBvcGVyYXRvcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBsZXhLZXlzKG9iaikge1xuICByZXR1cm4gZ2V0T3BlcmF0b3JzKG9iaikuY29uY2F0KE9iamVjdC5rZXlzKG9iaikpO1xufVxuZXhwb3J0cy5nZXRDb21wbGV4S2V5cyA9IGdldENvbXBsZXhLZXlzO1xuXG4vKipcbiAqIGdldENvbXBsZXhTaXplXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fEFycmF5fSBvYmpcbiAqIEByZXR1cm5zIHtudW1iZXJ9ICAgICAgTGVuZ3RoIG9mIG9iamVjdCBwcm9wZXJ0aWVzIGluY2x1ZGluZyBvcGVyYXRvcnMgaWYgb2JqIGlzIGFycmF5IHJldHVybnMgaXRzIGxlbmd0aFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGxleFNpemUob2JqKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBvYmoubGVuZ3RoIDogZ2V0Q29tcGxleEtleXMob2JqKS5sZW5ndGg7XG59XG5leHBvcnRzLmdldENvbXBsZXhTaXplID0gZ2V0Q29tcGxleFNpemU7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgd2hlcmUgY2xhdXNlIGlzIGVtcHR5LCBldmVuIHdpdGggU3ltYm9sc1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzV2hlcmVFbXB0eShvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmIF8uaXNFbXB0eShvYmopICYmIGdldE9wZXJhdG9ycyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNXaGVyZUVtcHR5ID0gaXNXaGVyZUVtcHR5O1xuXG4vKipcbiAqIFJldHVybnMgRU5VTSBuYW1lIGJ5IGpvaW5pbmcgdGFibGUgYW5kIGNvbHVtbiBuYW1lXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUVudW1OYW1lKHRhYmxlTmFtZSwgY29sdW1uTmFtZSkge1xuICByZXR1cm4gYGVudW1fJHt0YWJsZU5hbWV9XyR7Y29sdW1uTmFtZX1gO1xufVxuZXhwb3J0cy5nZW5lcmF0ZUVudW1OYW1lID0gZ2VuZXJhdGVFbnVtTmFtZTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG5ldyBPYmplY3Qgd2hpY2gga2V5cyBhcmUgY2FtZWxpemVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplT2JqZWN0S2V5cyhvYmopIHtcbiAgY29uc3QgbmV3T2JqID0gbmV3IE9iamVjdCgpO1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICBuZXdPYmpbY2FtZWxpemUoa2V5KV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5leHBvcnRzLmNhbWVsaXplT2JqZWN0S2V5cyA9IGNhbWVsaXplT2JqZWN0S2V5cztcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGFuZCBzeW1ib2wga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqXG4gKiBodHRwczovL2xvZGFzaC5jb20vZG9jcy80LjE3LjQjZGVmYXVsdHNcbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0cyhvYmplY3QsIC4uLnNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgc291cmNlID0gT2JqZWN0KHNvdXJjZSk7XG5cbiAgICAgIGdldENvbXBsZXhLZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgXy5lcSh2YWx1ZSwgT2JqZWN0LnByb3RvdHlwZVtrZXldKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSlcblxuICAgICAgICApIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3Q7XG59XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmRleFxuICogQHBhcmFtIHtBcnJheX0gIGluZGV4LmZpZWxkc1xuICogQHBhcmFtIHtzdHJpbmd9IFtpbmRleC5uYW1lXVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0YWJsZU5hbWVcbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmFtZUluZGV4KGluZGV4LCB0YWJsZU5hbWUpIHtcbiAgaWYgKHRhYmxlTmFtZS50YWJsZU5hbWUpIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5kZXgsICduYW1lJykpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBpbmRleC5maWVsZHMubWFwKFxuICAgICAgZmllbGQgPT4gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyA/IGZpZWxkIDogZmllbGQubmFtZSB8fCBmaWVsZC5hdHRyaWJ1dGVcbiAgICApO1xuICAgIGluZGV4Lm5hbWUgPSB1bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtmaWVsZHMuam9pbignXycpfWApO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuZXhwb3J0cy5uYW1lSW5kZXggPSBuYW1lSW5kZXg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIDIgYXJyYXlzIGludGVyc2VjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGFycjEuc29tZSh2ID0+IGFycjIuaW5jbHVkZXModikpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0cztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXcmFwcyBhIGNvbnN0cnVjdG9yIHRvIG5vdCBuZWVkIHRoZSBgbmV3YCBrZXl3b3JkIHVzaW5nIGEgcHJveHkuXG4gKiBPbmx5IHVzZWQgZm9yIGRhdGEgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ2xhc3MgVGhlIGNsYXNzIGluc3RhbmNlIHRvIHdyYXAgYXMgaW52b2NhYmxlLlxuICogQHJldHVybnMge1Byb3h5fSBXcmFwcGVkIGNsYXNzIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xhc3NUb0ludm9rYWJsZShDbGFzcykge1xuICByZXR1cm4gbmV3IFByb3h5KENsYXNzLCB7XG4gICAgYXBwbHkoVGFyZ2V0LCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IFRhcmdldCguLi5hcmdzKTtcbiAgICB9LFxuICAgIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgVGFyZ2V0KC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgcmV0dXJuIHRhcmdldFtwXTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5jbGFzc1RvSW52b2thYmxlID0gY2xhc3NUb0ludm9rYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBkZXByZWNhdGUgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5leHBvcnRzLm5vUmF3QXR0cmlidXRlcyA9IGRlcHJlY2F0ZShub29wLCAnVXNlIHNlcXVlbGl6ZS5mbiAvIHNlcXVlbGl6ZS5saXRlcmFsIHRvIGNvbnN0cnVjdCBhdHRyaWJ1dGVzJywgJ1NFUVVFTElaRTAwMDEnKTtcbmV4cG9ydHMubm9UcnVlTG9nZ2luZyA9IGRlcHJlY2F0ZShub29wLCAnVGhlIGxvZ2dpbmctb3B0aW9uIHNob3VsZCBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBmYWxzZS4gRGVmYXVsdDogY29uc29sZS5sb2cnLCAnU0VRVUVMSVpFMDAwMicpO1xuZXhwb3J0cy5ub1N0cmluZ09wZXJhdG9ycyA9IGRlcHJlY2F0ZShub29wLCAnU3RyaW5nIGJhc2VkIG9wZXJhdG9ycyBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBTeW1ib2wgYmFzZWQgb3BlcmF0b3JzIGZvciBiZXR0ZXIgc2VjdXJpdHksIHJlYWQgbW9yZSBhdCBodHRwczovL3NlcXVlbGl6ZS5vcmcvbWFzdGVyL21hbnVhbC9xdWVyeWluZy5odG1sI29wZXJhdG9ycycsICdTRVFVRUxJWkUwMDAzJyk7XG5leHBvcnRzLm5vQm9vbE9wZXJhdG9yQWxpYXNlcyA9IGRlcHJlY2F0ZShub29wLCAnQSBib29sZWFuIHZhbHVlIHdhcyBwYXNzZWQgdG8gb3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzLiBUaGlzIGlzIGEgbm8tb3Agd2l0aCB2NSBhbmQgc2hvdWxkIGJlIHJlbW92ZWQuJywgJ1NFUVVFTElaRTAwMDQnKTtcbmV4cG9ydHMubm9Eb3VibGVOZXN0ZWRHcm91cCA9IGRlcHJlY2F0ZShub29wLCAnUGFzc2luZyBhIGRvdWJsZSBuZXN0ZWQgbmVzdGVkIGFycmF5IHRvIGBncm91cGAgaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ni4nLCAnU0VRVUVMSVpFMDAwNScpO1xuZXhwb3J0cy51bnN1cHBvcnRlZEVuZ2luZSA9IGRlcHJlY2F0ZShub29wLCAnVGhpcyBkYXRhYmFzZSBlbmdpbmUgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgdXBkYXRlIHlvdXIgZGF0YWJhc2Ugc2VydmVyLiBNb3JlIGluZm9ybWF0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2Jsb2IvbWFpbi9FTkdJTkUubWQnLCAnU0VRVUVMSVpFMDAwNicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkb2VzTm90V2FudExlYWRpbmdTcGFjZShzdHIpIHtcbiAgcmV0dXJuIC9eWzssKV0vLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGRvZXNOb3RXYW50VHJhaWxpbmdTcGFjZShzdHIpIHtcbiAgcmV0dXJuIC9cXCgkLy50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogSm9pbnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIGEgc2luZ2xlIHNwYWNlIGJldHdlZW4gdGhlbSxcbiAqIGV4Y2VwdCBmb3I6XG4gKiBcbiAqIC0gU3RyaW5ncyBzdGFydGluZyB3aXRoICc7JywgJywnIGFuZCAnKScsIHdoaWNoIGRvIG5vdCBnZXQgYSBsZWFkaW5nIHNwYWNlLlxuICogLSBTdHJpbmdzIGVuZGluZyB3aXRoICcoJywgd2hpY2ggZG8gbm90IGdldCBhIHRyYWlsaW5nIHNwYWNlLlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJ0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVNwYWNlSm9pbkhlbHBlcihwYXJ0cykge1xuICByZXR1cm4gcGFydHMucmVkdWNlKCh7IHNraXBOZXh0TGVhZGluZ1NwYWNlLCByZXN1bHQgfSwgcGFydCkgPT4ge1xuICAgIGlmIChza2lwTmV4dExlYWRpbmdTcGFjZSB8fCBkb2VzTm90V2FudExlYWRpbmdTcGFjZShwYXJ0KSkge1xuICAgICAgcmVzdWx0ICs9IHBhcnQudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gYCAke3BhcnQudHJpbSgpfWA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBza2lwTmV4dExlYWRpbmdTcGFjZTogZG9lc05vdFdhbnRUcmFpbGluZ1NwYWNlKHBhcnQpLFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfSwge1xuICAgIHNraXBOZXh0TGVhZGluZ1NwYWNlOiB0cnVlLFxuICAgIHJlc3VsdDogJydcbiAgfSkucmVzdWx0O1xufVxuXG4vKipcbiAqIEpvaW5zIGFuIGFycmF5IHdpdGggYSBzaW5nbGUgc3BhY2UsIGF1dG8gdHJpbW1pbmcgd2hlbiBuZWVkZWQuXG4gKiBcbiAqIENlcnRhaW4gZWxlbWVudHMgZG8gbm90IGdldCBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlcy5cbiAqIFxuICogQHBhcmFtIHthbnlbXX0gYXJyYXkgVGhlIGFycmF5IHRvIGJlIGpvaW5lZC4gRmFsc3kgdmFsdWVzIGFyZSBza2lwcGVkLiBJZiBhblxuICogZWxlbWVudCBpcyBhbm90aGVyIGFycmF5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IG9uIHRoYXQgYXJyYXkuXG4gKiBPdGhlcndpc2UsIGlmIGEgbm9uLXN0cmluZywgbm9uLWZhbHN5IHZhbHVlIGlzIHByZXNlbnQsIGEgVHlwZUVycm9yIHdpbGwgYmUgdGhyb3duLlxuICogXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgam9pbmVkIHN0cmluZy5cbiAqIFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gam9pblNRTEZyYWdtZW50cyhhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG5cbiAgLy8gU2tpcCBmYWxzeSBmcmFnbWVudHNcbiAgYXJyYXkgPSBhcnJheS5maWx0ZXIoeCA9PiB4KTtcblxuICAvLyBSZXNvbHZlIHJlY3Vyc2l2ZSBjYWxsc1xuICBhcnJheSA9IGFycmF5Lm1hcChmcmFnbWVudCA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhZ21lbnQpKSB7XG4gICAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhmcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSk7XG5cbiAgLy8gRW5zdXJlIHN0cmluZ3NcbiAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBhcnJheSkge1xuICAgIGlmIChmcmFnbWVudCAmJiB0eXBlb2YgZnJhZ21lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYFRyaWVkIHRvIGNvbnN0cnVjdCBhIFNRTCBzdHJpbmcgd2l0aCBhIG5vbi1zdHJpbmcsIG5vbi1mYWxzeSBmcmFnbWVudCAoJHtmcmFnbWVudH0pLmApO1xuICAgICAgZXJyb3IuYXJncyA9IGFycmF5O1xuICAgICAgZXJyb3IuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaW0gZnJhZ21lbnRzXG4gIGFycmF5ID0gYXJyYXkubWFwKHggPT4geC50cmltKCkpO1xuXG4gIC8vIFNraXAgZnVsbC13aGl0ZXNwYWNlIGZyYWdtZW50cyAoZW1wdHkgYWZ0ZXIgdGhlIGFib3ZlIHRyaW0pXG4gIGFycmF5ID0gYXJyYXkuZmlsdGVyKHggPT4geCAhPT0gJycpO1xuXG4gIHJldHVybiBzaW5nbGVTcGFjZUpvaW5IZWxwZXIoYXJyYXkpO1xufVxuZXhwb3J0cy5qb2luU1FMRnJhZ21lbnRzID0gam9pblNRTEZyYWdtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZXF1ZWxpemUgbW9kdWxlIGZvciBkZWJ1ZyBhbmQgZGVwcmVjYXRpb24gbWVzc2FnZXMuXG4gKiBJdCByZXF1aXJlIGEgYGNvbnRleHRgIGZvciB3aGljaCBtZXNzYWdlcyB3aWxsIGJlIHByaW50ZWQuXG4gKlxuICogQG1vZHVsZSBsb2dnaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBjb250ZXh0OiAnc2VxdWVsaXplJyxcbiAgICAgIGRlYnVnOiB0cnVlLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgfVxuXG4gIHdhcm4obWVzc2FnZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKGAoJHt0aGlzLmNvbmZpZy5jb250ZXh0fSkgV2FybmluZzogJHttZXNzYWdlfWApO1xuICB9XG5cbiAgaW5zcGVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3QodmFsdWUsIGZhbHNlLCAzKTtcbiAgfVxuXG4gIGRlYnVnQ29udGV4dChuYW1lKSB7XG4gICAgcmV0dXJuIGRlYnVnKGAke3RoaXMuY29uZmlnLmNvbnRleHR9OiR7bmFtZX1gKTtcbiAgfVxufVxuXG5leHBvcnRzLmxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHZhbGlkYXRvciA9IF8uY2xvbmVEZWVwKHJlcXVpcmUoJ3ZhbGlkYXRvcicpKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5jb25zdCBleHRlbnNpb25zID0ge1xuICBleHRlbmQobmFtZSwgZm4pIHtcbiAgICB0aGlzW25hbWVdID0gZm47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm90RW1wdHkoc3RyKSB7XG4gICAgcmV0dXJuICFzdHIubWF0Y2goL15bXFxzXFx0XFxyXFxuXSokLyk7XG4gIH0sXG4gIGxlbihzdHIsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZW5ndGgoc3RyLCBtaW4sIG1heCk7XG4gIH0sXG4gIGlzVXJsKHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzVVJMKHN0cik7XG4gIH0sXG4gIGlzSVB2NihzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0lQKHN0ciwgNik7XG4gIH0sXG4gIGlzSVB2NChzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0lQKHN0ciwgNCk7XG4gIH0sXG4gIG5vdEluKHN0ciwgdmFsdWVzKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzSW4oc3RyLCB2YWx1ZXMpO1xuICB9LFxuICByZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHN0ciArPSAnJztcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhdHRlcm4pLnNsaWNlKDgsIC0xKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gICAgfVxuICAgIHJldHVybiBzdHIubWF0Y2gocGF0dGVybik7XG4gIH0sXG4gIG5vdFJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuICF0aGlzLnJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfSxcbiAgaXNEZWNpbWFsKHN0cikge1xuICAgIHJldHVybiBzdHIgIT09ICcnICYmICEhc3RyLm1hdGNoKC9eKD86LT8oPzpbMC05XSspKT8oPzpcXC5bMC05XSopPyg/OltlRV1bKy1dPyg/OlswLTldKykpPyQvKTtcbiAgfSxcbiAgbWluKHN0ciwgdmFsKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiBpc05hTihudW1iZXIpIHx8IG51bWJlciA+PSB2YWw7XG4gIH0sXG4gIG1heChzdHIsIHZhbCkge1xuICAgIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gaXNOYU4obnVtYmVyKSB8fCBudW1iZXIgPD0gdmFsO1xuICB9LFxuICBub3Qoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RSZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH0sXG4gIGNvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAgIHJldHVybiAhIWVsZW0gJiYgc3RyLmluY2x1ZGVzKGVsZW0pO1xuICB9LFxuICBub3RDb250YWlucyhzdHIsIGVsZW0pIHtcbiAgICByZXR1cm4gIXRoaXMuY29udGFpbnMoc3RyLCBlbGVtKTtcbiAgfSxcbiAgaXMoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH1cbn07XG5leHBvcnRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXG4vLyBpbnN0YW5jZSBiYXNlZCB2YWxpZGF0b3JzXG52YWxpZGF0b3IuaXNJbW11dGFibGUgPSBmdW5jdGlvbih2YWx1ZSwgdmFsaWRhdG9yQXJncywgZmllbGQsIG1vZGVsSW5zdGFuY2UpIHtcbiAgcmV0dXJuIG1vZGVsSW5zdGFuY2UuaXNOZXdSZWNvcmQgfHwgbW9kZWxJbnN0YW5jZS5kYXRhVmFsdWVzW2ZpZWxkXSA9PT0gbW9kZWxJbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2ZpZWxkXTtcbn07XG5cbi8vIGV4dHJhIHZhbGlkYXRvcnNcbnZhbGlkYXRvci5ub3ROdWxsID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9ibG9iLzYuMi4wL3ZhbGlkYXRvci5qc1xuXy5mb3JFYWNoKGV4dGVuc2lvbnMsIChleHRlbmQsIGtleSkgPT4ge1xuICB2YWxpZGF0b3Jba2V5XSA9IGV4dGVuZDtcbn0pO1xuXG4vLyBtYXAgaXNOdWxsIHRvIGlzRW1wdHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzL2NvbW1pdC9lMzNkMzhhMjZlZTJmOTY2NmIzMTlhZGI2N2M3ZmMwZDNkZWE3MTI1XG52YWxpZGF0b3IuaXNOdWxsID0gdmFsaWRhdG9yLmlzRW1wdHk7XG5cbi8vIGlzRGF0ZSByZW1vdmVkIGluIDcuMC4wXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9jb21taXQvMDk1NTA5ZmM3MDdhNGRjMGU5OWY4NTEzMWRmMTE3NmFkNjM4OWZjOVxudmFsaWRhdG9yLmlzRGF0ZSA9IGZ1bmN0aW9uKGRhdGVTdHJpbmcpIHtcbiAgLy8gYXZvaWQgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlL1xuICAvLyBieSBkb2luZyBhIHByZWxpbWluYXJ5IGNoZWNrIG9uIGBkYXRlU3RyaW5nYFxuICBjb25zdCBwYXJzZWQgPSBEYXRlLnBhcnNlKGRhdGVTdHJpbmcpO1xuICBpZiAoaXNOYU4ocGFyc2VkKSkge1xuICAgIC8vIGZhaWwgaWYgd2UgY2FuJ3QgcGFyc2UgaXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gb3RoZXJ3aXNlIGNvbnZlcnQgdG8gSVNPIDg2MDEgYXMgbW9tZW50IHByZWZlcnNcbiAgLy8gaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmcvXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwYXJzZWQpO1xuICByZXR1cm4gbW9tZW50KGRhdGUudG9JU09TdHJpbmcoKSkuaXNWYWxpZCgpO1xufTtcblxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4iLCIvKioqKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEd1c3Rhdm8gSGVua2UgYW5kIEFhcm9uIFRyZW50XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKioqKi9cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAgIGlmKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgZGVmaW5lKCBcIlRvcG9zb3J0XCIsIFtcImV4cG9ydHNcIiwgXCJtb2R1bGVcIl0sIGZhY3RvcnkgKTtcbiAgICB9IGVsc2UgaWYoIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIGZhY3RvcnkoIGV4cG9ydHMsIG1vZHVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtb2QgPSB7XG4gICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmYWN0b3J5KCBtb2QuZXhwb3J0cywgbW9kICk7XG4gICAgICAgIGdsb2JhbC5Ub3Bvc29ydCA9IG1vZC5leHBvcnRzO1xuICAgIH1cbn0pKCB0aGlzLCBmdW5jdGlvbiggZXhwb3J0cywgbW9kdWxlICkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKCBpbnN0YW5jZSwgQ29uc3RydWN0b3IgKSB7XG4gICAgICAgIGlmKCAhKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFRvcG9zb3J0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUb3Bvc29ydCgpIHtcbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayggdGhpcywgVG9wb3NvcnQgKTtcblxuICAgICAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5Ub3Bvc29ydCA9IFRvcG9zb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgZGVwZW5kZW5jeSBlZGdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNpbmNlICAgMC4xLjBcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gaXRlbSAgICAgICAgICAgICAgIEFuIGRlcGVuZGVudCBuYW1lLiBNdXN0IGJlIGFuIHN0cmluZyBhbmQgbm90IGVtcHR5XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmdbXXxTdHJpbmd9IFtkZXBzXSAgICBBbiBkZXBlbmRlbmN5IG9yIGFycmF5IG9mIGRlcGVuZGVuY2llc1xuICAgICAgICAgKiBAcmV0dXJucyB7VG9wb3NvcnR9ICAgICAgICAgICAgICAgICAgVGhlIFRvcG9zb3J0IGluc3RhbmNlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFRvcG9zb3J0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoIGl0ZW0sIGRlcHMgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIgfHwgIWl0ZW0gKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJEZXBlbmRlbnQgbmFtZSBtdXN0IGJlIGdpdmVuIGFzIGEgbm90IGVtcHR5IHN0cmluZ1wiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlcHMgPSBBcnJheS5pc0FycmF5KCBkZXBzICkgPyBkZXBzIDogW2RlcHNdO1xuXG4gICAgICAgICAgICBpZiggZGVwcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvciA9IGRlcHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yICksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaSA+PSBfaXRlcmF0b3IubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaS5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcCA9IF9yZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBkZXAgIT09IFwic3RyaW5nXCIgfHwgIWRlcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIFwiRGVwZW5kZW5jeSBuYW1lIG11c3QgYmUgZ2l2ZW4gYXMgYSBub3QgZW1wdHkgc3RyaW5nXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCggW2l0ZW0sIGRlcF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCggW2l0ZW1dICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIHRoZSB0b3Bvc29ydGluZyBhbmQgcmV0dXJuIGFuIG9yZGVyZWQgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAc2luY2UgICAwLjEuMFxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119ICBUaGUgbGlzdCBvZiBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgVG9wb3NvcnQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG5cbiAgICAgICAgICAgIC8vYWNjdW11bGF0ZSB1bmlxdWUgbm9kZXMgaW50byBhIGxhcmdlIGxpc3RcbiAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvcjIgPSB0aGlzLmVkZ2VzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3IyICksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiggX2kyLmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF9yZWYyO1xuXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yMyA9IGVkZ2UsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjMgKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pMy5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9yZWYzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBub2Rlcy5pbmRleE9mKCBub2RlICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIHBsYWNlbWVudCBvZiBub2RlcyBpbnRvIHRoZSBzb3J0ZWQgYXJyYXkgYXQgdGhlIGVuZFxuICAgICAgICAgICAgdmFyIHBsYWNlID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIHNvcnRlZCBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgdW5pcXVlIG5vZGVzIGFycmF5XG4gICAgICAgICAgICB2YXIgc29ydGVkID0gbmV3IEFycmF5KCBub2Rlcy5sZW5ndGggKTtcblxuICAgICAgICAgICAgLy9kZWZpbmUgYSB2aXNpdG9yIGZ1bmN0aW9uIHRoYXQgcmVjdXJzaXZlbHkgdHJhdmVyc2VzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIHZhciB2aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KCBub2RlLCBwcmVkZWNlc3NvcnMgKSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBhIG5vZGUgaXMgZGVwZW5kZW50IG9mIGl0c2VsZlxuICAgICAgICAgICAgICAgIGlmKCBwcmVkZWNlc3NvcnMubGVuZ3RoICE9PSAwICYmIHByZWRlY2Vzc29ycy5pbmRleE9mKCBub2RlICkgIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQuIFwiICsgbm9kZSArIFwiIGlzIGRlcGVuZGVudCBvZiBpdHNlbGYuXFxuRGVwZW5kZW5jeSBjaGFpbjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHByZWRlY2Vzc29ycy5qb2luKCBcIiAtPiBcIiApICsgXCIgPT4gXCIgKyBub2RlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbm9kZXMuaW5kZXhPZiggbm9kZSApO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgbm9kZSBzdGlsbCBleGlzdHMsIHRyYXZlcnNlIGl0cyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICBpZiggaW5kZXggIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29weSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgbm9kZSBhcyBmYWxzZSB0byBleGNsdWRlIGl0IGZyb20gZnV0dXJlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaW5kZXhdID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIGVkZ2VzIGFuZCBmb2xsb3cgZGVwZW5kZW5jaWVzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yNCA9IF90aGlzLmVkZ2VzLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3I0ICksIF9pNCA9IDAsIF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXk0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k0LmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pNC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfcmVmNDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGVkZ2VbMF0gPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sYXppbHkgY3JlYXRlIGEgY29weSBvZiBwcmVkZWNlc3NvcnMgd2l0aCB0aGUgY3VycmVudCBub2RlIGNvbmNhdGVuYXRlZCBvbnRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IGNvcHkgfHwgcHJlZGVjZXNzb3JzLmNvbmNhdCggW25vZGVdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlY3Vyc2UgdG8gbm9kZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdCggZWRnZVsxXSwgY29weSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIG5vZGUgdG8gdGhlIG5leHQgcGxhY2UgaW4gdGhlIHNvcnRlZCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRbLS1wbGFjZV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgICAgICAgIC8vaWdub3JlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGV4Y2x1ZGVkXG4gICAgICAgICAgICAgICAgaWYoIG5vZGUgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAvL21hcmsgdGhlIG5vZGUgYXMgZmFsc2UgdG8gZXhjbHVkZSBpdCBmcm9tIGZ1dHVyZSBpdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIGVkZ2VzIGFuZCBmb2xsb3cgZGVwZW5kZW5jaWVzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yNSA9IHRoaXMuZWRnZXMsIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjUgKSwgX2k1ID0gMCwgX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I1IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjVbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXk1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTUgPSBfaXRlcmF0b3I1Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k1LmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pNS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfcmVmNTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGVkZ2VbMF0gPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWN1cnNlIHRvIG5vZGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXQoIGVkZ2VbMV0sIFtub2RlXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIG5vZGUgdG8gdGhlIG5leHQgcGxhY2UgaW4gdGhlIHNvcnRlZCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRbLS1wbGFjZV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGVkZ2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzaW5jZSAgIDAuNC4wXG4gICAgICAgICAqIEByZXR1cm5zIHtUb3Bvc29ydH0gICAgICAgICAgICAgICAgICBUaGUgVG9wb3NvcnQgaW5zdGFuY2VcbiAgICAgICAgICovXG5cbiAgICAgICAgVG9wb3NvcnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VzID0gW107XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBUb3Bvc29ydDtcbiAgICB9KSgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3Bvc29ydDtcbn0gKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vYnVpbGQvdG9wb3NvcnQuanMnICk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluaXQgPSBleHBvcnRzLnNlcXVlbGl6ZSA9IHZvaWQgMDtcbnZhciBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xID0gcmVxdWlyZShcInNlcXVlbGl6ZS10eXBlc2NyaXB0XCIpO1xudmFyIGluaXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnNlcXVlbGl6ZSA9IG5ldyBzZXF1ZWxpemVfdHlwZXNjcmlwdF8xLlNlcXVlbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsczogW19fZGlybmFtZSArICcvZGF0YWJhc2UvbW9kZWxzLyoqLyoubW9kZWwudHMnXSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxNYXRjaDogZnVuY3Rpb24gKGZpbGVuYW1lLCBtZW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZS5zdWJzdHJpbmcoMCwgZmlsZW5hbWUuaW5kZXhPZignLm1vZGVsJykpID09PSBtZW1iZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogXCJsb2NhbGhvc3RcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2U6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgZGlhbGVjdDogJ215c3FsJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6ICdyb290JyxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHBvcnRzLnNlcXVlbGl6ZS5hdXRoZW50aWNhdGUoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREIgQ29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0byBEQlwiLCBlXzEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwb2xsb19zZXJ2ZXJfMSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyXCIpO1xudmFyIGluZGV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHlwZURlZnMvaW5kZXhcIikpO1xudmFyIGluZGV4XzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzb2x2ZXJzL2luZGV4XCIpKTtcbnZhciBzZXF1YWxpemVfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3Mvc2VxdWFsaXplXCIpO1xudmFyIHNlcnZlciA9IG5ldyBhcG9sbG9fc2VydmVyXzEuQXBvbGxvU2VydmVyKHsgdHlwZURlZnM6IGluZGV4XzEuZGVmYXVsdCwgcmVzb2x2ZXJzOiBpbmRleF8yLmRlZmF1bHQgfSk7XG5zZXF1YWxpemVfMS5pbml0KCk7XG5zZXJ2ZXIubGlzdGVuKClcbiAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsO1xuICAgIHJldHVybiBjb25zb2xlLmxvZyhcIlNlcnZlciByZWFkeSBhdCBcIiArIHVybCArIFwiLiBcIik7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3RvRGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RvRGF0ZVwiKSk7XG5cbnZhciBfdG9GbG9hdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RvRmxvYXRcIikpO1xuXG52YXIgX3RvSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9JbnRcIikpO1xuXG52YXIgX3RvQm9vbGVhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RvQm9vbGVhblwiKSk7XG5cbnZhciBfZXF1YWxzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvZXF1YWxzXCIpKTtcblxudmFyIF9jb250YWlucyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2NvbnRhaW5zXCIpKTtcblxudmFyIF9tYXRjaGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvbWF0Y2hlc1wiKSk7XG5cbnZhciBfaXNFbWFpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRW1haWxcIikpO1xuXG52YXIgX2lzVVJMID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNVUkxcIikpO1xuXG52YXIgX2lzTUFDQWRkcmVzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTUFDQWRkcmVzc1wiKSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVBcIikpO1xuXG52YXIgX2lzSVBSYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVBSYW5nZVwiKSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNGUUROXCIpKTtcblxudmFyIF9pc0Jvb2xlYW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0Jvb2xlYW5cIikpO1xuXG52YXIgX2lzQWxwaGEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvaXNBbHBoYVwiKSk7XG5cbnZhciBfaXNBbHBoYW51bWVyaWMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvaXNBbHBoYW51bWVyaWNcIikpO1xuXG52YXIgX2lzTnVtZXJpYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTnVtZXJpY1wiKSk7XG5cbnZhciBfaXNQb3J0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNQb3J0XCIpKTtcblxudmFyIF9pc0xvd2VyY2FzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTG93ZXJjYXNlXCIpKTtcblxudmFyIF9pc1VwcGVyY2FzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzVXBwZXJjYXNlXCIpKTtcblxudmFyIF9pc0FzY2lpID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNBc2NpaVwiKSk7XG5cbnZhciBfaXNGdWxsV2lkdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0Z1bGxXaWR0aFwiKSk7XG5cbnZhciBfaXNIYWxmV2lkdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hhbGZXaWR0aFwiKSk7XG5cbnZhciBfaXNWYXJpYWJsZVdpZHRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNWYXJpYWJsZVdpZHRoXCIpKTtcblxudmFyIF9pc011bHRpYnl0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTXVsdGlieXRlXCIpKTtcblxudmFyIF9pc1N1cnJvZ2F0ZVBhaXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1N1cnJvZ2F0ZVBhaXJcIikpO1xuXG52YXIgX2lzSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJbnRcIikpO1xuXG52YXIgX2lzRmxvYXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvaXNGbG9hdFwiKSk7XG5cbnZhciBfaXNEZWNpbWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNEZWNpbWFsXCIpKTtcblxudmFyIF9pc0hleGFkZWNpbWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNIZXhhZGVjaW1hbFwiKSk7XG5cbnZhciBfaXNEaXZpc2libGVCeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRGl2aXNpYmxlQnlcIikpO1xuXG52YXIgX2lzSGV4Q29sb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hleENvbG9yXCIpKTtcblxudmFyIF9pc0lTUkMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTUkNcIikpO1xuXG52YXIgX2lzTUQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc01ENVwiKSk7XG5cbnZhciBfaXNIYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNIYXNoXCIpKTtcblxudmFyIF9pc0pXVCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSldUXCIpKTtcblxudmFyIF9pc0pTT04gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0pTT05cIikpO1xuXG52YXIgX2lzRW1wdHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0VtcHR5XCIpKTtcblxudmFyIF9pc0xlbmd0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTGVuZ3RoXCIpKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0J5dGVMZW5ndGhcIikpO1xuXG52YXIgX2lzVVVJRCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzVVVJRFwiKSk7XG5cbnZhciBfaXNNb25nb0lkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNb25nb0lkXCIpKTtcblxudmFyIF9pc0FmdGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNBZnRlclwiKSk7XG5cbnZhciBfaXNCZWZvcmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0JlZm9yZVwiKSk7XG5cbnZhciBfaXNJbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSW5cIikpO1xuXG52YXIgX2lzQ3JlZGl0Q2FyZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQ3JlZGl0Q2FyZFwiKSk7XG5cbnZhciBfaXNJZGVudGl0eUNhcmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lkZW50aXR5Q2FyZFwiKSk7XG5cbnZhciBfaXNJU0lOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJU0lOXCIpKTtcblxudmFyIF9pc0lTQk4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTQk5cIikpO1xuXG52YXIgX2lzSVNTTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNTTlwiKSk7XG5cbnZhciBfaXNNb2JpbGVQaG9uZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc01vYmlsZVBob25lXCIpKTtcblxudmFyIF9pc0N1cnJlbmN5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNDdXJyZW5jeVwiKSk7XG5cbnZhciBfaXNJU08gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTTzg2MDFcIikpO1xuXG52YXIgX2lzUkZDID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNSRkMzMzM5XCIpKTtcblxudmFyIF9pc0lTTzMxNjYxQWxwaGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTTzMxNjYxQWxwaGEyXCIpKTtcblxudmFyIF9pc0lTTzMxNjYxQWxwaGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJU08zMTY2MUFscGhhM1wiKSk7XG5cbnZhciBfaXNCYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNCYXNlNjRcIikpO1xuXG52YXIgX2lzRGF0YVVSSSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRGF0YVVSSVwiKSk7XG5cbnZhciBfaXNNYWduZXRVUkkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc01hZ25ldFVSSVwiKSk7XG5cbnZhciBfaXNNaW1lVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTWltZVR5cGVcIikpO1xuXG52YXIgX2lzTGF0TG9uZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTGF0TG9uZ1wiKSk7XG5cbnZhciBfaXNQb3N0YWxDb2RlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbGliL2lzUG9zdGFsQ29kZVwiKSk7XG5cbnZhciBfbHRyaW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9sdHJpbVwiKSk7XG5cbnZhciBfcnRyaW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9ydHJpbVwiKSk7XG5cbnZhciBfdHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RyaW1cIikpO1xuXG52YXIgX2VzY2FwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2VzY2FwZVwiKSk7XG5cbnZhciBfdW5lc2NhcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi91bmVzY2FwZVwiKSk7XG5cbnZhciBfc3RyaXBMb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9zdHJpcExvd1wiKSk7XG5cbnZhciBfd2hpdGVsaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd2hpdGVsaXN0XCIpKTtcblxudmFyIF9ibGFja2xpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9ibGFja2xpc3RcIikpO1xuXG52YXIgX2lzV2hpdGVsaXN0ZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1doaXRlbGlzdGVkXCIpKTtcblxudmFyIF9ub3JtYWxpemVFbWFpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL25vcm1hbGl6ZUVtYWlsXCIpKTtcblxudmFyIF90b1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3V0aWwvdG9TdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB2ZXJzaW9uID0gJzEwLjExLjAnO1xudmFyIHZhbGlkYXRvciA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgdG9EYXRlOiBfdG9EYXRlLmRlZmF1bHQsXG4gIHRvRmxvYXQ6IF90b0Zsb2F0LmRlZmF1bHQsXG4gIHRvSW50OiBfdG9JbnQuZGVmYXVsdCxcbiAgdG9Cb29sZWFuOiBfdG9Cb29sZWFuLmRlZmF1bHQsXG4gIGVxdWFsczogX2VxdWFscy5kZWZhdWx0LFxuICBjb250YWluczogX2NvbnRhaW5zLmRlZmF1bHQsXG4gIG1hdGNoZXM6IF9tYXRjaGVzLmRlZmF1bHQsXG4gIGlzRW1haWw6IF9pc0VtYWlsLmRlZmF1bHQsXG4gIGlzVVJMOiBfaXNVUkwuZGVmYXVsdCxcbiAgaXNNQUNBZGRyZXNzOiBfaXNNQUNBZGRyZXNzLmRlZmF1bHQsXG4gIGlzSVA6IF9pc0lQLmRlZmF1bHQsXG4gIGlzSVBSYW5nZTogX2lzSVBSYW5nZS5kZWZhdWx0LFxuICBpc0ZRRE46IF9pc0ZRRE4uZGVmYXVsdCxcbiAgaXNCb29sZWFuOiBfaXNCb29sZWFuLmRlZmF1bHQsXG4gIGlzQWxwaGE6IF9pc0FscGhhLmRlZmF1bHQsXG4gIGlzQWxwaGFMb2NhbGVzOiBfaXNBbHBoYS5sb2NhbGVzLFxuICBpc0FscGhhbnVtZXJpYzogX2lzQWxwaGFudW1lcmljLmRlZmF1bHQsXG4gIGlzQWxwaGFudW1lcmljTG9jYWxlczogX2lzQWxwaGFudW1lcmljLmxvY2FsZXMsXG4gIGlzTnVtZXJpYzogX2lzTnVtZXJpYy5kZWZhdWx0LFxuICBpc1BvcnQ6IF9pc1BvcnQuZGVmYXVsdCxcbiAgaXNMb3dlcmNhc2U6IF9pc0xvd2VyY2FzZS5kZWZhdWx0LFxuICBpc1VwcGVyY2FzZTogX2lzVXBwZXJjYXNlLmRlZmF1bHQsXG4gIGlzQXNjaWk6IF9pc0FzY2lpLmRlZmF1bHQsXG4gIGlzRnVsbFdpZHRoOiBfaXNGdWxsV2lkdGguZGVmYXVsdCxcbiAgaXNIYWxmV2lkdGg6IF9pc0hhbGZXaWR0aC5kZWZhdWx0LFxuICBpc1ZhcmlhYmxlV2lkdGg6IF9pc1ZhcmlhYmxlV2lkdGguZGVmYXVsdCxcbiAgaXNNdWx0aWJ5dGU6IF9pc011bHRpYnl0ZS5kZWZhdWx0LFxuICBpc1N1cnJvZ2F0ZVBhaXI6IF9pc1N1cnJvZ2F0ZVBhaXIuZGVmYXVsdCxcbiAgaXNJbnQ6IF9pc0ludC5kZWZhdWx0LFxuICBpc0Zsb2F0OiBfaXNGbG9hdC5kZWZhdWx0LFxuICBpc0Zsb2F0TG9jYWxlczogX2lzRmxvYXQubG9jYWxlcyxcbiAgaXNEZWNpbWFsOiBfaXNEZWNpbWFsLmRlZmF1bHQsXG4gIGlzSGV4YWRlY2ltYWw6IF9pc0hleGFkZWNpbWFsLmRlZmF1bHQsXG4gIGlzRGl2aXNpYmxlQnk6IF9pc0RpdmlzaWJsZUJ5LmRlZmF1bHQsXG4gIGlzSGV4Q29sb3I6IF9pc0hleENvbG9yLmRlZmF1bHQsXG4gIGlzSVNSQzogX2lzSVNSQy5kZWZhdWx0LFxuICBpc01ENTogX2lzTUQuZGVmYXVsdCxcbiAgaXNIYXNoOiBfaXNIYXNoLmRlZmF1bHQsXG4gIGlzSldUOiBfaXNKV1QuZGVmYXVsdCxcbiAgaXNKU09OOiBfaXNKU09OLmRlZmF1bHQsXG4gIGlzRW1wdHk6IF9pc0VtcHR5LmRlZmF1bHQsXG4gIGlzTGVuZ3RoOiBfaXNMZW5ndGguZGVmYXVsdCxcbiAgaXNCeXRlTGVuZ3RoOiBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQsXG4gIGlzVVVJRDogX2lzVVVJRC5kZWZhdWx0LFxuICBpc01vbmdvSWQ6IF9pc01vbmdvSWQuZGVmYXVsdCxcbiAgaXNBZnRlcjogX2lzQWZ0ZXIuZGVmYXVsdCxcbiAgaXNCZWZvcmU6IF9pc0JlZm9yZS5kZWZhdWx0LFxuICBpc0luOiBfaXNJbi5kZWZhdWx0LFxuICBpc0NyZWRpdENhcmQ6IF9pc0NyZWRpdENhcmQuZGVmYXVsdCxcbiAgaXNJZGVudGl0eUNhcmQ6IF9pc0lkZW50aXR5Q2FyZC5kZWZhdWx0LFxuICBpc0lTSU46IF9pc0lTSU4uZGVmYXVsdCxcbiAgaXNJU0JOOiBfaXNJU0JOLmRlZmF1bHQsXG4gIGlzSVNTTjogX2lzSVNTTi5kZWZhdWx0LFxuICBpc01vYmlsZVBob25lOiBfaXNNb2JpbGVQaG9uZS5kZWZhdWx0LFxuICBpc01vYmlsZVBob25lTG9jYWxlczogX2lzTW9iaWxlUGhvbmUubG9jYWxlcyxcbiAgaXNQb3N0YWxDb2RlOiBfaXNQb3N0YWxDb2RlLmRlZmF1bHQsXG4gIGlzUG9zdGFsQ29kZUxvY2FsZXM6IF9pc1Bvc3RhbENvZGUubG9jYWxlcyxcbiAgaXNDdXJyZW5jeTogX2lzQ3VycmVuY3kuZGVmYXVsdCxcbiAgaXNJU084NjAxOiBfaXNJU08uZGVmYXVsdCxcbiAgaXNSRkMzMzM5OiBfaXNSRkMuZGVmYXVsdCxcbiAgaXNJU08zMTY2MUFscGhhMjogX2lzSVNPMzE2NjFBbHBoYS5kZWZhdWx0LFxuICBpc0lTTzMxNjYxQWxwaGEzOiBfaXNJU08zMTY2MUFscGhhMi5kZWZhdWx0LFxuICBpc0Jhc2U2NDogX2lzQmFzZS5kZWZhdWx0LFxuICBpc0RhdGFVUkk6IF9pc0RhdGFVUkkuZGVmYXVsdCxcbiAgaXNNYWduZXRVUkk6IF9pc01hZ25ldFVSSS5kZWZhdWx0LFxuICBpc01pbWVUeXBlOiBfaXNNaW1lVHlwZS5kZWZhdWx0LFxuICBpc0xhdExvbmc6IF9pc0xhdExvbmcuZGVmYXVsdCxcbiAgbHRyaW06IF9sdHJpbS5kZWZhdWx0LFxuICBydHJpbTogX3J0cmltLmRlZmF1bHQsXG4gIHRyaW06IF90cmltLmRlZmF1bHQsXG4gIGVzY2FwZTogX2VzY2FwZS5kZWZhdWx0LFxuICB1bmVzY2FwZTogX3VuZXNjYXBlLmRlZmF1bHQsXG4gIHN0cmlwTG93OiBfc3RyaXBMb3cuZGVmYXVsdCxcbiAgd2hpdGVsaXN0OiBfd2hpdGVsaXN0LmRlZmF1bHQsXG4gIGJsYWNrbGlzdDogX2JsYWNrbGlzdC5kZWZhdWx0LFxuICBpc1doaXRlbGlzdGVkOiBfaXNXaGl0ZWxpc3RlZC5kZWZhdWx0LFxuICBub3JtYWxpemVFbWFpbDogX25vcm1hbGl6ZUVtYWlsLmRlZmF1bHQsXG4gIHRvU3RyaW5nOiBfdG9TdHJpbmcuZGVmYXVsdFxufTtcbnZhciBfZGVmYXVsdCA9IHZhbGlkYXRvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb21tYURlY2ltYWwgPSBleHBvcnRzLmRvdERlY2ltYWwgPSBleHBvcnRzLmFyYWJpY0xvY2FsZXMgPSBleHBvcnRzLmVuZ2xpc2hMb2NhbGVzID0gZXhwb3J0cy5kZWNpbWFsID0gZXhwb3J0cy5hbHBoYW51bWVyaWMgPSBleHBvcnRzLmFscGhhID0gdm9pZCAwO1xudmFyIGFscGhhID0ge1xuICAnZW4tVVMnOiAvXltBLVpdKyQvaSxcbiAgJ2JnLUJHJzogL15b0JAt0K9dKyQvaSxcbiAgJ2NzLUNaJzogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSskL2ksXG4gICdkYS1ESyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnZGUtREUnOiAvXltBLVrDhMOWw5zDn10rJC9pLFxuICAnZWwtR1InOiAvXlvOkS3PiV0rJC9pLFxuICAnZXMtRVMnOiAvXltBLVrDgcOJw43DkcOTw5rDnF0rJC9pLFxuICAnZnItRlInOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0rJC9pLFxuICAnaXQtSVQnOiAvXltBLVrDgMOJw4jDjMOOw5PDksOZXSskL2ksXG4gICduYi1OTyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnbmwtTkwnOiAvXltBLVrDgcOJw4vDj8OTw5bDnMOaXSskL2ksXG4gICdubi1OTyc6IC9eW0EtWsOGw5jDhV0rJC9pLFxuICAnaHUtSFUnOiAvXltBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKyQvaSxcbiAgJ3BsLVBMJzogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSskL2ksXG4gICdwdC1QVCc6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSskL2ksXG4gICdydS1SVSc6IC9eW9CQLdCv0IFdKyQvaSxcbiAgJ3NsLVNJJzogL15bQS1axIzEhsSQxaDFvV0rJC9pLFxuICAnc2stU0snOiAvXltBLVrDgcSMxI7DicONxYfDk8WgxaTDmsOdxb3EucWUxL3DhMOUXSskL2ksXG4gICdzci1SU0BsYXRpbic6IC9eW0EtWsSMxIbFvcWgxJBdKyQvaSxcbiAgJ3NyLVJTJzogL15b0JAt0K/QgtCI0InQitCL0I9dKyQvaSxcbiAgJ3N2LVNFJzogL15bQS1aw4XDhMOWXSskL2ksXG4gICd0ci1UUic6IC9eW0EtWsOHxJ7EsMSxw5bFnsOcXSskL2ksXG4gICd1ay1VQSc6IC9eW9CQLdCp0KzQrtCv0IRJ0IfSkNGWXSskL2ksXG4gICdrdS1JUSc6IC9eW9im2KfYqNm+2KrYrNqG2K3Yrtiv2LHaldiy2pjYs9i02LnYutmB2qTZgtqp2q/ZhNq12YXZhtmI24bavtuV24zbjtmK2LfYpNir2KLYpdij2YPYtti12KnYuNiwXSskL2ksXG4gIGFyOiAvXlvYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKyQvXG59O1xuZXhwb3J0cy5hbHBoYSA9IGFscGhhO1xudmFyIGFscGhhbnVtZXJpYyA9IHtcbiAgJ2VuLVVTJzogL15bMC05QS1aXSskL2ksXG4gICdiZy1CRyc6IC9eWzAtOdCQLdCvXSskL2ksXG4gICdjcy1DWic6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0rJC9pLFxuICAnZGEtREsnOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ2RlLURFJzogL15bMC05QS1aw4TDlsOcw59dKyQvaSxcbiAgJ2VsLUdSJzogL15bMC05zpEtz4ldKyQvaSxcbiAgJ2VzLUVTJzogL15bMC05QS1aw4HDicONw5HDk8Oaw5xdKyQvaSxcbiAgJ2ZyLUZSJzogL15bMC05QS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhdKyQvaSxcbiAgJ2l0LUlUJzogL15bMC05QS1aw4DDicOIw4zDjsOTw5LDmV0rJC9pLFxuICAnaHUtSFUnOiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBdKyQvaSxcbiAgJ25iLU5PJzogL15bMC05QS1aw4bDmMOFXSskL2ksXG4gICdubC1OTCc6IC9eWzAtOUEtWsOBw4nDi8OPw5PDlsOcw5pdKyQvaSxcbiAgJ25uLU5PJzogL15bMC05QS1aw4bDmMOFXSskL2ksXG4gICdwbC1QTCc6IC9eWzAtOUEtWsSExIbEmMWaxYHFg8OTxbvFuV0rJC9pLFxuICAncHQtUFQnOiAvXlswLTlBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0rJC9pLFxuICAncnUtUlUnOiAvXlswLTnQkC3Qr9CBXSskL2ksXG4gICdzbC1TSSc6IC9eWzAtOUEtWsSMxIbEkMWgxb1dKyQvaSxcbiAgJ3NrLVNLJzogL15bMC05QS1aw4HEjMSOw4nDjcWHw5PFoMWkw5rDncW9xLnFlMS9w4TDlF0rJC9pLFxuICAnc3ItUlNAbGF0aW4nOiAvXlswLTlBLVrEjMSGxb3FoMSQXSskL2ksXG4gICdzci1SUyc6IC9eWzAtOdCQLdCv0ILQiNCJ0IrQi9CPXSskL2ksXG4gICdzdi1TRSc6IC9eWzAtOUEtWsOFw4TDll0rJC9pLFxuICAndHItVFInOiAvXlswLTlBLVrDh8SexLDEscOWxZ7DnF0rJC9pLFxuICAndWstVUEnOiAvXlswLTnQkC3QqdCs0K7Qr9CESdCH0pDRll0rJC9pLFxuICAna3UtSVEnOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdim2KfYqNm+2KrYrNqG2K3Yrtiv2LHaldiy2pjYs9i02LnYutmB2qTZgtqp2q/ZhNq12YXZhtmI24bavtuV24zbjtmK2LfYpNir2KLYpdij2YPYtti12KnYuNiwXSskL2ksXG4gIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0rJC9cbn07XG5leHBvcnRzLmFscGhhbnVtZXJpYyA9IGFscGhhbnVtZXJpYztcbnZhciBkZWNpbWFsID0ge1xuICAnZW4tVVMnOiAnLicsXG4gIGFyOiAn2asnXG59O1xuZXhwb3J0cy5kZWNpbWFsID0gZGVjaW1hbDtcbnZhciBlbmdsaXNoTG9jYWxlcyA9IFsnQVUnLCAnR0InLCAnSEsnLCAnSU4nLCAnTlonLCAnWkEnLCAnWk0nXTtcbmV4cG9ydHMuZW5nbGlzaExvY2FsZXMgPSBlbmdsaXNoTG9jYWxlcztcblxuZm9yICh2YXIgbG9jYWxlLCBpID0gMDsgaSA8IGVuZ2xpc2hMb2NhbGVzLmxlbmd0aDsgaSsrKSB7XG4gIGxvY2FsZSA9IFwiZW4tXCIuY29uY2F0KGVuZ2xpc2hMb2NhbGVzW2ldKTtcbiAgYWxwaGFbbG9jYWxlXSA9IGFscGhhWydlbi1VUyddO1xuICBhbHBoYW51bWVyaWNbbG9jYWxlXSA9IGFscGhhbnVtZXJpY1snZW4tVVMnXTtcbiAgZGVjaW1hbFtsb2NhbGVdID0gZGVjaW1hbFsnZW4tVVMnXTtcbn0gLy8gU291cmNlOiBodHRwOi8vd3d3LmxvY2FsZXBsYW5ldC5jb20vamF2YS9cblxuXG52YXIgYXJhYmljTG9jYWxlcyA9IFsnQUUnLCAnQkgnLCAnRFonLCAnRUcnLCAnSVEnLCAnSk8nLCAnS1cnLCAnTEInLCAnTFknLCAnTUEnLCAnUU0nLCAnUUEnLCAnU0EnLCAnU0QnLCAnU1knLCAnVE4nLCAnWUUnXTtcbmV4cG9ydHMuYXJhYmljTG9jYWxlcyA9IGFyYWJpY0xvY2FsZXM7XG5cbmZvciAodmFyIF9sb2NhbGUsIF9pID0gMDsgX2kgPCBhcmFiaWNMb2NhbGVzLmxlbmd0aDsgX2krKykge1xuICBfbG9jYWxlID0gXCJhci1cIi5jb25jYXQoYXJhYmljTG9jYWxlc1tfaV0pO1xuICBhbHBoYVtfbG9jYWxlXSA9IGFscGhhLmFyO1xuICBhbHBoYW51bWVyaWNbX2xvY2FsZV0gPSBhbHBoYW51bWVyaWMuYXI7XG4gIGRlY2ltYWxbX2xvY2FsZV0gPSBkZWNpbWFsLmFyO1xufSAvLyBTb3VyY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlY2ltYWxfbWFya1xuXG5cbnZhciBkb3REZWNpbWFsID0gW107XG5leHBvcnRzLmRvdERlY2ltYWwgPSBkb3REZWNpbWFsO1xudmFyIGNvbW1hRGVjaW1hbCA9IFsnYmctQkcnLCAnY3MtQ1onLCAnZGEtREsnLCAnZGUtREUnLCAnZWwtR1InLCAnZXMtRVMnLCAnZnItRlInLCAnaXQtSVQnLCAna3UtSVEnLCAnaHUtSFUnLCAnbmItTk8nLCAnbm4tTk8nLCAnbmwtTkwnLCAncGwtUEwnLCAncHQtUFQnLCAncnUtUlUnLCAnc2wtU0knLCAnc3ItUlNAbGF0aW4nLCAnc3ItUlMnLCAnc3YtU0UnLCAndHItVFInLCAndWstVUEnXTtcbmV4cG9ydHMuY29tbWFEZWNpbWFsID0gY29tbWFEZWNpbWFsO1xuXG5mb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBkb3REZWNpbWFsLmxlbmd0aDsgX2kyKyspIHtcbiAgZGVjaW1hbFtkb3REZWNpbWFsW19pMl1dID0gZGVjaW1hbFsnZW4tVVMnXTtcbn1cblxuZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY29tbWFEZWNpbWFsLmxlbmd0aDsgX2kzKyspIHtcbiAgZGVjaW1hbFtjb21tYURlY2ltYWxbX2kzXV0gPSAnLCc7XG59XG5cbmFscGhhWydwdC1CUiddID0gYWxwaGFbJ3B0LVBUJ107XG5hbHBoYW51bWVyaWNbJ3B0LUJSJ10gPSBhbHBoYW51bWVyaWNbJ3B0LVBUJ107XG5kZWNpbWFsWydwdC1CUiddID0gZGVjaW1hbFsncHQtUFQnXTsgLy8gc2VlICM4NjJcblxuYWxwaGFbJ3BsLVBsJ10gPSBhbHBoYVsncGwtUEwnXTtcbmFscGhhbnVtZXJpY1sncGwtUGwnXSA9IGFscGhhbnVtZXJpY1sncGwtUEwnXTtcbmRlY2ltYWxbJ3BsLVBsJ10gPSBkZWNpbWFsWydwbC1QTCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYmxhY2tsaXN0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBibGFja2xpc3Qoc3RyLCBjaGFycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcIi5jb25jYXQoY2hhcnMsIFwiXStcIiksICdnJyksICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29udGFpbnM7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfdG9TdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvdG9TdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjb250YWlucyhzdHIsIGVsZW0pIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCgwLCBfdG9TdHJpbmcuZGVmYXVsdCkoZWxlbSkpID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFscztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXF1YWxzKHN0ciwgY29tcGFyaXNvbikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyID09PSBjb21wYXJpc29uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlc2NhcGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmI3gyNzsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1xcLy9nLCAnJiN4MkY7JykucmVwbGFjZSgvXFxcXC9nLCAnJiN4NUM7JykucmVwbGFjZSgvYC9nLCAnJiM5NjsnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBZnRlcjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF90b0RhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RvRGF0ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIoc3RyKSB7XG4gIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTdHJpbmcobmV3IERhdGUoKSk7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBjb21wYXJpc29uID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoZGF0ZSk7XG4gIHZhciBvcmlnaW5hbCA9ICgwLCBfdG9EYXRlLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAhIShvcmlnaW5hbCAmJiBjb21wYXJpc29uICYmIG9yaWdpbmFsID4gY29tcGFyaXNvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWxwaGE7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBbHBoYShzdHIpIHtcbiAgdmFyIGxvY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2VuLVVTJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAobG9jYWxlIGluIF9hbHBoYS5hbHBoYSkge1xuICAgIHJldHVybiBfYWxwaGEuYWxwaGFbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhfYWxwaGEuYWxwaGEpO1xuZXhwb3J0cy5sb2NhbGVzID0gbG9jYWxlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWxwaGFudW1lcmljO1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2FscGhhID0gcmVxdWlyZShcIi4vYWxwaGFcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQWxwaGFudW1lcmljKHN0cikge1xuICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZW4tVVMnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gX2FscGhhLmFscGhhbnVtZXJpYykge1xuICAgIHJldHVybiBfYWxwaGEuYWxwaGFudW1lcmljW2xvY2FsZV0udGVzdChzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59XG5cbnZhciBsb2NhbGVzID0gT2JqZWN0LmtleXMoX2FscGhhLmFscGhhbnVtZXJpYyk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBc2NpaTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xudmFyIGFzY2lpID0gL15bXFx4MDAtXFx4N0ZdKyQvO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmZ1bmN0aW9uIGlzQXNjaWkoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBhc2NpaS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmFzZTY0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm90QmFzZTY0ID0gL1teQS1aMC05K1xcLz1dL2k7XG5cbmZ1bmN0aW9uIGlzQmFzZTY0KHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcblxuICBpZiAoIWxlbiB8fCBsZW4gJSA0ICE9PSAwIHx8IG5vdEJhc2U2NC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZmlyc3RQYWRkaW5nQ2hhciA9IHN0ci5pbmRleE9mKCc9Jyk7XG4gIHJldHVybiBmaXJzdFBhZGRpbmdDaGFyID09PSAtMSB8fCBmaXJzdFBhZGRpbmdDaGFyID09PSBsZW4gLSAxIHx8IGZpcnN0UGFkZGluZ0NoYXIgPT09IGxlbiAtIDIgJiYgc3RyW2xlbiAtIDFdID09PSAnPSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmVmb3JlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvRGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9EYXRlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNCZWZvcmUoc3RyKSB7XG4gIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTdHJpbmcobmV3IERhdGUoKSk7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBjb21wYXJpc29uID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoZGF0ZSk7XG4gIHZhciBvcmlnaW5hbCA9ICgwLCBfdG9EYXRlLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAhIShvcmlnaW5hbCAmJiBjb21wYXJpc29uICYmIG9yaWdpbmFsIDwgY29tcGFyaXNvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQm9vbGVhbjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNCb29sZWFuKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gWyd0cnVlJywgJ2ZhbHNlJywgJzEnLCAnMCddLmluZGV4T2Yoc3RyKSA+PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0J5dGVMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuZnVuY3Rpb24gaXNCeXRlTGVuZ3RoKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgIG1pbiA9IG9wdGlvbnMubWluIHx8IDA7XG4gICAgbWF4ID0gb3B0aW9ucy5tYXg7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlzQnl0ZUxlbmd0aChzdHIsIG1pbiBbLCBtYXhdKVxuICAgIG1pbiA9IGFyZ3VtZW50c1sxXTtcbiAgICBtYXggPSBhcmd1bWVudHNbMl07XG4gIH1cblxuICB2YXIgbGVuID0gZW5jb2RlVVJJKHN0cikuc3BsaXQoLyUuLnwuLykubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGxlbiA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IGxlbiA8PSBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0NyZWRpdENhcmQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBjcmVkaXRDYXJkID0gL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18KDIyMlsxLTldfDIyWzMtOV1bMC05XXwyWzMtNl1bMC05XXsyfXwyN1swMV1bMC05XXwyNzIwKVswLTldezEyfXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX18NlsyN11bMC05XXsxNH0pJC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gaXNDcmVkaXRDYXJkKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1stIF0rL2csICcnKTtcblxuICBpZiAoIWNyZWRpdENhcmQudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBkaWdpdDtcbiAgdmFyIHRtcE51bTtcbiAgdmFyIHNob3VsZERvdWJsZTtcblxuICBmb3IgKHZhciBpID0gc2FuaXRpemVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGlnaXQgPSBzYW5pdGl6ZWQuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuXG4gICAgaWYgKHNob3VsZERvdWJsZSkge1xuICAgICAgdG1wTnVtICo9IDI7XG5cbiAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcbiAgICAgICAgc3VtICs9IHRtcE51bSAlIDEwICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuXG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcbiAgfVxuXG4gIHJldHVybiAhIShzdW0gJSAxMCA9PT0gMCA/IHNhbml0aXplZCA6IGZhbHNlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDdXJyZW5jeTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGN1cnJlbmN5UmVnZXgob3B0aW9ucykge1xuICB2YXIgZGVjaW1hbF9kaWdpdHMgPSBcIlxcXFxke1wiLmNvbmNhdChvcHRpb25zLmRpZ2l0c19hZnRlcl9kZWNpbWFsWzBdLCBcIn1cIik7XG4gIG9wdGlvbnMuZGlnaXRzX2FmdGVyX2RlY2ltYWwuZm9yRWFjaChmdW5jdGlvbiAoZGlnaXQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICE9PSAwKSBkZWNpbWFsX2RpZ2l0cyA9IFwiXCIuY29uY2F0KGRlY2ltYWxfZGlnaXRzLCBcInxcXFxcZHtcIikuY29uY2F0KGRpZ2l0LCBcIn1cIik7XG4gIH0pO1xuICB2YXIgc3ltYm9sID0gXCIoXFxcXFwiLmNvbmNhdChvcHRpb25zLnN5bWJvbC5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJyksIFwiKVwiKS5jb25jYXQob3B0aW9ucy5yZXF1aXJlX3N5bWJvbCA/ICcnIDogJz8nKSxcbiAgICAgIG5lZ2F0aXZlID0gJy0/JyxcbiAgICAgIHdob2xlX2RvbGxhcl9hbW91bnRfd2l0aG91dF9zZXAgPSAnWzEtOV1cXFxcZConLFxuICAgICAgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRoX3NlcCA9IFwiWzEtOV1cXFxcZHswLDJ9KFxcXFxcIi5jb25jYXQob3B0aW9ucy50aG91c2FuZHNfc2VwYXJhdG9yLCBcIlxcXFxkezN9KSpcIiksXG4gICAgICB2YWxpZF93aG9sZV9kb2xsYXJfYW1vdW50cyA9IFsnMCcsIHdob2xlX2RvbGxhcl9hbW91bnRfd2l0aG91dF9zZXAsIHdob2xlX2RvbGxhcl9hbW91bnRfd2l0aF9zZXBdLFxuICAgICAgd2hvbGVfZG9sbGFyX2Ftb3VudCA9IFwiKFwiLmNvbmNhdCh2YWxpZF93aG9sZV9kb2xsYXJfYW1vdW50cy5qb2luKCd8JyksIFwiKT9cIiksXG4gICAgICBkZWNpbWFsX2Ftb3VudCA9IFwiKFxcXFxcIi5jb25jYXQob3B0aW9ucy5kZWNpbWFsX3NlcGFyYXRvciwgXCIoXCIpLmNvbmNhdChkZWNpbWFsX2RpZ2l0cywgXCIpKVwiKS5jb25jYXQob3B0aW9ucy5yZXF1aXJlX2RlY2ltYWwgPyAnJyA6ICc/Jyk7XG4gIHZhciBwYXR0ZXJuID0gd2hvbGVfZG9sbGFyX2Ftb3VudCArIChvcHRpb25zLmFsbG93X2RlY2ltYWwgfHwgb3B0aW9ucy5yZXF1aXJlX2RlY2ltYWwgPyBkZWNpbWFsX2Ftb3VudCA6ICcnKTsgLy8gZGVmYXVsdCBpcyBuZWdhdGl2ZSBzaWduIGJlZm9yZSBzeW1ib2wsIGJ1dCB0aGVyZSBhcmUgdHdvIG90aGVyIG9wdGlvbnMgKGJlc2lkZXMgcGFyZW5zKVxuXG4gIGlmIChvcHRpb25zLmFsbG93X25lZ2F0aXZlcyAmJiAhb3B0aW9ucy5wYXJlbnNfZm9yX25lZ2F0aXZlcykge1xuICAgIGlmIChvcHRpb25zLm5lZ2F0aXZlX3NpZ25fYWZ0ZXJfZGlnaXRzKSB7XG4gICAgICBwYXR0ZXJuICs9IG5lZ2F0aXZlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5uZWdhdGl2ZV9zaWduX2JlZm9yZV9kaWdpdHMpIHtcbiAgICAgIHBhdHRlcm4gPSBuZWdhdGl2ZSArIHBhdHRlcm47XG4gICAgfVxuICB9IC8vIFNvdXRoIEFmcmljYW4gUmFuZCwgZm9yIGV4YW1wbGUsIHVzZXMgUiAxMjMgKHNwYWNlKSBhbmQgUi0xMjMgKG5vIHNwYWNlKVxuXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfbmVnYXRpdmVfc2lnbl9wbGFjZWhvbGRlcikge1xuICAgIHBhdHRlcm4gPSBcIiggKD8hXFxcXC0pKT9cIi5jb25jYXQocGF0dGVybik7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxvd19zcGFjZV9hZnRlcl9zeW1ib2wpIHtcbiAgICBwYXR0ZXJuID0gXCIgP1wiLmNvbmNhdChwYXR0ZXJuKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93X3NwYWNlX2FmdGVyX2RpZ2l0cykge1xuICAgIHBhdHRlcm4gKz0gJyggKD8hJCkpPyc7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zeW1ib2xfYWZ0ZXJfZGlnaXRzKSB7XG4gICAgcGF0dGVybiArPSBzeW1ib2w7XG4gIH0gZWxzZSB7XG4gICAgcGF0dGVybiA9IHN5bWJvbCArIHBhdHRlcm47XG4gIH1cblxuICBpZiAob3B0aW9ucy5hbGxvd19uZWdhdGl2ZXMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnNfZm9yX25lZ2F0aXZlcykge1xuICAgICAgcGF0dGVybiA9IFwiKFxcXFwoXCIuY29uY2F0KHBhdHRlcm4sIFwiXFxcXCl8XCIpLmNvbmNhdChwYXR0ZXJuLCBcIilcIik7XG4gICAgfSBlbHNlIGlmICghKG9wdGlvbnMubmVnYXRpdmVfc2lnbl9iZWZvcmVfZGlnaXRzIHx8IG9wdGlvbnMubmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHMpKSB7XG4gICAgICBwYXR0ZXJuID0gbmVnYXRpdmUgKyBwYXR0ZXJuO1xuICAgIH1cbiAgfSAvLyBlbnN1cmUgdGhlcmUncyBhIGRvbGxhciBhbmQvb3IgZGVjaW1hbCBhbW91bnQsIGFuZCB0aGF0XG4gIC8vIGl0IGRvZXNuJ3Qgc3RhcnQgd2l0aCBhIHNwYWNlIG9yIGEgbmVnYXRpdmUgc2lnbiBmb2xsb3dlZCBieSBhIHNwYWNlXG5cblxuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPyEtPyApKD89LipcXFxcZClcIi5jb25jYXQocGF0dGVybiwgXCIkXCIpKTtcbn1cblxudmFyIGRlZmF1bHRfY3VycmVuY3lfb3B0aW9ucyA9IHtcbiAgc3ltYm9sOiAnJCcsXG4gIHJlcXVpcmVfc3ltYm9sOiBmYWxzZSxcbiAgYWxsb3dfc3BhY2VfYWZ0ZXJfc3ltYm9sOiBmYWxzZSxcbiAgc3ltYm9sX2FmdGVyX2RpZ2l0czogZmFsc2UsXG4gIGFsbG93X25lZ2F0aXZlczogdHJ1ZSxcbiAgcGFyZW5zX2Zvcl9uZWdhdGl2ZXM6IGZhbHNlLFxuICBuZWdhdGl2ZV9zaWduX2JlZm9yZV9kaWdpdHM6IGZhbHNlLFxuICBuZWdhdGl2ZV9zaWduX2FmdGVyX2RpZ2l0czogZmFsc2UsXG4gIGFsbG93X25lZ2F0aXZlX3NpZ25fcGxhY2Vob2xkZXI6IGZhbHNlLFxuICB0aG91c2FuZHNfc2VwYXJhdG9yOiAnLCcsXG4gIGRlY2ltYWxfc2VwYXJhdG9yOiAnLicsXG4gIGFsbG93X2RlY2ltYWw6IHRydWUsXG4gIHJlcXVpcmVfZGVjaW1hbDogZmFsc2UsXG4gIGRpZ2l0c19hZnRlcl9kZWNpbWFsOiBbMl0sXG4gIGFsbG93X3NwYWNlX2FmdGVyX2RpZ2l0czogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzQ3VycmVuY3koc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfY3VycmVuY3lfb3B0aW9ucyk7XG4gIHJldHVybiBjdXJyZW5jeVJlZ2V4KG9wdGlvbnMpLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEYXRhVVJJO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdmFsaWRNZWRpYVR5cGUgPSAvXlthLXpdK1xcL1thLXowLTlcXC1cXCtdKyQvaTtcbnZhciB2YWxpZEF0dHJpYnV0ZSA9IC9eW2EtelxcLV0rPVthLXowLTlcXC1dKyQvaTtcbnZhciB2YWxpZERhdGEgPSAvXlthLXowLTkhXFwkJidcXChcXClcXCpcXCssOz1cXC1cXC5ffjpAXFwvXFw/JVxcc10qJC9pO1xuXG5mdW5jdGlvbiBpc0RhdGFVUkkoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBkYXRhID0gc3RyLnNwbGl0KCcsJyk7XG5cbiAgaWYgKGRhdGEubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVzID0gZGF0YS5zaGlmdCgpLnRyaW0oKS5zcGxpdCgnOycpO1xuICB2YXIgc2NoZW1lQW5kTWVkaWFUeXBlID0gYXR0cmlidXRlcy5zaGlmdCgpO1xuXG4gIGlmIChzY2hlbWVBbmRNZWRpYVR5cGUuc3Vic3RyKDAsIDUpICE9PSAnZGF0YTonKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1lZGlhVHlwZSA9IHNjaGVtZUFuZE1lZGlhVHlwZS5zdWJzdHIoNSk7XG5cbiAgaWYgKG1lZGlhVHlwZSAhPT0gJycgJiYgIXZhbGlkTWVkaWFUeXBlLnRlc3QobWVkaWFUeXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBhdHRyaWJ1dGVzLmxlbmd0aCAtIDEgJiYgYXR0cmlidXRlc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnYmFzZTY0Jykgey8vIG9rXG4gICAgfSBlbHNlIGlmICghdmFsaWRBdHRyaWJ1dGUudGVzdChhdHRyaWJ1dGVzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2krKykge1xuICAgIGlmICghdmFsaWREYXRhLnRlc3QoZGF0YVtfaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRGVjaW1hbDtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaW5jbHVkZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvaW5jbHVkZXNcIikpO1xuXG52YXIgX2FscGhhID0gcmVxdWlyZShcIi4vYWxwaGFcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGRlY2ltYWxSZWdFeHAob3B0aW9ucykge1xuICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChcIl5bLStdPyhbMC05XSspPyhcXFxcXCIuY29uY2F0KF9hbHBoYS5kZWNpbWFsW29wdGlvbnMubG9jYWxlXSwgXCJbMC05XXtcIikuY29uY2F0KG9wdGlvbnMuZGVjaW1hbF9kaWdpdHMsIFwifSlcIikuY29uY2F0KG9wdGlvbnMuZm9yY2VfZGVjaW1hbCA/ICcnIDogJz8nLCBcIiRcIikpO1xuICByZXR1cm4gcmVnRXhwO1xufVxuXG52YXIgZGVmYXVsdF9kZWNpbWFsX29wdGlvbnMgPSB7XG4gIGZvcmNlX2RlY2ltYWw6IGZhbHNlLFxuICBkZWNpbWFsX2RpZ2l0czogJzEsJyxcbiAgbG9jYWxlOiAnZW4tVVMnXG59O1xudmFyIGJsYWNrbGlzdCA9IFsnJywgJy0nLCAnKyddO1xuXG5mdW5jdGlvbiBpc0RlY2ltYWwoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZGVjaW1hbF9vcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5sb2NhbGUgaW4gX2FscGhhLmRlY2ltYWwpIHtcbiAgICByZXR1cm4gISgwLCBfaW5jbHVkZXMuZGVmYXVsdCkoYmxhY2tsaXN0LCBzdHIucmVwbGFjZSgvIC9nLCAnJykpICYmIGRlY2ltYWxSZWdFeHAob3B0aW9ucykudGVzdChzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChvcHRpb25zLmxvY2FsZSwgXCInXCIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEaXZpc2libGVCeTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF90b0Zsb2F0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90b0Zsb2F0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNEaXZpc2libGVCeShzdHIsIG51bSkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gKDAsIF90b0Zsb2F0LmRlZmF1bHQpKHN0cikgJSBwYXJzZUludChudW0sIDEwKSA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbWFpbDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbnZhciBfaXNCeXRlTGVuZ3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0J5dGVMZW5ndGhcIikpO1xuXG52YXIgX2lzRlFETiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNGUUROXCIpKTtcblxudmFyIF9pc0lQID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0lQXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcbiAgYWxsb3dfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgcmVxdWlyZV9kaXNwbGF5X25hbWU6IGZhbHNlLFxuICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXG4gIHJlcXVpcmVfdGxkOiB0cnVlXG59O1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbnZhciBkaXNwbGF5TmFtZSA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXStbYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXCxcXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHNdKjwoLispPiQvaTtcbnZhciBlbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dKyQvaTtcbnZhciBnbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkXSskLztcbnZhciBxdW90ZWRFbWFpbFVzZXIgPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZV18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdKSkqJC9pO1xudmFyIGVtYWlsVXNlclV0ZjhQYXJ0ID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKyQvaTtcbnZhciBxdW90ZWRFbWFpbFVzZXJVdGY4ID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKiQvaTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNFbWFpbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9lbWFpbF9vcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSB8fCBvcHRpb25zLmFsbG93X2Rpc3BsYXlfbmFtZSkge1xuICAgIHZhciBkaXNwbGF5X2VtYWlsID0gc3RyLm1hdGNoKGRpc3BsYXlOYW1lKTtcblxuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XG4gICAgICBzdHIgPSBkaXNwbGF5X2VtYWlsWzFdO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcGFydHMucG9wKCk7XG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuICB2YXIgbG93ZXJfZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG9wdGlvbnMuZG9tYWluX3NwZWNpZmljX3ZhbGlkYXRpb24gJiYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSkge1xuICAgIC8qXG4gICAgICBQcmV2aW91c2x5IHdlIHJlbW92ZWQgZG90cyBmb3IgZ21haWwgYWRkcmVzc2VzIGJlZm9yZSB2YWxpZGF0aW5nLlxuICAgICAgVGhpcyB3YXMgcmVtb3ZlZCBiZWNhdXNlIGl0IGFsbG93cyBgbXVsdGlwbGUuLmRvdHNAZ21haWwuY29tYFxuICAgICAgdG8gYmUgcmVwb3J0ZWQgYXMgdmFsaWQsIGJ1dCBpdCBpcyBub3QuXG4gICAgICBHbWFpbCBvbmx5IG5vcm1hbGl6ZXMgc2luZ2xlIGRvdHMsIHJlbW92aW5nIHRoZW0gZnJvbSBoZXJlIGlzIHBvaW50bGVzcyxcbiAgICAgIHNob3VsZCBiZSBkb25lIGluIG5vcm1hbGl6ZUVtYWlsXG4gICAgKi9cbiAgICB1c2VyID0gdXNlci50b0xvd2VyQ2FzZSgpOyAvLyBSZW1vdmluZyBzdWItYWRkcmVzcyBmcm9tIHVzZXJuYW1lIGJlZm9yZSBnbWFpbCB2YWxpZGF0aW9uXG5cbiAgICB2YXIgdXNlcm5hbWUgPSB1c2VyLnNwbGl0KCcrJylbMF07IC8vIERvdHMgYXJlIG5vdCBpbmNsdWRlZCBpbiBnbWFpbCBsZW5ndGggcmVzdHJpY3Rpb25cblxuICAgIGlmICghKDAsIF9pc0J5dGVMZW5ndGguZGVmYXVsdCkodXNlcm5hbWUucmVwbGFjZSgnLicsICcnKSwge1xuICAgICAgbWluOiA2LFxuICAgICAgbWF4OiAzMFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF91c2VyX3BhcnRzID0gdXNlcm5hbWUuc3BsaXQoJy4nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3VzZXJfcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZ21haWxVc2VyUGFydC50ZXN0KF91c2VyX3BhcnRzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KSh1c2VyLCB7XG4gICAgbWF4OiA2NFxuICB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGguZGVmYXVsdCkoZG9tYWluLCB7XG4gICAgbWF4OiAyNTRcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoISgwLCBfaXNGUUROLmRlZmF1bHQpKGRvbWFpbiwge1xuICAgIHJlcXVpcmVfdGxkOiBvcHRpb25zLnJlcXVpcmVfdGxkXG4gIH0pKSB7XG4gICAgaWYgKCFvcHRpb25zLmFsbG93X2lwX2RvbWFpbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKDAsIF9pc0lQLmRlZmF1bHQpKGRvbWFpbikpIHtcbiAgICAgIGlmICghZG9tYWluLnN0YXJ0c1dpdGgoJ1snKSB8fCAhZG9tYWluLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9CcmFja2V0ZG9tYWluID0gZG9tYWluLnN1YnN0cigxLCBkb21haW4ubGVuZ3RoIC0gMik7XG5cbiAgICAgIGlmIChub0JyYWNrZXRkb21haW4ubGVuZ3RoID09PSAwIHx8ICEoMCwgX2lzSVAuZGVmYXVsdCkobm9CcmFja2V0ZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZXJbMF0gPT09ICdcIicpIHtcbiAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IHF1b3RlZEVtYWlsVXNlclV0ZjgudGVzdCh1c2VyKSA6IHF1b3RlZEVtYWlsVXNlci50ZXN0KHVzZXIpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcbiAgdmFyIHVzZXJfcGFydHMgPSB1c2VyLnNwbGl0KCcuJyk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHVzZXJfcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tfaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRW1wdHk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWVyZ2VcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9pc19lbXB0eV9vcHRpb25zID0ge1xuICBpZ25vcmVfd2hpdGVzcGFjZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzRW1wdHkoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfaXNfZW1wdHlfb3B0aW9ucyk7XG4gIHJldHVybiAob3B0aW9ucy5pZ25vcmVfd2hpdGVzcGFjZSA/IHN0ci50cmltKCkubGVuZ3RoIDogc3RyLmxlbmd0aCkgPT09IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRlFETjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2ZxZG5fb3B0aW9ucyA9IHtcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNGUUROKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG4gIC8qIFJlbW92ZSB0aGUgb3B0aW9uYWwgdHJhaWxpbmcgZG90IGJlZm9yZSBjaGVja2luZyB2YWxpZGl0eSAqL1xuXG4gIGlmIChvcHRpb25zLmFsbG93X3RyYWlsaW5nX2RvdCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydHNbaV0ubGVuZ3RoID4gNjMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcblxuICAgIGlmICghcGFydHMubGVuZ3RoIHx8ICEvXihbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH18eG5bYS16MC05LV17Mix9KSQvaS50ZXN0KHRsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGRpc2FsbG93IHNwYWNlc1xuXG5cbiAgICBpZiAoL1tcXHNcXHUyMDAyLVxcdTIwMEJcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXFx1REI0MFxcdURDMjBdLy50ZXN0KHRsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBwYXJ0LCBfaSA9IDA7IF9pIDwgcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW19pXTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93X3VuZGVyc2NvcmVzKSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9fL2csICcnKTtcbiAgICB9XG5cbiAgICBpZiAoIS9eW2EtelxcdTAwYTEtXFx1ZmZmZjAtOS1dKyQvaS50ZXN0KHBhcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBkaXNhbGxvdyBmdWxsLXdpZHRoIGNoYXJzXG5cblxuICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocGFydFswXSA9PT0gJy0nIHx8IHBhcnRbcGFydC5sZW5ndGggLSAxXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRmxvYXQ7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNGbG9hdChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBmbG9hdCA9IG5ldyBSZWdFeHAoXCJeKD86Wy0rXSk/KD86WzAtOV0rKT8oPzpcXFxcXCIuY29uY2F0KG9wdGlvbnMubG9jYWxlID8gX2FscGhhLmRlY2ltYWxbb3B0aW9ucy5sb2NhbGVdIDogJy4nLCBcIlswLTldKik/KD86W2VFXVtcXFxcK1xcXFwtXT8oPzpbMC05XSspKT8kXCIpKTtcblxuICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09ICcuJyB8fCBzdHIgPT09ICctJyB8fCBzdHIgPT09ICcrJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgcmV0dXJuIGZsb2F0LnRlc3Qoc3RyKSAmJiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21pbicpIHx8IHZhbHVlID49IG9wdGlvbnMubWluKSAmJiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21heCcpIHx8IHZhbHVlIDw9IG9wdGlvbnMubWF4KSAmJiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2x0JykgfHwgdmFsdWUgPCBvcHRpb25zLmx0KSAmJiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2d0JykgfHwgdmFsdWUgPiBvcHRpb25zLmd0KTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhfYWxwaGEuZGVjaW1hbCk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGdWxsV2lkdGg7XG5leHBvcnRzLmZ1bGxXaWR0aCA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bGxXaWR0aCA9IC9bXlxcdTAwMjAtXFx1MDA3RVxcdUZGNjEtXFx1RkY5RlxcdUZGQTAtXFx1RkZEQ1xcdUZGRTgtXFx1RkZFRTAtOWEtekEtWl0vO1xuZXhwb3J0cy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cbmZ1bmN0aW9uIGlzRnVsbFdpZHRoKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gZnVsbFdpZHRoLnRlc3Qoc3RyKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSGFsZldpZHRoO1xuZXhwb3J0cy5oYWxmV2lkdGggPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoYWxmV2lkdGggPSAvW1xcdTAwMjAtXFx1MDA3RVxcdUZGNjEtXFx1RkY5RlxcdUZGQTAtXFx1RkZEQ1xcdUZGRTgtXFx1RkZFRTAtOWEtekEtWl0vO1xuZXhwb3J0cy5oYWxmV2lkdGggPSBoYWxmV2lkdGg7XG5cbmZ1bmN0aW9uIGlzSGFsZldpZHRoKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gaGFsZldpZHRoLnRlc3Qoc3RyKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSGFzaDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGxlbmd0aHMgPSB7XG4gIG1kNTogMzIsXG4gIG1kNDogMzIsXG4gIHNoYTE6IDQwLFxuICBzaGEyNTY6IDY0LFxuICBzaGEzODQ6IDk2LFxuICBzaGE1MTI6IDEyOCxcbiAgcmlwZW1kMTI4OiAzMixcbiAgcmlwZW1kMTYwOiA0MCxcbiAgdGlnZXIxMjg6IDMyLFxuICB0aWdlcjE2MDogNDAsXG4gIHRpZ2VyMTkyOiA0OCxcbiAgY3JjMzI6IDgsXG4gIGNyYzMyYjogOFxufTtcblxuZnVuY3Rpb24gaXNIYXNoKHN0ciwgYWxnb3JpdGhtKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBoYXNoID0gbmV3IFJlZ0V4cChcIl5bYS1mMC05XXtcIi5jb25jYXQobGVuZ3Roc1thbGdvcml0aG1dLCBcIn0kXCIpKTtcbiAgcmV0dXJuIGhhc2gudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0hleENvbG9yO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaGV4Y29sb3IgPSAvXiM/KFswLTlBLUZdezN9fFswLTlBLUZdezZ9KSQvaTtcblxuZnVuY3Rpb24gaXNIZXhDb2xvcihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGhleGNvbG9yLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNIZXhhZGVjaW1hbDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGhleGFkZWNpbWFsID0gL15bMC05QS1GXSskL2k7XG5cbmZ1bmN0aW9uIGlzSGV4YWRlY2ltYWwoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBoZXhhZGVjaW1hbC50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpcHY0TWF5YmUgPSAvXihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSkkLztcbnZhciBpcHY2QmxvY2sgPSAvXlswLTlBLUZdezEsNH0kL2k7XG5cbmZ1bmN0aW9uIGlzSVAoc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcblxuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gaXNJUChzdHIsIDQpIHx8IGlzSVAoc3RyLCA2KTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNCcpIHtcbiAgICBpZiAoIWlwdjRNYXliZS50ZXN0KHN0cikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzWzNdIDw9IDI1NTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAnNicpIHtcbiAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcbiAgICAvLyBBdCBsZWFzdCBzb21lIE9TIGFjY2VwdCB0aGUgbGFzdCAzMiBiaXRzIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgIC8vIChpLmUuIDIgb2YgdGhlIGJsb2NrcykgaW4gSVB2NCBub3RhdGlvbiwgYW5kIFJGQyAzNDkzIHNheXNcbiAgICAvLyB0aGF0ICc6OmZmZmY6YS5iLmMuZCcgaXMgdmFsaWQgZm9yIElQdjQtbWFwcGVkIElQdjYgYWRkcmVzc2VzLFxuICAgIC8vIGFuZCAnOjphLmIuYy5kJyBpcyBkZXByZWNhdGVkLCBidXQgYWxzbyB2YWxpZC5cblxuICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xuICAgIHZhciBleHBlY3RlZE51bWJlck9mQmxvY2tzID0gZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrID8gNyA6IDg7XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGluaXRpYWwgb3IgZmluYWwgOjpcblxuXG4gICAgaWYgKHN0ciA9PT0gJzo6Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3Muc2hpZnQoKTtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDIpID09PSAnOjonKSB7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBibG9ja3MucG9wKCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyB0ZXN0IGZvciBhIDo6IHdoaWNoIGNhbiBub3QgYmUgYXQgdGhlIHN0cmluZyBzdGFydC9lbmRcbiAgICAgIC8vIHNpbmNlIHRob3NlIGNhc2VzIGhhdmUgYmVlbiBoYW5kbGVkIGFib3ZlXG4gICAgICBpZiAoYmxvY2tzW2ldID09PSAnJyAmJiBpID4gMCAmJiBpIDwgYmxvY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbXVsdGlwbGUgOjogaW4gYWRkcmVzc1xuICAgICAgICB9XG5cbiAgICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRJUHY0VHJhbnNpdGlvbkJsb2NrICYmIGkgPT09IGJsb2Nrcy5sZW5ndGggLSAxKSB7Ly8gaXQgaGFzIGJlZW4gY2hlY2tlZCBiZWZvcmUgdGhhdCB0aGUgbGFzdFxuICAgICAgICAvLyBibG9jayBpcyBhIHZhbGlkIElQdjQgYWRkcmVzc1xuICAgICAgfSBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA9PT0gZXhwZWN0ZWROdW1iZXJPZkJsb2NrcztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUFJhbmdlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSVBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3VibmV0TWF5YmUgPSAvXlxcZHsxLDJ9JC87XG5cbmZ1bmN0aW9uIGlzSVBSYW5nZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcvJyk7IC8vIHBhcnRzWzBdIC0+IGlwLCBwYXJ0c1sxXSAtPiBzdWJuZXRcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFzdWJuZXRNYXliZS50ZXN0KHBhcnRzWzFdKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBEaXNhbGxvdyBwcmVjZWRpbmcgMCBpLmUuIDAxLCAwMiwgLi4uXG5cblxuICBpZiAocGFydHNbMV0ubGVuZ3RoID4gMSAmJiBwYXJ0c1sxXS5zdGFydHNXaXRoKCcwJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gKDAsIF9pc0lQLmRlZmF1bHQpKHBhcnRzWzBdLCA0KSAmJiBwYXJ0c1sxXSA8PSAzMiAmJiBwYXJ0c1sxXSA+PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTQk47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpc2JuMTBNYXliZSA9IC9eKD86WzAtOV17OX1YfFswLTldezEwfSkkLztcbnZhciBpc2JuMTNNYXliZSA9IC9eKD86WzAtOV17MTN9KSQvO1xudmFyIGZhY3RvciA9IFsxLCAzXTtcblxuZnVuY3Rpb24gaXNJU0JOKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG5cbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGlzSVNCTihzdHIsIDEwKSB8fCBpc0lTQk4oc3RyLCAxMyk7XG4gIH1cblxuICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1tcXHMtXSsvZywgJycpO1xuICB2YXIgY2hlY2tzdW0gPSAwO1xuICB2YXIgaTtcblxuICBpZiAodmVyc2lvbiA9PT0gJzEwJykge1xuICAgIGlmICghaXNibjEwTWF5YmUudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgY2hlY2tzdW0gKz0gKGkgKyAxKSAqIHNhbml0aXplZC5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgaWYgKHNhbml0aXplZC5jaGFyQXQoOSkgPT09ICdYJykge1xuICAgICAgY2hlY2tzdW0gKz0gMTAgKiAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tzdW0gKz0gMTAgKiBzYW5pdGl6ZWQuY2hhckF0KDkpO1xuICAgIH1cblxuICAgIGlmIChjaGVja3N1bSAlIDExID09PSAwKSB7XG4gICAgICByZXR1cm4gISFzYW5pdGl6ZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICcxMycpIHtcbiAgICBpZiAoIWlzYm4xM01heWJlLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICBjaGVja3N1bSArPSBmYWN0b3JbaSAlIDJdICogc2FuaXRpemVkLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICBpZiAoc2FuaXRpemVkLmNoYXJBdCgxMikgLSAoMTAgLSBjaGVja3N1bSAlIDEwKSAlIDEwID09PSAwKSB7XG4gICAgICByZXR1cm4gISFzYW5pdGl6ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTSU47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpc2luID0gL15bQS1aXXsyfVswLTlBLVpdezl9WzAtOV0kLztcblxuZnVuY3Rpb24gaXNJU0lOKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmICghaXNpbi50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2hlY2tzdW1TdHIgPSBzdHIucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBwYXJzZUludChjaGFyYWN0ZXIsIDM2KTtcbiAgfSk7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgZGlnaXQ7XG4gIHZhciB0bXBOdW07XG4gIHZhciBzaG91bGREb3VibGUgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSBjaGVja3N1bVN0ci5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgIGRpZ2l0ID0gY2hlY2tzdW1TdHIuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuXG4gICAgaWYgKHNob3VsZERvdWJsZSkge1xuICAgICAgdG1wTnVtICo9IDI7XG5cbiAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcbiAgICAgICAgc3VtICs9IHRtcE51bSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdW0gKz0gdG1wTnVtO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdW0gKz0gdG1wTnVtO1xuICAgIH1cblxuICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMSksIDEwKSA9PT0gKDEwMDAwIC0gc3VtKSAlIDEwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTTzMxNjYxQWxwaGEyO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2luY2x1ZGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2luY2x1ZGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fMzE2Ni0xX2FscGhhLTJcbnZhciB2YWxpZElTTzMxNjYxQWxwaGEyQ291bnRyaWVzQ29kZXMgPSBbJ0FEJywgJ0FFJywgJ0FGJywgJ0FHJywgJ0FJJywgJ0FMJywgJ0FNJywgJ0FPJywgJ0FRJywgJ0FSJywgJ0FTJywgJ0FUJywgJ0FVJywgJ0FXJywgJ0FYJywgJ0FaJywgJ0JBJywgJ0JCJywgJ0JEJywgJ0JFJywgJ0JGJywgJ0JHJywgJ0JIJywgJ0JJJywgJ0JKJywgJ0JMJywgJ0JNJywgJ0JOJywgJ0JPJywgJ0JRJywgJ0JSJywgJ0JTJywgJ0JUJywgJ0JWJywgJ0JXJywgJ0JZJywgJ0JaJywgJ0NBJywgJ0NDJywgJ0NEJywgJ0NGJywgJ0NHJywgJ0NIJywgJ0NJJywgJ0NLJywgJ0NMJywgJ0NNJywgJ0NOJywgJ0NPJywgJ0NSJywgJ0NVJywgJ0NWJywgJ0NXJywgJ0NYJywgJ0NZJywgJ0NaJywgJ0RFJywgJ0RKJywgJ0RLJywgJ0RNJywgJ0RPJywgJ0RaJywgJ0VDJywgJ0VFJywgJ0VHJywgJ0VIJywgJ0VSJywgJ0VTJywgJ0VUJywgJ0ZJJywgJ0ZKJywgJ0ZLJywgJ0ZNJywgJ0ZPJywgJ0ZSJywgJ0dBJywgJ0dCJywgJ0dEJywgJ0dFJywgJ0dGJywgJ0dHJywgJ0dIJywgJ0dJJywgJ0dMJywgJ0dNJywgJ0dOJywgJ0dQJywgJ0dRJywgJ0dSJywgJ0dTJywgJ0dUJywgJ0dVJywgJ0dXJywgJ0dZJywgJ0hLJywgJ0hNJywgJ0hOJywgJ0hSJywgJ0hUJywgJ0hVJywgJ0lEJywgJ0lFJywgJ0lMJywgJ0lNJywgJ0lOJywgJ0lPJywgJ0lRJywgJ0lSJywgJ0lTJywgJ0lUJywgJ0pFJywgJ0pNJywgJ0pPJywgJ0pQJywgJ0tFJywgJ0tHJywgJ0tIJywgJ0tJJywgJ0tNJywgJ0tOJywgJ0tQJywgJ0tSJywgJ0tXJywgJ0tZJywgJ0taJywgJ0xBJywgJ0xCJywgJ0xDJywgJ0xJJywgJ0xLJywgJ0xSJywgJ0xTJywgJ0xUJywgJ0xVJywgJ0xWJywgJ0xZJywgJ01BJywgJ01DJywgJ01EJywgJ01FJywgJ01GJywgJ01HJywgJ01IJywgJ01LJywgJ01MJywgJ01NJywgJ01OJywgJ01PJywgJ01QJywgJ01RJywgJ01SJywgJ01TJywgJ01UJywgJ01VJywgJ01WJywgJ01XJywgJ01YJywgJ01ZJywgJ01aJywgJ05BJywgJ05DJywgJ05FJywgJ05GJywgJ05HJywgJ05JJywgJ05MJywgJ05PJywgJ05QJywgJ05SJywgJ05VJywgJ05aJywgJ09NJywgJ1BBJywgJ1BFJywgJ1BGJywgJ1BHJywgJ1BIJywgJ1BLJywgJ1BMJywgJ1BNJywgJ1BOJywgJ1BSJywgJ1BTJywgJ1BUJywgJ1BXJywgJ1BZJywgJ1FBJywgJ1JFJywgJ1JPJywgJ1JTJywgJ1JVJywgJ1JXJywgJ1NBJywgJ1NCJywgJ1NDJywgJ1NEJywgJ1NFJywgJ1NHJywgJ1NIJywgJ1NJJywgJ1NKJywgJ1NLJywgJ1NMJywgJ1NNJywgJ1NOJywgJ1NPJywgJ1NSJywgJ1NTJywgJ1NUJywgJ1NWJywgJ1NYJywgJ1NZJywgJ1NaJywgJ1RDJywgJ1REJywgJ1RGJywgJ1RHJywgJ1RIJywgJ1RKJywgJ1RLJywgJ1RMJywgJ1RNJywgJ1ROJywgJ1RPJywgJ1RSJywgJ1RUJywgJ1RWJywgJ1RXJywgJ1RaJywgJ1VBJywgJ1VHJywgJ1VNJywgJ1VTJywgJ1VZJywgJ1VaJywgJ1ZBJywgJ1ZDJywgJ1ZFJywgJ1ZHJywgJ1ZJJywgJ1ZOJywgJ1ZVJywgJ1dGJywgJ1dTJywgJ1lFJywgJ1lUJywgJ1pBJywgJ1pNJywgJ1pXJ107XG5cbmZ1bmN0aW9uIGlzSVNPMzE2NjFBbHBoYTIoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX2luY2x1ZGVzLmRlZmF1bHQpKHZhbGlkSVNPMzE2NjFBbHBoYTJDb3VudHJpZXNDb2Rlcywgc3RyLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTTzMxNjYxQWxwaGEzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2luY2x1ZGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2luY2x1ZGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fMzE2Ni0xX2FscGhhLTNcbnZhciB2YWxpZElTTzMxNjYxQWxwaGEzQ291bnRyaWVzQ29kZXMgPSBbJ0FGRycsICdBTEEnLCAnQUxCJywgJ0RaQScsICdBU00nLCAnQU5EJywgJ0FHTycsICdBSUEnLCAnQVRBJywgJ0FURycsICdBUkcnLCAnQVJNJywgJ0FCVycsICdBVVMnLCAnQVVUJywgJ0FaRScsICdCSFMnLCAnQkhSJywgJ0JHRCcsICdCUkInLCAnQkxSJywgJ0JFTCcsICdCTFonLCAnQkVOJywgJ0JNVScsICdCVE4nLCAnQk9MJywgJ0JFUycsICdCSUgnLCAnQldBJywgJ0JWVCcsICdCUkEnLCAnSU9UJywgJ0JSTicsICdCR1InLCAnQkZBJywgJ0JESScsICdLSE0nLCAnQ01SJywgJ0NBTicsICdDUFYnLCAnQ1lNJywgJ0NBRicsICdUQ0QnLCAnQ0hMJywgJ0NITicsICdDWFInLCAnQ0NLJywgJ0NPTCcsICdDT00nLCAnQ09HJywgJ0NPRCcsICdDT0snLCAnQ1JJJywgJ0NJVicsICdIUlYnLCAnQ1VCJywgJ0NVVycsICdDWVAnLCAnQ1pFJywgJ0ROSycsICdESkknLCAnRE1BJywgJ0RPTScsICdFQ1UnLCAnRUdZJywgJ1NMVicsICdHTlEnLCAnRVJJJywgJ0VTVCcsICdFVEgnLCAnRkxLJywgJ0ZSTycsICdGSkknLCAnRklOJywgJ0ZSQScsICdHVUYnLCAnUFlGJywgJ0FURicsICdHQUInLCAnR01CJywgJ0dFTycsICdERVUnLCAnR0hBJywgJ0dJQicsICdHUkMnLCAnR1JMJywgJ0dSRCcsICdHTFAnLCAnR1VNJywgJ0dUTScsICdHR1knLCAnR0lOJywgJ0dOQicsICdHVVknLCAnSFRJJywgJ0hNRCcsICdWQVQnLCAnSE5EJywgJ0hLRycsICdIVU4nLCAnSVNMJywgJ0lORCcsICdJRE4nLCAnSVJOJywgJ0lSUScsICdJUkwnLCAnSU1OJywgJ0lTUicsICdJVEEnLCAnSkFNJywgJ0pQTicsICdKRVknLCAnSk9SJywgJ0tBWicsICdLRU4nLCAnS0lSJywgJ1BSSycsICdLT1InLCAnS1dUJywgJ0tHWicsICdMQU8nLCAnTFZBJywgJ0xCTicsICdMU08nLCAnTEJSJywgJ0xCWScsICdMSUUnLCAnTFRVJywgJ0xVWCcsICdNQUMnLCAnTUtEJywgJ01ERycsICdNV0knLCAnTVlTJywgJ01EVicsICdNTEknLCAnTUxUJywgJ01ITCcsICdNVFEnLCAnTVJUJywgJ01VUycsICdNWVQnLCAnTUVYJywgJ0ZTTScsICdNREEnLCAnTUNPJywgJ01ORycsICdNTkUnLCAnTVNSJywgJ01BUicsICdNT1onLCAnTU1SJywgJ05BTScsICdOUlUnLCAnTlBMJywgJ05MRCcsICdOQ0wnLCAnTlpMJywgJ05JQycsICdORVInLCAnTkdBJywgJ05JVScsICdORksnLCAnTU5QJywgJ05PUicsICdPTU4nLCAnUEFLJywgJ1BMVycsICdQU0UnLCAnUEFOJywgJ1BORycsICdQUlknLCAnUEVSJywgJ1BITCcsICdQQ04nLCAnUE9MJywgJ1BSVCcsICdQUkknLCAnUUFUJywgJ1JFVScsICdST1UnLCAnUlVTJywgJ1JXQScsICdCTE0nLCAnU0hOJywgJ0tOQScsICdMQ0EnLCAnTUFGJywgJ1NQTScsICdWQ1QnLCAnV1NNJywgJ1NNUicsICdTVFAnLCAnU0FVJywgJ1NFTicsICdTUkInLCAnU1lDJywgJ1NMRScsICdTR1AnLCAnU1hNJywgJ1NWSycsICdTVk4nLCAnU0xCJywgJ1NPTScsICdaQUYnLCAnU0dTJywgJ1NTRCcsICdFU1AnLCAnTEtBJywgJ1NETicsICdTVVInLCAnU0pNJywgJ1NXWicsICdTV0UnLCAnQ0hFJywgJ1NZUicsICdUV04nLCAnVEpLJywgJ1RaQScsICdUSEEnLCAnVExTJywgJ1RHTycsICdUS0wnLCAnVE9OJywgJ1RUTycsICdUVU4nLCAnVFVSJywgJ1RLTScsICdUQ0EnLCAnVFVWJywgJ1VHQScsICdVS1InLCAnQVJFJywgJ0dCUicsICdVU0EnLCAnVU1JJywgJ1VSWScsICdVWkInLCAnVlVUJywgJ1ZFTicsICdWTk0nLCAnVkdCJywgJ1ZJUicsICdXTEYnLCAnRVNIJywgJ1lFTScsICdaTUInLCAnWldFJ107XG5cbmZ1bmN0aW9uIGlzSVNPMzE2NjFBbHBoYTMoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX2luY2x1ZGVzLmRlZmF1bHQpKHZhbGlkSVNPMzE2NjFBbHBoYTNDb3VudHJpZXNDb2Rlcywgc3RyLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTTzg2MDE7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8vIGZyb20gaHR0cDovL2dvby5nbC8wZWpISFdcbnZhciBpc284NjAxID0gL14oW1xcKy1dP1xcZHs0fSg/IVxcZHsyfVxcYikpKCgtPykoKDBbMS05XXwxWzAtMl0pKFxcMyhbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKFswLTRdXFxkfDVbMC0zXSkoLT9bMS03XSk/fCgwMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoWzAtNV1cXGR8NlsxLTZdKSkpKFtUXFxzXSgoKFswMV1cXGR8MlswLTNdKSgoOj8pWzAtNV1cXGQpP3wyNDo/MDApKFtcXC4sXVxcZCsoPyE6KSk/KT8oXFwxN1swLTVdXFxkKFtcXC4sXVxcZCspPyk/KFt6Wl18KFtcXCstXSkoWzAxXVxcZHwyWzAtM10pOj8oWzAtNV1cXGQpPyk/KT8pPyQvO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc1ZhbGlkRGF0ZSA9IGZ1bmN0aW9uIGlzVmFsaWREYXRlKHN0cikge1xuICAvLyBzdHIgbXVzdCBoYXZlIHBhc3NlZCB0aGUgSVNPODYwMSBjaGVja1xuICAvLyB0aGlzIGNoZWNrIGlzIG1lYW50IHRvIGNhdGNoIGludmFsaWQgZGF0ZXNcbiAgLy8gbGlrZSAyMDA5LTAyLTMxXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBvcmRpbmFsIGRhdGVzXG4gIHZhciBvcmRpbmFsTWF0Y2ggPSBzdHIubWF0Y2goL14oXFxkezR9KS0/KFxcZHszfSkoWyBUXXsxfVxcLip8JCkvKTtcblxuICBpZiAob3JkaW5hbE1hdGNoKSB7XG4gICAgdmFyIG9ZZWFyID0gTnVtYmVyKG9yZGluYWxNYXRjaFsxXSk7XG4gICAgdmFyIG9EYXkgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzJdKTsgLy8gaWYgaXMgbGVhcCB5ZWFyXG5cbiAgICBpZiAob1llYXIgJSA0ID09PSAwICYmIG9ZZWFyICUgMTAwICE9PSAwKSByZXR1cm4gb0RheSA8PSAzNjY7XG4gICAgcmV0dXJuIG9EYXkgPD0gMzY1O1xuICB9XG5cbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC8oXFxkezR9KS0/KFxcZHswLDJ9KS0/KFxcZCopLykubWFwKE51bWJlcik7XG4gIHZhciB5ZWFyID0gbWF0Y2hbMV07XG4gIHZhciBtb250aCA9IG1hdGNoWzJdO1xuICB2YXIgZGF5ID0gbWF0Y2hbM107XG4gIHZhciBtb250aFN0cmluZyA9IG1vbnRoID8gXCIwXCIuY29uY2F0KG1vbnRoKS5zbGljZSgtMikgOiBtb250aDtcbiAgdmFyIGRheVN0cmluZyA9IGRheSA/IFwiMFwiLmNvbmNhdChkYXkpLnNsaWNlKC0yKSA6IGRheTsgLy8gY3JlYXRlIGEgZGF0ZSBvYmplY3QgYW5kIGNvbXBhcmVcblxuICB2YXIgZCA9IG5ldyBEYXRlKFwiXCIuY29uY2F0KHllYXIsIFwiLVwiKS5jb25jYXQobW9udGhTdHJpbmcgfHwgJzAxJywgXCItXCIpLmNvbmNhdChkYXlTdHJpbmcgfHwgJzAxJykpO1xuICBpZiAoaXNOYU4oZC5nZXRVVENGdWxsWWVhcigpKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChtb250aCAmJiBkYXkpIHtcbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyICYmIGQuZ2V0VVRDTW9udGgoKSArIDEgPT09IG1vbnRoICYmIGQuZ2V0VVRDRGF0ZSgpID09PSBkYXk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGlzSVNPODYwMShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNoZWNrID0gaXNvODYwMS50ZXN0KHN0cik7XG4gIGlmICghb3B0aW9ucykgcmV0dXJuIGNoZWNrO1xuICBpZiAoY2hlY2sgJiYgb3B0aW9ucy5zdHJpY3QpIHJldHVybiBpc1ZhbGlkRGF0ZShzdHIpO1xuICByZXR1cm4gY2hlY2s7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNSQztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gc2VlIGh0dHA6Ly9pc3JjLmlmcGkub3JnL2VuL2lzcmMtc3RhbmRhcmQvY29kZS1zeW50YXhcbnZhciBpc3JjID0gL15bQS1aXXsyfVswLTlBLVpdezN9XFxkezJ9XFxkezV9JC87XG5cbmZ1bmN0aW9uIGlzSVNSQyhzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGlzcmMudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lTU047XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpc3NuID0gJ15cXFxcZHs0fS0/XFxcXGR7M31bXFxcXGRYXSQnO1xuXG5mdW5jdGlvbiBpc0lTU04oc3RyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHRlc3RJc3NuID0gaXNzbjtcbiAgdGVzdElzc24gPSBvcHRpb25zLnJlcXVpcmVfaHlwaGVuID8gdGVzdElzc24ucmVwbGFjZSgnPycsICcnKSA6IHRlc3RJc3NuO1xuICB0ZXN0SXNzbiA9IG9wdGlvbnMuY2FzZV9zZW5zaXRpdmUgPyBuZXcgUmVnRXhwKHRlc3RJc3NuKSA6IG5ldyBSZWdFeHAodGVzdElzc24sICdpJyk7XG5cbiAgaWYgKCF0ZXN0SXNzbi50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZGlnaXRzID0gc3RyLnJlcGxhY2UoJy0nLCAnJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGNoZWNrc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICBjaGVja3N1bSArPSAoZGlnaXQgPT09ICdYJyA/IDEwIDogK2RpZ2l0KSAqICg4IC0gaSk7XG4gIH1cblxuICByZXR1cm4gY2hlY2tzdW0gJSAxMSA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJZGVudGl0eUNhcmQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB2YWxpZGF0b3JzID0ge1xuICBFUzogZnVuY3Rpb24gRVMoc3RyKSB7XG4gICAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgICB2YXIgRE5JID0gL15bMC05WC1aXVswLTldezd9W1RSV0FHTVlGUERYQk5KWlNRVkhMQ0tFXSQvO1xuICAgIHZhciBjaGFyc1ZhbHVlID0ge1xuICAgICAgWDogMCxcbiAgICAgIFk6IDEsXG4gICAgICBaOiAyXG4gICAgfTtcbiAgICB2YXIgY29udHJvbERpZ2l0cyA9IFsnVCcsICdSJywgJ1cnLCAnQScsICdHJywgJ00nLCAnWScsICdGJywgJ1AnLCAnRCcsICdYJywgJ0InLCAnTicsICdKJywgJ1onLCAnUycsICdRJywgJ1YnLCAnSCcsICdMJywgJ0MnLCAnSycsICdFJ107IC8vIHNhbml0aXplIHVzZXIgaW5wdXRcblxuICAgIHZhciBzYW5pdGl6ZWQgPSBzdHIudHJpbSgpLnRvVXBwZXJDYXNlKCk7IC8vIHZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZVxuXG4gICAgaWYgKCFETkkudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB2YWxpZGF0ZSB0aGUgY29udHJvbCBkaWdpdFxuXG5cbiAgICB2YXIgbnVtYmVyID0gc2FuaXRpemVkLnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9bWCxZLFpdL2csIGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICByZXR1cm4gY2hhcnNWYWx1ZVtjaGFyXTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2FuaXRpemVkLmVuZHNXaXRoKGNvbnRyb2xEaWdpdHNbbnVtYmVyICUgMjNdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNJZGVudGl0eUNhcmQoc3RyKSB7XG4gIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdhbnknO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gdmFsaWRhdG9ycykge1xuICAgIHJldHVybiB2YWxpZGF0b3JzW2xvY2FsZV0oc3RyKTtcbiAgfSBlbHNlIGlmIChsb2NhbGUgPT09ICdhbnknKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbGlkYXRvcnMpIHtcbiAgICAgIGlmICh2YWxpZGF0b3JzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IHZhbGlkYXRvcnNba2V5XTtcblxuICAgICAgICBpZiAodmFsaWRhdG9yKHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0luO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL3RvU3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gaXNJbihzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGk7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRpb25zKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yIChpIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgIGFycmF5W2ldID0gKDAsIF90b1N0cmluZy5kZWZhdWx0KShvcHRpb25zW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihzdHIpID49IDA7XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShzdHIpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLmluZGV4T2Yoc3RyKSA+PSAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ludDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGludCA9IC9eKD86Wy0rXT8oPzowfFsxLTldWzAtOV0qKSkkLztcbnZhciBpbnRMZWFkaW5nWmVyb2VzID0gL15bLStdP1swLTldKyQvO1xuXG5mdW5jdGlvbiBpc0ludChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEdldCB0aGUgcmVnZXggdG8gdXNlIGZvciB0ZXN0aW5nLCBiYXNlZCBvbiB3aGV0aGVyXG4gIC8vIGxlYWRpbmcgemVyb2VzIGFyZSBhbGxvd2VkIG9yIG5vdC5cblxuICB2YXIgcmVnZXggPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdhbGxvd19sZWFkaW5nX3plcm9lcycpICYmICFvcHRpb25zLmFsbG93X2xlYWRpbmdfemVyb2VzID8gaW50IDogaW50TGVhZGluZ1plcm9lczsgLy8gQ2hlY2sgbWluL21heC9sdC9ndFxuXG4gIHZhciBtaW5DaGVja1Bhc3NlZCA9ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdtaW4nKSB8fCBzdHIgPj0gb3B0aW9ucy5taW47XG4gIHZhciBtYXhDaGVja1Bhc3NlZCA9ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdtYXgnKSB8fCBzdHIgPD0gb3B0aW9ucy5tYXg7XG4gIHZhciBsdENoZWNrUGFzc2VkID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2x0JykgfHwgc3RyIDwgb3B0aW9ucy5sdDtcbiAgdmFyIGd0Q2hlY2tQYXNzZWQgPSAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZ3QnKSB8fCBzdHIgPiBvcHRpb25zLmd0O1xuICByZXR1cm4gcmVnZXgudGVzdChzdHIpICYmIG1pbkNoZWNrUGFzc2VkICYmIG1heENoZWNrUGFzc2VkICYmIGx0Q2hlY2tQYXNzZWQgJiYgZ3RDaGVja1Bhc3NlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNKU09OO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc0pTT04oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgdHJ5IHtcbiAgICB2YXIgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xuICAgIHJldHVybiAhIW9iaiAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaWdub3JlICovXG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSldUO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgand0ID0gL14oW0EtWmEtejAtOVxcLV9+K1xcL10rWz1dezAsMn0pXFwuKFtBLVphLXowLTlcXC1ffitcXC9dK1s9XXswLDJ9KSg/OlxcLihbQS1aYS16MC05XFwtX34rXFwvXStbPV17MCwyfSkpPyQvO1xuXG5mdW5jdGlvbiBpc0pXVChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGp3dC50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbGF0ID0gL15cXCg/WystXT8oOTAoXFwuMCspP3xbMS04XT9cXGQoXFwuXFxkKyk/KSQvO1xudmFyIGxvbmcgPSAvXlxccz9bKy1dPygxODAoXFwuMCspP3wxWzAtN11cXGQoXFwuXFxkKyk/fFxcZHsxLDJ9KFxcLlxcZCspPylcXCk/JC87XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBpZiAoIXN0ci5pbmNsdWRlcygnLCcpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwYWlyID0gc3RyLnNwbGl0KCcsJyk7XG4gIHJldHVybiBsYXQudGVzdChwYWlyWzBdKSAmJiBsb25nLnRlc3QocGFpclsxXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTGVuZ3RoO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgIG1pbiA9IG9wdGlvbnMubWluIHx8IDA7XG4gICAgbWF4ID0gb3B0aW9ucy5tYXg7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlzTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXG4gICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBzdXJyb2dhdGVQYWlycyA9IHN0ci5tYXRjaCgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nKSB8fCBbXTtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGggLSBzdXJyb2dhdGVQYWlycy5sZW5ndGg7XG4gIHJldHVybiBsZW4gPj0gbWluICYmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyB8fCBsZW4gPD0gbWF4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNMb3dlcmNhc2U7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzTG93ZXJjYXNlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyID09PSBzdHIudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNQUNBZGRyZXNzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbWFjQWRkcmVzcyA9IC9eKFswLTlhLWZBLUZdWzAtOWEtZkEtRl06KXs1fShbMC05YS1mQS1GXVswLTlhLWZBLUZdKSQvO1xudmFyIG1hY0FkZHJlc3NOb0NvbG9ucyA9IC9eKFswLTlhLWZBLUZdKXsxMn0kLztcblxuZnVuY3Rpb24gaXNNQUNBZGRyZXNzKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fY29sb25zKSB7XG4gICAgcmV0dXJuIG1hY0FkZHJlc3NOb0NvbG9ucy50ZXN0KHN0cik7XG4gIH1cblxuICByZXR1cm4gbWFjQWRkcmVzcy50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTUQ1O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbWQ1ID0gL15bYS1mMC05XXszMn0kLztcblxuZnVuY3Rpb24gaXNNRDUoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBtZDUudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01hZ25ldFVSSTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG1hZ25ldFVSSSA9IC9ebWFnbmV0OlxcP3h0PXVybjpbYS16MC05XSs6W2EtejAtOV17MzIsNDB9JmRuPS4rJnRyPS4rJC9pO1xuXG5mdW5jdGlvbiBpc01hZ25ldFVSSSh1cmwpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkodXJsKTtcbiAgcmV0dXJuIG1hZ25ldFVSSS50ZXN0KHVybC50cmltKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01pbWVUeXBlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKlxuICBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyBtYXRjaGVzIHRvIGEgY29ycmVjdCBNZWRpYSB0eXBlIGZvcm1hdCAoTUlNRSB0eXBlKVxuXG4gIFRoaXMgZnVuY3Rpb24gb25seSBjaGVja3MgaXMgdGhlIHN0cmluZyBmb3JtYXQgZm9sbG93cyB0aGVcbiAgZXRhYmxpc2hlZCBydWxlcyBieSB0aGUgYWNjb3JkaW5nIFJGQyBzcGVjaWZpY2F0aW9ucy5cbiAgVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyAnY2hhcnNldCcgaW4gdGV4dHVhbCBtZWRpYSB0eXBlc1xuICAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NTcpLlxuXG4gIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2sgYWdhaW5zdCBhbGwgdGhlIG1lZGlhIHR5cGVzIGxpc3RlZFxuICBieSB0aGUgSUFOQSAoaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvbWVkaWEtdHlwZXMueGh0bWwpXG4gIGJlY2F1c2Ugb2YgbGlnaHRuZXNzIHB1cnBvc2VzIDogaXQgd291bGQgcmVxdWlyZSB0byBpbmNsdWRlXG4gIGFsbCB0aGVzZSBNSU1FIHR5cGVzIGluIHRoaXMgbGlicmFpcnksIHdoaWNoIHdvdWxkIHdlaWdoIGl0XG4gIHNpZ25pZmljYW50bHkuIFRoaXMga2luZCBvZiBlZmZvcnQgbWF5YmUgaXMgbm90IHdvcnRoIGZvciB0aGUgdXNlIHRoYXRcbiAgdGhpcyBmdW5jdGlvbiBoYXMgaW4gdGhpcyBlbnRpcmUgbGlicmFpcnkuXG5cbiAgTW9yZSBpbmZvcm1hdGlvbnMgaW4gdGhlIFJGQyBzcGVjaWZpY2F0aW9ucyA6XG4gIC0gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIwNDVcbiAgLSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0NlxuICAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tMy4xLjEuMVxuICAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tMy4xLjEuNVxuKi9cbi8vIE1hdGNoIHNpbXBsZSBNSU1FIHR5cGVzXG4vLyBOQiA6XG4vLyAgIFN1YnR5cGUgbGVuZ3RoIG11c3Qgbm90IGV4Y2VlZCAxMDAgY2hhcmFjdGVycy5cbi8vICAgVGhpcyBydWxlIGRvZXMgbm90IGNvbXBseSB0byB0aGUgUkZDIHNwZWNzICh3aGF0IGlzIHRoZSBtYXggbGVuZ3RoID8pLlxudmFyIG1pbWVUeXBlU2ltcGxlID0gL14oYXBwbGljYXRpb258YXVkaW98Zm9udHxpbWFnZXxtZXNzYWdlfG1vZGVsfG11bHRpcGFydHx0ZXh0fHZpZGVvKVxcL1thLXpBLVowLTlcXC5cXC1cXCtdezEsMTAwfSQvaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4vLyBIYW5kbGUgXCJjaGFyc2V0XCIgaW4gXCJ0ZXh0LypcIlxuXG52YXIgbWltZVR5cGVUZXh0ID0gL150ZXh0XFwvW2EtekEtWjAtOVxcLlxcLVxcK117MSwxMDB9O1xccz9jaGFyc2V0PShcIlthLXpBLVowLTlcXC5cXC1cXCtcXHNdezAsNzB9XCJ8W2EtekEtWjAtOVxcLlxcLVxcK117MCw3MH0pKFxccz9cXChbYS16QS1aMC05XFwuXFwtXFwrXFxzXXsxLDIwfVxcKSk/JC9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbi8vIEhhbmRsZSBcImJvdW5kYXJ5XCIgaW4gXCJtdWx0aXBhcnQvKlwiXG5cbnZhciBtaW1lVHlwZU11bHRpcGFydCA9IC9ebXVsdGlwYXJ0XFwvW2EtekEtWjAtOVxcLlxcLVxcK117MSwxMDB9KDtcXHM/KGJvdW5kYXJ5fGNoYXJzZXQpPShcIlthLXpBLVowLTlcXC5cXC1cXCtcXHNdezAsNzB9XCJ8W2EtekEtWjAtOVxcLlxcLVxcK117MCw3MH0pKFxccz9cXChbYS16QS1aMC05XFwuXFwtXFwrXFxzXXsxLDIwfVxcKSk/KXswLDJ9JC9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxuZnVuY3Rpb24gaXNNaW1lVHlwZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIG1pbWVUeXBlU2ltcGxlLnRlc3Qoc3RyKSB8fCBtaW1lVHlwZVRleHQudGVzdChzdHIpIHx8IG1pbWVUeXBlTXVsdGlwYXJ0LnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNb2JpbGVQaG9uZTtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIHBob25lcyA9IHtcbiAgJ2FyLUFFJzogL14oKFxcKz85NzEpfDApPzVbMDI0NTY4XVxcZHs3fSQvLFxuICAnYXItRFonOiAvXihcXCs/MjEzfDApKDV8Nnw3KVxcZHs4fSQvLFxuICAnYXItRUcnOiAvXigoXFwrPzIwKXwwKT8xWzAxMl1cXGR7OH0kLyxcbiAgJ2FyLUlRJzogL14oXFwrPzk2NHwwKT83WzAtOV1cXGR7OH0kLyxcbiAgJ2FyLUpPJzogL14oXFwrPzk2MnwwKT83Wzc4OV1cXGR7N30kLyxcbiAgJ2FyLUtXJzogL14oXFwrPzk2NSlbNTY5XVxcZHs3fSQvLFxuICAnYXItU0EnOiAvXighPyhcXCs/OTY2KXwwKT81XFxkezh9JC8sXG4gICdhci1TWSc6IC9eKCE/KFxcKz85NjMpfDApPzlcXGR7OH0kLyxcbiAgJ2FyLVROJzogL14oXFwrPzIxNik/WzI0NTldXFxkezd9JC8sXG4gICdiZS1CWSc6IC9eKFxcKz8zNzUpPygyNHwyNXwyOXwzM3w0NClcXGR7N30kLyxcbiAgJ2JnLUJHJzogL14oXFwrPzM1OXwwKT84Wzc4OV1cXGR7N30kLyxcbiAgJ2JuLUJEJzogL1xcKz8oODgpPzA/MVszNTY3ODldWzAtOV17OH1cXGIvLFxuICAnY3MtQ1onOiAvXihcXCs/NDIwKT8gP1sxLTldWzAtOV17Mn0gP1swLTldezN9ID9bMC05XXszfSQvLFxuICAnZGEtREsnOiAvXihcXCs/NDUpP1xccz9cXGR7Mn1cXHM/XFxkezJ9XFxzP1xcZHsyfVxccz9cXGR7Mn0kLyxcbiAgJ2RlLURFJzogL14oXFwrNDkpPzA/MSg1WzAtMjUtOV1cXGR8NihbMjNdfDBcXGQ/KXw3KFswLTU3LTldfDZcXGQpKVxcZHs3fSQvLFxuICAnZWwtR1InOiAvXihcXCs/MzB8MCk/KDY5XFxkezh9KSQvLFxuICAnZW4tQVUnOiAvXihcXCs/NjF8MCk0XFxkezh9JC8sXG4gICdlbi1HQic6IC9eKFxcKz80NHwwKTdcXGR7OX0kLyxcbiAgJ2VuLUdIJzogL14oXFwrMjMzfDApKDIwfDUwfDI0fDU0fDI3fDU3fDI2fDU2fDIzfDI4KVxcZHs3fSQvLFxuICAnZW4tSEsnOiAvXihcXCs/ODUyXFwtPyk/WzQ1Njc4OV1cXGR7M31cXC0/XFxkezR9JC8sXG4gICdlbi1JRSc6IC9eKFxcKz8zNTN8MCk4WzM1Njc4OV1cXGR7N30kLyxcbiAgJ2VuLUlOJzogL14oXFwrPzkxfDApP1s2Nzg5XVxcZHs5fSQvLFxuICAnZW4tS0UnOiAvXihcXCs/MjU0fDApP1s3XVxcZHs4fSQvLFxuICAnZW4tTVUnOiAvXihcXCs/MjMwfDApP1xcZHs4fSQvLFxuICAnZW4tTkcnOiAvXihcXCs/MjM0fDApP1s3ODldXFxkezl9JC8sXG4gICdlbi1OWic6IC9eKFxcKz82NHwwKVsyOF1cXGR7Nyw5fSQvLFxuICAnZW4tUEsnOiAvXigoXFwrOTIpfCgwMDkyKSktezAsMX1cXGR7M30tezAsMX1cXGR7N30kfF5cXGR7MTF9JHxeXFxkezR9LVxcZHs3fSQvLFxuICAnZW4tUlcnOiAvXihcXCs/MjUwfDApP1s3XVxcZHs4fSQvLFxuICAnZW4tU0cnOiAvXihcXCs2NSk/Wzg5XVxcZHs3fSQvLFxuICAnZW4tVFonOiAvXihcXCs/MjU1fDApP1s2N11cXGR7OH0kLyxcbiAgJ2VuLVVHJzogL14oXFwrPzI1NnwwKT9bN11cXGR7OH0kLyxcbiAgJ2VuLVVTJzogL14oKFxcKzF8MSk/KCB8LSk/KT8oXFwoWzItOV1bMC05XXsyfVxcKXxbMi05XVswLTldezJ9KSggfC0pPyhbMi05XVswLTldezJ9KCB8LSk/WzAtOV17NH0pJC8sXG4gICdlbi1aQSc6IC9eKFxcKz8yN3wwKVxcZHs5fSQvLFxuICAnZW4tWk0nOiAvXihcXCs/MjYpPzA5WzU2N11cXGR7N30kLyxcbiAgJ2VzLUVTJzogL14oXFwrPzM0KT8oNlxcZHsxfXw3WzEyMzRdKVxcZHs3fSQvLFxuICAnZXMtTVgnOiAvXihcXCs/NTIpPygxfDAxKT9cXGR7MTAsMTF9JC8sXG4gICdlcy1VWSc6IC9eKFxcKzU5OHwwKTlbMS05XVtcXGRdezZ9JC8sXG4gICdldC1FRSc6IC9eKFxcKz8zNzIpP1xccz8oNXw4WzEtNF0pXFxzPyhbMC05XVxccz8pezYsN30kLyxcbiAgJ2ZhLUlSJzogL14oXFwrPzk4W1xcLVxcc10/fDApOVswLTM5XVxcZFtcXC1cXHNdP1xcZHszfVtcXC1cXHNdP1xcZHs0fSQvLFxuICAnZmktRkknOiAvXihcXCs/MzU4fDApXFxzPyg0KDB8MXwyfDR8NXw2KT98NTApXFxzPyhcXGRcXHM/KXs0LDh9XFxkJC8sXG4gICdmby1GTyc6IC9eKFxcKz8yOTgpP1xccz9cXGR7Mn1cXHM/XFxkezJ9XFxzP1xcZHsyfSQvLFxuICAnZnItRlInOiAvXihcXCs/MzN8MClbNjddXFxkezh9JC8sXG4gICdoZS1JTCc6IC9eKFxcKzk3MnwwKShbMjM0ODldfDVbMDEyMzQ1Njg5XXw3NylbMS05XVxcZHs2fSQvLFxuICAnaHUtSFUnOiAvXihcXCs/MzYpKDIwfDMwfDcwKVxcZHs3fSQvLFxuICAnaWQtSUQnOiAvXihcXCs/NjJ8MCk4KDFbMTIzNDU2Nzg5XXwyWzEyMzhdfDNbMTIzOF18NVsxMjM1Njc4OV18N1s3OF18OVs1Njc4OV18OFsxMjM0NTY3ODldKShbXFxzP3xcXGRdezUsMTF9KSQvLFxuICAnaXQtSVQnOiAvXihcXCs/MzkpP1xccz8zXFxkezJ9ID9cXGR7Niw3fSQvLFxuICAnamEtSlAnOiAvXihcXCs/ODF8MClbNzg5XTBbIFxcLV0/WzEtOV1cXGR7Mn1bIFxcLV0/XFxkezV9JC8sXG4gICdray1LWic6IC9eKFxcKz83fDgpPzdcXGR7OX0kLyxcbiAgJ2tsLUdMJzogL14oXFwrPzI5OSk/XFxzP1xcZHsyfVxccz9cXGR7Mn1cXHM/XFxkezJ9JC8sXG4gICdrby1LUic6IC9eKChcXCs/ODIpWyBcXC1dPyk/MD8xKFswfDF8Nnw3fDh8OV17MX0pWyBcXC1dP1xcZHszLDR9WyBcXC1dP1xcZHs0fSQvLFxuICAnbHQtTFQnOiAvXihcXCszNzB8OClcXGR7OH0kLyxcbiAgJ21zLU1ZJzogL14oXFwrPzY/MDEpezF9KChbMDE0NV17MX0oXFwtfFxccyk/XFxkezcsOH0pfChbMjM2Nzg5XXsxfShcXHN8XFwtKT9cXGR7N30pKSQvLFxuICAnbmItTk8nOiAvXihcXCs/NDcpP1s0OV1cXGR7N30kLyxcbiAgJ25sLUJFJzogL14oXFwrPzMyfDApND9cXGR7OH0kLyxcbiAgJ25uLU5PJzogL14oXFwrPzQ3KT9bNDldXFxkezd9JC8sXG4gICdwbC1QTCc6IC9eKFxcKz80OCk/ID9bNS04XVxcZCA/XFxkezN9ID9cXGR7Mn0gP1xcZHsyfSQvLFxuICAncHQtQlInOiAvKD89XihcXCs/NXsyfVxcLT98MClbMS05XXsyfVxcLT9cXGR7NH1cXC0/XFxkezR9JCkoXihcXCs/NXsyfVxcLT98MClbMS05XXsyfVxcLT9bNi05XXsxfVxcZHszfVxcLT9cXGR7NH0kKXwoXihcXCs/NXsyfVxcLT98MClbMS05XXsyfVxcLT85WzYtOV17MX1cXGR7M31cXC0/XFxkezR9JCkvLFxuICAncHQtUFQnOiAvXihcXCs/MzUxKT85WzEyMzZdXFxkezd9JC8sXG4gICdyby1STyc6IC9eKFxcKz80PzApXFxzPzdcXGR7Mn0oXFwvfFxcc3xcXC58XFwtKT9cXGR7M30oXFxzfFxcLnxcXC0pP1xcZHszfSQvLFxuICAncnUtUlUnOiAvXihcXCs/N3w4KT85XFxkezl9JC8sXG4gICdzbC1TSSc6IC9eKFxcKzM4Nlxccz98MCkoXFxkezF9XFxzP1xcZHszfVxccz9cXGR7Mn1cXHM/XFxkezJ9fFxcZHsyfVxccz9cXGR7M31cXHM/XFxkezN9KSQvLFxuICAnc2stU0snOiAvXihcXCs/NDIxKT8gP1sxLTldWzAtOV17Mn0gP1swLTldezN9ID9bMC05XXszfSQvLFxuICAnc3ItUlMnOiAvXihcXCszODE2fDA2KVstIFxcZF17NSw5fSQvLFxuICAnc3YtU0UnOiAvXihcXCs/NDZ8MClbXFxzXFwtXT83W1xcc1xcLV0/WzAyMzY5XShbXFxzXFwtXT9cXGQpezd9JC8sXG4gICd0aC1USCc6IC9eKFxcKzY2fDY2fDApXFxkezl9JC8sXG4gICd0ci1UUic6IC9eKFxcKz85MHwwKT81XFxkezl9JC8sXG4gICd1ay1VQSc6IC9eKFxcKz8zOHw4KT8wXFxkezl9JC8sXG4gICd2aS1WTic6IC9eKFxcKz84NHwwKSgoMyhbMi05XSkpfCg1KFs2ODldKSl8KDcoWzB8Ni05XSkpfCg4KFsxLTVdKSl8KDkoWzAtOV0pKSkoWzAtOV17N30pJC8sXG4gICd6aC1DTic6IC9eKChcXCt8MDApODYpPzEoWzM1OF1bMC05XXw0WzU3OV18NjZ8N1swMTM1Njc4XXw5Wzg5XSlbMC05XXs4fSQvLFxuICAnemgtVFcnOiAvXihcXCs/ODg2XFwtP3wwKT85XFxkezh9JC9cbn07XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbi8vIGFsaWFzZXNcblxucGhvbmVzWydlbi1DQSddID0gcGhvbmVzWydlbi1VUyddO1xucGhvbmVzWydmci1CRSddID0gcGhvbmVzWydubC1CRSddO1xucGhvbmVzWyd6aC1ISyddID0gcGhvbmVzWydlbi1ISyddO1xuXG5mdW5jdGlvbiBpc01vYmlsZVBob25lKHN0ciwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3RNb2RlICYmICFzdHIuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobG9jYWxlKSkge1xuICAgIHJldHVybiBsb2NhbGUuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAocGhvbmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIHBob25lID0gcGhvbmVzW2tleV07XG5cbiAgICAgICAgaWYgKHBob25lLnRlc3Qoc3RyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsb2NhbGUgaW4gcGhvbmVzKSB7XG4gICAgcmV0dXJuIHBob25lc1tsb2NhbGVdLnRlc3Qoc3RyKTsgLy8gYWxpYXMgZmFsc2V5IGxvY2FsZSBhcyAnYW55J1xuICB9IGVsc2UgaWYgKCFsb2NhbGUgfHwgbG9jYWxlID09PSAnYW55Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBwaG9uZXMpIHtcbiAgICAgIGlmIChwaG9uZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgcGhvbmUgPSBwaG9uZXNba2V5XTtcblxuICAgICAgICBpZiAocGhvbmUudGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhwaG9uZXMpO1xuZXhwb3J0cy5sb2NhbGVzID0gbG9jYWxlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTW9uZ29JZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pc0hleGFkZWNpbWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0hleGFkZWNpbWFsXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNNb25nb0lkKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gKDAsIF9pc0hleGFkZWNpbWFsLmRlZmF1bHQpKHN0cikgJiYgc3RyLmxlbmd0aCA9PT0gMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTXVsdGlieXRlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgbXVsdGlieXRlID0gL1teXFx4MDAtXFx4N0ZdLztcbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc011bHRpYnl0ZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIG11bHRpYnl0ZS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTnVtZXJpYztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG51bWVyaWMgPSAvXlsrLV0/KFswLTldKlsuXSk/WzAtOV0rJC87XG52YXIgbnVtZXJpY05vU3ltYm9scyA9IC9eWzAtOV0rJC87XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vX3N5bWJvbHMpIHtcbiAgICByZXR1cm4gbnVtZXJpY05vU3ltYm9scy50ZXN0KHN0cik7XG4gIH1cblxuICByZXR1cm4gbnVtZXJpYy50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUG9ydDtcblxudmFyIF9pc0ludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNJbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1BvcnQoc3RyKSB7XG4gIHJldHVybiAoMCwgX2lzSW50LmRlZmF1bHQpKHN0ciwge1xuICAgIG1pbjogMCxcbiAgICBtYXg6IDY1NTM1XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gY29tbW9uIHBhdHRlcm5zXG52YXIgdGhyZWVEaWdpdCA9IC9eXFxkezN9JC87XG52YXIgZm91ckRpZ2l0ID0gL15cXGR7NH0kLztcbnZhciBmaXZlRGlnaXQgPSAvXlxcZHs1fSQvO1xudmFyIHNpeERpZ2l0ID0gL15cXGR7Nn0kLztcbnZhciBwYXR0ZXJucyA9IHtcbiAgQUQ6IC9eQURcXGR7M30kLyxcbiAgQVQ6IGZvdXJEaWdpdCxcbiAgQVU6IGZvdXJEaWdpdCxcbiAgQkU6IGZvdXJEaWdpdCxcbiAgQkc6IGZvdXJEaWdpdCxcbiAgQ0E6IC9eW0FCQ0VHSEpLTE1OUFJTVFZYWV1cXGRbQUJDRUdISi1OUFJTVFYtWl1bXFxzXFwtXT9cXGRbQUJDRUdISi1OUFJTVFYtWl1cXGQkL2ksXG4gIENIOiBmb3VyRGlnaXQsXG4gIENaOiAvXlxcZHszfVxccz9cXGR7Mn0kLyxcbiAgREU6IGZpdmVEaWdpdCxcbiAgREs6IGZvdXJEaWdpdCxcbiAgRFo6IGZpdmVEaWdpdCxcbiAgRUU6IGZpdmVEaWdpdCxcbiAgRVM6IGZpdmVEaWdpdCxcbiAgRkk6IGZpdmVEaWdpdCxcbiAgRlI6IC9eXFxkezJ9XFxzP1xcZHszfSQvLFxuICBHQjogL14oZ2lyXFxzPzBhYXxbYS16XXsxLDJ9XFxkW1xcZGEtel0/XFxzPyhcXGRbYS16XXsyfSk/KSQvaSxcbiAgR1I6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBIUjogL14oWzEtNV1cXGR7NH0kKS8sXG4gIEhVOiBmb3VyRGlnaXQsXG4gIElMOiBmaXZlRGlnaXQsXG4gIElOOiBzaXhEaWdpdCxcbiAgSVM6IHRocmVlRGlnaXQsXG4gIElUOiBmaXZlRGlnaXQsXG4gIEpQOiAvXlxcZHszfVxcLVxcZHs0fSQvLFxuICBLRTogZml2ZURpZ2l0LFxuICBMSTogL14oOTQ4WzUtOV18OTQ5WzAtN10pJC8sXG4gIExUOiAvXkxUXFwtXFxkezV9JC8sXG4gIExVOiBmb3VyRGlnaXQsXG4gIExWOiAvXkxWXFwtXFxkezR9JC8sXG4gIE1YOiBmaXZlRGlnaXQsXG4gIE5MOiAvXlxcZHs0fVxccz9bYS16XXsyfSQvaSxcbiAgTk86IGZvdXJEaWdpdCxcbiAgUEw6IC9eXFxkezJ9XFwtXFxkezN9JC8sXG4gIFBUOiAvXlxcZHs0fVxcLVxcZHszfT8kLyxcbiAgUk86IHNpeERpZ2l0LFxuICBSVTogc2l4RGlnaXQsXG4gIFNBOiBmaXZlRGlnaXQsXG4gIFNFOiAvXlxcZHszfVxccz9cXGR7Mn0kLyxcbiAgU0k6IGZvdXJEaWdpdCxcbiAgU0s6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBUTjogZm91ckRpZ2l0LFxuICBUVzogL15cXGR7M30oXFxkezJ9KT8kLyxcbiAgVUE6IGZpdmVEaWdpdCxcbiAgVVM6IC9eXFxkezV9KC1cXGR7NH0pPyQvLFxuICBaQTogZm91ckRpZ2l0LFxuICBaTTogZml2ZURpZ2l0XG59O1xudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhwYXR0ZXJucyk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChzdHIsIGxvY2FsZSkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gcGF0dGVybnMpIHtcbiAgICByZXR1cm4gcGF0dGVybnNbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH0gZWxzZSBpZiAobG9jYWxlID09PSAnYW55Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBwYXR0ZXJucykge1xuICAgICAgaWYgKHBhdHRlcm5zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1trZXldO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1JGQzMzMzk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIEJhc2VkIG9uIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42ICovXG52YXIgZGF0ZUZ1bGxZZWFyID0gL1swLTldezR9LztcbnZhciBkYXRlTW9udGggPSAvKDBbMS05XXwxWzAtMl0pLztcbnZhciBkYXRlTURheSA9IC8oWzEyXVxcZHwwWzEtOV18M1swMV0pLztcbnZhciB0aW1lSG91ciA9IC8oWzAxXVswLTldfDJbMC0zXSkvO1xudmFyIHRpbWVNaW51dGUgPSAvWzAtNV1bMC05XS87XG52YXIgdGltZVNlY29uZCA9IC8oWzAtNV1bMC05XXw2MCkvO1xudmFyIHRpbWVTZWNGcmFjID0gLyhcXC5bMC05XSspPy87XG52YXIgdGltZU51bU9mZnNldCA9IG5ldyBSZWdFeHAoXCJbLStdXCIuY29uY2F0KHRpbWVIb3VyLnNvdXJjZSwgXCI6XCIpLmNvbmNhdCh0aW1lTWludXRlLnNvdXJjZSkpO1xudmFyIHRpbWVPZmZzZXQgPSBuZXcgUmVnRXhwKFwiKFt6Wl18XCIuY29uY2F0KHRpbWVOdW1PZmZzZXQuc291cmNlLCBcIilcIikpO1xudmFyIHBhcnRpYWxUaW1lID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdCh0aW1lSG91ci5zb3VyY2UsIFwiOlwiKS5jb25jYXQodGltZU1pbnV0ZS5zb3VyY2UsIFwiOlwiKS5jb25jYXQodGltZVNlY29uZC5zb3VyY2UpLmNvbmNhdCh0aW1lU2VjRnJhYy5zb3VyY2UpKTtcbnZhciBmdWxsRGF0ZSA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoZGF0ZUZ1bGxZZWFyLnNvdXJjZSwgXCItXCIpLmNvbmNhdChkYXRlTW9udGguc291cmNlLCBcIi1cIikuY29uY2F0KGRhdGVNRGF5LnNvdXJjZSkpO1xudmFyIGZ1bGxUaW1lID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChwYXJ0aWFsVGltZS5zb3VyY2UpLmNvbmNhdCh0aW1lT2Zmc2V0LnNvdXJjZSkpO1xudmFyIHJmYzMzMzkgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KGZ1bGxEYXRlLnNvdXJjZSwgXCJbIHRUXVwiKS5jb25jYXQoZnVsbFRpbWUuc291cmNlKSk7XG5cbmZ1bmN0aW9uIGlzUkZDMzMzOShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHJmYzMzMzkudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1N1cnJvZ2F0ZVBhaXI7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdXJyb2dhdGVQYWlyID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vO1xuXG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdXJyb2dhdGVQYWlyLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVUkw7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0ZRRE5cIikpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSVBcIikpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfdXJsX29wdGlvbnMgPSB7XG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2Z0cCddLFxuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgcmVxdWlyZV9wcm90b2NvbDogZmFsc2UsXG4gIHJlcXVpcmVfaG9zdDogdHJ1ZSxcbiAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlLFxuICBhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzOiBmYWxzZVxufTtcbnZhciB3cmFwcGVkX2lwdjYgPSAvXlxcWyhbXlxcXV0rKVxcXSg/OjooWzAtOV0rKSk/JC87XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCwgbWF0Y2hlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuXG4gICAgaWYgKGhvc3QgPT09IG1hdGNoIHx8IGlzUmVnRXhwKG1hdGNoKSAmJiBtYXRjaC50ZXN0KGhvc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVVJMKHVybCwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KSh1cmwpO1xuXG4gIGlmICghdXJsIHx8IHVybC5sZW5ndGggPj0gMjA4MyB8fCAvW1xcczw+XS8udGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHVybC5pbmRleE9mKCdtYWlsdG86JykgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X3VybF9vcHRpb25zKTtcbiAgdmFyIHByb3RvY29sLCBhdXRoLCBob3N0LCBob3N0bmFtZSwgcG9ydCwgcG9ydF9zdHIsIHNwbGl0LCBpcHY2O1xuICBzcGxpdCA9IHVybC5zcGxpdCgnIycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICBzcGxpdCA9IHVybC5zcGxpdCgnPycpO1xuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICBzcGxpdCA9IHVybC5zcGxpdCgnOi8vJyk7XG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBwcm90b2NvbCA9IHNwbGl0LnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVfdmFsaWRfcHJvdG9jb2wgJiYgb3B0aW9ucy5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9wcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICh1cmwuc3Vic3RyKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKCFvcHRpb25zLmFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcGxpdFswXSA9IHVybC5zdWJzdHIoMik7XG4gIH1cblxuICB1cmwgPSBzcGxpdC5qb2luKCc6Ly8nKTtcblxuICBpZiAodXJsID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcvJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgaWYgKHVybCA9PT0gJycgJiYgIW9wdGlvbnMucmVxdWlyZV9ob3N0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzcGxpdCA9IHVybC5zcGxpdCgnQCcpO1xuXG4gIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWxsb3dfYXV0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGF1dGggPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKGF1dGguaW5kZXhPZignOicpID49IDAgJiYgYXV0aC5zcGxpdCgnOicpLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBob3N0bmFtZSA9IHNwbGl0LmpvaW4oJ0AnKTtcbiAgcG9ydF9zdHIgPSBudWxsO1xuICBpcHY2ID0gbnVsbDtcbiAgdmFyIGlwdjZfbWF0Y2ggPSBob3N0bmFtZS5tYXRjaCh3cmFwcGVkX2lwdjYpO1xuXG4gIGlmIChpcHY2X21hdGNoKSB7XG4gICAgaG9zdCA9ICcnO1xuICAgIGlwdjYgPSBpcHY2X21hdGNoWzFdO1xuICAgIHBvcnRfc3RyID0gaXB2Nl9tYXRjaFsyXSB8fCBudWxsO1xuICB9IGVsc2Uge1xuICAgIHNwbGl0ID0gaG9zdG5hbWUuc3BsaXQoJzonKTtcbiAgICBob3N0ID0gc3BsaXQuc2hpZnQoKTtcblxuICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcbiAgICAgIHBvcnRfc3RyID0gc3BsaXQuam9pbignOicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb3J0X3N0ciAhPT0gbnVsbCkge1xuICAgIHBvcnQgPSBwYXJzZUludChwb3J0X3N0ciwgMTApO1xuXG4gICAgaWYgKCEvXlswLTldKyQvLnRlc3QocG9ydF9zdHIpIHx8IHBvcnQgPD0gMCB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoISgwLCBfaXNJUC5kZWZhdWx0KShob3N0KSAmJiAhKDAsIF9pc0ZRRE4uZGVmYXVsdCkoaG9zdCwgb3B0aW9ucykgJiYgKCFpcHY2IHx8ICEoMCwgX2lzSVAuZGVmYXVsdCkoaXB2NiwgNikpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaG9zdCA9IGhvc3QgfHwgaXB2NjtcblxuICBpZiAob3B0aW9ucy5ob3N0X3doaXRlbGlzdCAmJiAhY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaG9zdF9ibGFja2xpc3QgJiYgY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF9ibGFja2xpc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVVVJRDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHV1aWQgPSB7XG4gIDM6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tM1swLTlBLUZdezN9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaSxcbiAgNDogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS00WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pLFxuICA1OiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTVbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gIGFsbDogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2lcbn07XG5cbmZ1bmN0aW9uIGlzVVVJRChzdHIpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdhbGwnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGF0dGVybiA9IHV1aWRbdmVyc2lvbl07XG4gIHJldHVybiBwYXR0ZXJuICYmIHBhdHRlcm4udGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VwcGVyY2FzZTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNVcHBlcmNhc2Uoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhcmlhYmxlV2lkdGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaXNGdWxsV2lkdGggPSByZXF1aXJlKFwiLi9pc0Z1bGxXaWR0aFwiKTtcblxudmFyIF9pc0hhbGZXaWR0aCA9IHJlcXVpcmUoXCIuL2lzSGFsZldpZHRoXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhcmlhYmxlV2lkdGgoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBfaXNGdWxsV2lkdGguZnVsbFdpZHRoLnRlc3Qoc3RyKSAmJiBfaXNIYWxmV2lkdGguaGFsZldpZHRoLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNXaGl0ZWxpc3RlZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNXaGl0ZWxpc3RlZChzdHIsIGNoYXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChjaGFycy5pbmRleE9mKHN0cltpXSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGx0cmltO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBsdHJpbShzdHIsIGNoYXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBwYXR0ZXJuID0gY2hhcnMgPyBuZXcgUmVnRXhwKFwiXltcIi5jb25jYXQoY2hhcnMsIFwiXStcIiksICdnJykgOiAvXlxccysvZztcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHBhdHRlcm4sICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hlcztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gbWF0Y2hlcyhzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF0dGVybikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbm9ybWFsaXplRW1haWw7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWVyZ2VcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9ub3JtYWxpemVfZW1haWxfb3B0aW9ucyA9IHtcbiAgLy8gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFwcGx5IHRvIGFsbCBlbWFpbCBhZGRyZXNzZXNcbiAgLy8gTG93ZXJjYXNlcyB0aGUgbG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcy5cbiAgLy8gUGxlYXNlIG5vdGUgdGhpcyBtYXkgdmlvbGF0ZSBSRkMgNTMyMSBhcyBwZXIgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTgwODMzMi8xOTIwMjQpLlxuICAvLyBUaGUgZG9tYWluIGlzIGFsd2F5cyBsb3dlcmNhc2VkLCBhcyBwZXIgUkZDIDEwMzVcbiAgYWxsX2xvd2VyY2FzZTogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gR01haWxcbiAgLy8gTG93ZXJjYXNlcyB0aGUgbG9jYWwgcGFydCBvZiB0aGUgR01haWwgYWRkcmVzcyAoa25vd24gdG8gYmUgY2FzZS1pbnNlbnNpdGl2ZSlcbiAgZ21haWxfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBSZW1vdmVzIGRvdHMgZnJvbSB0aGUgbG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcywgYXMgdGhhdCdzIGlnbm9yZWQgYnkgR01haWxcbiAgZ21haWxfcmVtb3ZlX2RvdHM6IHRydWUsXG4gIC8vIFJlbW92ZXMgdGhlIHN1YmFkZHJlc3MgKGUuZy4gXCIrZm9vXCIpIGZyb20gdGhlIGVtYWlsIGFkZHJlc3NcbiAgZ21haWxfcmVtb3ZlX3N1YmFkZHJlc3M6IHRydWUsXG4gIC8vIENvbnZlcnN0cyB0aGUgZ29vZ2xlbWFpbC5jb20gZG9tYWluIHRvIGdtYWlsLmNvbVxuICBnbWFpbF9jb252ZXJ0X2dvb2dsZW1haWxkb3Rjb206IHRydWUsXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29udmVyc2lvbnMgYXJlIHNwZWNpZmljIHRvIE91dGxvb2suY29tIC8gV2luZG93cyBMaXZlIC8gSG90bWFpbFxuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBPdXRsb29rLmNvbSBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICBvdXRsb29rZG90Y29tX2xvd2VyY2FzZTogdHJ1ZSxcbiAgLy8gUmVtb3ZlcyB0aGUgc3ViYWRkcmVzcyAoZS5nLiBcIitmb29cIikgZnJvbSB0aGUgZW1haWwgYWRkcmVzc1xuICBvdXRsb29rZG90Y29tX3JlbW92ZV9zdWJhZGRyZXNzOiB0cnVlLFxuICAvLyBUaGUgZm9sbG93aW5nIGNvbnZlcnNpb25zIGFyZSBzcGVjaWZpYyB0byBZYWhvb1xuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBZYWhvbyBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICB5YWhvb19sb3dlcmNhc2U6IHRydWUsXG4gIC8vIFJlbW92ZXMgdGhlIHN1YmFkZHJlc3MgKGUuZy4gXCItZm9vXCIpIGZyb20gdGhlIGVtYWlsIGFkZHJlc3NcbiAgeWFob29fcmVtb3ZlX3N1YmFkZHJlc3M6IHRydWUsXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29udmVyc2lvbnMgYXJlIHNwZWNpZmljIHRvIFlhbmRleFxuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBZYW5kZXggYWRkcmVzcyAoa25vd24gdG8gYmUgY2FzZS1pbnNlbnNpdGl2ZSlcbiAgeWFuZGV4X2xvd2VyY2FzZTogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gaUNsb3VkXG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIGlDbG91ZCBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICBpY2xvdWRfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBSZW1vdmVzIHRoZSBzdWJhZGRyZXNzIChlLmcuIFwiK2Zvb1wiKSBmcm9tIHRoZSBlbWFpbCBhZGRyZXNzXG4gIGljbG91ZF9yZW1vdmVfc3ViYWRkcmVzczogdHJ1ZVxufTsgLy8gTGlzdCBvZiBkb21haW5zIHVzZWQgYnkgaUNsb3VkXG5cbnZhciBpY2xvdWRfZG9tYWlucyA9IFsnaWNsb3VkLmNvbScsICdtZS5jb20nXTsgLy8gTGlzdCBvZiBkb21haW5zIHVzZWQgYnkgT3V0bG9vay5jb20gYW5kIGl0cyBwcmVkZWNlc3NvcnNcbi8vIFRoaXMgbGlzdCBpcyBsaWtlbHkgaW5jb21wbGV0ZS5cbi8vIFBhcnRpYWwgcmVmZXJlbmNlOlxuLy8gaHR0cHM6Ly9ibG9ncy5vZmZpY2UuY29tLzIwMTMvMDQvMTcvb3V0bG9vay1jb20tZ2V0cy10d28tc3RlcC12ZXJpZmljYXRpb24tc2lnbi1pbi1ieS1hbGlhcy1hbmQtbmV3LWludGVybmF0aW9uYWwtZG9tYWlucy9cblxudmFyIG91dGxvb2tkb3Rjb21fZG9tYWlucyA9IFsnaG90bWFpbC5hdCcsICdob3RtYWlsLmJlJywgJ2hvdG1haWwuY2EnLCAnaG90bWFpbC5jbCcsICdob3RtYWlsLmNvLmlsJywgJ2hvdG1haWwuY28ubnonLCAnaG90bWFpbC5jby50aCcsICdob3RtYWlsLmNvLnVrJywgJ2hvdG1haWwuY29tJywgJ2hvdG1haWwuY29tLmFyJywgJ2hvdG1haWwuY29tLmF1JywgJ2hvdG1haWwuY29tLmJyJywgJ2hvdG1haWwuY29tLmdyJywgJ2hvdG1haWwuY29tLm14JywgJ2hvdG1haWwuY29tLnBlJywgJ2hvdG1haWwuY29tLnRyJywgJ2hvdG1haWwuY29tLnZuJywgJ2hvdG1haWwuY3onLCAnaG90bWFpbC5kZScsICdob3RtYWlsLmRrJywgJ2hvdG1haWwuZXMnLCAnaG90bWFpbC5mcicsICdob3RtYWlsLmh1JywgJ2hvdG1haWwuaWQnLCAnaG90bWFpbC5pZScsICdob3RtYWlsLmluJywgJ2hvdG1haWwuaXQnLCAnaG90bWFpbC5qcCcsICdob3RtYWlsLmtyJywgJ2hvdG1haWwubHYnLCAnaG90bWFpbC5teScsICdob3RtYWlsLnBoJywgJ2hvdG1haWwucHQnLCAnaG90bWFpbC5zYScsICdob3RtYWlsLnNnJywgJ2hvdG1haWwuc2snLCAnbGl2ZS5iZScsICdsaXZlLmNvLnVrJywgJ2xpdmUuY29tJywgJ2xpdmUuY29tLmFyJywgJ2xpdmUuY29tLm14JywgJ2xpdmUuZGUnLCAnbGl2ZS5lcycsICdsaXZlLmV1JywgJ2xpdmUuZnInLCAnbGl2ZS5pdCcsICdsaXZlLm5sJywgJ21zbi5jb20nLCAnb3V0bG9vay5hdCcsICdvdXRsb29rLmJlJywgJ291dGxvb2suY2wnLCAnb3V0bG9vay5jby5pbCcsICdvdXRsb29rLmNvLm56JywgJ291dGxvb2suY28udGgnLCAnb3V0bG9vay5jb20nLCAnb3V0bG9vay5jb20uYXInLCAnb3V0bG9vay5jb20uYXUnLCAnb3V0bG9vay5jb20uYnInLCAnb3V0bG9vay5jb20uZ3InLCAnb3V0bG9vay5jb20ucGUnLCAnb3V0bG9vay5jb20udHInLCAnb3V0bG9vay5jb20udm4nLCAnb3V0bG9vay5jeicsICdvdXRsb29rLmRlJywgJ291dGxvb2suZGsnLCAnb3V0bG9vay5lcycsICdvdXRsb29rLmZyJywgJ291dGxvb2suaHUnLCAnb3V0bG9vay5pZCcsICdvdXRsb29rLmllJywgJ291dGxvb2suaW4nLCAnb3V0bG9vay5pdCcsICdvdXRsb29rLmpwJywgJ291dGxvb2sua3InLCAnb3V0bG9vay5sdicsICdvdXRsb29rLm15JywgJ291dGxvb2sucGgnLCAnb3V0bG9vay5wdCcsICdvdXRsb29rLnNhJywgJ291dGxvb2suc2cnLCAnb3V0bG9vay5zaycsICdwYXNzcG9ydC5jb20nXTsgLy8gTGlzdCBvZiBkb21haW5zIHVzZWQgYnkgWWFob28gTWFpbFxuLy8gVGhpcyBsaXN0IGlzIGxpa2VseSBpbmNvbXBsZXRlXG5cbnZhciB5YWhvb19kb21haW5zID0gWydyb2NrZXRtYWlsLmNvbScsICd5YWhvby5jYScsICd5YWhvby5jby51aycsICd5YWhvby5jb20nLCAneWFob28uZGUnLCAneWFob28uZnInLCAneWFob28uaW4nLCAneWFob28uaXQnLCAneW1haWwuY29tJ107IC8vIExpc3Qgb2YgZG9tYWlucyB1c2VkIGJ5IHlhbmRleC5ydVxuXG52YXIgeWFuZGV4X2RvbWFpbnMgPSBbJ3lhbmRleC5ydScsICd5YW5kZXgudWEnLCAneWFuZGV4Lmt6JywgJ3lhbmRleC5jb20nLCAneWFuZGV4LmJ5JywgJ3lhLnJ1J107IC8vIHJlcGxhY2Ugc2luZ2xlIGRvdHMsIGJ1dCBub3QgbXVsdGlwbGUgY29uc2VjdXRpdmUgZG90c1xuXG5mdW5jdGlvbiBkb3RzUmVwbGFjZXIobWF0Y2gpIHtcbiAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtYWlsKGVtYWlsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfbm9ybWFsaXplX2VtYWlsX29wdGlvbnMpO1xuICB2YXIgcmF3X3BhcnRzID0gZW1haWwuc3BsaXQoJ0AnKTtcbiAgdmFyIGRvbWFpbiA9IHJhd19wYXJ0cy5wb3AoKTtcbiAgdmFyIHVzZXIgPSByYXdfcGFydHMuam9pbignQCcpO1xuICB2YXIgcGFydHMgPSBbdXNlciwgZG9tYWluXTsgLy8gVGhlIGRvbWFpbiBpcyBhbHdheXMgbG93ZXJjYXNlZCwgYXMgaXQncyBjYXNlLWluc2Vuc2l0aXZlIHBlciBSRkMgMTAzNVxuXG4gIHBhcnRzWzFdID0gcGFydHNbMV0udG9Mb3dlckNhc2UoKTtcblxuICBpZiAocGFydHNbMV0gPT09ICdnbWFpbC5jb20nIHx8IHBhcnRzWzFdID09PSAnZ29vZ2xlbWFpbC5jb20nKSB7XG4gICAgLy8gQWRkcmVzcyBpcyBHTWFpbFxuICAgIGlmIChvcHRpb25zLmdtYWlsX3JlbW92ZV9zdWJhZGRyZXNzKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnNwbGl0KCcrJylbMF07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZ21haWxfcmVtb3ZlX2RvdHMpIHtcbiAgICAgIC8vIHRoaXMgZG9lcyBub3QgcmVwbGFjZSBjb25zZWN1dGl2ZSBkb3RzIGxpa2UgZXhhbXBsZS4uZW1haWxAZ21haWwuY29tXG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1xcLisvZywgZG90c1JlcGxhY2VyKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnRzWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbF9sb3dlcmNhc2UgfHwgb3B0aW9ucy5nbWFpbF9sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBwYXJ0c1sxXSA9IG9wdGlvbnMuZ21haWxfY29udmVydF9nb29nbGVtYWlsZG90Y29tID8gJ2dtYWlsLmNvbScgOiBwYXJ0c1sxXTtcbiAgfSBlbHNlIGlmIChpY2xvdWRfZG9tYWlucy5pbmRleE9mKHBhcnRzWzFdKSA+PSAwKSB7XG4gICAgLy8gQWRkcmVzcyBpcyBpQ2xvdWRcbiAgICBpZiAob3B0aW9ucy5pY2xvdWRfcmVtb3ZlX3N1YmFkZHJlc3MpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0uc3BsaXQoJysnKVswXTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnRzWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbF9sb3dlcmNhc2UgfHwgb3B0aW9ucy5pY2xvdWRfbG93ZXJjYXNlKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG91dGxvb2tkb3Rjb21fZG9tYWlucy5pbmRleE9mKHBhcnRzWzFdKSA+PSAwKSB7XG4gICAgLy8gQWRkcmVzcyBpcyBPdXRsb29rLmNvbVxuICAgIGlmIChvcHRpb25zLm91dGxvb2tkb3Rjb21fcmVtb3ZlX3N1YmFkZHJlc3MpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0uc3BsaXQoJysnKVswXTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnRzWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbF9sb3dlcmNhc2UgfHwgb3B0aW9ucy5vdXRsb29rZG90Y29tX2xvd2VyY2FzZSkge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5YWhvb19kb21haW5zLmluZGV4T2YocGFydHNbMV0pID49IDApIHtcbiAgICAvLyBBZGRyZXNzIGlzIFlhaG9vXG4gICAgaWYgKG9wdGlvbnMueWFob29fcmVtb3ZlX3N1YmFkZHJlc3MpIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gcGFydHNbMF0uc3BsaXQoJy0nKTtcbiAgICAgIHBhcnRzWzBdID0gY29tcG9uZW50cy5sZW5ndGggPiAxID8gY29tcG9uZW50cy5zbGljZSgwLCAtMSkuam9pbignLScpIDogY29tcG9uZW50c1swXTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnRzWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbF9sb3dlcmNhc2UgfHwgb3B0aW9ucy55YWhvb19sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeWFuZGV4X2RvbWFpbnMuaW5kZXhPZihwYXJ0c1sxXSkgPj0gMCkge1xuICAgIGlmIChvcHRpb25zLmFsbF9sb3dlcmNhc2UgfHwgb3B0aW9ucy55YW5kZXhfbG93ZXJjYXNlKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcGFydHNbMV0gPSAneWFuZGV4LnJ1JzsgLy8gYWxsIHlhbmRleCBkb21haW5zIGFyZSBlcXVhbCwgMXN0IHByZWZmZXJlZFxuICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSkge1xuICAgIC8vIEFueSBvdGhlciBhZGRyZXNzXG4gICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJ0AnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcnRyaW07XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHBhdHRlcm4gPSBjaGFycyA/IG5ldyBSZWdFeHAoXCJbXCIuY29uY2F0KGNoYXJzLCBcIl1cIikpIDogL1xccy87XG4gIHZhciBpZHggPSBzdHIubGVuZ3RoIC0gMTtcblxuICBmb3IgKDsgaWR4ID49IDAgJiYgcGF0dGVybi50ZXN0KHN0cltpZHhdKTsgaWR4LS0pIHtcbiAgICA7XG4gIH1cblxuICByZXR1cm4gaWR4IDwgc3RyLmxlbmd0aCA/IHN0ci5zdWJzdHIoMCwgaWR4ICsgMSkgOiBzdHI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmlwTG93O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2JsYWNrbGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmxhY2tsaXN0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaXBMb3coc3RyLCBrZWVwX25ld19saW5lcykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgY2hhcnMgPSBrZWVwX25ld19saW5lcyA/ICdcXFxceDAwLVxcXFx4MDlcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0YnIDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnO1xuICByZXR1cm4gKDAsIF9ibGFja2xpc3QuZGVmYXVsdCkoc3RyLCBjaGFycyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQm9vbGVhbjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9Cb29sZWFuKHN0ciwgc3RyaWN0KSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKHN0cmljdCkge1xuICAgIHJldHVybiBzdHIgPT09ICcxJyB8fCBzdHIgPT09ICd0cnVlJztcbiAgfVxuXG4gIHJldHVybiBzdHIgIT09ICcwJyAmJiBzdHIgIT09ICdmYWxzZScgJiYgc3RyICE9PSAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9EYXRlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0RhdGUoZGF0ZSkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShkYXRlKTtcbiAgZGF0ZSA9IERhdGUucGFyc2UoZGF0ZSk7XG4gIHJldHVybiAhaXNOYU4oZGF0ZSkgPyBuZXcgRGF0ZShkYXRlKSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvRmxvYXQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvRmxvYXQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvSW50O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0ludChzdHIsIHJhZGl4KSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBwYXJzZUludChzdHIsIHJhZGl4IHx8IDEwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJpbTtcblxudmFyIF9ydHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcnRyaW1cIikpO1xuXG52YXIgX2x0cmltID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9sdHJpbVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRyaW0oc3RyLCBjaGFycykge1xuICByZXR1cm4gKDAsIF9ydHJpbS5kZWZhdWx0KSgoMCwgX2x0cmltLmRlZmF1bHQpKHN0ciwgY2hhcnMpLCBjaGFycyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVuZXNjYXBlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1bmVzY2FwZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mYW1wOy9nLCAnJicpLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKS5yZXBsYWNlKC8mI3gyNzsvZywgXCInXCIpLnJlcGxhY2UoLyZsdDsvZywgJzwnKS5yZXBsYWNlKC8mZ3Q7L2csICc+JykucmVwbGFjZSgvJiN4MkY7L2csICcvJykucmVwbGFjZSgvJiN4NUM7L2csICdcXFxcJykucmVwbGFjZSgvJiM5NjsvZywgJ2AnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0U3RyaW5nO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcoaW5wdXQpIHtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcblxuICBpZiAoIWlzU3RyaW5nKSB7XG4gICAgdmFyIGludmFsaWRUeXBlO1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICBpbnZhbGlkVHlwZSA9ICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YWxpZFR5cGUgPSBfdHlwZW9mKGlucHV0KTtcblxuICAgICAgaWYgKGludmFsaWRUeXBlID09PSAnb2JqZWN0JyAmJiBpbnB1dC5jb25zdHJ1Y3RvciAmJiBpbnB1dC5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpKSB7XG4gICAgICAgIGludmFsaWRUeXBlID0gaW5wdXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRUeXBlID0gXCJhIFwiLmNvbmNhdChpbnZhbGlkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQgXCIuY29uY2F0KGludmFsaWRUeXBlLCBcIi5cIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGZ1bmN0aW9uIChhcnJWYWwpIHtcbiAgICByZXR1cm4gdmFsID09PSBhcnJWYWw7XG4gIH0pO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaW5jbHVkZXM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWZhdWx0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TdHJpbmc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGlucHV0KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcgJiYgaW5wdXQgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNOYU4oaW5wdXQpICYmICFpbnB1dC5sZW5ndGgpIHtcbiAgICBpbnB1dCA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHdoaXRlbGlzdDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gd2hpdGVsaXN0KHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbXlwiLmNvbmNhdChjaGFycywgXCJdK1wiKSwgJ2cnKSwgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwibW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlSZWFkZXI7XHJcblxyXG5mdW5jdGlvbiBCaW5hcnlSZWFkZXIoYnVmZmVyLCBpc0JpZ0VuZGlhbikge1xyXG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIHRoaXMuaXNCaWdFbmRpYW4gPSBpc0JpZ0VuZGlhbiB8fCBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3JlYWQocmVhZExFLCByZWFkQkUsIHNpemUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0JpZ0VuZGlhbilcclxuICAgICAgICAgICAgdmFsdWUgPSByZWFkQkUuY2FsbCh0aGlzLmJ1ZmZlciwgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHJlYWRMRS5jYWxsKHRoaXMuYnVmZmVyLCB0aGlzLnBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG59XHJcblxyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4LCBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCwgMSk7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQxNiA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFLCBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSwgMik7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQzMiA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFLCBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSwgNCk7XHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZEludDggPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4LCBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4LCAxKTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkSW50MTYgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFLCBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFLCAyKTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkSW50MzIgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFLCBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFLCA0KTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkRmxvYXQgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFLCBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFLCA0KTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkRG91YmxlID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFLCA4KTtcclxuXHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZFZhckludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBuZXh0Qnl0ZSxcclxuICAgICAgICByZXN1bHQgPSAwLFxyXG4gICAgICAgIGJ5dGVzUmVhZCA9IDA7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIG5leHRCeXRlID0gdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbiArIGJ5dGVzUmVhZF07XHJcbiAgICAgICAgcmVzdWx0ICs9IChuZXh0Qnl0ZSAmIDB4N0YpIDw8ICg3ICogYnl0ZXNSZWFkKTtcclxuICAgICAgICBieXRlc1JlYWQrKztcclxuICAgIH0gd2hpbGUgKG5leHRCeXRlID49IDB4ODApO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXNSZWFkO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gQmluYXJ5V3JpdGVyO1xyXG5cclxuZnVuY3Rpb24gQmluYXJ5V3JpdGVyKHNpemUsIGFsbG93UmVzaXplKSB7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXIoc2l6ZSk7XHJcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIHRoaXMuYWxsb3dSZXNpemUgPSBhbGxvd1Jlc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3dyaXRlKHdyaXRlLCBzaXplKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZShzaXplKTtcclxuXHJcbiAgICAgICAgd3JpdGUuY2FsbCh0aGlzLmJ1ZmZlciwgdmFsdWUsIHRoaXMucG9zaXRpb24sIG5vQXNzZXJ0KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHNpemU7XHJcbiAgICB9O1xyXG59XHJcblxyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDggPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4LCAxKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSwgMik7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUsIDIpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUsIDIpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSwgMik7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUsIDgpO1xyXG5cclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgIHRoaXMuZW5zdXJlU2l6ZShidWZmZXIubGVuZ3RoKTtcclxuXHJcbiAgICBidWZmZXIuY29weSh0aGlzLmJ1ZmZlciwgdGhpcy5wb3NpdGlvbiwgMCwgYnVmZmVyLmxlbmd0aCk7XHJcbiAgICB0aGlzLnBvc2l0aW9uICs9IGJ1ZmZlci5sZW5ndGg7XHJcbn07XHJcblxyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVmFySW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gMTtcclxuXHJcbiAgICB3aGlsZSAoKHZhbHVlICYgMHhGRkZGRkY4MCkgIT09IDApIHtcclxuICAgICAgICB0aGlzLndyaXRlVUludDgoKHZhbHVlICYgMHg3RikgfCAweDgwKTtcclxuICAgICAgICB2YWx1ZSA+Pj49IDc7XHJcbiAgICAgICAgbGVuZ3RoKys7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlICYgMHg3Rik7XHJcblxyXG4gICAgcmV0dXJuIGxlbmd0aDtcclxufTtcclxuXHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUuZW5zdXJlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgdGhpcy5wb3NpdGlvbiArIHNpemUpIHtcclxuICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcEJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5wb3NpdGlvbiArIHNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5KHRlbXBCdWZmZXIsIDAsIDAsIHRoaXMuYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGVtcEJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gR2VvbWV0cnk7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIExpbmVTdHJpbmcgPSByZXF1aXJlKCcuL2xpbmVzdHJpbmcnKTtcclxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL3BvbHlnb24nKTtcclxudmFyIE11bHRpUG9pbnQgPSByZXF1aXJlKCcuL211bHRpcG9pbnQnKTtcclxudmFyIE11bHRpTGluZVN0cmluZyA9IHJlcXVpcmUoJy4vbXVsdGlsaW5lc3RyaW5nJyk7XHJcbnZhciBNdWx0aVBvbHlnb24gPSByZXF1aXJlKCcuL211bHRpcG9seWdvbicpO1xyXG52YXIgR2VvbWV0cnlDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9nZW9tZXRyeWNvbGxlY3Rpb24nKTtcclxudmFyIEJpbmFyeVJlYWRlciA9IHJlcXVpcmUoJy4vYmluYXJ5cmVhZGVyJyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG52YXIgV2t0UGFyc2VyID0gcmVxdWlyZSgnLi93a3RwYXJzZXInKTtcclxudmFyIFppZ1phZyA9IHJlcXVpcmUoJy4vemlnemFnLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBHZW9tZXRyeSgpIHtcclxuICAgIHRoaXMuc3JpZCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGFzWiA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNNID0gZmFsc2U7XHJcbn1cclxuXHJcbkdlb21ldHJ5LnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuICAgIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgV2t0UGFyc2VyKVxyXG4gICAgICAgIHJldHVybiBHZW9tZXRyeS5fcGFyc2VXa3QodmFsdWUpO1xyXG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeVJlYWRlcilcclxuICAgICAgICByZXR1cm4gR2VvbWV0cnkuX3BhcnNlV2tiKHZhbHVlLCBvcHRpb25zKTtcclxuICAgIGVsc2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgb3IgQnVmZmVyJyk7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciB3a3RQYXJzZXIsXHJcbiAgICAgICAgc3JpZDtcclxuXHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBXa3RQYXJzZXIpXHJcbiAgICAgICAgd2t0UGFyc2VyID0gdmFsdWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgd2t0UGFyc2VyID0gbmV3IFdrdFBhcnNlcih2YWx1ZSk7XHJcblxyXG4gICAgdmFyIG1hdGNoID0gd2t0UGFyc2VyLm1hdGNoUmVnZXgoWy9eU1JJRD0oXFxkKyk7L10pO1xyXG4gICAgaWYgKG1hdGNoKVxyXG4gICAgICAgIHNyaWQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSB3a3RQYXJzZXIubWF0Y2hUeXBlKCk7XHJcbiAgICB2YXIgZGltZW5zaW9uID0gd2t0UGFyc2VyLm1hdGNoRGltZW5zaW9uKCk7XHJcblxyXG4gICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgc3JpZDogc3JpZCxcclxuICAgICAgICBoYXNaOiBkaW1lbnNpb24uaGFzWixcclxuICAgICAgICBoYXNNOiBkaW1lbnNpb24uaGFzTVxyXG4gICAgfTtcclxuXHJcbiAgICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0LlBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIExpbmVTdHJpbmcuX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIFBvbHlnb24uX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuTXVsdGlQb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9pbnQuX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuTXVsdGlMaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0Lk11bHRpUG9seWdvbjpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9seWdvbi5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5HZW9tZXRyeUNvbGxlY3Rpb246XHJcbiAgICAgICAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HZW9tZXRyeS5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIHBhcmVudE9wdGlvbnMpIHtcclxuICAgIHZhciBiaW5hcnlSZWFkZXIsXHJcbiAgICAgICAgd2tiVHlwZSxcclxuICAgICAgICBnZW9tZXRyeVR5cGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeVJlYWRlcilcclxuICAgICAgICBiaW5hcnlSZWFkZXIgPSB2YWx1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICBiaW5hcnlSZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKHZhbHVlKTtcclxuXHJcbiAgICBiaW5hcnlSZWFkZXIuaXNCaWdFbmRpYW4gPSAhYmluYXJ5UmVhZGVyLnJlYWRJbnQ4KCk7XHJcblxyXG4gICAgd2tiVHlwZSA9IGJpbmFyeVJlYWRlci5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgb3B0aW9ucy5oYXNTcmlkID0gKHdrYlR5cGUgJiAweDIwMDAwMDAwKSA9PT0gMHgyMDAwMDAwMDtcclxuICAgIG9wdGlvbnMuaXNFd2tiID0gKHdrYlR5cGUgJiAweDIwMDAwMDAwKSB8fCAod2tiVHlwZSAmIDB4NDAwMDAwMDApIHx8ICh3a2JUeXBlICYgMHg4MDAwMDAwMCk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzU3JpZClcclxuICAgICAgICBvcHRpb25zLnNyaWQgPSBiaW5hcnlSZWFkZXIucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIG9wdGlvbnMuaGFzWiA9IGZhbHNlO1xyXG4gICAgb3B0aW9ucy5oYXNNID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLmlzRXdrYiAmJiAoIXBhcmVudE9wdGlvbnMgfHwgIXBhcmVudE9wdGlvbnMuaXNFd2tiKSkge1xyXG4gICAgICAgIGlmICh3a2JUeXBlID49IDEwMDAgJiYgd2tiVHlwZSA8IDIwMDApIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNaID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlID0gd2tiVHlwZSAtIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHdrYlR5cGUgPj0gMjAwMCAmJiB3a2JUeXBlIDwgMzAwMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmhhc00gPSB0cnVlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSB3a2JUeXBlIC0gMjAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2tiVHlwZSA+PSAzMDAwICYmIHdrYlR5cGUgPCA0MDAwKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzWiA9IHRydWU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzTSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9IHdrYlR5cGUgLSAzMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlID0gd2tiVHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAod2tiVHlwZSAmIDB4ODAwMDAwMDApXHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzWiA9IHRydWU7XHJcbiAgICAgICAgaWYgKHdrYlR5cGUgJiAweDQwMDAwMDAwKVxyXG4gICAgICAgICAgICBvcHRpb25zLmhhc00gPSB0cnVlO1xyXG5cclxuICAgICAgICBnZW9tZXRyeVR5cGUgPSB3a2JUeXBlICYgMHhGO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5MaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTGluZVN0cmluZy5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5Qb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gUG9seWdvbi5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aVBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2ludC5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aUxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aUxpbmVTdHJpbmcuX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlQb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2x5Z29uLl9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLkdlb21ldHJ5Q29sbGVjdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5VHlwZSAnICsgZ2VvbWV0cnlUeXBlICsgJyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBiaW5hcnlSZWFkZXIsXHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeVJlYWRlcilcclxuICAgICAgICBiaW5hcnlSZWFkZXIgPSB2YWx1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICBiaW5hcnlSZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKHZhbHVlKTtcclxuXHJcbiAgICB2YXIgdHlwZSA9IGJpbmFyeVJlYWRlci5yZWFkVUludDgoKTtcclxuICAgIHZhciBtZXRhZGF0YUhlYWRlciA9IGJpbmFyeVJlYWRlci5yZWFkVUludDgoKTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0gdHlwZSAmIDB4MEY7XHJcbiAgICBvcHRpb25zLnByZWNpc2lvbiA9IFppZ1phZy5kZWNvZGUodHlwZSA+PiA0KTtcclxuICAgIG9wdGlvbnMucHJlY2lzaW9uRmFjdG9yID0gTWF0aC5wb3coMTAsIG9wdGlvbnMucHJlY2lzaW9uKTtcclxuXHJcbiAgICBvcHRpb25zLmhhc0JvdW5kaW5nQm94ID0gbWV0YWRhdGFIZWFkZXIgPj4gMCAmIDE7XHJcbiAgICBvcHRpb25zLmhhc1NpemVBdHRyaWJ1dGUgPSBtZXRhZGF0YUhlYWRlciA+PiAxICYgMTtcclxuICAgIG9wdGlvbnMuaGFzSWRMaXN0ID0gbWV0YWRhdGFIZWFkZXIgPj4gMiAmIDE7XHJcbiAgICBvcHRpb25zLmhhc0V4dGVuZGVkUHJlY2lzaW9uID0gbWV0YWRhdGFIZWFkZXIgPj4gMyAmIDE7XHJcbiAgICBvcHRpb25zLmlzRW1wdHkgPSBtZXRhZGF0YUhlYWRlciA+PiA0ICYgMTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNFeHRlbmRlZFByZWNpc2lvbikge1xyXG4gICAgICAgIHZhciBleHRlbmRlZFByZWNpc2lvbiA9IGJpbmFyeVJlYWRlci5yZWFkVUludDgoKTtcclxuICAgICAgICBvcHRpb25zLmhhc1ogPSAoZXh0ZW5kZWRQcmVjaXNpb24gJiAweDAxKSA9PT0gMHgwMTtcclxuICAgICAgICBvcHRpb25zLmhhc00gPSAoZXh0ZW5kZWRQcmVjaXNpb24gJiAweDAyKSA9PT0gMHgwMjtcclxuXHJcbiAgICAgICAgb3B0aW9ucy56UHJlY2lzaW9uID0gWmlnWmFnLmRlY29kZSgoZXh0ZW5kZWRQcmVjaXNpb24gJiAweDFDKSA+PiAyKTtcclxuICAgICAgICBvcHRpb25zLnpQcmVjaXNpb25GYWN0b3IgPSBNYXRoLnBvdygxMCwgb3B0aW9ucy56UHJlY2lzaW9uKTtcclxuXHJcbiAgICAgICAgb3B0aW9ucy5tUHJlY2lzaW9uID0gWmlnWmFnLmRlY29kZSgoZXh0ZW5kZWRQcmVjaXNpb24gJiAweEUwKSA+PiA1KTtcclxuICAgICAgICBvcHRpb25zLm1QcmVjaXNpb25GYWN0b3IgPSBNYXRoLnBvdygxMCwgb3B0aW9ucy5tUHJlY2lzaW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9wdGlvbnMuaGFzWiA9IGZhbHNlO1xyXG4gICAgICAgIG9wdGlvbnMuaGFzTSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc1NpemVBdHRyaWJ1dGUpXHJcbiAgICAgICAgYmluYXJ5UmVhZGVyLnJlYWRWYXJJbnQoKTtcclxuICAgIGlmIChvcHRpb25zLmhhc0JvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSAyO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5oYXNaKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25zKys7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzTSlcclxuICAgICAgICAgICAgZGltZW5zaW9ucysrO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBiaW5hcnlSZWFkZXIucmVhZFZhckludCgpO1xyXG4gICAgICAgICAgICBiaW5hcnlSZWFkZXIucmVhZFZhckludCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLlBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLkxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lU3RyaW5nLl9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5Qb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gUG9seWdvbi5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlQb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpUG9pbnQuX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpTGluZVN0cmluZy5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlQb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2x5Z29uLl9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5HZW9tZXRyeUNvbGxlY3Rpb246XHJcbiAgICAgICAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2VvbWV0cnlUeXBlICcgKyBnZW9tZXRyeVR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdlb21ldHJ5LnBhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIEdlb21ldHJ5Ll9wYXJzZUdlb0pTT04odmFsdWUpO1xyXG59O1xyXG5cclxuR2VvbWV0cnkuX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNTdWJHZW9tZXRyeSkge1xyXG4gICAgdmFyIGdlb21ldHJ5O1xyXG5cclxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5Qb2ludDpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBQb2ludC5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLkxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gTGluZVN0cmluZy5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLlBvbHlnb246XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gUG9seWdvbi5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLk11bHRpUG9pbnQ6XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gTXVsdGlQb2ludC5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLk11bHRpTGluZVN0cmluZzpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBNdWx0aUxpbmVTdHJpbmcuX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5NdWx0aVBvbHlnb246XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gTXVsdGlQb2x5Z29uLl9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uR2VvbWV0cnlDb2xsZWN0aW9uOlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IEdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW9tZXRyeVR5cGUgJyArIHZhbHVlLnR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUuY3JzICYmIHZhbHVlLmNycy50eXBlICYmIHZhbHVlLmNycy50eXBlID09PSAnbmFtZScgJiYgdmFsdWUuY3JzLnByb3BlcnRpZXMgJiYgdmFsdWUuY3JzLnByb3BlcnRpZXMubmFtZSkge1xyXG4gICAgICAgIHZhciBjcnMgPSB2YWx1ZS5jcnMucHJvcGVydGllcy5uYW1lO1xyXG5cclxuICAgICAgICBpZiAoY3JzLmluZGV4T2YoJ0VQU0c6JykgPT09IDApXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnNyaWQgPSBwYXJzZUludChjcnMuc3Vic3RyaW5nKDUpKTtcclxuICAgICAgICBlbHNlIGlmIChjcnMuaW5kZXhPZigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OicpID09PSAwKVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5zcmlkID0gcGFyc2VJbnQoY3JzLnN1YnN0cmluZygyMikpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjcnM6ICcgKyBjcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWlzU3ViR2VvbWV0cnkpIHtcclxuICAgICAgICBnZW9tZXRyeS5zcmlkID0gNDMyNjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnk7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUudG9Fd2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICdTUklEPScgKyB0aGlzLnNyaWQgKyAnOycgKyB0aGlzLnRvV2t0KCk7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUudG9Fd2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSArIDQpO1xyXG4gICAgdmFyIHdrYiA9IHRoaXMudG9Xa2IoKTtcclxuXHJcbiAgICBld2tiLndyaXRlSW50OCgxKTtcclxuICAgIGV3a2Iud3JpdGVVSW50MzJMRSgod2tiLnNsaWNlKDEsIDUpLnJlYWRVSW50MzJMRSgwKSB8IDB4MjAwMDAwMDApID4+PiAwLCB0cnVlKTtcclxuICAgIGV3a2Iud3JpdGVVSW50MzJMRSh0aGlzLnNyaWQpO1xyXG5cclxuICAgIGV3a2Iud3JpdGVCdWZmZXIod2tiLnNsaWNlKDUpKTtcclxuXHJcbiAgICByZXR1cm4gZXdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUuX2dldFdrdFR5cGUgPSBmdW5jdGlvbiAod2t0VHlwZSwgaXNFbXB0eSkge1xyXG4gICAgdmFyIHdrdCA9IHdrdFR5cGU7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWiAmJiB0aGlzLmhhc00pXHJcbiAgICAgICAgd2t0ICs9ICcgWk0gJztcclxuICAgIGVsc2UgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICB3a3QgKz0gJyBaICc7XHJcbiAgICBlbHNlIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgd2t0ICs9ICcgTSAnO1xyXG5cclxuICAgIGlmIChpc0VtcHR5ICYmICF0aGlzLmhhc1ogJiYgIXRoaXMuaGFzTSlcclxuICAgICAgICB3a3QgKz0gJyAnO1xyXG5cclxuICAgIGlmIChpc0VtcHR5KVxyXG4gICAgICAgIHdrdCArPSAnRU1QVFknO1xyXG5cclxuICAgIHJldHVybiB3a3Q7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUuX2dldFdrdENvb3JkaW5hdGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgIHZhciBjb29yZGluYXRlcyA9IHBvaW50LnggKyAnICcgKyBwb2ludC55O1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgY29vcmRpbmF0ZXMgKz0gJyAnICsgcG9pbnQuejtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgY29vcmRpbmF0ZXMgKz0gJyAnICsgcG9pbnQubTtcclxuXHJcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUuX3dyaXRlV2tiVHlwZSA9IGZ1bmN0aW9uICh3a2IsIGdlb21ldHJ5VHlwZSwgcGFyZW50T3B0aW9ucykge1xyXG4gICAgdmFyIGRpbWVuc2lvblR5cGUgPSAwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy5zcmlkID09PSAndW5kZWZpbmVkJyAmJiAoIXBhcmVudE9wdGlvbnMgfHwgdHlwZW9mIHBhcmVudE9wdGlvbnMuc3JpZCA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzWiAmJiB0aGlzLmhhc00pXHJcbiAgICAgICAgICAgIGRpbWVuc2lvblR5cGUgKz0gMzAwMDtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgIGRpbWVuc2lvblR5cGUgKz0gMTAwMDtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgICAgIGRpbWVuc2lvblR5cGUgKz0gMjAwMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgIGRpbWVuc2lvblR5cGUgfD0gMHg4MDAwMDAwMDtcclxuICAgICAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25UeXBlIHw9IDB4NDAwMDAwMDA7XHJcbiAgICB9XHJcblxyXG4gICAgd2tiLndyaXRlVUludDMyTEUoKGRpbWVuc2lvblR5cGUgKyBnZW9tZXRyeVR5cGUpID4+PiAwLCB0cnVlKTtcclxufTtcclxuXHJcbkdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24gPSBmdW5jdGlvbiAoeHlQcmVjaXNpb24sIHpQcmVjaXNpb24sIG1QcmVjaXNpb24pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeHk6IHh5UHJlY2lzaW9uLFxyXG4gICAgICAgIHo6IHpQcmVjaXNpb24sXHJcbiAgICAgICAgbTogbVByZWNpc2lvbixcclxuICAgICAgICB4eUZhY3RvcjogTWF0aC5wb3coMTAsIHh5UHJlY2lzaW9uKSxcclxuICAgICAgICB6RmFjdG9yOiBNYXRoLnBvdygxMCwgelByZWNpc2lvbiksXHJcbiAgICAgICAgbUZhY3RvcjogTWF0aC5wb3coMTAsIG1QcmVjaXNpb24pXHJcbiAgICB9O1xyXG59O1xyXG5cclxuR2VvbWV0cnkucHJvdG90eXBlLl93cml0ZVR3a2JIZWFkZXIgPSBmdW5jdGlvbiAodHdrYiwgZ2VvbWV0cnlUeXBlLCBwcmVjaXNpb24sIGlzRW1wdHkpIHtcclxuICAgIHZhciB0eXBlID0gKFppZ1phZy5lbmNvZGUocHJlY2lzaW9uLnh5KSA8PCA0KSArIGdlb21ldHJ5VHlwZTtcclxuICAgIHZhciBtZXRhZGF0YUhlYWRlciA9ICh0aGlzLmhhc1ogfHwgdGhpcy5oYXNNKSA8PCAzO1xyXG4gICAgbWV0YWRhdGFIZWFkZXIgKz0gaXNFbXB0eSA8PCA0O1xyXG5cclxuICAgIHR3a2Iud3JpdGVVSW50OCh0eXBlKTtcclxuICAgIHR3a2Iud3JpdGVVSW50OChtZXRhZGF0YUhlYWRlcik7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWiB8fCB0aGlzLmhhc00pIHtcclxuICAgICAgICB2YXIgZXh0ZW5kZWRQcmVjaXNpb24gPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgIGV4dGVuZGVkUHJlY2lzaW9uIHw9IDB4MTtcclxuICAgICAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgICAgICBleHRlbmRlZFByZWNpc2lvbiB8PSAweDI7XHJcblxyXG4gICAgICAgIHR3a2Iud3JpdGVVSW50OChleHRlbmRlZFByZWNpc2lvbik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0ge307XHJcblxyXG4gICAgaWYgKHRoaXMuc3JpZCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3J0Q3JzKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9KU09OLmNycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRVBTRzonICsgdGhpcy5zcmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmxvbmdDcnMpIHtcclxuICAgICAgICAgICAgICAgIGdlb0pTT04uY3JzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICduYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cm46b2djOmRlZjpjcnM6RVBTRzo6JyArIHRoaXMuc3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gR2VvbWV0cnlDb2xsZWN0aW9uO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5nZW9tZXRyaWVzWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5nZW9tZXRyaWVzWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoR2VvbWV0cnlDb2xsZWN0aW9uLCBHZW9tZXRyeSk7XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uWiA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzLCBzcmlkKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBzcmlkKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uTSA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzLCBzcmlkKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBzcmlkKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uWk0gPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgc3JpZCkge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgc3JpZCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IHRydWU7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5wdXNoKEdlb21ldHJ5LnBhcnNlKHZhbHVlKSk7XHJcbiAgICB9IHdoaWxlICh2YWx1ZS5pc01hdGNoKFsnLCddKSk7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnlDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Q291bnQ7IGkrKylcclxuICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5wdXNoKEdlb21ldHJ5LnBhcnNlKHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbigpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5Q291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeUNvdW50OyBpKyspXHJcbiAgICAgICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMucHVzaChHZW9tZXRyeS5wYXJzZVR3a2IodmFsdWUpKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLnB1c2goR2VvbWV0cnkuX3BhcnNlR2VvSlNPTih2YWx1ZS5nZW9tZXRyaWVzW2ldLCB0cnVlKSk7XHJcblxyXG4gICAgaWYgKGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllc1swXS5oYXNaO1xyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lkdlb21ldHJ5Q29sbGVjdGlvbiwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHdrdCA9IHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lkdlb21ldHJ5Q29sbGVjdGlvbiwgZmFsc2UpICsgJygnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrdCArPSB0aGlzLmdlb21ldHJpZXNbaV0udG9Xa3QoKSArICcsJztcclxuXHJcbiAgICB3a3QgPSB3a3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgd2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gd2t0O1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuR2VvbWV0cnlDb2xsZWN0aW9uKTtcclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrYi53cml0ZUJ1ZmZlcih0aGlzLmdlb21ldHJpZXNbaV0udG9Xa2IoeyBzcmlkOiB0aGlzLnNyaWQgfSkpO1xyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5HZW9tZXRyeUNvbGxlY3Rpb24sIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHR3a2Iud3JpdGVCdWZmZXIodGhpcy5nZW9tZXRyaWVzW2ldLnRvVHdrYigpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNpemUgPSAxICsgNCArIDQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgc2l6ZSArPSB0aGlzLmdlb21ldHJpZXNbaV0uX2dldFdrYlNpemUoKTtcclxuXHJcbiAgICByZXR1cm4gc2l6ZTtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5HZW9tZXRyeUNvbGxlY3Rpb247XHJcbiAgICBnZW9KU09OLmdlb21ldHJpZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBnZW9KU09OLmdlb21ldHJpZXMucHVzaCh0aGlzLmdlb21ldHJpZXNbaV0udG9HZW9KU09OKCkpO1xyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IExpbmVTdHJpbmc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gTGluZVN0cmluZyhwb2ludHMsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMucG9pbnRzWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5wb2ludHNbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhMaW5lU3RyaW5nLCBHZW9tZXRyeSk7XHJcblxyXG5MaW5lU3RyaW5nLlogPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKHBvaW50cywgc3JpZCk7XHJcbiAgICBsaW5lU3RyaW5nLmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLk0gPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKHBvaW50cywgc3JpZCk7XHJcbiAgICBsaW5lU3RyaW5nLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLlpNID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhwb2ludHMsIHNyaWQpO1xyXG4gICAgbGluZVN0cmluZy5oYXNaID0gdHJ1ZTtcclxuICAgIGxpbmVTdHJpbmcuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKCk7XHJcbiAgICBsaW5lU3RyaW5nLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBsaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBsaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gbGluZVN0cmluZztcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICBsaW5lU3RyaW5nLnBvaW50cy5wdXNoLmFwcGx5KGxpbmVTdHJpbmcucG9pbnRzLCB2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLl9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZygpO1xyXG4gICAgbGluZVN0cmluZy5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciBwb2ludENvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKVxyXG4gICAgICAgIGxpbmVTdHJpbmcucG9pbnRzLnB1c2goUG9pbnQuX3JlYWRXa2JQb2ludCh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKCk7XHJcbiAgICBsaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBsaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gbGluZVN0cmluZztcclxuXHJcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCBvcHRpb25zLmhhc1ogPyAwIDogdW5kZWZpbmVkLCBvcHRpb25zLmhhc00gPyAwIDogdW5kZWZpbmVkKTtcclxuICAgIHZhciBwb2ludENvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKVxyXG4gICAgICAgIGxpbmVTdHJpbmcucG9pbnRzLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZygpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgIGxpbmVTdHJpbmcuaGFzWiA9IHZhbHVlLmNvb3JkaW5hdGVzWzBdLmxlbmd0aCA+IDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBsaW5lU3RyaW5nLnBvaW50cy5wdXNoKFBvaW50Ll9yZWFkR2VvSlNPTlBvaW50KHZhbHVlLmNvb3JkaW5hdGVzW2ldKSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LkxpbmVTdHJpbmcsIHRydWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5MaW5lU3RyaW5nLCBmYWxzZSkgKyB0aGlzLl90b0lubmVyV2t0KCk7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5fdG9Jbm5lcldrdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbm5lcldrdCA9ICcoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlubmVyV2t0ICs9IHRoaXMuX2dldFdrdENvb3JkaW5hdGUodGhpcy5wb2ludHNbaV0pICsgJywnO1xyXG5cclxuICAgIGlubmVyV2t0ID0gaW5uZXJXa3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgaW5uZXJXa3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiBpbm5lcldrdDtcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKHBhcmVudE9wdGlvbnMpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuTGluZVN0cmluZywgcGFyZW50T3B0aW9ucyk7XHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLnBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5wb2ludHNbaV0uX3dyaXRlV2tiUG9pbnQod2tiKTtcclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5wb2ludHMubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuTGluZVN0cmluZywgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5wb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZVNpemUgPSAxNjtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcblxyXG4gICAgcmV0dXJuIDEgKyA0ICsgNCArICh0aGlzLnBvaW50cy5sZW5ndGggKiBjb29yZGluYXRlU2l6ZSk7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLkxpbmVTdHJpbmc7XHJcbiAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaChbdGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSwgdGhpcy5wb2ludHNbaV0uel0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKFt0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55XSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gTXVsdGlMaW5lU3RyaW5nO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgTGluZVN0cmluZyA9IHJlcXVpcmUoJy4vbGluZXN0cmluZycpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmxpbmVTdHJpbmdzID0gbGluZVN0cmluZ3MgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5saW5lU3RyaW5ncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5saW5lU3RyaW5nc1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMubGluZVN0cmluZ3NbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhNdWx0aUxpbmVTdHJpbmcsIEdlb21ldHJ5KTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5aID0gZnVuY3Rpb24gKGxpbmVTdHJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgc3JpZCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLk0gPSBmdW5jdGlvbiAobGluZVN0cmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCBzcmlkKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuWk0gPSBmdW5jdGlvbiAobGluZVN0cmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCBzcmlkKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gdHJ1ZTtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZygpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgICAgICBtdWx0aUxpbmVTdHJpbmcubGluZVN0cmluZ3MucHVzaChuZXcgTGluZVN0cmluZyh2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKSk7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuICAgIH0gd2hpbGUgKHZhbHVlLmlzTWF0Y2goWycsJ10pKTtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZygpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciBsaW5lU3RyaW5nQ291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU3RyaW5nQ291bnQ7IGkrKylcclxuICAgICAgICBtdWx0aUxpbmVTdHJpbmcubGluZVN0cmluZ3MucHVzaChHZW9tZXRyeS5wYXJzZSh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG5cclxuICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIG9wdGlvbnMuaGFzWiA/IDAgOiB1bmRlZmluZWQsIG9wdGlvbnMuaGFzTSA/IDAgOiB1bmRlZmluZWQpO1xyXG4gICAgdmFyIGxpbmVTdHJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTdHJpbmdDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZygpO1xyXG4gICAgICAgIGxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgICAgICBsaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgICAgIHZhciBwb2ludENvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50Q291bnQ7IGorKylcclxuICAgICAgICAgICAgbGluZVN0cmluZy5wb2ludHMucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgICAgICBtdWx0aUxpbmVTdHJpbmcubGluZVN0cmluZ3MucHVzaChsaW5lU3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLl9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDAgJiYgdmFsdWUuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMClcclxuICAgICAgICBtdWx0aUxpbmVTdHJpbmcuaGFzWiA9IHZhbHVlLmNvb3JkaW5hdGVzWzBdWzBdLmxlbmd0aCA+IDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBtdWx0aUxpbmVTdHJpbmcubGluZVN0cmluZ3MucHVzaChMaW5lU3RyaW5nLl9wYXJzZUdlb0pTT04oeyBjb29yZGluYXRlczogdmFsdWUuY29vcmRpbmF0ZXNbaV0gfSkpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMubGluZVN0cmluZ3MubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aUxpbmVTdHJpbmcsIHRydWUpO1xyXG5cclxuICAgIHZhciB3a3QgPSB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aUxpbmVTdHJpbmcsIGZhbHNlKSArICcoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2t0ICs9IHRoaXMubGluZVN0cmluZ3NbaV0uX3RvSW5uZXJXa3QoKSArICcsJztcclxuXHJcbiAgICB3a3QgPSB3a3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgd2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gd2t0O1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuTXVsdGlMaW5lU3RyaW5nKTtcclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMubGluZVN0cmluZ3MubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2tiLndyaXRlQnVmZmVyKHRoaXMubGluZVN0cmluZ3NbaV0udG9Xa2IoeyBzcmlkOiB0aGlzLnNyaWQgfSkpO1xyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuTXVsdGlMaW5lU3RyaW5nLCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMubGluZVN0cmluZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5saW5lU3RyaW5nc1tpXS5wb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5saW5lU3RyaW5nc1tpXS5wb2ludHMubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdHJpbmdzW2ldLnBvaW50c1tqXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzaXplID0gMSArIDQgKyA0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lU3RyaW5ncy5sZW5ndGg7IGkrKylcclxuICAgICAgICBzaXplICs9IHRoaXMubGluZVN0cmluZ3NbaV0uX2dldFdrYlNpemUoKTtcclxuXHJcbiAgICByZXR1cm4gc2l6ZTtcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5NdWx0aUxpbmVTdHJpbmc7XHJcbiAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaCh0aGlzLmxpbmVTdHJpbmdzW2ldLnRvR2VvSlNPTigpLmNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aVBvaW50O1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIE11bHRpUG9pbnQocG9pbnRzLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblx0XHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMucG9pbnRzWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5wb2ludHNbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhNdWx0aVBvaW50LCBHZW9tZXRyeSk7XHJcblxyXG5NdWx0aVBvaW50LlogPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHBvaW50cywgc3JpZCk7XHJcbiAgICBtdWx0aVBvaW50Lmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50Lk0gPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHBvaW50cywgc3JpZCk7XHJcbiAgICBtdWx0aVBvaW50Lmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LlpNID0gZnVuY3Rpb24gKHBvaW50cywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludChwb2ludHMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2ludC5oYXNaID0gdHJ1ZTtcclxuICAgIG11bHRpUG9pbnQuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KCk7XHJcbiAgICBtdWx0aVBvaW50LnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aVBvaW50Lmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvaW50Lmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlQb2ludDtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICBtdWx0aVBvaW50LnBvaW50cy5wdXNoLmFwcGx5KG11bHRpUG9pbnQucG9pbnRzLCB2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50Ll9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludCgpO1xyXG4gICAgbXVsdGlQb2ludC5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlQb2ludC5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2ludC5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciBwb2ludENvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKVxyXG4gICAgICAgIG11bHRpUG9pbnQucG9pbnRzLnB1c2goR2VvbWV0cnkucGFyc2UodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludCgpO1xyXG4gICAgbXVsdGlQb2ludC5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2ludC5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgb3B0aW9ucy5oYXNaID8gMCA6IHVuZGVmaW5lZCwgb3B0aW9ucy5oYXNNID8gMCA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgcG9pbnRDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkrKylcclxuICAgICAgICBtdWx0aVBvaW50LnBvaW50cy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50Ll9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQoKTtcclxuXHJcbiAgICBpZiAodmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoID4gMClcclxuICAgICAgICBtdWx0aVBvaW50Lmhhc1ogPSB2YWx1ZS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgbXVsdGlQb2ludC5wb2ludHMucHVzaChQb2ludC5fcGFyc2VHZW9KU09OKHsgY29vcmRpbmF0ZXM6IHZhbHVlLmNvb3JkaW5hdGVzW2ldIH0pKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlQb2ludCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHdrdCA9IHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpUG9pbnQsIGZhbHNlKSArICcoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrdCArPSB0aGlzLl9nZXRXa3RDb29yZGluYXRlKHRoaXMucG9pbnRzW2ldKSArICcsJztcclxuXHJcbiAgICB3a3QgPSB3a3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgd2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gd2t0O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLk11bHRpUG9pbnQpO1xyXG4gICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5wb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrYi53cml0ZUJ1ZmZlcih0aGlzLnBvaW50c1tpXS50b1drYih7IHNyaWQ6IHRoaXMuc3JpZCB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLk11bHRpUG9pbnQsIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMucG9pbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpUG9pbnQucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVTaXplID0gMTY7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICBjb29yZGluYXRlU2l6ZSArPSA4O1xyXG5cclxuICAgIGNvb3JkaW5hdGVTaXplICs9IDU7XHJcblxyXG4gICAgcmV0dXJuIDEgKyA0ICsgNCArICh0aGlzLnBvaW50cy5sZW5ndGggKiBjb29yZGluYXRlU2l6ZSk7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLk11bHRpUG9pbnQ7XHJcbiAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2godGhpcy5wb2ludHNbaV0udG9HZW9KU09OKCkuY29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IE11bHRpUG9seWdvbjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL3BvbHlnb24nKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5wb2x5Z29ucyA9IHBvbHlnb25zIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMucG9seWdvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFzWiA9IHRoaXMucG9seWdvbnNbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLnBvbHlnb25zWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoTXVsdGlQb2x5Z29uLCBHZW9tZXRyeSk7XHJcblxyXG5NdWx0aVBvbHlnb24uWiA9IGZ1bmN0aW9uIChwb2x5Z29ucywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHNyaWQpO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5NID0gZnVuY3Rpb24gKHBvbHlnb25zLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgc3JpZCk7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLlpNID0gZnVuY3Rpb24gKHBvbHlnb25zLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgc3JpZCk7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzWiA9IHRydWU7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLl9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24oKTtcclxuICAgIG11bHRpUG9seWdvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgICAgIHZhciBleHRlcmlvclJpbmcgPSBbXTtcclxuICAgICAgICB2YXIgaW50ZXJpb3JSaW5ncyA9IFtdO1xyXG5cclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICAgICAgZXh0ZXJpb3JSaW5nLnB1c2guYXBwbHkoZXh0ZXJpb3JSaW5nLCB2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgICAgICB3aGlsZSAodmFsdWUuaXNNYXRjaChbJywnXSkpIHtcclxuICAgICAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgICAgICAgICBpbnRlcmlvclJpbmdzLnB1c2godmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICAgICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtdWx0aVBvbHlnb24ucG9seWdvbnMucHVzaChuZXcgUG9seWdvbihleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MpKTtcclxuXHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICB9IHdoaWxlICh2YWx1ZS5pc01hdGNoKFsnLCddKSk7XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLl9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24oKTtcclxuICAgIG11bHRpUG9seWdvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgcG9seWdvbkNvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbkNvdW50OyBpKyspXHJcbiAgICAgICAgbXVsdGlQb2x5Z29uLnBvbHlnb25zLnB1c2goR2VvbWV0cnkucGFyc2UodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLl9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKCk7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxuXHJcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCBvcHRpb25zLmhhc1ogPyAwIDogdW5kZWZpbmVkLCBvcHRpb25zLmhhc00gPyAwIDogdW5kZWZpbmVkKTtcclxuICAgIHZhciBwb2x5Z29uQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQ291bnQ7IGkrKykge1xyXG4gICAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oKTtcclxuICAgICAgICBwb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICAgICAgcG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgICAgICB2YXIgcmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG4gICAgICAgIHZhciBleHRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHRlcmlvclJpbmdDb3VudDsgaisrKVxyXG4gICAgICAgICAgICBwb2x5Z29uLmV4dGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCByaW5nQ291bnQ7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJpb3JSaW5nID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGludGVyaW9yUmluZ0NvdW50OyBrKyspXHJcbiAgICAgICAgICAgICAgICBpbnRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgICAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzLnB1c2goaW50ZXJpb3JSaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG11bHRpUG9seWdvbi5wb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24oKTtcclxuXHJcbiAgICBpZiAodmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoID4gMCAmJiB2YWx1ZS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAwICYmIHZhbHVlLmNvb3JkaW5hdGVzWzBdWzBdLmxlbmd0aCA+IDApXHJcbiAgICAgICAgbXVsdGlQb2x5Z29uLmhhc1ogPSB2YWx1ZS5jb29yZGluYXRlc1swXVswXVswXS5sZW5ndGggPiAyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgbXVsdGlQb2x5Z29uLnBvbHlnb25zLnB1c2goUG9seWdvbi5fcGFyc2VHZW9KU09OKHsgY29vcmRpbmF0ZXM6IHZhbHVlLmNvb3JkaW5hdGVzW2ldIH0pKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLnBvbHlnb25zLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlQb2x5Z29uLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgd2t0ID0gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlQb2x5Z29uLCBmYWxzZSkgKyAnKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvbHlnb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrdCArPSB0aGlzLnBvbHlnb25zW2ldLl90b0lubmVyV2t0KCkgKyAnLCc7XHJcblxyXG4gICAgd2t0ID0gd2t0LnNsaWNlKDAsIC0xKTtcclxuICAgIHdrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIHdrdDtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2tiID0gbmV3IEJpbmFyeVdyaXRlcih0aGlzLl9nZXRXa2JTaXplKCkpO1xyXG5cclxuICAgIHdrYi53cml0ZUludDgoMSk7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLk11bHRpUG9seWdvbik7XHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLnBvbHlnb25zLmxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvbHlnb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHdrYi53cml0ZUJ1ZmZlcih0aGlzLnBvbHlnb25zW2ldLnRvV2tiKHsgc3JpZDogdGhpcy5zcmlkIH0pKTtcclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLnBvbHlnb25zLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLk11bHRpUG9seWdvbiwgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5wb2x5Z29ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLnBvbHlnb25zLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2x5Z29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0d2tiLndyaXRlVmFySW50KDEgKyB0aGlzLnBvbHlnb25zW2ldLmludGVyaW9yUmluZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5wb2x5Z29uc1tpXS5leHRlcmlvclJpbmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5wb2x5Z29uc1tpXS5leHRlcmlvclJpbmcubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25zW2ldLmV4dGVyaW9yUmluZ1tqXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnBvbHlnb25zW2ldLmludGVyaW9yUmluZ3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5wb2x5Z29uc1tpXS5pbnRlcmlvclJpbmdzW2pdLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLnBvbHlnb25zW2ldLmludGVyaW9yUmluZ3Nbal0ubGVuZ3RoOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uc1tpXS5pbnRlcmlvclJpbmdzW2pdW2tdLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2l6ZSA9IDEgKyA0ICsgNDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgc2l6ZSArPSB0aGlzLnBvbHlnb25zW2ldLl9nZXRXa2JTaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uTXVsdGlQb2x5Z29uO1xyXG4gICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2x5Z29ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2godGhpcy5wb2x5Z29uc1tpXS50b0dlb0pTT04oKS5jb29yZGluYXRlcyk7XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxudmFyIFppZ1phZyA9IHJlcXVpcmUoJy4vemlnemFnLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB6LCBtLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy56ID0gejtcclxuICAgIHRoaXMubSA9IG07XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICB0aGlzLmhhc1ogPSB0eXBlb2YgdGhpcy56ICE9PSAndW5kZWZpbmVkJztcclxuICAgIHRoaXMuaGFzTSA9IHR5cGVvZiB0aGlzLm0gIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKFBvaW50LCBHZW9tZXRyeSk7XHJcblxyXG5Qb2ludC5aID0gZnVuY3Rpb24gKHgsIHksIHosIHNyaWQpIHtcclxuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5LCB6LCB1bmRlZmluZWQsIHNyaWQpO1xyXG4gICAgcG9pbnQuaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5NID0gZnVuY3Rpb24gKHgsIHksIG0sIHNyaWQpIHtcclxuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5LCB1bmRlZmluZWQsIG0sIHNyaWQpO1xyXG4gICAgcG9pbnQuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5aTSA9IGZ1bmN0aW9uICh4LCB5LCB6LCBtLCBzcmlkKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSwgeiwgbSwgc3JpZCk7XHJcbiAgICBwb2ludC5oYXNaID0gdHJ1ZTtcclxuICAgIHBvaW50Lmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoKTtcclxuICAgIHBvaW50LnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBwb2ludC5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgcG9pbnQuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgdmFyIGNvb3JkaW5hdGUgPSB2YWx1ZS5tYXRjaENvb3JkaW5hdGUob3B0aW9ucyk7XHJcblxyXG4gICAgcG9pbnQueCA9IGNvb3JkaW5hdGUueDtcclxuICAgIHBvaW50LnkgPSBjb29yZGluYXRlLnk7XHJcbiAgICBwb2ludC56ID0gY29vcmRpbmF0ZS56O1xyXG4gICAgcG9pbnQubSA9IGNvb3JkaW5hdGUubTtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50Ll9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvaW50ID0gUG9pbnQuX3JlYWRXa2JQb2ludCh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBwb2ludC5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuX3JlYWRXa2JQb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludCh2YWx1ZS5yZWFkRG91YmxlKCksIHZhbHVlLnJlYWREb3VibGUoKSxcclxuICAgICAgICBvcHRpb25zLmhhc1ogPyB2YWx1ZS5yZWFkRG91YmxlKCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgb3B0aW9ucy5oYXNNID8gdmFsdWUucmVhZERvdWJsZSgpIDogdW5kZWZpbmVkKTtcclxufTtcclxuXHJcblBvaW50Ll9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgcG9pbnQuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIHBvaW50Lmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gcG9pbnQ7XHJcblxyXG4gICAgcG9pbnQueCA9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMucHJlY2lzaW9uRmFjdG9yO1xyXG4gICAgcG9pbnQueSA9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMucHJlY2lzaW9uRmFjdG9yO1xyXG4gICAgcG9pbnQueiA9IG9wdGlvbnMuaGFzWiA/IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMuelByZWNpc2lvbkZhY3RvciA6IHVuZGVmaW5lZDtcclxuICAgIHBvaW50Lm0gPSBvcHRpb25zLmhhc00gPyBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLm1QcmVjaXNpb25GYWN0b3IgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuX3JlYWRUd2tiUG9pbnQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpIHtcclxuICAgIHByZXZpb3VzUG9pbnQueCArPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnByZWNpc2lvbkZhY3RvcjtcclxuICAgIHByZXZpb3VzUG9pbnQueSArPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnByZWNpc2lvbkZhY3RvcjtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNaKVxyXG4gICAgICAgIHByZXZpb3VzUG9pbnQueiArPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLnpQcmVjaXNpb25GYWN0b3I7XHJcbiAgICBpZiAob3B0aW9ucy5oYXNNKVxyXG4gICAgICAgIHByZXZpb3VzUG9pbnQubSArPSBaaWdaYWcuZGVjb2RlKHZhbHVlLnJlYWRWYXJJbnQoKSkgLyBvcHRpb25zLm1QcmVjaXNpb25GYWN0b3I7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQb2ludChwcmV2aW91c1BvaW50LngsIHByZXZpb3VzUG9pbnQueSwgcHJldmlvdXNQb2ludC56LCBwcmV2aW91c1BvaW50Lm0pO1xyXG59O1xyXG5cclxuUG9pbnQuX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFBvaW50Ll9yZWFkR2VvSlNPTlBvaW50KHZhbHVlLmNvb3JkaW5hdGVzKTtcclxufTtcclxuXHJcblBvaW50Ll9yZWFkR2VvSlNPTlBvaW50ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XHJcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoKTtcclxuXHJcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMilcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSwgY29vcmRpbmF0ZXNbMl0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgUG9pbnQoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdKTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS50b1drdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy54ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy55ID09PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiB0aGlzLnogPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLm0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5Qb2ludCwgdHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LlBvaW50LCBmYWxzZSkgKyAnKCcgKyB0aGlzLl9nZXRXa3RDb29yZGluYXRlKHRoaXMpICsgJyknO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKHBhcmVudE9wdGlvbnMpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5Qb2ludCwgcGFyZW50T3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgd2tiLndyaXRlRG91YmxlTEUoTmFOKTtcclxuICAgICAgICB3a2Iud3JpdGVEb3VibGVMRShOYU4pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICB3a2Iud3JpdGVEb3VibGVMRShOYU4pO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgICAgIHdrYi53cml0ZURvdWJsZUxFKE5hTik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl93cml0ZVdrYlBvaW50KHdrYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuX3dyaXRlV2tiUG9pbnQgPSBmdW5jdGlvbiAod2tiKSB7XHJcbiAgICB3a2Iud3JpdGVEb3VibGVMRSh0aGlzLngpO1xyXG4gICAgd2tiLndyaXRlRG91YmxlTEUodGhpcy55KTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIHdrYi53cml0ZURvdWJsZUxFKHRoaXMueik7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIHdrYi53cml0ZURvdWJsZUxFKHRoaXMubSk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0eXBlb2YgdGhpcy54ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy55ID09PSAndW5kZWZpbmVkJztcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLlBvaW50LCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICghaXNFbXB0eSlcclxuICAgICAgICB0aGlzLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIG5ldyBQb2ludCgwLCAwLCAwLCAwKSk7XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLl93cml0ZVR3a2JQb2ludCA9IGZ1bmN0aW9uICh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpIHtcclxuICAgIHZhciB4ID0gdGhpcy54ICogcHJlY2lzaW9uLnh5RmFjdG9yO1xyXG4gICAgdmFyIHkgPSB0aGlzLnkgKiBwcmVjaXNpb24ueHlGYWN0b3I7XHJcbiAgICB2YXIgeiA9IHRoaXMueiAqIHByZWNpc2lvbi56RmFjdG9yO1xyXG4gICAgdmFyIG0gPSB0aGlzLm0gKiBwcmVjaXNpb24ubUZhY3RvcjtcclxuXHJcbiAgICB0d2tiLndyaXRlVmFySW50KFppZ1phZy5lbmNvZGUoeCAtIHByZXZpb3VzUG9pbnQueCkpO1xyXG4gICAgdHdrYi53cml0ZVZhckludChaaWdaYWcuZW5jb2RlKHkgLSBwcmV2aW91c1BvaW50LnkpKTtcclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludChaaWdaYWcuZW5jb2RlKHogLSBwcmV2aW91c1BvaW50LnopKTtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludChaaWdaYWcuZW5jb2RlKG0gLSBwcmV2aW91c1BvaW50Lm0pKTtcclxuXHJcbiAgICBwcmV2aW91c1BvaW50LnggPSB4O1xyXG4gICAgcHJldmlvdXNQb2ludC55ID0geTtcclxuICAgIHByZXZpb3VzUG9pbnQueiA9IHo7XHJcbiAgICBwcmV2aW91c1BvaW50Lm0gPSBtO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNpemUgPSAxICsgNCArIDggKyA4O1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgc2l6ZSArPSA4O1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICBzaXplICs9IDg7XHJcblxyXG4gICAgcmV0dXJuIHNpemU7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5Qb2ludDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMueSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMueiAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFt0aGlzLngsIHRoaXMueSwgdGhpcy56XTtcclxuICAgIGVsc2VcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW3RoaXMueCwgdGhpcy55XTtcclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIFBvbHlnb24oZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZXh0ZXJpb3JSaW5nID0gZXh0ZXJpb3JSaW5nIHx8IFtdO1xyXG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gaW50ZXJpb3JSaW5ncyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5leHRlcmlvclJpbmdbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLmV4dGVyaW9yUmluZ1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKFBvbHlnb24sIEdlb21ldHJ5KTtcclxuXHJcblBvbHlnb24uWiA9IGZ1bmN0aW9uIChleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKTtcclxuICAgIHBvbHlnb24uaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uTSA9IGZ1bmN0aW9uIChleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKTtcclxuICAgIHBvbHlnb24uaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uWk0gPSBmdW5jdGlvbiAoZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCk7XHJcbiAgICBwb2x5Z29uLmhhc1ogPSB0cnVlO1xyXG4gICAgcG9seWdvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oKTtcclxuICAgIHBvbHlnb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIHBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIHBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBwb2x5Z29uO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICBwb2x5Z29uLmV4dGVyaW9yUmluZy5wdXNoLmFwcGx5KHBvbHlnb24uZXh0ZXJpb3JSaW5nLCB2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgd2hpbGUgKHZhbHVlLmlzTWF0Y2goWycsJ10pKSB7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5ncy5wdXNoKHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24uX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICBwb2x5Z29uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBwb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBwb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIHJpbmdDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBpZiAocmluZ0NvdW50ID4gMCkge1xyXG4gICAgICAgIHZhciBleHRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlcmlvclJpbmdDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICBwb2x5Z29uLmV4dGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkV2tiUG9pbnQodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJpbmdDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcmlvclJpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW50ZXJpb3JSaW5nQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIGludGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkV2tiUG9pbnQodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICAgICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5ncy5wdXNoKGludGVyaW9yUmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICBwb2x5Z29uLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBwb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuXHJcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCBvcHRpb25zLmhhc1ogPyAwIDogdW5kZWZpbmVkLCBvcHRpb25zLmhhc00gPyAwIDogdW5kZWZpbmVkKTtcclxuICAgIHZhciByaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcbiAgICB2YXIgZXh0ZXJpb3JSaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlcmlvclJpbmdDb3VudDsgaSsrKVxyXG4gICAgICAgIHBvbHlnb24uZXh0ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgcmluZ0NvdW50OyBpKyspIHtcclxuICAgICAgICB2YXIgaW50ZXJpb3JSaW5nID0gW107XHJcblxyXG4gICAgICAgIHZhciBpbnRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnRlcmlvclJpbmdDb3VudDsgaisrKVxyXG4gICAgICAgICAgICBpbnRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3MucHVzaChpbnRlcmlvclJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XHJcblxyXG4gICAgaWYgKHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDAgJiYgdmFsdWUuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMClcclxuICAgICAgICBwb2x5Z29uLmhhc1ogPSB2YWx1ZS5jb29yZGluYXRlc1swXVswXS5sZW5ndGggPiAyO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5ncy5wdXNoKFtdKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIDwgdmFsdWUuY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApXHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmV4dGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkR2VvSlNPTlBvaW50KHZhbHVlLmNvb3JkaW5hdGVzW2ldW2pdKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5nc1tpIC0gMV0ucHVzaChQb2ludC5fcmVhZEdlb0pTT05Qb2ludCh2YWx1ZS5jb29yZGluYXRlc1tpXVtqXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuUG9seWdvbiwgdHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LlBvbHlnb24sIGZhbHNlKSArIHRoaXMuX3RvSW5uZXJXa3QoKTtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLl90b0lubmVyV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGlubmVyV2t0ID0gJygoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlubmVyV2t0ICs9IHRoaXMuX2dldFdrdENvb3JkaW5hdGUodGhpcy5leHRlcmlvclJpbmdbaV0pICsgJywnO1xyXG5cclxuICAgIGlubmVyV2t0ID0gaW5uZXJXa3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgaW5uZXJXa3QgKz0gJyknO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpbm5lcldrdCArPSAnLCgnO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpbm5lcldrdCArPSB0aGlzLl9nZXRXa3RDb29yZGluYXRlKHRoaXMuaW50ZXJpb3JSaW5nc1tpXVtqXSkgKyAnLCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbm5lcldrdCA9IGlubmVyV2t0LnNsaWNlKDAsIC0xKTtcclxuICAgICAgICBpbm5lcldrdCArPSAnKSc7XHJcbiAgICB9XHJcblxyXG4gICAgaW5uZXJXa3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiBpbm5lcldrdDtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKHBhcmVudE9wdGlvbnMpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuUG9seWdvbiwgcGFyZW50T3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3a2Iud3JpdGVVSW50MzJMRSgxICsgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aCk7XHJcbiAgICAgICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdrYi53cml0ZVVJbnQzMkxFKDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRlcmlvclJpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5leHRlcmlvclJpbmdbaV0uX3dyaXRlV2tiUG9pbnQod2tiKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICB0aGlzLmludGVyaW9yUmluZ3NbaV1bal0uX3dyaXRlV2tiUG9pbnQod2tiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuUG9seWdvbiwgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQoMSArIHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRlcmlvclJpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJpb3JSaW5nW2ldLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJpb3JSaW5nc1tpXVtqXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZVNpemUgPSAxNjtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcblxyXG4gICAgdmFyIHNpemUgPSAxICsgNCArIDQ7XHJcblxyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA+IDApXHJcbiAgICAgICAgc2l6ZSArPSA0ICsgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCAqIGNvb3JkaW5hdGVTaXplKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkrKylcclxuICAgICAgICBzaXplICs9IDQgKyAodGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aCAqIGNvb3JkaW5hdGVTaXplKTtcclxuXHJcbiAgICByZXR1cm4gc2l6ZTtcclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uUG9seWdvbjtcclxuICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBleHRlcmlvclJpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICAgICAgZXh0ZXJpb3JSaW5nLnB1c2goW3RoaXMuZXh0ZXJpb3JSaW5nW2ldLngsIHRoaXMuZXh0ZXJpb3JSaW5nW2ldLnksIHRoaXMuZXh0ZXJpb3JSaW5nW2ldLnpdKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZXh0ZXJpb3JSaW5nLnB1c2goW3RoaXMuZXh0ZXJpb3JSaW5nW2ldLngsIHRoaXMuZXh0ZXJpb3JSaW5nW2ldLnldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaChleHRlcmlvclJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdmFyIGludGVyaW9yUmluZyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuaW50ZXJpb3JSaW5nc1tqXS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgICAgICAgICAgaW50ZXJpb3JSaW5nLnB1c2goW3RoaXMuaW50ZXJpb3JSaW5nc1tqXVtrXS54LCB0aGlzLmludGVyaW9yUmluZ3Nbal1ba10ueSwgdGhpcy5pbnRlcmlvclJpbmdzW2pdW2tdLnpdKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaW50ZXJpb3JSaW5nLnB1c2goW3RoaXMuaW50ZXJpb3JSaW5nc1tqXVtrXS54LCB0aGlzLmludGVyaW9yUmluZ3Nbal1ba10ueV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKGludGVyaW9yUmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgd2t0OiB7XHJcbiAgICAgICAgUG9pbnQ6ICdQT0lOVCcsXHJcbiAgICAgICAgTGluZVN0cmluZzogJ0xJTkVTVFJJTkcnLFxyXG4gICAgICAgIFBvbHlnb246ICdQT0xZR09OJyxcclxuICAgICAgICBNdWx0aVBvaW50OiAnTVVMVElQT0lOVCcsXHJcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiAnTVVMVElMSU5FU1RSSU5HJyxcclxuICAgICAgICBNdWx0aVBvbHlnb246ICdNVUxUSVBPTFlHT04nLFxyXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogJ0dFT01FVFJZQ09MTEVDVElPTidcclxuICAgIH0sXHJcbiAgICB3a2I6IHtcclxuICAgICAgICBQb2ludDogMSxcclxuICAgICAgICBMaW5lU3RyaW5nOiAyLFxyXG4gICAgICAgIFBvbHlnb246IDMsXHJcbiAgICAgICAgTXVsdGlQb2ludDogNCxcclxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IDUsXHJcbiAgICAgICAgTXVsdGlQb2x5Z29uOiA2LFxyXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogN1xyXG4gICAgfSxcclxuICAgIGdlb0pTT046IHtcclxuICAgICAgICBQb2ludDogJ1BvaW50JyxcclxuICAgICAgICBMaW5lU3RyaW5nOiAnTGluZVN0cmluZycsXHJcbiAgICAgICAgUG9seWdvbjogJ1BvbHlnb24nLFxyXG4gICAgICAgIE11bHRpUG9pbnQ6ICdNdWx0aVBvaW50JyxcclxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6ICdNdWx0aUxpbmVTdHJpbmcnLFxyXG4gICAgICAgIE11bHRpUG9seWdvbjogJ011bHRpUG9seWdvbicsXHJcbiAgICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG4gICAgfVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFdrdFBhcnNlcjtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG5cclxuZnVuY3Rpb24gV2t0UGFyc2VyKHZhbHVlKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxufVxyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgIHRoaXMuc2tpcFdoaXRlc3BhY2VzKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5wb3NpdGlvbikuaW5kZXhPZih0b2tlbnNbaV0pID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gdG9rZW5zW2ldLmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoUmVnZXggPSBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICB0aGlzLnNraXBXaGl0ZXNwYWNlcygpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gdGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5wb3NpdGlvbikubWF0Y2godG9rZW5zW2ldKTtcclxuXHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5pc01hdGNoID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgdGhpcy5za2lwV2hpdGVzcGFjZXMoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlLnN1YnN0cmluZyh0aGlzLnBvc2l0aW9uKS5pbmRleE9mKHRva2Vuc1tpXSkgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSB0b2tlbnNbaV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaFR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0gdGhpcy5tYXRjaChbVHlwZXMud2t0LlBvaW50LCBUeXBlcy53a3QuTGluZVN0cmluZywgVHlwZXMud2t0LlBvbHlnb24sIFR5cGVzLndrdC5NdWx0aVBvaW50LFxyXG4gICAgVHlwZXMud2t0Lk11bHRpTGluZVN0cmluZywgVHlwZXMud2t0Lk11bHRpUG9seWdvbiwgVHlwZXMud2t0Lkdlb21ldHJ5Q29sbGVjdGlvbl0pO1xyXG5cclxuICAgIGlmICghZ2VvbWV0cnlUeXBlKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZScpO1xyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeVR5cGU7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoRGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMubWF0Y2goWydaTScsICdaJywgJ00nXSk7XHJcblxyXG4gICAgc3dpdGNoIChkaW1lbnNpb24pIHtcclxuICAgICAgICBjYXNlICdaTSc6IHJldHVybiB7IGhhc1o6IHRydWUsIGhhc006IHRydWUgfTtcclxuICAgICAgICBjYXNlICdaJzogcmV0dXJuIHsgaGFzWjogdHJ1ZSwgaGFzTTogZmFsc2UgfTtcclxuICAgICAgICBjYXNlICdNJzogcmV0dXJuIHsgaGFzWjogZmFsc2UsIGhhc006IHRydWUgfTtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4geyBoYXNaOiBmYWxzZSwgaGFzTTogZmFsc2UgfTtcclxuICAgIH1cclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUuZXhwZWN0R3JvdXBTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5pc01hdGNoKFsnKCddKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGdyb3VwIHN0YXJ0Jyk7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLmV4cGVjdEdyb3VwRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzTWF0Y2goWycpJ10pKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZ3JvdXAgZW5kJyk7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgbWF0Y2g7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzWiAmJiBvcHRpb25zLmhhc00pXHJcbiAgICAgICAgbWF0Y2ggPSB0aGlzLm1hdGNoUmVnZXgoWy9eKFxcUyopXFxzKyhcXFMqKVxccysoXFxTKilcXHMrKFteXFxzLCldKikvXSk7XHJcbiAgICBlbHNlIGlmIChvcHRpb25zLmhhc1ogfHwgb3B0aW9ucy5oYXNNKVxyXG4gICAgICAgIG1hdGNoID0gdGhpcy5tYXRjaFJlZ2V4KFsvXihcXFMqKVxccysoXFxTKilcXHMrKFteXFxzLCldKikvXSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgbWF0Y2ggPSB0aGlzLm1hdGNoUmVnZXgoWy9eKFxcUyopXFxzKyhbXlxccywpXSopL10pO1xyXG5cclxuICAgIGlmICghbWF0Y2gpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBjb29yZGluYXRlcycpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc1ogJiYgb3B0aW9ucy5oYXNNKVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocGFyc2VGbG9hdChtYXRjaFsxXSksIHBhcnNlRmxvYXQobWF0Y2hbMl0pLCBwYXJzZUZsb2F0KG1hdGNoWzNdKSwgcGFyc2VGbG9hdChtYXRjaFs0XSkpO1xyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5oYXNaKVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocGFyc2VGbG9hdChtYXRjaFsxXSksIHBhcnNlRmxvYXQobWF0Y2hbMl0pLCBwYXJzZUZsb2F0KG1hdGNoWzNdKSk7XHJcbiAgICBlbHNlIGlmIChvcHRpb25zLmhhc00pXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwYXJzZUZsb2F0KG1hdGNoWzFdKSwgcGFyc2VGbG9hdChtYXRjaFsyXSksIHVuZGVmaW5lZCwgcGFyc2VGbG9hdChtYXRjaFszXSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocGFyc2VGbG9hdChtYXRjaFsxXSksIHBhcnNlRmxvYXQobWF0Y2hbMl0pKTtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2hDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgdmFyIHN0YXJ0c1dpdGhCcmFja2V0ID0gdGhpcy5pc01hdGNoKFsnKCddKTtcclxuXHJcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaCh0aGlzLm1hdGNoQ29vcmRpbmF0ZShvcHRpb25zKSk7XHJcblxyXG4gICAgICAgIGlmIChzdGFydHNXaXRoQnJhY2tldClcclxuICAgICAgICAgICAgdGhpcy5leHBlY3RHcm91cEVuZCgpO1xyXG4gICAgfSB3aGlsZSAodGhpcy5pc01hdGNoKFsnLCddKSk7XHJcblxyXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5za2lwV2hpdGVzcGFjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudmFsdWUubGVuZ3RoICYmIHRoaXMudmFsdWVbdGhpcy5wb3NpdGlvbl0gPT09ICcgJylcclxuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XHJcbn07XHJcbiIsImV4cG9ydHMuVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbmV4cG9ydHMuR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dlb21ldHJ5Jyk7XHJcbmV4cG9ydHMuUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbmV4cG9ydHMuTGluZVN0cmluZyA9IHJlcXVpcmUoJy4vbGluZXN0cmluZycpO1xyXG5leHBvcnRzLlBvbHlnb24gPSByZXF1aXJlKCcuL3BvbHlnb24nKTtcclxuZXhwb3J0cy5NdWx0aVBvaW50ID0gcmVxdWlyZSgnLi9tdWx0aXBvaW50Jyk7XHJcbmV4cG9ydHMuTXVsdGlMaW5lU3RyaW5nID0gcmVxdWlyZSgnLi9tdWx0aWxpbmVzdHJpbmcnKTtcclxuZXhwb3J0cy5NdWx0aVBvbHlnb24gPSByZXF1aXJlKCcuL211bHRpcG9seWdvbicpO1xyXG5leHBvcnRzLkdlb21ldHJ5Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZ2VvbWV0cnljb2xsZWN0aW9uJyk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgPDwgMSkgXiAodmFsdWUgPj4gMzEpO1xyXG4gICAgfSxcclxuICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA+PiAxKSBeICgtKHZhbHVlICYgMSkpO1xyXG4gICAgfVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGVidWdcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJnbG9iXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJsb2Rhc2gvX2Jhc2VJc05hdGl2ZVwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibHJ1LWNhY2hlXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtb21lbnRcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dWlkXCIpOzsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCIwODJiMzBmMDhjYjA5MjZlMGIyYlwiKSJdLCJzb3VyY2VSb290IjoiIn0=