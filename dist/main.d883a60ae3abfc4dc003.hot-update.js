exports.id = "main";
exports.ids = null;
exports.modules = {

/***/ "./node_modules/any-promise/index.js":
/*!*******************************************!*\
  !*** ./node_modules/any-promise/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./register */ "./node_modules/any-promise/register.js")().Promise


/***/ }),

/***/ "./node_modules/any-promise/loader.js":
/*!********************************************!*\
  !*** ./node_modules/any-promise/loader.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";

    // global key for user preferred registration
var REGISTRATION_KEY = '@@any-promise/REGISTRATION',
    // Prior registration (preferred or detected)
    registered = null

/**
 * Registers the given implementation.  An implementation must
 * be registered prior to any call to `require("any-promise")`,
 * typically on application load.
 *
 * If called with no arguments, will return registration in
 * following priority:
 *
 * For Node.js:
 *
 * 1. Previous registration
 * 2. global.Promise if node.js version >= 0.12
 * 3. Auto detected promise based on first sucessful require of
 *    known promise libraries. Note this is a last resort, as the
 *    loaded library is non-deterministic. node.js >= 0.12 will
 *    always use global.Promise over this priority list.
 * 4. Throws error.
 *
 * For Browser:
 *
 * 1. Previous registration
 * 2. window.Promise
 * 3. Throws error.
 *
 * Options:
 *
 * Promise: Desired Promise constructor
 * global: Boolean - Should the registration be cached in a global variable to
 * allow cross dependency/bundle registration?  (default true)
 */
module.exports = function(root, loadImplementation){
  return function register(implementation, opts){
    implementation = implementation || null
    opts = opts || {}
    // global registration unless explicitly  {global: false} in options (default true)
    var registerGlobal = opts.global !== false;

    // load any previous global registration
    if(registered === null && registerGlobal){
      registered = root[REGISTRATION_KEY] || null
    }

    if(registered !== null
        && implementation !== null
        && registered.implementation !== implementation){
      // Throw error if attempting to redefine implementation
      throw new Error('any-promise already defined as "'+registered.implementation+
        '".  You can only register an implementation before the first '+
        ' call to require("any-promise") and an implementation cannot be changed')
    }

    if(registered === null){
      // use provided implementation
      if(implementation !== null && typeof opts.Promise !== 'undefined'){
        registered = {
          Promise: opts.Promise,
          implementation: implementation
        }
      } else {
        // require implementation if implementation is specified but not provided
        registered = loadImplementation(implementation)
      }

      if(registerGlobal){
        // register preference globally in case multiple installations
        root[REGISTRATION_KEY] = registered
      }
    }

    return registered
  }
}


/***/ }),

/***/ "./node_modules/any-promise/register.js":
/*!**********************************************!*\
  !*** ./node_modules/any-promise/register.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./loader */ "./node_modules/any-promise/loader.js")(global, loadImplementation);

/**
 * Node.js version of loadImplementation.
 *
 * Requires the given implementation and returns the registration
 * containing {Promise, implementation}
 *
 * If implementation is undefined or global.Promise, loads it
 * Otherwise uses require
 */
function loadImplementation(implementation){
  var impl = null

  if(shouldPreferGlobalPromise(implementation)){
    // if no implementation or env specified use global.Promise
    impl = {
      Promise: global.Promise,
      implementation: 'global.Promise'
    }
  } else if(implementation){
    // if implementation specified, require it
    var lib = __webpack_require__("./node_modules/any-promise sync recursive")(implementation)
    impl = {
      Promise: lib.Promise || lib,
      implementation: implementation
    }
  } else {
    // try to auto detect implementation. This is non-deterministic
    // and should prefer other branches, but this is our last chance
    // to load something without throwing error
    impl = tryAutoDetect()
  }

  if(impl === null){
    throw new Error('Cannot find any-promise implementation nor'+
      ' global.Promise. You must install polyfill or call'+
      ' require("any-promise/register") with your preferred'+
      ' implementation, e.g. require("any-promise/register/bluebird")'+
      ' on application load prior to any require("any-promise").')
  }

  return impl
}

/**
 * Determines if the global.Promise should be preferred if an implementation
 * has not been registered.
 */
function shouldPreferGlobalPromise(implementation){
  if(implementation){
    return implementation === 'global.Promise'
  } else if(typeof global.Promise !== 'undefined'){
    // Load global promise if implementation not specified
    // Versions < 0.11 did not have global Promise
    // Do not use for version < 0.12 as version 0.11 contained buggy versions
    var version = (/v(\d+)\.(\d+)\.(\d+)/).exec(process.version)
    return !(version && +version[1] == 0 && +version[2] < 12)
  }

  // do not have global.Promise or another implementation was specified
  return false
}

/**
 * Look for common libs as last resort there is no guarantee that
 * this will return a desired implementation or even be deterministic.
 * The priority is also nearly arbitrary. We are only doing this
 * for older versions of Node.js <0.12 that do not have a reasonable
 * global.Promise implementation and we the user has not registered
 * the preference. This preserves the behavior of any-promise <= 0.1
 * and may be deprecated or removed in the future
 */
function tryAutoDetect(){
  var libs = [
      "es6-promise",
      "promise",
      "native-promise-only",
      "bluebird",
      "rsvp",
      "when",
      "q",
      "pinkie",
      "lie",
      "vow"]
  var i = 0, len = libs.length
  for(; i < len; i++){
    try {
      return loadImplementation(libs[i])
    } catch(e){}
  }
  return null
}


/***/ }),

/***/ "./node_modules/any-promise sync recursive":
/*!****************************************!*\
  !*** ./node_modules/any-promise/ sync ***!
  \****************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/any-promise sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/dottie/dottie.js":
/*!***************************************!*\
  !*** ./node_modules/dottie/dottie.js ***!
  \***************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(undefined) {
  var root = this;

  // Weird IE shit, objects do not have hasOwn, but the prototype does...
  var hasOwnProp = Object.prototype.hasOwnProperty;

  var reverseDupArray = function (array) {
    var result = new Array(array.length);
    var index  = array.length;
    var arrayMaxIndex = index - 1;

    while (index--) {
      result[arrayMaxIndex - index] = array[index];
    }

    return result;
  };

  var Dottie = function() {
    var args = Array.prototype.slice.call(arguments);

    if (args.length == 2) {
      return Dottie.find.apply(this, args);
    }
    return Dottie.transform.apply(this, args);
  };

  // Legacy syntax, changed syntax to have get/set be similar in arg order
  Dottie.find = function(path, object) {
    return Dottie.get(object, path);
  };

  // Dottie memoization flag
  Dottie.memoizePath = true;
  var memoized = {};

  // Traverse object according to path, return value if found - Return undefined if destination is unreachable
  Dottie.get = function(object, path, defaultVal) {
    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {
        return defaultVal;
    }

    var names;

    if (typeof path === "string") {
      if (Dottie.memoizePath) {
        if (memoized[path]) {
          names = memoized[path].slice(0);
        } else {
          names = path.split('.').reverse();
          memoized[path] = names.slice(0);
        }
      } else {
        names = path.split('.').reverse();
      }
    } else if (Array.isArray(path)) {
      names = reverseDupArray(path);
    }

    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);

    // Handle cases where accessing a childprop of a null value
    if (object === null && names.length) object = undefined;

    return (object === undefined ? defaultVal : object);
  };

  Dottie.exists = function(object, path) {
    return Dottie.get(object, path) !== undefined;
  };

  // Set nested value
  Dottie.set = function(object, path, value, options) {
    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;

    if (typeof current !== 'object') {
        throw new Error('Parent is not an object.');
    }

    for (var index = 0; index < length; index++) {
      piece = pieces[index];

      // Create namespace (object) where none exists.
      // If `force === true`, bruteforce the path without throwing errors.
      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || (typeof current[piece] !== 'object' && options && options.force === true)) {
        current[piece] = {};
      }

      if (index == (length - 1)) {
        // Set final value
        current[piece] = value;
      } else {
        // We do not overwrite existing path pieces by default
        if (typeof current[piece] !== 'object') {
          throw new Error('Target key "' + piece + '" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');
        }

        // Traverse next in path
        current = current[piece];
      }
    }

    // Is there any case when this is relevant? It's also the last line in the above for-loop
    current[piece] = value;
  };

  // Set default nested value
  Dottie['default'] = function(object, path, value) {
    if (Dottie.get(object, path) === undefined) {
      Dottie.set(object, path, value);
    }
  };

  // Transform unnested object with .-seperated keys into a nested object.
  Dottie.transform = function Dottie$transformfunction(object, options) {
    if (Array.isArray(object)) {
      return object.map(function(o) {
        return Dottie.transform(o, options);
      });
    }

    options = options || {};
    options.delimiter = options.delimiter || '.';

    var pieces
      , piecesLength
      , piece
      , current
      , transformed = {}
      , key
      , keys = Object.keys(object)
      , length = keys.length
      , i;

    for (i = 0; i < length; i++) {
      key = keys[i];

      if (key.indexOf(options.delimiter) !== -1) {
        pieces = key.split(options.delimiter);
        piecesLength = pieces.length;
        current = transformed;

        for (var index = 0; index < piecesLength; index++) {
          piece = pieces[index];
          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {
            current[piece] = {};
          }

          if (index == (piecesLength - 1)) {
            current[piece] = object[key];
          }

          current = current[piece];
          if (current === null) {
            break;
          }
        }
      } else {
        transformed[key] = object[key];
      }
    }

    return transformed;
  };

  Dottie.flatten = function(object, seperator) {
    if (typeof seperator === "undefined") seperator = '.';
    var flattened = {}
      , current
      , nested;

    for (var key in object) {
      if (hasOwnProp.call(object, key)) {
        current = object[key];
        if (Object.prototype.toString.call(current) === "[object Object]") {
          nested = Dottie.flatten(current, seperator);

          for (var _key in nested) {
            flattened[key+seperator+_key] = nested[_key];
          }
        } else {
          flattened[key] = current;
        }
      }
    }

    return flattened;
  };

  Dottie.paths = function(object, prefixes) {
    var paths = [];
    var value;
    var key;

    prefixes = prefixes || [];

    if (typeof object === 'object') {
      for (key in object) {
        value = object[key];

        if (typeof value === 'object' && value !== null) {
          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));
        } else {
          paths.push(prefixes.concat(key).join('.'));
        }
      }
    } else {
      throw new Error('Paths was called with non-object argument.');
    }

    return paths;
  };

  if ( true && module.exports) {
    exports = module.exports = Dottie;
  } else {
    root['Dottie'] = Dottie;
    root['Dot'] = Dottie; //BC

    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Dottie; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "./node_modules/inflection/lib/inflection.js":
/*!***************************************************!*\
  !*** ./node_modules/inflection/lib/inflection.js ***!
  \***************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root, factory ){
  if( true ){
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }else {}
}( this, function (){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    // 'access',
    'accommodation',
    'adulthood',
    'advertising',
    'advice',
    'aggression',
    'aid',
    'air',
    'aircraft',
    'alcohol',
    'anger',
    'applause',
    'arithmetic',
    // 'art',
    'assistance',
    'athletics',
    // 'attention',

    'bacon',
    'baggage',
    // 'ballet',
    // 'beauty',
    'beef',
    // 'beer',
    // 'behavior',
    'biology',
    // 'billiards',
    'blood',
    'botany',
    // 'bowels',
    'bread',
    // 'business',
    'butter',

    'carbon',
    'cardboard',
    'cash',
    'chalk',
    'chaos',
    'chess',
    'crossroads',
    'countryside',

    // 'damage',
    'dancing',
    // 'danger',
    'deer',
    // 'delight',
    // 'dessert',
    'dignity',
    'dirt',
    // 'distribution',
    'dust',

    'economics',
    'education',
    'electricity',
    // 'employment',
    // 'energy',
    'engineering',
    'enjoyment',
    // 'entertainment',
    'envy',
    'equipment',
    'ethics',
    'evidence',
    'evolution',

    // 'failure',
    // 'faith',
    'fame',
    'fiction',
    // 'fish',
    'flour',
    'flu',
    'food',
    // 'freedom',
    // 'fruit',
    'fuel',
    'fun',
    // 'funeral',
    'furniture',

    'gallows',
    'garbage',
    'garlic',
    // 'gas',
    'genetics',
    // 'glass',
    'gold',
    'golf',
    'gossip',
    'grammar',
    // 'grass',
    'gratitude',
    'grief',
    // 'ground',
    'guilt',
    'gymnastics',

    // 'hair',
    'happiness',
    'hardware',
    'harm',
    'hate',
    'hatred',
    'health',
    'heat',
    // 'height',
    'help',
    'homework',
    'honesty',
    'honey',
    'hospitality',
    'housework',
    'humour',
    'hunger',
    'hydrogen',

    'ice',
    'importance',
    'inflation',
    'information',
    // 'injustice',
    'innocence',
    // 'intelligence',
    'iron',
    'irony',

    'jam',
    // 'jealousy',
    // 'jelly',
    'jewelry',
    // 'joy',
    'judo',
    // 'juice',
    // 'justice',

    'karate',
    // 'kindness',
    'knowledge',

    // 'labour',
    'lack',
    // 'land',
    'laughter',
    'lava',
    'leather',
    'leisure',
    'lightning',
    'linguine',
    'linguini',
    'linguistics',
    'literature',
    'litter',
    'livestock',
    'logic',
    'loneliness',
    // 'love',
    'luck',
    'luggage',

    'macaroni',
    'machinery',
    'magic',
    // 'mail',
    'management',
    'mankind',
    'marble',
    'mathematics',
    'mayonnaise',
    'measles',
    // 'meat',
    // 'metal',
    'methane',
    'milk',
    'minus',
    'money',
    // 'moose',
    'mud',
    'music',
    'mumps',

    'nature',
    'news',
    'nitrogen',
    'nonsense',
    'nurture',
    'nutrition',

    'obedience',
    'obesity',
    // 'oil',
    'oxygen',

    // 'paper',
    // 'passion',
    'pasta',
    'patience',
    // 'permission',
    'physics',
    'poetry',
    'pollution',
    'poverty',
    // 'power',
    'pride',
    // 'production',
    // 'progress',
    // 'pronunciation',
    'psychology',
    'publicity',
    'punctuation',

    // 'quality',
    // 'quantity',
    'quartz',

    'racism',
    // 'rain',
    // 'recreation',
    'relaxation',
    'reliability',
    'research',
    'respect',
    'revenge',
    'rice',
    'rubbish',
    'rum',

    'safety',
    // 'salad',
    // 'salt',
    // 'sand',
    // 'satire',
    'scenery',
    'seafood',
    'seaside',
    'series',
    'shame',
    'sheep',
    'shopping',
    // 'silence',
    'sleep',
    // 'slang'
    'smoke',
    'smoking',
    'snow',
    'soap',
    'software',
    'soil',
    // 'sorrow',
    // 'soup',
    'spaghetti',
    // 'speed',
    'species',
    // 'spelling',
    // 'sport',
    'steam',
    // 'strength',
    'stuff',
    'stupidity',
    // 'success',
    // 'sugar',
    'sunshine',
    'symmetry',

    // 'tea',
    'tennis',
    'thirst',
    'thunder',
    'timber',
    // 'time',
    // 'toast',
    // 'tolerance',
    // 'trade',
    'traffic',
    'transportation',
    // 'travel',
    'trust',

    // 'understanding',
    'underwear',
    'unemployment',
    'unity',
    // 'usage',

    'validity',
    'veal',
    'vegetation',
    'vegetarianism',
    'vengeance',
    'violence',
    // 'vision',
    'vitality',

    'warmth',
    // 'water',
    'wealth',
    'weather',
    // 'weight',
    'welfare',
    'wheat',
    // 'whiskey',
    // 'width',
    'wildlife',
    // 'wine',
    'wisdom',
    // 'wood',
    // 'wool',
    // 'work',

    // 'yeast',
    'yoga',

    'zinc',
    'zoology'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */

  var regex = {
    plural : {
      men       : new RegExp( '^(m|wom)en$'                    , 'gi' ),
      people    : new RegExp( '(pe)ople$'                      , 'gi' ),
      children  : new RegExp( '(child)ren$'                    , 'gi' ),
      tia       : new RegExp( '([ti])a$'                       , 'gi' ),
      analyses  : new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ),
      hives     : new RegExp( '(hi|ti)ves$'                    , 'gi' ),
      curves    : new RegExp( '(curve)s$'                      , 'gi' ),
      lrves     : new RegExp( '([lr])ves$'                     , 'gi' ),
      aves      : new RegExp( '([a])ves$'                      , 'gi' ),
      foves     : new RegExp( '([^fo])ves$'                    , 'gi' ),
      movies    : new RegExp( '(m)ovies$'                      , 'gi' ),
      aeiouyies : new RegExp( '([^aeiouy]|qu)ies$'             , 'gi' ),
      series    : new RegExp( '(s)eries$'                      , 'gi' ),
      xes       : new RegExp( '(x|ch|ss|sh)es$'                , 'gi' ),
      mice      : new RegExp( '([m|l])ice$'                    , 'gi' ),
      buses     : new RegExp( '(bus)es$'                       , 'gi' ),
      oes       : new RegExp( '(o)es$'                         , 'gi' ),
      shoes     : new RegExp( '(shoe)s$'                       , 'gi' ),
      crises    : new RegExp( '(cris|ax|test)es$'              , 'gi' ),
      octopi    : new RegExp( '(octop|vir)i$'                  , 'gi' ),
      aliases   : new RegExp( '(alias|canvas|status|campus)es$', 'gi' ),
      summonses : new RegExp( '^(summons)es$'                  , 'gi' ),
      oxen      : new RegExp( '^(ox)en'                        , 'gi' ),
      matrices  : new RegExp( '(matr)ices$'                    , 'gi' ),
      vertices  : new RegExp( '(vert|ind)ices$'                , 'gi' ),
      feet      : new RegExp( '^feet$'                         , 'gi' ),
      teeth     : new RegExp( '^teeth$'                        , 'gi' ),
      geese     : new RegExp( '^geese$'                        , 'gi' ),
      quizzes   : new RegExp( '(quiz)zes$'                     , 'gi' ),
      whereases : new RegExp( '^(whereas)es$'                  , 'gi' ),
      criteria  : new RegExp( '^(criteri)a$'                   , 'gi' ),
      genera    : new RegExp( '^genera$'                       , 'gi' ),
      ss        : new RegExp( 'ss$'                            , 'gi' ),
      s         : new RegExp( 's$'                             , 'gi' )
    },

    singular : {
      man       : new RegExp( '^(m|wom)an$'                  , 'gi' ),
      person    : new RegExp( '(pe)rson$'                    , 'gi' ),
      child     : new RegExp( '(child)$'                     , 'gi' ),
      ox        : new RegExp( '^(ox)$'                       , 'gi' ),
      axis      : new RegExp( '(ax|test)is$'                 , 'gi' ),
      octopus   : new RegExp( '(octop|vir)us$'               , 'gi' ),
      alias     : new RegExp( '(alias|status|canvas|campus)$', 'gi' ),
      summons   : new RegExp( '^(summons)$'                  , 'gi' ),
      bus       : new RegExp( '(bu)s$'                       , 'gi' ),
      buffalo   : new RegExp( '(buffal|tomat|potat)o$'       , 'gi' ),
      tium      : new RegExp( '([ti])um$'                    , 'gi' ),
      sis       : new RegExp( 'sis$'                         , 'gi' ),
      ffe       : new RegExp( '(?:([^f])fe|([lr])f)$'        , 'gi' ),
      hive      : new RegExp( '(hi|ti)ve$'                   , 'gi' ),
      aeiouyy   : new RegExp( '([^aeiouy]|qu)y$'             , 'gi' ),
      x         : new RegExp( '(x|ch|ss|sh)$'                , 'gi' ),
      matrix    : new RegExp( '(matr)ix$'                    , 'gi' ),
      vertex    : new RegExp( '(vert|ind)ex$'                , 'gi' ),
      mouse     : new RegExp( '([m|l])ouse$'                 , 'gi' ),
      foot      : new RegExp( '^foot$'                       , 'gi' ),
      tooth     : new RegExp( '^tooth$'                      , 'gi' ),
      goose     : new RegExp( '^goose$'                      , 'gi' ),
      quiz      : new RegExp( '(quiz)$'                      , 'gi' ),
      whereas   : new RegExp( '^(whereas)$'                  , 'gi' ),
      criterion : new RegExp( '^(criteri)on$'                , 'gi' ),
      genus     : new RegExp( '^genus$'                      , 'gi' ),
      s         : new RegExp( 's$'                           , 'gi' ),
      common    : new RegExp( '$'                            , 'gi' )
    }
  };

  var plural_rules = [

    // do not replace if its already a plural word
    [ regex.plural.men       ],
    [ regex.plural.people    ],
    [ regex.plural.children  ],
    [ regex.plural.tia       ],
    [ regex.plural.analyses  ],
    [ regex.plural.hives     ],
    [ regex.plural.curves    ],
    [ regex.plural.lrves     ],
    [ regex.plural.foves     ],
    [ regex.plural.aeiouyies ],
    [ regex.plural.series    ],
    [ regex.plural.movies    ],
    [ regex.plural.xes       ],
    [ regex.plural.mice      ],
    [ regex.plural.buses     ],
    [ regex.plural.oes       ],
    [ regex.plural.shoes     ],
    [ regex.plural.crises    ],
    [ regex.plural.octopi    ],
    [ regex.plural.aliases   ],
    [ regex.plural.summonses ],
    [ regex.plural.oxen      ],
    [ regex.plural.matrices  ],
    [ regex.plural.feet      ],
    [ regex.plural.teeth     ],
    [ regex.plural.geese     ],
    [ regex.plural.quizzes   ],
    [ regex.plural.whereases ],
    [ regex.plural.criteria  ],
    [ regex.plural.genera    ],

    // original rule
    [ regex.singular.man      , '$1en' ],
    [ regex.singular.person   , '$1ople' ],
    [ regex.singular.child    , '$1ren' ],
    [ regex.singular.ox       , '$1en' ],
    [ regex.singular.axis     , '$1es' ],
    [ regex.singular.octopus  , '$1i' ],
    [ regex.singular.alias    , '$1es' ],
    [ regex.singular.summons  , '$1es' ],
    [ regex.singular.bus      , '$1ses' ],
    [ regex.singular.buffalo  , '$1oes' ],
    [ regex.singular.tium     , '$1a' ],
    [ regex.singular.sis      , 'ses' ],
    [ regex.singular.ffe      , '$1$2ves' ],
    [ regex.singular.hive     , '$1ves' ],
    [ regex.singular.aeiouyy  , '$1ies' ],
    [ regex.singular.matrix   , '$1ices' ],
    [ regex.singular.vertex   , '$1ices' ],
    [ regex.singular.x        , '$1es' ],
    [ regex.singular.mouse    , '$1ice' ],
    [ regex.singular.foot     , 'feet' ],
    [ regex.singular.tooth    , 'teeth' ],
    [ regex.singular.goose    , 'geese' ],
    [ regex.singular.quiz     , '$1zes' ],
    [ regex.singular.whereas  , '$1es' ],
    [ regex.singular.criterion, '$1a' ],
    [ regex.singular.genus    , 'genera' ],

    [ regex.singular.s     , 's' ],
    [ regex.singular.common, 's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ regex.singular.man     ],
    [ regex.singular.person  ],
    [ regex.singular.child   ],
    [ regex.singular.ox      ],
    [ regex.singular.axis    ],
    [ regex.singular.octopus ],
    [ regex.singular.alias   ],
    [ regex.singular.summons ],
    [ regex.singular.bus     ],
    [ regex.singular.buffalo ],
    [ regex.singular.tium    ],
    [ regex.singular.sis     ],
    [ regex.singular.ffe     ],
    [ regex.singular.hive    ],
    [ regex.singular.aeiouyy ],
    [ regex.singular.x       ],
    [ regex.singular.matrix  ],
    [ regex.singular.mouse   ],
    [ regex.singular.foot    ],
    [ regex.singular.tooth   ],
    [ regex.singular.goose   ],
    [ regex.singular.quiz    ],
    [ regex.singular.whereas ],
    [ regex.singular.criterion ],
    [ regex.singular.genus ],

    // original rule
    [ regex.plural.men      , '$1an' ],
    [ regex.plural.people   , '$1rson' ],
    [ regex.plural.children , '$1' ],
    [ regex.plural.genera   , 'genus'],
    [ regex.plural.criteria , '$1on'],
    [ regex.plural.tia      , '$1um' ],
    [ regex.plural.analyses , '$1$2sis' ],
    [ regex.plural.hives    , '$1ve' ],
    [ regex.plural.curves   , '$1' ],
    [ regex.plural.lrves    , '$1f' ],
    [ regex.plural.aves     , '$1ve' ],
    [ regex.plural.foves    , '$1fe' ],
    [ regex.plural.movies   , '$1ovie' ],
    [ regex.plural.aeiouyies, '$1y' ],
    [ regex.plural.series   , '$1eries' ],
    [ regex.plural.xes      , '$1' ],
    [ regex.plural.mice     , '$1ouse' ],
    [ regex.plural.buses    , '$1' ],
    [ regex.plural.oes      , '$1' ],
    [ regex.plural.shoes    , '$1' ],
    [ regex.plural.crises   , '$1is' ],
    [ regex.plural.octopi   , '$1us' ],
    [ regex.plural.aliases  , '$1' ],
    [ regex.plural.summonses, '$1' ],
    [ regex.plural.oxen     , '$1' ],
    [ regex.plural.matrices , '$1ix' ],
    [ regex.plural.vertices , '$1ex' ],
    [ regex.plural.feet     , 'foot' ],
    [ regex.plural.teeth    , 'tooth' ],
    [ regex.plural.geese    , 'goose' ],
    [ regex.plural.quizzes  , '$1' ],
    [ regex.plural.whereases, '$1' ],

    [ regex.plural.ss, 'ss' ],
    [ regex.plural.s , '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function ( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} from_index Starts checking from this position in the Array.(optional)
   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function ( arr, item, from_index, compare_func ){
      if( !from_index ){
        from_index = -1;
      }

      var index = -1;
      var i     = from_index;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },


  /**
   * This function will pluralize or singularlize a String appropriately based on an integer value
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Number} count The number to base pluralization off of.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} English language nouns are returned in the plural or singular form based on the count.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.inflect( 'people' 1 ); // === 'person'
   *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
   *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
   *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
   *     inflection.inflect( 'person', 2 ); // === 'people'
   *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
   *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
   *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
   */
    inflect : function ( str, count, singular, plural ){
      count = parseInt( count, 10 );

      if( isNaN( count )) return str;

      if( count === 0 || count > 1 ){
        return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
      }else{
        return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
      }
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, low_first_letter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = low_first_letter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, all_upper_case ){
      if( all_upper_case && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function ( str, low_first_letter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !low_first_letter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function replaces underscores with dashes in the string.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underscores with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ' );
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function ( str, drop_id_ubar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( inflector.hasOwnProperty( method )){
          str = inflector[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.12.0';

  return inflector;
}));


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/retry-as-promised/index.js":
/*!*************************************************!*\
  !*** ./node_modules/retry-as-promised/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Promise = __webpack_require__(/*! any-promise */ "./node_modules/any-promise/index.js");
var util = __webpack_require__(/*! util */ "util");
var format = util.format;

function TimeoutError(message, err) {
  Error.call(this);
  Error.captureStackTrace(this, TimeoutError);
  this.name = 'TimeoutError';
  this.message = message;
  this.previous = err;
}

util.inherits(TimeoutError, Error);

function matches(match, err) {
  if (match === true) return true;
  if (typeof match === 'function') {
    try {
      if (err instanceof match) return true;
    } catch (_) {
      return !!match(err);
    }
  }
  if (match === err.toString()) return true;
  if (match === err.message) return true;
  return match instanceof RegExp
    && (match.test(err.message) || match.test(err.toString()));
}

module.exports = function retryAsPromised(callback, options) {
  if (!callback || !options) {
    throw new Error(
      'retry-as-promised must be passed a callback and a options set or a number'
    );
  }

  if (typeof options === 'number') {
    options = {
      max: options
    };
  }

  // Super cheap clone
  options = {
    $current: options.$current || 1,
    max: options.max,
    timeout: options.timeout || undefined,
    match: options.match || [],
    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,
    backoffExponent: options.backoffExponent || 1.1,
    report: options.report || function () {},
    name: options.name || callback.name || 'unknown'
  };

  if (!Array.isArray(options.match)) options.match = [options.match];
  options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);

  return new Promise(function(resolve, reject) {
    var timeout, backoffTimeout, lastError;

    if (options.timeout) {
      timeout = setTimeout(function() {
        if (backoffTimeout) clearTimeout(backoffTimeout);
        reject(new TimeoutError(options.name + ' timed out', lastError));
      }, options.timeout);
    }

    Promise.resolve(callback({ current: options.$current }))
      .then(resolve)
      .then(function() {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);
      })
      .catch(function(err) {
        if (timeout) clearTimeout(timeout);
        if (backoffTimeout) clearTimeout(backoffTimeout);

        lastError = err;
        options.report((err && err.toString()) || err, options);

        // Should not retry if max has been reached
        var shouldRetry = options.$current < options.max;
        if (!shouldRetry) return reject(err);
        shouldRetry = options.match.length === 0 || options.match.some(function (match) {
          return matches(match, err)
        });
        if (!shouldRetry) return reject(err);

        var retryDelay = Math.pow(
          options.backoffBase,
          Math.pow(options.backoffExponent, options.$current - 1)
        );

        // Do some accounting
        options.$current++;
        options.report(format('Retrying %s (%s)', options.name, options.$current), options);

        if (retryDelay) {
          // Use backoff function to ease retry rate
          options.report(format('Delaying retry of %s by %s', options.name, retryDelay), options);
          backoffTimeout = setTimeout(function() {
            retryAsPromised(callback, options)
              .then(resolve)
              .catch(reject);
          }, retryDelay);
        } else {
          retryAsPromised(callback, options)
            .then(resolve)
            .catch(reject);
        }
      });
  });
};

module.exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "lru-cache")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const {re, t} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js")
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js"),
  compareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js").rcompareIdentifiers,
  parse: __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js"),
  valid: __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js"),
  clean: __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js"),
  inc: __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js"),
  diff: __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js"),
  major: __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js"),
  minor: __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js"),
  patch: __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js"),
  prerelease: __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js"),
  compare: __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js"),
  rcompare: __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js"),
  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js"),
  compareBuild: __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js"),
  sort: __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js"),
  rsort: __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js"),
  gt: __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js"),
  lt: __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js"),
  eq: __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js"),
  neq: __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js"),
  gte: __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js"),
  lte: __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js"),
  cmp: __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js"),
  coerce: __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js"),
  Comparator: __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js"),
  Range: __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js"),
  satisfies: __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js"),
  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js"),
  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js"),
  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js"),
  minVersion: __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js"),
  validRange: __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js"),
  outside: __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js"),
  gtr: __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js"),
  ltr: __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js"),
  intersects: __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js"),
  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js"),
  subset: __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js"),
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js")
const {ANY} = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/sequelize-pool/lib/AggregateError.js":
/*!***********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/AggregateError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregateError = void 0;
class AggregateError extends Error {
    constructor(errors) {
        super();
        this.errors = errors;
        this.name = 'AggregateError';
    }
    toString() {
        const message = `AggregateError of:\n${this.errors
            .map((error) => error === this
            ? '[Circular AggregateError]'
            : error instanceof AggregateError
                ? String(error).replace(/\n$/, '').replace(/^/gm, '  ')
                : String(error).replace(/^/gm, '    ').substring(2))
            .join('\n')}\n`;
        return message;
    }
}
exports.AggregateError = AggregateError;
//# sourceMappingURL=AggregateError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Deferred.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Deferred.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
const TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = resolve;
        });
    }
    registerTimeout(timeoutInMillis, callback) {
        if (this._timeout)
            return;
        this._timeout = setTimeout(() => {
            callback();
            this.reject(new TimeoutError_1.TimeoutError('Operation timeout'));
        }, timeoutInMillis);
    }
    _clearTimeout() {
        if (!this._timeout)
            return;
        clearTimeout(this._timeout);
    }
    resolve(value) {
        this._clearTimeout();
        this._resolve(value);
    }
    reject(error) {
        this._clearTimeout();
        this._reject(error);
    }
    promise() {
        return this._promise;
    }
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/Pool.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/Pool.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pool = void 0;
const Deferred_1 = __webpack_require__(/*! ./Deferred */ "./node_modules/sequelize-pool/lib/Deferred.js");
const AggregateError_1 = __webpack_require__(/*! ./AggregateError */ "./node_modules/sequelize-pool/lib/AggregateError.js");
class Pool {
    constructor(factory) {
        this.log = false;
        if (!factory.create) {
            throw new Error('create function is required');
        }
        if (!factory.destroy) {
            throw new Error('destroy function is required');
        }
        if (!factory.validate) {
            throw new Error('validate function is required');
        }
        if (typeof factory.min !== 'number' ||
            factory.min < 0 ||
            factory.min !== Math.round(factory.min)) {
            throw new Error('min must be an integer >= 0');
        }
        if (typeof factory.max !== 'number' ||
            factory.max <= 0 ||
            factory.max !== Math.round(factory.max)) {
            throw new Error('max must be an integer > 0');
        }
        if (factory.min > factory.max) {
            throw new Error('max is smaller than min');
        }
        if (factory.maxUses !== undefined &&
            (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {
            throw new Error('maxUses must be an integer >= 0');
        }
        this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;
        this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;
        this.reapIntervalMillis = factory.reapIntervalMillis || 1000;
        this.maxUsesPerResource = factory.maxUses || Infinity;
        this.log = factory.log || false;
        this._factory = factory;
        this._count = 0;
        this._draining = false;
        this._pendingAcquires = [];
        this._inUseObjects = [];
        this._availableObjects = [];
        this._removeIdleScheduled = false;
    }
    get size() {
        return this._count;
    }
    get name() {
        return this._factory.name;
    }
    get available() {
        return this._availableObjects.length;
    }
    get using() {
        return this._inUseObjects.length;
    }
    get waiting() {
        return this._pendingAcquires.length;
    }
    get maxSize() {
        return this._factory.max;
    }
    get minSize() {
        return this._factory.min;
    }
    _log(message, level) {
        if (typeof this.log === 'function') {
            this.log(message, level);
        }
        else if (this.log) {
            console.log(`${level.toUpperCase()} pool ${this.name || ''} - ${message}`);
        }
    }
    _removeIdle() {
        const toRemove = [];
        const now = Date.now();
        let i;
        let available = this._availableObjects.length;
        const maxRemovable = this.size - this.minSize;
        let timeout;
        this._removeIdleScheduled = false;
        for (i = 0; i < available && maxRemovable > toRemove.length; i++) {
            timeout = this._availableObjects[i].timeout;
            if (now >= timeout) {
                this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');
                toRemove.push(this._availableObjects[i].resource);
            }
        }
        toRemove.forEach(this.destroy, this);
        available = this._availableObjects.length;
        if (available > 0) {
            this._log('this._availableObjects.length=' + available, 'verbose');
            this._scheduleRemoveIdle();
        }
        else {
            this._log('removeIdle() all objects removed', 'verbose');
        }
    }
    _scheduleRemoveIdle() {
        if (!this._removeIdleScheduled) {
            this._removeIdleScheduled = true;
            this._removeIdleTimer = setTimeout(() => {
                this._removeIdle();
            }, this.reapIntervalMillis);
        }
    }
    _dispense() {
        let wrappedResource = null;
        const waitingCount = this._pendingAcquires.length;
        this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, 'info');
        if (waitingCount < 1) {
            return;
        }
        while (this._availableObjects.length > 0) {
            this._log('dispense() - reusing obj', 'verbose');
            wrappedResource = this._availableObjects[this._availableObjects.length - 1];
            if (!this._factory.validate(wrappedResource.resource)) {
                this.destroy(wrappedResource.resource);
                continue;
            }
            this._availableObjects.pop();
            this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);
            const deferred = this._pendingAcquires.shift();
            return deferred.resolve(wrappedResource.resource);
        }
        if (this.size < this.maxSize) {
            this._createResource();
        }
    }
    _createResource() {
        this._count += 1;
        this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`, 'verbose');
        this._factory
            .create()
            .then((resource) => {
            const deferred = this._pendingAcquires.shift();
            if (deferred) {
                this._addResourceToInUseObjects(resource, 0);
                deferred.resolve(resource);
            }
            else {
                this._addResourceToAvailableObjects(resource, 0);
            }
        })
            .catch((error) => {
            const deferred = this._pendingAcquires.shift();
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            if (deferred) {
                deferred.reject(error);
            }
            process.nextTick(() => {
                this._dispense();
            });
        });
    }
    _addResourceToAvailableObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
            timeout: Date.now() + this.idleTimeoutMillis,
        };
        this._availableObjects.push(wrappedResource);
        this._dispense();
        this._scheduleRemoveIdle();
    }
    _addResourceToInUseObjects(resource, useCount) {
        const wrappedResource = {
            resource: resource,
            useCount: useCount,
        };
        this._inUseObjects.push(wrappedResource);
    }
    _ensureMinimum() {
        let i, diff;
        if (!this._draining && this.size < this.minSize) {
            diff = this.minSize - this.size;
            for (i = 0; i < diff; i++) {
                this._createResource();
            }
        }
    }
    acquire() {
        if (this._draining) {
            return Promise.reject(new Error('pool is draining and cannot accept work'));
        }
        const deferred = new Deferred_1.Deferred();
        deferred.registerTimeout(this.acquireTimeoutMillis, () => {
            this._pendingAcquires = this._pendingAcquires.filter((pending) => pending !== deferred);
        });
        this._pendingAcquires.push(deferred);
        this._dispense();
        return deferred.promise();
    }
    release(resource) {
        if (this._availableObjects.some((resourceWithTimeout) => resourceWithTimeout.resource === resource)) {
            this._log('release called twice for the same resource: ' + new Error().stack, 'error');
            return;
        }
        const index = this._inUseObjects.findIndex((wrappedResource) => wrappedResource.resource === resource);
        if (index < 0) {
            this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');
            return;
        }
        const wrappedResource = this._inUseObjects[index];
        wrappedResource.useCount += 1;
        if (wrappedResource.useCount >= this.maxUsesPerResource) {
            this._log('release() destroying obj - useCount:' +
                wrappedResource.useCount +
                ' maxUsesPerResource:' +
                this.maxUsesPerResource, 'verbose');
            this.destroy(wrappedResource.resource);
            this._dispense();
        }
        else {
            this._inUseObjects.splice(index, 1);
            this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);
        }
    }
    destroy(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const available = this._availableObjects.length;
            const using = this._inUseObjects.length;
            this._availableObjects = this._availableObjects.filter((object) => object.resource !== resource);
            this._inUseObjects = this._inUseObjects.filter((object) => object.resource !== resource);
            if (available === this._availableObjects.length &&
                using === this._inUseObjects.length) {
                this._ensureMinimum();
                return;
            }
            this._count -= 1;
            if (this._count < 0)
                this._count = 0;
            try {
                yield this._factory.destroy(resource);
            }
            finally {
                this._ensureMinimum();
            }
        });
    }
    drain() {
        this._log('draining', 'info');
        this._draining = true;
        const check = (callback) => {
            if (this._pendingAcquires.length > 0) {
                this._dispense();
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            if (this._availableObjects.length !== this._count) {
                setTimeout(() => {
                    check(callback);
                }, 100);
                return;
            }
            callback();
        };
        return new Promise((resolve) => check(resolve));
    }
    destroyAllNow() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log('force destroying all objects', 'info');
            this._removeIdleScheduled = false;
            clearTimeout(this._removeIdleTimer);
            const resources = this._availableObjects.map((resource) => resource.resource);
            const errors = [];
            for (const resource of resources) {
                try {
                    yield this.destroy(resource);
                }
                catch (ex) {
                    this._log('Error destroying resource: ' + ex.stack, 'error');
                    errors.push(ex);
                }
            }
            if (errors.length > 0) {
                throw new AggregateError_1.AggregateError(errors);
            }
        });
    }
}
exports.Pool = Pool;
//# sourceMappingURL=Pool.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/TimeoutError.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/TimeoutError.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = void 0;
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./node_modules/sequelize-pool/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize-pool/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var TimeoutError_1 = __webpack_require__(/*! ./TimeoutError */ "./node_modules/sequelize-pool/lib/TimeoutError.js");
Object.defineProperty(exports, "TimeoutError", ({ enumerable: true, get: function () { return TimeoutError_1.TimeoutError; } }));
var Pool_1 = __webpack_require__(/*! ./Pool */ "./node_modules/sequelize-pool/lib/Pool.js");
Object.defineProperty(exports, "Pool", ({ enumerable: true, get: function () { return Pool_1.Pool; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferAlias = void 0;
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
/**
 * Pre conform includes, so that "as" value can be inferred from source
 */
function inferAlias(options, source) {
    options = Object.assign({}, options);
    if (!options.include) {
        return options;
    }
    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
        options.include = [options.include];
    }
    else if (!options.include.length) {
        delete options.include;
        return options;
    }
    // convert all included elements to { model: Model } form
    options.include = options.include.map((include) => {
        include = inferAliasForInclude(include, source);
        return include;
    });
    return options;
}
exports.inferAlias = inferAlias;
/**
 * Pre conform include, so that alias ("as") value can be inferred from source class
 */
function inferAliasForInclude(include, source) {
    const hasModelOptionWithoutAsOption = !!(include.model && !include.as);
    const hasIncludeOptions = !!include.include;
    const isConstructorFn = include instanceof Function;
    if (isConstructorFn || hasModelOptionWithoutAsOption) {
        if (isConstructorFn) {
            include = { model: include };
        }
        const targetPrototype = source.prototype || source;
        const relatedClass = include.model;
        const associations = association_service_1.getAssociationsByRelation(targetPrototype, relatedClass);
        if (associations.length > 0) {
            if (associations.length > 1) {
                throw new Error(`Alias cannot be inferred: "${source.name}" has multiple ` +
                    `relations with "${include.model.name}"`);
            }
            include.as = associations[0].getAs();
        }
    }
    if (!isConstructorFn && hasIncludeOptions) {
        include = inferAlias(include, include.model);
    }
    return include;
}
//# sourceMappingURL=alias-inference-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToManyAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToManyAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsToMany;
    }
    getSequelizeOptions(model, sequelize) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        const throughOptions = this.getThroughOptions(sequelize);
        const throughModel = typeof throughOptions === 'object' && typeof throughOptions.model !== "string" ? throughOptions.model : undefined;
        options.through = throughOptions;
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, throughModel, this.options.foreignKey);
        options.otherKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, throughModel, this.options.otherKey);
        return options;
    }
    getThroughOptions(sequelize) {
        const through = this.options.through;
        const throughModel = typeof through === 'object' ? through.model : through;
        const throughOptions = typeof through === 'object' ? Object.assign({}, through) : {};
        if (typeof throughModel === 'function') {
            const throughModelClass = sequelize.model(throughModel());
            if (!throughModelClass.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(throughModelClass, 'Association cannot be resolved.');
            }
            throughOptions.model = throughModelClass;
        }
        else {
            return throughModel;
        }
        return throughOptions;
    }
}
exports.BelongsToManyAssociation = BelongsToManyAssociation;
//# sourceMappingURL=belongs-to-many-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=belongs-to-many-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToMany = void 0;
const belongs_to_many_association_1 = __webpack_require__(/*! ./belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsToMany(associatedClassGetter, throughOrOptions, foreignKey, otherKey) {
    return (target, propertyName) => {
        let options = { foreignKey, otherKey };
        if (typeof throughOrOptions === 'string' ||
            typeof throughOrOptions === 'function') {
            options.through = throughOrOptions;
        }
        else {
            options = Object.assign({}, throughOrOptions);
        }
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_many_association_1.BelongsToManyAssociation(associatedClassGetter, options));
    };
}
exports.BelongsToMany = BelongsToMany;
//# sourceMappingURL=belongs-to-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsToAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
class BelongsToAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options) {
        super(associatedClassGetter, options);
        this.options = options;
    }
    getAssociation() {
        return association_1.Association.BelongsTo;
    }
    getSequelizeOptions(model) {
        const associatedClass = this.getAssociatedClass();
        const foreignKey = foreign_key_service_1.getForeignKeyOptions(associatedClass, model, this.options.foreignKey);
        return Object.assign(Object.assign({}, this.options), { foreignKey });
    }
}
exports.BelongsToAssociation = BelongsToAssociation;
//# sourceMappingURL=belongs-to-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BelongsTo = void 0;
const belongs_to_association_1 = __webpack_require__(/*! ./belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
function BelongsTo(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new belongs_to_association_1.BelongsToAssociation(associatedClassGetter, options));
    };
}
exports.BelongsTo = BelongsTo;
//# sourceMappingURL=belongs-to.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getForeignKeys = exports.addForeignKey = exports.getForeignKeyOptions = void 0;
const FOREIGN_KEYS_KEY = 'sequelize:foreignKeys';
function getForeignKeyOptions(relatedClass, classWithForeignKey, foreignKey) {
    let foreignKeyOptions = {};
    if (typeof foreignKey === 'string') {
        foreignKeyOptions.name = foreignKey;
    }
    else if (foreignKey && typeof foreignKey === 'object') {
        foreignKeyOptions = Object.assign({}, foreignKey);
    }
    if (!foreignKeyOptions.name && classWithForeignKey) {
        const foreignKeys = getForeignKeys(classWithForeignKey.prototype) || [];
        for (const key of foreignKeys) {
            if (key.relatedClassGetter() === relatedClass ||
                relatedClass.prototype instanceof key.relatedClassGetter()) {
                foreignKeyOptions.name = key.foreignKey;
                break;
            }
        }
    }
    if (!foreignKeyOptions.name) {
        throw new Error(`Foreign key for "${relatedClass.name}" is missing ` +
            `on "${classWithForeignKey.name}".`);
    }
    return foreignKeyOptions;
}
exports.getForeignKeyOptions = getForeignKeyOptions;
/**
 * Adds foreign key meta data for specified class
 */
function addForeignKey(target, relatedClassGetter, foreignKey) {
    let foreignKeys = getForeignKeys(target);
    if (!foreignKeys) {
        foreignKeys = [];
    }
    foreignKeys.push({
        relatedClassGetter,
        foreignKey,
    });
    setForeignKeys(target, foreignKeys);
}
exports.addForeignKey = addForeignKey;
/**
 * Returns foreign key meta data from specified class
 */
function getForeignKeys(target) {
    const foreignKeys = Reflect.getMetadata(FOREIGN_KEYS_KEY, target);
    if (foreignKeys) {
        return [...foreignKeys];
    }
}
exports.getForeignKeys = getForeignKeys;
/**
 * Sets foreign key meta data
 */
function setForeignKeys(target, foreignKeys) {
    Reflect.defineMetadata(FOREIGN_KEYS_KEY, foreignKeys, target);
}
//# sourceMappingURL=foreign-key-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForeignKey = void 0;
const foreign_key_service_1 = __webpack_require__(/*! ./foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
function ForeignKey(relatedClassGetter) {
    return (target, propertyName) => {
        foreign_key_service_1.addForeignKey(target, relatedClassGetter, propertyName);
    };
}
exports.ForeignKey = ForeignKey;
//# sourceMappingURL=foreign-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-association.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasAssociation = void 0;
const base_association_1 = __webpack_require__(/*! ../shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js");
const foreign_key_service_1 = __webpack_require__(/*! ../foreign-key/foreign-key-service */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key-service.js");
class HasAssociation extends base_association_1.BaseAssociation {
    constructor(associatedClassGetter, options, association) {
        super(associatedClassGetter, options);
        this.options = options;
        this.association = association;
    }
    getAssociation() {
        return this.association;
    }
    getSequelizeOptions(model) {
        const options = Object.assign({}, this.options);
        const associatedClass = this.getAssociatedClass();
        options.foreignKey = foreign_key_service_1.getForeignKeyOptions(model, associatedClass, options.foreignKey);
        return options;
    }
}
exports.HasAssociation = HasAssociation;
//# sourceMappingURL=has-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-many.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasMany = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasMany(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasMany));
    };
}
exports.HasMany = HasMany;
//# sourceMappingURL=has-many.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/has/has-one.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasOne = void 0;
const has_association_1 = __webpack_require__(/*! ./has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js");
const association_service_1 = __webpack_require__(/*! ../shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const association_1 = __webpack_require__(/*! ../shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js");
function HasOne(associatedClassGetter, optionsOrForeignKey) {
    return (target, propertyName) => {
        const options = association_service_1.getPreparedAssociationOptions(optionsOrForeignKey);
        if (!options.as)
            options.as = propertyName;
        association_service_1.addAssociation(target, new has_association_1.HasAssociation(associatedClassGetter, options, association_1.Association.HasOne));
    };
}
exports.HasOne = HasOne;
//# sourceMappingURL=has-one.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association-service.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAssociationsByRelation = exports.setAssociations = exports.getAssociations = exports.addAssociation = exports.getPreparedAssociationOptions = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const ASSOCIATIONS_KEY = 'sequelize:associations';
// tslint:disable:max-line-length
function getPreparedAssociationOptions(optionsOrForeignKey) {
    let options = {};
    if (optionsOrForeignKey) {
        if (typeof optionsOrForeignKey === 'string') {
            options.foreignKey = optionsOrForeignKey;
        }
        else {
            options = Object.assign({}, optionsOrForeignKey);
        }
    }
    return options;
}
exports.getPreparedAssociationOptions = getPreparedAssociationOptions;
/**
 * Stores association meta data for specified class
 */
function addAssociation(target, association) {
    let associations = getAssociations(target);
    if (!associations) {
        associations = [];
    }
    associations.push(association);
    setAssociations(target, associations);
}
exports.addAssociation = addAssociation;
/**
 * Returns association meta data from specified class
 */
function getAssociations(target) {
    const associations = Reflect.getMetadata(ASSOCIATIONS_KEY, target);
    if (associations) {
        return [...associations];
    }
}
exports.getAssociations = getAssociations;
function setAssociations(target, associations) {
    Reflect.defineMetadata(ASSOCIATIONS_KEY, associations, target);
}
exports.setAssociations = setAssociations;
function getAssociationsByRelation(target, relatedClass) {
    const associations = getAssociations(target);
    return (associations || []).filter(association => {
        const _relatedClass = association.getAssociatedClass();
        return (_relatedClass.prototype === relatedClass.prototype ||
            relatedClass.prototype instanceof _relatedClass);
    });
}
exports.getAssociationsByRelation = getAssociationsByRelation;
//# sourceMappingURL=association-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/association.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/association.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Association = void 0;
var Association;
(function (Association) {
    Association["BelongsToMany"] = "belongsToMany";
    Association["BelongsTo"] = "belongsTo";
    Association["HasMany"] = "hasMany";
    Association["HasOne"] = "hasOne";
})(Association = exports.Association || (exports.Association = {}));
//# sourceMappingURL=association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/base-association.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAssociation = void 0;
class BaseAssociation {
    constructor(associatedClassGetter, options) {
        this.associatedClassGetter = associatedClassGetter;
        this.options = options;
    }
    getAssociatedClass() {
        return this.associatedClassGetter();
    }
    getAs() {
        return this.options.as;
    }
}
exports.BaseAssociation = BaseAssociation;
//# sourceMappingURL=base-association.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=union-association-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/associations/through/through-options.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=through-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkCreate', args);
}
exports.AfterBulkCreate = AfterBulkCreate;
//# sourceMappingURL=after-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkDestroy', args);
}
exports.AfterBulkDestroy = AfterBulkDestroy;
//# sourceMappingURL=after-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkRestore', args);
}
exports.AfterBulkRestore = AfterBulkRestore;
//# sourceMappingURL=after-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkSync', args);
}
exports.AfterBulkSync = AfterBulkSync;
//# sourceMappingURL=after-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterBulkUpdate', args);
}
exports.AfterBulkUpdate = AfterBulkUpdate;
//# sourceMappingURL=after-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkCreate', args);
}
exports.BeforeBulkCreate = BeforeBulkCreate;
//# sourceMappingURL=before-bulk-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkDestroy', args);
}
exports.BeforeBulkDestroy = BeforeBulkDestroy;
//# sourceMappingURL=before-bulk-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkRestore', args);
}
exports.BeforeBulkRestore = BeforeBulkRestore;
//# sourceMappingURL=before-bulk-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkSync', args);
}
exports.BeforeBulkSync = BeforeBulkSync;
//# sourceMappingURL=before-bulk-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeBulkUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeBulkUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeBulkUpdate', args);
}
exports.BeforeBulkUpdate = BeforeBulkUpdate;
//# sourceMappingURL=before-bulk-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=hook-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setHooks = exports.getHooks = exports.addHook = exports.implementHookDecorator = exports.installHooks = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const HOOKS_KEY = 'sequelize:hooks';
/**
 * Installs hooks on the specified models
 */
function installHooks(models) {
    models.forEach(model => {
        const hooks = getHooks(model);
        if (hooks) {
            hooks.forEach(hook => {
                installHook(model, hook);
            });
        }
    });
}
exports.installHooks = installHooks;
/**
 * Implementation for hook decorator functions. These are polymorphic. When
 * called with a single argument (IHookOptions) they return a decorator
 * factory function. When called with multiple arguments, they add the hook
 * to the models metadata.
 */
function implementHookDecorator(hookType, args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => addHook(target, hookType, propertyName, options);
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        addHook(target, hookType, propertyName);
    }
}
exports.implementHookDecorator = implementHookDecorator;
/**
 * Adds hook meta data for specified model
 * @throws if applied to a non-static method
 * @throws if the hook method name is reserved
 */
function addHook(target, hookType, methodName, options = {}) {
    if (typeof target !== 'function') {
        throw new Error(`Hook method '${methodName}' is not a static method. ` +
            `Only static methods can be used for hooks`);
    }
    // make sure the hook name doesnt conflict with Sequelizes existing methods
    if (methodName === hookType) {
        throw new Error(`Hook method cannot be named '${methodName}'. That name is ` +
            `reserved by Sequelize`);
    }
    const hooks = getHooks(target) || [];
    hooks.push({
        hookType,
        methodName,
        options
    });
    setHooks(target, hooks);
}
exports.addHook = addHook;
/**
 * Install a hook
 */
function installHook(model, hook) {
    if (hook.options && hook.options.name) {
        model.addHook(hook.hookType, hook.options.name, model[hook.methodName]);
        return;
    }
    model.addHook(hook.hookType, model[hook.methodName]);
}
/**
 * Returns hooks meta data from specified class
 */
function getHooks(target) {
    const hooks = Reflect.getMetadata(HOOKS_KEY, target);
    if (hooks) {
        return [...hooks];
    }
}
exports.getHooks = getHooks;
/**
 * Saves hooks meta data for the specified class
 */
function setHooks(target, hooks) {
    Reflect.defineMetadata(HOOKS_KEY, hooks, target);
}
exports.setHooks = setHooks;
//# sourceMappingURL=hooks-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationFailed = void 0;
const hooks_service_1 = __webpack_require__(/*! ./hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function ValidationFailed(...args) {
    return hooks_service_1.implementHookDecorator('validationFailed', args);
}
exports.ValidationFailed = ValidationFailed;
//# sourceMappingURL=validation-failed.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterConnect(...args) {
    return hooks_service_1.implementHookDecorator('afterConnect', args);
}
exports.AfterConnect = AfterConnect;
//# sourceMappingURL=after-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterCreate(...args) {
    return hooks_service_1.implementHookDecorator('afterCreate', args);
}
exports.AfterCreate = AfterCreate;
//# sourceMappingURL=after-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDefine(...args) {
    return hooks_service_1.implementHookDecorator('afterDefine', args);
}
exports.AfterDefine = AfterDefine;
//# sourceMappingURL=after-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterDestroy(...args) {
    return hooks_service_1.implementHookDecorator('afterDestroy', args);
}
exports.AfterDestroy = AfterDestroy;
//# sourceMappingURL=after-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterFind(...args) {
    return hooks_service_1.implementHookDecorator('afterFind', args);
}
exports.AfterFind = AfterFind;
//# sourceMappingURL=after-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterInit(...args) {
    return hooks_service_1.implementHookDecorator('afterInit', args);
}
exports.AfterInit = AfterInit;
//# sourceMappingURL=after-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterRestore(...args) {
    return hooks_service_1.implementHookDecorator('afterRestore', args);
}
exports.AfterRestore = AfterRestore;
//# sourceMappingURL=after-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSave(...args) {
    return hooks_service_1.implementHookDecorator('afterSave', args);
}
exports.AfterSave = AfterSave;
//# sourceMappingURL=after-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterSync(...args) {
    return hooks_service_1.implementHookDecorator('afterSync', args);
}
exports.AfterSync = AfterSync;
//# sourceMappingURL=after-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpdate(...args) {
    return hooks_service_1.implementHookDecorator('afterUpdate', args);
}
exports.AfterUpdate = AfterUpdate;
//# sourceMappingURL=after-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterUpsert(...args) {
    return hooks_service_1.implementHookDecorator('afterUpsert', args);
}
exports.AfterUpsert = AfterUpsert;
//# sourceMappingURL=after-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AfterValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function AfterValidate(...args) {
    return hooks_service_1.implementHookDecorator('afterValidate', args);
}
exports.AfterValidate = AfterValidate;
//# sourceMappingURL=after-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeConnect = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeConnect(...args) {
    return hooks_service_1.implementHookDecorator('beforeConnect', args);
}
exports.BeforeConnect = BeforeConnect;
//# sourceMappingURL=before-connect.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCount = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCount(...args) {
    return hooks_service_1.implementHookDecorator('beforeCount', args);
}
exports.BeforeCount = BeforeCount;
//# sourceMappingURL=before-count.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeCreate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeCreate(...args) {
    return hooks_service_1.implementHookDecorator('beforeCreate', args);
}
exports.BeforeCreate = BeforeCreate;
//# sourceMappingURL=before-create.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDefine = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDefine(...args) {
    return hooks_service_1.implementHookDecorator('beforeDefine', args);
}
exports.BeforeDefine = BeforeDefine;
//# sourceMappingURL=before-define.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeDestroy = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeDestroy(...args) {
    return hooks_service_1.implementHookDecorator('beforeDestroy', args);
}
exports.BeforeDestroy = BeforeDestroy;
//# sourceMappingURL=before-destroy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterExpandIncludeAll = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterExpandIncludeAll(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterExpandIncludeAll', args);
}
exports.BeforeFindAfterExpandIncludeAll = BeforeFindAfterExpandIncludeAll;
//# sourceMappingURL=before-find-after-expand-include-all.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFindAfterOptions = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFindAfterOptions(...args) {
    return hooks_service_1.implementHookDecorator('beforeFindAfterOptions', args);
}
exports.BeforeFindAfterOptions = BeforeFindAfterOptions;
//# sourceMappingURL=before-find-after-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeFind = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeFind(...args) {
    return hooks_service_1.implementHookDecorator('beforeFind', args);
}
exports.BeforeFind = BeforeFind;
//# sourceMappingURL=before-find.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeInit = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeInit(...args) {
    return hooks_service_1.implementHookDecorator('beforeInit', args);
}
exports.BeforeInit = BeforeInit;
//# sourceMappingURL=before-init.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeRestore = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeRestore(...args) {
    return hooks_service_1.implementHookDecorator('beforeRestore', args);
}
exports.BeforeRestore = BeforeRestore;
//# sourceMappingURL=before-restore.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSave = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSave(...args) {
    return hooks_service_1.implementHookDecorator('beforeSave', args);
}
exports.BeforeSave = BeforeSave;
//# sourceMappingURL=before-save.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeSync = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeSync(...args) {
    return hooks_service_1.implementHookDecorator('beforeSync', args);
}
exports.BeforeSync = BeforeSync;
//# sourceMappingURL=before-sync.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpdate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpdate(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpdate', args);
}
exports.BeforeUpdate = BeforeUpdate;
//# sourceMappingURL=before-update.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeUpsert = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeUpsert(...args) {
    return hooks_service_1.implementHookDecorator('beforeUpsert', args);
}
exports.BeforeUpsert = BeforeUpsert;
//# sourceMappingURL=before-upsert.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeforeValidate = void 0;
const hooks_service_1 = __webpack_require__(/*! ../../shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
function BeforeValidate(...args) {
    return hooks_service_1.implementHookDecorator('beforeValidate', args);
}
exports.BeforeValidate = BeforeValidate;
//# sourceMappingURL=before-validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to/belongs-to-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to/belongs-to-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-association */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/belongs-to-many/belongs-to-many-options */ "./node_modules/sequelize-typescript/dist/associations/belongs-to-many/belongs-to-many-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/foreign-key/foreign-key */ "./node_modules/sequelize-typescript/dist/associations/foreign-key/foreign-key.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-association */ "./node_modules/sequelize-typescript/dist/associations/has/has-association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-one */ "./node_modules/sequelize-typescript/dist/associations/has/has-one.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/has/has-many */ "./node_modules/sequelize-typescript/dist/associations/has/has-many.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association */ "./node_modules/sequelize-typescript/dist/associations/shared/association.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/base-association */ "./node_modules/sequelize-typescript/dist/associations/shared/base-association.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-action-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/union-association-options */ "./node_modules/sequelize-typescript/dist/associations/shared/union-association-options.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js"), exports);
__exportStar(__webpack_require__(/*! ./associations/through/through-options */ "./node_modules/sequelize-typescript/dist/associations/through/through-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/after/after-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/after/after-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-create */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-destroy */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-restore */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-sync */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/bulk/before/before-bulk-update */ "./node_modules/sequelize-typescript/dist/hooks/bulk/before/before-bulk-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-create */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-define */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-find */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-init */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-save */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-update */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/after/after-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/after/after-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-connect */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-connect.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-count */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-count.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-create */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-create.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-define */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-define.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-destroy */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-destroy.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-expand-include-all */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-expand-include-all.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-find-after-options */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-find-after-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-init */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-init.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-restore */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-restore.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-save */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-save.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-sync */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-sync.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-update */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-update.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-upsert */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-upsert.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/single/before/before-validate */ "./node_modules/sequelize-typescript/dist/hooks/single/before/before-validate.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hook-options */ "./node_modules/sequelize-typescript/dist/hooks/shared/hook-options.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js"), exports);
__exportStar(__webpack_require__(/*! ./hooks/shared/validation-failed */ "./node_modules/sequelize-typescript/dist/hooks/shared/validation-failed.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/allow-null */ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/comment */ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/default */ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column-options/unique */ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/auto-increment */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/primary-key/primary-key */ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/created-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/deleted-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/timestamps/updated-at */ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/column/column */ "./node_modules/sequelize-typescript/dist/model/column/column.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-count-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/association/association-get-options */ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-class-getter */ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js"), exports);
__exportStar(__webpack_require__(/*! ./model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table */ "./node_modules/sequelize-typescript/dist/model/table/table.js"), exports);
__exportStar(__webpack_require__(/*! ./model/table/table-options */ "./node_modules/sequelize-typescript/dist/model/table/table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/create-index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-decorator */ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js"), exports);
__exportStar(__webpack_require__(/*! ./model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/default-scope */ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scope-table-options */ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js"), exports);
__exportStar(__webpack_require__(/*! ./scopes/scopes */ "./node_modules/sequelize-typescript/dist/scopes/scopes.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-options */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/validation-only/db-dialect-dummy */ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/sequelize/sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js"), exports);
__exportStar(__webpack_require__(/*! ./sequelize/repository/repository */ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/contains */ "./node_modules/sequelize-typescript/dist/validation/contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/equals */ "./node_modules/sequelize-typescript/dist/validation/equals.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is */ "./node_modules/sequelize-typescript/dist/validation/is.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-after */ "./node_modules/sequelize-typescript/dist/validation/is-after.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alpha */ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-alphanumeric */ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-before */ "./node_modules/sequelize-typescript/dist/validation/is-before.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-credit-card */ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-date */ "./node_modules/sequelize-typescript/dist/validation/is-date.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-decimal */ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-email */ "./node_modules/sequelize-typescript/dist/validation/is-email.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-float */ "./node_modules/sequelize-typescript/dist/validation/is-float.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-in */ "./node_modules/sequelize-typescript/dist/validation/is-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-int */ "./node_modules/sequelize-typescript/dist/validation/is-int.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip */ "./node_modules/sequelize-typescript/dist/validation/is-ip.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v4 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-array */ "./node_modules/sequelize-typescript/dist/validation/is-array.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-ip-v6 */ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-lowercase */ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-null */ "./node_modules/sequelize-typescript/dist/validation/is-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-numeric */ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uppercase */ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-url */ "./node_modules/sequelize-typescript/dist/validation/is-url.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/is-uuid */ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/length */ "./node_modules/sequelize-typescript/dist/validation/length.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/max */ "./node_modules/sequelize-typescript/dist/validation/max.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/min */ "./node_modules/sequelize-typescript/dist/validation/min.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not */ "./node_modules/sequelize-typescript/dist/validation/not.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-contains */ "./node_modules/sequelize-typescript/dist/validation/not-contains.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-empty */ "./node_modules/sequelize-typescript/dist/validation/not-empty.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-in */ "./node_modules/sequelize-typescript/dist/validation/not-in.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/not-null */ "./node_modules/sequelize-typescript/dist/validation/not-null.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validate */ "./node_modules/sequelize-typescript/dist/validation/validate.js"), exports);
__exportStar(__webpack_require__(/*! ./validation/validator */ "./node_modules/sequelize-typescript/dist/validation/validator.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/attribute-service.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addAttributeOptions = exports.addAttribute = exports.setAttributes = exports.getAttributes = void 0;
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const ATTRIBUTES_KEY = 'sequelize:attributes';
/**
 * Returns model attributes from class by restoring this
 * information from reflect metadata
 */
function getAttributes(target) {
    const attributes = Reflect.getMetadata(ATTRIBUTES_KEY, target);
    if (attributes) {
        return Object
            .keys(attributes)
            .reduce((copy, key) => {
            copy[key] = Object.assign({}, attributes[key]);
            return copy;
        }, {});
    }
}
exports.getAttributes = getAttributes;
/**
 * Sets attributes
 */
function setAttributes(target, attributes) {
    Reflect.defineMetadata(ATTRIBUTES_KEY, Object.assign({}, attributes), target);
}
exports.setAttributes = setAttributes;
/**
 * Adds model attribute by specified property name and
 * sequelize attribute options and stores this information
 * through reflect metadata
 */
function addAttribute(target, name, options) {
    let attributes = getAttributes(target);
    if (!attributes) {
        attributes = {};
    }
    attributes[name] = Object.assign({}, options);
    setAttributes(target, attributes);
}
exports.addAttribute = addAttribute;
/**
 * Adds attribute options for specific attribute
 */
function addAttributeOptions(target, propertyName, options) {
    const attributes = getAttributes(target);
    if (!attributes || !attributes[propertyName]) {
        throw new Error(`@Column annotation is missing for "${propertyName}" of class "${target.constructor.name}"` +
            ` or annotation order is wrong.`);
    }
    attributes[propertyName] = object_1.deepAssign(attributes[propertyName], options);
    setAttributes(target, attributes);
}
exports.addAttributeOptions = addAttributeOptions;
//# sourceMappingURL=attribute-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/allow-null.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllowNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function AllowNull(...args) {
    if (args.length === 1) {
        const allowNull = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, { allowNull });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            allowNull: true
        });
    }
}
exports.AllowNull = AllowNull;
//# sourceMappingURL=allow-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/comment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comment = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified comment value for the annotated field
 */
function Comment(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            comment: value
        });
    };
}
exports.Comment = Comment;
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/default.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/default.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets the specified default value for the annotated field
 */
function Default(value) {
    return (target, propertyName) => {
        attribute_service_1.addAttributeOptions(target, propertyName, {
            defaultValue: value
        });
    };
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column-options/unique.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unique = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Unique(...args) {
    if (args.length === 1) {
        const [options] = args;
        return (_target, _propertyName) => {
            annotate(_target, _propertyName, options);
        };
    }
    const [target, propertyName] = args;
    annotate(target, propertyName);
}
exports.Unique = Unique;
function annotate(target, propertyName, option = true) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        unique: option,
    });
}
//# sourceMappingURL=unique.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/column.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/column.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Column = void 0;
const attribute_service_1 = __webpack_require__(/*! ./attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Column(...args) {
    // In case of no specified options, we infer the
    // sequelize data type by the type of the property
    if (args.length >= 2) {
        const target = args[0];
        const propertyName = args[1];
        const propertyDescriptor = args[2];
        annotate(target, propertyName, propertyDescriptor);
        return;
    }
    return (target, propertyName, propertyDescriptor) => {
        annotate(target, propertyName, propertyDescriptor, args[0]);
    };
}
exports.Column = Column;
function annotate(target, propertyName, propertyDescriptor, optionsOrDataType = {}) {
    let options;
    if (data_type_service_1.isDataType(optionsOrDataType)) {
        options = {
            type: optionsOrDataType
        };
    }
    else {
        options = Object.assign({}, optionsOrDataType);
        if (!options.type) {
            options.type = model_service_1.getSequelizeTypeByDesignType(target, propertyName);
        }
    }
    if (propertyDescriptor) {
        if (propertyDescriptor.get) {
            options.get = propertyDescriptor.get;
        }
        if (propertyDescriptor.set) {
            options.set = propertyDescriptor.set;
        }
    }
    attribute_service_1.addAttribute(target, propertyName, options);
}
//# sourceMappingURL=column.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/auto-increment.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoIncrement = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets auto increment true for annotated field
 */
function AutoIncrement(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        autoIncrement: true
    });
}
exports.AutoIncrement = AutoIncrement;
//# sourceMappingURL=auto-increment.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/primary-key/primary-key.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimaryKey = void 0;
const attribute_service_1 = __webpack_require__(/*! ../attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets primary key option true for annotated property.
 */
function PrimaryKey(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        primaryKey: true
    });
}
exports.PrimaryKey = PrimaryKey;
//# sourceMappingURL=primary-key.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/created-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function CreatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        createdAt: propertyName,
        timestamps: true
    });
}
exports.CreatedAt = CreatedAt;
//# sourceMappingURL=created-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/deleted-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function DeletedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        deletedAt: propertyName,
        timestamps: true,
        paranoid: true
    });
}
exports.DeletedAt = DeletedAt;
//# sourceMappingURL=deleted-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/column/timestamps/updated-at.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatedAt = void 0;
const model_service_1 = __webpack_require__(/*! ../../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function UpdatedAt(target, propertyName) {
    model_service_1.addOptions(target, {
        updatedAt: propertyName,
        timestamps: true
    });
}
exports.UpdatedAt = UpdatedAt;
//# sourceMappingURL=updated-at.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/create-index-decorator.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIndexDecorator = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function createIndexDecorator(options = {}) {
    let indexId;
    return ((...args) => {
        if (args.length >= 2) {
            const [target, propertyName] = args;
            const fieldOptions = { name: propertyName };
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
            return;
        }
        return (target, propertyName) => {
            const fieldOptions = Object.assign({ name: propertyName }, args[0]);
            indexId = index_service_1.addFieldToIndex(target, fieldOptions, options, indexId);
        };
    });
}
exports.createIndexDecorator = createIndexDecorator;
//# sourceMappingURL=create-index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-decorator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-decorator.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.annotateModelWithIndex = exports.Index = void 0;
const index_service_1 = __webpack_require__(/*! ./index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
function Index(...args) {
    if (args.length >= 2) {
        const [target, propertyName] = args;
        annotateModelWithIndex(target, propertyName);
        return;
    }
    return (target, propertyName) => {
        annotateModelWithIndex(target, propertyName, args[0]);
    };
}
exports.Index = Index;
function annotateModelWithIndex(target, propertyName, optionsOrName = {}, indexId) {
    let indexOptions;
    let fieldOptions;
    if (typeof optionsOrName === 'string') {
        indexOptions = { name: optionsOrName };
        fieldOptions = { name: propertyName };
    }
    else {
        const { length, order, collate } = optionsOrName, rest = __rest(optionsOrName, ["length", "order", "collate"]);
        indexOptions = rest;
        fieldOptions = {
            name: propertyName,
            length,
            order,
            collate,
        };
    }
    return index_service_1.addFieldToIndex(target, fieldOptions, indexOptions, indexId);
}
exports.annotateModelWithIndex = annotateModelWithIndex;
//# sourceMappingURL=index-decorator.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/index/index-service.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/index/index-service.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addFieldToIndex = exports.setIndexes = exports.getIndexes = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const INDEXES_KEY = 'sequelize:indexes';
/**
 * Returns model indexes from class by restoring this
 * information from reflect metadata
 */
function getIndexes(target) {
    const { named = {}, unnamed = [] } = Reflect.getMetadata(INDEXES_KEY, target) || {};
    return { named: Object.assign({}, named), unnamed: [...unnamed] };
}
exports.getIndexes = getIndexes;
/**
 * Sets indexes
 */
function setIndexes(target, indexes) {
    Reflect.defineMetadata(INDEXES_KEY, indexes, target);
}
exports.setIndexes = setIndexes;
/**
 * Adds field to index by sequelize index and index field options,
 * and stores this information through reflect metadata. Returns index ID.
 */
function addFieldToIndex(target, fieldOptions, indexOptions, indexId) {
    const indexes = getIndexes(target);
    const chosenId = typeof indexId !== 'undefined'
        ? indexId
        : indexOptions.name || indexes.unnamed.length;
    const indexStore = typeof chosenId === 'string'
        ? indexes.named
        : indexes.unnamed;
    if (!indexStore[chosenId])
        indexStore[chosenId] = Object.assign({}, indexOptions);
    const index = indexStore[chosenId];
    if (!index.fields)
        index.fields = [];
    index.fields.push(fieldOptions);
    setIndexes(target, indexes);
    return chosenId;
}
exports.addFieldToIndex = addFieldToIndex;
//# sourceMappingURL=index-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-action-options.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-action-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-count-options.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-count-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/association/association-get-options.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=association-get-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/model/model.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/model/model.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INFER_ALIAS_MAP = exports.Model = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const string_1 = __webpack_require__(/*! ../../shared/string */ "./node_modules/sequelize-typescript/dist/shared/string.js");
const alias_inference_service_1 = __webpack_require__(/*! ../../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const object_1 = __webpack_require__(/*! ../../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
class Model extends sequelize_1.Model {
    constructor(values, options) {
        if (!new.target.isInitialized) {
            throw new model_not_initialized_error_1.ModelNotInitializedError(new.target, `${new.target.name} cannot be instantiated.`);
        }
        super(values, alias_inference_service_1.inferAlias(options, new.target));
    }
    static init(attributes, options) {
        this.isInitialized = true;
        // @ts-ignore
        return super.init(attributes, options);
    }
    /**
     * Adds relation between specified instances and source instance
     */
    $add(propertyKey, instances, options) {
        return this['add' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Sets relation between specified instances and source instance
     * (replaces old relations)
     */
    $set(propertyKey, instances, options) {
        return this['set' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Returns related instance (specified by propertyKey) of source instance
     */
    $get(propertyKey, options) {
        return this['get' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Counts related instances (specified by propertyKey) of source instance
     */
    $count(propertyKey, options) {
        return this['count' + string_1.capitalize(propertyKey)](options);
    }
    /**
     * Creates instances and relate them to source instance
     */
    $create(propertyKey, values, options) {
        return this['create' + string_1.capitalize(propertyKey)](values, options);
    }
    /**
     * Checks if specified instances is related to source instance
     */
    $has(propertyKey, instances, options) {
        return this['has' + string_1.capitalize(propertyKey)](instances, options);
    }
    /**
     * Removes specified instances from source instance
     */
    $remove(propertyKey, instances, options) {
        return this['remove' + string_1.capitalize(propertyKey)](instances, options);
    }
    reload(options) {
        return super.reload(alias_inference_service_1.inferAlias(options, this));
    }
}
exports.Model = Model;
Model.isInitialized = false;
/**
 * Indicates which static methods of Model has to be proxied,
 * to prepare include option to automatically resolve alias;
 * The index represents the index of the options of the
 * corresponding method parameter
 */
exports.INFER_ALIAS_MAP = {
    bulkBuild: 1,
    build: 1,
    create: 1,
    aggregate: 2,
    all: 0,
    find: 0,
    findAll: 0,
    findAndCount: 0,
    findAndCountAll: 0,
    findById: 1,
    findByPrimary: 1,
    findCreateFind: 0,
    findOne: 0,
    findOrBuild: 0,
    findOrCreate: 0,
    findOrInitialize: 0,
    reload: 0,
};
const staticModelFunctionProperties = object_1.getAllPropertyNames(sequelize_1.Model)
    .filter(key => !isForbiddenMember(key) &&
    isFunctionMember(key, sequelize_1.Model) &&
    !isPrivateMember(key));
function isFunctionMember(propertyKey, target) {
    return typeof target[propertyKey] === 'function';
}
function isForbiddenMember(propertyKey) {
    const FORBIDDEN_KEYS = ['name', 'constructor', 'length', 'prototype', 'caller', 'arguments', 'apply',
        'queryInterface', 'queryGenerator', 'init', 'replaceHookAliases', 'refreshAttributes', 'inspect'];
    return FORBIDDEN_KEYS.indexOf(propertyKey) !== -1;
}
function isPrivateMember(propertyKey) {
    return (propertyKey.charAt(0) === '_');
}
function addThrowNotInitializedProxy() {
    staticModelFunctionProperties
        .forEach(key => {
        const superFn = Model[key];
        Model[key] = function (...args) {
            if (!this.isInitialized) {
                throw new model_not_initialized_error_1.ModelNotInitializedError(this, `Member "${key}" cannot be called.`);
            }
            return superFn.call(this, ...args);
        };
    });
}
function addInferAliasOverrides() {
    Object
        .keys(exports.INFER_ALIAS_MAP)
        .forEach(key => {
        const optionIndex = exports.INFER_ALIAS_MAP[key];
        const superFn = Model[key];
        Model[key] = function (...args) {
            args[optionIndex] = alias_inference_service_1.inferAlias(args[optionIndex], this);
            return superFn.call(this, ...args);
        };
    });
}
addThrowNotInitializedProxy();
addInferAliasOverrides();
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-class-getter.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=model-class-getter.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelNotInitializedError = void 0;
class ModelNotInitializedError extends Error {
    constructor(modelClass, additionalMessage) {
        super();
        this.message = `Model not initialized: ${additionalMessage} "${modelClass.name}" ` +
            `needs to be added to a Sequelize instance.`;
    }
}
exports.ModelNotInitializedError = ModelNotInitializedError;
//# sourceMappingURL=model-not-initialized-error.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/shared/model-service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModelGetter = exports.getSequelizeTypeByDesignType = exports.addOptions = exports.setOptions = exports.getOptions = exports.getModelName = exports.setModelName = void 0;
const model_1 = __webpack_require__(/*! ../model/model */ "./node_modules/sequelize-typescript/dist/model/model/model.js");
const data_type_service_1 = __webpack_require__(/*! ../../sequelize/data-type/data-type-service */ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js");
const MODEL_NAME_KEY = 'sequelize:modelName';
const OPTIONS_KEY = 'sequelize:options';
/**
 * Sets model name from class by storing this
 * information through reflect metadata
 */
function setModelName(target, modelName) {
    Reflect.defineMetadata(MODEL_NAME_KEY, modelName, target);
}
exports.setModelName = setModelName;
/**
 * Returns model name from class by restoring this
 * information from reflect metadata
 */
function getModelName(target) {
    return Reflect.getMetadata(MODEL_NAME_KEY, target);
}
exports.getModelName = getModelName;
/**
 * Returns sequelize define options from class prototype
 * by restoring this information from reflect metadata
 */
function getOptions(target) {
    const options = Reflect.getMetadata(OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
}
exports.getOptions = getOptions;
/**
 * Sets seuqlize define options to class prototype
 */
function setOptions(target, options) {
    Reflect.defineMetadata(OPTIONS_KEY, Object.assign({}, options), target);
}
exports.setOptions = setOptions;
/**
 * Adds options be assigning new options to old one
 */
function addOptions(target, options) {
    let _options = getOptions(target);
    if (!_options) {
        _options = {};
    }
    setOptions(target, Object.assign(Object.assign(Object.assign({}, _options), options), { validate: Object.assign(Object.assign({}, (_options.validate || {})), (options.validate || {})) }));
}
exports.addOptions = addOptions;
/**
 * Maps design types to sequelize data types;
 * @throws if design type cannot be automatically mapped to
 * a sequelize data type
 */
function getSequelizeTypeByDesignType(target, propertyName) {
    const type = Reflect.getMetadata('design:type', target, propertyName);
    const dataType = data_type_service_1.inferDataType(type);
    if (dataType) {
        return dataType;
    }
    throw new Error(`Specified type of property '${propertyName}'
            cannot be automatically resolved to a sequelize data type. Please
            define the data type manually`);
}
exports.getSequelizeTypeByDesignType = getSequelizeTypeByDesignType;
/**
 * Resolves all model getters of specified options object
 * recursively.
 * So that {model: () => Person} will be converted to
 * {model: Person}
 */
function resolveModelGetter(options) {
    const maybeModelGetter = value => typeof value === 'function' && value.length === 0;
    const isModel = value => value && value.prototype && value.prototype instanceof model_1.Model;
    const isOptionObjectOrArray = value => value && typeof value === 'object';
    return Object
        .keys(options)
        .reduce((acc, key) => {
        const value = options[key];
        if (maybeModelGetter(value)) {
            const maybeModel = value();
            if (isModel(maybeModel)) {
                acc[key] = maybeModel;
            }
        }
        else if (isOptionObjectOrArray(value)) {
            acc[key] = resolveModelGetter(value);
        }
        return acc;
    }, Array.isArray(options) ? [...options] : Object.assign({}, options));
}
exports.resolveModelGetter = resolveModelGetter;
//# sourceMappingURL=model-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table-options.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table-options.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/model/table/table.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/model/table/table.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = void 0;
const model_service_1 = __webpack_require__(/*! ../shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
function Table(arg) {
    if (typeof arg === 'function') {
        annotate(arg);
    }
    else {
        const options = Object.assign({}, arg);
        return (target) => annotate(target, options);
    }
}
exports.Table = Table;
function annotate(target, options = {}) {
    model_service_1.setModelName(target.prototype, options.modelName || target.name);
    model_service_1.addOptions(target.prototype, options);
}
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/default-scope.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/default-scope.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultScope = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining default Model scope
 */
function DefaultScope(scopeOrSsopeGetter) {
    return (target) => {
        if (typeof scopeOrSsopeGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, { getDefaultScope: scopeOrSsopeGetter });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, { defaultScope: scopeOrSsopeGetter });
        }
    };
}
exports.DefaultScope = DefaultScope;
//# sourceMappingURL=default-scope.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-options.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-options.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-service.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getScopeOptions = exports.addScopeOptions = exports.resolvesDeprecatedScopes = exports.setScopeOptionsGetters = exports.getScopeOptionsGetters = exports.addScopeOptionsGetter = exports.resolveScope = exports.resolveScopes = void 0;
const object_1 = __webpack_require__(/*! ../shared/object */ "./node_modules/sequelize-typescript/dist/shared/object.js");
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const alias_inference_service_1 = __webpack_require__(/*! ../associations/alias-inference/alias-inference-service */ "./node_modules/sequelize-typescript/dist/associations/alias-inference/alias-inference-service.js");
const SCOPES_KEY = 'sequelize:scopes';
const SCOPES_OPTIONS_KEY = 'sequelize:scopes-options';
/**
 * Resolves scopes and adds them to the specified models
 */
function resolveScopes(models) {
    models.forEach(model => {
        exports.resolvesDeprecatedScopes(model);
        const { getDefaultScope, getScopes } = exports.getScopeOptionsGetters(model.prototype);
        let options = {};
        if (getDefaultScope) {
            options = Object.assign(Object.assign({}, options), { defaultScope: getDefaultScope() });
        }
        if (getScopes) {
            options = Object.assign(Object.assign({}, options), getScopes());
        }
        Object
            .keys(options)
            .forEach(key => exports.resolveScope(key, model, options[key]));
    });
}
exports.resolveScopes = resolveScopes;
const resolveScope = (scopeName, model, options) => {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(options, model);
    }
    model.addScope(scopeName, options, { override: true });
};
exports.resolveScope = resolveScope;
const addScopeOptionsGetter = (target, options) => {
    const currentOptions = exports.getScopeOptionsGetters(target) || {};
    exports.setScopeOptionsGetters(target, Object.assign(Object.assign({}, currentOptions), options));
};
exports.addScopeOptionsGetter = addScopeOptionsGetter;
const getScopeOptionsGetters = (target) => {
    const options = Reflect.getMetadata(SCOPES_OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
    return {};
};
exports.getScopeOptionsGetters = getScopeOptionsGetters;
const setScopeOptionsGetters = (target, options) => {
    Reflect.defineMetadata(SCOPES_OPTIONS_KEY, options, target);
};
exports.setScopeOptionsGetters = setScopeOptionsGetters;
/**
 * @deprecated
 */
const resolvesDeprecatedScopes = (model) => {
    const options = getScopeOptions(model.prototype) || {};
    Object
        .keys(options)
        .forEach(key => resolveDeprecatedScope(key, model, options[key]));
};
exports.resolvesDeprecatedScopes = resolvesDeprecatedScopes;
/**
 * Adds scope option meta data for specified prototype
 * @deprecated
 */
function addScopeOptions(target, options) {
    const _options = getScopeOptions(target) || {};
    setScopeOptions(target, object_1.deepAssign({}, _options, options));
}
exports.addScopeOptions = addScopeOptions;
/**
 * Returns scope option meta data from specified target
 * @deprecated
 */
function getScopeOptions(target) {
    const options = Reflect.getMetadata(SCOPES_KEY, target);
    if (options) {
        return object_1.deepAssign({}, options);
    }
}
exports.getScopeOptions = getScopeOptions;
/**
 * @deprecated
 */
function resolveDeprecatedScope(scopeName, model, options) {
    if (typeof options === 'function') {
        const fn = options;
        options = (...args) => alias_inference_service_1.inferAlias(fn(...args), model);
    }
    else {
        options = alias_inference_service_1.inferAlias(model_service_1.resolveModelGetter(options), model);
    }
    model.addScope(scopeName, options, { override: true });
}
/**
 * Set scope option meta data for specified prototype
 * @deprecated
 */
function setScopeOptions(target, options) {
    Reflect.defineMetadata(SCOPES_KEY, options, target);
}
//# sourceMappingURL=scope-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scope-table-options.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=scope-table-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/scopes/scopes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/scopes/scopes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scopes = void 0;
const scope_service_1 = __webpack_require__(/*! ./scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
/**
 * Decorator for defining Model scopes
 */
function Scopes(scopesOrScopesGetter) {
    return (target) => {
        if (typeof scopesOrScopesGetter === 'function') {
            scope_service_1.addScopeOptionsGetter(target.prototype, {
                getScopes: scopesOrScopesGetter,
            });
        }
        else {
            scope_service_1.addScopeOptions(target.prototype, scopesOrScopesGetter);
        }
    };
}
exports.Scopes = Scopes;
//# sourceMappingURL=scopes.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferDataType = exports.isDataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
/*
 * Checks if specified value is a sequelize data type (ABSTRACT, STRING...)
 */
function isDataType(value) {
    return typeof value === 'string' ||
        (typeof value === 'function' && value({}) instanceof sequelize_1.DataTypes.ABSTRACT) ||
        value instanceof sequelize_1.DataTypes.ABSTRACT;
}
exports.isDataType = isDataType;
/**
 * Infers sequelize data type by design type
 */
function inferDataType(designType) {
    switch (designType) {
        case String:
            return sequelize_1.DataTypes.STRING;
        case BigInt:
            return sequelize_1.DataTypes.BIGINT;
        case Number:
            return sequelize_1.DataTypes.INTEGER;
        case Boolean:
            return sequelize_1.DataTypes.BOOLEAN;
        case Date:
            return sequelize_1.DataTypes.DATE;
        case Buffer:
            return sequelize_1.DataTypes.BLOB;
        default:
            return void 0;
    }
}
exports.inferDataType = inferDataType;
//# sourceMappingURL=data-type-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/data-type/data-type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataType = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
exports.DataType = sequelize_1.DataTypes;
//# sourceMappingURL=data-type.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/repository/repository.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=repository.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=sequelize-options.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getModels = exports.prepareArgs = exports.prepareOptions = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const glob = __webpack_require__(/*! glob */ "glob");
const array_1 = __webpack_require__(/*! ../../shared/array */ "./node_modules/sequelize-typescript/dist/shared/array.js");
/**
 * Prepares sequelize config passed to original sequelize constructor
 */
function prepareOptions(options) {
    if (options.validateOnly) {
        return getValidationOnlyOptions(options);
    }
    return Object.assign({}, options);
}
exports.prepareOptions = prepareOptions;
function prepareArgs(...args) {
    const lastArg = args[args.length - 1];
    const options = lastArg && typeof lastArg === 'object'
        ? prepareOptions(lastArg) : undefined;
    if (options) {
        args[args.length - 1] = options;
    }
    return { preparedArgs: args, options };
}
exports.prepareArgs = prepareArgs;
function getValidationOnlyOptions(options) {
    return Object.assign(Object.assign({}, options), { dialect: 'sqlite', dialectModulePath: __dirname + '/../validation-only/db-dialect-dummy' });
}
/**
 * Determines models from value
 */
function getModels(arg, modelMatch) {
    const hasSupportedExtension = path => ['.ts', '.js'].indexOf(path_1.extname(path)) !== -1;
    if (arg && typeof arg[0] === 'string') {
        return arg.reduce((models, dir) => {
            if (!glob.hasMagic(dir) && !hasSupportedExtension(dir))
                dir = path_1.join(dir, '/*');
            const _models = glob
                .sync(dir)
                .filter(isImportable)
                .map(getFullfilepathWithoutExtension)
                .filter(array_1.uniqueFilter)
                .map(fullPath => {
                const module = __webpack_require__("./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive")(fullPath);
                const fileName = path_1.basename(fullPath);
                const matchedMemberKey = Object.keys(module).find(m => modelMatch(fileName, m));
                const matchedMember = matchedMemberKey ? module[matchedMemberKey] : undefined;
                if (!matchedMember && !module.default) {
                    throw new Error(`No default export defined for file "${fileName}" or ` +
                        `export does not satisfy filename.`);
                }
                return matchedMember || module.default;
            });
            models.push(..._models);
            return models;
        }, []);
    }
    return arg;
}
exports.getModels = getModels;
/**
 * Checks if specified filename is importable or not;
 * Which means that, it needs to have a specific file extension
 */
function isImportable(file) {
    const filePart = file.slice(-3);
    return filePart === '.js' || (filePart === '.ts' && file.slice(-5) !== '.d.ts');
}
/**
 * Return the value of the full path with filename, without extension
 */
function getFullfilepathWithoutExtension(file) {
    const parsedFile = path_1.parse(file);
    return path_1.join(parsedFile.dir, parsedFile.name);
}
//# sourceMappingURL=sequelize-service.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sequelize = void 0;
const sequelize_1 = __webpack_require__(/*! sequelize */ "./node_modules/sequelize/index.js");
const model_not_initialized_error_1 = __webpack_require__(/*! ../../model/shared/model-not-initialized-error */ "./node_modules/sequelize-typescript/dist/model/shared/model-not-initialized-error.js");
const sequelize_service_1 = __webpack_require__(/*! ./sequelize-service */ "./node_modules/sequelize-typescript/dist/sequelize/sequelize/sequelize-service.js");
const model_service_1 = __webpack_require__(/*! ../../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const scope_service_1 = __webpack_require__(/*! ../../scopes/scope-service */ "./node_modules/sequelize-typescript/dist/scopes/scope-service.js");
const hooks_service_1 = __webpack_require__(/*! ../../hooks/shared/hooks-service */ "./node_modules/sequelize-typescript/dist/hooks/shared/hooks-service.js");
const association_service_1 = __webpack_require__(/*! ../../associations/shared/association-service */ "./node_modules/sequelize-typescript/dist/associations/shared/association-service.js");
const attribute_service_1 = __webpack_require__(/*! ../../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
const index_service_1 = __webpack_require__(/*! ../../model/index/index-service */ "./node_modules/sequelize-typescript/dist/model/index/index-service.js");
class Sequelize extends sequelize_1.Sequelize {
    constructor(...args) {
        const { preparedArgs, options } = sequelize_service_1.prepareArgs(...args);
        super(...preparedArgs);
        if (options) {
            this.repositoryMode = !!options.repositoryMode;
            if (options.models)
                this.addModels(options.models);
            if (options.modelPaths)
                this.addModels(options.modelPaths);
        }
        else {
            this.repositoryMode = false;
        }
    }
    model(model) {
        if (typeof model !== 'string') {
            return super.model(model_service_1.getModelName(model.prototype));
        }
        return super.model(model);
    }
    addModels(arg, modelMatch) {
        const defaultModelMatch = (filename, member) => filename === member;
        const models = sequelize_service_1.getModels(arg, modelMatch || this.options.modelMatch || defaultModelMatch);
        const definedModels = this.defineModels(models);
        this.associateModels(definedModels);
        scope_service_1.resolveScopes(definedModels);
        hooks_service_1.installHooks(definedModels);
    }
    getRepository(modelClass) {
        return this.model(modelClass);
    }
    associateModels(models) {
        models.forEach(model => {
            const associations = association_service_1.getAssociations(model.prototype);
            if (!associations)
                return;
            associations.forEach(association => {
                const options = association.getSequelizeOptions(model, this);
                const associatedClass = this.model(association.getAssociatedClass());
                if (!associatedClass.isInitialized) {
                    throw new model_not_initialized_error_1.ModelNotInitializedError(associatedClass, `Association between ${associatedClass.name} and ${model.name} cannot be resolved.`);
                }
                model[association.getAssociation()](associatedClass, options);
            });
        });
    }
    defineModels(models) {
        return models.map(model => {
            const modelName = model_service_1.getModelName(model.prototype);
            const attributes = attribute_service_1.getAttributes(model.prototype);
            const indexes = index_service_1.getIndexes(model.prototype);
            const modelOptions = model_service_1.getOptions(model.prototype);
            if (!modelOptions)
                throw new Error(`@Table annotation is missing on class "${model['name']}"`);
            const indexArray = Object.keys(indexes.named)
                .map(key => indexes.named[key])
                .concat(indexes.unnamed);
            const initOptions = Object.assign(Object.assign(Object.assign({}, (indexArray.length > 0 && { indexes: indexArray })), modelOptions), { modelName, sequelize: this });
            const definedModel = this.repositoryMode
                ? this.createRepositoryModel(model)
                : model;
            definedModel.init(attributes, initOptions);
            return definedModel;
        });
    }
    createRepositoryModel(modelClass) {
        return class extends modelClass {
        };
    }
}
exports.Sequelize = Sequelize;
//# sourceMappingURL=sequelize.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/sequelize/ sync ***!
  \**************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize-typescript/dist/sequelize/sequelize sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/sequelize/validation-only/db-dialect-dummy.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Dummy database file, which gets required by sequelize, to
 * make validation of models possible without using the
 * actual ORM or any database connection.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verbose = void 0;
function verbose() {
    return {};
}
exports.verbose = verbose;
//# sourceMappingURL=db-dialect-dummy.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueFilter = exports.unique = void 0;
/**
 * Removes duplicates from specified array
 */
function unique(arr) {
    return arr.filter(exports.uniqueFilter);
}
exports.unique = unique;
/**
 * Returns true for items, that only exists once on an array
 */
const uniqueFilter = (item, index, arr) => arr.indexOf(item) === index;
exports.uniqueFilter = uniqueFilter;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/object.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllPropertyNames = exports.cloneRegExp = exports.deepAssign = void 0;
function deepAssign(target, ...sources) {
    sources.forEach(source => {
        Object
            .getOwnPropertyNames(source)
            .forEach(key => assign(key, target, source));
        /* istanbul ignore next */
        if (Object.getOwnPropertySymbols) {
            Object
                .getOwnPropertySymbols(source)
                .forEach(key => assign(key, target, source));
        }
    });
    return target;
    function assign(key, _target, _source) {
        const sourceValue = _source[key];
        if (sourceValue !== void 0) {
            let targetValue = _target[key];
            if (Array.isArray(sourceValue)) {
                if (!Array.isArray(targetValue)) {
                    targetValue = [];
                }
                const length = targetValue.length;
                sourceValue.forEach((_, index) => assign(length + index, targetValue, sourceValue));
            }
            else if (typeof sourceValue === 'object') {
                if (sourceValue instanceof RegExp) {
                    targetValue = cloneRegExp(sourceValue);
                }
                else if (sourceValue instanceof Date) {
                    targetValue = new Date(sourceValue);
                }
                else if (sourceValue === null) {
                    targetValue = null;
                }
                else {
                    if (!targetValue) {
                        targetValue = Object.create(sourceValue.constructor.prototype);
                    }
                    deepAssign(targetValue, sourceValue);
                }
            }
            else {
                targetValue = sourceValue;
            }
            _target[key] = targetValue;
        }
    }
}
exports.deepAssign = deepAssign;
/**
 * I clone the given RegExp object, and ensure that the given flags exist on
 * the clone. The injectFlags parameter is purely additive - it cannot remove
 * flags that already exist on the
 *
 * @param input RegExp - I am the regular expression object being cloned.
 * @param injectFlags String( Optional ) - I am the flags to enforce on the clone.
 * @source https://www.bennadel.com/blog/2664-cloning-regexp-regular-expression-objects-in-javascript.htm
 */
function cloneRegExp(input, injectFlags) {
    const pattern = input.source;
    let flags = "";
    // Make sure the parameter is a defined string - it will make the conditional
    // logic easier to read.
    injectFlags = (injectFlags || "");
    // Test for global.
    if (input.global || (/g/i).test(injectFlags)) {
        flags += "g";
    }
    // Test for ignoreCase.
    if (input.ignoreCase || (/i/i).test(injectFlags)) {
        flags += "i";
    }
    // Test for multiline.
    if (input.multiline || (/m/i).test(injectFlags)) {
        flags += "m";
    }
    // Return a clone with the additive flags.
    return (new RegExp(pattern, flags));
}
exports.cloneRegExp = cloneRegExp;
function getAllPropertyNames(obj) {
    const names = [];
    const exists = {};
    do {
        names.push.apply(names, Object.getOwnPropertyNames(obj));
        obj = Object.getPrototypeOf(obj);
    } while (obj !== Object.prototype);
    return names.filter(name => {
        const isValid = !exists[name] && name !== 'constructor';
        exists[name] = true;
        return isValid;
    });
}
exports.getAllPropertyNames = getAllPropertyNames;
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/shared/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/shared/string.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.capitalize = void 0;
/**
 * Capitalize specified string value
 */
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.substr(1, value.length);
}
exports.capitalize = capitalize;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/contains.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/contains.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Contains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Force specific substrings
 */
function Contains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            contains: value
        }
    });
}
exports.Contains = Contains;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/equals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/equals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Equals = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow a specific value
 */
function Equals(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            equals: value
        }
    });
}
exports.Equals = Equals;
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-after.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-after.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAfter = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings after a specific date
 */
function IsAfter(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAfter: date
        }
    });
}
exports.IsAfter = IsAfter;
//# sourceMappingURL=is-after.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alpha.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alpha.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlpha = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow letters
 */
function IsAlpha(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlpha: true
        }
    });
}
exports.IsAlpha = IsAlpha;
//# sourceMappingURL=is-alpha.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-alphanumeric.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsAlphanumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow alphanumeric characters, so "_abc" will fail
 */
function IsAlphanumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isAlphanumeric: true
        }
    });
}
exports.IsAlphanumeric = IsAlphanumeric;
//# sourceMappingURL=is-alphanumeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-array.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsArray = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow arrays
 */
function IsArray(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isArray: true
        }
    });
}
exports.IsArray = IsArray;
//# sourceMappingURL=is-array.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-before.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-before.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsBefore = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings before a specific date
 */
function IsBefore(date) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isBefore: date
        }
    });
}
exports.IsBefore = IsBefore;
//# sourceMappingURL=is-before.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-credit-card.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-credit-card.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsCreditCard = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check for valid credit card numbers
 */
function IsCreditCard(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isCreditCard: true
        }
    });
}
exports.IsCreditCard = IsCreditCard;
//# sourceMappingURL=is-credit-card.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-date.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-date.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow date strings
 */
function IsDate(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDate: true
        }
    });
}
exports.IsDate = IsDate;
//# sourceMappingURL=is-date.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-decimal.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-decimal.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsDecimal = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for any numbers
 */
function IsDecimal(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isDecimal: true
        }
    });
}
exports.IsDecimal = IsDecimal;
//# sourceMappingURL=is-decimal.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-email.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-email.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsEmail = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for email format (foo@bar.com)
 */
function IsEmail(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isEmail: true
        }
    });
}
exports.IsEmail = IsEmail;
//# sourceMappingURL=is-email.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-float.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-float.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsFloat = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid floating point numbers
 */
function IsFloat(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isFloat: true
        }
    });
}
exports.IsFloat = IsFloat;
//# sourceMappingURL=is-float.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-in.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-in.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is one of these
 */
function IsIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIn: arg
        }
    });
}
exports.IsIn = IsIn;
//# sourceMappingURL=is-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-int.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-int.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsInt = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for valid integers
 */
function IsInt(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isInt: true
        }
    });
}
exports.IsInt = IsInt;
//# sourceMappingURL=is-int.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv4 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1)
 */
function IsIPv4(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv4: true
        }
    });
}
exports.IsIPv4 = IsIPv4;
//# sourceMappingURL=is-ip-v4.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip-v6.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIPv6 = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv6 format
 */
function IsIPv6(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIPv6: true
        }
    });
}
exports.IsIPv6 = IsIPv6;
//# sourceMappingURL=is-ip-v6.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-ip.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-ip.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsIP = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for IPv4 (129.89.23.1) or IPv6 format
 */
function IsIP(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isIP: true
        }
    });
}
exports.IsIP = IsIP;
//# sourceMappingURL=is-ip.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-lowercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-lowercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsLowercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for lowercase
 */
function IsLowercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isLowercase: true
        }
    });
}
exports.IsLowercase = IsLowercase;
//# sourceMappingURL=is-lowercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-null.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-null.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allows null
 */
function IsNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNull: true
        }
    });
}
exports.IsNull = IsNull;
//# sourceMappingURL=is-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-numeric.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-numeric.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsNumeric = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will only allow numbers
 */
function IsNumeric(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isNumeric: true
        }
    });
}
exports.IsNumeric = IsNumeric;
//# sourceMappingURL=is-numeric.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uppercase.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uppercase.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUppercase = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for uppercase
 */
function IsUppercase(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUppercase: true
        }
    });
}
exports.IsUppercase = IsUppercase;
//# sourceMappingURL=is-uppercase.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUrl = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Checks for url format (http://foo.com)
 */
function IsUrl(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUrl: true
        }
    });
}
exports.IsUrl = IsUrl;
//# sourceMappingURL=is-url.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is-uuid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is-uuid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsUUID = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/*
 * Only allow uuids.
 * Version's regular expressions:
 * https://github.com/chriso/validator.js/blob/b59133b1727b6af355b403a9a97a19226cceb34b/lib/isUUID.js#L14-L19.
 */
function IsUUID(version) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            isUUID: version
        }
    });
}
exports.IsUUID = IsUUID;
//# sourceMappingURL=is-uuid.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/is.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/is.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Is = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function Is(...args) {
    const options = {};
    const argIsFunction = typeof args[0] === 'function';
    if (argIsFunction || (typeof args[0] === 'string' && typeof args[1] === 'function')) {
        let validator;
        let name;
        if (argIsFunction) {
            validator = args[0];
            name = validator.name;
            if (!name)
                throw new Error(`Passed validator function must have a name`);
        }
        else {
            name = args[0];
            validator = args[1];
        }
        options[`is${name.charAt(0).toUpperCase() + name.substr(1, name.length)}`] = validator;
    }
    else {
        options.is = args[0];
    }
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Is = Is;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/length.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Length = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values with length between min and max
 */
function Length({ msg, min, max }) {
    let options;
    const length = [min || 0, max];
    options = msg ? { args: length, msg: msg } : length;
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            len: options
        }
    });
}
exports.Length = Length;
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/max.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/max.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Max = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values <= limit
 */
function Max(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            max: limit
        }
    });
}
exports.Max = Max;
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/min.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/min.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Min = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Only allow values >= limit
 */
function Min(limit) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            min: limit
        }
    });
}
exports.Min = Min;
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-contains.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-contains.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotContains = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Don't allow specific substrings
 */
function NotContains(value) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notContains: value
        }
    });
}
exports.NotContains = NotContains;
//# sourceMappingURL=not-contains.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-empty.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-empty.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotEmpty = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
function NotEmpty(...args) {
    if (args.length === 1) {
        const options = args[0];
        return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: options,
            }
        });
    }
    else {
        const target = args[0];
        const propertyName = args[1];
        attribute_service_1.addAttributeOptions(target, propertyName, {
            validate: {
                notEmpty: true
            }
        });
    }
}
exports.NotEmpty = NotEmpty;
//# sourceMappingURL=not-empty.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-in.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-in.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotIn = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Check the value is not one of these
 */
function NotIn(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notIn: arg
        }
    });
}
exports.NotIn = NotIn;
//# sourceMappingURL=not-in.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not-null.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not-null.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotNull = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Won't allow null
 */
function NotNull(target, propertyName) {
    attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            notNull: true
        }
    });
}
exports.NotNull = NotNull;
//# sourceMappingURL=not-null.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/not.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/not.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Not = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Will not allow values, that match the string regex or real regex
 */
function Not(arg) {
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: {
            not: arg
        }
    });
}
exports.Not = Not;
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validate = void 0;
const attribute_service_1 = __webpack_require__(/*! ../model/column/attribute-service */ "./node_modules/sequelize-typescript/dist/model/column/attribute-service.js");
/**
 * Sets validation options for annotated field
 */
function Validate(options) {
    options = Object.assign({}, options);
    return (target, propertyName) => attribute_service_1.addAttributeOptions(target, propertyName, {
        validate: options
    });
}
exports.Validate = Validate;
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "./node_modules/sequelize-typescript/dist/validation/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize-typescript/dist/validation/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = void 0;
const model_service_1 = __webpack_require__(/*! ../model/shared/model-service */ "./node_modules/sequelize-typescript/dist/model/shared/model-service.js");
const Validator = (target, propertyName, descriptor) => {
    model_service_1.addOptions(target, {
        validate: {
            [propertyName]: descriptor.value
        }
    });
};
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "./node_modules/sequelize/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sequelize/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
  * The entry point.
  *
  * @module Sequelize
  */
module.exports = __webpack_require__(/*! ./lib/sequelize */ "./node_modules/sequelize/lib/sequelize.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/base.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { AssociationError } = __webpack_require__(/*! ./../errors */ "./node_modules/sequelize/lib/errors/index.js");

/**
 * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).
 *
 * * hasOne - adds a foreign key to the target and singular association mixins to the source.
 * * belongsTo - add a foreign key and singular association mixins to the source.
 * * hasMany - adds a foreign key to target and plural association mixins to the source.
 * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.
 *
 * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.
 *
 * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.
 *
 * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.
 *
 * ```js
 * User.hasMany(Picture)
 * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })
 *
 * user.getPictures() // gets you all pictures
 * user.getProfilePicture() // gets you only the profile picture
 *
 * User.findAll({
 *   where: ...,
 *   include: [
 *     { model: Picture }, // load all pictures
 *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture.
 *     // Notice that the spelling must be the exact same as the one in the association
 *   ]
 * })
 * ```
 * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,
 * equivalent to those passed to `sequelize.define`.
 *
 * ```js
 * User.hasMany(Picture, { foreignKey: 'uid' })
 * ```
 *
 * The foreign key column in Picture will now be called `uid` instead of the default `userId`.
 *
 * ```js
 * User.hasMany(Picture, {
 *   foreignKey: {
 *     name: 'uid',
 *     allowNull: false
 *   }
 * })
 * ```
 *
 * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).
 *
 * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:
 *
 * ```js
 * user.getPictures({
 *   where: {
 *     format: 'jpg'
 *   }
 * })
 * ```
 *
 * There are several ways to update and add new associations. Continuing with our example of users and pictures:
 * ```js
 * user.addPicture(p) // Add a single picture
 * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted
 * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations
 * ```
 *
 * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:
 *
 * ```js
 * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture
 * ```
 *
 * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.
 *
 * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.
 */
class Association {
  constructor(source, target, options = {}) {
    /**
     * @type {Model}
     */
    this.source = source;

    /**
     * @type {Model}
     */
    this.target = target;

    this.options = options;
    this.scope = options.scope;
    this.isSelfAssociation = this.source === this.target;
    this.as = options.as;

    /**
     * The type of the association. One of `HasMany`, `BelongsTo`, `HasOne`, `BelongsToMany`
     *
     * @type {string}
     */
    this.associationType = '';

    if (source.hasAlias(options.as)) {
      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. ` +
      'Aliased associations must have unique aliases.'
      );
    }
  }

  /**
   * Normalize input
   *
   * @param {Array|string} input it may be array or single obj, instance or primary key
   *
   * @private
   * @returns {Array} built objects
   */
  toInstanceArray(input) {
    if (!Array.isArray(input)) {
      input = [input];
    }

    return input.map(element => {
      if (element instanceof this.target) return element;

      const tmpInstance = {};
      tmpInstance[this.target.primaryKeyAttribute] = element;

      return this.target.build(tmpInstance, { isNewRecord: false });
    });
  }

  [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.as;
  }
}

module.exports = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const AssociationError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").AssociationError;
const EmptyResultError = __webpack_require__(/*! ../errors */ "./node_modules/sequelize/lib/errors/index.js").EmptyResultError;
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * Many-to-many association with a join table.
 *
 * When the join table has additional attributes, these can be passed in the options object:
 *
 * ```js
 * UserProject = sequelize.define('user_project', {
 *   role: Sequelize.STRING
 * });
 * User.belongsToMany(Project, { through: UserProject });
 * Project.belongsToMany(User, { through: UserProject });
 * // through is required!
 *
 * user.addProject(project, { through: { role: 'manager' }});
 * ```
 *
 * All methods allow you to pass either a persisted instance, its primary key, or a mixture:
 *
 * ```js
 * const project = await Project.create({ id: 11 });
 * await user.addProjects([project, 12]);
 * ```
 *
 * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:
 *
 * ```js
 * p1.UserProjects = {
 *   started: true
 * }
 * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.
 * ```
 *
 * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.
 * ```js
 * const projects = await user.getProjects();
 * const p1 = projects[0];
 * p1.UserProjects.started // Is this project started yet?
 * })
 * ```
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.
 *
 * @see {@link Model.belongsToMany}
 */
class BelongsToMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {
      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);
    }

    if (!this.options.through.model) {
      this.options.through = {
        model: options.through
      };
    }

    this.associationType = 'BelongsToMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.through = { ...this.options.through };
    this.isMultiAssociation = true;
    this.doubleLinked = false;

    if (!this.as && this.isSelfAssociation) {
      throw new AssociationError('\'as\' must be defined for many-to-many self-associations');
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    this.combinedTableName = Utils.combineTableNames(
      this.source.tableName,
      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName
    );

    /*
    * If self association, this is the target association - Unless we find a pairing association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    /*
    * Find paired association (if exists)
    */
    _.each(this.target.associations, association => {
      if (association.associationType !== 'BelongsToMany') return;
      if (association.target !== this.source) return;

      if (this.options.through.model === association.options.through.model) {
        this.paired = association;
        association.paired = this;
      }
    });

    /*
    * Default/generated source/target keys
    */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    if (this.options.targetKey) {
      this.targetKey = this.options.targetKey;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    } else {
      this.targetKeyDefault = true;
      this.targetKey = this.target.primaryKeyAttribute;
      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    }

    this._createForeignAndOtherKeys();

    if (typeof this.through.model === 'string') {
      if (!this.sequelize.isDefined(this.through.model)) {
        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {
          tableName: this.through.model,
          indexes: [], //we don't want indexes here (as referenced in #2416)
          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)
          validate: {} // Don't propagate model-level validations
        }));
      } else {
        this.through.model = this.sequelize.model(this.through.model);
      }
    }

    Object.assign(this.options, _.pick(this.through.model.options, [
      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'
    ]));

    if (this.paired) {
      let needInjectPaired = false;

      if (this.targetKeyDefault) {
        this.targetKey = this.paired.sourceKey;
        this.targetKeyField = this.paired.sourceKeyField;
        this._createForeignAndOtherKeys();
      }
      if (this.paired.targetKeyDefault) {
        // in this case paired.otherKey depends on paired.targetKey,
        // so cleanup previously wrong generated otherKey
        if (this.paired.targetKey !== this.sourceKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.targetKey = this.sourceKey;
          this.paired.targetKeyField = this.sourceKeyField;
          this.paired._createForeignAndOtherKeys();
          needInjectPaired = true;
        }
      }

      if (this.otherKeyDefault) {
        this.otherKey = this.paired.foreignKey;
      }
      if (this.paired.otherKeyDefault) {
        // If paired otherKey was inferred we should make sure to clean it up
        // before adding a new one that matches the foreignKey
        if (this.paired.otherKey !== this.foreignKey) {
          delete this.through.model.rawAttributes[this.paired.otherKey];
          this.paired.otherKey = this.foreignKey;
          needInjectPaired = true;
        }
      }

      if (needInjectPaired) {
        this.paired._injectAttributes();
      }
    }

    if (this.through) {
      this.throughModel = this.through.model;
    }

    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;

    this.associationAccessor = this.as;

    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  _createForeignAndOtherKeys() {
    /*
    * Default/generated foreign/other keys
    */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else {
      this.foreignKeyAttribute = {};
      this.foreignKey = this.options.foreignKey || Utils.camelize(
        [
          this.source.options.name.singular,
          this.sourceKey
        ].join('_')
      );
    }

    if (_.isObject(this.options.otherKey)) {
      this.otherKeyAttribute = this.options.otherKey;
      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;
    } else {
      if (!this.options.otherKey) {
        this.otherKeyDefault = true;
      }

      this.otherKeyAttribute = {};
      this.otherKey = this.options.otherKey || Utils.camelize(
        [
          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,
          this.targetKey
        ].join('_')
      );
    }
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    this.identifier = this.foreignKey;
    this.foreignIdentifier = this.otherKey;

    // remove any PKs previously defined by sequelize
    // but ignore any keys that are part of this association (#5865)
    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {
      if (attribute.primaryKey === true && attribute._autoGenerated === true) {
        if (attributeName === this.foreignKey || attributeName === this.otherKey) {
          // this key is still needed as it's part of the association
          // so just set primaryKey to false
          attribute.primaryKey = false;
        }
        else {
          delete this.through.model.rawAttributes[attributeName];
        }
        this.primaryKeyDeleted = true;
      }
    });

    const sourceKey = this.source.rawAttributes[this.sourceKey];
    const sourceKeyType = sourceKey.type;
    const sourceKeyField = this.sourceKeyField;
    const targetKey = this.target.rawAttributes[this.targetKey];
    const targetKeyType = targetKey.type;
    const targetKeyField = this.targetKeyField;
    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };
    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };

    if (this.primaryKeyDeleted === true) {
      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;
    } else if (this.through.unique !== false) {
      let uniqueKey;
      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {
        uniqueKey = this.options.uniqueKey;
      } else {
        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');
      }
      targetAttribute.unique = sourceAttribute.unique = uniqueKey;
    }

    if (!this.through.model.rawAttributes[this.foreignKey]) {
      this.through.model.rawAttributes[this.foreignKey] = {
        _autoGenerated: true
      };
    }

    if (!this.through.model.rawAttributes[this.otherKey]) {
      this.through.model.rawAttributes[this.otherKey] = {
        _autoGenerated: true
      };
    }

    if (this.options.constraints !== false) {
      sourceAttribute.references = {
        model: this.source.getTableName(),
        key: sourceKeyField
      };
      // For the source attribute the passed option is the priority
      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;
      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;

      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';
      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';

      targetAttribute.references = {
        model: this.target.getTableName(),
        key: targetKeyField
      };
      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)
      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;
      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;

      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';
      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';
    }

    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);
    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);

    this.through.model.refreshAttributes();

    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;

    if (this.paired && !this.paired.foreignIdentifierField) {
      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;
    }

    this.toSource = new BelongsTo(this.through.model, this.source, {
      foreignKey: this.foreignKey
    });
    this.manyFromSource = new HasMany(this.source, this.through.model, {
      foreignKey: this.foreignKey
    });
    this.oneFromSource = new HasOne(this.source, this.through.model, {
      foreignKey: this.foreignKey,
      sourceKey: this.sourceKey,
      as: this.through.model.name
    });

    this.toTarget = new BelongsTo(this.through.model, this.target, {
      foreignKey: this.otherKey
    });
    this.manyFromTarget = new HasMany(this.target, this.through.model, {
      foreignKey: this.otherKey
    });
    this.oneFromTarget = new HasOne(this.target, this.through.model, {
      foreignKey: this.otherKey,
      sourceKey: this.targetKey,
      as: this.through.model.name
    });

    if (this.paired && this.paired.otherKeyDefault) {
      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {
        foreignKey: this.paired.otherKey
      });

      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {
        foreignKey: this.paired.otherKey,
        sourceKey: this.paired.targetKey,
        as: this.paired.through.model.name
      });
    }

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @see
   * {@link Model} for a full explanation of options
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   * @param {object} [options.through.where] An optional where clause applied to through model (join table)
   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instance, options) {
    options = Utils.cloneDeep(options) || {};

    const through = this.through;
    let scopeWhere;
    let throughWhere;

    if (this.scope) {
      scopeWhere = { ...this.scope };
    }

    options.where = {
      [Op.and]: [
        scopeWhere,
        options.where
      ]
    };

    if (Object(through.model) === through.model) {
      throughWhere = {};
      throughWhere[this.foreignKey] = instance.get(this.sourceKey);

      if (through.scope) {
        Object.assign(throughWhere, through.scope);
      }

      //If a user pass a where on the options through options, make an "and" with the current throughWhere
      if (options.through && options.through.where) {
        throughWhere = {
          [Op.and]: [throughWhere, options.through.where]
        };
      }

      options.include = options.include || [];
      options.include.push({
        association: this.oneFromTarget,
        attributes: options.joinTableAttributes,
        required: true,
        paranoid: _.get(options.through, 'paranoid', true),
        where: throughWhere
      });
    }

    let model = this.target;
    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        model = model.unscoped();
      } else {
        model = model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      model = model.schema(options.schema, options.schemaDelimiter);
    }

    return model.findAll(options);
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model} instance instance
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    const sequelize = this.target.sequelize;

    options = Utils.cloneDeep(options);
    options.attributes = [
      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']
    ];
    options.joinTableAttributes = [];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated
   *
   * @param {Model} sourceInstance source instance to check for an association with
   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise<boolean>}
   */
  async has(sourceInstance, instances, options) {
    if (!Array.isArray(instances)) {
      instances = [instances];
    }

    options = {
      raw: true,
      ...options,
      scope: false,
      attributes: [this.targetKey],
      joinTableAttributes: []
    };

    const instancePrimaryKeys = instances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.targetKey]: instance
      };
    });

    options.where = {
      [Op.and]: [
        { [Op.or]: instancePrimaryKeys },
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return _.differenceWith(instancePrimaryKeys, associatedObjects,
      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;
  }

  /**
   * Set the associated models by passing an array of instances or their primary keys.
   * Everything that it not in the passed array will be un-associated.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`
   * @param {object} [options.validate] Run validation for the join model
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async set(sourceInstance, newAssociatedObjects, options) {
    options = options || {};

    const sourceKey = this.sourceKey;
    const targetKey = this.targetKey;
    const identifier = this.identifier;
    const foreignIdentifier = this.foreignIdentifier;

    if (newAssociatedObjects === null) {
      newAssociatedObjects = [];
    } else {
      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);
    }
    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      ...this.through.scope
    };

    const updateAssociations = currentRows => {
      const obsoleteAssociations = [];
      const promises = [];
      const defaultAttributes = options.through || {};

      const unassociatedObjects = newAssociatedObjects.filter(obj =>
        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))
      );

      for (const currentRow of currentRows) {
        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));

        if (!newObj) {
          obsoleteAssociations.push(currentRow);
        } else {
          let throughAttributes = newObj[this.through.model.name];
          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
          if (throughAttributes instanceof this.through.model) {
            throughAttributes = {};
          }

          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).length) {
            promises.push(
              this.through.model.update(attributes, Object.assign(options, {
                where: {
                  [identifier]: sourceInstance.get(sourceKey),
                  [foreignIdentifier]: newObj.get(targetKey)
                }
              }
              ))
            );
          }
        }
      }

      if (obsoleteAssociations.length > 0) {
        promises.push(
          this.through.model.destroy({
            ...options,
            where: {
              [identifier]: sourceInstance.get(sourceKey),
              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),
              ...this.through.scope
            }
          })
        );
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          return {
            ...defaultAttributes,
            ...unassociatedObject[this.through.model.name],
            [identifier]: sourceInstance.get(sourceKey),
            [foreignIdentifier]: unassociatedObject.get(targetKey),
            ...this.through.scope
          };
        });

        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });
      return await updateAssociations(currentRows);
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations([]);
      throw error;
    }
  }

  /**
   * Associate one or several rows with source instance. It will not un-associate any already associated instance
   * that may be missing from `newInstances`.
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`
   * @param {object} [options.validate] Run validation for the join model.
   * @param {object} [options.through] Additional attributes for the join table.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, newInstances, options) {
    // If newInstances is null or undefined, no-op
    if (!newInstances) return Promise.resolve();

    options = { ...options };

    const association = this;
    const sourceKey = association.sourceKey;
    const targetKey = association.targetKey;
    const identifier = association.identifier;
    const foreignIdentifier = association.foreignIdentifier;
    const defaultAttributes = options.through || {};

    newInstances = association.toInstanceArray(newInstances);

    const where = {
      [identifier]: sourceInstance.get(sourceKey),
      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),
      ...association.through.scope
    };

    const updateAssociations = currentRows => {
      const promises = [];
      const unassociatedObjects = [];
      const changedAssociations = [];
      for (const obj of newInstances) {
        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));

        if (!existingAssociation) {
          unassociatedObjects.push(obj);
        } else {
          const throughAttributes = obj[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {
            changedAssociations.push(obj);
          }
        }
      }

      if (unassociatedObjects.length > 0) {
        const bulk = unassociatedObjects.map(unassociatedObject => {
          const throughAttributes = unassociatedObject[association.through.model.name];
          const attributes = { ...defaultAttributes, ...throughAttributes };

          attributes[identifier] = sourceInstance.get(sourceKey);
          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);

          Object.assign(attributes, association.through.scope);

          return attributes;
        });

        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));
      }

      for (const assoc of changedAssociations) {
        let throughAttributes = assoc[association.through.model.name];
        const attributes = { ...defaultAttributes, ...throughAttributes };
        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)
        if (throughAttributes instanceof association.through.model) {
          throughAttributes = {};
        }

        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {
          [identifier]: sourceInstance.get(sourceKey),
          [foreignIdentifier]: assoc.get(targetKey)
        } })));
      }

      return Promise.all(promises);
    };

    try {
      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });
      const [associations] = await updateAssociations(currentRows);
      return associations;
    } catch (error) {
      if (error instanceof EmptyResultError) return updateAssociations();
      throw error;
    }
  }

  /**
   * Un-associate one or more instance(s).
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `through.destroy`
   *
   * @returns {Promise}
   */
  remove(sourceInstance, oldAssociatedObjects, options) {
    const association = this;

    options = options || {};

    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);

    const where = {
      [association.identifier]: sourceInstance.get(association.sourceKey),
      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))
    };

    return association.through.model.destroy({ ...options, where });
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model
   * @param {object} [options] Options passed to create and add
   * @param {object} [options.through] Additional attributes for the join table
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options) {
    const association = this;

    options = options || {};
    values = values || {};

    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (association.scope) {
      Object.assign(values, association.scope);
      if (options.fields) {
        options.fields = options.fields.concat(Object.keys(association.scope));
      }
    }

    // Create the related model instance
    const newAssociatedObject = await association.target.create(values, options);

    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));
    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsToMany;
module.exports.BelongsToMany = BelongsToMany;
module.exports.default = BelongsToMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/belongs-to.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.
 *
 * @see {@link Model.belongsTo}
 */
class BelongsTo extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'BelongsTo';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.as,
          this.target.primaryKeyAttribute
        ].join('_')
      );
    }

    this.identifier = this.foreignKey;
    if (this.source.rawAttributes[this.identifier]) {
      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;
    }

    if (
      this.options.targetKey
      && !this.target.rawAttributes[this.options.targetKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.targetKey}" passed as targetKey, define this attribute on model "${this.target.name}" first`);
    }

    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;
    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;
    this.targetIdentifier = this.targetKey;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the source table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);
    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);

    this.source.refreshAttributes();

    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.
   * @param {string}         [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};
    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.targetKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))
      };
    } else {
      if (this.targetKeyIsPrimary && !options.where) {
        return Target.findByPk(instance.get(this.foreignKey), options);
      }
      where[this.targetKey] = instance.get(this.foreignKey);
      options.limit = null;
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.foreignKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.targetKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options={}] options passed to `this.save`
   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.
   *
   *  @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options = {}) {
    let value = associatedInstance;

    if (associatedInstance instanceof this.target) {
      value = associatedInstance[this.targetKey];
    }

    sourceInstance.set(this.foreignKey, value);

    if (options.save === false) return;

    options = {
      fields: [this.foreignKey],
      allowNull: [this.foreignKey],
      association: true,
      ...options
    };

    // passes the changed field to save, so only that field get updated.
    return await sourceInstance.save(options);
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options={}] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create}  for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    const newAssociatedObject = await this.target.create(values, options);
    await sourceInstance[this.accessors.set](newAssociatedObject, options);

    return newAssociatedObject;
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = BelongsTo;
module.exports.BelongsTo = BelongsTo;
module.exports.default = BelongsTo;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-many.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-many.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-many association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.
 * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.
 *
 * @see {@link Model.hasMany}
 */
class HasMany extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasMany';
    this.targetAssociation = null;
    this.sequelize = source.sequelize;
    this.isMultiAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.options.through) {
      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');
    }

    /*
    * If self association, this is the target association
    */
    if (this.isSelfAssociation) {
      this.targetAssociation = this;
    }

    if (this.as) {
      this.isAliased = true;

      if (_.isPlainObject(this.as)) {
        this.options.name = this.as;
        this.as = this.as.plural;
      } else {
        this.options.name = {
          plural: this.as,
          singular: Utils.singularize(this.as)
        };
      }
    } else {
      this.as = this.target.options.name.plural;
      this.options.name = this.target.options.name;
    }

    /*
     * Foreign key setup
     */
    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          this.source.options.name.singular,
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    /*
     * Source key setup
     */
    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;

    if (this.source.rawAttributes[this.sourceKey]) {
      this.sourceKeyAttribute = this.sourceKey;
      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    } else {
      this.sourceKeyAttribute = this.source.primaryKeyAttribute;
      this.sourceKeyField = this.source.primaryKeyField;
    }

    // Get singular and plural names
    // try to uppercase the first letter, unless the model forbids it
    const plural = _.upperFirst(this.options.name.plural);
    const singular = _.upperFirst(this.options.name.singular);

    this.associationAccessor = this.as;
    this.accessors = {
      get: `get${plural}`,
      set: `set${plural}`,
      addMultiple: `add${plural}`,
      add: `add${singular}`,
      create: `create${singular}`,
      remove: `remove${singular}`,
      removeMultiple: `remove${plural}`,
      hasSingle: `has${singular}`,
      hasAll: `has${plural}`,
      count: `count${plural}`
    };
  }

  // the id is in the target table
  // or in an extra table which connects two tables
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m
    const constraintOptions = { ...this.options };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();
    this.source.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];
    const aliases = {
      hasSingle: 'has',
      hasAll: 'has',
      addMultiple: 'add',
      removeMultiple: 'remove'
    };

    Helpers.mixinMethods(this, obj, methods, aliases);
  }

  /**
   * Get everything currently associated with this, using an optional where clause.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object} [options] find options
   * @param {object} [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findAll}  for a full explanation of options
   *
   * @returns {Promise<Array<Model>>}
   */
  async get(instances, options = {}) {
    const where = {};

    let Model = this.target;
    let instance;
    let values;

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    options = { ...options };

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    if (instances) {
      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));

      if (options.limit && instances.length > 1) {
        options.groupedLimit = {
          limit: options.limit,
          on: this, // association
          values
        };

        delete options.limit;
      } else {
        where[this.foreignKey] = {
          [Op.in]: values
        };
        delete options.groupedLimit;
      }
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Model = Model.unscoped();
      } else {
        Model = Model.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Model = Model.schema(options.schema, options.schemaDelimiter);
    }

    const results = await Model.findAll(options);
    if (instance) return results;

    const result = {};
    for (const _instance of instances) {
      result[_instance.get(this.sourceKey, { raw: true })] = [];
    }

    for (const _instance of results) {
      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);
    }

    return result;
  }

  /**
   * Count everything currently associated with this, using an optional where clause.
   *
   * @param {Model}        instance the source instance
   * @param {object}         [options] find & count options
   * @param {object}         [options.where] An optional where clause to limit the associated models
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   *
   * @returns {Promise<number>}
   */
  async count(instance, options) {
    options = Utils.cloneDeep(options);

    options.attributes = [
      [
        this.sequelize.fn(
          'COUNT',
          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)
        ),
        'count'
      ]
    ];
    options.raw = true;
    options.plain = true;

    const result = await this.get(instance, options);

    return parseInt(result.count, 10);
  }

  /**
   * Check if one or more rows are associated with `this`.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys
   * @param {object} [options] Options passed to getAssociations
   *
   * @returns {Promise}
   */
  async has(sourceInstance, targetInstances, options) {
    const where = {};

    if (!Array.isArray(targetInstances)) {
      targetInstances = [targetInstances];
    }

    options = {
      ...options,
      scope: false,
      attributes: [this.target.primaryKeyAttribute],
      raw: true
    };

    where[Op.or] = targetInstances.map(instance => {
      if (instance instanceof this.target) {
        return instance.where();
      }
      return {
        [this.target.primaryKeyAttribute]: instance
      };
    });

    options.where = {
      [Op.and]: [
        where,
        options.where
      ]
    };

    const associatedObjects = await this.get(sourceInstance, options);

    return associatedObjects.length === targetInstances.length;
  }

  /**
   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated
   *
   * @param {Model} sourceInstance source instance to associate new instances with
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.
   * @param {object} [options] Options passed to `target.findAll` and `update`.
   * @param {object} [options.validate] Run validation for the join model
   *
   * @returns {Promise}
   */
  async set(sourceInstance, targetInstances, options) {
    if (targetInstances === null) {
      targetInstances = [];
    } else {
      targetInstances = this.toInstanceArray(targetInstances);
    }

    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });
    const promises = [];
    const obsoleteAssociations = oldAssociations.filter(old =>
      !targetInstances.find(obj =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    const unassociatedObjects = targetInstances.filter(obj =>
      !oldAssociations.find(old =>
        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]
      )
    );
    let updateWhere;
    let update;

    if (obsoleteAssociations.length > 0) {
      update = {};
      update[this.foreignKey] = null;

      updateWhere = {
        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>
          associatedObject[this.target.primaryKeyAttribute]
        )
      };


      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    if (unassociatedObjects.length > 0) {
      updateWhere = {};

      update = {};
      update[this.foreignKey] = sourceInstance.get(this.sourceKey);

      Object.assign(update, this.scope);
      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>
        unassociatedObject[this.target.primaryKeyAttribute]
      );

      promises.push(this.target.unscoped().update(
        update,
        {
          ...options,
          where: updateWhere
        }
      ));
    }

    await Promise.all(promises);

    return sourceInstance;
  }

  /**
   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,
   * or a mixed array of Model / string / numbers to associate multiple rows.
   *
   * @param {Model} sourceInstance the source instance
   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys
   * @param {object} [options] Options passed to `target.update`.
   *
   * @returns {Promise}
   */
  async add(sourceInstance, targetInstances, options = {}) {
    if (!targetInstances) return Promise.resolve();


    targetInstances = this.toInstanceArray(targetInstances);

    const update = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      ...this.scope
    };

    const where = {
      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>
        unassociatedObject.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return sourceInstance;
  }

  /**
   * Un-associate one or several target rows.
   *
   * @param {Model} sourceInstance instance to un associate instances with
   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys
   * @param {object} [options] Options passed to `target.update`
   *
   * @returns {Promise}
   */
  async remove(sourceInstance, targetInstances, options = {}) {
    const update = {
      [this.foreignKey]: null
    };

    targetInstances = this.toInstanceArray(targetInstances);

    const where = {
      [this.foreignKey]: sourceInstance.get(this.sourceKey),
      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>
        targetInstance.get(this.target.primaryKeyAttribute)
      )
    };

    await this.target.unscoped().update(update, { ...options, where });

    return this;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance source instance
   * @param {object} [values] values for target model instance
   * @param {object} [options] Options passed to `target.create`
   *
   * @returns {Promise}
   */
  async create(sourceInstance, values, options = {}) {
    if (Array.isArray(options)) {
      options = {
        fields: options
      };
    }

    if (values === undefined) {
      values = {};
    }

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) options.fields.push(attribute);
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKey);
    if (options.fields) options.fields.push(this.foreignKey);
    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.plural) {
      return this.as === alias.plural;
    }

    return !this.isAliased;
  }
}

module.exports = HasMany;
module.exports.HasMany = HasMany;
module.exports.default = HasMany;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/has-one.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-one.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ./../utils */ "./node_modules/sequelize/lib/utils.js");
const Helpers = __webpack_require__(/*! ./helpers */ "./node_modules/sequelize/lib/associations/helpers.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");
const Op = __webpack_require__(/*! ../operators */ "./node_modules/sequelize/lib/operators.js");

/**
 * One-to-one association
 *
 * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.
 * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.
 *
 * @see {@link Model.hasOne}
 */
class HasOne extends Association {
  constructor(source, target, options) {
    super(source, target, options);

    this.associationType = 'HasOne';
    this.isSingleAssociation = true;
    this.foreignKeyAttribute = {};

    if (this.as) {
      this.isAliased = true;
      this.options.name = {
        singular: this.as
      };
    } else {
      this.as = this.target.options.name.singular;
      this.options.name = this.target.options.name;
    }

    if (_.isObject(this.options.foreignKey)) {
      this.foreignKeyAttribute = this.options.foreignKey;
      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
    } else if (this.options.foreignKey) {
      this.foreignKey = this.options.foreignKey;
    }

    if (!this.foreignKey) {
      this.foreignKey = Utils.camelize(
        [
          Utils.singularize(this.options.as || this.source.name),
          this.source.primaryKeyAttribute
        ].join('_')
      );
    }

    if (
      this.options.sourceKey
      && !this.source.rawAttributes[this.options.sourceKey]
    ) {
      throw new Error(`Unknown attribute "${this.options.sourceKey}" passed as sourceKey, define this attribute on model "${this.source.name}" first`);
    }

    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;
    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;

    this.associationAccessor = this.as;
    this.options.useHooks = options.useHooks;

    if (this.target.rawAttributes[this.foreignKey]) {
      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
    }

    // Get singular name, trying to uppercase the first letter, unless the model forbids it
    const singular = _.upperFirst(this.options.name.singular);

    this.accessors = {
      get: `get${singular}`,
      set: `set${singular}`,
      create: `create${singular}`
    };
  }

  // the id is in the target table
  _injectAttributes() {
    const newAttributes = {
      [this.foreignKey]: {
        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,
        allowNull: true,
        ...this.foreignKeyAttribute
      }
    };

    if (this.options.constraints !== false) {
      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');
      this.options.onUpdate = this.options.onUpdate || 'CASCADE';
    }

    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);
    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);

    this.target.refreshAttributes();

    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;

    Helpers.checkNamingCollision(this);

    return this;
  }

  mixin(obj) {
    const methods = ['get', 'set', 'create'];

    Helpers.mixinMethods(this, obj, methods);
  }

  /**
   * Get the associated instance.
   *
   * @param {Model|Array<Model>} instances source instances
   * @param {object}         [options] find options
   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false
   * @param {string} [options.schema] Apply a schema on the related model
   *
   * @see
   * {@link Model.findOne} for a full explanation of options
   *
   * @returns {Promise<Model>}
   */
  async get(instances, options) {
    const where = {};

    let Target = this.target;
    let instance;

    options = Utils.cloneDeep(options);

    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {
      if (!options.scope) {
        Target = Target.unscoped();
      } else {
        Target = Target.scope(options.scope);
      }
    }

    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {
      Target = Target.schema(options.schema, options.schemaDelimiter);
    }

    if (!Array.isArray(instances)) {
      instance = instances;
      instances = undefined;
    }

    if (instances) {
      where[this.foreignKey] = {
        [Op.in]: instances.map(_instance => _instance.get(this.sourceKey))
      };
    } else {
      where[this.foreignKey] = instance.get(this.sourceKey);
    }

    if (this.scope) {
      Object.assign(where, this.scope);
    }

    options.where = options.where ?
      { [Op.and]: [where, options.where] } :
      where;

    if (instances) {
      const results = await Target.findAll(options);
      const result = {};
      for (const _instance of instances) {
        result[_instance.get(this.sourceKey, { raw: true })] = null;
      }

      for (const _instance of results) {
        result[_instance.get(this.foreignKey, { raw: true })] = _instance;
      }

      return result;
    }

    return Target.findOne(options);
  }

  /**
   * Set the associated model.
   *
   * @param {Model} sourceInstance the source instance
   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.
   * @param {object} [options] Options passed to getAssociation and `target.save`
   *
   * @returns {Promise}
   */
  async set(sourceInstance, associatedInstance, options) {
    options = { ...options, scope: false };

    const oldInstance = await sourceInstance[this.accessors.get](options);
    // TODO Use equals method once #5605 is resolved
    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>
      oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)
    );

    if (oldInstance && !alreadyAssociated) {
      oldInstance[this.foreignKey] = null;

      await oldInstance.save({
        ...options,
        fields: [this.foreignKey],
        allowNull: [this.foreignKey],
        association: true
      });
    }
    if (associatedInstance && !alreadyAssociated) {
      if (!(associatedInstance instanceof this.target)) {
        const tmpInstance = {};
        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;
        associatedInstance = this.target.build(tmpInstance, {
          isNewRecord: false
        });
      }

      Object.assign(associatedInstance, this.scope);
      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));

      return associatedInstance.save(options);
    }

    return null;
  }

  /**
   * Create a new instance of the associated model and associate it with this.
   *
   * @param {Model} sourceInstance the source instance
   * @param {object} [values={}] values to create associated model instance with
   * @param {object} [options] Options passed to `target.create` and setAssociation.
   *
   * @see
   * {@link Model#create} for a full explanation of options
   *
   * @returns {Promise<Model>} The created target model
   */
  async create(sourceInstance, values, options) {
    values = values || {};
    options = options || {};

    if (this.scope) {
      for (const attribute of Object.keys(this.scope)) {
        values[attribute] = this.scope[attribute];
        if (options.fields) {
          options.fields.push(attribute);
        }
      }
    }

    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);
    if (options.fields) {
      options.fields.push(this.foreignKey);
    }

    return await this.target.create(values, options);
  }

  verifyAssociationAlias(alias) {
    if (typeof alias === 'string') {
      return this.as === alias;
    }

    if (alias && alias.singular) {
      return this.as === alias.singular;
    }

    return !this.isAliased;
  }
}

module.exports = HasOne;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function checkNamingCollision(association) {
  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {
    throw new Error(
      `Naming collision between attribute '${association.as}'` +
      ` and association '${association.as}' on model ${association.source.name}` +
      '. To remedy this, change either foreignKey or as in your association definition'
    );
  }
}
exports.checkNamingCollision = checkNamingCollision;

function addForeignKeyConstraints(newAttribute, source, target, options, key) {
  // FK constraints are opt-in: users must either set `foreignKeyConstraints`
  // on the association, or request an `onDelete` or `onUpdate` behavior

  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {
    // Find primary keys: composite keys not supported with this approach
    const primaryKeys = Object.keys(source.primaryKeys)
      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);

    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {
      newAttribute.references = {
        model: source.getTableName(),
        key: key || primaryKeys[0]
      };

      newAttribute.onDelete = options.onDelete;
      newAttribute.onUpdate = options.onUpdate;
    }
  }
}
exports.addForeignKeyConstraints = addForeignKeyConstraints;

/**
 * Mixin (inject) association methods to model prototype
 *
 * @private
 *
 * @param {object} association instance
 * @param {object} obj Model prototype
 * @param {Array} methods Method names to inject
 * @param {object} aliases Mapping between model and association method names
 *
 */
function mixinMethods(association, obj, methods, aliases) {
  aliases = aliases || {};

  for (const method of methods) {
    // don't override custom methods
    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {
      const realMethod = aliases[method] || method;

      obj[association.accessors[method]] = function() {
        return association[realMethod](this, ...Array.from(arguments));
      };
    }
  }
}
exports.mixinMethods = mixinMethods;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Association = __webpack_require__(/*! ./base */ "./node_modules/sequelize/lib/associations/base.js");

Association.BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
Association.HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
Association.HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
Association.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");

module.exports = Association;
module.exports.default = Association;
module.exports.Association = Association;


/***/ }),

/***/ "./node_modules/sequelize/lib/associations/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/mixin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const HasOne = __webpack_require__(/*! ./has-one */ "./node_modules/sequelize/lib/associations/has-one.js");
const HasMany = __webpack_require__(/*! ./has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const BelongsTo = __webpack_require__(/*! ./belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");

function isModel(model, sequelize) {
  return model
    && model.prototype
    && model.prototype instanceof sequelize.Sequelize.Model;
}

const Mixin = {
  hasMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    Object.assign(options, _.omit(source.options, ['hooks']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);
    }

    // the id is in the foreign table or in a connecting table
    const association = new HasMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);
    }

    return association;
  },

  belongsToMany(target, options = {}) {
    if (!isModel(target, this.sequelize)) {
      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);
    }

    const source = this;

    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;
    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;
    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));

    if (options.useHooks) {
      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);
    }
    // the id is in the foreign table or in a connecting table
    const association = new BelongsToMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);
    }

    return association;
  },

  getAssociations(target) {
    return Object.values(this.associations).filter(association => association.target.name === target.name);
  },

  getAssociationForAlias(target, alias) {
    // Two associations cannot have the same alias, so we can use find instead of filter
    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;
  }
};

// The logic for hasOne and belongsTo is exactly the same
function singleLinked(Type) {
  return function(target, options = {}) {
    // eslint-disable-next-line no-invalid-this
    const source = this;
    if (!isModel(target, source.sequelize)) {
      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);
    }


    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)
    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    if (options.useHooks) {
      source.runHooks('beforeAssociate', { source, target, type: Type }, options);
    }
    // the id is in the foreign table
    const association = new Type(source, target, Object.assign(options, source.options));
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();
    association.mixin(source.prototype);

    if (options.useHooks) {
      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);
    }

    return association;
  };
}

Mixin.hasOne = singleLinked(HasOne);
Mixin.belongsTo = singleLinked(BelongsTo);

module.exports = Mixin;
module.exports.Mixin = Mixin;
module.exports.default = Mixin;


/***/ }),

/***/ "./node_modules/sequelize/lib/data-types.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/data-types.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const moment = __webpack_require__(/*! moment */ "moment");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const warnings = {};
const { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js");
const { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js");

class ABSTRACT {
  toString(options) {
    return this.toSql(options);
  }
  toSql() {
    return this.key;
  }
  stringify(value, options) {
    if (this._stringify) {
      return this._stringify(value, options);
    }
    return value;
  }
  bindParam(value, options) {
    if (this._bindParam) {
      return this._bindParam(value, options);
    }
    return options.bindParam(this.stringify(value, options));
  }
  static toString() {
    return this.name;
  }
  static warn(link, text) {
    if (!warnings[text]) {
      warnings[text] = true;
      logger.warn(`${text} \n>> Check: ${link}`);
    }
  }
  static extend(oldType) {
    return new this(oldType.options);
  }
}

ABSTRACT.prototype.dialectTypes = '';

/**
 * STRING A variable length string
 */
class STRING extends ABSTRACT {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super();
    const options = typeof length === 'object' && length || { length, binary };
    this.options = options;
    this._binary = options.binary;
    this._length = options.length || 255;
  }
  toSql() {
    return joinSQLFragments([
      `VARCHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
  validate(value) {
    if (Object.prototype.toString.call(value) !== '[object String]') {
      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {
        return true;
      }
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }

  get BINARY() {
    this._binary = true;
    this.options.binary = true;
    return this;
  }

  static get BINARY() {
    return new this().BINARY;
  }
}

/**
 * CHAR A fixed length string
 */
class CHAR extends STRING {
  /**
   * @param {number} [length=255] length of string
   * @param {boolean} [binary=false] Is this binary?
   */
  constructor(length, binary) {
    super(typeof length === 'object' && length || { length, binary });
  }
  toSql() {
    return joinSQLFragments([
      `CHAR(${this._length})`,
      this._binary && 'BINARY'
    ]);
  }
}

/**
 * Unlimited length TEXT column
 */
class TEXT extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYTEXT';
      case 'medium':
        return 'MEDIUMTEXT';
      case 'long':
        return 'LONGTEXT';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * An unlimited length case-insensitive text column.
 * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).
 * Only available in Postgres and SQLite.
 *
 */
class CITEXT extends ABSTRACT {
  toSql() {
    return 'CITEXT';
  }
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * Base number type which is used to build other types
 */
class NUMBER extends ABSTRACT {
  /**
   * @param {object} options type options
   * @param {string|number} [options.length] length of type, like `INT(4)`
   * @param {boolean} [options.zerofill] Is zero filled?
   * @param {boolean} [options.unsigned] Is unsigned?
   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`
   * @param {string|number} [options.precision] defines precision for decimal type
   * @param {string|number} [options.scale] defines scale for decimal type
   */
  constructor(options = {}) {
    super();
    if (typeof options === 'number') {
      options = {
        length: options
      };
    }
    this.options = options;
    this._length = options.length;
    this._zerofill = options.zerofill;
    this._decimals = options.decimals;
    this._precision = options.precision;
    this._scale = options.scale;
    this._unsigned = options.unsigned;
  }
  toSql() {
    let result = this.key;
    if (this._length) {
      result += `(${this._length}`;
      if (typeof this._decimals === 'number') {
        result += `,${this._decimals}`;
      }
      result += ')';
    }
    if (this._unsigned) {
      result += ' UNSIGNED';
    }
    if (this._zerofill) {
      result += ' ZEROFILL';
    }
    return result;
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
  _stringify(number) {
    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {
      return number;
    }
    if (typeof number.toString === 'function') {
      return number.toString();
    }
    return number;
  }

  get UNSIGNED() {
    this._unsigned = true;
    this.options.unsigned = true;
    return this;
  }

  get ZEROFILL() {
    this._zerofill = true;
    this.options.zerofill = true;
    return this;
  }

  static get UNSIGNED() {
    return new this().UNSIGNED;
  }

  static get ZEROFILL() {
    return new this().ZEROFILL;
  }
}

/**
 * A 32 bit integer
 */
class INTEGER extends NUMBER {
  validate(value) {
    if (!Validator.isInt(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
    }
    return true;
  }
}

/**
 * A 8 bit integer
 */
class TINYINT extends INTEGER {
}

/**
 * A 16 bit integer
 */
class SMALLINT extends INTEGER {
}

/**
 * A 24 bit integer
 */
class MEDIUMINT extends INTEGER {
}

/**
 * A 64 bit integer
 */
class BIGINT extends INTEGER {
}

/**
 * Floating point number (4-byte precision).
 */
class FLOAT extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `FLOAT(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
  validate(value) {
    if (!Validator.isFloat(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));
    }
    return true;
  }
}

/**
 * Floating point number (4-byte precision).
 */
class REAL extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `REAL(4)`
   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Floating point number (8-byte precision).
 */
class DOUBLE extends NUMBER {
  /**
   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`
   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`
   */
  constructor(length, decimals) {
    super(typeof length === 'object' && length || { length, decimals });
  }
}

/**
 * Decimal type, variable precision, take length as specified by user
 */
class DECIMAL extends NUMBER {
  /**
   * @param {string|number} [precision] defines precision
   * @param {string|number} [scale] defines scale
   */
  constructor(precision, scale) {
    super(typeof precision === 'object' && precision || { precision, scale });
  }
  toSql() {
    if (this._precision || this._scale) {
      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;
    }
    return 'DECIMAL';
  }
  validate(value) {
    if (!Validator.isDecimal(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));
    }
    return true;
  }
}

// TODO: Create intermediate class
const protoExtensions = {
  escape: false,
  _value(value) {
    if (isNaN(value)) {
      return 'NaN';
    }
    if (!isFinite(value)) {
      const sign = value < 0 ? '-' : '';
      return `${sign}Infinity`;
    }

    return value;
  },
  _stringify(value) {
    return `'${this._value(value)}'`;
  },
  _bindParam(value, options) {
    return options.bindParam(this._value(value));
  }
};

for (const floating of [FLOAT, DOUBLE, REAL]) {
  Object.assign(floating.prototype, protoExtensions);
}

/**
 * A boolean / tinyint column, depending on dialect
 */
class BOOLEAN extends ABSTRACT {
  toSql() {
    return 'TINYINT(1)';
  }
  validate(value) {
    if (!Validator.isBoolean(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));
    }
    return true;
  }
  _sanitize(value) {
    if (value !== null && value !== undefined) {
      if (Buffer.isBuffer(value) && value.length === 1) {
        // Bit fields are returned as buffers
        value = value[0];
      }
      const type = typeof value;
      if (type === 'string') {
        // Only take action on valid boolean strings.
        return value === 'true' ? true : value === 'false' ? false : value;
      }
      if (type === 'number') {
        // Only take action on valid boolean integers.
        return value === 1 ? true : value === 0 ? false : value;
      }
    }
    return value;
  }
}


BOOLEAN.parse = BOOLEAN.prototype._sanitize;

/**
 * A time column
 *
 */
class TIME extends ABSTRACT {
  toSql() {
    return 'TIME';
  }
}

/**
 * Date column with timezone, default is UTC
 */
class DATE extends ABSTRACT {
  /**
   * @param {string|number} [length] precision to allow storing milliseconds
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    return 'DATETIME';
  }
  validate(value) {
    if (!Validator.isDate(String(value))) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));
    }
    return true;
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {
      return new Date(value);
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value &&
      (value === originalValue ||
        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
  _applyTimezone(date, options) {
    if (options.timezone) {
      if (momentTz.tz.zone(options.timezone)) {
        return momentTz(date).tz(options.timezone);
      }
      return date = moment(date).utcOffset(options.timezone);
    }
    return momentTz(date);
  }
  _stringify(date, options) {
    date = this._applyTimezone(date, options);
    // Z here means current timezone, _not_ UTC
    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');
  }
}

/**
 * A date only column (no timestamp)
 */
class DATEONLY extends ABSTRACT {
  toSql() {
    return 'DATE';
  }
  _stringify(date) {
    return moment(date).format('YYYY-MM-DD');
  }
  _sanitize(value, options) {
    if ((!options || options && !options.raw) && !!value) {
      return moment(value).format('YYYY-MM-DD');
    }
    return value;
  }
  _isChanged(value, originalValue) {
    if (originalValue && !!value && originalValue === value) {
      return false;
    }
    // not changed when set to same empty value
    if (!originalValue && !value && originalValue === value) {
      return false;
    }
    return true;
  }
}

/**
 * A key / value store column. Only available in Postgres.
 */
class HSTORE extends ABSTRACT {
  validate(value) {
    if (!_.isPlainObject(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));
    }
    return true;
  }
}

/**
 * A JSON string column. Available in MySQL, Postgres and SQLite
 */
class JSONTYPE extends ABSTRACT {
  validate() {
    return true;
  }
  _stringify(value) {
    return JSON.stringify(value);
  }
}

/**
 * A binary storage JSON column. Only available in Postgres.
 */
class JSONB extends JSONTYPE {
}

/**
 * A default value of the current timestamp
 */
class NOW extends ABSTRACT {
}

/**
 * Binary storage
 */
class BLOB extends ABSTRACT {
  /**
   * @param {string} [length=''] could be tiny, medium, long.
   */
  constructor(length) {
    super();
    const options = typeof length === 'object' && length || { length };
    this.options = options;
    this._length = options.length || '';
  }
  toSql() {
    switch (this._length.toLowerCase()) {
      case 'tiny':
        return 'TINYBLOB';
      case 'medium':
        return 'MEDIUMBLOB';
      case 'long':
        return 'LONGBLOB';
      default:
        return this.key;
    }
  }
  validate(value) {
    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));
    }
    return true;
  }
  _stringify(value) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    const hex = value.toString('hex');
    return this._hexify(hex);
  }
  _hexify(hex) {
    return `X'${hex}'`;
  }
  _bindParam(value, options) {
    if (!Buffer.isBuffer(value)) {
      if (Array.isArray(value)) {
        value = Buffer.from(value);
      }
      else {
        value = Buffer.from(value.toString());
      }
    }
    return options.bindParam(value);
  }
}


BLOB.prototype.escape = false;

/**
 * Range types are data types representing a range of values of some element type (called the range's subtype).
 * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details
 */
class RANGE extends ABSTRACT {
  /**
   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)
   */
  constructor(subtype) {
    super();
    const options = _.isPlainObject(subtype) ? subtype : { subtype };
    if (!options.subtype)
      options.subtype = new INTEGER();
    if (typeof options.subtype === 'function') {
      options.subtype = new options.subtype();
    }
    this._subtype = options.subtype.key;
    this.options = options;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));
    }
    if (value.length !== 2) {
      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');
    }
    return true;
  }
}

/**
 * A column storing a unique universal identifier.
 * Use with `UUIDV1` or `UUIDV4` for default values.
 */
class UUID extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v1 standard
 */
class UUIDV1 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));
    }
    return true;
  }
}

/**
 * A default unique universal identifier generated following the UUID v4 standard
 */
class UUIDV4 extends ABSTRACT {
  validate(value, options) {
    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));
    }
    return true;
  }
}

/**
 * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.
 *
 * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments
 * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.
 * Return type is mostly useful for setups that rely on types like GraphQL.
 *
 * @example <caption>Checking password length before hashing it</caption>
 * sequelize.define('user', {
 *   password_hash: DataTypes.STRING,
 *   password: {
 *     type: DataTypes.VIRTUAL,
 *     set: function (val) {
 *        // Remember to set the data value, otherwise it won't be validated
 *        this.setDataValue('password', val);
 *        this.setDataValue('password_hash', this.salt + val);
 *      },
 *      validate: {
 *         isLongEnough: function (val) {
 *           if (val.length < 7) {
 *             throw new Error("Please choose a longer password")
 *          }
 *       }
 *     }
 *   }
 * })
 *
 * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.
 *
 * @example <caption>Virtual with dependency fields</caption>
 * {
 *   active: {
 *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),
 *     get: function() {
 *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)
 *     }
 *   }
 * }
 *
 */
class VIRTUAL extends ABSTRACT {
  /**
   * @param {ABSTRACT} [ReturnType] return type for virtual type
   * @param {Array} [fields] array of fields this virtual type is dependent on
   */
  constructor(ReturnType, fields) {
    super();
    if (typeof ReturnType === 'function')
      ReturnType = new ReturnType();
    this.returnType = ReturnType;
    this.fields = fields;
  }
}

/**
 * An enumeration, Postgres Only
 *
 * @example
 * DataTypes.ENUM('value', 'another value')
 * DataTypes.ENUM(['value', 'another value'])
 * DataTypes.ENUM({
 *   values: ['value', 'another value']
 * })
 */
class ENUM extends ABSTRACT {
  /**
   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values
   */
  constructor(...args) {
    super();
    const value = args[0];
    const options = typeof value === 'object' && !Array.isArray(value) && value || {
      values: args.reduce((result, element) => {
        return result.concat(Array.isArray(element) ? element : [element]);
      }, [])
    };
    this.values = options.values;
    this.options = options;
  }
  validate(value) {
    if (!this.values.includes(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));
    }
    return true;
  }
}

/**
 * An array of `type`. Only available in Postgres.
 *
 * @example
 * DataTypes.ARRAY(DataTypes.DECIMAL)
 */
class ARRAY extends ABSTRACT {
  /**
   * @param {ABSTRACT} type type of array values
   */
  constructor(type) {
    super();
    const options = _.isPlainObject(type) ? type : { type };
    this.options = options;
    this.type = typeof options.type === 'function' ? new options.type() : options.type;
  }
  toSql() {
    return `${this.type.toSql()}[]`;
  }
  validate(value) {
    if (!Array.isArray(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));
    }
    return true;
  }
  static is(obj, type) {
    return obj instanceof ARRAY && obj.type instanceof type;
  }
}

/**
 * A column storing Geometry information.
 * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.
 *
 * GeoJSON is accepted as input and returned as output.
 *
 * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.
 * In MySQL it is parsed using the function `GeomFromText`.
 *
 * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:
 *
 * @example <caption>Defining a Geometry type attribute</caption>
 * DataTypes.GEOMETRY
 * DataTypes.GEOMETRY('POINT')
 * DataTypes.GEOMETRY('POINT', 4326)
 *
 * @example <caption>Create a new point</caption>
 * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};
 *
 * User.create({username: 'username', geometry: point });
 *
 * @example <caption>Create a new linestring</caption>
 * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };
 *
 * User.create({username: 'username', geometry: line });
 *
 * @example <caption>Create a new polygon</caption>
 * const polygon = { type: 'Polygon', coordinates: [
 *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
 *                   [100.0, 1.0], [100.0, 0.0] ]
 *                 ]};
 *
 * User.create({username: 'username', geometry: polygon });
 *
 * @example <caption>Create a new point with a custom SRID</caption>
 * const point = {
 *   type: 'Point',
 *   coordinates: [39.807222,-76.984722],
 *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }
 * };
 *
 * User.create({username: 'username', geometry: point })
 *
 *
 * @see {@link DataTypes.GEOGRAPHY}
 */
class GEOMETRY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geometry data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}

GEOMETRY.prototype.escape = false;

/**
 * A geography datatype represents two dimensional spacial objects in an elliptic coord system.
 *
 * __The difference from geometry and geography type:__
 *
 * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.
 * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),
 * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.
 *
 * __What is best to use? It depends:__
 *
 * When choosing between the geometry and geography type for data storage, you should consider what youll be using it for.
 * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.
 * Although the new geography data type can cover the globe, the geometry type is far from obsolete.
 * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools
 *
 * @example <caption>Defining a Geography type attribute</caption>
 * DataTypes.GEOGRAPHY
 * DataTypes.GEOGRAPHY('POINT')
 * DataTypes.GEOGRAPHY('POINT', 4326)
 */
class GEOGRAPHY extends ABSTRACT {
  /**
   * @param {string} [type] Type of geography data
   * @param {string} [srid] SRID of type
   */
  constructor(type, srid) {
    super();
    const options = _.isPlainObject(type) ? type : { type, srid };
    this.options = options;
    this.type = options.type;
    this.srid = options.srid;
  }
  _stringify(value, options) {
    return `GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
  _bindParam(value, options) {
    return `GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
  }
}


GEOGRAPHY.prototype.escape = false;

/**
 * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.
 *
 * Only available for Postgres
 */
class CIDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIPRange(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));
    }
    return true;
  }
}

/**
 * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes
 *
 * Only available for Postgres
 */
class INET extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isIP(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));
    }
    return true;
  }
}

/**
 * The MACADDR type stores MAC addresses. Takes 6 bytes
 *
 * Only available for Postgres
 *
 */
class MACADDR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));
    }
    return true;
  }
}

/**
 * The TSVECTOR type stores text search vectors.
 *
 * Only available for Postgres
 *
 */
class TSVECTOR extends ABSTRACT {
  validate(value) {
    if (typeof value !== 'string') {
      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));
    }
    return true;
  }
}

/**
 * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:
 * ```js
 * sequelize.define('model', {
 *   column: DataTypes.INTEGER
 * })
 * ```
 * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean
 * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.
 *
 * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`
 *
 * Some data types have special properties that can be accessed in order to change the data type.
 * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.
 * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.
 *
 * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`
 * * The `CHAR` and `STRING` types expose the `BINARY` property
 *
 * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for
 * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: DataTypes.UUIDV1,
 *     primaryKey: true
 *   }
 * })
 * ```
 * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished
 * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value
 * from a function.
 * ```js
 * sequelize.define('model', {
 *   uuid: {
 *     type: DataTypes.UUID,
 *     defaultValue: function() {
 *       return generateMyId()
 *     },
 *     primaryKey: true
 *   }
 * })
 * ```
 */
const DataTypes = module.exports = {
  ABSTRACT,
  STRING,
  CHAR,
  TEXT,
  NUMBER,
  TINYINT,
  SMALLINT,
  MEDIUMINT,
  INTEGER,
  BIGINT,
  FLOAT,
  TIME,
  DATE,
  DATEONLY,
  BOOLEAN,
  NOW,
  BLOB,
  DECIMAL,
  NUMERIC: DECIMAL,
  UUID,
  UUIDV1,
  UUIDV4,
  HSTORE,
  JSON: JSONTYPE,
  JSONB,
  VIRTUAL,
  ARRAY,
  ENUM,
  RANGE,
  REAL,
  'DOUBLE PRECISION': DOUBLE,
  DOUBLE,
  GEOMETRY,
  GEOGRAPHY,
  CIDR,
  INET,
  MACADDR,
  CITEXT,
  TSVECTOR
};

_.each(DataTypes, (dataType, name) => {
  // guard for aliases
  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {
    dataType.types = {};
    dataType.key = dataType.prototype.key = name;
  }
});

const dialectMap = {};
dialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ "./node_modules/sequelize/lib/dialects/postgres/data-types.js")(DataTypes);
dialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ "./node_modules/sequelize/lib/dialects/mysql/data-types.js")(DataTypes);
dialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js")(DataTypes);
dialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js")(DataTypes);
dialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ "./node_modules/sequelize/lib/dialects/mssql/data-types.js")(DataTypes);

const dialectList = Object.values(dialectMap);

for (const dataTypes of dialectList) {
  _.each(dataTypes, (DataType, key) => {
    if (!DataType.key) {
      DataType.key = DataType.prototype.key = key;
    }
  });
}

// Wrap all data types to not require `new`
for (const dataTypes of [DataTypes, ...dialectList]) {
  _.each(dataTypes, (DataType, key) => {
    dataTypes[key] = classToInvokable(DataType);
  });
}

Object.assign(DataTypes, dialectMap);


/***/ }),

/***/ "./node_modules/sequelize/lib/deferrable.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/deferrable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { classToInvokable } = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");

class ABSTRACT {
  static toString(...args) {
    return new this().toString(...args);
  }

  toString(...args) {
    return this.toSql(...args);
  }

  toSql() {
    throw new Error('toSql implementation missing');
  }
}

class INITIALLY_DEFERRED extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY DEFERRED';
  }
}

class INITIALLY_IMMEDIATE extends ABSTRACT {
  toSql() {
    return 'DEFERRABLE INITIALLY IMMEDIATE';
  }
}

class NOT extends ABSTRACT {
  toSql() {
    return 'NOT DEFERRABLE';
  }
}

class SET_DEFERRED extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setDeferredQuery(this.constraints);
  }
}

class SET_IMMEDIATE extends ABSTRACT {
  constructor(constraints) {
    super();
    this.constraints = constraints;
  }

  toSql(queryGenerator) {
    return queryGenerator.setImmediateQuery(this.constraints);
  }
}

/**
 * A collection of properties related to deferrable constraints. It can be used to
 * make foreign key constraints deferrable and to set the constraints within a
 * transaction. This is only supported in PostgreSQL.
 *
 * The foreign keys can be configured like this. It will create a foreign key
 * that will check the constraints immediately when the data was inserted.
 *
 * ```js
 * sequelize.define('Model', {
 *   foreign_id: {
 *     type: Sequelize.INTEGER,
 *     references: {
 *       model: OtherModel,
 *       key: 'id',
 *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE
 *     }
 *   }
 * });
 * ```
 *
 * The constraints can be configured in a transaction like this. It will
 * trigger a query once the transaction has been started and set the constraints
 * to be checked at the very end of the transaction.
 *
 * ```js
 * sequelize.transaction({
 *   deferrable: Sequelize.Deferrable.SET_DEFERRED
 * });
 * ```
 *
 * @property INITIALLY_DEFERRED    Use when declaring a constraint. Allow and enable by default this constraint's checks to be deferred at the end of transactions.
 * @property INITIALLY_IMMEDIATE   Use when declaring a constraint. Allow the constraint's checks to be deferred at the end of transactions.
 * @property NOT                   Use when declaring a constraint. Set the constraint to not deferred. This is the default in PostgreSQL and makes it impossible to dynamically defer the constraints within a transaction.
 * @property SET_DEFERRED          Use when declaring a transaction. Defer the deferrable checks involved in this transaction at commit.
 * @property SET_IMMEDIATE         Use when declaring a transaction. Execute the deferrable checks involved in this transaction immediately.
 */

const Deferrable = {
  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),
  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),
  NOT: classToInvokable(NOT),
  SET_DEFERRED: classToInvokable(SET_DEFERRED),
  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)
};

module.exports = Deferrable;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ "./node_modules/sequelize-pool/lib/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const errors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const debug = logger.debugContext('pool');

/**
 * Abstract Connection Manager
 *
 * Connection manager which handles pooling & replication.
 * Uses sequelize-pool for pooling
 *
 * @private
 */
class ConnectionManager {
  constructor(dialect, sequelize) {
    const config = _.cloneDeep(sequelize.config);

    this.sequelize = sequelize;
    this.config = config;
    this.dialect = dialect;
    this.versionPromise = null;
    this.dialectName = this.sequelize.options.dialect;

    if (config.pool === false) {
      throw new Error('Support for pool:false was removed in v4.0');
    }

    config.pool = _.defaults(config.pool || {}, {
      max: 5,
      min: 0,
      idle: 10000,
      acquire: 60000,
      evict: 1000,
      validate: this._validate.bind(this)
    });

    this.initPools();
  }

  refreshTypeParser(dataTypes) {
    _.each(dataTypes, dataType => {
      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {
        if (dataType.types[this.dialectName]) {
          this._refreshTypeParser(dataType);
        } else {
          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);
        }
      }
    });
  }

  /**
   * Try to load dialect module from various configured options.
   * Priority goes like dialectModulePath > dialectModule > require(default)
   *
   * @param {string} moduleName Name of dialect module to lookup
   *
   * @private
   * @returns {object}
   */
  _loadDialectModule(moduleName) {
    try {
      if (this.sequelize.config.dialectModulePath) {
        return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(this.sequelize.config.dialectModulePath);
      }
      if (this.sequelize.config.dialectModule) {
        return this.sequelize.config.dialectModule;
      }
      return __webpack_require__("./node_modules/sequelize/lib/dialects/abstract sync recursive")(moduleName);

    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        if (this.sequelize.config.dialectModulePath) {
          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);
        }
        throw new Error(`Please install ${moduleName} package manually`);
      }

      throw err;
    }
  }

  /**
   * Handler which executes on process exit or connection manager shutdown
   *
   * @private
   * @returns {Promise}
   */
  async _onProcessExit() {
    if (!this.pool) {
      return;
    }

    await this.pool.drain();
    debug('connection drain due to process exit');

    return await this.pool.destroyAllNow();
  }

  /**
   * Drain the pool and close it permanently
   *
   * @returns {Promise}
   */
  async close() {
    // Mark close of pool
    this.getConnection = async function getConnection() {
      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');
    };

    return await this._onProcessExit();
  }

  /**
   * Initialize connection pool. By default pool autostart is set to false, so no connection will be
   * be created unless `pool.acquire` is called.
   */
  initPools() {
    const config = this.config;

    if (!config.replication) {
      this.pool = new Pool({
        name: 'sequelize',
        create: () => this._connect(config),
        destroy: async connection => {
          const result = await this._disconnect(connection);
          debug('connection destroy');
          return result;
        },
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      });

      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);

      return;
    }

    if (!Array.isArray(config.replication.read)) {
      config.replication.read = [config.replication.read];
    }

    // Map main connection config
    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));

    // Apply defaults to each read config
    config.replication.read = config.replication.read.map(readConfig =>
      _.defaults(readConfig, _.omit(this.config, 'replication'))
    );

    // custom pooling for replication (original author @janmeier)
    let reads = 0;
    this.pool = {
      release: client => {
        if (client.queryType === 'read') {
          this.pool.read.release(client);
        } else {
          this.pool.write.release(client);
        }
      },
      acquire: (queryType, useMaster) => {
        useMaster = useMaster === undefined ? false : useMaster;
        if (queryType === 'SELECT' && !useMaster) {
          return this.pool.read.acquire();
        }
        return this.pool.write.acquire();
      },
      destroy: connection => {
        this.pool[connection.queryType].destroy(connection);
        debug('connection destroy');
      },
      destroyAllNow: async () => {
        await Promise.all([
          this.pool.read.destroyAllNow(),
          this.pool.write.destroyAllNow()
        ]);

        debug('all connections destroyed');
      },
      drain: async () => Promise.all([
        this.pool.write.drain(),
        this.pool.read.drain()
      ]),
      read: new Pool({
        name: 'sequelize:read',
        create: async () => {
          // round robin config
          const nextRead = reads++ % config.replication.read.length;
          const connection = await this._connect(config.replication.read[nextRead]);
          connection.queryType = 'read';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      }),
      write: new Pool({
        name: 'sequelize:write',
        create: async () => {
          const connection = await this._connect(config.replication.write);
          connection.queryType = 'write';
          return connection;
        },
        destroy: connection => this._disconnect(connection),
        validate: config.pool.validate,
        max: config.pool.max,
        min: config.pool.min,
        acquireTimeoutMillis: config.pool.acquire,
        idleTimeoutMillis: config.pool.idle,
        reapIntervalMillis: config.pool.evict,
        maxUses: config.pool.maxUses
      })
    };

    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);
  }

  /**
   * Get connection from pool. It sets database version if it's not already set.
   * Call pool.acquire to get a connection
   *
   * @param {object}   [options]                 Pool options
   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`
   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from
   *
   * @returns {Promise<Connection>}
   */
  async getConnection(options) {
    options = options || {};

    if (this.sequelize.options.databaseVersion === 0) {
      if (!this.versionPromise) {
        this.versionPromise = (async () => {
          try {
            const connection = await this._connect(this.config.replication.write || this.config);
            const _options = {};

            _options.transaction = { connection }; // Cheat .query to use our private connection
            _options.logging = () => {};
            _options.logging.__testLoggingFn = true;

            //connection might have set databaseVersion value at initialization,
            //avoiding a useless round trip
            if (this.sequelize.options.databaseVersion === 0) {
              const version = await this.sequelize.databaseVersion(_options);
              const parsedVersion = _.get(semver.coerce(version), 'version') || version;
              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)
                ? parsedVersion
                : this.dialect.defaultVersion;
            }

            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {
              deprecations.unsupportedEngine();
              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);
            }

            this.versionPromise = null;
            return await this._disconnect(connection);
          } catch (err) {
            this.versionPromise = null;
            throw err;
          }
        })();
      }
      await this.versionPromise;
    }

    let result;

    try {
      result = await this.pool.acquire(options.type, options.useMaster);
    } catch (error) {
      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);
      throw error;
    }

    debug('connection acquired');

    return result;
  }

  /**
   * Release a pooled connection so it can be utilized by other connection requests
   *
   * @param {Connection} connection
   *
   * @returns {Promise}
   */
  async releaseConnection(connection) {
    this.pool.release(connection);
    debug('connection released');
  }

  /**
   * Call dialect library to get connection
   *
   * @param {*} config Connection config
   * @private
   * @returns {Promise<Connection>}
   */
  async _connect(config) {
    await this.sequelize.runHooks('beforeConnect', config);
    const connection = await this.dialect.connectionManager.connect(config);
    await this.sequelize.runHooks('afterConnect', connection, config);
    return connection;
  }

  /**
   * Call dialect library to disconnect a connection
   *
   * @param {Connection} connection
   * @private
   * @returns {Promise}
   */
  async _disconnect(connection) {
    await this.sequelize.runHooks('beforeDisconnect', connection);
    await this.dialect.connectionManager.disconnect(connection);
    return this.sequelize.runHooks('afterDisconnect', connection);
  }

  /**
   * Determine if a connection is still valid or not
   *
   * @param {Connection} connection
   *
   * @returns {boolean}
   */
  _validate(connection) {
    if (!this.dialect.connectionManager.validate) {
      return true;
    }

    return this.dialect.connectionManager.validate(connection);
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class AbstractDialect {}

AbstractDialect.prototype.supports = {
  'DEFAULT': true,
  'DEFAULT VALUES': false,
  'VALUES ()': false,
  'LIMIT ON UPDATE': false,
  'ORDER NULLS': false,
  'UNION': true,
  'UNION ALL': true,
  'RIGHT JOIN': true,

  /* does the dialect support returning values for inserted/updated fields */
  returnValues: false,

  /* features specific to autoIncrement values */
  autoIncrement: {
    /* does the dialect require modification of insert queries when inserting auto increment fields */
    identityInsert: false,

    /* does the dialect support inserting default/null values for autoincrement fields */
    defaultValue: true,

    /* does the dialect support updating autoincrement fields */
    update: true
  },
  /* Do we need to say DEFAULT for bulk insert */
  bulkDefault: false,
  schemas: false,
  transactions: true,
  settingIsolationLevelDuringTransaction: true,
  transactionOptions: {
    type: false
  },
  migrations: true,
  upserts: true,
  inserts: {
    ignoreDuplicates: '', /* dialect specific words for INSERT IGNORE or DO NOTHING */
    updateOnDuplicate: false, /* whether dialect supports ON DUPLICATE KEY UPDATE */
    onConflictDoNothing: '' /* dialect specific words for ON CONFLICT DO NOTHING */
  },
  constraints: {
    restrict: true,
    addConstraint: true,
    dropConstraint: true,
    unique: true,
    default: false,
    check: true,
    foreignKey: true,
    primaryKey: true
  },
  index: {
    collate: true,
    length: false,
    parser: false,
    concurrently: false,
    type: false,
    using: true,
    functionBased: false,
    operator: false
  },
  joinTableDependent: true,
  groupedLimit: true,
  indexViaAlter: false,
  JSON: false,
  deferrableConstraints: false
};

module.exports = AbstractDialect;
module.exports.AbstractDialect = AbstractDialect;
module.exports.default = AbstractDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const _ = __webpack_require__(/*! lodash */ "lodash");
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Model = __webpack_require__(/*! ../../model */ "./node_modules/sequelize/lib/model.js");
const Association = __webpack_require__(/*! ../../associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const HasMany = __webpack_require__(/*! ../../associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const sequelizeError = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const IndexHints = __webpack_require__(/*! ../../index-hints */ "./node_modules/sequelize/lib/index-hints.js");

const QuoteHelper = __webpack_require__(/*! ./query-generator/helpers/quote */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js");

/**
 * Abstract Query Generator
 *
 * @private
 */
class QueryGenerator {
  constructor(options) {
    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');
    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');

    this.sequelize = options.sequelize;
    this.options = options.sequelize.options;

    // dialect name
    this.dialect = options._dialect.name;
    this._dialect = options._dialect;
  }

  extractTableDetails(tableName, options) {
    options = options || {};
    tableName = tableName || {};
    return {
      schema: tableName.schema || options.schema || 'public',
      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
      delimiter: tableName.delimiter || options.delimiter || '.'
    };
  }

  addSchema(param) {
    if (!param._schema) return param.tableName || param;
    const self = this;
    return {
      tableName: param.tableName || param,
      table: param.tableName || param,
      name: param.name || param,
      schema: param._schema,
      delimiter: param._schemaDelimiter || '.',
      toString() {
        return self.quoteTable(this);
      }
    };
  }

  dropSchema(tableName, options) {
    return this.dropTableQuery(tableName, options);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `DESCRIBE ${table};`;
  }

  dropTableQuery(tableName) {
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;
  }

  renameTableQuery(before, after) {
    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;
  }

  /**
   * Returns an insert into command
   *
   * @param {string} table
   * @param {object} valueHash       attribute value pairs
   * @param {object} modelAttributes
   * @param {object} [options]
   *
   * @private
   */
  insertQuery(table, valueHash, modelAttributes, options) {
    options = options || {};
    _.defaults(options, this.options);

    const modelAttributeMap = {};
    const bind = [];
    const fields = [];
    const returningModelAttributes = [];
    const values = [];
    const quotedTable = this.quoteTable(table);
    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;
    let query;
    let valueQuery = '';
    let emptyQuery = '';
    let outputFragment = '';
    let returningFragment = '';
    let identityWrapperRequired = false;
    let tmpTable = ''; //tmpTable declaration for trigger

    if (modelAttributes) {
      _.each(modelAttributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    if (this._dialect.supports['DEFAULT VALUES']) {
      emptyQuery += ' DEFAULT VALUES';
    } else if (this._dialect.supports['VALUES ()']) {
      emptyQuery += ' VALUES ()';
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(modelAttributes, options);

      returningModelAttributes.push(...returnValues.returnFields);
      returningFragment = returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';
    }

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    if (this._dialect.supports.EXCEPTION && options.exception) {
      // Not currently supported with bind parameters (requires output of multiple queries)
      options.bindParam = false;
    }

    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
    for (const key in valueHash) {
      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {
        const value = valueHash[key];
        fields.push(this.quoteIdentifier(key));

        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {
          if (!this._dialect.supports.autoIncrement.defaultValue) {
            fields.splice(-1, 1);
          } else if (this._dialect.supports.DEFAULT) {
            values.push('DEFAULT');
          } else {
            values.push(this.escape(null));
          }
        } else {
          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
            identityWrapperRequired = true;
          }

          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));
          } else {
            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));
          }
        }
      }
    }

    let onDuplicateKeyUpdate = '';

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else {
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const replacements = {
      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',
      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',
      attributes: fields.join(','),
      output: outputFragment,
      values: values.join(','),
      tmpTable
    };

    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;
    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;

    // Mostly for internal use, so we expect the user to know what he's doing!
    // pg_temp functions are private per connection, so we never risk this function interfering with another one.
    if (this._dialect.supports.EXCEPTION && options.exception) {
      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';

      if (returningModelAttributes.length === 0) {
        returningModelAttributes.push('*');
      }

      const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;
      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;

      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';
      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;
    } else {
      valueQuery += returningFragment;
      emptyQuery += returningFragment;
    }

    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;
    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;
    }

    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }

    return result;
  }

  /**
   * Returns an insert into command for multiple values.
   *
   * @param {string} tableName
   * @param {object} fieldValueHashes
   * @param {object} options
   * @param {object} fieldMappedAttributes
   *
   * @private
   */
  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
    options = options || {};
    fieldMappedAttributes = fieldMappedAttributes || {};

    const tuples = [];
    const serials = {};
    const allAttributes = [];
    let onDuplicateKeyUpdate = '';

    for (const fieldValueHash of fieldValueHashes) {
      _.forOwn(fieldValueHash, (value, key) => {
        if (!allAttributes.includes(key)) {
          allAttributes.push(key);
        }
        if (
          fieldMappedAttributes[key]
          && fieldMappedAttributes[key].autoIncrement === true
        ) {
          serials[key] = true;
        }
      });
    }

    for (const fieldValueHash of fieldValueHashes) {
      const values = allAttributes.map(key => {
        if (
          this._dialect.supports.bulkDefault
          && serials[key] === true
        ) {
          return fieldValueHash[key] || 'DEFAULT';
        }

        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });
      });

      tuples.push(`(${values.join(',')})`);
    }

    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite
        // If no conflict target columns were specified, use the primary key names from options.upsertKeys
        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));
        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;
      } else { // mysql / maria
        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;
      }
    }

    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';
    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';
    let returning = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);

      returning += returnValues.returningFragment;
    }

    return Utils.joinSQLFragments([
      'INSERT',
      ignoreDuplicates,
      'INTO',
      this.quoteTable(tableName),
      `(${attributes})`,
      'VALUES',
      tuples.join(','),
      onDuplicateKeyUpdate,
      onConflictDoNothing,
      returning,
      ';'
    ]);
  }

  /**
   * Returns an update query
   *
   * @param {string} tableName
   * @param {object} attrValueHash
   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} options
   * @param {object} attributes
   *
   * @private
   */
  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const values = [];
    const bind = [];
    const modelAttributeMap = {};
    let outputFragment = '';
    let tmpTable = ''; // tmpTable declaration for trigger
    let suffix = '';

    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {
      // Not currently supported with search path (requires output of multiple queries)
      options.bindParam = false;
    }

    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;

    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {
      if (this.dialect !== 'mssql') {
        suffix = ` LIMIT ${this.escape(options.limit)} `;
      }
    }

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      suffix += returnValues.returningFragment;
      tmpTable = returnValues.tmpTable || '';
      outputFragment = returnValues.outputFragment || '';

      // ensure that the return output is properly mapped to model fields.
      if (!this._dialect.supports.returnValues.output && options.returning) {
        options.mapToModel = true;
      }
    }

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      if (modelAttributeMap && modelAttributeMap[key] &&
        modelAttributeMap[key].autoIncrement === true &&
        !this._dialect.supports.autoIncrement.update) {
        // not allowed to update identity column
        continue;
      }

      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    const whereOptions = { ...options, bindParam };

    if (values.length === 0) {
      return '';
    }

    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();
    // Used by Postgres upsertQuery and calls to here with options.exception set to true
    const result = { query };
    if (options.bindParam !== false) {
      result.bind = bind;
    }
    return result;
  }

  /**
   * Returns an update query using arithmetic operator
   *
   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')
   * @param {string} tableName                   Name of the table
   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer
   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs
   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs
   * @param {object} options
   *
   * @private
   */
  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = options || {};
    _.defaults(options, { returning: true });

    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);

    let outputFragment = '';
    let returningFragment = '';

    if (this._dialect.supports.returnValues && options.returning) {
      const returnValues = this.generateReturnValues(null, options);

      outputFragment = returnValues.outputFragment;
      returningFragment = returnValues.returningFragment;
    }

    const updateSetSqlFragments = [];
    for (const field in incrementAmountsByField) {
      const incrementAmount = incrementAmountsByField[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedAmount = this.escape(incrementAmount);
      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);
    }
    for (const field in extraAttributesToBeUpdated) {
      const newValue = extraAttributesToBeUpdated[field];
      const quotedField = this.quoteIdentifier(field);
      const escapedValue = this.escape(newValue);
      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);
    }

    return Utils.joinSQLFragments([
      'UPDATE',
      this.quoteTable(tableName),
      'SET',
      updateSetSqlFragments.join(','),
      outputFragment,
      this.whereQuery(where),
      returningFragment
    ]);
  }

  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
        - using
        - operator
        - concurrently: Pass CONCURRENT so other operations run while the index is created
      - rawTablename, the name of the table, without schema. Used to create the name of the index
   @private
  */
  addIndexQuery(tableName, attributes, options, rawTablename) {
    options = options || {};

    if (!Array.isArray(attributes)) {
      options = attributes;
      attributes = undefined;
    } else {
      options.fields = attributes;
    }

    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && typeof options.prefix === 'string') {
      options.prefix = options.prefix.replace(/\./g, '_');
      options.prefix = options.prefix.replace(/("|')/g, '');
    }

    const fieldsSql = options.fields.map(field => {
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (typeof field === 'string') {
        field = {
          name: field
        };
      }
      let result = '';

      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${util.inspect(field)}`);
      }

      result += this.quoteIdentifier(field.name);

      if (this._dialect.supports.index.collate && field.collate) {
        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;
      }

      if (this._dialect.supports.index.operator) {
        const operator = field.operator || options.operator;
        if (operator) {
          result += ` ${operator}`;
        }
      }

      if (this._dialect.supports.index.length && field.length) {
        result += `(${field.length})`;
      }

      if (field.order) {
        result += ` ${field.order}`;
      }

      return result;
    });

    if (!options.name) {
      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)
      // All calls that go through sequelize should already have a name
      options = Utils.nameIndex(options, options.prefix);
    }

    options = Model._conformIndex(options);

    if (!this._dialect.supports.index.type) {
      delete options.type;
    }

    if (options.where) {
      options.where = this.whereQuery(options.where);
    }

    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;
    let ind;
    if (this._dialect.supports.indexViaAlter) {
      ind = [
        'ALTER TABLE',
        tableName,
        concurrently,
        'ADD'
      ];
    } else {
      ind = ['CREATE'];
    }

    ind = ind.concat(
      options.unique ? 'UNIQUE' : '',
      options.type, 'INDEX',
      !this._dialect.supports.indexViaAlter ? concurrently : undefined,
      this.quoteIdentifiers(options.name),
      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',
      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,
      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',
      `(${fieldsSql.join(', ')})`,
      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,
      this._dialect.supports.index.where && options.where ? options.where : undefined
    );

    return _.compact(ind).join(' ');
  }

  addConstraintQuery(tableName, options) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'ADD',
      this.getConstraintSnippet(tableName, options || {}),
      ';'
    ]);
  }

  getConstraintSnippet(tableName, options) {
    let constraintSnippet, constraintName;

    const fieldsSql = options.fields.map(field => {
      if (typeof field === 'string') {
        return this.quoteIdentifier(field);
      }
      if (field instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(field);
      }
      if (field.attribute) {
        field.name = field.attribute;
      }

      if (!field.name) {
        throw new Error(`The following index field has no name: ${field}`);
      }

      return this.quoteIdentifier(field.name);
    });

    const fieldsSqlQuotedString = fieldsSql.join(', ');
    const fieldsSqlString = fieldsSql.join('_');

    switch (options.type.toUpperCase()) {
      case 'UNIQUE':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);
        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;
        break;
      case 'CHECK':
        options.where = this.whereItemsQuery(options.where);
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);
        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;
        break;
      case 'DEFAULT':
        if (options.defaultValue === undefined) {
          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');
        }

        if (this._dialect.name !== 'mssql') {
          throw new Error('Default constraints are supported only for MSSQL dialect.');
        }

        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);
        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;
        break;
      case 'PRIMARY KEY':
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);
        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;
        break;
      case 'FOREIGN KEY':
        const references = options.references;
        if (!references || !references.table || !(references.field || references.fields)) {
          throw new Error('references object with table and field must be specified');
        }
        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);
        const quotedReferences =
          typeof references.field !== 'undefined'
            ? this.quoteIdentifier(references.field)
            : references.fields.map(f => this.quoteIdentifier(f)).join(', ');
        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;
        constraintSnippet = `CONSTRAINT ${constraintName} `;
        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;
        if (options.onUpdate) {
          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;
        }
        if (options.onDelete) {
          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;
        }
        break;
      default: throw new Error(`${options.type} is invalid.`);
    }

    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {
      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;
    }

    return constraintSnippet;
  }

  removeConstraintQuery(tableName, constraintName) {
    if (typeof tableName === 'string') {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      tableName,
      'DROP CONSTRAINT',
      this.quoteIdentifiers(constraintName)
    ]);
  }

  /*
    Quote an object based on its type. This is a more general version of quoteIdentifiers
    Strings: should proxy to quoteIdentifiers
    Arrays:
      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]
        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an
        association object, or the name of an association.
      * Zero or more models can be included in the array and are used to trace a path through the tree of
        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL
        and quotes it.
      * If a single string is appended to end of array, it is quoted.
        If two strings appended, the 1st string is quoted, the 2nd string unquoted.
    Objects:
      * If raw is set, that value should be returned verbatim, without quoting
      * If fn is set, the string should start with the value of fn, starting paren, followed by
        the values of cols (which is assumed to be an array), quoted and joined with ', ',
        unless they are themselves objects
      * If direction is set, should be prepended

    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could
    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)
   @private
  */
  quote(collection, parent, connector) {
    // init
    const validOrderOptions = [
      'ASC',
      'DESC',
      'ASC NULLS LAST',
      'DESC NULLS LAST',
      'ASC NULLS FIRST',
      'DESC NULLS FIRST',
      'NULLS FIRST',
      'NULLS LAST'
    ];

    // default
    connector = connector || '.';

    // just quote as identifiers if string
    if (typeof collection === 'string') {
      return this.quoteIdentifiers(collection);
    }
    if (Array.isArray(collection)) {
      // iterate through the collection and mutate objects into associations
      collection.forEach((item, index) => {
        const previous = collection[index - 1];
        let previousAssociation;
        let previousModel;

        // set the previous as the parent when previous is undefined or the target of the association
        if (!previous && parent !== undefined) {
          previousModel = parent;
        } else if (previous && previous instanceof Association) {
          previousAssociation = previous;
          previousModel = previous.target;
        }

        // if the previous item is a model, then attempt getting an association
        if (previousModel && previousModel.prototype instanceof Model) {
          let model;
          let as;

          if (typeof item === 'function' && item.prototype instanceof Model) {
            // set
            model = item;
          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {
            // set
            model = item.model;
            as = item.as;
          }

          if (model) {
            // set the as to either the through name or the model name
            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {
              // get from previous association
              item = new Association(previousModel, model, {
                as: model.name
              });
            } else {
              // get association from previous model
              item = previousModel.getAssociationForAlias(model, as);

              // attempt to use the model name if the item is still null
              if (!item) {
                item = previousModel.getAssociationForAlias(model, model.name);
              }
            }

            // make sure we have an association
            if (!(item instanceof Association)) {
              throw new Error(util.format('Unable to find a valid association for model, \'%s\'', model.name));
            }
          }
        }

        if (typeof item === 'string') {
          // get order index
          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());

          // see if this is an order
          if (index > 0 && orderIndex !== -1) {
            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);
          } else if (previousModel && previousModel.prototype instanceof Model) {
            // only go down this path if we have preivous model and check only once
            if (previousModel.associations !== undefined && previousModel.associations[item]) {
              // convert the item to an association
              item = previousModel.associations[item];
            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {
              // convert the item attribute from its alias
              item = previousModel.rawAttributes[item].field;
            } else if (
              item.includes('.')
              && previousModel.rawAttributes !== undefined
            ) {
              const itemSplit = item.split('.');

              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {
                // just quote identifiers for now
                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);

                // get path
                const path = itemSplit.slice(1);

                // extract path
                item = this.jsonPathExtractionQuery(identifier, path);

                // literal because we don't want to append the model name when string
                item = this.sequelize.literal(item);
              }
            }
          }
        }

        collection[index] = item;
      }, this);

      // loop through array, adding table names of models to quoted
      const collectionLength = collection.length;
      const tableNames = [];
      let item;
      let i = 0;

      for (i = 0; i < collectionLength - 1; i++) {
        item = collection[i];
        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {
          break;
        } else if (item instanceof Association) {
          tableNames[i] = item.as;
        }
      }

      // start building sql
      let sql = '';

      if (i > 0) {
        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;
      } else if (typeof collection[0] === 'string' && parent) {
        sql += `${this.quoteIdentifier(parent.name)}.`;
      }

      // loop through everything past i and append to the sql
      collection.slice(i).forEach(collectionItem => {
        sql += this.quote(collectionItem, parent, connector);
      }, this);

      return sql;
    }
    if (collection._modelAttribute) {
      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;
    }
    if (collection instanceof Utils.SequelizeMethod) {
      return this.handleSequelizeMethod(collection);
    }
    if (_.isPlainObject(collection) && collection.raw) {
      // simple objects with raw is no longer supported
      throw new Error('The `{raw: "..."}` syntax is no longer supported.  Use `sequelize.literal` instead.');
    }
    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);
  }

  /**
   * Split a list of identifiers by "." and quote each part
   *
   * @param {string} identifier
   * @param {boolean} force
   *
   * @returns {string}
   */
  quoteIdentifier(identifier, force) {
    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {
      force,
      quoteIdentifiers: this.options.quoteIdentifiers
    });
  }

  quoteIdentifiers(identifiers) {
    if (identifiers.includes('.')) {
      identifiers = identifiers.split('.');

      const head = identifiers.slice(0, identifiers.length - 1).join('->');
      const tail = identifiers[identifiers.length - 1];

      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;
    }

    return this.quoteIdentifier(identifiers);
  }

  quoteAttribute(attribute, model) {
    if (model && attribute in model.rawAttributes) {
      return this.quoteIdentifier(attribute);
    }
    return this.quoteIdentifiers(attribute);
  }

  /**
   * Quote table name with optional alias and schema attribution
   *
   * @param {string|object}  param table string or object
   * @param {string|boolean} alias alias name
   *
   * @returns {string}
   */
  quoteTable(param, alias) {
    let table = '';

    if (alias === true) {
      alias = param.as || param.name || param;
    }

    if (_.isObject(param)) {
      if (this._dialect.supports.schemas) {
        if (param.schema) {
          table += `${this.quoteIdentifier(param.schema)}.`;
        }

        table += this.quoteIdentifier(param.tableName);
      } else {
        if (param.schema) {
          table += param.schema + (param.delimiter || '.');
        }

        table += param.tableName;
        table = this.quoteIdentifier(table);
      }
    } else {
      table = this.quoteIdentifier(param);
    }

    if (alias) {
      table += ` AS ${this.quoteIdentifier(alias)}`;
    }

    return table;
  }

  /*
    Escape a value (e.g. a string, number or date)
    @private
  */
  escape(value, field, options) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(value);
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.stringify) {
          // Users shouldn't have to worry about these args - just give them a function that takes a single arg
          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);

          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });

          if (field.type.escape === false) {
            // The data-type already did the required escaping
            return value;
          }
        }
      }
    }
    return SqlString.escape(value, this.options.timezone, this.dialect);
  }

  bindParam(bind) {
    return value => {
      bind.push(value);
      return `$${bind.length}`;
    };
  }

  /*
    Returns a bind parameter representation of a value (e.g. a string, number or date)
    @private
  */
  format(value, field, options, bindParam) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value instanceof Utils.SequelizeMethod) {
        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');
      }
      if (field && field.type) {
        this.validate(value, field, options);

        if (field.type.bindParam) {
          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });
        }
      }
    }

    return bindParam(value);
  }

  /*
    Validate a value against a field specification
    @private
  */
  validate(value, field, options) {
    if (this.typeValidation && field.type.validate && value) {
      try {
        if (options.isList && Array.isArray(value)) {
          for (const item of value) {
            field.type.validate(item, options);
          }
        } else {
          field.type.validate(value, options);
        }
      } catch (error) {
        if (error instanceof sequelizeError.ValidationError) {
          error.errors.push(new sequelizeError.ValidationErrorItem(
            error.message,
            'Validation error',
            field.fieldName,
            value,
            null,
            `${field.type.key} validator`
          ));
        }

        throw error;
      }
    }
  }

  isIdentifierQuoted(identifier) {
    return QuoteHelper.isIdentifierQuoted(identifier);
  }

  /**
   * Generates an SQL query that extract JSON property of given path.
   *
   * @param   {string}               column  The JSON column
   * @param   {string|Array<string>} [path]  The path to extract (optional)
   * @returns {string}                       The generated sql query
   * @private
   */
  jsonPathExtractionQuery(column, path) {
    let paths = _.toPath(path);
    let pathStr;
    const quotedColumn = this.isIdentifierQuoted(column)
      ? column
      : this.quoteIdentifier(column);

    switch (this.dialect) {
      case 'mysql':
      case 'mariadb':
      case 'sqlite':
        /**
         * Non digit sub paths need to be quoted as ECMAScript identifiers
         * https://bugs.mysql.com/bug.php?id=81896
         */
        if (this.dialect === 'mysql') {
          paths = paths.map(subPath => {
            return /\D/.test(subPath)
              ? Utils.addTicks(subPath, '"')
              : subPath;
          });
        }

        pathStr = this.escape(['$']
          .concat(paths)
          .join('.')
          .replace(/\.(\d+)(?:(?=\.)|$)/g, (__, digit) => `[${digit}]`));

        if (this.dialect === 'sqlite') {
          return `json_extract(${quotedColumn},${pathStr})`;
        }

        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;

      case 'postgres':
        pathStr = this.escape(`{${paths.join(',')}}`);
        return `(${quotedColumn}#>>${pathStr})`;

      default:
        throw new Error(`Unsupported ${this.dialect} for JSON operations`);
    }
  }

  /*
    Returns a query for selecting elements in the table <tableName>.
    Options:
      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
      - order -> e.g. 'id DESC'
      - group
      - limit -> The maximum count you want to get.
      - offset -> An offset value to start from. Only useable with limit!
   @private
  */
  selectQuery(tableName, options, model) {
    options = options || {};
    const limit = options.limit;
    const mainQueryItems = [];
    const subQueryItems = [];
    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;
    const attributes = {
      main: options.attributes && options.attributes.slice(),
      subQuery: null
    };
    const mainTable = {
      name: tableName,
      quotedName: null,
      as: null,
      model
    };
    const topLevelInfo = {
      names: mainTable,
      options,
      subQuery
    };
    let mainJoinQueries = [];
    let subJoinQueries = [];
    let query;

    // Aliases can be passed through subqueries and we don't want to reset them
    if (this.options.minifyAliases && !options.aliasesMapping) {
      options.aliasesMapping = new Map();
      options.aliasesByTable = {};
      options.includeAliases = new Map();
    }

    // resolve table name options
    if (options.tableAs) {
      mainTable.as = this.quoteIdentifier(options.tableAs);
    } else if (!Array.isArray(mainTable.name) && mainTable.model) {
      mainTable.as = this.quoteIdentifier(mainTable.model.name);
    }

    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {
      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);
    }).join(', ');

    if (subQuery && attributes.main) {
      for (const keyAtt of mainTable.model.primaryKeyAttributes) {
        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field
        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {
          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);
        }
      }
    }

    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);
    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);

    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery
    if (subQuery || options.groupedLimit) {
      // We need primary keys
      attributes.subQuery = attributes.main;
      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];
    }

    if (options.include) {
      for (const include of options.include) {
        if (include.separate) {
          continue;
        }
        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);

        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

        if (joinQueries.attributes.main.length > 0) {
          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));
        }
        if (joinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));
        }
      }
    }

    if (subQuery) {
      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));
      subQueryItems.push(subJoinQueries.join(''));
    } else {
      if (options.groupedLimit) {
        if (!mainTable.as) {
          mainTable.as = mainTable.quotedName;
        }
        const where = { ...options.where };
        let groupedLimitOrder,
          whereKey,
          include,
          groupedTableName = mainTable.as;

        if (typeof options.groupedLimit.on === 'string') {
          whereKey = options.groupedLimit.on;
        } else if (options.groupedLimit.on instanceof HasMany) {
          whereKey = options.groupedLimit.on.foreignKeyField;
        }

        if (options.groupedLimit.on instanceof BelongsToMany) {
          // BTM includes needs to join the through table on to check ID
          groupedTableName = options.groupedLimit.on.manyFromSource.as;
          const groupedLimitOptions = Model._validateIncludedElements({
            include: [{
              association: options.groupedLimit.on.manyFromSource,
              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot
              required: true,
              where: {
                [Op.placeholder]: true,
                ...options.groupedLimit.through && options.groupedLimit.through.where
              }
            }],
            model
          });

          // Make sure attributes from the join table are mapped back to models
          options.hasJoin = true;
          options.hasMultiAssociation = true;
          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);
          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
          include = groupedLimitOptions.include;

          if (Array.isArray(options.order)) {
            // We need to make sure the order by attributes are available to the parent query
            options.order.forEach((order, i) => {
              if (Array.isArray(order)) {
                order = order[0];
              }

              let alias = `subquery_order_${i}`;
              options.attributes.push([order, alias]);

              // We don't want to prepend model name when we alias the attributes, so quote them here
              alias = this.sequelize.literal(this.quote(alias));

              if (Array.isArray(options.order[i])) {
                options.order[i][0] = alias;
              } else {
                options.order[i] = alias;
              }
            });
            groupedLimitOrder = options.order;
          }
        } else {
          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed
          groupedLimitOrder = options.order;
          delete options.order;
          where[Op.placeholder] = true;
        }

        // Caching the base query and splicing the where part into it is consistently > twice
        // as fast than generating from scratch each time for values.length >= 5
        const baseQuery = `SELECT * FROM (${this.selectQuery(
          tableName,
          {
            attributes: options.attributes,
            offset: options.offset,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            aliasesMapping: options.aliasesMapping,
            aliasesByTable: options.aliasesByTable,
            where,
            include,
            model
          },
          model
        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias
        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });
        const splicePos = baseQuery.indexOf(placeHolder);

        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${
          options.groupedLimit.values.map(value => {
            let groupWhere;
            if (whereKey) {
              groupWhere = {
                [whereKey]: value
              };
            }
            if (include) {
              groupWhere = {
                [options.groupedLimit.on.foreignIdentifierField]: value
              };
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
          }).join(
            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '
          )
        })`, mainTable.as));
      } else {
        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));
      }

      mainQueryItems.push(mainJoinQueries.join(''));
    }

    // Add WHERE to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {
      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);
      if (options.where) {
        if (subQuery) {
          subQueryItems.push(` WHERE ${options.where}`);
        } else {
          mainQueryItems.push(` WHERE ${options.where}`);
          // Walk the main query to update all selects
          mainQueryItems.forEach((value, key) => {
            if (value.startsWith('SELECT')) {
              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);
            }
          });
        }
      }
    }

    // Add GROUP BY to sub or main query
    if (options.group) {
      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);

      if (subQuery && options.group) {
        subQueryItems.push(` GROUP BY ${options.group}`);
      } else if (options.group) {
        mainQueryItems.push(` GROUP BY ${options.group}`);
      }
    }

    // Add HAVING to sub or main query
    if (Object.prototype.hasOwnProperty.call(options, 'having')) {
      options.having = this.getWhereConditions(options.having, tableName, model, options, false);
      if (options.having) {
        if (subQuery) {
          subQueryItems.push(` HAVING ${options.having}`);
        } else {
          mainQueryItems.push(` HAVING ${options.having}`);
        }
      }
    }

    // Add ORDER to sub or main query
    if (options.order) {
      const orders = this.getQueryOrders(options, model, subQuery);
      if (orders.mainQueryOrder.length) {
        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);
      }
      if (orders.subQueryOrder.length) {
        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);
      }
    }

    // Add LIMIT, OFFSET to sub or main query
    const limitOrder = this.addLimitAndOffset(options, mainTable.model);
    if (limitOrder && !options.groupedLimit) {
      if (subQuery) {
        subQueryItems.push(limitOrder);
      } else {
        mainQueryItems.push(limitOrder);
      }
    }

    if (subQuery) {
      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });
      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;
    } else {
      query = mainQueryItems.join('');
    }

    if (options.lock && this._dialect.supports.lock) {
      let lock = options.lock;
      if (typeof options.lock === 'object') {
        lock = options.lock.level;
      }
      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {
        query += ` FOR ${lock}`;
      } else if (lock === 'SHARE') {
        query += ` ${this._dialect.supports.forShare}`;
      } else {
        query += ' FOR UPDATE';
      }
      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {
        query += ` OF ${this.quoteTable(options.lock.of.name)}`;
      }
      if (this._dialect.supports.skipLocked && options.skipLocked) {
        query += ' SKIP LOCKED';
      }
    }

    return `${query};`;
  }

  aliasGrouping(field, model, tableName, options) {
    const src = Array.isArray(field) ? field[0] : field;

    return this.quote(this._getAliasForField(tableName, src, options) || src, model);
  }

  escapeAttributes(attributes, options, mainTableAs) {
    return attributes && attributes.map(attr => {
      let addTable = true;

      if (attr instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(attr);
      }
      if (Array.isArray(attr)) {
        if (attr.length !== 2) {
          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);
        }
        attr = attr.slice();

        if (attr[0] instanceof Utils.SequelizeMethod) {
          attr[0] = this.handleSequelizeMethod(attr[0]);
          addTable = false;
        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {
          attr[0] = this.quoteIdentifier(attr[0]);
        } else {
          deprecations.noRawAttributes();
        }
        let alias = attr[1];

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, mainTableAs, options);
        }

        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');
      } else {
        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('"')
          ? this.quoteAttribute(attr, options.model)
          : this.escape(attr);
      }
      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {
        attr = `${mainTableAs}.${attr}`;
      }

      return attr;
    });
  }

  generateInclude(include, parentTableName, topLevelInfo) {
    const joinQueries = {
      mainQuery: [],
      subQuery: []
    };
    const mainChildIncludes = [];
    const subChildIncludes = [];
    let requiredMismatch = false;
    const includeAs = {
      internalAs: include.as,
      externalAs: include.as
    };
    const attributes = {
      main: [],
      subQuery: []
    };
    let joinQuery;

    topLevelInfo.options.keysEscaped = true;

    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {
      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;
      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;
    }

    // includeIgnoreAttributes is used by aggregate functions
    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      include.model._expandAttributes(include);
      Utils.mapFinderOptions(include, include.model);

      const includeAttributes = include.attributes.map(attr => {
        let attrAs = attr;
        let verbatim = false;

        if (Array.isArray(attr) && attr.length === 2) {
          if (attr[0] instanceof Utils.SequelizeMethod && (
            attr[0] instanceof Utils.Literal ||
            attr[0] instanceof Utils.Cast ||
            attr[0] instanceof Utils.Fn
          )) {
            verbatim = true;
          }

          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);

          attrAs = attr[1];
          attr = attr[0];
        }
        if (attr instanceof Utils.Literal) {
          return attr.val; // We trust the user to rename the field correctly
        }
        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {
          throw new Error(
            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +
            'This means the attribute will not be added to the returned instance'
          );
        }

        let prefix;
        if (verbatim === true) {
          prefix = attr;
        } else if (/#>>|->>/.test(attr)) {
          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\(|\)/g, '')})`;
        } else if (/json_extract\(/.test(attr)) {
          prefix = attr.replace(/json_extract\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);
        } else {
          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;
        }
        let alias = `${includeAs.externalAs}.${attrAs}`;

        if (this.options.minifyAliases) {
          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);
        }

        return Utils.joinSQLFragments([
          prefix,
          'AS',
          this.quoteIdentifier(alias, true)
        ]);
      });
      if (include.subQuery && topLevelInfo.subQuery) {
        for (const attr of includeAttributes) {
          attributes.subQuery.push(attr);
        }
      } else {
        for (const attr of includeAttributes) {
          attributes.main.push(attr);
        }
      }
    }

    //through
    if (include.through) {
      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);
    } else {
      this._generateSubQueryFilter(include, includeAs, topLevelInfo);
      joinQuery = this.generateJoin(include, topLevelInfo);
    }

    // handle possible new attributes created in join
    if (joinQuery.attributes.main.length > 0) {
      attributes.main = attributes.main.concat(joinQuery.attributes.main);
    }

    if (joinQuery.attributes.subQuery.length > 0) {
      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);
    }

    if (include.include) {
      for (const childInclude of include.include) {
        if (childInclude.separate || childInclude._pseudo) {
          continue;
        }

        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);

        if (include.required === false && childInclude.required === true) {
          requiredMismatch = true;
        }
        // if the child is a sub query we just give it to the
        if (childInclude.subQuery && topLevelInfo.subQuery) {
          subChildIncludes.push(childJoinQueries.subQuery);
        }
        if (childJoinQueries.mainQuery) {
          mainChildIncludes.push(childJoinQueries.mainQuery);
        }
        if (childJoinQueries.attributes.main.length > 0) {
          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);
        }
        if (childJoinQueries.attributes.subQuery.length > 0) {
          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);
        }
      }
    }

    if (include.subQuery && topLevelInfo.subQuery) {
      if (requiredMismatch && subChildIncludes.length > 0) {
        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (subChildIncludes.length > 0) {
          joinQueries.subQuery.push(subChildIncludes.join(''));
        }
      }
      joinQueries.mainQuery.push(mainChildIncludes.join(''));
    } else {
      if (requiredMismatch && mainChildIncludes.length > 0) {
        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);
      } else {
        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
        if (mainChildIncludes.length > 0) {
          joinQueries.mainQuery.push(mainChildIncludes.join(''));
        }
      }
      joinQueries.subQuery.push(subChildIncludes.join(''));
    }

    return {
      mainQuery: joinQueries.mainQuery.join(''),
      subQuery: joinQueries.subQuery.join(''),
      attributes
    };
  }

  _getMinifiedAlias(alias, tableName, options) {
    // We do not want to re-alias in case of a subquery
    if (options.aliasesByTable[`${tableName}${alias}`]) {
      return options.aliasesByTable[`${tableName}${alias}`];
    }

    // Do not alias custom suquery_orders
    if (alias.match(/subquery_order_[0-9]/)) {
      return alias;
    }

    const minifiedAlias = `_${options.aliasesMapping.size}`;

    options.aliasesMapping.set(minifiedAlias, alias);
    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;

    return minifiedAlias;
  }

  _getAliasForField(tableName, field, options) {
    if (this.options.minifyAliases) {
      if (options.aliasesByTable[`${tableName}${field}`]) {
        return options.aliasesByTable[`${tableName}${field}`];
      }
    }
    return null;
  }

  generateJoin(include, topLevelInfo) {
    const association = include.association;
    const parent = include.parent;
    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    let $parent;
    let joinWhere;
    /* Attributes for the left side */
    const left = association.source;
    const attrLeft = association instanceof BelongsTo ?
      association.identifier :
      association.sourceKeyAttribute || left.primaryKeyAttribute;
    const fieldLeft = association instanceof BelongsTo ?
      association.identifierField :
      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;
    let asLeft;
    /* Attributes for the right side */
    const right = include.model;
    const tableRight = right.getTableName();
    const fieldRight = association instanceof BelongsTo ?
      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :
      association.identifierField;
    let asRight = include.as;

    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {
      if (asLeft) {
        asLeft = `${$parent.as}->${asLeft}`;
      } else {
        asLeft = $parent.as;
      }
    }

    if (!asLeft) asLeft = parent.as || parent.model.name;
    else asRight = `${asLeft}->${asRight}`;

    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;
    const subqueryAttributes = [];

    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {
      if (parentIsTop) {
        // The main model attributes is not aliased to a prefix
        const tableName = this.quoteTable(parent.as || parent.model.name);

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;

        if (topLevelInfo.subQuery) {
          subqueryAttributes.push(`${tableName}.${this.quoteIdentifier(fieldLeft)}`);
        }
      } else {
        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;

        // Check for potential aliased JOIN condition
        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);
      }
    }

    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;

    if (include.on) {
      joinOn = this.whereItemsQuery(include.on, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
    }

    if (include.where) {
      joinWhere = this.whereItemsQuery(include.where, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
      if (joinWhere) {
        if (include.or) {
          joinOn += ` OR ${joinWhere}`;
        } else {
          joinOn += ` AND ${joinWhere}`;
        }
      }
    }

    if (this.options.minifyAliases && asRight.length > 63) {
      const alias = `%${topLevelInfo.options.includeAliases.size}`;

      topLevelInfo.options.includeAliases.set(alias, asRight);
    }

    return {
      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',
      body: this.quoteTable(tableRight, asRight),
      condition: joinOn,
      attributes: {
        main: [],
        subQuery: subqueryAttributes
      }
    };
  }

  /**
   * Returns the SQL fragments to handle returning the attributes from an insert/update query.
   *
   * @param  {object} modelAttributes An object with the model attributes.
   * @param  {object} options         An object with options.
   *
   * @private
   */
  generateReturnValues(modelAttributes, options) {
    const returnFields = [];
    const returnTypes = [];
    let outputFragment = '';
    let returningFragment = '';
    let tmpTable = '';

    if (Array.isArray(options.returning)) {
      returnFields.push(...options.returning.map(field => this.quoteIdentifier(field)));
    } else if (modelAttributes) {
      _.each(modelAttributes, attribute => {
        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {
          returnFields.push(this.quoteIdentifier(attribute.field));
          returnTypes.push(attribute.type);
        }
      });
    }

    if (_.isEmpty(returnFields)) {
      returnFields.push('*');
    }

    if (this._dialect.supports.returnValues.returning) {
      returningFragment = ` RETURNING ${returnFields.join(',')}`;
    } else if (this._dialect.supports.returnValues.output) {
      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(',')}`;

      //To capture output rows when there is a trigger on MSSQL DB
      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);

        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;
        outputFragment += ' INTO @tmp';
        returningFragment = '; SELECT * FROM @tmp';
      }
    }

    return { outputFragment, returnFields, returningFragment, tmpTable };
  }

  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {
    const through = include.through;
    const throughTable = through.model.getTableName();
    const throughAs = `${includeAs.internalAs}->${through.as}`;
    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;
    const throughAttributes = through.attributes.map(attr => {
      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;

      if (this.options.minifyAliases) {
        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);
      }

      return Utils.joinSQLFragments([
        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,
        'AS',
        this.quoteIdentifier(alias)
      ]);
    });
    const association = include.association;
    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
    const tableSource = parentTableName;
    const identSource = association.identifierField;
    const tableTarget = includeAs.internalAs;
    const identTarget = association.foreignIdentifierField;
    const attrTarget = association.targetKeyField;

    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';
    let joinBody;
    let joinCondition;
    const attributes = {
      main: [],
      subQuery: []
    };
    let attrSource = association.sourceKey;
    let sourceJoinOn;
    let targetJoinOn;
    let throughWhere;
    let targetWhere;

    if (topLevelInfo.options.includeIgnoreAttributes !== false) {
      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)
      for (const attr of throughAttributes) {
        attributes.main.push(attr);
      }
    }

    // Figure out if we need to use field or attribute
    if (!topLevelInfo.subQuery) {
      attrSource = association.sourceKeyField;
    }
    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {
      attrSource = association.sourceKeyField;
    }

    // Filter statement for left side of through
    // Used by both join and subquery where
    // If parent include was in a subquery need to join on the aliased attribute
    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;

      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;
    } else {
      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name
      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;

      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;
    }
    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;

    // Filter statement for right side of through
    // Used by both join and subquery where
    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;
    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;

    if (through.where) {
      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);
    }

    if (this._dialect.supports.joinTableDependent) {
      // Generate a wrapped join so that the through table join can be dependent on the target join
      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;
      if (throughWhere) {
        joinBody += ` AND ${throughWhere}`;
      }
      joinBody += ')';
      joinCondition = sourceJoinOn;
    } else {
      // Generate join SQL for left side of through
      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;
      joinCondition = targetJoinOn;
      if (throughWhere) {
        joinCondition += ` AND ${throughWhere}`;
      }
    }

    if (include.where || include.through.where) {
      if (include.where) {
        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);
        if (targetWhere) {
          joinCondition += ` AND ${targetWhere}`;
        }
      }
    }

    this._generateSubQueryFilter(include, includeAs, topLevelInfo);

    return {
      join: joinType,
      body: joinBody,
      condition: joinCondition,
      attributes
    };
  }

  /*
   * Generates subQueryFilter - a select nested in the where clause of the subQuery.
   * For a given include a query is generated that contains all the way from the subQuery
   * table to the include table plus everything that's in required transitive closure of the
   * given include.
   */
  _generateSubQueryFilter(include, includeAs, topLevelInfo) {
    if (!topLevelInfo.subQuery || !include.subQueryFilter) {
      return;
    }

    if (!topLevelInfo.options.where) {
      topLevelInfo.options.where = {};
    }
    let parent = include;
    let child = include;
    let nestedIncludes = this._getRequiredClosure(include).include;
    let query;

    while ((parent = parent.parent)) { // eslint-disable-line
      if (parent.parent && !parent.required) {
        return; // only generate subQueryFilter if all the parents of this include are required
      }

      if (parent.subQueryFilter) {
        // the include is already handled as this parent has the include on its required closure
        // skip to prevent duplicate subQueryFilter
        return;
      }

      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];
      child = parent;
    }

    const topInclude = nestedIncludes[0];
    const topParent = topInclude.parent;
    const topAssociation = topInclude.association;
    topInclude.association = undefined;

    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
      query = this.selectQuery(topInclude.through.model.getTableName(), {
        attributes: [topInclude.through.model.primaryKeyField],
        include: Model._validateIncludedElements({
          model: topInclude.through.model,
          include: [{
            association: topAssociation.toTarget,
            required: true,
            where: topInclude.where,
            include: topInclude.include
          }]
        }).include,
        model: topInclude.through.model,
        where: {
          [Op.and]: [
            this.sequelize.literal([
              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,
              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`
            ].join(' = ')),
            topInclude.through.where
          ]
        },
        limit: 1,
        includeIgnoreAttributes: false
      }, topInclude.through.model);
    } else {
      const isBelongsTo = topAssociation.associationType === 'BelongsTo';
      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;
      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;

      const join = [
        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,
        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`
      ].join(' = ');

      query = this.selectQuery(topInclude.model.getTableName(), {
        attributes: [targetField],
        include: Model._validateIncludedElements(topInclude).include,
        model: topInclude.model,
        where: {
          [Op.and]: [
            topInclude.where,
            { [Op.join]: this.sequelize.literal(join) }
          ]
        },
        limit: 1,
        tableAs: topInclude.as,
        includeIgnoreAttributes: false
      }, topInclude.model);
    }

    if (!topLevelInfo.options.where[Op.and]) {
      topLevelInfo.options.where[Op.and] = [];
    }

    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([
      '(',
      query.replace(/;$/, ''),
      ')',
      'IS NOT NULL'
    ].join(' '));
  }

  /*
   * For a given include hierarchy creates a copy of it where only the required includes
   * are preserved.
   */
  _getRequiredClosure(include) {
    const copy = { ...include, attributes: [], include: [] };

    if (Array.isArray(include.include)) {
      copy.include = include.include
        .filter(i => i.required)
        .map(inc => this._getRequiredClosure(inc));
    }

    return copy;
  }

  getQueryOrders(options, model, subQuery) {
    const mainQueryOrder = [];
    const subQueryOrder = [];

    if (Array.isArray(options.order)) {
      for (let order of options.order) {

        // wrap if not array
        if (!Array.isArray(order)) {
          order = [order];
        }

        if (
          subQuery
          && Array.isArray(order)
          && order[0]
          && !(order[0] instanceof Association)
          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)
          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)
          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])
        ) {
          subQueryOrder.push(this.quote(order, model, '->'));
        }

        if (subQuery) {
          // Handle case where sub-query renames attribute we want to order by,
          // see https://github.com/sequelize/sequelize/issues/8739
          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);
          if (subQueryAttribute) {
            const modelName = this.quoteIdentifier(model.name);

            order[0] = new Utils.Col(this._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);
          }
        }

        mainQueryOrder.push(this.quote(order, model, '->'));
      }
    } else if (options.order instanceof Utils.SequelizeMethod) {
      const sql = this.quote(options.order, model, '->');
      if (subQuery) {
        subQueryOrder.push(sql);
      }
      mainQueryOrder.push(sql);
    } else {
      throw new Error('Order must be type of array or instance of a valid sequelize method.');
    }

    return { mainQueryOrder, subQueryOrder };
  }

  _throwOnEmptyAttributes(attributes, extraInfo = {}) {
    if (attributes.length > 0) return;
    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';
    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';
    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;
    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;

    if (mainTableAs) {
      fragment += ` AS ${mainTableAs}`;
    }

    if (options.indexHints && this._dialect.supports.indexHints) {
      for (const hint of options.indexHints) {
        if (IndexHints[hint.type]) {
          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;
        }
      }
    }

    return fragment;
  }

  /**
   * Returns an SQL fragment for adding result constraints.
   *
   * @param  {object} options An object with selectQuery options.
   * @returns {string}         The generated sql query.
   * @private
   */
  addLimitAndOffset(options) {
    let fragment = '';

    /* eslint-disable */
    if (options.offset != null && options.limit == null) {
      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;
    } else if (options.limit != null) {
      if (options.offset != null) {
        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);
      } else {
        fragment += ' LIMIT ' + this.escape(options.limit);
      }
    }
    /* eslint-enable */

    return fragment;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    let result;

    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {
      smth.comparator = this.OperatorMap[smth.comparator];
    }

    if (smth instanceof Utils.Where) {
      let value = smth.logic;
      let key;

      if (smth.attribute instanceof Utils.SequelizeMethod) {
        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
      } else {
        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;
      }

      if (value && value instanceof Utils.SequelizeMethod) {
        value = this.getWhereConditions(value, tableName, factory, options, prepend);

        if (value === 'NULL') {
          if (smth.comparator === '=') {
            smth.comparator = 'IS';
          }
          if (smth.comparator === '!=') {
            smth.comparator = 'IS NOT';
          }
        }

        return [key, value].join(` ${smth.comparator} `);
      }
      if (_.isPlainObject(value)) {
        return this.whereItemQuery(smth.attribute, value, {
          model: factory
        });
      }
      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {
        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;
      } else if (typeof value === 'boolean') {
        value = this.booleanValue(value);
      } else {
        value = this.escape(value);
      }

      if (value === 'NULL') {
        if (smth.comparator === '=') {
          smth.comparator = 'IS';
        }
        if (smth.comparator === '!=') {
          smth.comparator = 'IS NOT';
        }
      }

      return [key, value].join(` ${smth.comparator} `);
    }
    if (smth instanceof Utils.Literal) {
      return smth.val;
    }
    if (smth instanceof Utils.Cast) {
      if (smth.val instanceof Utils.SequelizeMethod) {
        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
      } else if (_.isPlainObject(smth.val)) {
        result = this.whereItemsQuery(smth.val);
      } else {
        result = this.escape(smth.val);
      }

      return `CAST(${result} AS ${smth.type.toUpperCase()})`;
    }
    if (smth instanceof Utils.Fn) {
      return `${smth.fn}(${
        smth.args.map(arg => {
          if (arg instanceof Utils.SequelizeMethod) {
            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);
          }
          if (_.isPlainObject(arg)) {
            return this.whereItemsQuery(arg);
          }
          return this.escape(typeof arg === 'string' ? arg.replace('$', '$$$') : arg);
        }).join(', ')
      })`;
    }
    if (smth instanceof Utils.Col) {
      if (Array.isArray(smth.col) && !factory) {
        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');
      }
      if (smth.col.startsWith('*')) {
        return '*';
      }
      return this.quote(smth.col, factory);
    }
    return smth.toString(this, factory);
  }

  whereQuery(where, options) {
    const query = this.whereItemsQuery(where, options);
    if (query && query.length) {
      return `WHERE ${query}`;
    }
    return '';
  }

  whereItemsQuery(where, options, binding) {
    if (
      where === null ||
      where === undefined ||
      Utils.getComplexSize(where) === 0
    ) {
      // NO OP
      return '';
    }

    if (typeof where === 'string') {
      throw new Error('Support for `{where: \'raw query\'}` has been removed.');
    }

    const items = [];

    binding = binding || 'AND';
    if (binding[0] !== ' ') binding = ` ${binding} `;

    if (_.isPlainObject(where)) {
      Utils.getComplexKeys(where).forEach(prop => {
        const item = where[prop];
        items.push(this.whereItemQuery(prop, item, options));
      });
    } else {
      items.push(this.whereItemQuery(undefined, where, options));
    }

    return items.length && items.filter(item => item && item.length).join(binding) || '';
  }

  whereItemQuery(key, value, options = {}) {
    if (value === undefined) {
      throw new Error(`WHERE parameter "${key}" has invalid "undefined" value`);
    }

    if (typeof key === 'string' && key.includes('.') && options.model) {
      const keyParts = key.split('.');
      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {
        const tmp = {};
        const field = options.model.rawAttributes[keyParts[0]];
        _.set(tmp, keyParts.slice(1), value);
        return this.whereItemQuery(field.field || keyParts[0], tmp, { field, ...options });
      }
    }

    const field = this._findField(key, options);
    const fieldType = field && field.type || options.type;

    const isPlainObject = _.isPlainObject(value);
    const isArray = !isPlainObject && Array.isArray(value);
    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;
    if (isPlainObject) {
      value = this._replaceAliases(value);
    }
    const valueKeys = isPlainObject && Utils.getComplexKeys(value);

    if (key === undefined) {
      if (typeof value === 'string') {
        return value;
      }

      if (isPlainObject && valueKeys.length === 1) {
        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);
      }
    }

    if (value === null) {
      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);
    }

    if (!value) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {
      return this.handleSequelizeMethod(value);
    }

    // Convert where: [] to Op.and if possible, else treat as literal/replacements
    if (key === undefined && isArray) {
      if (Utils.canTreatArrayAsAnd(value)) {
        key = Op.and;
      } else {
        throw new Error('Support for literal replacements in the `where` object has been removed.');
      }
    }

    if (key === Op.or || key === Op.and || key === Op.not) {
      return this._whereGroupBind(key, value, options);
    }


    if (value[Op.or]) {
      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);
    }

    if (value[Op.and]) {
      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);
    }

    if (isArray && fieldType instanceof DataTypes.ARRAY) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {
      return this._whereJSON(key, value, options);
    }
    // If multiple keys we combine the different logic conditions
    if (isPlainObject && valueKeys.length > 1) {
      return this._whereBind(this.OperatorMap[Op.and], key, value, options);
    }

    if (isArray) {
      return this._whereParseSingleValueObject(key, field, Op.in, value, options);
    }
    if (isPlainObject) {
      if (this.OperatorMap[valueKeys[0]]) {
        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);
      }
      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);
    }

    if (key === Op.placeholder) {
      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);
    }

    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
  }

  _findField(key, options) {
    if (options.field) {
      return options.field;
    }

    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {
      return options.model.rawAttributes[key];
    }

    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {
      return options.model.fieldRawAttributesMap[key];
    }
  }

  // OR/AND/NOT grouping logic
  _whereGroupBind(key, value, options) {
    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];
    const outerBinding = key === Op.not ? 'NOT ' : '';

    if (Array.isArray(value)) {
      value = value.map(item => {
        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);
        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {
          itemQuery = `(${itemQuery})`;
        }
        return itemQuery;
      }).filter(item => item && item.length);

      value = value.length && value.join(binding);
    } else {
      value = this.whereItemsQuery(value, options, binding);
    }
    // Op.or: [] should return no data.
    // Op.not of no restriction should also return no data
    if ((key === Op.or || key === Op.not) && !value) {
      return '0 = 1';
    }

    return value ? `${outerBinding}(${value})` : undefined;
  }

  _whereBind(binding, key, value, options) {
    if (_.isPlainObject(value)) {
      value = Utils.getComplexKeys(value).map(prop => {
        const item = value[prop];
        return this.whereItemQuery(key, { [prop]: item }, options);
      });
    } else {
      value = value.map(item => this.whereItemQuery(key, item, options));
    }

    value = value.filter(item => item && item.length);

    return value.length ? `(${value.join(binding)})` : undefined;
  }

  _whereJSON(key, value, options) {
    const items = [];
    let baseKey = this.quoteIdentifier(key);
    if (options.prefix) {
      if (options.prefix instanceof Utils.Literal) {
        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;
      } else {
        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;
      }
    }

    Utils.getOperators(value).forEach(op => {
      const where = {
        [op]: value[op]
      };
      items.push(this.whereItemQuery(key, where, { ...options, json: false }));
    });

    _.forOwn(value, (item, prop) => {
      this._traverseJSON(items, baseKey, prop, item, [prop]);
    });

    const result = items.join(this.OperatorMap[Op.and]);
    return items.length > 1 ? `(${result})` : result;
  }

  _traverseJSON(items, baseKey, prop, item, path) {
    let cast;

    if (path[path.length - 1].includes('::')) {
      const tmp = path[path.length - 1].split('::');
      cast = tmp[1];
      path[path.length - 1] = tmp[0];
    }

    const pathKey = this.jsonPathExtractionQuery(baseKey, path);

    if (_.isPlainObject(item)) {
      Utils.getOperators(item).forEach(op => {
        const value = this._toJSONValue(item[op]);
        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));
      });
      _.forOwn(item, (value, itemProp) => {
        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));
      });

      return;
    }

    item = this._toJSONValue(item);
    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));
  }

  _toJSONValue(value) {
    return value;
  }

  _castKey(key, value, cast, json) {
    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);
    if (cast) {
      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));
    }

    return new Utils.Literal(key);
  }

  _getJsonCast(value) {
    if (typeof value === 'number') {
      return 'double precision';
    }
    if (value instanceof Date) {
      return 'timestamptz';
    }
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    return;
  }

  _joinKeyValue(key, value, comparator, prefix) {
    if (!key) {
      return value;
    }
    if (comparator === undefined) {
      throw new Error(`${key} and ${value} has no comparator`);
    }
    key = this._getSafeKey(key, prefix);
    return [key, value].join(` ${comparator} `);
  }

  _getSafeKey(key, prefix) {
    if (key instanceof Utils.SequelizeMethod) {
      key = this.handleSequelizeMethod(key);
      return this._prefixKey(this.handleSequelizeMethod(key), prefix);
    }

    if (Utils.isColString(key)) {
      key = key.substr(1, key.length - 2).split('.');

      if (key.length > 2) {
        key = [
          // join the tables by -> to match out internal namings
          key.slice(0, -1).join('->'),
          key[key.length - 1]
        ];
      }

      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');
    }

    return this._prefixKey(this.quoteIdentifier(key), prefix);
  }

  _prefixKey(key, prefix) {
    if (prefix) {
      if (prefix instanceof Utils.Literal) {
        return [this.handleSequelizeMethod(prefix), key].join('.');
      }

      return [this.quoteTable(prefix), key].join('.');
    }

    return key;
  }

  _whereParseSingleValueObject(key, field, prop, value, options) {
    if (prop === Op.not) {
      if (Array.isArray(value)) {
        prop = Op.notIn;
      } else if (value !== null && value !== true && value !== false) {
        prop = Op.ne;
      }
    }

    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];

    switch (prop) {
      case Op.in:
      case Op.notIn:
        if (value instanceof Utils.Literal) {
          return this._joinKeyValue(key, value.val, comparator, options.prefix);
        }

        if (value.length) {
          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);
        }

        if (comparator === this.OperatorMap[Op.in]) {
          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);
        }

        return '';
      case Op.any:
      case Op.all:
        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;
        if (value[Op.values]) {
          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);
        }

        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);
      case Op.between:
      case Op.notBetween:
        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);
      case Op.raw:
        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');
      case Op.col:
        comparator = this.OperatorMap[Op.eq];
        value = value.split('.');

        if (value.length > 2) {
          value = [
            // join the tables by -> to match out internal namings
            value.slice(0, -1).join('->'),
            value[value.length - 1]
          ];
        }

        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);
      case Op.startsWith:
      case Op.endsWith:
      case Op.substring:
        comparator = this.OperatorMap[Op.like];

        if (value instanceof Utils.Literal) {
          value = value.val;
        }

        let pattern = `${value}%`;

        if (prop === Op.endsWith) pattern = `%${value}`;
        if (prop === Op.substring) pattern = `%${value}%`;

        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);
    }

    const escapeOptions = {
      acceptStrings: comparator.includes(this.OperatorMap[Op.like])
    };

    if (_.isPlainObject(value)) {
      if (value[Op.col]) {
        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);
      }
      if (value[Op.any]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);
      }
      if (value[Op.all]) {
        escapeOptions.isList = true;
        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);
      }
    }

    if (value === null && comparator === this.OperatorMap[Op.eq]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);
    }
    if (value === null && comparator === this.OperatorMap[Op.ne]) {
      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);
    }

    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);
  }

  /*
    Takes something and transforms it into values of a where condition.
   @private
  */
  getWhereConditions(smth, tableName, factory, options, prepend) {
    const where = {};

    if (Array.isArray(tableName)) {
      tableName = tableName[0];
      if (Array.isArray(tableName)) {
        tableName = tableName[1];
      }
    }

    options = options || {};

    if (prepend === undefined) {
      prepend = true;
    }

    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls
      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }
    if (_.isPlainObject(smth)) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName,
        type: options.type
      });
    }
    if (typeof smth === 'number') {
      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];

      if (primaryKeys.length > 0) {
        // Since we're just a number, assume only the first key
        primaryKeys = primaryKeys[0];
      } else {
        primaryKeys = 'id';
      }

      where[primaryKeys] = smth;

      return this.whereItemsQuery(where, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (typeof smth === 'string') {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }
    if (Buffer.isBuffer(smth)) {
      return this.escape(smth);
    }
    if (Array.isArray(smth)) {
      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';
      if (Utils.canTreatArrayAsAnd(smth)) {
        const _smth = { [Op.and]: smth };
        return this.getWhereConditions(_smth, tableName, factory, options, prepend);
      }
      throw new Error('Support for literal replacements in the `where` object has been removed.');
    }
    if (smth === null) {
      return this.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }

    return '1=1';
  }

  // A recursive parser for nested where conditions
  parseConditionObject(conditions, path) {
    path = path || [];
    return _.reduce(conditions, (result, value, key) => {
      if (_.isObject(value)) {
        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects
      }
      result.push({ path: path.concat(key), value });
      return result;
    }, []);
  }

  booleanValue(value) {
    return value;
  }
}

Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js"));
Object.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js"));

module.exports = QueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/helpers/quote.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Quote helpers implement quote ability for all dialects.
 * These are basic block of query building
 *
 * Its better to implement all dialect implementation together here. Which will allow
 * even abstract generator to use them by just specifying dialect type.
 *
 * Defining these helpers in each query dialect will leave
 * code in dual dependency of abstract <-> specific dialect
 */



const Utils = __webpack_require__(/*! ../../../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * list of reserved words in PostgreSQL 10
 * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html
 *
 * @private
 */
const postgresReservedWords = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');

/**
 *
 * @param {string}  dialect         Dialect name
 * @param {string}  identifier      Identifier to quote
 * @param {object}  [options]
 * @param {boolean} [options.force=false]
 * @param {boolean} [options.quoteIdentifiers=true]
 *
 * @returns {string}
 * @private
 */
function quoteIdentifier(dialect, identifier, options) {
  if (identifier === '*') return identifier;

  options = Utils.defaults(options || {}, {
    force: false,
    quoteIdentifiers: true
  });

  switch (dialect) {
    case 'sqlite':
    case 'mariadb':
    case 'mysql':
      return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');

    case 'postgres':
      const rawIdentifier = Utils.removeTicks(identifier, '"');

      if (
        options.force !== true &&
        options.quoteIdentifiers === false &&
        !identifier.includes('.') &&
        !identifier.includes('->') &&
        !postgresReservedWords.includes(rawIdentifier.toLowerCase())
      ) {
        // In Postgres, if tables or attributes are created double-quoted,
        // they are also case sensitive. If they contain any uppercase
        // characters, they must always be double-quoted. This makes it
        // impossible to write queries in portable SQL if tables are created in
        // this way. Hence, we strip quotes if we don't want case sensitivity.
        return rawIdentifier;
      }
      return Utils.addTicks(rawIdentifier, '"');
    case 'mssql':
      return `[${identifier.replace(/[[\]']+/g, '')}]`;

    default:
      throw new Error(`Dialect "${dialect}" is not supported`);
  }
}
module.exports.quoteIdentifier = quoteIdentifier;

/**
 * Test if a give string is already quoted
 *
 * @param {string} identifier
 *
 * @returns {boolean}
 * @private
 */
function isIdentifierQuoted(identifier) {
  return /^\s*(?:([`"'])(?:(?!\1).|\1{2})*\1\.?)+\s*$/i.test(identifier);
}
module.exports.isIdentifierQuoted = isIdentifierQuoted;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Op = __webpack_require__(/*! ../../../operators */ "./node_modules/sequelize/lib/operators.js");
const Utils = __webpack_require__(/*! ../../../utils */ "./node_modules/sequelize/lib/utils.js");

const OperatorHelpers = {
  OperatorMap: {
    [Op.eq]: '=',
    [Op.ne]: '!=',
    [Op.gte]: '>=',
    [Op.gt]: '>',
    [Op.lte]: '<=',
    [Op.lt]: '<',
    [Op.not]: 'IS NOT',
    [Op.is]: 'IS',
    [Op.in]: 'IN',
    [Op.notIn]: 'NOT IN',
    [Op.like]: 'LIKE',
    [Op.notLike]: 'NOT LIKE',
    [Op.iLike]: 'ILIKE',
    [Op.notILike]: 'NOT ILIKE',
    [Op.startsWith]: 'LIKE',
    [Op.endsWith]: 'LIKE',
    [Op.substring]: 'LIKE',
    [Op.regexp]: '~',
    [Op.notRegexp]: '!~',
    [Op.iRegexp]: '~*',
    [Op.notIRegexp]: '!~*',
    [Op.between]: 'BETWEEN',
    [Op.notBetween]: 'NOT BETWEEN',
    [Op.overlap]: '&&',
    [Op.contains]: '@>',
    [Op.contained]: '<@',
    [Op.adjacent]: '-|-',
    [Op.strictLeft]: '<<',
    [Op.strictRight]: '>>',
    [Op.noExtendRight]: '&<',
    [Op.noExtendLeft]: '&>',
    [Op.any]: 'ANY',
    [Op.all]: 'ALL',
    [Op.and]: ' AND ',
    [Op.or]: ' OR ',
    [Op.col]: 'COL',
    [Op.placeholder]: '$$PLACEHOLDER$$',
    [Op.match]: '@@'
  },

  OperatorsAliasMap: {},

  setOperatorsAliases(aliases) {
    if (!aliases || _.isEmpty(aliases)) {
      this.OperatorsAliasMap = false;
    } else {
      this.OperatorsAliasMap = { ...aliases };
    }
  },

  _replaceAliases(orig) {
    const obj = {};
    if (!this.OperatorsAliasMap) {
      return orig;
    }

    Utils.getOperators(orig).forEach(op => {
      const item = orig[op];
      if (_.isPlainObject(item)) {
        obj[op] = this._replaceAliases(item);
      } else {
        obj[op] = item;
      }
    });

    _.forOwn(orig, (item, prop) => {
      prop = this.OperatorsAliasMap[prop] || prop;
      if (_.isPlainObject(item)) {
        item = this._replaceAliases(item);
      }
      obj[prop] = item;
    });
    return obj;
  }
};

module.exports = OperatorHelpers;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;

const TransactionQueries = {
  /**
   * Returns a query that sets the transaction isolation level.
   *
   * @param  {string} value   The isolation level.
   * @param  {object} options An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  setIsolationLevelQuery(value, options) {
    if (options.parent) {
      return;
    }

    return `SET TRANSACTION ISOLATION LEVEL ${value};`;
  },

  generateTransactionId() {
    return uuidv4();
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'START TRANSACTION;';
  },

  deferConstraintsQuery() {},

  setConstraintQuery() {},
  setDeferredQuery() {},
  setImmediateQuery() {},

  /**
   * Returns a query that commits a transaction.
   *
   * @param  {Transaction} transaction An object with options.
   * @returns {string}         The generated sql query.
   * @private
   */
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT;';
  },

  /**
   * Returns a query that rollbacks a transaction.
   *
   * @param  {Transaction} transaction
   * @returns {string}         The generated sql query.
   * @private
   */
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
    }

    return 'ROLLBACK;';
  }
};

module.exports = TransactionQueries;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk to all databases
 */
class QueryInterface {
  constructor(sequelize, queryGenerator) {
    this.sequelize = sequelize;
    this.queryGenerator = queryGenerator;
  }

  /**
   * Create a database
   *
   * @param {string} database  Database name to create
   * @param {object} [options] Query options
   * @param {string} [options.charset] Database default character set, MYSQL only
   * @param {string} [options.collate] Database default collation
   * @param {string} [options.encoding] Database default character set, PostgreSQL only
   * @param {string} [options.ctype] Database character classification, PostgreSQL only
   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only
   *
   * @returns {Promise}
   */
  async createDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.createDatabaseQuery(database, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a database
   *
   * @param {string} database  Database name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropDatabase(database, options) {
    options = options || {};
    const sql = this.queryGenerator.dropDatabaseQuery(database);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Create a schema
   *
   * @param {string} schema    Schema name to create
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.createSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a schema
   *
   * @param {string} schema    Schema name to drop
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    options = options || {};
    const sql = this.queryGenerator.dropSchema(schema);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    options = options || {};

    if (!this.queryGenerator._dialect.supports.schemas) {
      return this.sequelize.drop(options);
    }
    const schemas = await this.showAllSchemas(options);
    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));
  }

  /**
   * Show all schemas
   *
   * @param {object} [options] Query options
   *
   * @returns {Promise<Array>}
   */
  async showAllSchemas(options) {
    options = {
      ...options,
      raw: true,
      type: this.sequelize.QueryTypes.SELECT
    };

    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);

    const schemaNames = await this.sequelize.query(showSchemasSql, options);

    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));
  }

  /**
   * Return database version
   *
   * @param {object}    [options]      Query options
   * @param {QueryType} [options.type] Query type
   *
   * @returns {Promise}
   * @private
   */
  async databaseVersion(options) {
    return await this.sequelize.query(
      this.queryGenerator.versionQuery(),
      { ...options, type: QueryTypes.VERSION }
    );
  }

  /**
   * Create a table with given set of attributes
   *
   * ```js
   * queryInterface.createTable(
   *   'nameOfTheNewTable',
   *   {
   *     id: {
   *       type: Sequelize.INTEGER,
   *       primaryKey: true,
   *       autoIncrement: true
   *     },
   *     createdAt: {
   *       type: Sequelize.DATE
   *     },
   *     updatedAt: {
   *       type: Sequelize.DATE
   *     },
   *     attr1: Sequelize.STRING,
   *     attr2: Sequelize.INTEGER,
   *     attr3: {
   *       type: Sequelize.BOOLEAN,
   *       defaultValue: false,
   *       allowNull: false
   *     },
   *     //foreign key usage
   *     attr4: {
   *       type: Sequelize.INTEGER,
   *       references: {
   *         model: 'another_table_name',
   *         key: 'id'
   *       },
   *       onUpdate: 'cascade',
   *       onDelete: 'cascade'
   *     }
   *   },
   *   {
   *     engine: 'MYISAM',    // default: 'InnoDB'
   *     charset: 'latin1',   // default: null
   *     schema: 'public',    // default: public, PostgreSQL only.
   *     comment: 'my table', // comment for table
   *     collate: 'latin1_danish_ci' // collation, MYSQL only
   *   }
   * )
   * ```
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of table attributes to create
   * @param {object} [options] create table and query options
   * @param {Model}  [model] model class
   *
   * @returns {Promise}
   */
  async createTable(tableName, attributes, options, model) {
    let sql = '';

    options = { ...options };

    if (options && options.uniqueKeys) {
      _.forOwn(options.uniqueKeys, uniqueKey => {
        if (uniqueKey.customIndex === undefined) {
          uniqueKey.customIndex = true;
        }
      });
    }

    if (model) {
      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;
    }

    attributes = _.mapValues(
      attributes,
      attribute => this.sequelize.normalizeAttribute(attribute)
    );

    // Postgres requires special SQL commands for ENUM/ENUM[]
    await this.ensureEnums(tableName, attributes, options, model);

    if (
      !tableName.schema &&
      (options.schema || !!model && model._schema)
    ) {
      tableName = this.queryGenerator.addSchema({
        tableName,
        _schema: !!model && model._schema || options.schema
      });
    }

    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });
    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);

    return await this.sequelize.query(sql, options);
  }

  /**
   * Drop a table from database
   *
   * @param {string} tableName Table name to drop
   * @param {object} options   Query options
   *
   * @returns {Promise}
   */
  async dropTable(tableName, options) {
    // if we're forcing we should be cascading unless explicitly stated otherwise
    options = { ...options };
    options.cascade = options.cascade || options.force || false;

    const sql = this.queryGenerator.dropTableQuery(tableName, options);

    await this.sequelize.query(sql, options);
  }

  async _dropAllTables(tableNames, skip, options) {
    for (const tableName of tableNames) {
      // if tableName is not in the Array of tables names then don't drop it
      if (!skip.includes(tableName.tableName || tableName)) {
        await this.dropTable(tableName, { ...options, cascade: true } );
      }
    }
  }

  /**
   * Drop all tables from database
   *
   * @param {object} [options] query options
   * @param {Array}  [options.skip] List of table to skip
   *
   * @returns {Promise}
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);

    for (const tableName of tableNames) {
      let normalizedTableName = tableName;
      if (_.isObject(tableName)) {
        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;
      }

      for (const foreignKey of foreignKeys[normalizedTableName]) {
        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));
      }
    }
    await this._dropAllTables(tableNames, skip, options);
  }

  /**
   * Rename a table
   *
   * @param {string} before    Current name of table
   * @param {string} after     New name from table
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async renameTable(before, after, options) {
    options = options || {};
    const sql = this.queryGenerator.renameTableQuery(before, after);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Get all tables in current database
   *
   * @param {object}    [options] Query options
   * @param {boolean}   [options.raw=true] Run query in raw mode
   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showAllTables(options) {
    options = {
      ...options,
      raw: true,
      type: QueryTypes.SHOWTABLES
    };

    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);
    const tableNames = await this.sequelize.query(showTablesSql, options);
    return _.flatten(tableNames);
  }

  /**
   * Describe a table structure
   *
   * This method returns an array of hashes containing information about all attributes in the table.
   *
   * ```js
   * {
   *    name: {
   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!
   *      allowNull:    true,
   *      defaultValue: null
   *    },
   *    isBetaMember: {
   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!
   *      allowNull:    false,
   *      defaultValue: false
   *    }
   * }
   * ```
   *
   * @param {string} tableName table name
   * @param {object} [options] Query options
   *
   * @returns {Promise<object>}
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }

  /**
   * Add a new column to a table
   *
   * ```js
   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {
   *    after: 'columnB' // after option is only supported by MySQL
   * });
   * ```
   *
   * @param {string} table     Table to add column to
   * @param {string} key       Column name
   * @param {object} attribute Attribute definition
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async addColumn(table, key, attribute, options) {
    if (!table || !key || !attribute) {
      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');
    }

    options = options || {};
    attribute = this.sequelize.normalizeAttribute(attribute);
    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);
  }

  /**
   * Remove a column from a table
   *
   * @param {string} tableName      Table to remove column from
   * @param {string} attributeName  Column name to remove
   * @param {object} [options]      Query options
   */
  async removeColumn(tableName, attributeName, options) {
    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);
  }

  normalizeAttribute(dataTypeOrOptions) {
    let attribute;
    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {
      attribute = { type: dataTypeOrOptions, allowNull: true };
    } else {
      attribute = dataTypeOrOptions;
    }

    return this.sequelize.normalizeAttribute(attribute);
  }

  /**
   * Change a column definition
   *
   * @param {string} tableName          Table name to change from
   * @param {string} attributeName      Column name
   * @param {object} dataTypeOrOptions  Attribute definition for new column
   * @param {object} [options]          Query options
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const query = this.queryGenerator.attributesToSQL({
      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)
    }, {
      context: 'changeColumn',
      table: tableName
    });
    const sql = this.queryGenerator.changeColumnQuery(tableName, query);

    return this.sequelize.query(sql, options);
  }

  /**
   * Rejects if the table doesn't have the specified column, otherwise returns the column description.
   *
   * @param {string} tableName
   * @param {string} columnName
   * @param {object} options
   * @private
   */
  async assertTableHasColumn(tableName, columnName, options) {
    const description = await this.describeTable(tableName, options);
    if (description[columnName]) {
      return description;
    }
    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);
  }

  /**
   * Rename a column
   *
   * @param {string} tableName        Table name whose column to rename
   * @param {string} attrNameBefore   Current column name
   * @param {string} attrNameAfter    New column name
   * @param {object} [options]        Query option
   *
   * @returns {Promise}
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];

    const _options = {};

    _options[attrNameAfter] = {
      attribute: attrNameAfter,
      type: data.type,
      allowNull: data.allowNull,
      defaultValue: data.defaultValue
    };

    // fix: a not-null column cannot have null as default value
    if (data.defaultValue === null && !data.allowNull) {
      delete _options[attrNameAfter].defaultValue;
    }

    const sql = this.queryGenerator.renameColumnQuery(
      tableName,
      attrNameBefore,
      this.queryGenerator.attributesToSQL(_options)
    );
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add an index to a column
   *
   * @param {string|object}  tableName Table name to add index on, can be a object with schema
   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on
   * @param {object}  options          indexes options
   * @param {Array}   options.fields   List of attributes to add index on
   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created
   * @param {boolean} [options.unique] Create a unique index
   * @param {string}  [options.using]  Useful for GIN indexes
   * @param {string}  [options.operator] Index operator
   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL
   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>
   * @param {object}  [options.where]  Where condition on index, for partial indexes
   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity
   *
   * @returns {Promise}
   */
  async addIndex(tableName, attributes, options, rawTablename) {
    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)
    if (!Array.isArray(attributes)) {
      rawTablename = options;
      options = attributes;
      attributes = options.fields;
    }

    if (!rawTablename) {
      // Map for backwards compat
      rawTablename = tableName;
    }

    options = Utils.cloneDeep(options);
    options.fields = attributes;
    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);
    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });
  }

  /**
   * Show indexes on a table
   *
   * @param {string} tableName table name
   * @param {object} [options]   Query options
   *
   * @returns {Promise<Array>}
   * @private
   */
  async showIndex(tableName, options) {
    const sql = this.queryGenerator.showIndexesQuery(tableName, options);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });
  }


  /**
   * Returns all foreign key constraints of requested tables
   *
   * @param {string[]} tableNames table names
   * @param {object} [options] Query options
   *
   * @returns {Promise}
   */
  async getForeignKeysForTables(tableNames, options) {
    if (tableNames.length === 0) {
      return {};
    }

    options = { ...options, type: QueryTypes.FOREIGNKEYS };

    const results = await Promise.all(tableNames.map(tableName =>
      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));

    const result = {};

    tableNames.forEach((tableName, i) => {
      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      result[tableName] = Array.isArray(results[i])
        ? results[i].map(r => r.constraint_name)
        : [results[i] && results[i].constraint_name];

      result[tableName] = result[tableName].filter(_.identity);
    });

    return result;
  }

  /**
   * Get foreign key references details for the table
   *
   * Those details contains constraintSchema, constraintName, constraintCatalog
   * tableCatalog, tableSchema, tableName, columnName,
   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.
   * Remind: constraint informations won't return if it's sqlite.
   *
   * @param {string} tableName table name
   * @param {object} [options]  Query options
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };
    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);
    return this.sequelize.query(query, queryOptions);
  }

  /**
   * Remove an already existing index from a table
   *
   * @param {string} tableName                    Table name to drop index from
   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index
   * @param {object} [options]                    Query options
   *
   * @returns {Promise}
   */
  async removeIndex(tableName, indexNameOrAttributes, options) {
    options = options || {};
    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Add a constraint to a table
   *
   * Available constraints:
   * - UNIQUE
   * - DEFAULT (MSSQL only)
   * - CHECK (MySQL - Ignored by the database engine )
   * - FOREIGN KEY
   * - PRIMARY KEY
   *
   * @example <caption>UNIQUE</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['email'],
   *   type: 'unique',
   *   name: 'custom_unique_constraint_name'
   * });
   *
   * @example <caption>CHECK</caption>
   * queryInterface.addConstraint('Users', {
   *   fields: ['roles'],
   *   type: 'check',
   *   where: {
   *      roles: ['user', 'admin', 'moderator', 'guest']
   *   }
   * });
   *
   * @example <caption>Default - MSSQL only</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['roles'],
   *    type: 'default',
   *    defaultValue: 'guest'
   * });
   *
   * @example <caption>Primary Key</caption>
   * queryInterface.addConstraint('Users', {
   *    fields: ['username'],
   *    type: 'primary key',
   *    name: 'custom_primary_constraint_name'
   * });
   *
   * @example <caption>Foreign Key</caption>
   * queryInterface.addConstraint('Posts', {
   *   fields: ['username'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     field: 'target_column_name'
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @example <caption>Composite Foreign Key</caption>
   * queryInterface.addConstraint('TableName', {
   *   fields: ['source_column_name', 'other_source_column_name'],
   *   type: 'foreign key',
   *   name: 'custom_fkey_constraint_name',
   *   references: { //Required field
   *     table: 'target_table_name',
   *     fields: ['target_column_name', 'other_target_column_name']
   *   },
   *   onDelete: 'cascade',
   *   onUpdate: 'cascade'
   * });
   *
   * @param {string} tableName                   Table name where you want to add a constraint
   * @param {object} options                     An object to define the constraint name, type etc
   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)
   * @param {Array}  options.fields              Array of column names to apply the constraint over
   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names
   * @param {string} [options.defaultValue]      The value for the default constraint
   * @param {object} [options.where]             Where clause/expression for the CHECK constraint
   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint
   * @param {string} [options.references.table]  Target table name
   * @param {string} [options.references.field]  Target column name
   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.
   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only
   *
   * @returns {Promise}
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.addConstraintQuery(tableName, options);
    return await this.sequelize.query(sql, options);
  }

  async showConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);
    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });
  }

  /**
   * Remove a constraint from a table
   *
   * @param {string} tableName       Table name to drop constraint from
   * @param {string} constraintName  Constraint name
   * @param {object} options         Query options
   */
  async removeConstraint(tableName, constraintName, options) {
    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);
  }

  async insert(instance, tableName, values, options) {
    options = Utils.cloneDeep(options);
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;
    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);

    options.type = QueryTypes.INSERT;
    options.instance = instance;

    const results = await this.sequelize.query(sql, options);
    if (instance) results[0].isNewRecord = false;

    return results;
  }

  /**
   * Upsert
   *
   * @param {string} tableName    table to upsert on
   * @param {object} insertValues values to be inserted, mapped to field name
   * @param {object} updateValues values to be updated, mapped to field name
   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails
   * @param {object} options      query options
   *
   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    const model = options.model;
    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);
    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length >= 1).map(c => c.fields);
    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length >= 1).map(c => c.fields);

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);
    options.upsertKeys = [];

    // For fields in updateValues, try to find a constraint or unique index
    // that includes given field. Only first matching upsert key is used.
    for (const field of options.updateOnDuplicate) {
      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));
      if (uniqueKey) {
        options.upsertKeys = uniqueKey;
        break;
      }

      const indexKey = indexKeys.find(fields => fields.includes(field));
      if (indexKey) {
        options.upsertKeys = indexKey;
        break;
      }
    }

    // Always use PK, if no constraint available OR update data contains PK
    if (
      options.upsertKeys.length === 0
      || _.intersection(options.updateOnDuplicate, primaryKeys).length
    ) {
      options.upsertKeys = primaryKeys;
    }

    options.upsertKeys = _.uniq(options.upsertKeys);

    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * Insert multiple records into a table
   *
   * @example
   * queryInterface.bulkInsert('roles', [{
   *    label: 'user',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }, {
   *    label: 'admin',
   *    createdAt: new Date(),
   *    updatedAt: new Date()
   *  }]);
   *
   * @param {string} tableName   Table name to insert record to
   * @param {Array}  records     List of records to insert
   * @param {object} options     Various options, please see Model.bulkCreate options
   * @param {object} attributes  Various attributes mapped by field name
   *
   * @returns {Promise}
   */
  async bulkInsert(tableName, records, options, attributes) {
    options = { ...options };
    options.type = QueryTypes.INSERT;

    const results = await this.sequelize.query(
      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),
      options
    );

    return results[0];
  }

  async update(instance, tableName, values, identifier, options) {
    options = { ...options };
    options.hasTrigger = instance && instance.constructor.options.hasTrigger;

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);

    options.type = QueryTypes.UPDATE;

    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Update multiple records of a table
   *
   * @example
   * queryInterface.bulkUpdate('roles', {
   *     label: 'admin',
   *   }, {
   *     userType: 3,
   *   },
   * );
   *
   * @param {string} tableName     Table name to update
   * @param {object} values        Values to be inserted, mapped to field name
   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions
   * @param {object} [options]     Various options, please see Model.bulkCreate options
   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect
   *
   * @returns {Promise}
   */
  async bulkUpdate(tableName, values, identifier, options, attributes) {
    options = Utils.cloneDeep(options);
    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);

    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);
    const table = _.isObject(tableName) ? tableName : { tableName };
    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });

    options.type = QueryTypes.BULKUPDATE;
    options.model = model;
    return await this.sequelize.query(sql, options);
  }

  async delete(instance, tableName, identifier, options) {
    const cascades = [];
    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);

    options = { ...options };

    // Check for a restrict field
    if (!!instance.constructor && !!instance.constructor.associations) {
      const keys = Object.keys(instance.constructor.associations);
      const length = keys.length;
      let association;

      for (let i = 0; i < length; i++) {
        association = instance.constructor.associations[keys[i]];
        if (association.options && association.options.onDelete &&
          association.options.onDelete.toLowerCase() === 'cascade' &&
          association.options.useHooks === true) {
          cascades.push(association.accessors.get);
        }
      }
    }

    for (const cascade of cascades) {
      let instances = await instance[cascade](options);
      // Check for hasOne relationship with non-existing associate ("has zero")
      if (!instances) continue;
      if (!Array.isArray(instances)) instances = [instances];
      for (const _instance of instances) await _instance.destroy(options);
    }
    options.instance = instance;
    return await this.sequelize.query(sql, options);
  }

  /**
   * Delete multiple records from a table
   *
   * @param {string}  tableName            table name from where to delete records
   * @param {object}  where                where conditions to find records to delete
   * @param {object}  [options]            options
   * @param {boolean} [options.truncate]   Use truncate table command
   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param {Model}   [model]              Model
   *
   * @returns {Promise}
   */
  async bulkDelete(tableName, where, options, model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { limit: null });

    if (options.truncate === true) {
      return this.sequelize.query(
        this.queryGenerator.truncateTableQuery(tableName, options),
        options
      );
    }

    if (typeof identifier === 'object') where = Utils.cloneDeep(where);

    return await this.sequelize.query(
      this.queryGenerator.deleteQuery(tableName, where, options, model),
      options
    );
  }

  async select(model, tableName, optionsArg) {
    const options = { ...optionsArg, type: QueryTypes.SELECT, model };

    return await this.sequelize.query(
      this.queryGenerator.selectQuery(tableName, options, model),
      options
    );
  }

  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    options = Utils.cloneDeep(options);

    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);

    options.type = QueryTypes.UPDATE;
    options.model = model;

    return await this.sequelize.query(sql, options);
  }

  async rawSelect(tableName, options, attributeSelector, Model) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT
    });

    const sql = this.queryGenerator.selectQuery(tableName, options, Model);

    if (attributeSelector === undefined) {
      throw new Error('Please pass an attribute selector!');
    }

    const data = await this.sequelize.query(sql, options);
    if (!options.plain) {
      return data;
    }

    const result = data ? data[attributeSelector] : null;

    if (!options || !options.dataType) {
      return result;
    }

    const dataType = options.dataType;

    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {
      if (result !== null) {
        return parseFloat(result);
      }
    }
    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {
      return parseInt(result, 10);
    }
    if (dataType instanceof DataTypes.DATE) {
      if (result !== null && !(result instanceof Date)) {
        return new Date(result);
      }
    }
    return result;
  }

  async createTrigger(
    tableName,
    triggerName,
    timingType,
    fireOnArray,
    functionName,
    functionParams,
    optionsArray,
    options
  ) {
    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);
    options = options || {};
    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async dropTrigger(tableName, triggerName, options) {
    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {
    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Create an SQL function
   *
   * @example
   * queryInterface.createFunction(
   *   'someFunction',
   *   [
   *     {type: 'integer', name: 'param', direction: 'IN'}
   *   ],
   *   'integer',
   *   'plpgsql',
   *   'RETURN param + 1;',
   *   [
   *     'IMMUTABLE',
   *     'LEAKPROOF'
   *   ],
   *   {
   *    variables:
   *      [
   *        {type: 'integer', name: 'myVar', default: 100}
   *      ],
   *      force: true
   *   };
   * );
   *
   * @param {string}  functionName  Name of SQL function to create
   * @param {Array}   params        List of parameters declared for SQL function
   * @param {string}  returnType    SQL type of function returned value
   * @param {string}  language      The name of the language that the function is implemented in
   * @param {string}  body          Source code of function
   * @param {Array}   optionsArray  Extra-options for creation
   * @param {object}  [options]     query options
   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false
   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.
   *
   * @returns {Promise}
   */
  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Drop an SQL function
   *
   * @example
   * queryInterface.dropFunction(
   *   'someFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ]
   * );
   *
   * @param {string} functionName Name of SQL function to drop
   * @param {Array}  params       List of parameters declared for SQL function
   * @param {object} [options]    query options
   *
   * @returns {Promise}
   */
  async dropFunction(functionName, params, options) {
    const sql = this.queryGenerator.dropFunction(functionName, params);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  /**
   * Rename an SQL function
   *
   * @example
   * queryInterface.renameFunction(
   *   'fooFunction',
   *   [
   *     {type: 'varchar', name: 'param1', direction: 'IN'},
   *     {type: 'integer', name: 'param2', direction: 'INOUT'}
   *   ],
   *   'barFunction'
   * );
   *
   * @param {string} oldFunctionName  Current name of function
   * @param {Array}  params           List of parameters declared for SQL function
   * @param {string} newFunctionName  New name of function
   * @param {object} [options]        query options
   *
   * @returns {Promise}
   */
  async renameFunction(oldFunctionName, params, newFunctionName, options) {
    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);
    options = options || {};

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  // Helper methods useful for querying

  /**
   * @private
   */
  ensureEnums() {
    // noop by default
  }

  async setIsolationLevel(transaction, value, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to set isolation level for a transaction without transaction object!');
    }

    if (transaction.parent || !value) {
      // Not possible to set a separate isolation level for savepoints
      return;
    }

    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.setIsolationLevelQuery(value, {
      parent: transaction.parent
    });

    if (!sql) return;

    return await this.sequelize.query(sql, options);
  }

  async startTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to start a transaction without transaction object!');
    }

    options = { ...options, transaction: transaction.parent || transaction };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.startTransactionQuery(transaction);

    return await this.sequelize.query(sql, options);
  }

  async deferConstraints(transaction, options) {
    options = { ...options, transaction: transaction.parent || transaction };

    const sql = this.queryGenerator.deferConstraintsQuery(options);

    if (sql) {
      return await this.sequelize.query(sql, options);
    }
  }

  async commitTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to commit a transaction without transaction object!');
    }
    if (transaction.parent) {
      // Savepoints cannot be committed
      return;
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };

    const sql = this.queryGenerator.commitTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'commit';

    return await promise;
  }

  async rollbackTransaction(transaction, options) {
    if (!transaction || !(transaction instanceof Transaction)) {
      throw new Error('Unable to rollback a transaction without transaction object!');
    }

    options = {
      ...options,
      transaction: transaction.parent || transaction,
      supportsSearchPath: false,
      completesTransaction: true
    };
    options.transaction.name = transaction.parent ? transaction.name : undefined;
    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);
    const promise = this.sequelize.query(sql, options);

    transaction.finished = 'rollback';

    return await promise;
  }
}

exports.QueryInterface = QueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const SqlString = __webpack_require__(/*! ../../sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Dot = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");
const deprecations = __webpack_require__(/*! ../../utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");
const uuid = __webpack_require__(/*! uuid */ "uuid").v4;

class AbstractQuery {

  constructor(connection, sequelize, options) {
    this.uuid = uuid();
    this.connection = connection;
    this.instance = options.instance;
    this.model = options.model;
    this.sequelize = sequelize;
    this.options = {
      plain: false,
      raw: false,
      // eslint-disable-next-line no-console
      logging: console.log,
      ...options
    };
    this.checkLoggingOption();
  }

  /**
   * rewrite query with parameters
   *
   * Examples:
   *
   *   query.formatBindParameters('select $1 as foo', ['fooval']);
   *
   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });
   *
   * Options
   *   skipUnescape: bool, skip unescaping $$
   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available
   *
   * @param {string} sql
   * @param {object|Array} values
   * @param {string} dialect
   * @param {Function} [replacementFunc]
   * @param {object} [options]
   * @private
   */
  static formatBindParameters(sql, values, dialect, replacementFunc, options) {
    if (!values) {
      return [sql, []];
    }

    options = options || {};
    if (typeof replacementFunc !== 'function') {
      options = replacementFunc || {};
      replacementFunc = undefined;
    }

    if (!replacementFunc) {
      if (options.skipValueReplace) {
        replacementFunc = (match, key, values) => {
          if (values[key] !== undefined) {
            return match;
          }
          return undefined;
        };
      } else {
        replacementFunc = (match, key, values, timeZone, dialect) => {
          if (values[key] !== undefined) {
            return SqlString.escape(values[key], timeZone, dialect);
          }
          return undefined;
        };
      }
    } else if (options.skipValueReplace) {
      const origReplacementFunc = replacementFunc;
      replacementFunc = (match, key, values, timeZone, dialect, options) => {
        if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {
          return match;
        }
        return undefined;
      };
    }

    const timeZone = null;
    const list = Array.isArray(values);
    sql = sql.replace(/\B\$(\$|\w+)/g, (match, key) => {
      if ('$' === key) {
        return options.skipUnescape ? match : key;
      }

      let replVal;
      if (list) {
        if (key.match(/^[1-9]\d*$/)) {
          key = key - 1;
          replVal = replacementFunc(match, key, values, timeZone, dialect, options);
        }
      } else if (!key.match(/^\d*$/)) {
        replVal = replacementFunc(match, key, values, timeZone, dialect, options);
      }
      if (replVal === undefined) {
        throw new Error(`Named bind parameter "${match}" has no value in the given object.`);
      }
      return replVal;
    });
    return [sql, []];
  }

  /**
   * Execute the passed sql query.
   *
   * Examples:
   *
   *     query.run('SELECT 1')
   *
   * @private
   */
  run() {
    throw new Error('The run method wasn\'t overwritten!');
  }

  /**
   * Check the logging option of the instance and print deprecation warnings.
   *
   * @private
   */
  checkLoggingOption() {
    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }
  }

  /**
   * Get the attributes of an insert query, which contains the just inserted id.
   *
   * @returns {string} The field name.
   * @private
   */
  getInsertIdField() {
    return 'insertId';
  }

  getUniqueConstraintErrorMessage(field) {
    let message = field ? `${field} must be unique` : 'Must be unique';

    if (field && this.model) {
      for (const key of Object.keys(this.model.uniqueKeys)) {
        if (this.model.uniqueKeys[key].fields.includes(field.replace(/"/g, ''))) {
          if (this.model.uniqueKeys[key].msg) {
            message = this.model.uniqueKeys[key].msg;
          }
        }
      }
    }
    return message;
  }

  isRawQuery() {
    return this.options.type === QueryTypes.RAW;
  }

  isVersionQuery() {
    return this.options.type === QueryTypes.VERSION;
  }

  isUpsertQuery() {
    return this.options.type === QueryTypes.UPSERT;
  }

  isInsertQuery(results, metaData) {
    let result = true;

    if (this.options.type === QueryTypes.INSERT) {
      return true;
    }

    // is insert query if sql contains insert into
    result = result && this.sql.toLowerCase().startsWith('insert into');

    // is insert query if no results are passed or if the result has the inserted id
    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));

    // is insert query if no metadata are passed or if the metadata has the inserted id
    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));

    return result;
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;

      id = id || results && results[this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];

      this.instance[autoIncrementAttribute] = id;
    }
  }

  isShowTablesQuery() {
    return this.options.type === QueryTypes.SHOWTABLES;
  }

  handleShowTablesQuery(results) {
    return _.flatten(results.map(resultSet => Object.values(resultSet)));
  }

  isShowIndexesQuery() {
    return this.options.type === QueryTypes.SHOWINDEXES;
  }

  isShowConstraintsQuery() {
    return this.options.type === QueryTypes.SHOWCONSTRAINTS;
  }

  isDescribeQuery() {
    return this.options.type === QueryTypes.DESCRIBE;
  }

  isSelectQuery() {
    return this.options.type === QueryTypes.SELECT;
  }

  isBulkUpdateQuery() {
    return this.options.type === QueryTypes.BULKUPDATE;
  }

  isBulkDeleteQuery() {
    return this.options.type === QueryTypes.BULKDELETE;
  }

  isForeignKeysQuery() {
    return this.options.type === QueryTypes.FOREIGNKEYS;
  }

  isUpdateQuery() {
    return this.options.type === QueryTypes.UPDATE;
  }

  handleSelectQuery(results) {
    let result = null;

    // Map raw fields to names if a mapping is provided
    if (this.options.fieldMap) {
      const fieldMap = this.options.fieldMap;
      results = results.map(result => _.reduce(fieldMap, (result, name, field) => {
        if (result[field] !== undefined && name !== field) {
          result[name] = result[field];
          delete result[field];
        }
        return result;
      }, result));
    }

    // Raw queries
    if (this.options.raw) {
      result = results.map(result => {
        let o = {};

        for (const key in result) {
          if (Object.prototype.hasOwnProperty.call(result, key)) {
            o[key] = result[key];
          }
        }

        if (this.options.nest) {
          o = Dot.transform(o);
        }

        return o;
      });
    // Queries with include
    } else if (this.options.hasJoin === true) {
      results = AbstractQuery._groupJoinData(results, {
        model: this.model,
        includeMap: this.options.includeMap,
        includeNames: this.options.includeNames
      }, {
        checkExisting: this.options.hasMultiAssociation
      });

      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        include: this.options.include,
        includeNames: this.options.includeNames,
        includeMap: this.options.includeMap,
        includeValidated: true,
        attributes: this.options.originalAttributes || this.options.attributes,
        raw: true
      });
    // Regular queries
    } else {
      result = this.model.bulkBuild(results, {
        isNewRecord: false,
        raw: true,
        attributes: this.options.originalAttributes || this.options.attributes
      });
    }

    // return the first real model instance if options.plain is set (e.g. Model.find)
    if (this.options.plain) {
      result = result.length === 0 ? null : result[0];
    }
    return result;
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith('show');
    result = result || this.sql.toLowerCase().startsWith('describe');

    return result;
  }

  isCallQuery() {
    return this.sql.toLowerCase().startsWith('call');
  }

  /**
   * @param {string} sql
   * @param {Function} debugContext
   * @param {Array|object} parameters
   * @protected
   * @returns {Function} A function to call after the query was completed.
   */
  _logQuery(sql, debugContext, parameters) {
    const { connection, options } = this;
    const benchmark = this.sequelize.options.benchmark || options.benchmark;
    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;
    const startTime = Date.now();
    let logParameter = '';

    if (logQueryParameters && parameters) {
      const delimiter = sql.endsWith(';') ? '' : ';';
      let paramStr;
      if (Array.isArray(parameters)) {
        paramStr = parameters.map(p=>JSON.stringify(p)).join(', ');
      } else {
        paramStr = JSON.stringify(parameters);
      }
      logParameter = `${delimiter} ${paramStr}`;
    }
    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;
    const msg = `Executing ${fmt}`;
    debugContext(msg);
    if (!benchmark) {
      this.sequelize.log(`Executing ${fmt}`, options);
    }
    return () => {
      const afterMsg = `Executed ${fmt}`;
      debugContext(afterMsg);
      if (benchmark) {
        this.sequelize.log(afterMsg, Date.now() - startTime, options);
      }
    };
  }

  /**
   * The function takes the result of the query execution and groups
   * the associated data by the callee.
   *
   * Example:
   *   groupJoinData([
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 1 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 2 }
   *     }, {
   *       some: 'data',
   *       id: 1,
   *       association: { foo: 'bar', id: 3 }
   *     }
   *   ])
   *
   * Result:
   *   Something like this:
   *
   *   [
   *     {
   *       some: 'data',
   *       id: 1,
   *       association: [
   *         { foo: 'bar', id: 1 },
   *         { foo: 'bar', id: 2 },
   *         { foo: 'bar', id: 3 }
   *       ]
   *     }
   *   ]
   *
   * @param {Array} rows
   * @param {object} includeOptions
   * @param {object} options
   * @private
   */
  static _groupJoinData(rows, includeOptions, options) {

    /*
     * Assumptions
     * ID is not necessarily the first field
     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)
     * Parent keys will be seen before any include/child keys
     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)
     */

    /*
     * Author (MH) comment: This code is an unreadable mess, but it's performant.
     * groupJoinData is a performance critical function so we prioritize perf over readability.
     */
    if (!rows.length) {
      return [];
    }

    // Generic looping
    let i;
    let length;
    let $i;
    let $length;
    // Row specific looping
    let rowsI;
    let row;
    const rowsLength = rows.length;
    // Key specific looping
    let keys;
    let key;
    let keyI;
    let keyLength;
    let prevKey;
    let values;
    let topValues;
    let topExists;
    const checkExisting = options.checkExisting;
    // If we don't have to deduplicate we can pre-allocate the resulting array
    let itemHash;
    let parentHash;
    let topHash;
    const results = checkExisting ? [] : new Array(rowsLength);
    const resultMap = {};
    const includeMap = {};
    // Result variables for the respective functions
    let $keyPrefix;
    let $keyPrefixString;
    let $prevKeyPrefixString; // eslint-disable-line
    let $prevKeyPrefix;
    let $lastKeyPrefix;
    let $current;
    let $parent;
    // Map each key to an include option
    let previousPiece;
    const buildIncludeMap = piece => {
      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {
        includeMap[key] = $current = $current.includeMap[piece];
        if (previousPiece) {
          previousPiece = `${previousPiece}.${piece}`;
        } else {
          previousPiece = piece;
        }
        includeMap[previousPiece] = $current;
      }
    };
    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')
    const keyPrefixStringMemo = {};
    const keyPrefixString = (key, memo) => {
      if (!Object.prototype.hasOwnProperty.call(memo, key)) {
        memo[key] = key.substr(0, key.lastIndexOf('.'));
      }
      return memo[key];
    };
    // Removes the prefix from a key ('id' for 'User.Results.id')
    const removeKeyPrefixMemo = {};
    const removeKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {
        const index = key.lastIndexOf('.');
        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);
      }
      return removeKeyPrefixMemo[key];
    };
    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')
    const keyPrefixMemo = {};
    const keyPrefix = key => {
      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values
      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {
        const prefixString = keyPrefixString(key, keyPrefixStringMemo);
        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {
          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];
        }
        keyPrefixMemo[key] = keyPrefixMemo[prefixString];
      }
      return keyPrefixMemo[key];
    };
    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')
    const lastKeyPrefixMemo = {};
    const lastKeyPrefix = key => {
      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {
        const prefix = keyPrefix(key);
        const length = prefix.length;

        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];
      }
      return lastKeyPrefixMemo[key];
    };
    const getUniqueKeyAttributes = model => {
      let uniqueKeyAttributes = _.chain(model.uniqueKeys);
      uniqueKeyAttributes = uniqueKeyAttributes
        .result(`${uniqueKeyAttributes.findKey()}.fields`)
        .map(field => _.findKey(model.attributes, chr => chr.field === field))
        .value();

      return uniqueKeyAttributes;
    };
    const stringify = obj => obj instanceof Buffer ? obj.toString('hex') : obj;
    let primaryKeyAttributes;
    let uniqueKeyAttributes;
    let prefix;

    for (rowsI = 0; rowsI < rowsLength; rowsI++) {
      row = rows[rowsI];

      // Keys are the same for all rows, so only need to compute them on the first row
      if (rowsI === 0) {
        keys = Object.keys(row);
        keyLength = keys.length;
      }

      if (checkExisting) {
        topExists = false;

        // Compute top level hash key (this is usually just the primary key values)
        $length = includeOptions.model.primaryKeyAttributes.length;
        topHash = '';
        if ($length === 1) {
          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);
        }
        else if ($length > 1) {
          for ($i = 0; $i < $length; $i++) {
            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);
          }
        }
        else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {
          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);
          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
            topHash += row[uniqueKeyAttributes[$i]];
          }
        }
      }

      topValues = values = {};
      $prevKeyPrefix = undefined;
      for (keyI = 0; keyI < keyLength; keyI++) {
        key = keys[keyI];

        // The string prefix isn't actualy needed
        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix
        // TODO: Find a better way?
        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);
        $keyPrefix = keyPrefix(key);

        // On the first row we compute the includeMap
        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {
          if (!$keyPrefix.length) {
            includeMap[key] = includeMap[''] = includeOptions;
          } else {
            $current = includeOptions;
            previousPiece = undefined;
            $keyPrefix.forEach(buildIncludeMap);
          }
        }
        // End of key set
        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {
          if (checkExisting) {
            // Compute hash key for this set instance
            // TODO: Optimize
            length = $prevKeyPrefix.length;
            $parent = null;
            parentHash = null;

            if (length) {
              for (i = 0; i < length; i++) {
                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                $length = primaryKeyAttributes.length;
                itemHash = prefix;
                if ($length === 1) {
                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
                }
                else if ($length > 1) {
                  for ($i = 0; $i < $length; $i++) {
                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
                  }
                }
                else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
                  }
                }
                if (!parentHash) {
                  parentHash = topHash;
                }

                itemHash = parentHash + itemHash;
                $parent = prefix;
                if (i < length - 1) {
                  parentHash = itemHash;
                }
              }
            } else {
              itemHash = topHash;
            }

            if (itemHash === topHash) {
              if (!resultMap[itemHash]) {
                resultMap[itemHash] = values;
              } else {
                topExists = true;
              }
            } else if (!resultMap[itemHash]) {
              $parent = resultMap[parentHash];
              $lastKeyPrefix = lastKeyPrefix(prevKey);

              if (includeMap[prevKey].association.isSingleAssociation) {
                if ($parent) {
                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                }
              } else {
                if (!$parent[$lastKeyPrefix]) {
                  $parent[$lastKeyPrefix] = [];
                }
                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
              }
            }

            // Reset values
            values = {};
          } else {
            // If checkExisting is false it's because there's only 1:1 associations in this query
            // However we still need to map onto the appropriate parent
            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop
            $current = topValues;
            length = $keyPrefix.length;
            if (length) {
              for (i = 0; i < length; i++) {
                if (i === length - 1) {
                  values = $current[$keyPrefix[i]] = {};
                }
                $current = $current[$keyPrefix[i]] || {};
              }
            }
          }
        }

        // End of iteration, set value and set prev values (for next iteration)
        values[removeKeyPrefix(key)] = row[key];
        prevKey = key;
        $prevKeyPrefix = $keyPrefix;
        $prevKeyPrefixString = $keyPrefixString;
      }

      if (checkExisting) {
        length = $prevKeyPrefix.length;
        $parent = null;
        parentHash = null;

        if (length) {
          for (i = 0; i < length; i++) {
            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
            $length = primaryKeyAttributes.length;
            itemHash = prefix;
            if ($length === 1) {
              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
            }
            else if ($length > 0) {
              for ($i = 0; $i < $length; $i++) {
                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
              }
            }
            else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
              }
            }
            if (!parentHash) {
              parentHash = topHash;
            }

            itemHash = parentHash + itemHash;
            $parent = prefix;
            if (i < length - 1) {
              parentHash = itemHash;
            }
          }
        } else {
          itemHash = topHash;
        }

        if (itemHash === topHash) {
          if (!resultMap[itemHash]) {
            resultMap[itemHash] = values;
          } else {
            topExists = true;
          }
        } else if (!resultMap[itemHash]) {
          $parent = resultMap[parentHash];
          $lastKeyPrefix = lastKeyPrefix(prevKey);

          if (includeMap[prevKey].association.isSingleAssociation) {
            if ($parent) {
              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
            }
          } else {
            if (!$parent[$lastKeyPrefix]) {
              $parent[$lastKeyPrefix] = [];
            }
            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
          }
        }
        if (!topExists) {
          results.push(topValues);
        }
      } else {
        results[rowsI] = topValues;
      }
    }

    return results;
  }
}

module.exports = AbstractQuery;
module.exports.AbstractQuery = AbstractQuery;
module.exports.default = AbstractQuery;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/abstract sync recursive":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/ sync ***!
  \************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/sequelize/lib/dialects/abstract sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mariadb');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mariadb');

/**
 * MariaDB Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MariaDB specific connections
 * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mariadb');
    this.refreshTypeParser(DataTypes);
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  /**
   * Connect with MariaDB database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    // Named timezone is not supported in mariadb, convert to offset
    let tzOffset = this.sequelize.options.timezone;
    tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')
      : tzOffset;

    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      password: config.password,
      database: config.database,
      timezone: tzOffset,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      foundRows: false,
      ...config.dialectOptions
    };

    if (!this.sequelize.config.keepDefaultTimezone) {
      // set timezone for this connection
      if (connectionConfig.initSql) {
        if (!Array.isArray(
          connectionConfig.initSql)) {
          connectionConfig.initSql = [connectionConfig.initSql];
        }
        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);
      } else {
        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;
      }
    }

    try {
      const connection = await this.lib.createConnection(connectionConfig);
      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });
      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
        case 'ENETUNREACH':
        case 'EADDRNOTAVAIL':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (!connection.isValid()) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }
    return await connection.end();
  }

  validate(connection) {
    return connection && connection.isValid();
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");

module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';

  /**
   * types: [buffer_type, ...]
   *
   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types
   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js
   */

  BaseTypes.DATE.types.mariadb = ['DATETIME'];
  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];
  BaseTypes.CHAR.types.mariadb = ['STRING'];
  BaseTypes.TEXT.types.mariadb = ['BLOB'];
  BaseTypes.TINYINT.types.mariadb = ['TINY'];
  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];
  BaseTypes.INTEGER.types.mariadb = ['LONG'];
  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];
  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];
  BaseTypes.TIME.types.mariadb = ['TIME'];
  BaseTypes.DATEONLY.types.mariadb = ['DATE'];
  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];
  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mariadb = false;
  BaseTypes.ENUM.types.mariadb = false;
  BaseTypes.REAL.types.mariadb = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];
  BaseTypes.JSON.types.mariadb = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      return date.format('YYYY-MM-DD HH:mm:ss.SSS');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
      }
      else {
        this.sqlType = this.type;
      }
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value
        : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mariadb/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js");
const { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mariadb;

class MariadbDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MariadbDialect.prototype.supports = _.merge(
  _.cloneDeep(AbstractDialect.prototype.supports), {
    'VALUES ()': true,
    'LIMIT ON UPDATE': true,
    lock: true,
    forShare: 'LOCK IN SHARE MODE',
    settingIsolationLevelDuringTransaction: false,
    schemas: true,
    inserts: {
      ignoreDuplicates: ' IGNORE',
      updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
    },
    index: {
      collate: false,
      length: true,
      parser: true,
      type: true,
      using: 1
    },
    constraints: {
      dropConstraint: false,
      check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: true,
    JSON: true,
    REGEXP: true
  });

MariadbDialect.prototype.defaultVersion = '10.1.44';
MariadbDialect.prototype.Query = Query;
MariadbDialect.prototype.QueryGenerator = QueryGenerator;
MariadbDialect.prototype.DataTypes = DataTypes;
MariadbDialect.prototype.name = 'mariadb';
MariadbDialect.prototype.TICK_CHAR = '`';
MariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;
MariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;

module.exports = MariadbDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const Utils = __webpack_require__(/*! ./../../utils */ "./node_modules/sequelize/lib/utils.js");

class MariaDBQueryGenerator extends MySQLQueryGenerator {
  createSchema(schema, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE SCHEMA IF NOT EXISTS',
      this.quoteIdentifier(schema),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;
  }

  showSchemasQuery(options) {
    const schemasToSkip = [
      '\'MYSQL\'',
      '\'INFORMATION_SCHEMA\'',
      '\'PERFORMANCE_SCHEMA\''
    ];
    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {
      for (const schemaName of options.skip) {
        schemasToSkip.push(this.escape(schemaName));
      }
    }
    return Utils.joinSQLFragments([
      'SELECT SCHEMA_NAME as schema_name',
      'FROM INFORMATION_SCHEMA.SCHEMATA',
      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(', ')})`,
      ';'
    ]);
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\')';
    }
    return `${query};`;
  }
}

module.exports = MariaDBQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mariadb');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      results = await connection.query(this.sql, parameters);
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MariaDB automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MariaDB automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          // ONLY TRUE IF @auto_increment_increment is set to 1 !!
          // Doesn't work with GALERA => each node will reserve increment (x for first server, x+1 for next node...)
          const startId = data[this.getInsertIdField()];
          result = new Array(data.affectedRows);
          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;
          for (let i = 0; i < data.affectedRows; i++) {
            result[i] = { [pkField]: startId + i };
          }
          return [result, data.affectedRows];
        }

        return [data[this.getInsertIdField()], data.affectedRows];
      }
    }

    if (this.isSelectQuery()) {
      this.handleJsonSelectQuery(data);
      return this.handleSelectQuery(data);
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isRawQuery()) {
      const meta = data.meta;
      delete data.meta;
      return [data, meta];
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        result[_result.Field] = {
          type: _result.Type.toLowerCase().startsWith('enum') ? _result.Type.replace(/^enum/i,
            'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }

    return result;
  }

  handleJsonSelectQuery(rows) {
    if (!this.model || !this.model.fieldRawAttributesMap) {
      return;
    }
    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {
      const modelField = this.model.fieldRawAttributesMap[_field];
      if (modelField.type instanceof DataTypes.JSON) {
        // Value is returned as String, not JSON
        rows = rows.map(row => {
          row[modelField.fieldName] = row[modelField.fieldName] ? JSON.parse(
            row[modelField.fieldName]) : null;
          if (DataTypes.JSON.parse) {
            return DataTypes.JSON.parse(modelField, this.sequelize.options,
              row[modelField.fieldName]);
          }
          return row;
        });
      }
    }
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MariaDB Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    switch (err.errno) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(
          /Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?\s.*$/);

        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: err.errno === ER_ROW_IS_REFERENCED ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => ({
      tableName: resultSet.TABLE_NAME,
      schema: resultSet.TABLE_SCHEMA
    }));
  }

  handleShowIndexesQuery(data) {

    let currItem;
    const result = [];

    data.forEach(item => {
      if (!currItem || currItem.name !== item.Key_name) {
        currItem = {
          primary: item.Key_name === 'PRIMARY',
          fields: [],
          name: item.Key_name,
          tableName: item.Table,
          unique: item.Non_unique !== 1,
          type: item.Index_type
        };
        result.push(currItem);
      }

      currItem.fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
    });

    return result;
  }
}

module.exports = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ../../errors/base-error */ "./node_modules/sequelize/lib/errors/base-error.js");
const ConnectionError = __webpack_require__(/*! ../../errors/connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is closed while an operation is in progress
 */
class AsyncQueueError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAsyncQueueError';
  }
}

exports.AsyncQueueError = AsyncQueueError;

class AsyncQueue {
  constructor() {
    this.previous = Promise.resolve();
    this.closed = false;
    this.rejectCurrent = () => {};
  }
  close() {
    this.closed = true;
    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));
  }
  enqueue(asyncFunction) {
    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).
    // However, this ensures that this.previous will never be a rejected promise so the queue will
    // always keep going, while still communicating rejection from asyncFunction to the user.
    return new Promise((resolve, reject) => {
      this.previous = this.previous.then(
        () => {
          this.rejectCurrent = reject;
          if (this.closed) {
            return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));
          }
          return asyncFunction().then(resolve, reject);
        }
      );
    });
  }
}

exports.default = AsyncQueue;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const AsyncQueue = __webpack_require__(/*! ./async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").default;
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const debug = logger.debugContext('connection:mssql');
const debugTedious = logger.debugContext('connection:mssql:tedious');

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 1433;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('tedious');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async connect(config) {
    const connectionConfig = {
      server: config.host,
      authentication: {
        type: 'default',
        options: {
          userName: config.username || undefined,
          password: config.password || undefined
        }
      },
      options: {
        port: parseInt(config.port, 10),
        database: config.database,
        trustServerCertificate: true
      }
    };

    if (config.dialectOptions) {
      // only set port if no instance name was provided
      if (
        config.dialectOptions.options &&
        config.dialectOptions.options.instanceName
      ) {
        delete connectionConfig.options.port;
      }

      if (config.dialectOptions.authentication) {
        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);
      }

      Object.assign(connectionConfig.options, config.dialectOptions.options);
    }

    try {
      return await new Promise((resolve, reject) => {
        const connection = new this.lib.Connection(connectionConfig);
        if (connection.state === connection.STATE.INITIALIZED) {
          connection.connect();
        }
        connection.queue = new AsyncQueue();
        connection.lib = this.lib;

        const connectHandler = error => {
          connection.removeListener('end', endHandler);
          connection.removeListener('error', errorHandler);

          if (error) return reject(error);

          debug('connection acquired');
          resolve(connection);
        };

        const endHandler = () => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', errorHandler);
          reject(new Error('Connection was closed by remote server'));
        };

        const errorHandler = error => {
          connection.removeListener('connect', connectHandler);
          connection.removeListener('end', endHandler);
          reject(error);
        };

        connection.once('error', errorHandler);
        connection.once('end', endHandler);
        connection.once('connect', connectHandler);

        /*
         * Permanently attach this event before connection is even acquired
         * tedious sometime emits error even after connect(with error).
         *
         * If we dont attach this even that unexpected error event will crash node process
         *
         * E.g. connectTimeout is set higher than requestTimeout
         */
        connection.on('error', error => {
          switch (error.code) {
            case 'ESOCKET':
            case 'ECONNRESET':
              this.pool.destroy(connection);
          }
        });

        if (config.dialectOptions && config.dialectOptions.debug) {
          connection.on('debug', debugTedious.log.bind(debugTedious));
        }
      });
    } catch (error) {
      if (!error.code) {
        throw new sequelizeErrors.ConnectionError(error);
      }

      switch (error.code) {
        case 'ESOCKET':
          if (error.message.includes('connect EHOSTUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect ENETUNREACH')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('connect EADDRNOTAVAIL')) {
            throw new sequelizeErrors.HostNotReachableError(error);
          }
          if (error.message.includes('getaddrinfo ENOTFOUND')) {
            throw new sequelizeErrors.HostNotFoundError(error);
          }
          if (error.message.includes('connect ECONNREFUSED')) {
            throw new sequelizeErrors.ConnectionRefusedError(error);
          }
          throw new sequelizeErrors.ConnectionError(error);
        case 'ER_ACCESS_DENIED_ERROR':
        case 'ELOGIN':
          throw new sequelizeErrors.AccessDeniedError(error);
        case 'EINVAL':
          throw new sequelizeErrors.InvalidConnectionError(error);
        default:
          throw new sequelizeErrors.ConnectionError(error);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect a connection that is already disconnected
    if (connection.closed) {
      return;
    }

    connection.queue.close();

    return new Promise(resolve => {
      connection.on('end', resolve);
      connection.close();
      debug('connection closed');
    });
  }

  validate(connection) {
    return connection && connection.loggedIn;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const moment = __webpack_require__(/*! moment */ "moment");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');

  /**
   * Removes unsupported MSSQL options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types: [hex, ...]
   *
   * @see hex here https://github.com/tediousjs/tedious/blob/master/src/data-type.ts
   */

  BaseTypes.DATE.types.mssql = [43];
  BaseTypes.STRING.types.mssql = [231, 173];
  BaseTypes.CHAR.types.mssql = [175];
  BaseTypes.TEXT.types.mssql = false;
  // https://msdn.microsoft.com/en-us/library/ms187745(v=sql.110).aspx
  BaseTypes.TINYINT.types.mssql = [30];
  BaseTypes.SMALLINT.types.mssql = [34];
  BaseTypes.MEDIUMINT.types.mssql = false;
  BaseTypes.INTEGER.types.mssql = [38];
  BaseTypes.BIGINT.types.mssql = false;
  BaseTypes.FLOAT.types.mssql = [109];
  BaseTypes.TIME.types.mssql = [41];
  BaseTypes.DATEONLY.types.mssql = [40];
  BaseTypes.BOOLEAN.types.mssql = [104];
  BaseTypes.BLOB.types.mssql = [165];
  BaseTypes.DECIMAL.types.mssql = [106];
  BaseTypes.UUID.types.mssql = false;
  BaseTypes.ENUM.types.mssql = false;
  BaseTypes.REAL.types.mssql = [109];
  BaseTypes.DOUBLE.types.mssql = [109];
  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported
  BaseTypes.GEOMETRY.types.mssql = false;

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');
          return 'VARBINARY(256)';
        }
        warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');
      }
      return 'VARBINARY(MAX)';
    }
    _hexify(hex) {
      return `0x${hex}`;
    }
  }


  class STRING extends BaseTypes.STRING {
    toSql() {
      if (!this._binary) {
        return `NVARCHAR(${this._length})`;
      }
      return `BINARY(${this._length})`;
    }
    _stringify(value, options) {
      if (this._binary) {
        return BLOB.prototype._stringify(value);
      }
      return options.escape(value);
    }
    _bindParam(value, options) {
      return options.bindParam(this._binary ? Buffer.from(value) : value);
    }
  }

  STRING.prototype.escape = false;

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.
      // Using unicode is just future proof
      if (this._length) {
        if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8
          warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');
          return 'NVARCHAR(256)';
        }
        warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');
      }
      return 'NVARCHAR(MAX)';
    }
  }

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BIT';
    }
  }

  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36)';
    }
  }

  class NOW extends BaseTypes.NOW {
    toSql() {
      return 'GETDATE()';
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'DATETIMEOFFSET';
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return moment(value).format('YYYY-MM-DD');
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  class REAL extends BaseTypes.REAL {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does not support any options for real
      if (this._length || this.options.length || this._unsigned || this._zerofill) {
        warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._unsigned = undefined;
        this._zerofill = undefined;
      }
    }
  }
  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // MSSQL does only support lengths as option.
      // Values between 1-24 result in 7 digits precision (4 bytes storage size)
      // Values between 25-53 result in 15 digits precision (8 bytes storage size)
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
      }
      if (this._unsigned) {
        warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'VARCHAR(255)';
    }
  }

  return {
    BLOB,
    BOOLEAN,
    ENUM,
    STRING,
    UUID,
    DATE,
    DATEONLY,
    NOW,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    REAL,
    FLOAT,
    TEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mssql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mssql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mssql;
const { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js");

class MssqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);
  }
}

MssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': true,
  'DEFAULT VALUES': true,
  'LIMIT ON UPDATE': true,
  'ORDER NULLS': false,
  lock: false,
  transactions: true,
  migrations: false,
  returnValues: {
    output: true
  },
  schemas: true,
  autoIncrement: {
    identityInsert: true,
    defaultValue: false,
    update: false
  },
  constraints: {
    restrict: false,
    default: true
  },
  index: {
    collate: false,
    length: false,
    parser: false,
    type: true,
    using: false,
    where: true
  },
  NUMERIC: true,
  tmpTableTrigger: true
});

MssqlDialect.prototype.defaultVersion = '12.0.2000'; // SQL Server 2014 Express
MssqlDialect.prototype.Query = Query;
MssqlDialect.prototype.name = 'mssql';
MssqlDialect.prototype.TICK_CHAR = '"';
MssqlDialect.prototype.TICK_CHAR_LEFT = '[';
MssqlDialect.prototype.TICK_CHAR_RIGHT = ']';
MssqlDialect.prototype.DataTypes = DataTypes;

module.exports = MssqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const TableHints = __webpack_require__(/*! ../../table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const randomBytes = __webpack_require__(/*! crypto */ "crypto").randomBytes;
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");

/* istanbul ignore next */
const throwMethodUndefined = function(methodName) {
  throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};

class MSSQLQueryGenerator extends AbstractQueryGenerator {
  createDatabaseQuery(databaseName, options) {
    options = { collate: null, ...options };

    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';

    return [
      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'CREATE DATABASE', this.quoteIdentifier(databaseName),
      `${collation};`,
      'END;'
    ].join(' ');
  }

  dropDatabaseQuery(databaseName) {
    return [
      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',
      'BEGIN',
      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',
      'END;'
    ].join(' ');
  }

  createSchema(schema) {
    return [
      'IF NOT EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', wrapSingleQuote(schema), ')',
      'BEGIN',
      "EXEC sp_executesql N'CREATE SCHEMA",
      this.quoteIdentifier(schema),
      ";'",
      'END;'
    ].join(' ');
  }

  dropSchema(schema) {
    // Mimics Postgres CASCADE, will drop objects belonging to the schema
    const quotedSchema = wrapSingleQuote(schema);
    return [
      'IF EXISTS (SELECT schema_name',
      'FROM information_schema.schemata',
      'WHERE schema_name =', quotedSchema, ')',
      'BEGIN',
      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',
      'DECLARE @cascade TABLE (',
      'id INT NOT NULL IDENTITY PRIMARY KEY,',
      'ms_sql NVARCHAR(2000) NOT NULL );',
      'INSERT INTO @cascade ( ms_sql )',
      "SELECT CASE WHEN o.type IN ('F','PK')",
      "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'",
      "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END",
      'FROM sys.objects o',
      'JOIN sys.schemas s on o.schema_id = s.schema_id',
      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',
      "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ", quotedSchema,
      'ORDER BY o.type ASC;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'WHILE @id IS NOT NULL',
      'BEGIN',
      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',
      'BEGIN CATCH BREAK; THROW; END CATCH;',
      'DELETE FROM @cascade WHERE id = @id;',
      'SELECT @id = NULL, @ms_sql = NULL;',
      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',
      'END',
      "EXEC sp_executesql N'DROP SCHEMA", this.quoteIdentifier(schema), ";'",
      'END;'
    ].join(' ');
  }

  showSchemasQuery() {
    return [
      'SELECT "name" as "schema_name" FROM sys.schemas as s',
      'WHERE "s"."name" NOT IN (',
      "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'",
      ')', 'AND', '"s"."name" NOT LIKE', "'db_%'"
    ].join(' ');
  }

  versionQuery() {
    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch
    return [
      'DECLARE @ms_ver NVARCHAR(20);',
      "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));",
      "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"
    ].join(' ');
  }

  createTableQuery(tableName, attributes, options) {
    const primaryKeys = [],
      foreignKeys = {},
      attributesClauseParts = [];

    let commentStr = '';

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        let dataType = attributes[attr];
        let match;

        if (dataType.includes('COMMENT ')) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace('COMMENT', '').trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          // remove comment related substring from dataType
          dataType = commentMatch[1];
        }

        if (dataType.includes('PRIMARY KEY')) {
          primaryKeys.push(attr);

          if (dataType.includes('REFERENCES')) {
            // MSSQL doesn't support inline REFERENCES declarations: move to the end
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
          }
        } else if (dataType.includes('REFERENCES')) {
          // MSSQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }

    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClauseParts.push(`CONSTRAINT ${
            this.quoteIdentifier(indexName)
          } UNIQUE (${
            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')
          })`);
        }
      });
    }

    if (pkString.length > 0) {
      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
      }
    }

    const quotedTableName = this.quoteTable(tableName);

    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,
      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,
      ';',
      commentStr
    ]);
  }

  describeTableQuery(tableName, schema) {
    let sql = [
      'SELECT',
      "c.COLUMN_NAME AS 'Name',",
      "c.DATA_TYPE AS 'Type',",
      "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',",
      "c.IS_NULLABLE as 'IsNull',",
      "COLUMN_DEFAULT AS 'Default',",
      "pk.CONSTRAINT_TYPE AS 'Constraint',",
      "COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',",
      "CAST(prop.value AS NVARCHAR) AS 'Comment'",
      'FROM',
      'INFORMATION_SCHEMA.TABLES t',
      'INNER JOIN',
      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',
      'cu.column_name, tc.CONSTRAINT_TYPE ',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',
      'and tc.constraint_name=cu.constraint_name ',
      'and tc.CONSTRAINT_TYPE=\'PRIMARY KEY\') pk ',
      'ON pk.table_schema=c.table_schema ',
      'AND pk.table_name=c.table_name ',
      'AND pk.column_name=c.column_name ',
      'INNER JOIN sys.columns AS sc',
      "ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name",
      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',
      'AND prop.minor_id = sc.column_id',
      "AND prop.name = 'MS_Description'",
      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)
    ].join(' ');

    if (schema) {
      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;
    }

    return sql;
  }

  renameTableQuery(before, after) {
    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;
  }

  showTablesQuery() {
    return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';";
  }

  dropTableQuery(tableName) {
    const quoteTbl = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,
      'DROP TABLE',
      quoteTbl,
      ';'
    ]);
  }

  addColumnQuery(table, key, dataType) {
    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery
    //        but instead we need to pass the key along as the field here
    dataType.field = key;
    let commentStr = '';

    if (dataType.comment && _.isString(dataType.comment)) {
      commentStr = this.commentTemplate(dataType.comment, table, key);
      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key
      // is present. This is needed for createTable statement where that part is extracted with regex.
      // Here we can intercept the object and remove comment property since we have the original object.
      delete dataType['comment'];
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, { context: 'addColumn' }),
      ';',
      commentStr
    ]);
  }

  commentTemplate(comment, table, column) {
    return ' EXEC sp_addextendedproperty ' +
        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +
        '@level0type = N\'Schema\', @level0name = \'dbo\', ' +
        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +
        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP COLUMN',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [],
      constraintString = [];
    let commentString = '';

    for (const attributeName in attributes) {
      const quotedAttrName = this.quoteIdentifier(attributeName);
      let definition = attributes[attributeName];
      if (definition.includes('COMMENT ')) {
        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
        const commentText = commentMatch[2].replace('COMMENT', '').trim();
        commentString += this.commentTemplate(commentText, tableName, attributeName);
        // remove comment related substring from dataType
        definition = commentMatch[1];
      }
      if (definition.includes('REFERENCES')) {
        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);
      } else {
        attrString.push(`${quotedAttrName} ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';',
      commentString
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const newName = Object.keys(attributes)[0];
    return Utils.joinSQLFragments([
      'EXEC sp_rename',
      `'${this.quoteTable(tableName)}.${attrBefore}',`,
      `'${newName}',`,
      "'COLUMN'",
      ';'
    ]);
  }

  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    const quotedTable = this.quoteTable(tableName);
    options = options || {};
    attributes = attributes || {};

    const tuples = [];
    const allAttributes = [];
    const allQueries = [];

    let needIdentityInsertWrapper = false,
      outputFragment = '';

    if (options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);

      outputFragment = returnValues.outputFragment;
    }

    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;

    attrValueHashes.forEach(attrValueHash => {
      // special case for empty objects with primary keys
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
        allQueries.push(emptyQuery);
        return;
      }

      // normal case
      _.forOwn(attrValueHash, (value, key) => {
        if (value !== null && attributes[key] && attributes[key].autoIncrement) {
          needIdentityInsertWrapper = true;
        }

        if (!allAttributes.includes(key)) {
          if (value === null && attributes[key] && attributes[key].autoIncrement)
            return;

          allAttributes.push(key);
        }
      });
    });

    if (allAttributes.length > 0) {
      attrValueHashes.forEach(attrValueHash => {
        tuples.push(`(${
          allAttributes.map(key =>
            this.escape(attrValueHash[key])).join(',')
        })`);
      });

      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');
      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);
    }
    const commands = [];
    let offset = 0;
    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;
    while (offset < Math.max(tuples.length, 1)) {
      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');
      if (needIdentityInsertWrapper) {
        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;
      }
      commands.push(generatedQuery);
      offset += batch;
    }
    return commands.join(';');
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    if (options.limit) {
      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;
      sql.query = sql.query.replace('UPDATE', updateArgs);
    }
    return sql;
  }

  upsertQuery(tableName, insertValues, updateValues, where, model) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysAttrs = [];
    const identityAttrs = [];
    const uniqueAttrs = [];
    const tableNameQuoted = this.quoteTable(tableName);
    let needIdentityInsertWrapper = false;

    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed
    for (const key in model.rawAttributes) {
      if (model.rawAttributes[key].primaryKey) {
        primaryKeysAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].unique) {
        uniqueAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].autoIncrement) {
        identityAttrs.push(model.rawAttributes[key].field || key);
      }
    }

    //Add unique indexes defined by indexes option to uniqueAttrs
    for (const index of model._indexes) {
      if (index.unique && index.fields) {
        for (const field of index.fields) {
          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;
          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {
            uniqueAttrs.push(fieldName);
          }
        }
      }
    }

    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');
    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table
    let joinCondition;

    //IDENTITY_INSERT Condition
    identityAttrs.forEach(key => {
      if (updateValues[key] && updateValues[key] !== null) {
        needIdentityInsertWrapper = true;
        /*
         * IDENTITY_INSERT Column Cannot be updated, only inserted
         * http://stackoverflow.com/a/30176254/2254360
         */
      }
    });

    //Filter NULL Clauses
    const clauses = where[Op.or].filter(clause => {
      let valid = true;
      /*
       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row
       */
      for (const key in clause) {
        if (typeof clause[key] === 'undefined' || clause[key] == null) {
          valid = false;
          break;
        }
      }
      return valid;
    });

    /*
     * Generate ON condition using PK(s).
     * If not, generate using UK(s). Else throw error
     */
    const getJoinSnippet = array => {
      return array.map(key => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };

    if (clauses.length === 0) {
      throw new Error('Primary Key or Unique key should be passed to upsert query');
    } else {
      // Search for primary key attribute in clauses -- Model can have two separate unique keys
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.includes(keys[0])) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');
      }
    }

    // Remove the IDENTITY_INSERT Column from update
    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))
      .map(key => {
        const value = this.escape(updateValues[key]);
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${value}`;
      }).join(', ');

    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    const whereClause = this.getWhereConditions(where, null, model, options);

    return Utils.joinSQLFragments([
      'DELETE',
      options.limit && `TOP(${this.escape(options.limit)})`,
      'FROM',
      table,
      whereClause && `WHERE ${whereClause}`,
      ';',
      'SELECT @@ROWCOUNT AS AFFECTEDROWS',
      ';'
    ]);
  }

  showIndexesQuery(tableName) {
    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;
  }

  showConstraintsQuery(tableName) {
    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
  }

  attributeToSQL(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    // handle self referential constraints
    if (attribute.references) {

      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
        this.sequelize.log('MSSQL does not support self referencial constraints, '
          + 'we will remove it but we recommend restructuring your query');
        attribute.onDelete = '';
        attribute.onUpdate = '';
      }
    }

    let template;

    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;

      // enums are a special case
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {
        return this.escape(value);
      }).join(', ') }))`;
      return template;
    }
    template = attribute.type.toString();

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ' NULL';
    }

    if (attribute.autoIncrement) {
      template += ' IDENTITY(1,1)';
    }

    // Blobs/texts cannot have a defaultValue
    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&
        Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.references) {
      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      template += ` COMMENT ${attribute.comment}`;
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {},
      existingConstraints = [];
    let key,
      attribute;

    for (key in attributes) {
      attribute = attributes[key];

      if (attribute.references) {
        if (existingConstraints.includes(attribute.references.model.toString())) {
          // no cascading constraints to a table more than once
          attribute.onDelete = '';
          attribute.onUpdate = '';
        } else {
          existingConstraints.push(attribute.references.model.toString());

          // NOTE: this really just disables cascading updates for all
          //       definitions. Can be made more robust to support the
          //       few cases where MSSQL actually supports them
          attribute.onUpdate = '';
        }

      }

      if (key && !attribute.field) attribute.field = key;
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  createTrigger() {
    throwMethodUndefined('createTrigger');
  }

  dropTrigger() {
    throwMethodUndefined('dropTrigger');
  }

  renameTrigger() {
    throwMethodUndefined('renameTrigger');
  }

  createFunction() {
    throwMethodUndefined('createFunction');
  }

  dropFunction() {
    throwMethodUndefined('dropFunction');
  }

  renameFunction() {
    throwMethodUndefined('renameFunction');
  }

  /**
   * Generate common SQL prefix for ForeignKeysQuery.
   *
   * @param {string} catalogName
   * @returns {string}
   */
  _getForeignKeysQueryPrefix(catalogName) {
    return `${'SELECT ' +
        'constraint_name = OBJ.NAME, ' +
        'constraintName = OBJ.NAME, '}${
      catalogName ? `constraintCatalog = '${catalogName}', ` : ''
    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +
        'tableName = TB.NAME, ' +
        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${
          catalogName ? `tableCatalog = '${catalogName}', ` : ''
        }columnName = COL.NAME, ` +
        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${
          catalogName ? `referencedCatalog = '${catalogName}', ` : ''
        }referencedTableName = RTB.NAME, ` +
        'referencedColumnName = RCOL.NAME ' +
      'FROM sys.foreign_key_columns FKC ' +
        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +
        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +
        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +
        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +
        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * @param {string|object} table
   * @param {string} catalogName database name
   * @returns {string}
   */
  getForeignKeysQuery(table, catalogName) {
    const tableName = table.tableName || table;
    let sql = `${this._getForeignKeysQueryPrefix(catalogName)
    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;

    if (table.schema) {
      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
    }
    return sql;
  }

  getForeignKeyQuery(table, attributeName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      this._getForeignKeysQueryPrefix(),
      'WHERE',
      `TB.NAME =${wrapSingleQuote(tableName)}`,
      'AND',
      `COL.NAME =${wrapSingleQuote(attributeName)}`,
      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`
    ]);
  }

  getPrimaryKeyConstraintQuery(table, attributeName) {
    const tableName = wrapSingleQuote(table.tableName || table);
    return Utils.joinSQLFragments([
      'SELECT K.TABLE_NAME AS tableName,',
      'K.COLUMN_NAME AS columnName,',
      'K.CONSTRAINT_NAME AS constraintName',
      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',
      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',
      'ON C.TABLE_NAME = K.TABLE_NAME',
      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',
      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',
      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',
      'WHERE C.CONSTRAINT_TYPE = \'PRIMARY KEY\'',
      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
      `AND K.TABLE_NAME = ${tableName}`,
      ';'
    ]);
  }

  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(foreignKey)
    ]);
  }

  getDefaultConstraintQuery(tableName, attributeName) {
    const quotedTable = this.quoteTable(tableName);
    return Utils.joinSQLFragments([
      'SELECT name FROM sys.default_constraints',
      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,
      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,
      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,
      ';'
    ]);
  }

  dropConstraintQuery(tableName, constraintName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP CONSTRAINT',
      this.quoteIdentifier(constraintName),
      ';'
    ]);
  }

  setIsolationLevelQuery() {

  }

  generateTransactionId() {
    return randomBytes(10).toString('hex');
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'BEGIN TRANSACTION;';
  }

  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT TRANSACTION;';
  }

  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return 'ROLLBACK TRANSACTION;';
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });

    const dbVersion = this.sequelize.options.databaseVersion;
    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');

    if (isSQLServer2008 && options.offset) {
      // For earlier versions of SQL server, we need to nest several queries
      // in order to emulate the OFFSET behavior.
      //
      // 1. The outermost query selects all items from the inner query block.
      //    This is due to a limitation in SQL server with the use of computed
      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.
      // 2. The next query handles the LIMIT and OFFSET behavior by getting
      //    the TOP N rows of the query where the row number is > OFFSET
      // 3. The innermost query is the actual set we want information from

      const offset = options.offset || 0;
      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
      let orders = { mainQueryOrder: [] };
      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }

      if (orders.mainQueryOrder.length === 0) {
        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
      }

      const tmpTable = mainTableAs || 'OffsetTable';

      return Utils.joinSQLFragments([
        'SELECT TOP 100 PERCENT',
        attributes.join(', '),
        'FROM (',
        [
          'SELECT',
          options.limit && `TOP ${options.limit}`,
          '* FROM (',
          [
            'SELECT ROW_NUMBER() OVER (',
            [
              'ORDER BY',
              orders.mainQueryOrder.join(', ')
            ],
            `) as row_num, * FROM ${tables} AS ${tmpTable}`,
            where && `WHERE ${where}`
          ],
          `) AS ${tmpTable} WHERE row_num > ${offset}`
        ],
        `) AS ${tmpTable}`
      ]);
    }

    return Utils.joinSQLFragments([
      'SELECT',
      isSQLServer2008 && options.limit && `TOP ${options.limit}`,
      attributes.join(', '),
      `FROM ${tables}`,
      mainTableAs && `AS ${mainTableAs}`,
      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`
    ]);
  }

  addLimitAndOffset(options, model) {
    // Skip handling of limit and offset as postfixes for older SQL Server versions
    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {
      return '';
    }

    const offset = options.offset || 0;
    const isSubQuery = options.subQuery === undefined
      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation
      : options.subQuery;

    let fragment = '';
    let orders = {};

    if (options.order) {
      orders = this.getQueryOrders(options, model, isSubQuery);
    }

    if (options.limit || options.offset) {
      if (!options.order || !options.order.length || options.include && !orders.subQueryOrder.length) {
        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;
        if (!options.order || !options.order.length) {
          fragment += ` ORDER BY ${tablePkFragment}`;
        } else {
          const orderFieldNames = _.map(options.order, order => order[0]);
          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);

          if (!primaryKeyFieldAlreadyPresent) {
            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';
            fragment += tablePkFragment;
          }
        }
      }

      if (options.offset || options.limit) {
        fragment += ` OFFSET ${this.escape(offset)} ROWS`;
      }

      if (options.limit) {
        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
      }
    }

    return fragment;
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}

module.exports = MSSQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");

/**
 * The interface that Sequelize uses to talk with MSSQL database
 */
class MSSqlQueryInterface extends QueryInterface {
  /**
  * A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.
  *
  * @override
  */
  async removeColumn(tableName, attributeName, options) {
    options = { raw: true, ...options || {} };

    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);
    const [results0] = await this.sequelize.query(findConstraintSql, options);
    if (results0.length) {
      // No default constraint found -- we can cleanly remove the column
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);
    const [results] = await this.sequelize.query(findForeignKeySql, options);
    if (results.length) {
      // No foreign key constraints found, so we can remove the column
      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);
      await this.sequelize.query(dropForeignKeySql, options);
    }
    //Check if the current column is a primaryKey
    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);
    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);
    if (result.length) {
      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);
      await this.sequelize.query(dropConstraintSql, options);
    }
    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);
    return this.sequelize.query(removeSql, options);
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    const model = options.model;
    const wheres = [];

    options = { ...options };

    if (!Utils.isWhereEmpty(where)) {
      wheres.push(where);
    }

    // Lets combine unique keys and indexes into one
    let indexes = Object.values(model.uniqueKeys).map(item => item.fields);
    indexes = indexes.concat(Object.values(model._indexes).filter(item => item.unique).map(item => item.fields));

    const attributes = Object.keys(insertValues);
    for (const index of indexes) {
      if (_.intersection(attributes, index).length === index.length) {
        where = {};
        for (const field of index) {
          where[field] = insertValues[field];
        }
        wheres.push(where);
      }
    }

    where = { [Op.or]: wheres };

    options.type = QueryTypes.UPSERT;
    options.raw = true;

    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
    return await this.sequelize.query(sql, options);
  }
}

exports.MSSqlQueryInterface = MSSqlQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mssql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mssql');
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:mssql');

function getScale(aNum) {
  if (!Number.isFinite(aNum)) return 0;
  let e = 1;
  while (Math.round(aNum * e) / e !== aNum) e *= 10;
  return Math.log10(e);
}

class Query extends AbstractQuery {
  getInsertIdField() {
    return 'id';
  }

  getSQLTypeFromJsType(value, TYPES) {
    const paramType = { type: TYPES.VarChar, typeOptions: {} };
    paramType.type = TYPES.NVarChar;
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        if (value >= -2147483648 && value <= 2147483647) {
          paramType.type = TYPES.Int;
        } else {
          paramType.type = TYPES.BigInt;
        }
      } else {
        paramType.type = TYPES.Numeric;
        //Default to a reasonable numeric precision/scale pending more sophisticated logic
        paramType.typeOptions = { precision: 30, scale: getScale(value) };
      }
    } else if (typeof value === 'boolean') {
      paramType.type = TYPES.Bit;
    }
    if (Buffer.isBuffer(value)) {
      paramType.type = TYPES.VarBinary;
    }
    return paramType;
  }

  async _run(connection, sql, parameters) {
    this.sql = sql;
    const { options } = this;

    const complete = this._logQuery(sql, debug, parameters);

    const query = new Promise((resolve, reject) => {
      // TRANSACTION SUPPORT
      if (sql.startsWith('BEGIN TRANSACTION')) {
        return connection.beginTransaction(error => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);
      }
      if (sql.startsWith('COMMIT TRANSACTION')) {
        return connection.commitTransaction(error => error ? reject(error) : resolve([]));
      }
      if (sql.startsWith('ROLLBACK TRANSACTION')) {
        return connection.rollbackTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }
      if (sql.startsWith('SAVE TRANSACTION')) {
        return connection.saveTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);
      }

      const rows = [];
      const request = new connection.lib.Request(sql, (err, rowCount) => err ? reject(err) : resolve([rows, rowCount]));

      if (parameters) {
        _.forOwn(parameters, (value, key) => {
          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);
          request.addParameter(key, paramType.type, value, paramType.typeOptions);
        });
      }

      request.on('row', columns => {
        rows.push(columns);
      });

      connection.execSql(request);
    });

    let rows, rowCount;

    try {
      [rows, rowCount] = await query;
    } catch (err) {
      err.sql = sql;
      err.parameters = parameters;

      throw this.formatError(err);
    }

    complete();

    if (Array.isArray(rows)) {
      rows = rows.map(columns => {
        const row = {};
        for (const column of columns) {
          const typeid = column.metadata.type.id;
          const parse = parserStore.get(typeid);
          let value = column.value;

          if (value !== null & !!parse) {
            value = parse(value);
          }
          row[column.metadata.colName] = value;
        }
        return row;
      });
    }

    return this.formatResults(rows, rowCount);
  }

  run(sql, parameters) {
    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters));
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = {};
    const replacementFunc = (match, key, values) => {
      if (values[key] !== undefined) {
        bindParam[key] = values[key];
        return `@${key}`;
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];

    return [sql, bindParam];
  }

  /**
   * High level function that handles the results of a query execution.
   *
   * @param {Array} data - The result of the query execution.
   * @param {number} rowCount
   * @private
   * @example
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   */
  formatResults(data, rowCount) {
    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);
      return [this.instance || data, rowCount];
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      const result = {};
      for (const _result of data) {
        if (_result.Default) {
          _result.Default = _result.Default.replace("('", '').replace("')", '').replace(/'/g, '');
        }

        result[_result.Name] = {
          type: _result.Type.toUpperCase(),
          allowNull: _result.IsNull === 'YES' ? true : false,
          defaultValue: _result.Default,
          primaryKey: _result.Constraint === 'PRIMARY KEY',
          autoIncrement: _result.IsIdentity === 1,
          comment: _result.Comment
        };

        if (
          result[_result.Name].type.includes('CHAR')
          && _result.Length
        ) {
          if (_result.Length === -1) {
            result[_result.Name].type += '(MAX)';
          } else {
            result[_result.Name].type += `(${_result.Length})`;
          }
        }
      }
      return result;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery()) {
      if (this.options.returning) {
        return this.handleSelectQuery(data);
      }

      return rowCount;
    }
    if (this.isBulkDeleteQuery()) {
      return data[0] ? data[0].AFFECTEDROWS : 0;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      this.handleInsertQuery(data);
      return [this.instance || data, data[0].$action === 'INSERT'];
    }
    if (this.isUpdateQuery()) {
      return [this.instance || data, rowCount];
    }
    if (this.isShowConstraintsQuery()) {
      return this.handleShowConstraintsQuery(data);
    }
    if (this.isRawQuery()) {
      return [data, rowCount];
    }
    return data;
  }

  handleShowTablesQuery(results) {
    return results.map(resultSet => {
      return {
        tableName: resultSet.TABLE_NAME,
        schema: resultSet.TABLE_SCHEMA
      };
    });
  }

  handleShowConstraintsQuery(data) {
    //Convert snake_case keys to camelCase as it's generated by stored procedure
    return data.slice(1).map(result => {
      const constraint = {};
      for (const key in result) {
        constraint[_.camelCase(key)] = result[key];
      }
      return constraint;
    });
  }

  formatError(err) {
    let match;

    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \((.*)\).)?/);
    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);
    if (match && match.length > 1) {
      let fields = {};
      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];
      let message = 'Validation error';

      if (uniqueKey && !!uniqueKey.msg) {
        message = uniqueKey.msg;
      }
      if (match[3]) {
        const values = match[3].split(',').map(part => part.trim());
        if (uniqueKey) {
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[match[1]] = match[3];
        }
      }

      const errors = [];
      _.forOwn(fields, (value, field) => {
        errors.push(new sequelizeErrors.ValidationErrorItem(
          this.getUniqueConstraintErrorMessage(field),
          'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
          field,
          value,
          this.instance,
          'not_unique'
        ));
      });

      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
    }

    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||
      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./) ||
      err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./);
    if (match && match.length > 0) {
      return new sequelizeErrors.ForeignKeyConstraintError({
        fields: null,
        index: match[1],
        parent: err
      });
    }

    match = err.message.match(/Could not drop constraint. See previous errors./);
    if (match && match.length > 0) {
      let constraint = err.sql.match(/(?:constraint|index) \[(.+?)\]/i);
      constraint = constraint ? constraint[1] : undefined;
      let table = err.sql.match(/table \[(.+?)\]/i);
      table = table ? table[1] : undefined;

      return new sequelizeErrors.UnknownConstraintError({
        message: match[1],
        constraint,
        table,
        parent: err
      });
    }

    return new sequelizeErrors.DatabaseError(err);
  }

  isShowOrDescribeQuery() {
    let result = false;

    result = result || this.sql.toLowerCase().startsWith("select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'");
    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');
    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');

    return result;
  }

  isShowIndexesQuery() {
    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.index_name in acc)) {
        acc[item.index_name] = item;
        item.fields = [];
      }

      item.index_keys.split(',').forEach(column => {
        let columnName = column.trim();
        if (columnName.includes('(-)')) {
          columnName = columnName.replace('(-)', '');
        }

        acc[item.index_name].fields.push({
          attribute: columnName,
          length: undefined,
          order: column.includes('(-)') ? 'DESC' : 'ASC',
          collate: undefined
        });
      });
      delete item.index_keys;
      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.index_name.toLowerCase().startsWith('pk'),
      fields: item.fields,
      name: item.index_name,
      tableName: undefined,
      unique: item.index_description.toLowerCase().includes('unique'),
      type: undefined
    }));
  }

  handleInsertQuery(results, metaData) {
    if (this.instance) {
      // add the inserted row id to the instance
      const autoIncrementAttribute = this.model.autoIncrementAttribute;
      let id = null;
      let autoIncrementAttributeAlias = null;

      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) &&
        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)
        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;

      id = id || results && results[0][this.getInsertIdField()];
      id = id || metaData && metaData[this.getInsertIdField()];
      id = id || results && results[0][autoIncrementAttribute];
      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];

      this.instance[autoIncrementAttribute] = id;

      if (this.instance.dataValues) {
        for (const key in results[0]) {
          if (Object.prototype.hasOwnProperty.call(results[0], key)) {
            const record = results[0][key];
  
            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);
  
            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }
      
    }
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const SequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const momentTz = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const debug = logger.debugContext('connection:mysql');
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('mysql');
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * MySQL Connection Manager
 *
 * Get connections, validate and disconnect them.
 * AbstractConnectionManager pooling use it to handle MySQL specific connections
 * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server
 *
 * @private
 */
class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 3306;
    super(dialect, sequelize);
    this.lib = this._loadDialectModule('mysql2');
    this.refreshTypeParser(DataTypes);
  }

  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  static _typecast(field, next) {
    if (parserStore.get(field.type)) {
      return parserStore.get(field.type)(field, this.sequelize.options, next);
    }
    return next();
  }

  /**
   * Connect with MySQL database based on config, Handle any errors in connection
   * Set the pool handlers on connection.error
   * Also set proper timezone once connection is connected.
   *
   * @param {object} config
   * @returns {Promise<Connection>}
   * @private
   */
  async connect(config) {
    const connectionConfig = {
      host: config.host,
      port: config.port,
      user: config.username,
      flags: '-FOUND_ROWS',
      password: config.password,
      database: config.database,
      timezone: this.sequelize.options.timezone,
      typeCast: ConnectionManager._typecast.bind(this),
      bigNumberStrings: false,
      supportBigNumbers: true,
      ...config.dialectOptions
    };

    try {
      const connection = await new Promise((resolve, reject) => {
        const connection = this.lib.createConnection(connectionConfig);

        const errorHandler = e => {
          // clean up connect & error event if there is error
          connection.removeListener('connect', connectHandler);
          connection.removeListener('error', connectHandler);
          reject(e);
        };

        const connectHandler = () => {
          // clean up error event if connected
          connection.removeListener('error', errorHandler);
          resolve(connection);
        };

        // don't use connection.once for error event handling here
        // mysql2 emit error two times in case handshake was failed
        // first error is protocol_lost and second is timeout
        // if we will use `once.error` node process will crash on 2nd error emit
        connection.on('error', errorHandler);
        connection.once('connect', connectHandler);
      });

      debug('connection acquired');
      connection.on('error', error => {
        switch (error.code) {
          case 'ESOCKET':
          case 'ECONNRESET':
          case 'EPIPE':
          case 'PROTOCOL_CONNECTION_LOST':
            this.pool.destroy(connection);
        }
      });

      if (!this.sequelize.config.keepDefaultTimezone) {
        // set timezone for this connection
        // but named timezone are not directly supported in mysql, so get its offset first
        let tzOffset = this.sequelize.options.timezone;
        tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;
        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();
      }

      return connection;
    } catch (err) {
      switch (err.code) {
        case 'ECONNREFUSED':
          throw new SequelizeErrors.ConnectionRefusedError(err);
        case 'ER_ACCESS_DENIED_ERROR':
          throw new SequelizeErrors.AccessDeniedError(err);
        case 'ENOTFOUND':
          throw new SequelizeErrors.HostNotFoundError(err);
        case 'EHOSTUNREACH':
          throw new SequelizeErrors.HostNotReachableError(err);
        case 'EINVAL':
          throw new SequelizeErrors.InvalidConnectionError(err);
        default:
          throw new SequelizeErrors.ConnectionError(err);
      }
    }
  }

  async disconnect(connection) {
    // Don't disconnect connections with CLOSED state
    if (connection._closing) {
      debug('connection tried to disconnect but was already at CLOSED state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return connection
      && !connection._fatalError
      && !connection._protocolError
      && !connection._closing
      && !connection.stream.destroyed;
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
module.exports = BaseTypes => {
  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';

  /**
   * types: [buffer_type, ...]
   *
   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html
   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js
   */

  BaseTypes.DATE.types.mysql = ['DATETIME'];
  BaseTypes.STRING.types.mysql = ['VAR_STRING'];
  BaseTypes.CHAR.types.mysql = ['STRING'];
  BaseTypes.TEXT.types.mysql = ['BLOB'];
  BaseTypes.TINYINT.types.mysql = ['TINY'];
  BaseTypes.SMALLINT.types.mysql = ['SHORT'];
  BaseTypes.MEDIUMINT.types.mysql = ['INT24'];
  BaseTypes.INTEGER.types.mysql = ['LONG'];
  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];
  BaseTypes.FLOAT.types.mysql = ['FLOAT'];
  BaseTypes.TIME.types.mysql = ['TIME'];
  BaseTypes.DATEONLY.types.mysql = ['DATE'];
  BaseTypes.BOOLEAN.types.mysql = ['TINY'];
  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];
  BaseTypes.UUID.types.mysql = false;
  BaseTypes.ENUM.types.mysql = false;
  BaseTypes.REAL.types.mysql = ['DOUBLE'];
  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];
  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];
  BaseTypes.JSON.types.mysql = ['JSON'];

  class DECIMAL extends BaseTypes.DECIMAL {
    toSql() {
      let definition = super.toSql();
      if (this._unsigned) {
        definition += ' UNSIGNED';
      }
      if (this._zerofill) {
        definition += ' ZEROFILL';
      }
      return definition;
    }
  }

  class DATE extends BaseTypes.DATE {
    toSql() {
      return this._length ? `DATETIME(${this._length})` : 'DATETIME';
    }
    _stringify(date, options) {
      date = this._applyTimezone(date, options);
      // Fractional DATETIMEs only supported on MySQL 5.6.4+
      if (this._length) {
        return date.format('YYYY-MM-DD HH:mm:ss.SSS');
      }
      return date.format('YYYY-MM-DD HH:mm:ss');
    }
    static parse(value, options) {
      value = value.string();
      if (value === null) {
        return value;
      }
      if (moment.tz.zone(options.timezone)) {
        value = moment.tz(value, options.timezone).toDate();
      }
      else {
        value = new Date(`${value} ${options.timezone}`);
      }
      return value;
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(value) {
      return value.string();
    }
  }
  class UUID extends BaseTypes.UUID {
    toSql() {
      return 'CHAR(36) BINARY';
    }
  }

  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    constructor(type, srid) {
      super(type, srid);
      if (_.isEmpty(this.type)) {
        this.sqlType = this.key;
        return;
      }
      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {
        this.sqlType = this.type;
        return;
      }
      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(', ')}`);
    }
    static parse(value) {
      value = value.buffer();
      // Empty buffer, MySQL doesn't support POINT EMPTY
      // check, https://dev.mysql.com/worklog/task/?id=2381
      if (!value || value.length === 0) {
        return null;
      }
      // For some reason, discard the first 4 bytes
      value = value.slice(4);
      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });
    }
    toSql() {
      return this.sqlType;
    }
  }

  class ENUM extends BaseTypes.ENUM {
    toSql(options) {
      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;
    }
  }

  class JSONTYPE extends BaseTypes.JSON {
    _stringify(value, options) {
      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);
    }
  }

  return {
    ENUM,
    DATE,
    DATEONLY,
    UUID,
    GEOMETRY,
    DECIMAL,
    JSON: JSONTYPE
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/mysql/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/mysql/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").mysql;
const { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js");

class MysqlDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
  }
}

MysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'VALUES ()': true,
  'LIMIT ON UPDATE': true,
  lock: true,
  forShare: 'LOCK IN SHARE MODE',
  settingIsolationLevelDuringTransaction: false,
  inserts: {
    ignoreDuplicates: ' IGNORE',
    updateOnDuplicate: ' ON DUPLICATE KEY UPDATE'
  },
  index: {
    collate: false,
    length: true,
    parser: true,
    type: true,
    using: 1
  },
  constraints: {
    dropConstraint: false,
    check: false
  },
  indexViaAlter: true,
  indexHints: true,
  NUMERIC: true,
  GEOMETRY: true,
  JSON: true,
  REGEXP: true
});

MysqlDialect.prototype.defaultVersion = '5.7.0';
MysqlDialect.prototype.Query = Query;
MysqlDialect.prototype.QueryGenerator = QueryGenerator;
MysqlDialect.prototype.DataTypes = DataTypes;
MysqlDialect.prototype.name = 'mysql';
MysqlDialect.prototype.TICK_CHAR = '`';
MysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;
MysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;

module.exports = MysqlDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const util = __webpack_require__(/*! util */ "util");
const Op = __webpack_require__(/*! ../../operators */ "./node_modules/sequelize/lib/operators.js");


const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
const FOREIGN_KEY_FIELDS = [
  'CONSTRAINT_NAME as constraint_name',
  'CONSTRAINT_NAME as constraintName',
  'CONSTRAINT_SCHEMA as constraintSchema',
  'CONSTRAINT_SCHEMA as constraintCatalog',
  'TABLE_NAME as tableName',
  'TABLE_SCHEMA as tableSchema',
  'TABLE_SCHEMA as tableCatalog',
  'COLUMN_NAME as columnName',
  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',
  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',
  'REFERENCED_TABLE_NAME as referencedTableName',
  'REFERENCED_COLUMN_NAME as referencedColumnName'
].join(',');

const typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);

class MySQLQueryGenerator extends AbstractQueryGenerator {
  constructor(options) {
    super(options);

    this.OperatorMap = {
      ...this.OperatorMap,
      [Op.regexp]: 'REGEXP',
      [Op.notRegexp]: 'NOT REGEXP'
    };
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      charset: null,
      collate: null,
      ...options
    };

    return Utils.joinSQLFragments([
      'CREATE DATABASE IF NOT EXISTS',
      this.quoteIdentifier(databaseName),
      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
      ';'
    ]);
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;
  }

  createSchema() {
    return 'SHOW TABLES';
  }

  showSchemasQuery() {
    return 'SHOW TABLES';
  }

  versionQuery() {
    return 'SELECT VERSION() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = {
      engine: 'InnoDB',
      charset: null,
      rowFormat: null,
      ...options
    };

    const primaryKeys = [];
    const foreignKeys = {};
    const attrStr = [];

    for (const attr in attributes) {
      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
      const dataType = attributes[attr];
      let match;

      if (dataType.includes('PRIMARY KEY')) {
        primaryKeys.push(attr);

        if (dataType.includes('REFERENCES')) {
          // MySQL doesn't support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);
        }
      } else if (dataType.includes('REFERENCES')) {
        // MySQL doesn't support inline REFERENCES declarations: move to the end
        match = dataType.match(/^(.+) (REFERENCES.*)$/);
        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
        foreignKeys[attr] = match[2];
      } else {
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attributesClause = attrStr.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) => {
        if (columns.customIndex) {
          if (typeof indexName !== 'string') {
            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;
          }
          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }

    return Utils.joinSQLFragments([
      'CREATE TABLE IF NOT EXISTS',
      table,
      `(${attributesClause})`,
      `ENGINE=${options.engine}`,
      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,
      options.charset && `DEFAULT CHARSET=${options.charset}`,
      options.collate && `COLLATE ${options.collate}`,
      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,
      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,
      ';'
    ]);
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = this.quoteTable(
      this.addSchema({
        tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      })
    );

    return `SHOW FULL COLUMNS FROM ${table};`;
  }

  showTablesQuery(database) {
    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \'BASE TABLE\'';
    if (database) {
      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
    } else {
      query += ' AND TABLE_SCHEMA NOT IN (\'MYSQL\', \'INFORMATION_SCHEMA\', \'PERFORMANCE_SCHEMA\', \'SYS\')';
    }
    return `${query};`;
  }

  addColumnQuery(table, key, dataType) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(table),
      'ADD',
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, {
        context: 'addColumn',
        tableName: table,
        foreignKey: key
      }),
      ';'
    ]);
  }

  removeColumnQuery(tableName, attributeName) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP',
      this.quoteIdentifier(attributeName),
      ';'
    ]);
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [];
    const constraintString = [];

    for (const attributeName in attributes) {
      let definition = attributes[attributeName];
      if (definition.includes('REFERENCES')) {
        const attrName = this.quoteIdentifier(attributeName);
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);
      } else {
        attrString.push(`\`${attributeName}\` \`${attributeName}\` ${definition}`);
      }
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      attrString.length && `CHANGE ${attrString.join(', ')}`,
      constraintString.length && `ADD ${constraintString.join(', ')}`,
      ';'
    ]);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const attrString = [];

    for (const attrName in attributes) {
      const definition = attributes[attrName];
      attrString.push(`\`${attrBefore}\` \`${attrName}\` ${definition}`);
    }

    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'CHANGE',
      attrString.join(', '),
      ';'
    ]);
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the sqlite json functions
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    } else if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      } else if (smth.json && /boolean/i.test(smth.type)) {
        // true or false cannot be casted as booleans within a JSON structure
        smth.type = 'char';
      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {
        smth.type = 'decimal';
      } else if (/text/i.test(smth.type)) {
        smth.type = 'char';
      }
    }

    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
  }

  _toJSONValue(value) {
    // true/false are stored as strings in mysql
    if (typeof value === 'boolean') {
      return value.toString();
    }
    // null is stored as a string in mysql
    if (value === null) {
      return 'null';
    }
    return value;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    let limit = '';
    let query = `DELETE FROM ${this.quoteTable(tableName)}`;

    if (options.limit) {
      limit = ` LIMIT ${this.escape(options.limit)}`;
    }

    where = this.getWhereConditions(where, null, model, options);

    if (where) {
      query += ` WHERE ${where}`;
    }

    return query + limit;
  }

  showIndexesQuery(tableName, options) {
    return Utils.joinSQLFragments([
      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,
      options && options.database && `FROM \`${options.database}\``
    ]);
  }

  showConstraintsQuery(table, constraintName) {
    const tableName = table.tableName || table;
    const schemaName = table.schema;

    return Utils.joinSQLFragments([
      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',
      'CONSTRAINT_NAME AS constraintName,',
      'CONSTRAINT_SCHEMA AS constraintSchema,',
      'CONSTRAINT_TYPE AS constraintType,',
      'TABLE_NAME AS tableName,',
      'TABLE_SCHEMA AS tableSchema',
      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',
      `WHERE table_name='${tableName}'`,
      constraintName && `AND constraint_name = '${constraintName}'`,
      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,
      ';'
    ]);
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return Utils.joinSQLFragments([
      'DROP INDEX',
      this.quoteIdentifier(indexName),
      'ON',
      this.quoteTable(tableName)
    ]);
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });
    let template = attributeString;

    if (attribute.allowNull === false) {
      template += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      template += ' auto_increment';
    }

    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value
    if (!typeWithoutDefault.has(attributeString)
      && attribute.type._binary !== true
      && Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      template += ' PRIMARY KEY';
    }

    if (attribute.comment) {
      template += ` COMMENT ${this.escape(attribute.comment)}`;
    }

    if (attribute.first) {
      template += ' FIRST';
    }
    if (attribute.after) {
      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
    }

    if (attribute.references) {
      if (options && options.context === 'addColumn' && options.foreignKey) {
        const attrName = this.quoteIdentifier(options.foreignKey);
        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);

        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
      }

      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier('id')})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   * @private
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = JSON_FUNCTION_REGEX.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {object} table  The table.
   * @param  {string} schemaName The name of the schema.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(table, schemaName) {
    const tableName = table.tableName || table;
    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,
      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,
      'AND REFERENCED_TABLE_NAME IS NOT NULL',
      ';'
    ]);
  }

  /**
   * Generates an SQL query that returns the foreign key constraint of a given column.
   *
   * @param  {object} table  The table.
   * @param  {string} columnName The name of the column.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeyQuery(table, columnName) {
    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';
    const quotedTableName = wrapSingleQuote(table.tableName || table);
    const quotedColumnName = wrapSingleQuote(columnName);

    return Utils.joinSQLFragments([
      'SELECT',
      FOREIGN_KEY_FIELDS,
      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',
      'WHERE (',
      [
        `REFERENCED_TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`
      ],
      ') OR (',
      [
        `TABLE_NAME = ${quotedTableName}`,
        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,
        `AND COLUMN_NAME = ${quotedColumnName}`,
        'AND REFERENCED_TABLE_NAME IS NOT NULL'
      ],
      ')'
    ]);
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return Utils.joinSQLFragments([
      'ALTER TABLE',
      this.quoteTable(tableName),
      'DROP FOREIGN KEY',
      this.quoteIdentifier(foreignKey),
      ';'
    ]);
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(identifier, '\'');
}

module.exports = MySQLQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");

/**
 * The interface that Sequelize uses to talk with MySQL/MariaDB database
 */
class MySQLQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.
   *
   * @override
   */
  async removeColumn(tableName, columnName, options) {
    options = options || {};

    const [results] = await this.sequelize.query(
      this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, columnName),
      { raw: true, ...options }
    );

    //Exclude primary key constraint
    if (results.length && results[0].constraint_name !== 'PRIMARY') {
      await Promise.all(results.map(constraint => this.sequelize.query(
        this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name),
        { raw: true, ...options }
      )));
    }

    return await this.sequelize.query(
      this.queryGenerator.removeColumnQuery(tableName, columnName),
      { raw: true, ...options }
    );
  }

  /**
   * @override
   */
  async upsert(tableName, insertValues, updateValues, where, options) {
    options = { ...options };

    options.type = QueryTypes.UPSERT;
    options.updateOnDuplicate = Object.keys(updateValues);

    const model = options.model;
    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
    return await this.sequelize.query(sql, options);
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    const sql = this.queryGenerator.showConstraintsQuery(
      tableName.tableName ? tableName : {
        tableName,
        schema: this.sequelize.config.database
      }, constraintName);

    const constraints = await this.sequelize.query(sql, { ...options,
      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS });

    const constraint = constraints[0];
    let query;
    if (!constraint || !constraint.constraintType) {
      throw new sequelizeErrors.UnknownConstraintError(
        {
          message: `Constraint ${constraintName} on table ${tableName} does not exist`,
          constraint: constraintName,
          table: tableName
        });
    }

    if (constraint.constraintType === 'FOREIGN KEY') {
      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);
    } else {
      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);
    }

    return await this.sequelize.query(query, options);
  }
}

exports.MySQLQueryInterface = MySQLQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/mysql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;

const debug = logger.debugContext('sql:mysql');

class Query extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  static formatBindParameters(sql, values, dialect) {
    const bindParam = [];
    const replacementFunc = (match, key, values_) => {
      if (values_[key] !== undefined) {
        bindParam.push(values_[key]);
        return '?';
      }
      return undefined;
    };
    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    return [sql, bindParam.length > 0 ? bindParam : undefined];
  }

  async run(sql, parameters) {
    this.sql = sql;
    const { connection, options } = this;

    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;

    const complete = this._logQuery(sql, debug, parameters);

    if (parameters) {
      debug('parameters(%j)', parameters);
    }

    let results;

    try {
      if (parameters && parameters.length) {
        results = await new Promise((resolve, reject) => {
          connection
            .execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      } else {
        results = await new Promise((resolve, reject) => {
          connection
            .query({ sql }, (error, result) => error ? reject(error) : resolve(result))
            .setMaxListeners(100);
        });
      }
    } catch (error) {
      if (options.transaction && error.errno === ER_DEADLOCK) {
        // MySQL automatically rolls-back transactions in the event of a deadlock.
        // However, we still initiate a manual rollback to ensure the connection gets released - see #13102.
        try {
          await options.transaction.rollback();
        } catch (error_) {
          // Ignore errors - since MySQL automatically rolled back, we're
          // not that worried about this redundant rollback failing.
        }

        options.transaction.finished = 'rollback';
      }

      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    } finally {
      complete();
    }

    if (showWarnings && results && results.warningStatus > 0) {
      await this.logWarnings(results);
    }
    return this.formatResults(results);
  }

  /**
   * High level function that handles the results of a query execution.
   *
   *
   * Example:
   *  query.formatResults([
   *    {
   *      id: 1,              // this is from the main table
   *      attr2: 'snafu',     // this is from the main table
   *      Tasks.id: 1,        // this is from the associated table
   *      Tasks.title: 'task' // this is from the associated table
   *    }
   *  ])
   *
   * @param {Array} data - The result of the query execution.
   * @private
   */
  formatResults(data) {
    let result = this.instance;

    if (this.isInsertQuery(data)) {
      this.handleInsertQuery(data);

      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          data.constructor.name === 'ResultSetHeader'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = data[this.getInsertIdField()];
          result = [];
          for (let i = startId; i < startId + data.affectedRows; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = data[this.getInsertIdField()];
        }
      }
    }

    if (this.isSelectQuery()) {
      return this.handleSelectQuery(data);
    }
    if (this.isShowTablesQuery()) {
      return this.handleShowTablesQuery(data);
    }
    if (this.isDescribeQuery()) {
      result = {};

      for (const _result of data) {
        const enumRegex = /^enum/i;
        result[_result.Field] = {
          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.Type.toUpperCase(),
          allowNull: _result.Null === 'YES',
          defaultValue: _result.Default,
          primaryKey: _result.Key === 'PRI',
          autoIncrement: Object.prototype.hasOwnProperty.call(_result, 'Extra')
            && _result.Extra.toLowerCase() === 'auto_increment',
          comment: _result.Comment ? _result.Comment : null
        };
      }
      return result;
    }
    if (this.isShowIndexesQuery()) {
      return this.handleShowIndexesQuery(data);
    }
    if (this.isCallQuery()) {
      return data[0];
    }
    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
      return data.affectedRows;
    }
    if (this.isVersionQuery()) {
      return data[0].version;
    }
    if (this.isForeignKeysQuery()) {
      return data;
    }
    if (this.isUpsertQuery()) {
      return [result, data.affectedRows === 1];
    }
    if (this.isInsertQuery() || this.isUpdateQuery()) {
      return [result, data.affectedRows];
    }
    if (this.isShowConstraintsQuery()) {
      return data;
    }
    if (this.isRawQuery()) {
      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta
      return [data, data];
    }

    return result;
  }

  async logWarnings(results) {
    const warningResults = await this.run('SHOW WARNINGS');
    const warningMessage = `MySQL Warnings (${this.connection.uuid || 'default'}): `;
    const messages = [];
    for (const _warningRow of warningResults) {
      if (_warningRow === undefined || typeof _warningRow[Symbol.iterator] !== 'function') {
        continue;
      }
      for (const _warningResult of _warningRow) {
        if (Object.prototype.hasOwnProperty.call(_warningResult, 'Message')) {
          messages.push(_warningResult.Message);
        } else {
          for (const _objectKey of _warningResult.keys()) {
            messages.push([_objectKey, _warningResult[_objectKey]].join(': '));
          }
        }
      }
    }

    this.sequelize.log(warningMessage + messages.join('; '), this.options);

    return results;
  }

  formatError(err) {
    const errCode = err.errno || err.code;

    switch (errCode) {
      case ER_DUP_ENTRY: {
        const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?$/);
        let fields = {};
        let message = 'Validation error';
        const values = match ? match[1].split('-') : undefined;
        const fieldKey = match ? match[2] : undefined;
        const fieldVal = match ? match[1] : undefined;
        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];

        if (uniqueKey) {
          if (uniqueKey.msg) message = uniqueKey.msg;
          fields = _.zipObject(uniqueKey.fields, values);
        } else {
          fields[fieldKey] = fieldVal;
        }

        const errors = [];
        _.forOwn(fields, (value, field) => {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            value,
            this.instance,
            'not_unique'
          ));
        });

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }

      case ER_ROW_IS_REFERENCED:
      case ER_NO_REFERENCED_ROW: {
        // e.g. CONSTRAINT `example_constraint_name` FOREIGN KEY (`example_id`) REFERENCES `examples` (`id`)
        const match = err.message.match(
          /CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/
        );
        const quoteChar = match ? match[1] : '`';
        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({
          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? 'parent' : 'child',
          table: match ? match[4] : undefined,
          fields,
          value: fields && fields.length && this.instance && this.instance[fields[0]] || undefined,
          index: match ? match[2] : undefined,
          parent: err
        });
      }

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  handleShowIndexesQuery(data) {
    // Group by index name, and collect all fields
    data = data.reduce((acc, item) => {
      if (!(item.Key_name in acc)) {
        acc[item.Key_name] = item;
        item.fields = [];
      }

      acc[item.Key_name].fields[item.Seq_in_index - 1] = {
        attribute: item.Column_name,
        length: item.Sub_part || undefined,
        order: item.Collation === 'A' ? 'ASC' : undefined
      };
      delete item.column_name;

      return acc;
    }, {});

    return _.map(data, item => ({
      primary: item.Key_name === 'PRIMARY',
      fields: item.fields,
      name: item.Key_name,
      tableName: item.Table,
      unique: item.Non_unique !== 1,
      type: item.Index_type
    }));
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/parserStore.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/parserStore.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


const stores = new Map();

module.exports = dialect => {
  if (!stores.has(dialect)) {
    stores.set(dialect, new Map());
  }

  return {
    clear() {
      stores.get(dialect).clear();
    },
    refresh(dataType) {
      for (const type of dataType.types[dialect]) {
        stores.get(dialect).set(type, dataType.parse);
      }
    },
    get(type) {
      return stores.get(dialect).get(type);
    }
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:pg');
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const moment = __webpack_require__(/*! moment-timezone */ "moment-timezone");
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    sequelize.config.port = sequelize.config.port || 5432;
    super(dialect, sequelize);

    const pgLib = this._loadDialectModule('pg');
    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;

    this._clearDynamicOIDs();
    this._clearTypeParser();
    this.refreshTypeParser(dataTypes.postgres);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    const arrayParserBuilder = parser => {
      return value => this.lib.types.arrayParser.create(value, parser).parse();
    };
    const rangeParserBuilder = parser => {
      return value => dataType.parse(value, { parser });
    };

    // Set range parsers
    if (dataType.key.toLowerCase() === 'range') {
      for (const name in this.nameOidMap) {
        const entry = this.nameOidMap[name];
        if (! entry.rangeOid) continue;

        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));
        const arrayRangeParser = arrayParserBuilder(rangeParser);

        this.oidParserMap.set(entry.rangeOid, rangeParser);
        if (! entry.arrayRangeOid) continue;
        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);
      }
      return;
    }

    // Create parsers for normal or enum data types
    const parser = value => dataType.parse(value);
    const arrayParser = arrayParserBuilder(parser);

    // Set enum parsers
    if (dataType.key.toLowerCase() === 'enum') {
      this.enumOids.oids.forEach(oid => {
        this.oidParserMap.set(oid, parser);
      });
      this.enumOids.arrayOids.forEach(arrayOid => {
        this.oidParserMap.set(arrayOid, arrayParser);
      });
      return;
    }

    // Set parsers for normal data types
    dataType.types.postgres.forEach(name => {
      if (! this.nameOidMap[name]) return;
      this.oidParserMap.set(this.nameOidMap[name].oid, parser);

      if (! this.nameOidMap[name].arrayOid) return;
      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);
    });
  }

  _clearTypeParser() {
    this.oidParserMap = new Map();
  }

  getTypeParser(oid, ...args) {
    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);

    return this.lib.types.getTypeParser(oid, ...args);
  }

  async connect(config) {
    config.user = config.username;
    const connectionConfig = _.pick(config, [
      'user', 'password', 'host', 'database', 'port'
    ]);

    connectionConfig.types = {
      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)
    };

    if (config.dialectOptions) {
      _.merge(connectionConfig,
        _.pick(config.dialectOptions, [
        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]
          'application_name',
          // choose the SSL mode with the PGSSLMODE environment variable
          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]
          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]
          'ssl',
          // In addition to the values accepted by the corresponding server,
          // you can use "auto" to determine the right encoding from the
          // current locale in the client (LC_CTYPE environment variable on Unix systems)
          'client_encoding',
          // !! DO NOT SET THIS TO TRUE !!
          // (unless you know what you're doing)
          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]
          'binary',
          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.
          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md
          'keepAlive',
          // Times out queries after a set time in milliseconds. Added in pg v7.3
          'statement_timeout',
          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10
          'idle_in_transaction_session_timeout'
        ]));
    }

    const connection = await new Promise((resolve, reject) => {
      let responded = false;

      const connection = new this.lib.Client(connectionConfig);

      const parameterHandler = message => {
        switch (message.parameterName) {
          case 'server_version':
            if (this.sequelize.options.databaseVersion === 0) {
              const version = semver.coerce(message.parameterValue).version;
              this.sequelize.options.databaseVersion = semver.valid(version)
                ? version
                : this.dialect.defaultVersion;
            }
            break;
          case 'standard_conforming_strings':
            connection['standard_conforming_strings'] = message.parameterValue;
            break;
        }
      };

      const endHandler = () => {
        debug('connection timeout');
        if (!responded) {
          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));
        }
      };

      // If we didn't ever hear from the client.connect() callback the connection timeout
      // node-postgres does not treat this as an error since no active query was ever emitted
      connection.once('end', endHandler);

      if (!this.sequelize.config.native) {
        // Receive various server parameters for further configuration
        connection.connection.on('parameterStatus', parameterHandler);
      }

      connection.connect(err => {
        responded = true;

        if (!this.sequelize.config.native) {
          // remove parameter handler
          connection.connection.removeListener('parameterStatus', parameterHandler);
        }

        if (err) {
          if (err.code) {
            switch (err.code) {
              case 'ECONNREFUSED':
                reject(new sequelizeErrors.ConnectionRefusedError(err));
                break;
              case 'ENOTFOUND':
                reject(new sequelizeErrors.HostNotFoundError(err));
                break;
              case 'EHOSTUNREACH':
                reject(new sequelizeErrors.HostNotReachableError(err));
                break;
              case 'EINVAL':
                reject(new sequelizeErrors.InvalidConnectionError(err));
                break;
              default:
                reject(new sequelizeErrors.ConnectionError(err));
                break;
            }
          } else {
            reject(new sequelizeErrors.ConnectionError(err));
          }
        } else {
          debug('connection acquired');
          connection.removeListener('end', endHandler);
          resolve(connection);
        }
      });
    });

    let query = '';

    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {
      // Disable escape characters in strings
      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)
      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS
      query += 'SET standard_conforming_strings=on;';
    }

    if (this.sequelize.options.clientMinMessages !== false) {
      query += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`;
    }

    if (!this.sequelize.config.keepDefaultTimezone) {
      const isZone = !!moment.tz.zone(this.sequelize.options.timezone);
      if (isZone) {
        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;
      } else {
        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;
      }
    }

    if (query) {
      await connection.query(query);
    }
    if (Object.keys(this.nameOidMap).length === 0 &&
      this.enumOids.oids.length === 0 &&
      this.enumOids.arrayOids.length === 0) {
      await this._refreshDynamicOIDs(connection);
    }
    // Don't let a Postgres restart (or error) to take down the whole app
    connection.on('error', error => {
      connection._invalid = true;
      debug(`connection error ${error.code || error.message}`);
      this.pool.destroy(connection);
    });

    return connection;
  }

  async disconnect(connection) {
    if (connection._ending) {
      debug('connection tried to disconnect but was already at ENDING state');
      return;
    }

    return await promisify(callback => connection.end(callback))();
  }

  validate(connection) {
    return !connection._invalid && !connection._ending;
  }

  async _refreshDynamicOIDs(connection) {
    const databaseVersion = this.sequelize.options.databaseVersion;
    const supportedVersion = '8.3.0';

    // Check for supported version
    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {
      return;
    }

    const results = await (connection || this.sequelize).query(
      'WITH ranges AS (' +
      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +
      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +
      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +
      ')' +
      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +
      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +
      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +
      ' WHERE (pg_type.typtype IN(\'b\', \'e\'));'
    );

    let result = Array.isArray(results) ? results.pop() : results;

    // When searchPath is prepended then two statements are executed and the result is
    // an array of those two statements. First one is the SET search_path and second is
    // the SELECT query result.
    if (Array.isArray(result)) {
      if (result[0].command === 'SET') {
        result = result.pop();
      }
    }

    const newNameOidMap = {};
    const newEnumOids = { oids: [], arrayOids: [] };

    for (const row of result.rows) {
      // Mapping enums, handled separatedly
      if (row.typtype === 'e') {
        newEnumOids.oids.push(row.oid);
        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);
        continue;
      }

      // Mapping base types and their arrays
      newNameOidMap[row.typname] = { oid: row.oid };
      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;

      // Mapping ranges(of base types) and their arrays
      if (row.rngtypid) {
        newNameOidMap[row.typname].rangeOid = row.rngtypid;
        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;
      }
    }

    // Replace all OID mappings. Avoids temporary empty OID mappings.
    this.nameOidMap = newNameOidMap;
    this.enumOids = newEnumOids;

    this.refreshTypeParser(dataTypes.postgres);
  }

  _clearDynamicOIDs() {
    this.nameOidMap = {};
    this.enumOids = { oids: [], arrayOids: [] };
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const wkx = __webpack_require__(/*! wkx */ "./node_modules/wkx/lib/wkx.js");

module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');

  /**
   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._length = undefined;
      dataType.options.length = undefined;
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * types:
   * {
   *   oids: [oid],
   *   array_oids: [oid]
   * }
   *
   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go
   */

  BaseTypes.UUID.types.postgres = ['uuid'];
  BaseTypes.CIDR.types.postgres = ['cidr'];
  BaseTypes.INET.types.postgres = ['inet'];
  BaseTypes.MACADDR.types.postgres = ['macaddr'];
  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];
  BaseTypes.JSON.types.postgres = ['json'];
  BaseTypes.JSONB.types.postgres = ['jsonb'];
  BaseTypes.TIME.types.postgres = ['time'];

  class DATEONLY extends BaseTypes.DATEONLY {
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return super._sanitize(value);
      }
      return value;
    }
    static parse(value) {
      if (value === 'infinity') {
        return Infinity;
      }
      if (value === '-infinity') {
        return -Infinity;
      }
      return value;
    }
  }

  BaseTypes.DATEONLY.types.postgres = ['date'];

  class DECIMAL extends BaseTypes.DECIMAL {
    static parse(value) {
      return value;
    }
  }

  // numeric
  BaseTypes.DECIMAL.types.postgres = ['numeric'];

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.STRING.types.postgres = ['varchar'];

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  BaseTypes.TEXT.types.postgres = ['text'];

  class CITEXT extends BaseTypes.CITEXT {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.CITEXT.types.postgres = ['citext'];

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return 'BYTEA';
      }
      return super.toSql();
    }
  }

  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];

  class BOOLEAN extends BaseTypes.BOOLEAN {
    toSql() {
      return 'BOOLEAN';
    }
    _sanitize(value) {
      if (value !== null && value !== undefined) {
        if (Buffer.isBuffer(value) && value.length === 1) {
          // Bit fields are returned as buffers
          value = value[0];
        }
        if (typeof value === 'string') {
          // Only take action on valid boolean strings.
          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;
        }
        if (typeof value === 'number') {
          // Only take action on valid boolean integers.
          return value === 1 ? true : value === 0 ? false : value;
        }
      }
      return value;
    }
  }

  BOOLEAN.parse = BOOLEAN.prototype._sanitize;

  BaseTypes.BOOLEAN.types.postgres = ['bool'];

  class DATE extends BaseTypes.DATE {
    toSql() {
      return 'TIMESTAMP WITH TIME ZONE';
    }
    validate(value) {
      if (value !== Infinity && value !== -Infinity) {
        return super.validate(value);
      }
      return true;
    }
    _stringify(value, options) {
      if (value === Infinity) {
        return 'Infinity';
      }
      if (value === -Infinity) {
        return '-Infinity';
      }
      return super._stringify(value, options);
    }
    _sanitize(value, options) {
      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'infinity') {
            return Infinity;
          }
          if (lower === '-infinity') {
            return -Infinity;
          }
        }
        return new Date(value);
      }
      return value;
    }
  }

  BaseTypes.DATE.types.postgres = ['timestamptz'];

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.TINYINT.types.postgres = ['int2'];

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int2
  BaseTypes.SMALLINT.types.postgres = ['int2'];

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  INTEGER.parse = function parse(value) {
    return parseInt(value, 10);
  };

  // int4
  BaseTypes.INTEGER.types.postgres = ['int4'];

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // int8
  BaseTypes.BIGINT.types.postgres = ['int8'];

  class REAL extends BaseTypes.REAL {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float4
  BaseTypes.REAL.types.postgres = ['float4'];

  class DOUBLE extends BaseTypes.DOUBLE {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }
  // float8
  BaseTypes.DOUBLE.types.postgres = ['float8'];

  class FLOAT extends BaseTypes.FLOAT {
    constructor(length, decimals) {
      super(length, decimals);
      // POSTGRES does only support lengths as parameter.
      // Values between 1-24 result in REAL
      // Values between 25-53 result in DOUBLE PRECISION
      // If decimals are provided remove these and print a warning
      if (this._decimals) {
        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');
        this._length = undefined;
        this.options.length = undefined;
        this._decimals = undefined;
      }
      if (this._unsigned) {
        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');
        this._unsigned = undefined;
      }
      if (this._zerofill) {
        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');
        this._zerofill = undefined;
      }
    }
  }
  delete FLOAT.parse; // Float has no separate type in PG

  class BLOB extends BaseTypes.BLOB {
    toSql() {
      if (this._length) {
        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');
        this._length = undefined;
      }
      return 'BYTEA';
    }
    _hexify(hex) {
      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html
      return `E'\\\\x${hex}'`;
    }
  }

  BaseTypes.BLOB.types.postgres = ['bytea'];

  class GEOMETRY extends BaseTypes.GEOMETRY {
    toSql() {
      let result = this.key;
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    _bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOMETRY.types.postgres = ['geometry'];


  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {
    toSql() {
      let result = 'GEOGRAPHY';
      if (this.type) {
        result += `(${this.type}`;
        if (this.srid) {
          result += `,${this.srid}`;
        }
        result += ')';
      }
      return result;
    }
    static parse(value) {
      const b = Buffer.from(value, 'hex');
      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });
    }
    _stringify(value, options) {
      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
    }
    bindParam(value, options) {
      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
    }
  }

  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];

  let hstore;

  class HSTORE extends BaseTypes.HSTORE {
    constructor() {
      super();
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
    }
    _value(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.stringify(value);
    }
    _stringify(value) {
      return `'${this._value(value)}'`;
    }
    _bindParam(value, options) {
      return options.bindParam(this._value(value));
    }
    static parse(value) {
      if (!hstore) {
        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated
        hstore = __webpack_require__(/*! ./hstore */ "./node_modules/sequelize/lib/dialects/postgres/hstore.js");
      }
      return hstore.parse(value);
    }
  }

  HSTORE.prototype.escape = false;

  BaseTypes.HSTORE.types.postgres = ['hstore'];

  class RANGE extends BaseTypes.RANGE {
    _value(values, options) {
      if (!Array.isArray(values)) {
        return this.options.subtype.stringify(values, options);
      }
      const valueInclusivity = [true, false];
      const valuesStringified = values.map((value, index) => {
        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {
          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {
            valueInclusivity[index] = value.inclusive;
          }
          value = value.value;
        }
        if (value === null || value === -Infinity || value === Infinity) {
          // Pass through "unbounded" bounds unchanged
          return value;
        }
        if (this.options.subtype.stringify) {
          return this.options.subtype.stringify(value, options);
        }
        return options.escape(value);
      });
      // Array.map does not preserve extra array properties
      valuesStringified.inclusive = valueInclusivity;
      return range.stringify(valuesStringified);
    }
    _stringify(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `'${value}'::${this.toCastType()}`;
      }
      return `'${value}'`;
    }
    _bindParam(values, options) {
      const value = this._value(values, options);
      if (!Array.isArray(values)) {
        return `${options.bindParam(value)}::${this.toCastType()}`;
      }
      return options.bindParam(value);
    }
    toSql() {
      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];
    }
    toCastType() {
      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];
    }
    static parse(value, options = { parser: val => val }) {
      return range.parse(value, options.parser);
    }
  }
  const range = __webpack_require__(/*! ./range */ "./node_modules/sequelize/lib/dialects/postgres/range.js");

  RANGE.prototype.escape = false;

  BaseTypes.RANGE.types.postgres = {
    subtypes: {
      integer: 'int4range',
      decimal: 'numrange',
      date: 'tstzrange',
      dateonly: 'daterange',
      bigint: 'int8range'
    },
    castTypes: {
      integer: 'int4',
      decimal: 'numeric',
      date: 'timestamptz',
      dateonly: 'date',
      bigint: 'int8'
    }
  };

  // TODO: Why are base types being manipulated??
  BaseTypes.ARRAY.prototype.escape = false;
  BaseTypes.ARRAY.prototype._value = function _value(values, options) {
    return values.map(value => {
      if (options && options.bindParam && this.type && this.type._value) {
        return this.type._value(value, options);
      }
      if (this.type && this.type.stringify) {
        value = this.type.stringify(value, options);

        if (this.type.escape === false) {
          return value;
        }
      }
      return options.escape(value);
    }, this);
  };
  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {
    let str = `ARRAY[${this._value(values, options).join(',')}]`;

    if (this.type) {
      const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
      let castKey = this.toSql();

      if (this.type instanceof BaseTypes.ENUM) {
        castKey = `${Utils.addTicks(
          Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName),
          '"'
        ) }[]`;
      }

      str += `::${castKey}`;
    }

    return str;
  };
  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {
    return options.bindParam(this._value(values, options));
  };

  class ENUM extends BaseTypes.ENUM {
    static parse(value) {
      return value;
    }
  }

  BaseTypes.ENUM.types.postgres = [null];

  return {
    DECIMAL,
    BLOB,
    STRING,
    CHAR,
    TEXT,
    CITEXT,
    TINYINT,
    SMALLINT,
    INTEGER,
    BIGINT,
    BOOLEAN,
    DATE,
    DATEONLY,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    FLOAT,
    GEOMETRY,
    GEOGRAPHY,
    HSTORE,
    RANGE,
    ENUM
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const hstore = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'pg-hstore'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))({ sanitize: true });

function stringify(data) {
  if (data === null) return null;
  return hstore.stringify(data);
}
exports.stringify = stringify;

function parse(value) {
  if (value === null) return null;
  return hstore.parse(value);
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/postgres/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/postgres/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").postgres;
const { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js");

class PostgresDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });
    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);
  }
}

PostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT VALUES': true,
  'EXCEPTION': true,
  'ON DUPLICATE KEY': false,
  'ORDER NULLS': true,
  returnValues: {
    returning: true
  },
  bulkDefault: true,
  schemas: true,
  lock: true,
  lockOf: true,
  lockKey: true,
  lockOuterJoinFailure: true,
  skipLocked: true,
  forShare: 'FOR SHARE',
  index: {
    concurrently: true,
    using: 2,
    where: true,
    functionBased: true,
    operator: true
  },
  inserts: {
    onConflictDoNothing: ' ON CONFLICT DO NOTHING',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  NUMERIC: true,
  ARRAY: true,
  RANGE: true,
  GEOMETRY: true,
  REGEXP: true,
  GEOGRAPHY: true,
  JSON: true,
  JSONB: true,
  HSTORE: true,
  TSVECTOR: true,
  deferrableConstraints: true,
  searchPath: true
});

PostgresDialect.prototype.defaultVersion = '9.5.0';
PostgresDialect.prototype.Query = Query;
PostgresDialect.prototype.DataTypes = DataTypes;
PostgresDialect.prototype.name = 'postgres';
PostgresDialect.prototype.TICK_CHAR = '"';
PostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;
PostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;

module.exports = PostgresDialect;
module.exports.default = PostgresDialect;
module.exports.PostgresDialect = PostgresDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const util = __webpack_require__(/*! util */ "util");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class PostgresQueryGenerator extends AbstractQueryGenerator {
  setSearchPath(searchPath) {
    return `SET search_path to ${searchPath};`;
  }

  createDatabaseQuery(databaseName, options) {
    options = {
      encoding: null,
      collate: null,
      ...options
    };

    const values = {
      database: this.quoteTable(databaseName),
      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',
      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',
      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',
      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''
    };

    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
  }

  createSchema(schema) {
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);

    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {
      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;
    }

    return `CREATE SCHEMA ${schema};`;
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;
  }

  showSchemasQuery() {
    return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
  }

  versionQuery() {
    return 'SHOW SERVER_VERSION';
  }

  createTableQuery(tableName, attributes, options) {
    options = { ...options };

    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do
    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);
    const attrStr = [];
    let comments = '';
    let columnComments = '';

    const quotedTable = this.quoteTable(tableName);

    if (options.comment && typeof options.comment === 'string') {
      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
    }

    for (const attr in attributes) {
      const quotedAttr = this.quoteIdentifier(attr);
      const i = attributes[attr].indexOf('COMMENT ');
      if (i !== -1) {
        // Move comment to a separate query
        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
        attributes[attr] = attributes[attr].substring(0, i);
      }

      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
      attrStr.push(`${quotedAttr} ${dataType}`);
    }


    let attributesClause = attrStr.join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    const pks = _.reduce(attributes, (acc, attribute, key) => {
      if (attribute.includes('PRIMARY KEY')) {
        acc.push(this.quoteIdentifier(key));
      }
      return acc;
    }, []).join(',');

    if (pks.length > 0) {
      attributesClause += `, PRIMARY KEY (${pks})`;
    }

    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;
  }

  dropTableQuery(tableName, options) {
    options = options || {};
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;
  }

  showTablesQuery() {
    return "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';";
  }

  describeTableQuery(tableName, schema) {
    if (!schema) schema = 'public';

    return 'SELECT ' +
      'pk.constraint_type as "Constraint",' +
      'c.column_name as "Field", ' +
      'c.column_default as "Default",' +
      'c.is_nullable as "Null", ' +
      '(CASE WHEN c.udt_name = \'hstore\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \'(\' || c.character_maximum_length || \')\' ELSE \'\' END) as "Type", ' +
      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", ' +
      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" ' +
      'FROM information_schema.columns c ' +
      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +
      'cu.column_name, tc.constraint_type ' +
      'FROM information_schema.TABLE_CONSTRAINTS tc ' +
      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +
      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +
      'and tc.constraint_name=cu.constraint_name ' +
      'and tc.constraint_type=\'PRIMARY KEY\') pk ' +
      'ON pk.table_schema=c.table_schema ' +
      'AND pk.table_name=c.table_name ' +
      'AND pk.column_name=c.column_name ' +
      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://www.postgresql.org/docs/current/static/functions-json.html
    const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
    const jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = jsonOperatorRegex.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =>
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`
        );

        return conditions.join(' AND ');
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the postgres json syntax
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(' = %s', this.escape(smth.value));
        }

        return str;
      }
    }
    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, attribute) {
    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });
    const dataType = attribute.type || attribute;
    const definition = this.dataTypeMapping(table, key, dbDataType);
    const quotedKey = this.quoteIdentifier(key);
    const quotedTable = this.quoteTable(this.extractTableDetails(table));

    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;

    if (dataType instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType) + query;
    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType.type) + query;
    }

    return query;
  }

  removeColumnQuery(tableName, attributeName) {
    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
    const quotedAttributeName = this.quoteIdentifier(attributeName);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
  }

  changeColumnQuery(tableName, attributes) {
    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
    const sql = [];
    for (const attributeName in attributes) {
      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
      let attrSql = '';

      if (definition.includes('NOT NULL')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);

        definition = definition.replace('NOT NULL', '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
      }

      if (definition.includes('DEFAULT')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);

        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();
      } else if (!definition.includes('REFERENCES')) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
      }

      if (attributes[attributeName].startsWith('ENUM(')) {
        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
        definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, { schema: false }));
        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
      }

      if (definition.match(/UNIQUE;*$/)) {
        definition = definition.replace(/UNIQUE;*$/, '');
        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');
      }

      if (definition.includes('REFERENCES')) {
        definition = definition.replace(/.+?(?=REFERENCES)/, '');
        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');
      } else {
        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
      }

      sql.push(attrSql);
    }

    return sql.join('');
  }

  renameColumnQuery(tableName, attrBefore, attributes) {

    const attrString = [];

    for (const attributeName in attributes) {
      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
    }

    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;
  }

  fn(fnName, tableName, parameters, body, returns, language) {
    fnName = fnName || 'testfunc';
    language = language || 'plpgsql';
    returns = returns ? `RETURNS ${returns}` : '';
    parameters = parameters || '';

    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `TRUNCATE ${this.quoteTable(tableName)}`,
      options.restartIdentity ? ' RESTART IDENTITY' : '',
      options.cascade ? ' CASCADE' : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    let whereClause = this.getWhereConditions(where, null, model, options);
    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';
    let primaryKeys = '';
    let primaryKeysSelection = '';

    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }

    if (options.limit) {
      if (!model) {
        throw new Error('Cannot LIMIT delete without a model.');
      }

      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');

      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
      primaryKeysSelection = pks;

      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
    }
    return `DELETE FROM ${table}${whereClause}`;
  }

  showIndexesQuery(tableName) {
    let schemaJoin = '';
    let schemaWhere = '';
    if (typeof tableName !== 'string') {
      schemaJoin = ', pg_namespace s';
      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;
      tableName = tableName.tableName;
    }

    // This is ARCANE!
    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +
      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +
      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +
      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +
      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +
      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';
  }

  showConstraintsQuery(tableName) {
    //Postgres converts camelCased alias to lowercase unless quoted
    return [
      'SELECT constraint_catalog AS "constraintCatalog",',
      'constraint_schema AS "constraintSchema",',
      'constraint_name AS "constraintName",',
      'table_catalog AS "tableCatalog",',
      'table_schema AS "tableSchema",',
      'table_name AS "tableName",',
      'constraint_type AS "constraintType",',
      'is_deferrable AS "isDeferrable",',
      'initially_deferred AS "initiallyDeferred"',
      'from INFORMATION_SCHEMA.table_constraints',
      `WHERE table_name='${tableName}';`
    ].join(' ');
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;
  }

  addLimitAndOffset(options) {
    let fragment = '';
    /* eslint-disable */
    if (options.limit != null) {
      fragment += ' LIMIT ' + this.escape(options.limit);
    }
    if (options.offset != null) {
      fragment += ' OFFSET ' + this.escape(options.offset);
    }
    /* eslint-enable */

    return fragment;
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    let type;
    if (
      attribute.type instanceof DataTypes.ENUM ||
      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM
    ) {
      const enumType = attribute.type.type || attribute.type;
      let values = attribute.values;

      if (enumType.values && !attribute.values) {
        values = enumType.values;
      }

      if (Array.isArray(values) && values.length > 0) {
        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;

        if (attribute.type instanceof DataTypes.ARRAY) {
          type += '[]';
        }

      } else {
        throw new Error("Values for ENUM haven't been defined.");
      }
    }

    if (!type) {
      type = attribute.type;
    }

    let sql = type.toString();

    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {
      sql += ' NOT NULL';
    }

    if (attribute.autoIncrement) {
      if (attribute.autoIncrementIdentity) {
        sql += ' GENERATED BY DEFAULT AS IDENTITY';
      } else {
        sql += ' SERIAL';
      }
    }

    if (Utils.defaultValueSchemable(attribute.defaultValue)) {
      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
    }

    if (attribute.unique === true) {
      sql += ' UNIQUE';
    }

    if (attribute.primaryKey) {
      sql += ' PRIMARY KEY';
    }

    if (attribute.references) {
      let referencesTable = this.quoteTable(attribute.references.model);
      let schema;

      if (options.schema) {
        schema = options.schema;
      } else if (
        (!attribute.references.model || typeof attribute.references.model == 'string')
        && options.table
        && options.table.schema
      ) {
        schema = options.table.schema;
      }

      if (schema) {
        referencesTable = this.quoteTable(this.addSchema({
          tableName: referencesTable,
          _schema: schema
        }));
      }

      let referencesKey;

      if (attribute.references.key) {
        referencesKey = this.quoteIdentifiers(attribute.references.key);
      } else {
        referencesKey = this.quoteIdentifier('id');
      }

      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

      if (attribute.onDelete) {
        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }

      if (attribute.references.deferrable) {
        sql += ` ${attribute.references.deferrable.toString(this)}`;
      }
    }

    if (attribute.comment && typeof attribute.comment === 'string') {
      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {
        const quotedAttr = this.quoteIdentifier(options.key);
        const escapedCommentText = this.escape(attribute.comment);
        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
      } else {
        // for createTable event which does it's own parsing
        // TODO: centralize creation of comment statements here
        sql += ` COMMENT ${attribute.comment}`;
      }
    }

    return sql;
  }

  deferConstraintsQuery(options) {
    return options.deferrable.toString(this);
  }

  setConstraintQuery(columns, type) {
    let columnFragment = 'ALL';

    if (columns) {
      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');
    }

    return `SET CONSTRAINTS ${columnFragment} ${type}`;
  }

  setDeferredQuery(columns) {
    return this.setConstraintQuery(columns, 'DEFERRED');
  }

  setImmediateQuery(columns) {
    return this.setConstraintQuery(columns, 'IMMEDIATE');
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });
    }

    return result;
  }

  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
    const decodedEventType = this.decodeTriggerEventType(eventType);
    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);
    const expandedOptions = this.expandOptions(optionsArray);
    const paramList = this._expandFunctionParamList(functionParams);

    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${
      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;
  }

  dropTrigger(tableName, triggerName) {
    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;
  }

  renameTrigger(tableName, oldTriggerName, newTriggerName) {
    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;
  }

  createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');

    const paramList = this._expandFunctionParamList(params);
    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';
    const expandedOptionsArray = this.expandOptions(optionsArray);

    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';

    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;
  }

  dropFunction(functionName, params) {
    if (!functionName) throw new Error('requires functionName');
    // RESTRICT is (currently, as of 9.2) default but we'll be explicit
    const paramList = this._expandFunctionParamList(params);
    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;
  }

  renameFunction(oldFunctionName, params, newFunctionName) {
    const paramList = this._expandFunctionParamList(params);
    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;
  }

  pgEscapeAndQuote(val) {
    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), "'"));
  }

  _expandFunctionParamList(params) {
    if (params === undefined || !Array.isArray(params)) {
      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');
    }

    const paramList = [];
    params.forEach(curParam => {
      const paramDef = [];
      if (curParam.type) {
        if (curParam.direction) { paramDef.push(curParam.direction); }
        if (curParam.name) { paramDef.push(curParam.name); }
        paramDef.push(curParam.type);
      } else {
        throw new Error('function or trigger used with a parameter without any type');
      }

      const joined = paramDef.join(' ');
      if (joined) paramList.push(joined);

    });

    return paramList.join(', ');
  }

  _expandFunctionVariableList(variables) {
    if (!Array.isArray(variables)) {
      throw new Error('_expandFunctionVariableList: function variables must be an array');
    }
    const variableDefinitions = [];
    variables.forEach(variable => {
      if (!variable.name || !variable.type) {
        throw new Error('function variable must have a name and type');
      }
      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;
      if (variable.default) {
        variableDefinition += ` := ${variable.default}`;
      }
      variableDefinition += ';';
      variableDefinitions.push(variableDefinition);
    });
    return variableDefinitions.join(' ');
  }

  expandOptions(options) {
    return options === undefined || _.isEmpty(options) ?
      '' : options.join(' ');
  }

  decodeTriggerEventType(eventSpecifier) {
    const EVENT_DECODER = {
      'after': 'AFTER',
      'before': 'BEFORE',
      'instead_of': 'INSTEAD OF',
      'after_constraint': 'AFTER'
    };

    if (!EVENT_DECODER[eventSpecifier]) {
      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);
    }

    return EVENT_DECODER[eventSpecifier];
  }

  triggerEventTypeIsConstraint(eventSpecifier) {
    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';
  }

  expandTriggerEventSpec(fireOnSpec) {
    if (_.isEmpty(fireOnSpec)) {
      throw new Error('no table change events specified to trigger on');
    }

    return _.map(fireOnSpec, (fireValue, fireKey) => {
      const EVENT_MAP = {
        'insert': 'INSERT',
        'update': 'UPDATE',
        'delete': 'DELETE',
        'truncate': 'TRUNCATE'
      };

      if (!EVENT_MAP[fireValue]) {
        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);
      }

      let eventSpec = EVENT_MAP[fireValue];
      if (eventSpec === 'UPDATE') {
        if (Array.isArray(fireValue) && fireValue.length > 0) {
          eventSpec += ` OF ${fireValue.join(', ')}`;
        }
      }

      return eventSpec;
    }).join(' OR ');
  }

  pgEnumName(tableName, attr, options) {
    options = options || {};

    const tableDetails = this.extractTableDetails(tableName, options);
    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '"');

    // pgListEnums requires the enum name only, without the schema
    if (options.schema !== false && tableDetails.schema) {
      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
    }

    return enumName;
  }

  pgListEnums(tableName, attrName, options) {
    let enumName = '';
    const tableDetails = this.extractTableDetails(tableName, options);

    if (tableDetails.tableName && attrName) {
      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/"/g, "'")}`;
    }

    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +
      'JOIN pg_enum e ON t.oid = e.enumtypid ' +
      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +
      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;
  }

  pgEnum(tableName, attr, dataType, options) {
    const enumName = this.pgEnumName(tableName, attr, options);
    let values;

    if (dataType.values) {
      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;
    } else {
      values = dataType.toString().match(/^ENUM\(.+\)/)[0];
    }

    let sql = `CREATE TYPE ${enumName} AS ${values};`;
    if (!!options && options.force === true) {
      sql = this.pgEnumDrop(tableName, attr) + sql;
    }
    return sql;
  }

  pgEnumAdd(tableName, attr, value, options) {
    const enumName = this.pgEnumName(tableName, attr);
    let sql = `ALTER TYPE ${enumName} ADD VALUE `;

    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {
      sql += 'IF NOT EXISTS ';
    }
    sql += this.escape(value);

    if (options.before) {
      sql += ` BEFORE ${this.escape(options.before)}`;
    } else if (options.after) {
      sql += ` AFTER ${this.escape(options.after)}`;
    }

    return sql;
  }

  pgEnumDrop(tableName, attr, enumName) {
    enumName = enumName || this.pgEnumName(tableName, attr);
    return `DROP TYPE IF EXISTS ${enumName}; `;
  }

  fromArray(text) {
    text = text.replace(/^{/, '').replace(/}$/, '');
    let matches = text.match(/("(?:\\.|[^"\\\\])*"|[^,]*)(?:\s*,\s*|\s*$)/ig);

    if (matches.length < 1) {
      return [];
    }

    matches = matches.map(m => m.replace(/",$/, '').replace(/,$/, '').replace(/(^"|"$)/g, ''));

    return matches.slice(0, -1);
  }

  dataTypeMapping(tableName, attr, dataType) {
    if (dataType.includes('PRIMARY KEY')) {
      dataType = dataType.replace('PRIMARY KEY', '');
    }

    if (dataType.includes('SERIAL')) {
      if (dataType.includes('BIGINT')) {
        dataType = dataType.replace('SERIAL', 'BIGSERIAL');
        dataType = dataType.replace('BIGINT', '');
      } else if (dataType.includes('SMALLINT')) {
        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');
        dataType = dataType.replace('SMALLINT', '');
      } else {
        dataType = dataType.replace('INTEGER', '');
      }
      dataType = dataType.replace('NOT NULL', '');
    }

    if (dataType.startsWith('ENUM(')) {
      dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
    }

    return dataType;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +
      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;
  }

  /**
   * Generate common SQL prefix for getForeignKeyReferencesQuery.
   *
   * @returns {string}
   */
  _getForeignKeyReferencesQueryPrefix() {
    return 'SELECT ' +
      'DISTINCT tc.constraint_name as constraint_name, ' +
      'tc.constraint_schema as constraint_schema, ' +
      'tc.constraint_catalog as constraint_catalog, ' +
      'tc.table_name as table_name,' +
      'tc.table_schema as table_schema,' +
      'tc.table_catalog as table_catalog,' +
      'kcu.column_name as column_name,' +
      'ccu.table_schema  AS referenced_table_schema,' +
      'ccu.table_catalog  AS referenced_table_catalog,' +
      'ccu.table_name  AS referenced_table_name,' +
      'ccu.column_name AS referenced_column_name ' +
      'FROM information_schema.table_constraints AS tc ' +
      'JOIN information_schema.key_column_usage AS kcu ' +
      'ON tc.constraint_name = kcu.constraint_name ' +
      'JOIN information_schema.constraint_column_usage AS ccu ' +
      'ON ccu.constraint_name = tc.constraint_name ';
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.
   *
   * @param {string} tableName
   * @param {string} catalogName
   * @param {string} schemaName
   */
  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${
      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''
    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;
  }

  getForeignKeyReferenceQuery(table, columnName) {
    const tableName = table.tableName || table;
    const schema = table.schema;
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${
      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;
  }
}

module.exports = PostgresQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");

/**
 * The interface that Sequelize uses to talk with Postgres database
 */
class PostgresQueryInterface extends QueryInterface {
  /**
   * Ensure enum and their values.
   *
   * @param {string} tableName  Name of table to create
   * @param {object} attributes Object representing a list of normalized table attributes
   * @param {object} [options]
   * @param {Model}  [model]
   *
   * @protected
   */
  async ensureEnums(tableName, attributes, options, model) {
    const keys = Object.keys(attributes);
    const keyLen = keys.length;

    let sql = '';
    let promises = [];
    let i = 0;

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
        promises.push(this.sequelize.query(
          sql,
          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }
        ));
      }
    }

    const results = await Promise.all(promises);
    promises = [];
    let enumIdx = 0;

    // This little function allows us to re-use the same code that prepends or appends new value to enum array
    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {
      const valueOptions = { ...options };
      valueOptions.before = null;
      valueOptions.after = null;

      switch (position) {
        case 'after':
          valueOptions.after = relativeValue;
          break;
        case 'before':
        default:
          valueOptions.before = relativeValue;
          break;
      }

      promises.splice(spliceStart, 0, () => {
        return this.sequelize.query(this.queryGenerator.pgEnumAdd(
          tableName, field, value, valueOptions
        ), valueOptions);
      });
    };

    for (i = 0; i < keyLen; i++) {
      const attribute = attributes[keys[i]];
      const type = attribute.type;
      const enumType = type.type || type;
      const field = attribute.field || keys[i];

      if (
        type instanceof DataTypes.ENUM ||
        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM
      ) {
        // If the enum type doesn't exist then create it
        if (!results[enumIdx]) {
          promises.push(() => {
            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });
          });
        } else if (!!results[enumIdx] && !!model) {
          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);
          const vals = enumType.values;

          // Going through already existing values allows us to make queries that depend on those values
          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values
          // Then we append the rest of new values AFTER the latest already existing value
          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]
          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]
          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]
          let lastOldEnumValue;
          let rightestPosition = -1;
          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {
            const enumVal = enumVals[oldIndex];
            const newIdx = vals.indexOf(enumVal);
            lastOldEnumValue = enumVal;

            if (newIdx === -1) {
              continue;
            }

            const newValuesBefore = vals.slice(0, newIdx);
            const promisesLength = promises.length;
            // we go in reverse order so we could stop when we meet old value
            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {
              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {
                break;
              }

              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);
            }

            // we detect the most 'right' position of old value in new enum array so we can append new values to it
            if (newIdx > rightestPosition) {
              rightestPosition = newIdx;
            }
          }

          if (lastOldEnumValue && rightestPosition < vals.length - 1) {
            const remainingEnumValues = vals.slice(rightestPosition + 1);
            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {
              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');
            }
          }

          enumIdx++;
        }
      }
    }

    const result = await promises
      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());

    // If ENUM processed, then refresh OIDs
    if (promises.length) {
      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();
    }
    return result;
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const queryOptions = {
      ...options,
      type: QueryTypes.FOREIGNKEYS
    };

    // postgres needs some special treatment as those field names returned are all lowercase
    // in order to keep same result with other dialects.
    const query = this.queryGenerator.getForeignKeyReferencesQuery(tableName, this.sequelize.config.database);
    const result = await this.sequelize.query(query, queryOptions);
    return result.map(Utils.camelizeObjectKeys);
  }

  /**
   * Drop specified enum from database (Postgres only)
   *
   * @param {string} [enumName]  Enum name to drop
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropEnum(enumName, options) {
    options = options || {};

    return this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),
      { ...options, raw: true }
    );
  }

  /**
   * Drop all enums from database (Postgres only)
   *
   * @param {object} options Query options
   *
   * @returns {Promise}
   */
  async dropAllEnums(options) {
    options = options || {};

    const enums = await this.pgListEnums(null, options);

    return await Promise.all(enums.map(result => this.sequelize.query(
      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),
      { ...options, raw: true }
    )));
  }

  /**
   * List all enums (Postgres only)
   *
   * @param {string} [tableName]  Table whose enum to list
   * @param {object} [options]    Query options
   *
   * @returns {Promise}
   */
  async pgListEnums(tableName, options) {
    options = options || {};
    const sql = this.queryGenerator.pgListEnums(tableName);
    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });
  }

  /**
   * Since postgres has a special case for enums, we should drop the related
   * enum type within the table and attribute
   *
   * @override
   */
  async dropTable(tableName, options) {
    await super.dropTable(tableName, options);
    const promises = [];
    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });

    if (!instanceTable) {
      // Do nothing when model is not available
      return;
    }

    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;

    const keys = Object.keys(instanceTable.rawAttributes);
    const keyLen = keys.length;

    for (let i = 0; i < keyLen; i++) {
      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {
        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);
        options.supportsSearchPath = false;
        promises.push(this.sequelize.query(sql, { ...options, raw: true }));
      }
    }

    await Promise.all(promises);
  }
}

exports.PostgresQueryInterface = PostgresQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:pg');


class Query extends AbstractQuery {
  /**
   * Rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    const stringReplaceFunc = value => typeof value === 'string' ? value.replace(/\0/g, '\\0') : value;

    let bindParam;
    if (Array.isArray(values)) {
      bindParam = values.map(stringReplaceFunc);
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = [];
      let i = 0;
      const seen = {};
      const replacementFunc = (match, key, values) => {
        if (seen[key] !== undefined) {
          return seen[key];
        }
        if (values[key] !== undefined) {
          i = i + 1;
          bindParam.push(stringReplaceFunc(values[key]));
          seen[key] = `$${i}`;
          return `$${i}`;
        }
        return undefined;
      };
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
    }
    return [sql, bindParam];
  }

  async run(sql, parameters) {
    const { connection } = this;

    if (!_.isEmpty(this.options.searchPath)) {
      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;
    }

    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {
      _.toPairs(this.options.includeAliases)
        // Sorting to replace the longest aliases first to prevent alias collision
        .sort((a, b) => b[1].length - a[1].length)
        .forEach(([alias, original]) => {
          const reg = new RegExp(_.escapeRegExp(original), 'g');

          sql = sql.replace(reg, alias);
        });
    }

    this.sql = sql;

    const query = parameters && parameters.length
      ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result)))
      : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));

    const complete = this._logQuery(sql, debug, parameters);

    let queryResult;

    try {
      queryResult = await query;
    } catch (err) {
      // set the client so that it will be reaped if the connection resets while executing
      if (err.code === 'ECONNRESET') {
        connection._invalid = true;
      }

      err.sql = sql;
      err.parameters = parameters;
      throw this.formatError(err);
    }

    complete();

    let rows = Array.isArray(queryResult)
      ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), [])
      : queryResult.rows;
    const rowCount = Array.isArray(queryResult)
      ? queryResult.reduce(
        (count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count,
        0
      )
      : queryResult.rowCount || 0;

    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {
      rows = rows
        .map(row => _.toPairs(row)
          .reduce((acc, [key, value]) => {
            const mapping = this.options.aliasesMapping.get(key);
            acc[mapping || key] = value;
            return acc;
          }, {})
        );
    }

    const isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');
    const isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');

    if (isRelNameQuery) {
      return rows.map(row => ({
        name: row.relname,
        tableName: row.relname.split('_')[0]
      }));
    }
    if (isTableNameQuery) {
      return rows.map(row => Object.values(row));
    }

    if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {
      if (rows[0].sequelize_caught_exception !== null) {
        throw this.formatError({
          sql,
          parameters,
          code: '23505',
          detail: rows[0].sequelize_caught_exception
        });
      }
      for (const row of rows) {
        delete row.sequelize_caught_exception;
      }
    }

    if (this.isShowIndexesQuery()) {
      for (const row of rows) {
        const attributes = /ON .*? (?:USING .*?\s)?\(([^]*)\)/gi.exec(row.definition)[1].split(',');

        // Map column index in table to column name
        const columns = _.zipObject(
          row.column_indexes,
          this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names)
        );
        delete row.column_indexes;
        delete row.column_names;

        let field;
        let attribute;

        // Indkey is the order of attributes in the index, specified by a string of attribute indexes
        row.fields = row.indkey.split(' ').map((indKey, index) => {
          field = columns[indKey];
          // for functional indices indKey = 0
          if (!field) {
            return null;
          }
          attribute = attributes[index];
          return {
            attribute: field,
            collate: attribute.match(/COLLATE "(.*?)"/) ? /COLLATE "(.*?)"/.exec(attribute)[1] : undefined,
            order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,
            length: undefined
          };
        }).filter(n => n !== null);
        delete row.columns;
      }
      return rows;
    }
    if (this.isForeignKeysQuery()) {
      const result = [];
      for (const row of rows) {
        let defParts;
        if (row.condef !== undefined && (defParts = row.condef.match(/FOREIGN KEY \((.+)\) REFERENCES (.+)\((.+)\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {
          row.id = row.constraint_name;
          row.table = defParts[2];
          row.from = defParts[1];
          row.to = defParts[3];
          let i;
          for (i = 5; i <= 8; i += 3) {
            if (/(UPDATE|DELETE)/.test(defParts[i])) {
              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];
            }
          }
        }
        result.push(row);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      let result = rows;
      // Postgres will treat tables as case-insensitive, so fix the case
      // of the returned values to match attributes
      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {
          m[k.toLowerCase()] = k;
          return m;
        }, {});
        result = rows.map(row => {
          return _.mapKeys(row, (value, key) => {
            const targetAttr = attrsMap[key];
            if (typeof targetAttr === 'string' && targetAttr !== key) {
              return targetAttr;
            }
            return key;
          });
        });
      }
      return this.handleSelectQuery(result);
    }
    if (QueryTypes.DESCRIBE === this.options.type) {
      const result = {};

      for (const row of rows) {
        result[row.Field] = {
          type: row.Type.toUpperCase(),
          allowNull: row.Null === 'YES',
          defaultValue: row.Default,
          comment: row.Comment,
          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],
          primaryKey: row.Constraint === 'PRIMARY KEY'
        };

        if (result[row.Field].type === 'BOOLEAN') {
          result[row.Field].defaultValue = { 'false': false, 'true': true }[result[row.Field].defaultValue];

          if (result[row.Field].defaultValue === undefined) {
            result[row.Field].defaultValue = null;
          }
        }

        if (typeof result[row.Field].defaultValue === 'string') {
          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, '');

          if (result[row.Field].defaultValue.includes('::')) {
            const split = result[row.Field].defaultValue.split('::');
            if (split[1].toLowerCase() !== 'regclass)') {
              result[row.Field].defaultValue = split[0];
            }
          }
        }
      }

      return result;
    }
    if (this.isVersionQuery()) {
      return rows[0].server_version;
    }
    if (this.isShowOrDescribeQuery()) {
      return rows;
    }
    if (QueryTypes.BULKUPDATE === this.options.type) {
      if (!this.options.returning) {
        return parseInt(rowCount, 10);
      }
      return this.handleSelectQuery(rows);
    }
    if (QueryTypes.BULKDELETE === this.options.type) {
      return parseInt(rowCount, 10);
    }
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        for (const key in rows[0]) {
          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {
            const record = rows[0][key];

            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

            this.instance.dataValues[attr && attr.fieldName || key] = record;
          }
        }
      }

      if (this.isUpsertQuery()) {
        return [
          this.instance,
          null
        ];
      }

      return [
        this.instance || rows && (this.options.plain && rows[0] || rows) || undefined,
        rowCount
      ];
    }
    if (this.isRawQuery()) {
      return [rows, queryResult];
    }
    return rows;
  }

  formatError(err) {
    let match;
    let table;
    let index;
    let fields;
    let errors;
    let message;

    const code = err.code || err.sqlState;
    const errMessage = err.message || err.messagePrimary;
    const errDetail = err.detail || err.messageDetail;

    switch (code) {
      case '23503':
        index = errMessage.match(/violates foreign key constraint "(.+?)"/);
        index = index ? index[1] : undefined;
        table = errMessage.match(/on table "(.+?)"/);
        table = table ? table[1] : undefined;

        return new sequelizeErrors.ForeignKeyConstraintError({ message: errMessage, fields: null, index, table, parent: err });
      case '23505':
        // there are multiple different formats of error messages for this error code
        // this regex should check at least two
        if (errDetail && (match = errDetail.replace(/"/g, '').match(/Key \((.*?)\)=\((.*?)\)/))) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
          errors = [];
          message = 'Validation error';

          _.forOwn(fields, (value, field) => {
            errors.push(new sequelizeErrors.ValidationErrorItem(
              this.getUniqueConstraintErrorMessage(field),
              'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
              field,
              value,
              this.instance,
              'not_unique'
            ));
          });

          if (this.model && this.model.uniqueKeys) {
            _.forOwn(this.model.uniqueKeys, constraint => {
              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {
                message = constraint.msg;
                return false;
              }
            });
          }

          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
        }

        return new sequelizeErrors.UniqueConstraintError({
          message: errMessage,
          parent: err
        });

      case '23P01':
        match = errDetail.match(/Key \((.*?)\)=\((.*?)\)/);

        if (match) {
          fields = _.zipObject(match[1].split(', '), match[2].split(', '));
        }
        message = 'Exclusion constraint error';

        return new sequelizeErrors.ExclusionConstraintError({
          message,
          constraint: err.constraint,
          fields,
          table: err.table,
          parent: err
        });

      case '42704':
        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {
          message = 'Unknown constraint error';
          index = errMessage.match(/(?:constraint|index) "(.+?)"/i);
          index = index ? index[1] : undefined;
          table = errMessage.match(/relation "(.+?)"/i);
          table = table ? table[1] : undefined;

          throw new sequelizeErrors.UnknownConstraintError({
            message,
            constraint: index,
            fields,
            table,
            parent: err
          });
        }
      // falls through
      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  isForeignKeysQuery() {
    return /SELECT conname as constraint_name, pg_catalog\.pg_get_constraintdef\(r\.oid, true\) as condef FROM pg_catalog\.pg_constraint r WHERE r\.conrelid = \(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\) AND r\.contype = 'f' ORDER BY 1;/.test(this.sql);
  }

  getInsertIdField() {
    return 'id';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/postgres/range.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");

function stringifyRangeBound(bound) {
  if (bound === null) {
    return '' ;
  }
  if (bound === Infinity || bound === -Infinity) {
    return bound.toString().toLowerCase();
  }
  return JSON.stringify(bound);
}

function parseRangeBound(bound, parseType) {
  if (!bound) {
    return null;
  }
  if (bound === 'infinity') {
    return Infinity;
  }
  if (bound === '-infinity') {
    return -Infinity;
  }
  return parseType(bound);

}

function stringify(data) {
  if (data === null) return null;

  if (!Array.isArray(data)) throw new Error('range must be an array');
  if (!data.length) return 'empty';
  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');

  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {
    if (data.inclusive === false) data.inclusive = [false, false];
    else if (!data.inclusive) data.inclusive = [true, false];
    else if (data.inclusive === true) data.inclusive = [true, true];
  } else {
    data.inclusive = [true, false];
  }

  _.each(data, (value, index) => {
    if (_.isObject(value)) {
      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;
      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;
    }
  });

  const lowerBound = stringifyRangeBound(data[0]);
  const upperBound = stringifyRangeBound(data[1]);

  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;
}
exports.stringify = stringify;

function parse(value, parser) {
  if (value === null) return null;
  if (value === 'empty') {
    return [];
  }

  let result = value
    .substring(1, value.length - 1)
    .split(',', 2);

  if (result.length !== 2) return value;

  result = result.map((item, index) => {
    return {
      value: parseRangeBound(item, parser),
      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'
    };
  });

  return result;
}
exports.parse = parse;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ "./node_modules/sequelize/lib/dialects/abstract/connection-manager.js");
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('connection:sqlite');
const dataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { promisify } = __webpack_require__(/*! util */ "util");

class ConnectionManager extends AbstractConnectionManager {
  constructor(dialect, sequelize) {
    super(dialect, sequelize);

    // We attempt to parse file location from a connection uri
    // but we shouldn't match sequelize default host.
    if (this.sequelize.options.host === 'localhost') {
      delete this.sequelize.options.host;
    }

    this.connections = {};
    this.lib = this._loadDialectModule('sqlite3');
    this.refreshTypeParser(dataTypes);
  }

  async _onProcessExit() {
    await Promise.all(
      Object.getOwnPropertyNames(this.connections)
        .map(connection => promisify(callback => this.connections[connection].close(callback))())
    );
    return super._onProcessExit.call(this);
  }

  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types
  _refreshTypeParser(dataType) {
    parserStore.refresh(dataType);
  }

  _clearTypeParser() {
    parserStore.clear();
  }

  async getConnection(options) {
    options = options || {};
    options.uuid = options.uuid || 'default';
    options.storage = this.sequelize.options.storage || this.sequelize.options.host || ':memory:';
    options.inMemory = options.storage === ':memory:' ? 1 : 0;

    const dialectOptions = this.sequelize.options.dialectOptions;
    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;

    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;

    if (this.connections[options.inMemory || options.uuid]) {
      return this.connections[options.inMemory || options.uuid];
    }

    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {
      // automatic path provision for `options.storage`
      fs.mkdirSync(path.dirname(options.storage), { recursive: true });
    }

    const connection = await new Promise((resolve, reject) => {
      this.connections[options.inMemory || options.uuid] = new this.lib.Database(
        options.storage,
        options.readWriteMode,
        err => {
          if (err) return reject(new sequelizeErrors.ConnectionError(err));
          debug(`connection acquired ${options.uuid}`);
          resolve(this.connections[options.inMemory || options.uuid]);
        }
      );
    });

    if (this.sequelize.config.password) {
      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher
      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);
    }
    if (this.sequelize.options.foreignKeys !== false) {
      // Make it possible to define and use foreign key constraints unless
      // explicitly disallowed. It's still opt-in per relation
      connection.run('PRAGMA FOREIGN_KEYS=ON');
    }

    return connection;
  }

  releaseConnection(connection, force) {
    if (connection.filename === ':memory:' && force !== true) return;

    if (connection.uuid) {
      connection.close();
      debug(`connection released ${connection.uuid}`);
      delete this.connections[connection.uuid];
    }
  }
}

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = BaseTypes => {
  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');

  /**
   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.
   *
   * @param {object} dataType The base integer data type.
   * @private
   */
  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._zerofill || dataType._unsigned) {
      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
      dataType._unsigned = undefined;
      dataType._zerofill = undefined;
    }
  }

  /**
   * @see https://sqlite.org/datatype3.html
   */

  BaseTypes.DATE.types.sqlite = ['DATETIME'];
  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];
  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];
  BaseTypes.TEXT.types.sqlite = ['TEXT'];
  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];
  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];
  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];
  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];
  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];
  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];
  BaseTypes.TIME.types.sqlite = ['TIME'];
  BaseTypes.DATEONLY.types.sqlite = ['DATE'];
  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];
  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];
  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];
  BaseTypes.UUID.types.sqlite = ['UUID'];
  BaseTypes.ENUM.types.sqlite = false;
  BaseTypes.REAL.types.sqlite = ['REAL'];
  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];
  BaseTypes.GEOMETRY.types.sqlite = false;
  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];

  class JSONTYPE extends BaseTypes.JSON {
    static parse(data) {
      return JSON.parse(data);
    }
  }

  class DATE extends BaseTypes.DATE {
    static parse(date, options) {
      if (!date.includes('+')) {
        // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set
        return new Date(date + options.timezone);
      }
      return new Date(date); // We already have a timezone stored in the string
    }
  }

  class DATEONLY extends BaseTypes.DATEONLY {
    static parse(date) {
      return date;
    }
  }

  class STRING extends BaseTypes.STRING {
    toSql() {
      if (this._binary) {
        return `VARCHAR BINARY(${this._length})`;
      }
      return super.toSql(this);
    }
  }

  class TEXT extends BaseTypes.TEXT {
    toSql() {
      if (this._length) {
        warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');
        this._length = undefined;
      }
      return 'TEXT';
    }
  }

  class CITEXT extends BaseTypes.CITEXT {
    toSql() {
      return 'TEXT COLLATE NOCASE';
    }
  }

  class CHAR extends BaseTypes.CHAR {
    toSql() {
      if (this._binary) {
        return `CHAR BINARY(${this._length})`;
      }
      return super.toSql();
    }
  }

  class NUMBER extends BaseTypes.NUMBER {
    toSql() {
      let result = this.key;
      if (this._unsigned) {
        result += ' UNSIGNED';
      }
      if (this._zerofill) {
        result += ' ZEROFILL';
      }
      if (this._length) {
        result += `(${this._length}`;
        if (typeof this._decimals === 'number') {
          result += `,${this._decimals}`;
        }
        result += ')';
      }
      return result;
    }
  }

  class TINYINT extends BaseTypes.TINYINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class SMALLINT extends BaseTypes.SMALLINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class MEDIUMINT extends BaseTypes.MEDIUMINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class INTEGER extends BaseTypes.INTEGER {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class BIGINT extends BaseTypes.BIGINT {
    constructor(length) {
      super(length);
      removeUnsupportedIntegerOptions(this);
    }
  }

  class FLOAT extends BaseTypes.FLOAT {
  }

  class DOUBLE extends BaseTypes.DOUBLE {
  }

  class REAL extends BaseTypes.REAL { }

  function parseFloating(value) {
    if (typeof value !== 'string') {
      return value;
    }
    if (value === 'NaN') {
      return NaN;
    }
    if (value === 'Infinity') {
      return Infinity;
    }
    if (value === '-Infinity') {
      return -Infinity;
    }
  }
  for (const floating of [FLOAT, DOUBLE, REAL]) {
    floating.parse = parseFloating;
  }


  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {
    num.prototype.toSql = NUMBER.prototype.toSql;
  }

  class ENUM extends BaseTypes.ENUM {
    toSql() {
      return 'TEXT';
    }
  }

  return {
    DATE,
    DATEONLY,
    STRING,
    CHAR,
    NUMBER,
    FLOAT,
    REAL,
    'DOUBLE PRECISION': DOUBLE,
    TINYINT,
    SMALLINT,
    MEDIUMINT,
    INTEGER,
    BIGINT,
    TEXT,
    ENUM,
    JSON: JSONTYPE,
    CITEXT
  };
};


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const AbstractDialect = __webpack_require__(/*! ../abstract */ "./node_modules/sequelize/lib/dialects/abstract/index.js");
const ConnectionManager = __webpack_require__(/*! ./connection-manager */ "./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js");
const Query = __webpack_require__(/*! ./query */ "./node_modules/sequelize/lib/dialects/sqlite/query.js");
const QueryGenerator = __webpack_require__(/*! ./query-generator */ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js");
const DataTypes = __webpack_require__(/*! ../../data-types */ "./node_modules/sequelize/lib/data-types.js").sqlite;
const { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js");

class SqliteDialect extends AbstractDialect {
  constructor(sequelize) {
    super();
    this.sequelize = sequelize;
    this.connectionManager = new ConnectionManager(this, sequelize);
    this.queryGenerator = new QueryGenerator({
      _dialect: this,
      sequelize
    });

    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);
  }
}

SqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
  'DEFAULT': false,
  'DEFAULT VALUES': true,
  'UNION ALL': false,
  'RIGHT JOIN': false,
  inserts: {
    ignoreDuplicates: ' OR IGNORE',
    updateOnDuplicate: ' ON CONFLICT DO UPDATE SET'
  },
  index: {
    using: false,
    where: true,
    functionBased: true
  },
  transactionOptions: {
    type: true
  },
  constraints: {
    addConstraint: false,
    dropConstraint: false
  },
  joinTableDependent: false,
  groupedLimit: false,
  JSON: true
});

SqliteDialect.prototype.defaultVersion = '3.8.0';
SqliteDialect.prototype.Query = Query;
SqliteDialect.prototype.DataTypes = DataTypes;
SqliteDialect.prototype.name = 'sqlite';
SqliteDialect.prototype.TICK_CHAR = '`';
SqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;
SqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;

module.exports = SqliteDialect;
module.exports.SqliteDialect = SqliteDialect;
module.exports.default = SqliteDialect;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const Transaction = __webpack_require__(/*! ../../transaction */ "./node_modules/sequelize/lib/transaction.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ "./node_modules/sequelize/lib/dialects/mysql/query-generator.js");
const AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ "./node_modules/sequelize/lib/dialects/abstract/query-generator.js");

class SQLiteQueryGenerator extends MySqlQueryGenerator {
  createSchema() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  showSchemasQuery() {
    return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
  }

  versionQuery() {
    return 'SELECT sqlite_version() as `version`';
  }

  createTableQuery(tableName, attributes, options) {
    options = options || {};

    const primaryKeys = [];
    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;
    const attrArray = [];

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        const dataType = attributes[attr];
        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');

        let dataTypeString = dataType;
        if (dataType.includes('PRIMARY KEY')) {
          if (dataType.includes('INT')) {
            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)
            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';

            if (dataType.includes(' REFERENCES')) {
              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));
            }
          }

          if (needsMultiplePrimaryKeys) {
            primaryKeys.push(attr);
            if (dataType.includes('NOT NULL')) {
              dataTypeString = dataType.replace(' PRIMARY KEY', '');
            } else {
              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');
            }
          }
        }
        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);
      }
    }

    const table = this.quoteTable(tableName);
    let attrStr = attrArray.join(', ');
    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns => {
        if (columns.customIndex) {
          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;
        }
      });
    }

    if (pkString.length > 0) {
      attrStr += `, PRIMARY KEY (${pkString})`;
    }

    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;
    return this.replaceBooleanDefaults(sql);
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== 'string') {
      return false;
    }

    // https://sqlite.org/json1.html
    const jsonFunctionRegex = /^\s*(json(?:_[a-z]+){0,2})\([^)]*\)/i;
    const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex < stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf('(');
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === '(') {
          openingBrackets++;
        } else if (capturedToken === ')') {
          closingBrackets++;
        } else if (capturedToken === ';') {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction && hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  //sqlite can't cast to datetime so we need to convert date values to their ISO strings
  _toJSONValue(value) {
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (Array.isArray(value) && value[0] instanceof Date) {
      return value.map(val => val.toISOString());
    }
    return value;
  }


  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }

    if (smth instanceof Utils.Cast) {
      if (/timestamp/i.test(smth.type)) {
        smth.type = 'datetime';
      }
    }

    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, dataType) {
    const attributes = {};
    attributes[key] = dataType;
    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });
    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;

    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;

    return this.replaceBooleanDefaults(sql);
  }

  showTablesQuery() {
    return 'SELECT name FROM `sqlite_master` WHERE type=\'table\' and name!=\'sqlite_sequence\';';
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    const modelAttributeMap = {};
    const values = [];
    const bind = [];
    const bindParam = options.bindParam || this.bindParam(bind);

    if (attributes) {
      _.each(attributes, (attribute, key) => {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (const key in attrValueHash) {
      const value = attrValueHash[key];

      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);
      } else {
        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);
      }
    }

    let query;
    const whereOptions = { ...options, bindParam };

    if (options.limit) {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;
    } else {
      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;
    }

    return { query, bind };
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `DELETE FROM ${this.quoteTable(tableName)}`,
      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), "'")};` : ''
    ].join('');
  }

  deleteQuery(tableName, where, options = {}, model) {
    _.defaults(options, this.options);

    let whereClause = this.getWhereConditions(where, null, model, options);

    if (whereClause) {
      whereClause = `WHERE ${whereClause}`;
    }

    if (options.limit) {
      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;
    }

    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;
  }

  attributesToSQL(attributes) {
    const result = {};
    for (const name in attributes) {
      const dataType = attributes[name];
      const fieldName = dataType.field || name;

      if (_.isObject(dataType)) {
        let sql = dataType.type.toString();

        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {
          sql += ' NOT NULL';
        }

        if (Utils.defaultValueSchemable(dataType.defaultValue)) {
          // TODO thoroughly check that DataTypes.NOW will properly
          // get populated on all databases as DEFAULT value
          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP
          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;
        }

        if (dataType.unique === true) {
          sql += ' UNIQUE';
        }

        if (dataType.primaryKey) {
          sql += ' PRIMARY KEY';

          if (dataType.autoIncrement) {
            sql += ' AUTOINCREMENT';
          }
        }

        if (dataType.references) {
          const referencesTable = this.quoteTable(dataType.references.model);

          let referencesKey;
          if (dataType.references.key) {
            referencesKey = this.quoteIdentifier(dataType.references.key);
          } else {
            referencesKey = this.quoteIdentifier('id');
          }

          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

          if (dataType.onDelete) {
            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;
          }

          if (dataType.onUpdate) {
            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;
          }

        }

        result[fieldName] = sql;
      } else {
        result[fieldName] = dataType;
      }
    }

    return result;
  }

  showIndexesQuery(tableName) {
    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;
  }

  showConstraintsQuery(tableName, constraintName) {
    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;

    if (constraintName) {
      sql += ` AND sql LIKE '%${constraintName}%'`;
    }

    return `${sql};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;
  }

  describeTableQuery(tableName, schema, schemaDelimiter) {
    const table = {
      _schema: schema,
      _schemaDelimiter: schemaDelimiter,
      tableName
    };
    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;
  }

  describeCreateTableQuery(tableName) {
    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;
  }

  removeColumnQuery(tableName, attributes) {

    attributes = this.attributesToSQL(attributes);

    let backupTableName;
    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary table cannot work for foreign keys.
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  _alterConstraintQuery(tableName, attributes, createTableSql) {
    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }
    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    return `${createTableSql
      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)
      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '"')}`, `CREATE TABLE ${quotedBackupTableName}`)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};`
      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;
  }

  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {

    let backupTableName;

    attributes = this.attributesToSQL(attributes);

    if (typeof tableName === 'object') {
      backupTableName = {
        tableName: `${tableName.tableName}_backup`,
        schema: tableName.schema
      };
    } else {
      backupTableName = `${tableName}_backup`;
    }

    const quotedTableName = this.quoteTable(tableName);
    const quotedBackupTableName = this.quoteTable(backupTableName);
    const attributeNamesImport = Object.keys(attributes).map(attr =>
      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)
    ).join(', ');
    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');

    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved
    return `${this.createTableQuery(backupTableName, attributes)
    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`
      + `DROP TABLE ${quotedTableName};${
        this.createTableQuery(tableName, attributes)
      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`
      + `DROP TABLE ${quotedBackupTableName};`;
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;
    }

    return `BEGIN ${transaction.options.type} TRANSACTION;`;
  }

  setIsolationLevelQuery(value) {
    switch (value) {
      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';
      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
        return 'PRAGMA read_uncommitted = ON;';
      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
        return 'PRAGMA read_uncommitted = OFF;';
      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
        return '-- SQLite\'s default isolation level is SERIALIZABLE. Nothing to do.';
      default:
        throw new Error(`Unknown isolation level: ${value}`);
    }
  }

  replaceBooleanDefaults(sql) {
    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return `PRAGMA foreign_key_list(${tableName})`;
  }
}

module.exports = SQLiteQueryGenerator;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ "./node_modules/sequelize/lib/dialects/abstract/query-interface.js");
const { cloneDeep } = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

/**
 * The interface that Sequelize uses to talk with SQLite database
 */
class SQLiteQueryInterface extends QueryInterface {
  /**
   * A wrapper that fixes SQLite's inability to remove columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but without the obsolete column.
   *
   * @override
   */
  async removeColumn(tableName, attributeName, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    delete fields[attributeName];

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to change columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a modified version of the respective column.
   *
   * @override
   */
  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
    options = options || {};

    const fields = await this.describeTable(tableName, options);
    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));

    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * A wrapper that fixes SQLite's inability to rename columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a renamed version of the respective column.
   *
   * @override
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);

    fields[attrNameAfter] = { ...fields[attrNameBefore] };
    delete fields[attrNameBefore];

    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async removeConstraint(tableName, constraintName, options) {
    let createTableSql;

    const constraints = await this.showConstraint(tableName, constraintName);
    // sqlite can't show only one constraint, so we find here the one to remove
    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);

    if (!constraint) {
      throw new sequelizeErrors.UnknownConstraintError({
        message: `Constraint ${constraintName} on table ${tableName} does not exist`,
        constraint: constraintName,
        table: tableName
      });
    }
    createTableSql = constraint.sql;
    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;

    if (constraint.constraintType === 'FOREIGN KEY') {
      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);
      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));
      const referenceTableKeys = constraint.referenceTableKeys.join(', ');
      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;
      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;
      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;
    }

    createTableSql = createTableSql.replace(constraintSnippet, '');
    createTableSql += ';';

    const fields = await this.describeTable(tableName, options);

    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error('Fields must be specified through options.fields');
    }

    if (!options.type) {
      throw new Error('Constraint type must be specified through options.type');
    }

    options = cloneDeep(options);

    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);

    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options, type: QueryTypes.SELECT, raw: true });
    let sql = constraints[0].sql;
    const index = sql.length - 1;
    //Replace ending ')' with constraint snippet - Simulates String.replaceAt
    //http://stackoverflow.com/questions/1431094
    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;

    const fields = await this.describeTable(tableName, options);
    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(';').filter(q => q !== '');

    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
  }

  /**
   * @override
   */
  async getForeignKeyReferencesForTable(tableName, options) {
    const database = this.sequelize.config.database;
    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);
    const result = await this.sequelize.query(query, options);
    return result.map(row => ({
      tableName,
      columnName: row.from,
      referencedTableName: row.table,
      referencedColumnName: row.to,
      tableCatalog: database,
      referencedTableCatalog: database
    }));
  }

  /**
   * @override
   */
  async dropAllTables(options) {
    options = options || {};
    const skip = options.skip || [];

    const tableNames = await this.showAllTables(options);
    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);
    await this._dropAllTables(tableNames, skip, options);
    await this.sequelize.query('PRAGMA foreign_keys = ON', options);
  }

  /**
   * @override
   */
  async describeTable(tableName, options) {
    let schema = null;
    let schemaDelimiter = null;

    if (typeof options === 'string') {
      schema = options;
    } else if (typeof options === 'object' && options !== null) {
      schema = options.schema || null;
      schemaDelimiter = options.schemaDelimiter || null;
    }

    if (typeof tableName === 'object' && tableName !== null) {
      schema = tableName.schema;
      tableName = tableName.tableName;
    }

    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
    options = { ...options, type: QueryTypes.DESCRIBE };
    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);

    try {
      const data = await this.sequelize.query(sql, options);
      /*
       * If no data is returned from the query, then the table name may be wrong.
       * Query generators that use information_schema for retrieving table info will just return an empty result set,
       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).
       */
      if (_.isEmpty(data)) {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      const indexes = await this.sequelize.query(sqlIndexes, options);
      for (const prop in data) {
        data[prop].unique = false;
      }
      for (const index of indexes) {
        for (const field of index.fields) {
          if (index.unique !== undefined) {
            data[field.attribute].unique = index.unique;
          }
        }
      }

      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);
      for (const foreignKey of foreignKeys) {
        data[foreignKey.columnName].references = {
          model: foreignKey.referencedTableName,
          key: foreignKey.referencedColumnName
        };
      }

      return data;
    } catch (e) {
      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {
        throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
      }

      throw e;
    }
  }
}

exports.SQLiteQueryInterface = SQLiteQueryInterface;


/***/ }),

/***/ "./node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ../../utils */ "./node_modules/sequelize/lib/utils.js");
const AbstractQuery = __webpack_require__(/*! ../abstract/query */ "./node_modules/sequelize/lib/dialects/abstract/query.js");
const QueryTypes = __webpack_require__(/*! ../../query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ../../errors */ "./node_modules/sequelize/lib/errors/index.js");
const parserStore = __webpack_require__(/*! ../parserStore */ "./node_modules/sequelize/lib/dialects/parserStore.js")('sqlite');
const { logger } = __webpack_require__(/*! ../../utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

const debug = logger.debugContext('sql:sqlite');


class Query extends AbstractQuery {
  getInsertIdField() {
    return 'lastID';
  }

  /**
   * rewrite query with parameters.
   *
   * @param {string} sql
   * @param {Array|object} values
   * @param {string} dialect
   * @private
   */
  static formatBindParameters(sql, values, dialect) {
    let bindParam;
    if (Array.isArray(values)) {
      bindParam = {};
      values.forEach((v, i) => {
        bindParam[`$${i + 1}`] = v;
      });
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    } else {
      bindParam = {};
      if (typeof values === 'object') {
        for (const k of Object.keys(values)) {
          bindParam[`$${k}`] = values[k];
        }
      }
      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];
    }
    return [sql, bindParam];
  }

  _collectModels(include, prefix) {
    const ret = {};

    if (include) {
      for (const _include of include) {
        let key;
        if (!prefix) {
          key = _include.as;
        } else {
          key = `${prefix}.${_include.as}`;
        }
        ret[key] = _include.model;

        if (_include.include) {
          _.merge(ret, this._collectModels(_include.include, key));
        }
      }
    }

    return ret;
  }

  _handleQueryResponse(metaData, columnTypes, err, results) {
    if (err) {
      err.sql = this.sql;
      throw this.formatError(err);
    }
    let result = this.instance;

    // add the inserted row id to the instance
    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
      this.handleInsertQuery(results, metaData);
      if (!this.instance) {
        // handle bulkCreate AI primary key
        if (
          metaData.constructor.name === 'Statement'
          && this.model
          && this.model.autoIncrementAttribute
          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute
          && this.model.rawAttributes[this.model.primaryKeyAttribute]
        ) {
          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
          result = [];
          for (let i = startId; i < startId + metaData.changes; i++) {
            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });
          }
        } else {
          result = metaData[this.getInsertIdField()];
        }
      }
    }

    if (this.isShowTablesQuery()) {
      return results.map(row => row.name);
    }
    if (this.isShowConstraintsQuery()) {
      result = results;
      if (results && results[0] && results[0].sql) {
        result = this.parseConstraintsFromSql(results[0].sql);
      }
      return result;
    }
    if (this.isSelectQuery()) {
      if (this.options.raw) {
        return this.handleSelectQuery(results);
      }
      // This is a map of prefix strings to models, e.g. user.projects -> Project model
      const prefixes = this._collectModels(this.options.include);

      results = results.map(result => {
        return _.mapValues(result, (value, name) => {
          let model;
          if (name.includes('.')) {
            const lastind = name.lastIndexOf('.');

            model = prefixes[name.substr(0, lastind)];

            name = name.substr(lastind + 1);
          } else {
            model = this.options.model;
          }

          const tableName = model.getTableName().toString().replace(/`/g, '');
          const tableTypes = columnTypes[tableName] || {};

          if (tableTypes && !(name in tableTypes)) {
            // The column is aliased
            _.forOwn(model.rawAttributes, (attribute, key) => {
              if (name === key && attribute.field) {
                name = attribute.field;
                return false;
              }
            });
          }

          return Object.prototype.hasOwnProperty.call(tableTypes, name)
            ? this.applyParsers(tableTypes[name], value)
            : value;
        });
      });

      return this.handleSelectQuery(results);
    }
    if (this.isShowOrDescribeQuery()) {
      return results;
    }
    if (this.sql.includes('PRAGMA INDEX_LIST')) {
      return this.handleShowIndexesQuery(results);
    }
    if (this.sql.includes('PRAGMA INDEX_INFO')) {
      return results;
    }
    if (this.sql.includes('PRAGMA TABLE_INFO')) {
      // this is the sqlite way of getting the metadata of a table
      result = {};

      let defaultValue;
      for (const _result of results) {
        if (_result.dflt_value === null) {
          // Column schema omits any "DEFAULT ..."
          defaultValue = undefined;
        } else if (_result.dflt_value === 'NULL') {
          // Column schema is a "DEFAULT NULL"
          defaultValue = null;
        } else {
          defaultValue = _result.dflt_value;
        }

        result[_result.name] = {
          type: _result.type,
          allowNull: _result.notnull === 0,
          defaultValue,
          primaryKey: _result.pk !== 0
        };

        if (result[_result.name].type === 'TINYINT(1)') {
          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];
        }

        if (typeof result[_result.name].defaultValue === 'string') {
          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');
        }
      }
      return result;
    }
    if (this.sql.includes('PRAGMA foreign_keys;')) {
      return results[0];
    }
    if (this.sql.includes('PRAGMA foreign_keys')) {
      return results;
    }
    if (this.sql.includes('PRAGMA foreign_key_list')) {
      return results;
    }
    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {
      return metaData.changes;
    }
    if (this.options.type === QueryTypes.VERSION) {
      return results[0].version;
    }
    if (this.options.type === QueryTypes.RAW) {
      return [results, metaData];
    }
    if (this.isUpsertQuery()) {
      return [result, null];
    }
    if (this.isUpdateQuery() || this.isInsertQuery()) {
      return [result, metaData.changes];
    }
    return result;
  }

  async run(sql, parameters) {
    const conn = this.connection;
    this.sql = sql;
    const method = this.getDatabaseMethod();
    const complete = this._logQuery(sql, debug, parameters);

    return new Promise((resolve, reject) => conn.serialize(async () => {
      const columnTypes = {};
      const executeSql = () => {
        if (sql.startsWith('-- ')) {
          return resolve();
        }
        const query = this;
        // cannot use arrow function here because the function is bound to the statement
        function afterExecute(executionError, results) {
          try {
            complete();
            // `this` is passed from sqlite, we have no control over this.
            // eslint-disable-next-line no-invalid-this
            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));
            return;
          } catch (error) {
            reject(error);
          }
        }

        if (!parameters) parameters = [];
        conn[method](sql, parameters, afterExecute);

        return null;
      };

      if (this.getDatabaseMethod() === 'all') {
        let tableNames = [];
        if (this.options && this.options.tableNames) {
          tableNames = this.options.tableNames;
        } else if (/FROM `(.*?)`/i.exec(this.sql)) {
          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);
        }

        // If we already have the metadata for the table, there's no need to ask for it again
        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');

        if (!tableNames.length) {
          return executeSql();
        }
        await Promise.all(tableNames.map(tableName =>
          new Promise(resolve => {
            tableName = tableName.replace(/`/g, '');
            columnTypes[tableName] = {};

            conn.all(`PRAGMA table_info(\`${tableName}\`)`, (err, results) => {
              if (!err) {
                for (const result of results) {
                  columnTypes[tableName][result.name] = result.type;
                }
              }
              resolve();
            });
          })));
      }
      return executeSql();
    }));
  }

  parseConstraintsFromSql(sql) {
    let constraints = sql.split('CONSTRAINT ');
    let referenceTableName, referenceTableKeys, updateAction, deleteAction;
    constraints.splice(0, 1);
    constraints = constraints.map(constraintSql => {
      //Parse foreign key snippets
      if (constraintSql.includes('REFERENCES')) {
        //Parse out the constraint condition form sql string
        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);

        if (updateAction) {
          updateAction = updateAction[1];
        }

        if (deleteAction) {
          deleteAction = deleteAction[1];
        }

        const referencesRegex = /REFERENCES.+\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/;
        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');
        referenceTableName = Utils.removeTicks(referenceConditions[1]);
        let columnNames = referenceConditions[2];
        columnNames = columnNames.replace(/\(|\)/g, '').split(', ');
        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));
      }

      const constraintCondition = constraintSql.match(/\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/)[0];
      constraintSql = constraintSql.replace(/\(.+\)/, '');
      const constraint = constraintSql.split(' ');

      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {
        constraint[1] += ' KEY';
      }

      return {
        constraintName: Utils.removeTicks(constraint[0]),
        constraintType: constraint[1],
        updateAction,
        deleteAction,
        sql: sql.replace(/"/g, '`'), //Sqlite returns double quotes for table name
        constraintCondition,
        referenceTableName,
        referenceTableKeys
      };
    });

    return constraints;
  }

  applyParsers(type, value) {
    if (type.includes('(')) {
      // Remove the length part
      type = type.substr(0, type.indexOf('('));
    }
    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');
    type = type.trim().toUpperCase();
    const parse = parserStore.get(type);

    if (value !== null && parse) {
      return parse(value, { timezone: this.sequelize.options.timezone });
    }
    return value;
  }

  formatError(err) {

    switch (err.code) {
      case 'SQLITE_CONSTRAINT': {
        if (err.message.includes('FOREIGN KEY constraint failed')) {
          return new sequelizeErrors.ForeignKeyConstraintError({
            parent: err
          });
        }

        let fields = [];

        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique
        let match = err.message.match(/columns (.*?) are/);
        if (match !== null && match.length >= 2) {
          fields = match[1].split(', ');
        } else {

          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y
          match = err.message.match(/UNIQUE constraint failed: (.*)/);
          if (match !== null && match.length >= 2) {
            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);
          }
        }

        const errors = [];
        let message = 'Validation error';

        for (const field of fields) {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            this.instance && this.instance[field],
            this.instance,
            'not_unique'
          ));
        }

        if (this.model) {
          _.forOwn(this.model.uniqueKeys, constraint => {
            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {
              message = constraint.msg;
              return false;
            }
          });
        }

        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });
      }
      case 'SQLITE_BUSY':
        return new sequelizeErrors.TimeoutError(err);

      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }

  async handleShowIndexesQuery(data) {
    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!
    return Promise.all(data.reverse().map(async item => {
      item.fields = [];
      item.primary = false;
      item.unique = !!item.unique;
      item.constraintName = item.name;
      const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
      for (const column of columns) {
        item.fields[column.seqno] = {
          attribute: column.name,
          length: undefined,
          order: undefined
        };
      }

      return item;
    }));
  }

  getDatabaseMethod() {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
      return 'run';
    }
    return 'all';
  }
}

module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/aggregate-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A wrapper for multiple Errors
 *
 * @param {Error[]} [errors] Array of errors
 *
 * @property errors {Error[]}
 */
class AggregateError extends BaseError {
  constructor(errors) {
    super();
    this.errors = errors;
    this.name = 'AggregateError';
  }

  toString() {
    const message = `AggregateError of:\n${
      this.errors.map(error =>
        error === this
          ? '[Circular AggregateError]'
          : error instanceof AggregateError
            ? String(error).replace(/\n$/, '').replace(/^/mg, '  ')
            : String(error).replace(/^/mg, '    ').substring(2)
        
      ).join('\n')
    }\n`;
    return message;
  }
}

module.exports = AggregateError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/association-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/association-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an association is improperly constructed (see message for details)
 */
class AssociationError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeAssociationError';
  }
}

module.exports = AssociationError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/base-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/base-error.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.
 * All sequelize errors inherit from the base JS error object.
 *
 * This means that errors can be accessed using `Sequelize.ValidationError`
 * The Base Error all Sequelize Errors inherit from.
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'SequelizeBaseError';
  }
}

module.exports = BaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when bulk operation fails, it represent per record level error.
 * Used with AggregateError
 *
 * @param {Error}  error   Error for a given record/instance
 * @param {object} record  DAO instance that error belongs to
 */
class BulkRecordError extends BaseError {
  constructor(error, record) {
    super(error.message);
    this.name = 'SequelizeBulkRecordError';
    this.errors = error;
    this.record = record;
  }
}

module.exports = BulkRecordError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all connection related errors.
 */
class ConnectionError extends BaseError {
  constructor(parent) {
    super(parent ? parent.message : '');
    this.name = 'SequelizeConnectionError';
    /**
     * The connection specific error which triggered this one
     *
     * @type {Error}
     */
    this.parent = parent;
    this.original = parent;
  }
}

module.exports = ConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused due to insufficient privileges
 */
class AccessDeniedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeAccessDeniedError';
  }
}

module.exports = AccessDeniedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when connection is not acquired due to timeout
 */
class ConnectionAcquireTimeoutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionAcquireTimeoutError';
  }
}

module.exports = ConnectionAcquireTimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database is refused
 */
class ConnectionRefusedError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionRefusedError';
  }
}

module.exports = ConnectionRefusedError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database times out
 */
class ConnectionTimedOutError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeConnectionTimedOutError';
  }
}

module.exports = ConnectionTimedOutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not found
 */
class HostNotFoundError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotFoundError';
  }
}

module.exports = HostNotFoundError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has a hostname that was not reachable
 */
class HostNotReachableError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeHostNotReachableError';
  }
}

module.exports = HostNotReachableError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ConnectionError = __webpack_require__(/*! ./../connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");

/**
 * Thrown when a connection to a database has invalid values for any of the connection parameters
 */
class InvalidConnectionError extends ConnectionError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeInvalidConnectionError';
  }
}

module.exports = InvalidConnectionError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * A base class for all database related errors.
 */
class DatabaseError extends BaseError {
  constructor(parent) {
    super(parent.message);
    this.name = 'SequelizeDatabaseError';
    /**
     * @type {Error}
     */
    this.parent = parent;
    /**
     * @type {Error}
     */
    this.original = parent;
    /**
     * The SQL that triggered the error
     *
     * @type {string}
     */
    this.sql = parent.sql;
    /**
     * The parameters for the sql that triggered the error
     *
     * @type {Array<any>}
     */
    this.parameters = parent.parameters;
  }
}

module.exports = DatabaseError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when an exclusion constraint is violated in the database
 */
class ExclusionConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeExclusionConstraintError';

    this.message = options.message || options.parent.message || '';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = ExclusionConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a foreign key constraint is violated in the database
 */
class ForeignKeyConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeForeignKeyConstraintError';

    this.message = options.message || options.parent.message || 'Database Error';
    this.fields = options.fields;
    this.table = options.table;
    this.value = options.value;
    this.index = options.index;
    this.reltype = options.reltype;
  }
}

module.exports = ForeignKeyConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when a database query times out because of a deadlock
 */
class TimeoutError extends DatabaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeTimeoutError';
  }
}

module.exports = TimeoutError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DatabaseError = __webpack_require__(/*! ./../database-error */ "./node_modules/sequelize/lib/errors/database-error.js");

/**
 * Thrown when constraint name is not found in the database
 */
class UnknownConstraintError extends DatabaseError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };

    super(options.parent);
    this.name = 'SequelizeUnknownConstraintError';

    this.message = options.message || 'The specified constraint does not exist';
    this.constraint = options.constraint;
    this.fields = options.fields;
    this.table = options.table;
  }
}

module.exports = UnknownConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when an include statement is improperly constructed (see message for details)
 */
class EagerLoadingError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEagerLoadingError';
  }
}

module.exports = EagerLoadingError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/empty-result-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)
 */
class EmptyResultError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeEmptyResultError';
  }
}

module.exports = EmptyResultError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

exports.AggregateError = __webpack_require__(/*! ./aggregate-error */ "./node_modules/sequelize/lib/errors/aggregate-error.js");
exports.AsyncQueueError = __webpack_require__(/*! ../dialects/mssql/async-queue */ "./node_modules/sequelize/lib/dialects/mssql/async-queue.js").AsyncQueueError;
exports.AssociationError = __webpack_require__(/*! ./association-error */ "./node_modules/sequelize/lib/errors/association-error.js");
exports.BulkRecordError = __webpack_require__(/*! ./bulk-record-error */ "./node_modules/sequelize/lib/errors/bulk-record-error.js");
exports.ConnectionError = __webpack_require__(/*! ./connection-error */ "./node_modules/sequelize/lib/errors/connection-error.js");
exports.DatabaseError = __webpack_require__(/*! ./database-error */ "./node_modules/sequelize/lib/errors/database-error.js");
exports.EagerLoadingError = __webpack_require__(/*! ./eager-loading-error */ "./node_modules/sequelize/lib/errors/eager-loading-error.js");
exports.EmptyResultError = __webpack_require__(/*! ./empty-result-error */ "./node_modules/sequelize/lib/errors/empty-result-error.js");
exports.InstanceError = __webpack_require__(/*! ./instance-error */ "./node_modules/sequelize/lib/errors/instance-error.js");
exports.OptimisticLockError = __webpack_require__(/*! ./optimistic-lock-error */ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js");
exports.QueryError = __webpack_require__(/*! ./query-error */ "./node_modules/sequelize/lib/errors/query-error.js");
exports.SequelizeScopeError = __webpack_require__(/*! ./sequelize-scope-error */ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js");
exports.ValidationError = __webpack_require__(/*! ./validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");
exports.ValidationErrorItem = exports.ValidationError.ValidationErrorItem;

exports.AccessDeniedError = __webpack_require__(/*! ./connection/access-denied-error */ "./node_modules/sequelize/lib/errors/connection/access-denied-error.js");
exports.ConnectionAcquireTimeoutError = __webpack_require__(/*! ./connection/connection-acquire-timeout-error */ "./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js");
exports.ConnectionRefusedError = __webpack_require__(/*! ./connection/connection-refused-error */ "./node_modules/sequelize/lib/errors/connection/connection-refused-error.js");
exports.ConnectionTimedOutError = __webpack_require__(/*! ./connection/connection-timed-out-error */ "./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js");
exports.HostNotFoundError = __webpack_require__(/*! ./connection/host-not-found-error */ "./node_modules/sequelize/lib/errors/connection/host-not-found-error.js");
exports.HostNotReachableError = __webpack_require__(/*! ./connection/host-not-reachable-error */ "./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js");
exports.InvalidConnectionError = __webpack_require__(/*! ./connection/invalid-connection-error */ "./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js");

exports.ExclusionConstraintError = __webpack_require__(/*! ./database/exclusion-constraint-error */ "./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js");
exports.ForeignKeyConstraintError = __webpack_require__(/*! ./database/foreign-key-constraint-error */ "./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js");
exports.TimeoutError = __webpack_require__(/*! ./database/timeout-error */ "./node_modules/sequelize/lib/errors/database/timeout-error.js");
exports.UnknownConstraintError = __webpack_require__(/*! ./database/unknown-constraint-error */ "./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js");

exports.UniqueConstraintError = __webpack_require__(/*! ./validation/unique-constraint-error */ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js");


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/instance-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/instance-error.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a some problem occurred with Instance methods (see message for details)
 */
class InstanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeInstanceError';
  }
}

module.exports = InstanceError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when attempting to update a stale model instance
 */
class OptimisticLockError extends BaseError {
  constructor(options) {
    options = options || {};
    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;
    super(options.message);
    this.name = 'SequelizeOptimisticLockError';
    /**
     * The name of the model on which the update was attempted
     *
     * @type {string}
     */
    this.modelName = options.modelName;
    /**
     * The values of the attempted update
     *
     * @type {object}
     */
    this.values = options.values;
    /**
     *
     * @type {object}
     */
    this.where = options.where;
  }
}

module.exports = OptimisticLockError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/query-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/query-error.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Thrown when a query is passed invalid options (see message for details)
 */
class QueryError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'SequelizeQueryError';
  }
}

module.exports = QueryError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Scope Error. Thrown when the sequelize cannot query the specified scope.
 */
class SequelizeScopeError extends BaseError {
  constructor(parent) {
    super(parent);
    this.name = 'SequelizeScopeError';
  }
}

module.exports = SequelizeScopeError;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__(/*! ./base-error */ "./node_modules/sequelize/lib/errors/base-error.js");

/**
 * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,
 * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.
 *
 * @param {string} message Error message
 * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors
 *
 * @property errors {ValidationErrorItems[]}
 */
class ValidationError extends BaseError {
  constructor(message, errors) {
    super(message);
    this.name = 'SequelizeValidationError';
    this.message = 'Validation Error';
    /**
     *
     * @type {ValidationErrorItem[]}
     */
    this.errors = errors || [];

    // Use provided error message if available...
    if (message) {
      this.message = message;

      // ... otherwise create a concatenated message out of existing errors.
    } else if (this.errors.length > 0 && this.errors[0].message) {
      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\n');
    }
  }

  /**
   * Gets all validation error items for the path / field specified.
   *
   * @param {string} path The path to be checked for error items
   *
   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path
   */
  get(path) {
    return this.errors.reduce((reduced, error) => {
      if (error.path === path) {
        reduced.push(error);
      }
      return reduced;
    }, []);
  }
}

/**
 * Validation Error Item
 * Instances of this class are included in the `ValidationError.errors` property.
 */
class ValidationErrorItem {
  /**
   * Creates a new ValidationError item. Instances of this class are included in the `ValidationError.errors` property.
   *
   * @param {string} [message] An error message
   * @param {string} [type] The type/origin of the validation error
   * @param {string} [path] The field that triggered the validation error
   * @param {string} [value] The value that generated the error
   * @param {Model} [instance] the DAO instance that caused the validation error
   * @param {string} [validatorKey] a validation "key", used for identification
   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
   * @param {Array} [fnArgs] parameters used with the BUILT-IN validator function, if applicable
   */
  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {
    /**
     * An error message
     *
     * @type {string} message
     */
    this.message = message || '';

    /**
     * The type/origin of the validation error
     *
     * @type {string | null}
     */
    this.type = null;

    /**
     * The field that triggered the validation error
     *
     * @type {string | null}
     */
    this.path = path || null;

    /**
     * The value that generated the error
     *
     * @type {string | null}
     */
    this.value = value !== undefined ? value : null;

    this.origin = null;

    /**
     * The DAO instance that caused the validation error
     *
     * @type {Model | null}
     */
    this.instance = instance || null;

    /**
     * A validation "key", used for identification
     *
     * @type {string | null}
     */
    this.validatorKey = validatorKey || null;

    /**
     * Property name of the BUILT-IN validator function that caused the validation error (e.g. "in" or "len"), if applicable
     *
     * @type {string | null}
     */
    this.validatorName = fnName || null;

    /**
     * Parameters used with the BUILT-IN validator function, if applicable
     *
     * @type {Array}
     */
    this.validatorArgs = fnArgs || [];

    if (type) {
      if (ValidationErrorItem.Origins[ type ]) {
        this.origin = type;
      } else {
        const lowercaseType = `${type}`.toLowerCase().trim();
        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];

        if (realType && ValidationErrorItem.Origins[ realType ]) {
          this.origin = realType;
          this.type = type;
        }
      }
    }

    // This doesn't need captureStackTrace because it's not a subclass of Error
  }

  /**
   * return a lowercase, trimmed string "key" that identifies the validator.
   *
   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property
   *
   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is "namespace",
   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins
   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,
   *                                            defaults to "." (fullstop). only used and validated if useTypeAsNS is TRUE.
   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.
   * @returns  {string}
   *
   * @private
   */
  getValidatorKey(useTypeAsNS, NSSeparator) {
    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;
    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;

    const type = this.origin;
    const key = this.validatorKey || this.validatorName;
    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];

    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {
      throw new Error('Invalid namespace separator given, must be a non-empty string');
    }

    if (!(typeof key === 'string' && key.length)) {
      return '';
    }

    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();
  }
}

/**
 * An enum that defines valid ValidationErrorItem `origin` values
 *
 * @type {object}
 * @property CORE       {string}  specifies errors that originate from the sequelize "core"
 * @property DB         {string}  specifies validation errors that originate from the storage engine
 * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute
 */
ValidationErrorItem.Origins = {
  CORE: 'CORE',
  DB: 'DB',
  FUNCTION: 'FUNCTION'
};

/**
 * An object that is used internally by the `ValidationErrorItem` class
 * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to
 * our new `origin` values.
 *
 * @type {object}
 */
ValidationErrorItem.TypeStringMap = {
  'notnull violation': 'CORE',
  'string violation': 'CORE',
  'unique violation': 'DB',
  'validation error': 'FUNCTION'
};

module.exports = ValidationError;
module.exports.ValidationErrorItem = ValidationErrorItem;


/***/ }),

/***/ "./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ValidationError = __webpack_require__(/*! ./../validation-error */ "./node_modules/sequelize/lib/errors/validation-error.js");

/**
 * Thrown when a unique constraint is violated in the database
 */
class UniqueConstraintError extends ValidationError {
  constructor(options) {
    options = options || {};
    options.parent = options.parent || { sql: '' };
    options.message = options.message || options.parent.message || 'Validation Error';
    options.errors = options.errors || {};
    super(options.message, options.errors);

    this.name = 'SequelizeUniqueConstraintError';
    this.errors = options.errors;
    this.fields = options.fields;
    this.parent = options.parent;
    this.original = options.parent;
    this.sql = options.parent.sql;
  }
}

module.exports = UniqueConstraintError;


/***/ }),

/***/ "./node_modules/sequelize/lib/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const debug = logger.debugContext('hooks');

const hookTypes = {
  beforeValidate: { params: 2 },
  afterValidate: { params: 2 },
  validationFailed: { params: 3 },
  beforeCreate: { params: 2 },
  afterCreate: { params: 2 },
  beforeDestroy: { params: 2 },
  afterDestroy: { params: 2 },
  beforeRestore: { params: 2 },
  afterRestore: { params: 2 },
  beforeUpdate: { params: 2 },
  afterUpdate: { params: 2 },
  beforeSave: { params: 2, proxies: ['beforeUpdate', 'beforeCreate'] },
  afterSave: { params: 2, proxies: ['afterUpdate', 'afterCreate'] },
  beforeUpsert: { params: 2 },
  afterUpsert: { params: 2 },
  beforeBulkCreate: { params: 2 },
  afterBulkCreate: { params: 2 },
  beforeBulkDestroy: { params: 1 },
  afterBulkDestroy: { params: 1 },
  beforeBulkRestore: { params: 1 },
  afterBulkRestore: { params: 1 },
  beforeBulkUpdate: { params: 1 },
  afterBulkUpdate: { params: 1 },
  beforeFind: { params: 1 },
  beforeFindAfterExpandIncludeAll: { params: 1 },
  beforeFindAfterOptions: { params: 1 },
  afterFind: { params: 2 },
  beforeCount: { params: 1 },
  beforeDefine: { params: 2, sync: true, noModel: true },
  afterDefine: { params: 1, sync: true, noModel: true },
  beforeInit: { params: 2, sync: true, noModel: true },
  afterInit: { params: 1, sync: true, noModel: true },
  beforeAssociate: { params: 2, sync: true },
  afterAssociate: { params: 2, sync: true },
  beforeConnect: { params: 1, noModel: true },
  afterConnect: { params: 2, noModel: true },
  beforeDisconnect: { params: 1, noModel: true },
  afterDisconnect: { params: 1, noModel: true },
  beforeSync: { params: 1 },
  afterSync: { params: 1 },
  beforeBulkSync: { params: 1 },
  afterBulkSync: { params: 1 },
  beforeQuery: { params: 2 },
  afterQuery: { params: 2 }
};
exports.hooks = hookTypes;


/**
 * get array of current hook and its proxies combined
 *
 * @param {string} hookType any hook type @see {@link hookTypes}
 *
 * @private
 */
const getProxiedHooks = hookType =>
  hookTypes[hookType].proxies
    ? hookTypes[hookType].proxies.concat(hookType)
    : [hookType]
;

function getHooks(hooked, hookType) {
  return (hooked.options.hooks || {})[hookType] || [];
}

const Hooks = {
  /**
   * Process user supplied hooks definition
   *
   * @param {object} hooks hooks definition
   *
   * @private
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  _setupHooks(hooks) {
    this.options.hooks = {};
    _.map(hooks || {}, (hooksArray, hookName) => {
      if (!Array.isArray(hooksArray)) hooksArray = [hooksArray];
      hooksArray.forEach(hookFn => this.addHook(hookName, hookFn));
    });
  },

  async runHooks(hooks, ...hookArgs) {
    if (!hooks) throw new Error('runHooks requires at least 1 argument');

    let hookType;

    if (typeof hooks === 'string') {
      hookType = hooks;
      hooks = getHooks(this, hookType);

      if (this.sequelize) {
        hooks = hooks.concat(getHooks(this.sequelize, hookType));
      }
    }

    if (!Array.isArray(hooks)) {
      hooks = [hooks];
    }

    // synchronous hooks
    if (hookTypes[hookType] && hookTypes[hookType].sync) {
      for (let hook of hooks) {
        if (typeof hook === 'object') {
          hook = hook.fn;
        }

        debug(`running hook(sync) ${hookType}`);
        hook.apply(this, hookArgs);
      }
      return;
    }

    // asynchronous hooks (default)
    for (let hook of hooks) {
      if (typeof hook === 'object') {
        hook = hook.fn;
      }

      debug(`running hook ${hookType}`);
      await hook.apply(this, hookArgs);
    }
  },

  /**
   * Add a hook to the model
   *
   * @param {string}          hookType hook name @see {@link hookTypes}
   * @param {string|Function} [name] Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.
   * @param {Function}        fn The hook function
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  addHook(hookType, name, fn) {
    if (typeof name === 'function') {
      fn = name;
      name = null;
    }

    debug(`adding hook ${hookType}`);
    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    hookType.forEach(type => {
      const hooks = getHooks(this, type);
      hooks.push(name ? { name, fn } : fn);
      this.options.hooks[type] = hooks;
    });

    return this;
  },

  /**
   * Remove hook from the model
   *
   * @param {string} hookType @see {@link hookTypes}
   * @param {string|Function} name name of hook or function reference which was attached
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  removeHook(hookType, name) {
    const isReference = typeof name === 'function' ? true : false;

    if (!this.hasHook(hookType)) {
      return this;
    }

    debug(`removing hook ${hookType}`);

    // check for proxies, add them too
    hookType = getProxiedHooks(hookType);

    for (const type of hookType) {
      this.options.hooks[type] = this.options.hooks[type].filter(hook => {
        if (isReference && typeof hook === 'function') {
          return hook !== name; // check if same method
        }
        if (!isReference && typeof hook === 'object') {
          return hook.name !== name;
        }
        return true;
      });
    }

    return this;
  },

  /**
   * Check whether the mode has any hooks of this type
   *
   * @param {string} hookType @see {@link hookTypes}
   *
   * @alias hasHooks
   *
   * @memberof Sequelize
   * @memberof Sequelize.Model
   */
  hasHook(hookType) {
    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;
  }
};
Hooks.hasHooks = Hooks.hasHook;


function applyTo(target, isModel = false) {
  _.mixin(target, Hooks);

  for (const hook of Object.keys(hookTypes)) {
    if (isModel && hookTypes[hook].noModel) {
      continue;
    }
    target[hook] = function(name, callback) {
      return this.addHook(hook, name, callback);
    };
  }
}
exports.applyTo = applyTo;

/**
 * A hook that is run before validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after validation
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterValidate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run when validation fails
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options, error. Error is the
 * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.
 * @name validationFailed
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name afterCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeSave
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeUpsert
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after upserting
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the result of upsert(), options
 * @name afterUpsert
 * @memberof Sequelize.Model
 */

/**
  * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with attributes, options
  * @name afterSave
  * @memberof Sequelize.Model
  */

/**
 * A hook that is run before destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name beforeRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 *
 * @name afterRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name beforeUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating a single instance
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance, options
 * @name afterUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name beforeBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after creating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instances, options
 * @name afterBulkCreate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after destroying instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkDestroy
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name beforeBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after restoring instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 *
 * @name afterBulkRestore
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after updating instances in bulk
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name afterBulkUpdate
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterExpandIncludeAll
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a find (select) query, after all option parsing is complete
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeFindAfterOptions
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run after a find (select) query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with instance(s), options
 * @name afterFind
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a count query
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options
 * @name beforeCount
 * @memberof Sequelize.Model
 */

/**
 * A hook that is run before a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with attributes, options
 * @name beforeDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run after a define call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with factory
 * @name afterDefine
 * @memberof Sequelize
 */

/**
 * A hook that is run before Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config, options
 * @name beforeInit
 * @memberof Sequelize
 */

/**
 * A hook that is run after Sequelize() call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with sequelize
 * @name afterInit
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with config passed to connection
 * @name beforeConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is created
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object and the config passed to connection
 * @name afterConnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name beforeDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run after a connection is disconnected
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with the connection object
 * @name afterDisconnect
 * @memberof Sequelize
 */

/**
 * A hook that is run before Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name beforeSync
 * @memberof Sequelize
 */

/**
 * A hook that is run after Model.sync call
 *
 * @param {string}   name
 * @param {Function} fn   A callback function that is called with options passed to Model.sync
 * @name afterSync
 * @memberof Sequelize
 */

/**
  * A hook that is run before sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name beforeBulkSync
  * @memberof Sequelize
  */

/**
  * A hook that is run after sequelize.sync call
 *
  * @param {string}   name
  * @param {Function} fn   A callback function that is called with options passed to sequelize.sync
  * @name afterBulkSync
  * @memberof Sequelize
  */


/***/ }),

/***/ "./node_modules/sequelize/lib/index-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/index-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of index hints to be used in mysql for querying with index hints
 *
 * @property USE
 * @property FORCE
 * @property IGNORE
 */
const IndexHints = module.exports = { // eslint-disable-line
  USE: 'USE',
  FORCE: 'FORCE',
  IGNORE: 'IGNORE'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/instance-validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/instance-validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const sequelizeError = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const { promisify } = __webpack_require__(/*! util */ "util");

/**
 * Instance Validator.
 *
 * @param {Instance} modelInstance The model instance.
 * @param {object} options A dictionary with options.
 *
 * @private
 */
class InstanceValidator {
  constructor(modelInstance, options) {
    options = {
      // assign defined and default options
      hooks: true,
      ...options
    };

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } else {
      options.skip = options.skip || [];
    }

    this.options = options;

    this.modelInstance = modelInstance;

    /**
     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
     *
     * @name validator
     * @private
     */
    this.validator = validator;

    /**
     *  All errors will be stored here from the validations.
     *
     * @type {Array} Will contain keys that correspond to attributes which will
     *   be Arrays of Errors.
     * @private
     */
    this.errors = [];

    /**
     * @type {boolean} Indicates if validations are in progress
     * @private
     */
    this.inProgress = false;
  }

  /**
   * The main entry point for the Validation module, invoke to start the dance.
   *
   * @returns {Promise}
   * @private
   */
  async _validate() {
    if (this.inProgress) throw new Error('Validations already in progress.');

    this.inProgress = true;

    await Promise.all([
      this._perAttributeValidators(),
      this._customValidators()
    ]);

    if (this.errors.length) {
      throw new sequelizeError.ValidationError(null, this.errors);
    }
  }

  /**
   * Invoke the Validation sequence and run validation hooks if defined
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async validate() {
    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());
  }

  /**
   * Invoke the Validation sequence and run hooks
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   *
   * @returns {Promise}
   * @private
   */
  async _validateAndRunHooks() {
    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
    await runHooks('beforeValidate', this.modelInstance, this.options);

    try {
      await this._validate();
    } catch (error) {
      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);
      throw newError || error;
    }

    await runHooks('afterValidate', this.modelInstance, this.options);
    return this.modelInstance;
  }

  /**
   * Will run all the validators defined per attribute (built-in validators and custom validators)
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _perAttributeValidators() {
    // promisify all attribute invocations
    const validators = [];

    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
      if (this.options.skip.includes(field)) {
        return;
      }

      const value = this.modelInstance.dataValues[field];

      if (value instanceof Utils.SequelizeMethod) {
        return;
      }

      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
        // perform validations based on schema
        this._validateSchema(rawAttribute, field, value);
      }

      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));
      }
    });

    return await Promise.all(validators);
  }

  /**
   * Will run all the custom validators defined in the model's options.
   *
   * @returns {Promise<Array>}
   * @private
   */
  async _customValidators() {
    const validators = [];
    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {
      if (this.options.skip.includes(validatorType)) {
        return;
      }

      const valprom = this._invokeCustomValidator(validator, validatorType)
        // errors are handled in settling, stub this
        .catch(() => {});

      validators.push(valprom);
    });

    return await Promise.all(validators);
  }

  /**
   * Validate a single attribute with all the defined built-in validators and custom validators.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {string} field The field name.
   * @param {boolean} allowNull Whether or not the schema allows null values
   *
   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.
   */
  async _singleAttrValidate(value, field, allowNull) {
    // If value is null and allowNull is false, no validators should run (see #9143)
    if ((value === null || value === undefined) && !allowNull) {
      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.
      return;
    }

    // Promisify each validator
    const validators = [];
    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {

      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {
        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
        if (typeof test === 'object' && test !== null && test.msg) {
          test = {
            msg: test.msg
          };
        } else if (test === true) {
          test = {};
        }
      }

      // Custom validators should always run, except if value is null and allowNull is false (see #9143)
      if (typeof test === 'function') {
        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));
        return;
      }

      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).
      if (value === null || value === undefined) {
        return;
      }

      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);
      // errors are handled in settling, stub this
      validatorPromise.catch(() => {});
      validators.push(validatorPromise);
    });

    return Promise
      .all(validators.map(validator => validator.catch(rejection => {
        const isBuiltIn = !!rejection.validatorName;
        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
      })));
  }

  /**
   * Prepare and invoke a custom validator.
   *
   * @private
   *
   * @param {Function} validator The custom validator.
   * @param {string} validatorType the custom validator type (name).
   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute
   * @param {*} optValue value for attribute
   * @param {string} optField field for attribute
   *
   * @returns {Promise} A promise.
   */
  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {
    let isAsync = false;

    const validatorArity = validator.length;
    // check if validator is async and requires a callback
    let asyncArity = 1;
    let errorKey = validatorType;
    let invokeArgs;
    if (optAttrDefined) {
      asyncArity = 2;
      invokeArgs = optValue;
      errorKey = optField;
    }
    if (validatorArity === asyncArity) {
      isAsync = true;
    }

    if (isAsync) {
      try {
        if (optAttrDefined) {
          return await promisify(validator.bind(this.modelInstance, invokeArgs))();
        }
        return await promisify(validator.bind(this.modelInstance))();
      } catch (e) {
        return this._pushError(false, errorKey, e, optValue, validatorType);
      }
    }

    try {
      return await validator.call(this.modelInstance, invokeArgs);
    } catch (e) {
      return this._pushError(false, errorKey, e, optValue, validatorType);
    }
  }

  /**
   * Prepare and invoke a build-in validator.
   *
   * @private
   *
   * @param {*} value Anything.
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated
   *
   * @returns {object} An object with specific keys to invoke the validator.
   */
  async _invokeBuiltinValidator(value, test, validatorType, field) {
    // Cast value as string to pass new Validator.js string requirement
    const valueString = String(value);
    // check if Validator knows that kind of validation test
    if (typeof validator[validatorType] !== 'function') {
      throw new Error(`Invalid validator function: ${validatorType}`);
    }

    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

    if (!validator[validatorType](valueString, ...validatorArgs)) {
      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });
    }
  }

  /**
   * Will extract arguments for the validator.
   *
   * @param {*} test The test case.
   * @param {string} validatorType One of known to Sequelize validators.
   * @param {string} field The field that is being validated.
   *
   * @private
   */
  _extractValidatorArgs(test, validatorType, field) {
    let validatorArgs = test.args || test;
    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

    if (!Array.isArray(validatorArgs)) {
      if (validatorType === 'isImmutable') {
        validatorArgs = [validatorArgs, field, this.modelInstance];
      } else if (isLocalizedValidator || validatorType === 'isIP') {
        validatorArgs = [];
      } else {
        validatorArgs = [validatorArgs];
      }
    } else {
      validatorArgs = validatorArgs.slice(0);
    }
    return validatorArgs;
  }

  /**
   * Will validate a single field against its schema definition (isnull).
   *
   * @param {object} rawAttribute As defined in the Schema.
   * @param {string} field The field name.
   * @param {*} value anything.
   *
   * @private
   */
  _validateSchema(rawAttribute, field, value) {
    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);
      if (!association || !this.modelInstance.get(association.associationAccessor)) {
        const validators = this.modelInstance.validators[field];
        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

        this.errors.push(new sequelizeError.ValidationErrorItem(
          errMsg,
          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'is_null'
        ));
      }
    }

    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
        this.errors.push(new sequelizeError.ValidationErrorItem(
          `${field} cannot be an array or an object`,
          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'not_a_string'
        ));
      }
    }
  }

  /**
   * Signs all errors retaining the original.
   *
   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.
   * @param {string}        errorKey    - name of invalid attribute.
   * @param {Error|string}  rawError    - The original error.
   * @param {string|number} value       - The data that triggered the error.
   * @param {string}        fnName      - Name of the validator, if any
   * @param {Array}         fnArgs      - Arguments for the validator [function], if any
   *
   * @private
   */
  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
    const message = rawError.message || rawError || 'Validation error';
    const error = new sequelizeError.ValidationErrorItem(
      message,
      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey,
      value,
      this.modelInstance,
      fnName,
      isBuiltin ? fnName : undefined,
      isBuiltin ? fnArgs : undefined
    );

    error[InstanceValidator.RAW_KEY_NAME] = rawError;

    this.errors.push(error);
  }
}
/**
 * The error key for arguments as passed by custom validators
 *
 * @type {string}
 * @private
 */
InstanceValidator.RAW_KEY_NAME = 'original';

module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator;


/***/ }),

/***/ "./node_modules/sequelize/lib/model-manager.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize/lib/model-manager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Toposort = __webpack_require__(/*! toposort-class */ "./node_modules/toposort-class/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

class ModelManager {
  constructor(sequelize) {
    this.models = [];
    this.sequelize = sequelize;
  }

  addModel(model) {
    this.models.push(model);
    this.sequelize.models[model.name] = model;

    return model;
  }

  removeModel(modelToRemove) {
    this.models = this.models.filter(model => model.name !== modelToRemove.name);

    delete this.sequelize.models[modelToRemove.name];
  }

  getModel(against, options) {
    options = _.defaults(options || {}, {
      attribute: 'name'
    });

    return this.models.find(model => model[options.attribute] === against);
  }

  get all() {
    return this.models;
  }

  /**
   * Iterate over Models in an order suitable for e.g. creating tables.
   * Will take foreign key constraints into account so that dependencies are visited before dependents.
   *
   * @param {Function} iterator method to execute on each model
   * @param {object} [options] iterator options
   * @private
   */
  forEachModel(iterator, options) {
    const models = {};
    const sorter = new Toposort();
    let sorted;
    let dep;

    options = _.defaults(options || {}, {
      reverse: true
    });

    for (const model of this.models) {
      let deps = [];
      let tableName = model.getTableName();

      if (_.isObject(tableName)) {
        tableName = `${tableName.schema}.${tableName.tableName}`;
      }

      models[tableName] = model;

      for (const attrName in model.rawAttributes) {
        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
          const attribute = model.rawAttributes[attrName];

          if (attribute.references) {
            dep = attribute.references.model;

            if (_.isObject(dep)) {
              dep = `${dep.schema}.${dep.tableName}`;
            }

            deps.push(dep);
          }
        }
      }

      deps = deps.filter(dep => tableName !== dep);

      sorter.add(tableName, deps);
    }

    sorted = sorter.sort();
    if (options.reverse) {
      sorted = sorted.reverse();
    }
    for (const name of sorted) {
      iterator(models[name], name);
    }
  }
}

module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports.default = ModelManager;


/***/ }),

/***/ "./node_modules/sequelize/lib/model.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Dottie = __webpack_require__(/*! dottie */ "./node_modules/dottie/dottie.js");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");
const BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ "./node_modules/sequelize/lib/associations/belongs-to.js");
const BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ "./node_modules/sequelize/lib/associations/belongs-to-many.js");
const InstanceValidator = __webpack_require__(/*! ./instance-validator */ "./node_modules/sequelize/lib/instance-validator.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Association = __webpack_require__(/*! ./associations/base */ "./node_modules/sequelize/lib/associations/base.js");
const HasMany = __webpack_require__(/*! ./associations/has-many */ "./node_modules/sequelize/lib/associations/has-many.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const associationsMixin = __webpack_require__(/*! ./associations/mixin */ "./node_modules/sequelize/lib/associations/mixin.js");
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");


// This list will quickly become dated, but failing to maintain this list just means
// we won't throw a warning when we should. At least most common cases will forever be covered
// so we stop throwing erroneous warnings when we shouldn't.
const validQueryKeywords = new Set(['where', 'attributes', 'paranoid', 'include', 'order', 'limit', 'offset',
  'transaction', 'lock', 'raw', 'logging', 'benchmark', 'having', 'searchPath', 'rejectOnEmpty', 'plain',
  'scope', 'group', 'through', 'defaults', 'distinct', 'primary', 'exception', 'type', 'hooks', 'force',
  'name']);

// List of attributes that should not be implicitly passed into subqueries/includes.
const nonCascadingOptions = ['include', 'attributes', 'originalAttributes', 'order', 'where', 'limit', 'offset', 'plain', 'group', 'having'];

/**
 * A Model represents a table in the database. Instances of this class represent a database row.
 *
 * Model instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.
 * By default, the values from dataValues can also be accessed directly from the Instance, that is:
 * ```js
 * instance.field
 * // is the same as
 * instance.get('field')
 * // is the same as
 * instance.getDataValue('field')
 * ```
 * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.
 * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.
 *
 * @see
   * {@link Sequelize#define} for more information about getters and setters
 * @mixes Hooks
 */
class Model {
  static get queryInterface() {
    return this.sequelize.getQueryInterface();
  }

  static get queryGenerator() {
    return this.queryInterface.queryGenerator;
  }

  /**
   * A reference to the sequelize instance
   *
   * @see
   * {@link Sequelize}
   *
   * @property sequelize
   *
   * @returns {Sequelize}
   */
  get sequelize() {
    return this.constructor.sequelize;
  }

  /**
   * Builds a new model instance.
   *
   * @param {object}  [values={}] an object of key value pairs
   * @param {object}  [options] instance construction options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this a new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   */
  constructor(values = {}, options = {}) {
    options = {
      isNewRecord: true,
      _schema: this.constructor._schema,
      _schemaDelimiter: this.constructor._schemaDelimiter,
      ...options
    };

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    if (!options.includeValidated) {
      this.constructor._conformIncludes(options, this.constructor);
      if (options.include) {
        this.constructor._expandIncludeAll(options);
        this.constructor._validateIncludedElements(options);
      }
    }

    this.dataValues = {};
    this._previousDataValues = {};
    this._changed = new Set();
    this._options = options || {};

    /**
     * Returns true if this instance has not yet been persisted to the database
     *
     * @property isNewRecord
     * @returns {boolean}
     */
    this.isNewRecord = options.isNewRecord;

    this._initValues(values, options);
  }

  _initValues(values, options) {
    let defaults;
    let key;

    values = { ...values };

    if (options.isNewRecord) {
      defaults = {};

      if (this.constructor._hasDefaultValues) {
        defaults = _.mapValues(this.constructor._defaultValues, valueFn => {
          const value = valueFn();
          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);
        });
      }

      // set id to null if not passed as value, a newly created dao has no id
      // removing this breaks bulkCreate
      // do after default values since it might have UUID as a default value
      if (this.constructor.primaryKeyAttributes.length) {
        this.constructor.primaryKeyAttributes.forEach(primaryKeyAttribute => {
          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {
            defaults[primaryKeyAttribute] = null;
          }
        });
      }

      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {
        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.createdAt];
      }

      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {
        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.updatedAt];
      }

      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {
        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);
        delete defaults[this.constructor._timestampAttributes.deletedAt];
      }

      for (key in defaults) {
        if (values[key] === undefined) {
          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });
          delete values[key];
        }
      }
    }

    this.set(values, options);
  }

  // validateIncludedElements should have been called before this method
  static _paranoidClause(model, options = {}) {
    // Apply on each include
    // This should be handled before handling where conditions because of logic with returns
    // otherwise this code will never run on includes of a already conditionable where
    if (options.include) {
      for (const include of options.include) {
        this._paranoidClause(include.model, include);
      }
    }

    // apply paranoid when groupedLimit is used
    if (_.get(options, 'groupedLimit.on.options.paranoid')) {
      const throughModel = _.get(options, 'groupedLimit.on.through.model');
      if (throughModel) {
        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);
      }
    }

    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {
      // This model is not paranoid, nothing to do here;
      return options;
    }

    const deletedAtCol = model._timestampAttributes.deletedAt;
    const deletedAtAttribute = model.rawAttributes[deletedAtCol];
    const deletedAtObject = {};

    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    deletedAtDefaultValue = deletedAtDefaultValue || {
      [Op.eq]: null
    };

    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;

    if (Utils.isWhereEmpty(options.where)) {
      options.where = deletedAtObject;
    } else {
      options.where = { [Op.and]: [deletedAtObject, options.where] };
    }

    return options;
  }

  static _addDefaultAttributes() {
    const tail = {};
    let head = {};

    // Add id if no primary key was manually added to definition
    // Can't use this.primaryKeys here, since this function is called before PKs are identified
    if (!_.some(this.rawAttributes, 'primaryKey')) {
      if ('id' in this.rawAttributes) {
        // Something is fishy here!
        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);
      }

      head = {
        id: {
          type: new DataTypes.INTEGER(),
          allowNull: false,
          primaryKey: true,
          autoIncrement: true,
          _autoGenerated: true
        }
      };
    }

    if (this._timestampAttributes.createdAt) {
      tail[this._timestampAttributes.createdAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.updatedAt) {
      tail[this._timestampAttributes.updatedAt] = {
        type: DataTypes.DATE,
        allowNull: false,
        _autoGenerated: true
      };
    }

    if (this._timestampAttributes.deletedAt) {
      tail[this._timestampAttributes.deletedAt] = {
        type: DataTypes.DATE,
        _autoGenerated: true
      };
    }

    if (this._versionAttribute) {
      tail[this._versionAttribute] = {
        type: DataTypes.INTEGER,
        allowNull: false,
        defaultValue: 0,
        _autoGenerated: true
      };
    }

    const newRawAttributes = {
      ...head,
      ...this.rawAttributes
    };
    _.each(tail, (value, attr) => {
      if (newRawAttributes[attr] === undefined) {
        newRawAttributes[attr] = value;
      }
    });

    this.rawAttributes = newRawAttributes;

    if (!Object.keys(this.primaryKeys).length) {
      this.primaryKeys.id = this.rawAttributes.id;
    }
  }

  static _findAutoIncrementAttribute() {
    this.autoIncrementAttribute = null;

    for (const name in this.rawAttributes) {
      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {
        const definition = this.rawAttributes[name];
        if (definition && definition.autoIncrement) {
          if (this.autoIncrementAttribute) {
            throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');
          }
          this.autoIncrementAttribute = name;
        }
      }
    }
  }

  static _conformIncludes(options, self) {
    if (!options.include) return;

    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
      options.include = [options.include];
    } else if (!options.include.length) {
      delete options.include;
      return;
    }

    // convert all included elements to { model: Model } form
    options.include = options.include.map(include => this._conformInclude(include, self));
  }

  static _transformStringAssociation(include, self) {
    if (self && typeof include === 'string') {
      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {
        throw new Error(`Association with alias "${include}" does not exist on ${self.name}`);
      }
      return self.associations[include];
    }
    return include;
  }

  static _conformInclude(include, self) {
    if (include) {
      let model;

      if (include._pseudo) return include;

      include = this._transformStringAssociation(include, self);

      if (include instanceof Association) {
        if (self && include.target.name === self.name) {
          model = include.source;
        } else {
          model = include.target;
        }

        return { model, association: include, as: include.as };
      }

      if (include.prototype && include.prototype instanceof Model) {
        return { model: include };
      }

      if (_.isPlainObject(include)) {
        if (include.association) {
          include.association = this._transformStringAssociation(include.association, self);

          if (self && include.association.target.name === self.name) {
            model = include.association.source;
          } else {
            model = include.association.target;
          }

          if (!include.model) include.model = model;
          if (!include.as) include.as = include.association.as;

          this._conformIncludes(include, model);
          return include;
        }

        if (include.model) {
          this._conformIncludes(include, include.model);
          return include;
        }

        if (include.all) {
          this._conformIncludes(include);
          return include;
        }
      }
    }

    throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');
  }

  static _expandIncludeAllElement(includes, include) {
    // check 'all' attribute provided is valid
    let all = include.all;
    delete include.all;

    if (all !== true) {
      if (!Array.isArray(all)) {
        all = [all];
      }

      const validTypes = {
        BelongsTo: true,
        HasOne: true,
        HasMany: true,
        One: ['BelongsTo', 'HasOne'],
        Has: ['HasOne', 'HasMany'],
        Many: ['HasMany']
      };

      for (let i = 0; i < all.length; i++) {
        const type = all[i];
        if (type === 'All') {
          all = true;
          break;
        }

        const types = validTypes[type];
        if (!types) {
          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);
        }

        if (types !== true) {
          // replace type placeholder e.g. 'One' with its constituent types e.g. 'HasOne', 'BelongsTo'
          all.splice(i, 1);
          i--;
          for (let j = 0; j < types.length; j++) {
            if (!all.includes(types[j])) {
              all.unshift(types[j]);
              i++;
            }
          }
        }
      }
    }

    // add all associations of types specified to includes
    const nested = include.nested;
    if (nested) {
      delete include.nested;

      if (!include.include) {
        include.include = [];
      } else if (!Array.isArray(include.include)) {
        include.include = [include.include];
      }
    }

    const used = [];
    (function addAllIncludes(parent, includes) {
      _.forEach(parent.associations, association => {
        if (all !== true && !all.includes(association.associationType)) {
          return;
        }

        // check if model already included, and skip if so
        const model = association.target;
        const as = association.options.as;

        const predicate = { model };
        if (as) {
          // We only add 'as' to the predicate if it actually exists
          predicate.as = as;
        }

        if (_.some(includes, predicate)) {
          return;
        }

        // skip if recursing over a model already nested
        if (nested && used.includes(model)) {
          return;
        }
        used.push(parent);

        // include this model
        const thisInclude = Utils.cloneDeep(include);
        thisInclude.model = model;
        if (as) {
          thisInclude.as = as;
        }
        includes.push(thisInclude);

        // run recursively if nested
        if (nested) {
          addAllIncludes(model, thisInclude.include);
          if (thisInclude.include.length === 0) delete thisInclude.include;
        }
      });
      used.pop();
    })(this, includes);
  }

  static _validateIncludedElements(options, tableNames) {
    if (!options.model) options.model = this;

    tableNames = tableNames || {};
    options.includeNames = [];
    options.includeMap = {};

    /* Legacy */
    options.hasSingleAssociation = false;
    options.hasMultiAssociation = false;

    if (!options.parent) {
      options.topModel = options.model;
      options.topLimit = options.limit;
    }

    options.include = options.include.map(include => {
      include = this._conformInclude(include);
      include.parent = options;
      include.topLimit = options.topLimit;

      this._validateIncludedElement.call(options.model, include, tableNames, options);

      if (include.duplicating === undefined) {
        include.duplicating = include.association.isMultiAssociation;
      }

      include.hasDuplicating = include.hasDuplicating || include.duplicating;
      include.hasRequired = include.hasRequired || include.required;

      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;
      options.hasRequired = options.hasRequired || include.required;

      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;
      return include;
    });

    for (const include of options.include) {
      include.hasParentWhere = options.hasParentWhere || !!options.where;
      include.hasParentRequired = options.hasParentRequired || !!options.required;

      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {
        if (include.duplicating) {
          include.subQuery = false;
          include.subQueryFilter = include.hasRequired;
        } else {
          include.subQuery = include.hasRequired;
          include.subQueryFilter = false;
        }
      } else {
        include.subQuery = include.subQuery || false;
        if (include.duplicating) {
          include.subQueryFilter = include.subQuery;
          include.subQuery = false;
        } else {
          include.subQueryFilter = false;
          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;
        }
      }

      options.includeMap[include.as] = include;
      options.includeNames.push(include.as);

      // Set top level options
      if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {
        if (include.subQuery) {
          options.subQuery = include.subQuery;
        } else if (include.hasDuplicating) {
          options.subQuery = true;
        }
      }

      /* Legacy */
      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;
      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;

      if (include.association.isMultiAssociation || include.hasMultiAssociation) {
        options.hasMultiAssociation = true;
      }
      if (include.association.isSingleAssociation || include.hasSingleAssociation) {
        options.hasSingleAssociation = true;
      }
    }

    if (options.topModel === options.model && options.subQuery === undefined) {
      options.subQuery = false;
    }
    return options;
  }

  static _validateIncludedElement(include, tableNames, options) {
    tableNames[include.model.getTableName()] = true;

    if (include.attributes && !options.raw) {
      include.model._expandAttributes(include);

      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);

      include = Utils.mapFinderOptions(include, include.model);

      if (include.attributes.length) {
        _.each(include.model.primaryKeys, (attr, key) => {
          // Include the primary key if it's not already included - take into account that the pk might be aliased (due to a .field prop)
          if (!include.attributes.some(includeAttr => {
            if (attr.field !== key) {
              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;
            }
            return includeAttr === key;
          })) {
            include.attributes.unshift(key);
          }
        });
      }
    } else {
      include = Utils.mapFinderOptions(include, include.model);
    }

    // pseudo include just needed the attribute logic, return
    if (include._pseudo) {
      if (!include.attributes) {
        include.attributes = Object.keys(include.model.tableAttributes);
      }
      return Utils.mapFinderOptions(include, include.model);
    }

    // check if the current Model is actually associated with the passed Model - or it's a pseudo include
    const association = include.association || this._getIncludedAssociation(include.model, include.as);

    include.association = association;
    include.as = association.as;

    // If through, we create a pseudo child include, to ease our parsing later on
    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {
      if (!include.include) include.include = [];
      const through = include.association.through;

      include.through = _.defaults(include.through || {}, {
        model: through.model,
        as: through.model.name,
        association: {
          isSingleAssociation: true
        },
        _pseudo: true,
        parent: include
      });


      if (through.scope) {
        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;
      }

      include.include.push(include.through);
      tableNames[through.tableName] = true;
    }

    // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source
    let model;
    if (include.model.scoped === true) {
      // If the passed model is already scoped, keep that
      model = include.model;
    } else {
      // Otherwise use the model that was originally passed to the association
      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;
    }

    model._injectScope(include);

    // This check should happen after injecting the scope, since the scope may contain a .attributes
    if (!include.attributes) {
      include.attributes = Object.keys(include.model.tableAttributes);
    }

    include = Utils.mapFinderOptions(include, include.model);

    if (include.required === undefined) {
      include.required = !!include.where;
    }

    if (include.association.scope) {
      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;
    }

    if (include.limit && include.separate === undefined) {
      include.separate = true;
    }

    if (include.separate === true) {
      if (!(include.association instanceof HasMany)) {
        throw new Error('Only HasMany associations support include.separate');
      }

      include.duplicating = false;

      if (
        options.attributes
        && options.attributes.length
        && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)
      ) {
        options.attributes.push(association.sourceKey);
      }

      if (
        include.attributes
        && include.attributes.length
        && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)
      ) {
        include.attributes.push(association.foreignKey);
      }
    }

    // Validate child includes
    if (Object.prototype.hasOwnProperty.call(include, 'include')) {
      this._validateIncludedElements.call(include.model, include, tableNames);
    }

    return include;
  }

  static _getIncludedAssociation(targetModel, targetAlias) {
    const associations = this.getAssociations(targetModel);
    let association = null;
    if (associations.length === 0) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);
    }
    if (associations.length === 1) {
      association = this.getAssociationForAlias(targetModel, targetAlias);
      if (association) {
        return association;
      }
      if (targetAlias) {
        const existingAliases = this.getAssociations(targetModel).map(association => association.as);
        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
          `You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(', ')}).`);
      }
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. ` +
        'You must use the \'as\' keyword to specify the alias within your include statement.');
    }
    association = this.getAssociationForAlias(targetModel, targetAlias);
    if (!association) {
      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. ` +
        'To identify the correct association, you must use the \'as\' keyword to specify the alias of the association you want to include.');
    }
    return association;
  }


  static _expandIncludeAll(options) {
    const includes = options.include;
    if (!includes) {
      return;
    }

    for (let index = 0; index < includes.length; index++) {
      const include = includes[index];

      if (include.all) {
        includes.splice(index, 1);
        index--;

        this._expandIncludeAllElement(includes, include);
      }
    }

    includes.forEach(include => {
      this._expandIncludeAll.call(include.model, include);
    });
  }

  static _conformIndex(index) {
    if (!index.fields) {
      throw new Error('Missing "fields" property for index definition');
    }

    index = _.defaults(index, {
      type: '',
      parser: null
    });

    if (index.type && index.type.toLowerCase() === 'unique') {
      index.unique = true;
      delete index.type;
    }

    return index;
  }


  static _uniqIncludes(options) {
    if (!options.include) return;

    options.include = _(options.include)
      .groupBy(include => `${include.model && include.model.name}-${include.as}`)
      .map(includes => this._assignOptions(...includes))
      .value();
  }

  static _baseMerge(...args) {
    _.assignWith(...args);
    this._conformIncludes(args[0], this);
    this._uniqIncludes(args[0]);
    return args[0];
  }

  static _mergeFunction(objValue, srcValue, key) {
    if (Array.isArray(objValue) && Array.isArray(srcValue)) {
      return _.union(objValue, srcValue);
    }
    if (key === 'where' || key === 'having') {
      if (srcValue instanceof Utils.SequelizeMethod) {
        srcValue = { [Op.and]: srcValue };
      }
      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
        return Object.assign(objValue, srcValue);
      }
    } else if (key === 'attributes' && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
      return _.assignWith(objValue, srcValue, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
          return _.union(objValue, srcValue);
        }
      });
    }
    // If we have a possible object/array to clone, we try it.
    // Otherwise, we return the original value when it's not undefined,
    // or the resulting object in that case.
    if (srcValue) {
      return Utils.cloneDeep(srcValue, true);
    }
    return srcValue === undefined ? objValue : srcValue;
  }

  static _assignOptions(...args) {
    return this._baseMerge(...args, this._mergeFunction);
  }

  static _defaultsOptions(target, opts) {
    return this._baseMerge(target, opts, (srcValue, objValue, key) => {
      return this._mergeFunction(objValue, srcValue, key);
    });
  }

  /**
   * Initialize a model, representing a table in the DB, with attributes and options.
   *
   * The table columns are defined by the hash that is given as the first argument.
   * Each attribute of the hash represents a column.
   *
   * @example
   * Project.init({
   *   columnA: {
   *     type: Sequelize.BOOLEAN,
   *     validate: {
   *       is: ['[a-z]','i'],        // will only allow letters
   *       max: 23,                  // only allow values <= 23
   *       isIn: {
   *         args: [['en', 'zh']],
   *         msg: "Must be English or Chinese"
   *       }
   *     },
   *     field: 'column_a'
   *     // Other attributes here
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * }, {sequelize})
   *
   * sequelize.models.modelName // The model will now be available in models under the class name
   *
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @see
   * <a href="/master/manual/model-basics.html">Hooks</a> guide
   *
   * @see
   * <a href="/master/manual/validations-and-constraints.html"/>Validations & Constraints</a> guide
   *
   * @param {object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:
   * @param {string|DataTypes|object} attributes.column The description of a database column
   * @param {string|DataTypes}        attributes.column.type A string or a data type
   * @param {boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.
   * @param {any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)
   * @param {string|boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index
   * @param {boolean}                 [attributes.column.primaryKey=false] If true, this attribute will be marked as primary key
   * @param {string}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database
   * @param {boolean}                 [attributes.column.autoIncrement=false] If true, this column will be set to auto increment
   * @param {boolean}                 [attributes.column.autoIncrementIdentity=false] If true, combined with autoIncrement=true, will use Postgres `GENERATED BY DEFAULT AS IDENTITY` instead of `SERIAL`. Postgres 10+ only.
   * @param {string}                  [attributes.column.comment=null] Comment for this column
   * @param {string|Model}            [attributes.column.references=null] An object with reference configurations
   * @param {string|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string
   * @param {string}                  [attributes.column.references.key='id'] The column of the foreign table that this column references
   * @param {string}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {string}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION
   * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.
   * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.
   * @param {object}                  [attributes.column.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field and the instance itself as the `this` binding, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation; if it is async, the callback should be called with the error text.
   * @param {object}                  options These options are merged with the default define options provided to the Sequelize constructor
   * @param {object}                  options.sequelize Define the sequelize instance to attach to the new Model. Throw error if none is provided.
   * @param {string}                  [options.modelName] Set name of the model. By default its same as Class name.
   * @param {object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll
   * @param {object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them
   * @param {boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved
   * @param {boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.
   * @param {boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work
   * @param {boolean}                 [options.underscored=false] Add underscored field to all attributes, this covers user defined attributes, timestamps and foreign keys. Will not affect attributes with explicitly set `field` option
   * @param {boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized
   * @param {object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.
   * @param {string}                  [options.name.singular=Utils.singularize(modelName)] Singular name for model
   * @param {string}                  [options.name.plural=Utils.pluralize(modelName)] Plural name for model
   * @param {Array<object>}           [options.indexes] indexes definitions
   * @param {string}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated
   * @param {string}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`
   * @param {string}                  [options.indexes[].using] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.
   * @param {string}                  [options.indexes[].operator] Specify index operator.
   * @param {boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`
   * @param {boolean}                 [options.indexes[].concurrently=false] PostgresSQL will build the index without taking any write locks. Postgres only
   * @param {Array<string|object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)
   * @param {string|boolean}          [options.createdAt] Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.updatedAt] Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string|boolean}          [options.deletedAt] Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.
   * @param {string}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim
   * @param {string}                  [options.schema='public'] schema
   * @param {string}                  [options.engine] Specify engine for model's table
   * @param {string}                  [options.charset] Specify charset for model's table
   * @param {string}                  [options.comment] Specify comment for model's table
   * @param {string}                  [options.collate] Specify collation for model's table
   * @param {string}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.
   * @param {object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, beforeSave, afterDestroy, afterUpdate, afterBulkCreate, afterSave, afterBulkDestroy and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.
   * @param {object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.
   *
   * @returns {Model}
   */
  static init(attributes, options = {}) {
    if (!options.sequelize) {
      throw new Error('No Sequelize instance passed');
    }

    this.sequelize = options.sequelize;

    const globalOptions = this.sequelize.options;

    options = Utils.merge(_.cloneDeep(globalOptions.define), options);

    if (!options.modelName) {
      options.modelName = this.name;
    }

    options = Utils.merge({
      name: {
        plural: Utils.pluralize(options.modelName),
        singular: Utils.singularize(options.modelName)
      },
      indexes: [],
      omitNull: globalOptions.omitNull,
      schema: globalOptions.schema
    }, options);

    this.sequelize.runHooks('beforeDefine', attributes, options);

    if (options.modelName !== this.name) {
      Object.defineProperty(this, 'name', { value: options.modelName });
    }
    delete options.modelName;

    this.options = {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      ...options
    };

    // if you call "define" multiple times for the same modelName, do not clutter the factory
    if (this.sequelize.isDefined(this.name)) {
      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));
    }

    this.associations = {};
    this._setupHooks(options.hooks);

    this.underscored = this.options.underscored;

    if (!this.options.tableName) {
      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);
    } else {
      this.tableName = this.options.tableName;
    }

    this._schema = this.options.schema;
    this._schemaDelimiter = this.options.schemaDelimiter;

    // error check options
    _.each(options.validate, (validator, validatorType) => {
      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {
        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);
      }

      if (typeof validator !== 'function') {
        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);
      }
    });

    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {
      attribute = this.sequelize.normalizeAttribute(attribute);

      if (attribute.type === undefined) {
        throw new Error(`Unrecognized datatype for attribute "${this.name}.${name}"`);
      }

      if (attribute.allowNull !== false && _.get(attribute, 'validate.notNull')) {
        throw new Error(`Invalid definition for "${this.name}.${name}", "notNull" validator is only allowed with "allowNull:false"`);
      }

      if (_.get(attribute, 'references.model.prototype') instanceof Model) {
        attribute.references.model = attribute.references.model.getTableName();
      }

      return attribute;
    });

    const tableName = this.getTableName();
    this._indexes = this.options.indexes
      .map(index => Utils.nameIndex(this._conformIndex(index), tableName));

    this.primaryKeys = {};
    this._readOnlyAttributes = new Set();
    this._timestampAttributes = {};

    // setup names of timestamp attributes
    if (this.options.timestamps) {
      for (const key of ['createdAt', 'updatedAt', 'deletedAt']) {
        if (!['undefined', 'string', 'boolean'].includes(typeof this.options[key])) {
          throw new Error(`Value for "${key}" option must be a string or a boolean, got ${typeof this.options[key]}`);
        }
        if (this.options[key] === '') {
          throw new Error(`Value for "${key}" option cannot be an empty string`);
        }
      }

      if (this.options.createdAt !== false) {
        this._timestampAttributes.createdAt =
          typeof this.options.createdAt === 'string' ? this.options.createdAt : 'createdAt';
        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);
      }
      if (this.options.updatedAt !== false) {
        this._timestampAttributes.updatedAt =
          typeof this.options.updatedAt === 'string' ? this.options.updatedAt : 'updatedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);
      }
      if (this.options.paranoid && this.options.deletedAt !== false) {
        this._timestampAttributes.deletedAt =
          typeof this.options.deletedAt === 'string' ? this.options.deletedAt : 'deletedAt';
        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);
      }
    }

    // setup name for version attribute
    if (this.options.version) {
      this._versionAttribute = typeof this.options.version === 'string' ? this.options.version : 'version';
      this._readOnlyAttributes.add(this._versionAttribute);
    }

    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;

    // Add head and tail default attributes (id, timestamps)
    this._addDefaultAttributes();
    this.refreshAttributes();
    this._findAutoIncrementAttribute();

    this._scope = this.options.defaultScope;
    this._scopeNames = ['defaultScope'];

    this.sequelize.modelManager.addModel(this);
    this.sequelize.runHooks('afterDefine', this);

    return this;
  }

  static refreshAttributes() {
    const attributeManipulation = {};

    this.prototype._customGetters = {};
    this.prototype._customSetters = {};

    ['get', 'set'].forEach(type => {
      const opt = `${type}terMethods`;
      const funcs = { ...this.options[opt] };
      const _custom = type === 'get' ? this.prototype._customGetters : this.prototype._customSetters;

      _.each(funcs, (method, attribute) => {
        _custom[attribute] = method;

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(this.rawAttributes, (options, attribute) => {
        if (Object.prototype.hasOwnProperty.call(options, type)) {
          _custom[attribute] = options[type];
        }

        if (type === 'get') {
          funcs[attribute] = function() {
            return this.get(attribute);
          };
        }
        if (type === 'set') {
          funcs[attribute] = function(value) {
            return this.set(attribute, value);
          };
        }
      });

      _.each(funcs, (fct, name) => {
        if (!attributeManipulation[name]) {
          attributeManipulation[name] = {
            configurable: true
          };
        }
        attributeManipulation[name][type] = fct;
      });
    });

    this._dataTypeChanges = {};
    this._dataTypeSanitizers = {};

    this._hasBooleanAttributes = false;
    this._hasDateAttributes = false;
    this._jsonAttributes = new Set();
    this._virtualAttributes = new Set();
    this._defaultValues = {};
    this.prototype.validators = {};

    this.fieldRawAttributesMap = {};

    this.primaryKeys = {};
    this.uniqueKeys = {};

    _.each(this.rawAttributes, (definition, name) => {
      definition.type = this.sequelize.normalizeDataType(definition.type);

      definition.Model = this;
      definition.fieldName = name;
      definition._modelAttribute = true;

      if (definition.field === undefined) {
        definition.field = Utils.underscoredIf(name, this.underscored);
      }

      if (definition.primaryKey === true) {
        this.primaryKeys[name] = definition;
      }

      this.fieldRawAttributesMap[definition.field] = definition;

      if (definition.type._sanitize) {
        this._dataTypeSanitizers[name] = definition.type._sanitize;
      }

      if (definition.type._isChanged) {
        this._dataTypeChanges[name] = definition.type._isChanged;
      }

      if (definition.type instanceof DataTypes.BOOLEAN) {
        this._hasBooleanAttributes = true;
      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {
        this._hasDateAttributes = true;
      } else if (definition.type instanceof DataTypes.JSON) {
        this._jsonAttributes.add(name);
      } else if (definition.type instanceof DataTypes.VIRTUAL) {
        this._virtualAttributes.add(name);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'defaultValue')) {
        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'unique') && definition.unique) {
        let idxName;
        if (
          typeof definition.unique === 'object' &&
          Object.prototype.hasOwnProperty.call(definition.unique, 'name')
        ) {
          idxName = definition.unique.name;
        } else if (typeof definition.unique === 'string') {
          idxName = definition.unique;
        } else {
          idxName = `${this.tableName}_${name}_unique`;
        }

        const idx = this.uniqueKeys[idxName] || { fields: [] };

        idx.fields.push(definition.field);
        idx.msg = idx.msg || definition.unique.msg || null;
        idx.name = idxName || false;
        idx.column = name;
        idx.customIndex = definition.unique !== true;

        this.uniqueKeys[idxName] = idx;
      }

      if (Object.prototype.hasOwnProperty.call(definition, 'validate')) {
        this.prototype.validators[name] = definition.validate;
      }

      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {
        this._indexes.push(
          Utils.nameIndex(
            this._conformIndex({
              fields: [definition.field || name],
              using: 'gin'
            }),
            this.getTableName()
          )
        );

        delete definition.index;
      }
    });

    // Create a map of field to attribute names
    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {
      if (key !== value.fieldName) {
        map[key] = value.fieldName;
      }
      return map;
    }, {});

    this._hasJsonAttributes = !!this._jsonAttributes.size;

    this._hasVirtualAttributes = !!this._virtualAttributes.size;

    this._hasDefaultValues = !_.isEmpty(this._defaultValues);

    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));

    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;
    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;

    for (const key of Object.keys(attributeManipulation)) {
      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {
        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);
        continue;
      }
      Object.defineProperty(this.prototype, key, attributeManipulation[key]);
    }

    this.prototype.rawAttributes = this.rawAttributes;
    this.prototype._isAttribute = key => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);

    // Primary key convenience constiables
    this.primaryKeyAttributes = Object.keys(this.primaryKeys);
    this.primaryKeyAttribute = this.primaryKeyAttributes[0];
    if (this.primaryKeyAttribute) {
      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
    }

    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;
    this._isPrimaryKey = key => this.primaryKeyAttributes.includes(key);
  }

  /**
   * Remove attribute from model definition
   *
   * @param {string} attribute name of attribute to remove
   */
  static removeAttribute(attribute) {
    delete this.rawAttributes[attribute];
    this.refreshAttributes();
  }

  /**
   * Sync this Model to the DB, that is create the table.
   *
   * @param {object} [options] sync options
   *
   * @see
   * {@link Sequelize#sync} for options
   *
   * @returns {Promise<Model>}
   */
  static async sync(options) {
    options = { ...this.options, ...options };
    options.hooks = options.hooks === undefined ? true : !!options.hooks;

    const attributes = this.tableAttributes;
    const rawAttributes = this.fieldRawAttributesMap;

    if (options.hooks) {
      await this.runHooks('beforeSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }

    const tableName = this.getTableName(options);

    await this.queryInterface.createTable(tableName, attributes, options, this);

    if (options.alter) {
      const tableInfos = await Promise.all([
        this.queryInterface.describeTable(tableName, options),
        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)
      ]);
      const columns = tableInfos[0];
      // Use for alter foreign keys
      const foreignKeyReferences = tableInfos[1];
      const removedConstraints = {};

      for (const columnName in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, columnName)) continue;
        if (!columns[columnName] && !columns[attributes[columnName].field]) {
          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);
        }
      }

      if (options.alter === true || typeof options.alter === 'object' && options.alter.drop !== false) {
        for (const columnName in columns) {
          if (!Object.prototype.hasOwnProperty.call(columns, columnName)) continue;
          const currentAttribute = rawAttributes[columnName];
          if (!currentAttribute) {
            await this.queryInterface.removeColumn(tableName, columnName, options);
            continue;
          }
          if (currentAttribute.primaryKey) continue;
          // Check foreign keys. If it's a foreign key, it should remove constraint first.
          const references = currentAttribute.references;
          if (currentAttribute.references) {
            const database = this.sequelize.config.database;
            const schema = this.sequelize.config.schema;
            // Find existed foreign keys
            for (const foreignKeyReference of foreignKeyReferences) {
              const constraintName = foreignKeyReference.constraintName;
              if (!!constraintName
                && foreignKeyReference.tableCatalog === database
                && (schema ? foreignKeyReference.tableSchema === schema : true)
                && foreignKeyReference.referencedTableName === references.model
                && foreignKeyReference.referencedColumnName === references.key
                && (schema ? foreignKeyReference.referencedTableSchema === schema : true)
                && !removedConstraints[constraintName]) {
                // Remove constraint on foreign keys.
                await this.queryInterface.removeConstraint(tableName, constraintName, options);
                removedConstraints[constraintName] = true;
              }
            }
          }
          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);
        }
      }
    }
    let indexes = await this.queryInterface.showIndex(tableName, options);
    indexes = this._indexes.filter(item1 =>
      !indexes.some(item2 => item1.name === item2.name)
    ).sort((index1, index2) => {
      if (this.sequelize.options.dialect === 'postgres') {
      // move concurrent indexes to the bottom to avoid weird deadlocks
        if (index1.concurrently === true) return 1;
        if (index2.concurrently === true) return -1;
      }

      return 0;
    });

    for (const index of indexes) {
      await this.queryInterface.addIndex(tableName, { ...options, ...index });
    }

    if (options.hooks) {
      await this.runHooks('afterSync', options);
    }

    return this;
  }

  /**
   * Drop the table represented by this Model
   *
   * @param {object}   [options] drop options
   * @param {boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres
   * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise}
   */
  static async drop(options) {
    return await this.queryInterface.dropTable(this.getTableName(options), options);
  }

  static async dropSchema(schema) {
    return await this.queryInterface.dropSchema(schema);
  }

  /**
   * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `"schema"."tableName"`,
   * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.
   *
   * This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important
   * to call `model.schema(schema, [options]).sync()` for each model to ensure the models are created in the correct schema.
   *
   * If a single default schema per model is needed, set the `options.schema='schema'` parameter during the `define()` call
   * for the model.
   *
   * @param {string}   schema The name of the schema
   * @param {object}   [options] schema options
   * @param {string}   [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @see
   * {@link Sequelize#define} for more information about setting a default schema.
   *
   * @returns {Model}
   */
  static schema(schema, options) {

    const clone = class extends this {};
    Object.defineProperty(clone, 'name', { value: this.name });

    clone._schema = schema;

    if (options) {
      if (typeof options === 'string') {
        clone._schemaDelimiter = options;
      } else if (options.schemaDelimiter) {
        clone._schemaDelimiter = options.schemaDelimiter;
      }
    }

    return clone;
  }

  /**
   * Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema,
   * or an object with `tableName`, `schema` and `delimiter` properties.
   *
   * @returns {string|object}
   */
  static getTableName() {
    return this.queryGenerator.addSchema(this);
  }

  /**
   * Get un-scoped model
   *
   * @returns {Model}
   */
  static unscoped() {
    return this.scope();
  }

  /**
   * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.
   *
   * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.
   *
   * @param {string}          name The name of the scope. Use `defaultScope` to override the default scope
   * @param {object|Function} scope scope or options
   * @param {object}          [options] scope options
   * @param {boolean}         [options.override=false] override old scope if already defined
   */
  static addScope(name, scope, options) {
    options = { override: false, ...options };

    if ((name === 'defaultScope' && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {
      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);
    }

    if (name === 'defaultScope') {
      this.options.defaultScope = this._scope = scope;
    } else {
      this.options.scopes[name] = scope;
    }
  }

  /**
   * Apply a scope created in `define` to the model.
   *
   * @example <caption>how to create scopes</caption>
   * const Model = sequelize.define('model', attributes, {
   *   defaultScope: {
   *     where: {
   *       username: 'dan'
   *     },
   *     limit: 12
   *   },
   *   scopes: {
   *     isALie: {
   *       where: {
   *         stuff: 'cake'
   *       }
   *     },
   *     complexFunction: function(email, accessLevel) {
   *       return {
   *         where: {
   *           email: {
   *             [Op.like]: email
   *           },
   *           access_level {
   *             [Op.gte]: accessLevel
   *           }
   *         }
   *       }
   *     }
   *   }
   * })
   *
   * # As you have defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:
   *
   * Model.findAll() // WHERE username = 'dan'
   * Model.findAll({ where: { age: { [Op.gt]: 12 } } }) // WHERE age > 12 AND username = 'dan'
   *
   * @example <caption>To invoke scope functions you can do</caption>
   * Model.scope({ method: ['complexFunction', 'dan@sequelize.com', 42]}).findAll()
   * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42
   *
   * @param {?Array|object|string} [option] The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.
   *
   * @returns {Model} A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.
   */
  static scope(option) {
    const self = class extends this {};
    let scope;
    let scopeName;

    Object.defineProperty(self, 'name', { value: this.name });

    self._scope = {};
    self._scopeNames = [];
    self.scoped = true;

    if (!option) {
      return self;
    }

    const options = _.flatten(arguments);

    for (const option of options) {
      scope = null;
      scopeName = null;

      if (_.isPlainObject(option)) {
        if (option.method) {
          if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {
            scopeName = option.method[0];
            scope = self.options.scopes[scopeName].apply(self, option.method.slice(1));
          }
          else if (self.options.scopes[option.method]) {
            scopeName = option.method;
            scope = self.options.scopes[scopeName].apply(self);
          }
        } else {
          scope = option;
        }
      } else if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {
        scope = self.options.defaultScope;
      } else {
        scopeName = option;
        scope = self.options.scopes[scopeName];
        if (typeof scope === 'function') {
          scope = scope();
        }
      }

      if (scope) {
        this._conformIncludes(scope, this);
        // clone scope so it doesn't get modified
        this._assignOptions(self._scope, Utils.cloneDeep(scope));
        self._scopeNames.push(scopeName ? scopeName : 'defaultScope');
      } else {
        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);
      }
    }

    return self;
  }

  /**
   * Search for multiple instances.
   *
   * @example <caption>Simple search using AND and =</caption>
   * Model.findAll({
   *   where: {
   *     attr1: 42,
   *     attr2: 'cake'
   *   }
   * })
   *
   * # WHERE attr1 = 42 AND attr2 = 'cake'
   *
   * @example <caption>Using greater than, less than etc.</caption>
   * const {gt, lte, ne, in: opIn} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     attr1: {
   *       [gt]: 50
   *     },
   *     attr2: {
   *       [lte]: 45
   *     },
   *     attr3: {
   *       [opIn]: [1,2,3]
   *     },
   *     attr4: {
   *       [ne]: 5
   *     }
   *   }
   * })
   *
   * # WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5
   *
   * @example <caption>Queries using OR</caption>
   * const {or, and, gt, lt} = Sequelize.Op;
   *
   * Model.findAll({
   *   where: {
   *     name: 'a project',
   *     [or]: [
   *       {id: [1, 2, 3]},
   *       {
   *         [and]: [
   *           {id: {[gt]: 10}},
   *           {id: {[lt]: 100}}
   *         ]
   *       }
   *     ]
   *   }
   * });
   *
   * # WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));
   *
   * @see
   * {@link Operators} for possible operators
   * __Alias__: _all_
   *
   * The promise is resolved with an array of Model instances if the query succeeds._
   *
   * @param  {object}                                                    [options] A hash of options to describe the scope of the search
   * @param  {object}                                                    [options.where] A hash of attributes to describe your search. See above for examples.
   * @param  {Array<string>|object}                                      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance
   * @param  {Array<string>}                                             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`
   * @param  {Array<string>}                                             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`
   * @param  {boolean}                                                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.
   * @param  {Array<object|Model|string>}                                [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}` or `{ include: ['Alias']}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).
   * @param  {Model}                                                     [options.include[].model] The model you want to eagerly load
   * @param  {string}                                                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural
   * @param  {Association}                                               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)
   * @param  {object}                                                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`
   * @param  {boolean}                                                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.
   * @param  {object}                                                    [options.include[].on] Supply your own ON condition for the join.
   * @param  {Array<string>}                                             [options.include[].attributes] A list of attributes to select from the child model
   * @param  {boolean}                                                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.
   * @param  {boolean}                                                   [options.include[].right] If true, converts to a right join if dialect support it. Ignored if `include.required` is true.
   * @param  {boolean}                                                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations
   * @param  {number}                                                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true
   * @param  {string}                                                    [options.include[].through.as] The alias for the join model, in case you want to give it a different name than the default one.
   * @param  {object}                                                    [options.include[].through.where] Filter on the join model for belongsToMany relations
   * @param  {Array}                                                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations
   * @param  {Array<object|Model|string>}                                [options.include[].include] Load further nested related models
   * @param  {boolean}                                                   [options.include[].duplicating] Mark the include as duplicating, will prevent a subquery from being used.
   * @param  {Array|Sequelize.fn|Sequelize.col|Sequelize.literal}        [options.order] Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.
   * @param  {number}                                                    [options.limit] Limit for result
   * @param  {number}                                                    [options.offset] Offset for result
   * @param  {Transaction}                                               [options.transaction] Transaction to run query under
   * @param  {string|object}                                             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.
   * @param  {boolean}                                                   [options.skipLocked] Skip locked rows. Only supported in Postgres.
   * @param  {boolean}                                                   [options.raw] Return raw result. See sequelize.query for more information.
   * @param  {Function}                                                  [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param  {boolean}                                                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {object}                                                    [options.having] Having options
   * @param  {string}                                                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Error}                                             [options.rejectOnEmpty=false] Throws an error when no records found
   *
   * @see
   * {@link Sequelize#query}
   *
   * @returns {Promise<Array<Model>>}
   */
  static async findAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new sequelizeErrors.QueryError('The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    if (options !== undefined && options.attributes) {
      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {
        throw new sequelizeErrors.QueryError('The attributes option must be an array of column names or an object');
      }
    }

    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));

    const tableNames = {};

    tableNames[this.getTableName(options)] = true;
    options = Utils.cloneDeep(options);

    _.defaults(options, { hooks: true });

    // set rejectOnEmpty option, defaults to model options
    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, 'rejectOnEmpty')
      ? options.rejectOnEmpty
      : this.options.rejectOnEmpty;

    this._injectScope(options);

    if (options.hooks) {
      await this.runHooks('beforeFind', options);
    }
    this._conformIncludes(options, this);
    this._expandAttributes(options);
    this._expandIncludeAll(options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterExpandIncludeAll', options);
    }
    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);

    if (options.include) {
      options.hasJoin = true;

      this._validateIncludedElements(options, tableNames);

      // If we're not raw, we have to make sure we include the primary key for de-duplication
      if (
        options.attributes
        && !options.raw
        && this.primaryKeyAttribute
        && !options.attributes.includes(this.primaryKeyAttribute)
        && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)
      ) {
        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);
      }
    }

    if (!options.attributes) {
      options.attributes = Object.keys(this.rawAttributes);
      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
    }

    // whereCollection is used for non-primary key updates
    this.options.whereCollection = options.where || null;

    Utils.mapFinderOptions(options, this);

    options = this._paranoidClause(this, options);

    if (options.hooks) {
      await this.runHooks('beforeFindAfterOptions', options);
    }
    const selectOptions = { ...options, tableNames: Object.keys(tableNames) };
    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);
    if (options.hooks) {
      await this.runHooks('afterFind', results, options);
    }

    //rejectOnEmpty mode
    if (_.isEmpty(results) && options.rejectOnEmpty) {
      if (typeof options.rejectOnEmpty === 'function') {
        throw new options.rejectOnEmpty();
      }
      if (typeof options.rejectOnEmpty === 'object') {
        throw options.rejectOnEmpty;
      }
      throw new sequelizeErrors.EmptyResultError();
    }

    return await Model._findSeparate(results, options);
  }

  static warnOnInvalidOptions(options, validColumnNames) {
    if (!_.isPlainObject(options)) {
      return;
    }

    const unrecognizedOptions = Object.keys(options).filter(k => !validQueryKeywords.has(k));
    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);
    if (!options.where && unexpectedModelAttributes.length > 0) {
      logger.warn(`Model attributes (${unexpectedModelAttributes.join(', ')}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);
    }
  }

  static _injectDependentVirtualAttributes(attributes) {
    if (!this._hasVirtualAttributes) return attributes;
    if (!attributes || !Array.isArray(attributes)) return attributes;

    for (const attribute of attributes) {
      if (
        this._virtualAttributes.has(attribute)
        && this.rawAttributes[attribute].type.fields
      ) {
        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);
      }
    }

    attributes = _.uniq(attributes);

    return attributes;
  }

  static async _findSeparate(results, options) {
    if (!options.include || options.raw || !results) return results;

    const original = results;
    if (options.plain) results = [results];

    if (!results.length) return original;

    await Promise.all(options.include.map(async include => {
      if (!include.separate) {
        return await Model._findSeparate(
          results.reduce((memo, result) => {
            let associations = result.get(include.association.as);

            // Might be an empty belongsTo relation
            if (!associations) return memo;

            // Force array so we can concat no matter if it's 1:1 or :M
            if (!Array.isArray(associations)) associations = [associations];

            for (let i = 0, len = associations.length; i !== len; ++i) {
              memo.push(associations[i]);
            }
            return memo;
          }, []),
          {

            ..._.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'offset', 'plain', 'scope'),
            include: include.include || []
          }
        );
      }

      const map = await include.association.get(results, {

        ..._.omit(options, nonCascadingOptions),
        ..._.omit(include, ['parent', 'association', 'as', 'originalAttributes'])
      });

      for (const result of results) {
        result.set(
          include.association.as,
          map[result.get(include.association.sourceKey)],
          { raw: true }
        );
      }
    }));

    return original;
  }

  /**
   * Search for a single instance by its primary key._
   *
   * @param  {number|string|Buffer}      param The value of the desired instance's primary key.
   * @param  {object}                    [options] find options
   * @param  {Transaction}               [options.transaction] Transaction to run query under
   * @param  {string}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll}           for a full explanation of options, Note that options.where is not supported.
   *
   * @returns {Promise<Model>}
   */
  static async findByPk(param, options) {
    // return Promise resolved with null if no arguments are passed
    if ([null, undefined].includes(param)) {
      return null;
    }

    options = Utils.cloneDeep(options) || {};

    if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {
      options.where = {
        [this.primaryKeyAttribute]: param
      };
    } else {
      throw new Error(`Argument passed to findByPk is invalid: ${param}`);
    }

    // Bypass a possible overloaded findOne
    return await this.findOne(options);
  }

  /**
   * Search for a single instance. Returns the first instance found, or null if none can be found.
   *
   * @param  {object}       [options] A hash of options to describe the scope of the search
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {string}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @see
   * {@link Model.findAll} for an explanation of options
   *
   * @returns {Promise<Model|null>}
   */
  static async findOne(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value');
    }
    options = Utils.cloneDeep(options);

    if (options.limit === undefined) {
      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter(c => c.fields.length === 1).map('column').value();

      // Don't add limit if querying directly on the pk or a unique column
      if (!options.where || !_.some(options.where, (value, key) =>
        (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) &&
          (Utils.isPrimitive(value) || Buffer.isBuffer(value))
      )) {
        options.limit = 1;
      }
    }

    // Bypass a possible overloaded findAll.
    return await this.findAll(_.defaults(options, {
      plain: true
    }));
  }

  /**
   * Run an aggregation method on the specified field
   *
   * @param {string}          attribute The attribute to aggregate over. Can be a field name or *
   * @param {string}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.
   * @param {object}          [options] Query options. See sequelize.query for full options
   * @param {object}          [options.where] A hash of search attributes.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {DataTypes|string} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.
   * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over
   * @param {Transaction}     [options.transaction] Transaction to run query under
   * @param {boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`
   *
   * @returns {Promise<DataTypes|object>} Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.
   */
  static async aggregate(attribute, aggregateFunction, options) {
    options = Utils.cloneDeep(options);

    // We need to preserve attributes here as the `injectScope` call would inject non aggregate columns.
    const prevAttributes = options.attributes;
    this._injectScope(options);
    options.attributes = prevAttributes;
    this._conformIncludes(options, this);

    if (options.include) {
      this._expandIncludeAll(options);
      this._validateIncludedElements(options);
    }

    const attrOptions = this.rawAttributes[attribute];
    const field = attrOptions && attrOptions.field || attribute;
    let aggregateColumn = this.sequelize.col(field);

    if (options.distinct) {
      aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);
    }

    let { group } = options;
    if (Array.isArray(group) && Array.isArray(group[0])) {
      noDoubleNestedGroup();
      group = _.flatten(group);
    }
    options.attributes = _.unionBy(
      options.attributes,
      group,
      [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]],
      a => Array.isArray(a) ? a[1] : a
    );

    if (!options.dataType) {
      if (attrOptions) {
        options.dataType = attrOptions.type;
      } else {
        // Use FLOAT as fallback
        options.dataType = new DataTypes.FLOAT();
      }
    } else {
      options.dataType = this.sequelize.normalizeDataType(options.dataType);
    }

    Utils.mapOptionFieldNames(options, this);
    options = this._paranoidClause(this, options);

    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);
    if (value === null) {
      return 0;
    }
    return value;
  }

  /**
   * Count the number of records matching the provided where clause.
   *
   * If you provide an `include` option, the number of matching associations will be counted instead.
   *
   * @param {object}        [options] options
   * @param {object}        [options.where] A hash of search attributes.
   * @param {object}        [options.include] Include options. See `find` for details
   * @param {boolean}       [options.paranoid=true] Set `true` to count only non-deleted records. Can be used on models with `paranoid` enabled
   * @param {boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key or on options.col.
   * @param {string}        [options.col] Column on which COUNT() should be applied
   * @param {Array}         [options.attributes] Used in conjunction with `group`
   * @param {Array}         [options.group] For creating complex counts. Will return multiple rows as needed.
   * @param {Transaction}   [options.transaction] Transaction to run query under
   * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<number>}
   */
  static async count(options) {
    options = Utils.cloneDeep(options);
    options = _.defaults(options, { hooks: true });
    options.raw = true;
    if (options.hooks) {
      await this.runHooks('beforeCount', options);
    }
    let col = options.col || '*';
    if (options.include) {
      col = `${this.name}.${options.col || this.primaryKeyField}`;
    }
    if (options.distinct && col === '*') {
      col = this.primaryKeyField;
    }
    options.plain = !options.group;
    options.dataType = new DataTypes.INTEGER();
    options.includeIgnoreAttributes = false;

    // No limit, offset or order for the options max be given to count()
    // Set them to null to prevent scopes setting those values
    options.limit = null;
    options.offset = null;
    options.order = null;

    return await this.aggregate(col, 'count', options);
  }

  /**
   * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging
   *
   * @example
   * const result = await Model.findAndCountAll({
   *   where: ...,
   *   limit: 12,
   *   offset: 12
   * });
   *
   * # In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.
   *
   * # When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.
   *
   * # Suppose you want to find all users who have a profile attached:
   *
   * User.findAndCountAll({
   *   include: [
   *      { model: Profile, required: true}
   *   ],
   *   limit: 3
   * });
   *
   * # Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted
   *
   * @param {object} [options] See findAll options
   *
   * @see
   * {@link Model.findAll} for a specification of find and query options
   * @see
   * {@link Model.count} for a specification of count options
   *
   * @returns {Promise<{count: number, rows: Model[]}>}
   */
  static async findAndCountAll(options) {
    if (options !== undefined && !_.isPlainObject(options)) {
      throw new Error('The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value');
    }

    const countOptions = Utils.cloneDeep(options);

    if (countOptions.attributes) {
      countOptions.attributes = undefined;
    }

    const [count, rows] = await Promise.all([
      this.count(countOptions),
      this.findAll(options)
    ]);

    return {
      count,
      rows: count === 0 ? [] : rows
    };
  }

  /**
   * Find the maximum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async max(field, options) {
    return await this.aggregate(field, 'max', options);
  }

  /**
   * Find the minimum value of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<*>}
   */
  static async min(field, options) {
    return await this.aggregate(field, 'min', options);
  }

  /**
   * Find the sum of field
   *
   * @param {string} field attribute / field name
   * @param {object} [options] See aggregate
   *
   * @see
   * {@link Model.aggregate} for options
   *
   * @returns {Promise<number>}
   */
  static async sum(field, options) {
    return await this.aggregate(field, 'sum', options);
  }

  /**
   * Builds a new model instance.
   *
   * @param {object|Array} values An object of key value pairs or an array of such. If an array, the function will return an array of instances.
   * @param {object}  [options] Instance build options
   * @param {boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {boolean} [options.isNewRecord=true] Is this new record
   * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`
   *
   * @returns {Model|Array<Model>}
   */
  static build(values, options) {
    if (Array.isArray(values)) {
      return this.bulkBuild(values, options);
    }

    return new this(values, options);
  }

  static bulkBuild(valueSets, options) {
    options = { isNewRecord: true, ...options };

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    if (options.attributes) {
      options.attributes = options.attributes.map(attribute => Array.isArray(attribute) ? attribute[1] : attribute);
    }

    return valueSets.map(values => this.build(values, options));
  }

  /**
   * Builds a new model instance and calls save on it.
   *
   * @see
   * {@link Model.build}
   * @see
   * {@link Model.save}
   *
   * @param  {object}         values                       Hash of data values to create new record with
   * @param  {object}         [options]                    Build and query options
   * @param  {boolean}        [options.raw=false]          If set to true, values will ignore field and virtual setters.
   * @param  {boolean}        [options.isNewRecord=true]   Is this new record
   * @param  {Array}          [options.include]            An array of include options - Used to build prefetched/included model instances. See `set`
   * @param  {string[]}       [options.fields]             An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param  {boolean}        [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {boolean}        [options.validate=true]      If false, validations won't be run.
   * @param  {boolean}        [options.hooks=true]         Run before and after create / update + validate hooks
   * @param  {Function}       [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]    Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]        Transaction to run query under
   * @param  {string}         [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param  {boolean|Array}  [options.returning=true]     Appends RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   *
   * @returns {Promise<Model>}
   *
   */
  static async create(values, options) {
    options = Utils.cloneDeep(options || {});

    return await this.build(values, {
      isNewRecord: true,
      attributes: options.fields,
      include: options.include,
      raw: options.raw,
      silent: options.silent
    }).save(options);
  }

  /**
   * Find a row that matches the query, or build (but don't save) the row if none is found.
   * The successful result of the promise will be (instance, built)
   *
   * @param {object}   options find options
   * @param {object}   options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}   [options.defaults] Default values to use if building a new instance
   * @param {object}   [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrBuild(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrBuild. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    let values;

    let instance = await this.findOne(options);
    if (instance === null) {
      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      instance = this.build(values, options);

      return [instance, true];
    }

    return [instance, false];
  }

  /**
   * Find a row that matches the query, or build and save the row if none is found
   * The successful result of the promise will be (instance, created)
   *
   * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.
   * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead.
   * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object}      options find and create options
   * @param {object}      options.where where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object}      [options.defaults] Default values to use if creating a new instance
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findOrCreate(options) {
    if (!options || !options.where || arguments.length > 1) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findOrCreate. ' +
        'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'
      );
    }

    options = { ...options };

    if (options.defaults) {
      const defaults = Object.keys(options.defaults);
      const unknownDefaults = defaults.filter(name => !this.rawAttributes[name]);

      if (unknownDefaults.length) {
        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);
      }
    }

    if (options.transaction === undefined && this.sequelize.constructor._cls) {
      const t = this.sequelize.constructor._cls.get('transaction');
      if (t) {
        options.transaction = t;
      }
    }

    const internalTransaction = !options.transaction;
    let values;
    let transaction;

    try {
      const t = await this.sequelize.transaction(options);
      transaction = t;
      options.transaction = t;

      const found = await this.findOne(Utils.defaults({ transaction }, options));
      if (found !== null) {
        return [found, false];
      }

      values = { ...options.defaults };
      if (_.isPlainObject(options.where)) {
        values = Utils.defaults(values, options.where);
      }

      options.exception = true;
      options.returning = true;

      try {
        const created = await this.create(values, options);
        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {
          // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation
          throw new sequelizeErrors.UniqueConstraintError();
        }

        return [created, true];
      } catch (err) {
        if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
        const flattenedWhere = Utils.flattenObjectDeep(options.where);
        const flattenedWhereKeys = Object.keys(flattenedWhere).map(name => _.last(name.split('.')));
        const whereFields = flattenedWhereKeys.map(name => _.get(this.rawAttributes, `${name}.field`, name));
        const defaultFields = options.defaults && Object.keys(options.defaults)
          .filter(name => this.rawAttributes[name])
          .map(name => this.rawAttributes[name].field || name);

        const errFieldKeys = Object.keys(err.fields);
        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);
        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {
          throw err;
        }

        if (errFieldsWhereIntersects) {
          _.each(err.fields, (value, key) => {
            const name = this.fieldRawAttributesMap[key].fieldName;
            if (value.toString() !== options.where[name].toString()) {
              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);
            }
          });
        }

        // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!
        const otherCreated = await this.findOne(Utils.defaults({
          transaction: internalTransaction ? null : transaction
        }, options));

        // Sanity check, ideally we caught this at the defaultFeilds/err.fields check
        // But if we didn't and instance is null, we will throw
        if (otherCreated === null) throw err;

        return [otherCreated, false];
      }
    } finally {
      if (internalTransaction && transaction) {
        await transaction.commit();
      }
    }
  }

  /**
   * A more performant findOrCreate that will not work under a transaction (at least not in postgres)
   * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again
   *
   * @see
   * {@link Model.findAll} for a full specification of find and options
   *
   * @param {object} options find options
   * @param {object} options.where A hash of search attributes. If `where` is a plain object it will be appended with defaults to build a new instance.
   * @param {object} [options.defaults] Default values to use if creating a new instance
   *
   * @returns {Promise<Model,boolean>}
   */
  static async findCreateFind(options) {
    if (!options || !options.where) {
      throw new Error(
        'Missing where attribute in the options parameter passed to findCreateFind.'
      );
    }

    let values = { ...options.defaults };
    if (_.isPlainObject(options.where)) {
      values = Utils.defaults(values, options.where);
    }


    const found = await this.findOne(options);
    if (found) return [found, false];

    try {
      const created = await this.create(values, options);
      return [created, true];
    } catch (err) {
      if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
      const foundAgain = await this.findOne(options);
      return [foundAgain, false];
    }
  }

  /**
   * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.
   *
   * **Implementation details:**
   *
   * * MySQL - Implemented with ON DUPLICATE KEY UPDATE`
   * * PostgreSQL - Implemented with ON CONFLICT DO UPDATE. If update data contains PK field, then PK is selected as the default conflict key. Otherwise first unique constraint/index will be selected, which can satisfy conflict key requirements.
   * * SQLite - Implemented with ON CONFLICT DO UPDATE
   * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`
   *
   * **Note** that Postgres/SQLite returns null for created, no matter if the row was created or updated
   *
   * @param  {object}       values                                        hash of values to upsert
   * @param  {object}       [options]                                     upsert options
   * @param  {boolean}      [options.validate=true]                       Run validations before the row is inserted
   * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all changed fields
   * @param  {boolean}      [options.hooks=true]                          Run before / after upsert hooks?
   * @param  {boolean}      [options.returning=true]                      If true, fetches back auto generated values
   * @param  {Transaction}  [options.transaction]                         Transaction to run query under
   * @param  {Function}     [options.logging=false]                       A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]                     Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {string}       [options.searchPath=DEFAULT]                  An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<[Model, boolean | null]>} returns an array with two elements, the first being the new record and the second being `true` if it was just created or `false` if it already existed (except on Postgres and SQLite, which can't detect this and will always return `null` instead of a boolean).
   */
  static async upsert(values, options) {
    options = {
      hooks: true,
      returning: true,
      validate: true,
      ...Utils.cloneDeep(options)
    };

    const createdAtAttr = this._timestampAttributes.createdAt;
    const updatedAtAttr = this._timestampAttributes.updatedAt;
    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;
    const instance = this.build(values);

    options.model = this;
    options.instance = instance;

    const changed = Array.from(instance._changed);
    if (!options.fields) {
      options.fields = changed;
    }

    if (options.validate) {
      await instance.validate(options);
    }
    // Map field names
    const updatedDataValues = _.pick(instance.dataValues, changed);
    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);
    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);
    const now = Utils.now(this.sequelize.options.dialect);

    // Attach createdAt
    if (createdAtAttr && !updateValues[createdAtAttr]) {
      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;
      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;
    }
    if (updatedAtAttr && !insertValues[updatedAtAttr]) {
      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;
    }

    // Build adds a null value for the primary key, if none was given by the user.
    // We need to remove that because of some Postgres technicalities.
    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {
      delete insertValues[this.primaryKeyField];
      delete updateValues[this.primaryKeyField];
    }

    if (options.hooks) {
      await this.runHooks('beforeUpsert', values, options);
    }
    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);

    const [record] = result;
    record.isNewRecord = false;

    if (options.hooks) {
      await this.runHooks('afterUpsert', result, options);
      return result;
    }
    return result;
  }

  /**
   * Create and insert multiple instances in bulk.
   *
   * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL
   * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.
   * To obtain Instances for the newly created values, you will need to query for them again.
   *
   * If validation fails, the promise is rejected with an array-like AggregateError
   *
   * @param  {Array}          records                          List of objects (key/value pairs) to create instances from
   * @param  {object}         [options]                        Bulk create options
   * @param  {Array}          [options.fields]                 Fields to insert (defaults to all fields)
   * @param  {boolean}        [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]             Run before / after bulk create hooks?
   * @param  {boolean}        [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.
   * @param  {boolean}        [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres < 9.5)
   * @param  {Array}          [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite >= 3.24.0 & Postgres >= 9.5). By default, all fields are updated.
   * @param  {Transaction}    [options.transaction]            Transaction to run query under
   * @param  {Function}       [options.logging=false]          A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]        Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {boolean|Array}  [options.returning=false]        If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {string}         [options.searchPath=DEFAULT]     An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Array<Model>>}
   */
  static async bulkCreate(records, options = {}) {
    if (!records.length) {
      return [];
    }

    const dialect = this.sequelize.options.dialect;
    const now = Utils.now(this.sequelize.options.dialect);

    options.model = this;

    if (!options.includeValidated) {
      this._conformIncludes(options, this);
      if (options.include) {
        this._expandIncludeAll(options);
        this._validateIncludedElements(options);
      }
    }

    const instances = records.map(values => this.build(values, { isNewRecord: true, include: options.include }));

    const recursiveBulkCreate = async (instances, options) => {
      options = {
        validate: false,
        hooks: true,
        individualHooks: false,
        ignoreDuplicates: false,
        ...options
      };

      if (options.returning === undefined) {
        if (options.association) {
          options.returning = false;
        } else {
          options.returning = true;
        }
      }

      if (options.ignoreDuplicates && ['mssql'].includes(dialect)) {
        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);
      }
      if (options.updateOnDuplicate && (dialect !== 'mysql' && dialect !== 'mariadb' && dialect !== 'sqlite' && dialect !== 'postgres')) {
        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);
      }

      const model = options.model;

      options.fields = options.fields || Object.keys(model.rawAttributes);
      const createdAtAttr = model._timestampAttributes.createdAt;
      const updatedAtAttr = model._timestampAttributes.updatedAt;

      if (options.updateOnDuplicate !== undefined) {
        if (Array.isArray(options.updateOnDuplicate) && options.updateOnDuplicate.length) {
          options.updateOnDuplicate = _.intersection(
            _.without(Object.keys(model.tableAttributes), createdAtAttr),
            options.updateOnDuplicate
          );
        } else {
          throw new Error('updateOnDuplicate option only supports non-empty array.');
        }
      }

      // Run before hook
      if (options.hooks) {
        await model.runHooks('beforeBulkCreate', instances, options);
      }
      // Validate
      if (options.validate) {
        const errors = [];
        const validateOptions = { ...options };
        validateOptions.hooks = options.individualHooks;

        await Promise.all(instances.map(async instance => {
          try {
            await instance.validate(validateOptions);
          } catch (err) {
            errors.push(new sequelizeErrors.BulkRecordError(err, instance));
          }
        }));

        delete options.skip;
        if (errors.length) {
          throw new sequelizeErrors.AggregateError(errors);
        }
      }
      if (options.individualHooks) {
        await Promise.all(instances.map(async instance => {
          const individualOptions = {
            ...options,
            validate: false,
            hooks: true
          };
          delete individualOptions.fields;
          delete individualOptions.individualHooks;
          delete individualOptions.ignoreDuplicates;

          await instance.save(individualOptions);
        }));
      } else {
        if (options.include && options.include.length) {
          await Promise.all(options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
            const associationInstances = [];
            const associationInstanceIndexToInstanceMap = [];

            for (const instance of instances) {
              const associationInstance = instance.get(include.as);
              if (associationInstance) {
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }

            if (!associationInstances.length) {
              return;
            }

            const includeOptions = _(Utils.cloneDeep(include))
              .omit(['association'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();

            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              await include.association.set(instance, associationInstance, { save: false, logging: options.logging });
            }
          }));
        }

        // Create all in one query
        // Recreate records from instances to represent any changes made in hooks or validation
        records = instances.map(instance => {
          const values = instance.dataValues;

          // set createdAt/updatedAt attributes
          if (createdAtAttr && !values[createdAtAttr]) {
            values[createdAtAttr] = now;
            if (!options.fields.includes(createdAtAttr)) {
              options.fields.push(createdAtAttr);
            }
          }
          if (updatedAtAttr && !values[updatedAtAttr]) {
            values[updatedAtAttr] = now;
            if (!options.fields.includes(updatedAtAttr)) {
              options.fields.push(updatedAtAttr);
            }
          }

          const out = Utils.mapValueFieldNames(values, options.fields, model);
          for (const key of model._virtualAttributes) {
            delete out[key];
          }
          return out;
        });

        // Map attributes to fields for serial identification
        const fieldMappedAttributes = {};
        for (const attr in model.tableAttributes) {
          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];
        }

        // Map updateOnDuplicate attributes to fields
        if (options.updateOnDuplicate) {
          options.updateOnDuplicate = options.updateOnDuplicate.map(attr => model.rawAttributes[attr].field || attr);
          // Get primary keys for postgres to enable updateOnDuplicate
          options.upsertKeys = _.chain(model.primaryKeys).values().map('field').value();
          if (Object.keys(model.uniqueKeys).length > 0) {
            options.upsertKeys = _.chain(model.uniqueKeys).values().filter(c => c.fields.length >= 1).map(c => c.fields).reduce(c => c[0]).value();
          }
        }

        // Map returning attributes to fields
        if (options.returning && Array.isArray(options.returning)) {
          options.returning = options.returning.map(attr => _.get(model.rawAttributes[attr], 'field', attr));
        }

        const results = await model.queryInterface.bulkInsert(model.getTableName(options), records, options, fieldMappedAttributes);
        if (Array.isArray(results)) {
          results.forEach((result, i) => {
            const instance = instances[i];

            for (const key in result) {
              if (!instance || key === model.primaryKeyAttribute &&
                instance.get(model.primaryKeyAttribute) &&
                ['mysql', 'mariadb', 'sqlite'].includes(dialect)) {
                // The query.js for these DBs is blind, it autoincrements the
                // primarykey value, even if it was set manually. Also, it can
                // return more results than instances, bug?.
                continue;
              }
              if (Object.prototype.hasOwnProperty.call(result, key)) {
                const record = result[key];

                const attr = _.find(model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);

                instance.dataValues[attr && attr.fieldName || key] = record;
              }
            }
          });
        }
      }

      if (options.include && options.include.length) {
        await Promise.all(options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          const associationInstances = [];
          const associationInstanceIndexToInstanceMap = [];

          for (const instance of instances) {
            let associated = instance.get(include.as);
            if (!Array.isArray(associated)) associated = [associated];

            for (const associationInstance of associated) {
              if (associationInstance) {
                if (!(include.association instanceof BelongsToMany)) {
                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
                  Object.assign(associationInstance, include.association.scope);
                }
                associationInstances.push(associationInstance);
                associationInstanceIndexToInstanceMap.push(instance);
              }
            }
          }

          if (!associationInstances.length) {
            return;
          }

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging
            }).value();

          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
          if (include.association instanceof BelongsToMany) {
            const valueSets = [];

            for (const idx in createdAssociationInstances) {
              const associationInstance = createdAssociationInstances[idx];
              const instance = associationInstanceIndexToInstanceMap[idx];

              const values = {
                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };
              if (associationInstance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof associationInstance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values[attr] = associationInstance[include.association.through.model.name][attr];
                }
              }

              valueSets.push(values);
            }

            const throughOptions = _(Utils.cloneDeep(include))
              .omit(['association', 'attributes'])
              .defaults({
                transaction: options.transaction,
                logging: options.logging
              }).value();
            throughOptions.model = include.association.throughModel;
            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);

            await recursiveBulkCreate(throughInstances, throughOptions);
          }
        }));
      }

      // map fields back to attributes
      instances.forEach(instance => {
        for (const attr in model.rawAttributes) {
          if (model.rawAttributes[attr].field &&
              instance.dataValues[model.rawAttributes[attr].field] !== undefined &&
              model.rawAttributes[attr].field !== attr
          ) {
            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];
            delete instance.dataValues[model.rawAttributes[attr].field];
          }
          instance._previousDataValues[attr] = instance.dataValues[attr];
          instance.changed(attr, false);
        }
        instance.isNewRecord = false;
      });

      // Run after hook
      if (options.hooks) {
        await model.runHooks('afterBulkCreate', instances, options);
      }

      return instances;
    };

    return await recursiveBulkCreate(instances, options);
  }

  /**
   * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).
   *
   * @param {object}           [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.cascade = false] Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param {boolean}          [options.restartIdentity=false] Automatically restart sequences owned by columns of the truncated table.
   * @param {Transaction}      [options.transaction] Transaction to run query under
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @param {boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   *
   * @see
   * {@link Model.destroy} for more information
   */
  static async truncate(options) {
    options = Utils.cloneDeep(options) || {};
    options.truncate = true;
    return await this.destroy(options);
  }

  /**
   * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.
   *
   * @param  {object}       options                         destroy options
   * @param  {object}       [options.where]                 Filter the destroy
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row
   * @param  {number}       [options.limit]                 How many rows to delete
   * @param  {boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)
   * @param  {boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored
   * @param  {boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.
   * @param  {boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.
   * @param  {Transaction}  [options.transaction] Transaction to run query under
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   *
   * @returns {Promise<number>} The number of destroyed rows
   */
  static async destroy(options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);

    if (!options || !(options.where || options.truncate)) {
      throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');
    }

    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {
      throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');
    }

    options = _.defaults(options, {
      hooks: true,
      individualHooks: false,
      force: false,
      cascade: false,
      restartIdentity: false
    });

    options.type = QueryTypes.BULKDELETE;

    Utils.mapOptionFieldNames(options, this);
    options.model = this;


    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkDestroy', options);
    }
    let instances;
    // Get daos and run beforeDestroy hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });

      await Promise.all(instances.map(instance => this.runHooks('beforeDestroy', instance, options)));
    }
    let result;
    // Run delete query (or update if paranoid)
    if (this._timestampAttributes.deletedAt && !options.force) {
      // Set query type appropriately when running soft delete
      options.type = QueryTypes.BULKUPDATE;

      const attrValueHash = {};
      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];
      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;
      const where = {
        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null
      };


      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);
      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);
    } else {
      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);
    }
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterDestroy', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkDestroy', options);
    }
    return result;
  }

  /**
   * Restore multiple instances if `paranoid` is enabled.
   *
   * @param  {object}       options                         restore options
   * @param  {object}       [options.where]                 Filter the restore
   * @param  {boolean}      [options.hooks=true]            Run before / after bulk restore hooks?
   * @param  {boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row
   * @param  {number}       [options.limit]                 How many rows to undelete (only for mysql)
   * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}  [options.transaction]           Transaction to run query under
   *
   * @returns {Promise}
   */
  static async restore(options) {
    if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      individualHooks: false,
      ...options
    };

    options.type = QueryTypes.RAW;
    options.model = this;

    Utils.mapOptionFieldNames(options, this);

    // Run before hook
    if (options.hooks) {
      await this.runHooks('beforeBulkRestore', options);
    }

    let instances;
    // Get daos and run beforeRestore hook on each record individually
    if (options.individualHooks) {
      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });

      await Promise.all(instances.map(instance => this.runHooks('beforeRestore', instance, options)));
    }
    // Run undelete query
    const attrValueHash = {};
    const deletedAtCol = this._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
    options.omitNull = false;
    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);
    // Run afterDestroy hook on each record individually
    if (options.individualHooks) {
      await Promise.all(
        instances.map(instance => this.runHooks('afterRestore', instance, options))
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.runHooks('afterBulkRestore', options);
    }
    return result;
  }

  /**
   * Update multiple instances that match the where options.
   *
   * @param  {object}         values                          hash of values to update
   * @param  {object}         options                         update options
   * @param  {object}         options.where                   Options to describe the scope of the search.
   * @param  {boolean}        [options.paranoid=true]         If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if `options.paranoid` is true for the model.
   * @param  {Array}          [options.fields]                Fields to update (defaults to all fields)
   * @param  {boolean}        [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {boolean}        [options.hooks=true]            Run before / after bulk update hooks?
   * @param  {boolean}        [options.sideEffects=true]      Whether or not to update the side effects of any virtual setters.
   * @param  {boolean}        [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks
   * @param  {boolean|Array}  [options.returning=false]       If true, append RETURNING <model columns> to get back all defined values; if an array of column names, append RETURNING <columns> to get back specific columns (Postgres only)
   * @param  {number}         [options.limit]                 How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)
   * @param  {Function}       [options.logging=false]         A function that gets executed while running the query to log the sql.
   * @param  {boolean}        [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param  {Transaction}    [options.transaction]           Transaction to run query under
   * @param  {boolean}        [options.silent=false]          If true, the updatedAt timestamp will not be updated.
   *
   * @returns {Promise<Array<number,number>>}  The promise returns an array with one or two elements. The first element is always the number
   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true).
   *
   */
  static async update(values, options) {
    options = Utils.cloneDeep(options);

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = this._paranoidClause(this, _.defaults(options, {
      validate: true,
      hooks: true,
      individualHooks: false,
      returning: false,
      force: false,
      sideEffects: true
    }));

    options.type = QueryTypes.BULKUPDATE;

    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    // Remove values that are not in the options.fields
    if (options.fields && options.fields instanceof Array) {
      for (const key of Object.keys(values)) {
        if (!options.fields.includes(key)) {
          delete values[key];
        }
      }
    } else {
      const updatedAtAttr = this._timestampAttributes.updatedAt;
      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));
      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {
        options.fields.push(updatedAtAttr);
      }
    }

    if (this._timestampAttributes.updatedAt && !options.silent) {
      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);
    }

    options.model = this;

    let valuesUse;
    // Validate
    if (options.validate) {
      const build = this.build(values);
      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });

      if (options.sideEffects) {
        Object.assign(values, _.pick(build.get(), build.changed()));
        options.fields = _.union(options.fields, Object.keys(values));
      }

      // We want to skip validations for all other fields
      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));
      const attributes = await build.validate(options);
      options.skip = undefined;
      if (attributes && attributes.dataValues) {
        values = _.pick(attributes.dataValues, Object.keys(values));
      }
    }
    // Run before hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('beforeBulkUpdate', options);
      values = options.attributes;
      delete options.attributes;
    }

    valuesUse = values;

    // Get instances and run beforeUpdate hook on each record individually
    let instances;
    let updateDoneRowByRow = false;
    if (options.individualHooks) {
      instances = await this.findAll({
        where: options.where,
        transaction: options.transaction,
        logging: options.logging,
        benchmark: options.benchmark,
        paranoid: options.paranoid
      });

      if (instances.length) {
        // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly
        // i.e. whether they change values for each record in the same way
        let changedValues;
        let different = false;

        instances = await Promise.all(instances.map(async instance => {
          // Record updates in instances dataValues
          Object.assign(instance.dataValues, values);
          // Set the changed fields on the instance
          _.forIn(valuesUse, (newValue, attr) => {
            if (newValue !== instance._previousDataValues[attr]) {
              instance.setDataValue(attr, newValue);
            }
          });

          // Run beforeUpdate hook
          await this.runHooks('beforeUpdate', instance, options);
          if (!different) {
            const thisChangedValues = {};
            _.forIn(instance.dataValues, (newValue, attr) => {
              if (newValue !== instance._previousDataValues[attr]) {
                thisChangedValues[attr] = newValue;
              }
            });

            if (!changedValues) {
              changedValues = thisChangedValues;
            } else {
              different = !_.isEqual(changedValues, thisChangedValues);
            }
          }

          return instance;
        }));

        if (!different) {
          const keys = Object.keys(changedValues);
          // Hooks do not change values or change them uniformly
          if (keys.length) {
            // Hooks change values - record changes in valuesUse so they are executed
            valuesUse = changedValues;
            options.fields = _.union(options.fields, keys);
          }
        } else {
          instances = await Promise.all(instances.map(async instance => {
            const individualOptions = {
              ...options,
              hooks: false,
              validate: false
            };
            delete individualOptions.individualHooks;

            return instance.save(individualOptions);
          }));
          updateDoneRowByRow = true;
        }
      }
    }
    let result;
    if (updateDoneRowByRow) {
      result = [instances.length, instances];
    } else if (_.isEmpty(valuesUse)
       || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {
      // only updatedAt is being passed, then skip update
      result = [0];
    } else {
      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);
      options = Utils.mapOptionFieldNames(options, this);
      options.hasTrigger = this.options ? this.options.hasTrigger : false;

      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);
      if (options.returning) {
        result = [affectedRows.length, affectedRows];
        instances = affectedRows;
      } else {
        result = [affectedRows];
      }
    }

    if (options.individualHooks) {
      await Promise.all(instances.map(instance => this.runHooks('afterUpdate', instance, options)));
      result[1] = instances;
    }
    // Run after hook
    if (options.hooks) {
      options.attributes = values;
      await this.runHooks('afterBulkUpdate', options);
      delete options.attributes;
    }
    return result;
  }

  /**
   * Run a describe query on the table.
   *
   * @param {string} [schema] schema name to search table in
   * @param {object} [options] query options
   *
   * @returns {Promise} hash of attributes and their types
   */
  static async describe(schema, options) {
    return await this.queryInterface.describeTable(this.tableName, { schema: schema || this._schema || undefined, ...options });
  }

  static _getDefaultTimestamp(attr) {
    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {
      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);
    }
    return undefined;
  }

  static _expandAttributes(options) {
    if (!_.isPlainObject(options.attributes)) {
      return;
    }
    let attributes = Object.keys(this.rawAttributes);

    if (options.attributes.exclude) {
      attributes = attributes.filter(elem => !options.attributes.exclude.includes(elem));
    }

    if (options.attributes.include) {
      attributes = attributes.concat(options.attributes.include);
    }

    options.attributes = attributes;
  }

  // Inject _scope into options.
  static _injectScope(options) {
    const scope = Utils.cloneDeep(this._scope);
    this._defaultsOptions(options, scope);
  }

  static [Symbol.for('nodejs.util.inspect.custom')]() {
    return this.name;
  }

  static hasAlias(alias) {
    return Object.prototype.hasOwnProperty.call(this.associations, alias);
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ``` SET column = column + X WHERE foo = 'bar' ``` query. To get the correct value after an increment into the Instance you should do a reload.
   *
   * @example <caption>increment number by 1</caption>
   * Model.increment('number', { where: { foo: 'bar' });
   *
   * @example <caption>increment number and count by 2</caption>
   * Model.increment(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>increment answer by 42, and decrement tries by 1</caption>
   * // `by` is ignored, as each column has its own value
   * Model.increment({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @see
   * {@link Model#reload}
   *
   * @param  {string|Array|object}  fields                       If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param  {object}               options                      increment options
   * @param  {object}               options.where                conditions hash
   * @param  {number}               [options.by=1]               The number to increment by
   * @param  {boolean}              [options.silent=false]       If true, the updatedAt timestamp will not be updated.
   * @param  {Function}             [options.logging=false]      A function that gets executed while running the query to log the sql.
   * @param  {Transaction}          [options.transaction]        Transaction to run query under
   * @param  {string}               [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async increment(fields, options) {
    options = options || {};
    if (typeof fields === 'string') fields = [fields];
    if (Array.isArray(fields)) {
      fields = fields.map(f => {
        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {
          return this.rawAttributes[f].field;
        }
        return f;
      });
    }

    this._injectScope(options);
    this._optionsMustContainWhere(options);

    options = Utils.defaults({}, options, {
      by: 1,
      where: {},
      increment: true
    });
    const isSubtraction = !options.increment;

    Utils.mapOptionFieldNames(options, this);

    const where = { ...options.where };

    // A plain object whose keys are the fields to be incremented and whose values are
    // the amounts to be incremented by.
    let incrementAmountsByField = {};
    if (Array.isArray(fields)) {
      incrementAmountsByField = {};
      for (const field of fields) {
        incrementAmountsByField[field] = options.by;
      }
    } else {
      // If the `fields` argument is not an array, then we assume it already has the
      // form necessary to be placed directly in the `incrementAmountsByField` variable.
      incrementAmountsByField = fields;
    }

    // If optimistic locking is enabled, we can take advantage that this is an
    // increment/decrement operation and send it here as well. We put `-1` for
    // decrementing because it will be subtracted, getting `-(-1)` which is `+1`
    if (this._versionAttribute) {
      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;
    }

    const extraAttributesToBeUpdated = {};

    const updatedAtAttr = this._timestampAttributes.updatedAt;
    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {
      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);
    }

    const tableName = this.getTableName(options);
    let affectedRows;
    if (isSubtraction) {
      affectedRows = await this.queryInterface.decrement(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    } else {
      affectedRows = await this.queryInterface.increment(
        this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options
      );
    }

    if (options.returning) {
      return [affectedRows, affectedRows.length];
    }

    return [affectedRows];
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql SET column = column - X WHERE foo = 'bar'``` query. To get the correct value after a decrement into the Instance you should do a reload.
   *
   * @example <caption>decrement number by 1</caption>
   * Model.decrement('number', { where: { foo: 'bar' });
   *
   * @example <caption>decrement number and count by 2</caption>
   * Model.decrement(['number', 'count'], { by: 2, where: { foo: 'bar' } });
   *
   * @example <caption>decrement answer by 42, and decrement tries by -1</caption>
   * // `by` is ignored, since each column has its own value
   * Model.decrement({ answer: 42, tries: -1}, { by: 2, where: { foo: 'bar' } });
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} options decrement options, similar to increment
   *
   * @see
   * {@link Model.increment}
   * @see
   * {@link Model#reload}
   * @since 4.36.0
   *
   * @returns {Promise<Model[],?number>} returns an array of affected rows and affected count with `options.returning` true, whenever supported by dialect
   */
  static async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  static _optionsMustContainWhere(options) {
    assert(options && options.where, 'Missing where attribute in the options parameter');
    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod,
      'Expected plain object, array or sequelize method in the options.where parameter');
  }

  /**
   * Get an object representing the query for this instance, use with `options.where`
   *
   * @param {boolean} [checkVersion=false] include version attribute in where hash
   *
   * @returns {object}
   */
  where(checkVersion) {
    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {
      result[attribute] = this.get(attribute, { raw: true });
      return result;
    }, {});

    if (_.size(where) === 0) {
      return this.constructor.options.whereCollection;
    }
    const versionAttr = this.constructor._versionAttribute;
    if (checkVersion && versionAttr) {
      where[versionAttr] = this.get(versionAttr, { raw: true });
    }
    return Utils.mapWhereFieldNames(where, this.constructor);
  }

  toString() {
    return `[object SequelizeInstance:${this.constructor.name}]`;
  }

  /**
   * Get the value of the underlying data value
   *
   * @param {string} key key to look in instance data store
   *
   * @returns {any}
   */
  getDataValue(key) {
    return this.dataValues[key];
  }

  /**
   * Update the underlying data value
   *
   * @param {string} key key to set in instance data store
   * @param {any} value new value for given key
   *
   */
  setDataValue(key, value) {
    const originalValue = this._previousDataValues[key];

    if (!_.isEqual(value, originalValue)) {
      this.changed(key, true);
    }

    this.dataValues[key] = value;
  }

  /**
   * If no key is given, returns all values of the instance, also invoking virtual getters.
   *
   * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.
   *
   * @param {string}  [key] key to get value of
   * @param {object}  [options] get options
   * @param {boolean} [options.plain=false] If set to true, included instances will be returned as plain objects
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   *
   * @returns {object|any}
   */
  get(key, options) {
    if (options === undefined && typeof key === 'object') {
      options = key;
      key = undefined;
    }

    options = options || {};

    if (key) {
      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {
        return this._customGetters[key].call(this, key, options);
      }

      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {
        if (Array.isArray(this.dataValues[key])) {
          return this.dataValues[key].map(instance => instance.get(options));
        }
        if (this.dataValues[key] instanceof Model) {
          return this.dataValues[key].get(options);
        }
        return this.dataValues[key];
      }

      return this.dataValues[key];
    }

    if (
      this._hasCustomGetters
      || options.plain && this._options.include
      || options.clone
    ) {
      const values = {};
      let _key;

      if (this._hasCustomGetters) {
        for (_key in this._customGetters) {
          if (
            this._options.attributes
            && !this._options.attributes.includes(_key)
          ) {
            continue;
          }

          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {
            values[_key] = this.get(_key, options);
          }
        }
      }

      for (_key in this.dataValues) {
        if (
          !Object.prototype.hasOwnProperty.call(values, _key)
          && Object.prototype.hasOwnProperty.call(this.dataValues, _key)
        ) {
          values[_key] = this.get(_key, options);
        }
      }

      return values;
    }

    return this.dataValues;
  }

  /**
   * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).
   * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function
   * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.
   *
   * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be
   * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.
   *
   * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).
   *
   * Set can also be used to build instances for associations, if you have values for those.
   * When using set with associations you need to make sure the property key matches the alias of the association
   * while also making sure that the proper include options have been set (from .build() or .findOne())
   *
   * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.
   *
   * @see
   * {@link Model.findAll} for more information about includes
   *
   * @param {string|object} key key to set, it can be string or object. When string it will set that key, for object it will loop over all object properties nd set them.
   * @param {any} value value to set
   * @param {object} [options] set options
   * @param {boolean} [options.raw=false] If set to true, field and virtual setters will be ignored
   * @param {boolean} [options.reset=false] Clear all previously set data values
   *
   * @returns {Model}
   */
  set(key, value, options) {
    let values;
    let originalValue;

    if (typeof key === 'object' && key !== null) {
      values = key;
      options = value || {};

      if (options.reset) {
        this.dataValues = {};
        for (const key in values) {
          this.changed(key, false);
        }
      }

      // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object
      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {
        if (Object.keys(this.dataValues).length) {
          Object.assign(this.dataValues, values);
        } else {
          this.dataValues = values;
        }
        // If raw, .changed() shouldn't be true
        this._previousDataValues = { ...this.dataValues };
      } else {
        // Loop and call set
        if (options.attributes) {
          const setKeys = data => {
            for (const k of data) {
              if (values[k] === undefined) {
                continue;
              }
              this.set(k, values[k], options);
            }
          };
          setKeys(options.attributes);
          if (this.constructor._hasVirtualAttributes) {
            setKeys(this.constructor._virtualAttributes);
          }
          if (this._options.includeNames) {
            setKeys(this._options.includeNames);
          }
        } else {
          for (const key in values) {
            this.set(key, values[key], options);
          }
        }

        if (options.raw) {
          // If raw, .changed() shouldn't be true
          this._previousDataValues = { ...this.dataValues };
        }
      }
      return this;
    }
    if (!options)
      options = {};
    if (!options.raw) {
      originalValue = this.dataValues[key];
    }

    // If not raw, and there's a custom setter
    if (!options.raw && this._customSetters[key]) {
      this._customSetters[key].call(this, value, key);
      // custom setter should have changed value, get that changed value
      // TODO: v5 make setters return new value instead of changing internal store
      const newValue = this.dataValues[key];
      if (!_.isEqual(newValue, originalValue)) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }
    } else {
      // Check if we have included models, and if this key matches the include model names/aliases
      if (this._options && this._options.include && this._options.includeNames.includes(key)) {
        // Pass it on to the include handler
        this._setInclude(key, value, options);
        return this;
      }
      // Bunch of stuff we won't do when it's raw
      if (!options.raw) {
        // If attribute is not in model definition, return
        if (!this._isAttribute(key)) {
          if (key.includes('.') && this.constructor._jsonAttributes.has(key.split('.')[0])) {
            const previousNestedValue = Dottie.get(this.dataValues, key);
            if (!_.isEqual(previousNestedValue, value)) {
              Dottie.set(this.dataValues, key, value);
              this.changed(key.split('.')[0], true);
            }
          }
          return this;
        }

        // If attempting to set primary key and primary key is already defined, return
        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {
          return this;
        }

        // If attempting to set read only attributes, return
        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {
          return this;
        }
      }

      // If there's a data type sanitizer
      if (
        !(value instanceof Utils.SequelizeMethod)
        && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)
      ) {
        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);
      }

      // Set when the value has changed and not raw
      if (
        !options.raw &&
        (
          // True when sequelize method
          (value instanceof Utils.SequelizeMethod ||
          // Check for data type type comparators
          !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || // Check default
          !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))
        )
      ) {
        this._previousDataValues[key] = originalValue;
        this.changed(key, true);
      }

      // set data value
      this.dataValues[key] = value;
    }
    return this;
  }

  setAttributes(updates) {
    return this.set(updates);
  }

  /**
   * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.
   *
   * If changed is called without an argument, it will return an array of keys that have changed.
   *
   * If changed is called without an argument and no keys have changed, it will return `false`.
   *
   * Please note that this function will return `false` when a property from a nested (for example JSON) property
   * was edited manually, you must call `changed('key', true)` manually in these cases.
   * Writing an entirely new object (eg. deep cloned) will be detected.
   *
   * @example
   * ```
   * const mdl = await MyModel.findOne();
   * mdl.myJsonField.a = 1;
   * console.log(mdl.changed()) => false
   * mdl.save(); // this will not save anything
   * mdl.changed('myJsonField', true);
   * console.log(mdl.changed()) => ['myJsonField']
   * mdl.save(); // will save
   * ```
   *
   * @param {string} [key] key to check or change status of
   * @param {any} [value] value to set
   *
   * @returns {boolean|Array}
   */
  changed(key, value) {
    if (key === undefined) {
      if (this._changed.size > 0) {
        return Array.from(this._changed);
      }
      return false;
    }
    if (value === true) {
      this._changed.add(key);
      return this;
    }
    if (value === false) {
      this._changed.delete(key);
      return this;
    }
    return this._changed.has(key);
  }

  /**
   * Returns the previous value for key from `_previousDataValues`.
   *
   * If called without a key, returns the previous values for all values which have changed
   *
   * @param {string} [key] key to get previous value of
   *
   * @returns {any|Array<any>}
   */
  previous(key) {
    if (key) {
      return this._previousDataValues[key];
    }

    return _.pickBy(this._previousDataValues, (value, key) => this.changed(key));
  }

  _setInclude(key, value, options) {
    if (!Array.isArray(value)) value = [value];
    if (value[0] instanceof Model) {
      value = value.map(instance => instance.dataValues);
    }

    const include = this._options.includeMap[key];
    const association = include.association;
    const accessor = key;
    const primaryKeyAttribute = include.model.primaryKeyAttribute;
    const childOptions = {
      isNewRecord: this.isNewRecord,
      include: include.include,
      includeNames: include.includeNames,
      includeMap: include.includeMap,
      includeValidated: true,
      raw: options.raw,
      attributes: include.originalAttributes
    };
    let isEmpty;

    if (include.originalAttributes === undefined || include.originalAttributes.length) {
      if (association.isSingleAssociation) {
        if (Array.isArray(value)) {
          value = value[0];
        }
        isEmpty = value && value[primaryKeyAttribute] === null || value === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);
      } else {
        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;
        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);
      }
    }
  }

  /**
   * Validates this instance, and if the validation passes, persists it to the database.
   *
   * Returns a Promise that resolves to the saved instance (or rejects with a `Sequelize.ValidationError`, which will have a property for each of the fields for which the validation failed, with the error message for that field).
   *
   * This method is optimized to perform an UPDATE only into the fields that changed. If nothing has changed, no SQL query will be performed.
   *
   * This method is not aware of eager loaded associations. In other words, if some other model instance (child) was eager loaded with this instance (parent), and you change something in the child, calling `save()` will simply ignore the change that happened on the child.
   *
   * @param {object}      [options] save options
   * @param {string[]}    [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {boolean}     [options.validate=true] If false, validations won't be run.
   * @param {boolean}     [options.hooks=true] Run before and after create / update + validate hooks
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   */
  async save(options) {
    if (arguments.length > 1) {
      throw new Error('The second argument was removed in favor of the options object.');
    }

    options = Utils.cloneDeep(options);
    options = _.defaults(options, {
      hooks: true,
      validate: true
    });

    if (!options.fields) {
      if (this.isNewRecord) {
        options.fields = Object.keys(this.constructor.rawAttributes);
      } else {
        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));
      }

      options.defaultFields = options.fields;
    }

    if (options.returning === undefined) {
      if (options.association) {
        options.returning = false;
      } else if (this.isNewRecord) {
        options.returning = true;
      }
    }

    const primaryKeyName = this.constructor.primaryKeyAttribute;
    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];
    const createdAtAttr = this.constructor._timestampAttributes.createdAt;
    const versionAttr = this.constructor._versionAttribute;
    const hook = this.isNewRecord ? 'Create' : 'Update';
    const wasNewRecord = this.isNewRecord;
    const now = Utils.now(this.sequelize.options.dialect);
    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;

    if (updatedAtAttr && options.fields.length >= 1 && !options.fields.includes(updatedAtAttr)) {
      options.fields.push(updatedAtAttr);
    }
    if (versionAttr && options.fields.length >= 1 && !options.fields.includes(versionAttr)) {
      options.fields.push(versionAttr);
    }

    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {
      // UpdateAtAttr might have been added as a result of Object.keys(Model.rawAttributes). In that case we have to remove it again
      _.remove(options.fields, val => val === updatedAtAttr);
      updatedAtAttr = false;
    }

    if (this.isNewRecord === true) {
      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {
        options.fields.push(createdAtAttr);
      }

      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {
        options.fields.unshift(primaryKeyName);
      }
    }

    if (this.isNewRecord === false) {
      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === undefined) {
        throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');
      }
    }

    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {
      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;
    }

    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {
      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;
    }

    // Validate
    if (options.validate) {
      await this.validate(options);
    }
    // Run before hook
    if (options.hooks) {
      const beforeHookValues = _.pick(this.dataValues, options.fields);
      let ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values
      let hookChanged;
      let afterHookValues;

      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {
        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);
      }

      await this.constructor.runHooks(`before${hook}`, this, options);
      if (options.defaultFields && !this.isNewRecord) {
        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));

        hookChanged = [];
        for (const key of Object.keys(afterHookValues)) {
          if (afterHookValues[key] !== beforeHookValues[key]) {
            hookChanged.push(key);
          }
        }

        options.fields = _.uniq(options.fields.concat(hookChanged));
      }

      if (hookChanged) {
        if (options.validate) {
          // Validate again

          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);
          await this.validate(options);
          delete options.skip;
        }
      }
    }
    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(this._options.include.filter(include => include.association instanceof BelongsTo).map(async include => {
        const instance = this.get(include.as);
        if (!instance) return;

        const includeOptions = _(Utils.cloneDeep(include))
          .omit(['association'])
          .defaults({
            transaction: options.transaction,
            logging: options.logging,
            parentRecord: this
          }).value();

        await instance.save(includeOptions);

        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });
      }));
    }
    const realFields = options.fields.filter(field => !this.constructor._virtualAttributes.has(field));
    if (!realFields.length) return this;
    if (!this.changed() && !this.isNewRecord) return this;

    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], 'field') || versionAttr;
    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);
    let query = null;
    let args = [];
    let where;

    if (this.isNewRecord) {
      query = 'insert';
      args = [this, this.constructor.getTableName(options), values, options];
    } else {
      where = this.where(true);
      if (versionAttr) {
        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;
      }
      query = 'update';
      args = [this, this.constructor.getTableName(options), values, where, options];
    }

    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);
    if (versionAttr) {
      // Check to see that a row was updated, otherwise it's an optimistic locking error.
      if (rowsUpdated < 1) {
        throw new sequelizeErrors.OptimisticLockError({
          modelName: this.constructor.name,
          values,
          where
        });
      } else {
        result.dataValues[versionAttr] = values[versionFieldName];
      }
    }

    // Transfer database generated values (defaults, autoincrement, etc)
    for (const attr of Object.keys(this.constructor.rawAttributes)) {
      if (this.constructor.rawAttributes[attr].field &&
          values[this.constructor.rawAttributes[attr].field] !== undefined &&
          this.constructor.rawAttributes[attr].field !== attr
      ) {
        values[attr] = values[this.constructor.rawAttributes[attr].field];
        delete values[this.constructor.rawAttributes[attr].field];
      }
    }
    Object.assign(values, result.dataValues);

    Object.assign(result.dataValues, values);
    if (wasNewRecord && this._options.include && this._options.include.length) {
      await Promise.all(
        this._options.include.filter(include => !(include.association instanceof BelongsTo ||
          include.parent && include.parent.association instanceof BelongsToMany)).map(async include => {
          let instances = this.get(include.as);

          if (!instances) return;
          if (!Array.isArray(instances)) instances = [instances];

          const includeOptions = _(Utils.cloneDeep(include))
            .omit(['association'])
            .defaults({
              transaction: options.transaction,
              logging: options.logging,
              parentRecord: this
            }).value();

          // Instances will be updated in place so we can safely treat HasOne like a HasMany
          await Promise.all(instances.map(async instance => {
            if (include.association instanceof BelongsToMany) {
              await instance.save(includeOptions);
              const values0 = {
                [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),
                [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),
                // Include values defined in the association
                ...include.association.through.scope
              };

              if (instance[include.association.through.model.name]) {
                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {
                  if (include.association.through.model.rawAttributes[attr]._autoGenerated ||
                    attr === include.association.foreignKey ||
                    attr === include.association.otherKey ||
                    typeof instance[include.association.through.model.name][attr] === undefined) {
                    continue;
                  }
                  values0[attr] = instance[include.association.through.model.name][attr];
                }
              }

              await include.association.throughModel.create(values0, includeOptions);
            } else {
              instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });
              Object.assign(instance, include.association.scope);
              await instance.save(includeOptions);
            }
          }));
        })
      );
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks(`after${hook}`, result, options);
    }
    for (const field of options.fields) {
      result._previousDataValues[field] = result.dataValues[field];
      this.changed(field, false);
    }
    this.isNewRecord = false;

    return result;
  }

  /**
   * Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.
   * This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,
   * all references to the Instance are updated with the new data and no new objects are created.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} [options] Options that are passed on to `Model.find`
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   *
   * @returns {Promise<Model>}
   */
  async reload(options) {
    options = Utils.defaults({
      where: this.where()
    }, options, {
      include: this._options.include || undefined
    });

    const reloaded = await this.constructor.findOne(options);
    if (!reloaded) {
      throw new sequelizeErrors.InstanceError(
        'Instance could not be reloaded because it does not exist anymore (find call returned null)'
      );
    }
    // update the internal options of the instance
    this._options = reloaded._options;
    // re-set instance values
    this.set(reloaded.dataValues, {
      raw: true,
      reset:  true && !options.attributes
    });

    return this;
  }

  /**
  * Validate the attributes of this instance according to validation rules set in the model definition.
  *
  * The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.
  *
  * @param {object} [options] Options that are passed to the validator
  * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated
  * @param {Array} [options.fields] An array of strings. Only the properties that are in this array will be validated
  * @param {boolean} [options.hooks=true] Run before and after validate hooks
  *
  * @returns {Promise}
  */
  async validate(options) {
    return new InstanceValidator(this, options).validate();
  }

  /**
   * This is the same as calling `set` and then calling `save` but it only saves the
   * exact values passed to it, making it more atomic and safer.
   *
   * @see
   * {@link Model#set}
   * @see
   * {@link Model#save}
   *
   * @param {object} values See `set`
   * @param {object} options See `save`
   *
   * @returns {Promise<Model>}
   */
  async update(values, options) {
    // Clone values so it doesn't get modified for caller scope and ignore undefined values
    values = _.omitBy(values, value => value === undefined);

    const changedBefore = this.changed() || [];

    options = options || {};
    if (Array.isArray(options)) options = { fields: options };

    options = Utils.cloneDeep(options);
    const setOptions = Utils.cloneDeep(options);
    setOptions.attributes = options.fields;
    this.set(values, setOptions);

    // Now we need to figure out which fields were actually affected by the setter.
    const sideEffects = _.without(this.changed(), ...changedBefore);
    const fields = _.union(Object.keys(values), sideEffects);

    if (!options.fields) {
      options.fields = _.intersection(fields, this.changed());
      options.defaultFields = options.fields;
    }

    return await this.save(options);
  }

  /**
   * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.
   *
   * @param {object}      [options={}] destroy options
   * @param {boolean}     [options.force=false] If set to true, paranoid models will actually be deleted
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   *
   * @returns {Promise}
   */
  async destroy(options) {
    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeDestroy', this, options);
    }
    const where = this.where(true);

    let result;
    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {
      const attributeName = this.constructor._timestampAttributes.deletedAt;
      const attribute = this.constructor.rawAttributes[attributeName];
      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')
        ? attribute.defaultValue
        : null;
      const currentValue = this.getDataValue(attributeName);
      const undefinedOrNull = currentValue == null && defaultValue == null;
      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {
        // only update timestamp if it wasn't already set
        this.setDataValue(attributeName, new Date());
      }

      result = await this.save({ ...options, hooks: false });
    } else {
      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, { type: QueryTypes.DELETE, limit: null, ...options });
    }
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterDestroy', this, options);
    }
    return result;
  }

  /**
   * Helper method to determine if a instance is "soft deleted".  This is
   * particularly useful if the implementer renamed the `deletedAt` attribute
   * to something different.  This method requires `paranoid` to be enabled.
   *
   * @returns {boolean}
   */
  isSoftDeleted() {
    if (!this.constructor._timestampAttributes.deletedAt) {
      throw new Error('Model is not paranoid');
    }

    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];
    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;
    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;
    const isSet = deletedAt !== defaultValue;

    return isSet;
  }

  /**
   * Restore the row corresponding to this instance. Only available for paranoid models.
   *
   * @param {object}      [options={}] restore options
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   *
   * @returns {Promise}
   */
  async restore(options) {
    if (!this.constructor._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');

    options = {
      hooks: true,
      force: false,
      ...options
    };

    // Run before hook
    if (options.hooks) {
      await this.constructor.runHooks('beforeRestore', this, options);
    }
    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;
    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];
    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, 'defaultValue') ? deletedAtAttribute.defaultValue : null;

    this.setDataValue(deletedAtCol, deletedAtDefaultValue);
    const result = await this.save({ ...options, hooks: false, omitNull: false });
    // Run after hook
    if (options.hooks) {
      await this.constructor.runHooks('afterRestore', this, options);
      return result;
    }
    return result;
  }

  /**
   * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a
   * ```sql
   * SET column = column + X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.increment('number') // increment number by 1
   *
   * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2
   *
   * // increment answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.increment({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   *
   * @param {string|Array|object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.
   * @param {object} [options] options
   * @param {number} [options.by=1] The number to increment by
   * @param {boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise<Model>}
   * @since 4.0.0
   */
  async increment(fields, options) {
    const identifier = this.where();

    options = Utils.cloneDeep(options);
    options.where = { ...options.where, ...identifier };
    options.instance = this;

    await this.constructor.increment(fields, options);

    return this;
  }

  /**
   * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a
   * ```sql
   * SET column = column - X
   * ```
   * query. The updated instance will be returned by default in Postgres. However, in other dialects, you will need to do a reload to get the new values.
   *
   * @example
   * instance.decrement('number') // decrement number by 1
   *
   * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2
   *
   * // decrement answer by 42, and tries by 1.
   * // `by` is ignored, since each column has its own value
   * instance.decrement({ answer: 42, tries: 1}, { by: 2 })
   *
   * @see
   * {@link Model#reload}
   * @param {string|Array|object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given
   * @param {object}      [options] decrement options
   * @param {number}      [options.by=1] The number to decrement by
   * @param {boolean}     [options.silent=false] If true, the updatedAt timestamp will not be updated.
   * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Transaction} [options.transaction] Transaction to run query under
   * @param {string}      [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}     [options.returning=true] Append RETURNING * to get back auto generated values (Postgres only)
   *
   * @returns {Promise}
   */
  async decrement(fields, options) {
    return this.increment(fields, {
      by: 1,
      ...options,
      increment: false
    });
  }

  /**
   * Check whether this and `other` Instance refer to the same row
   *
   * @param {Model} other Other instance to compare against
   *
   * @returns {boolean}
   */
  equals(other) {
    if (!other || !other.constructor) {
      return false;
    }

    if (!(other instanceof this.constructor)) {
      return false;
    }

    return this.constructor.primaryKeyAttributes.every(attribute => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));
  }

  /**
   * Check if this is equal to one of `others` by calling equals
   *
   * @param {Array<Model>} others An array of instances to check against
   *
   * @returns {boolean}
   */
  equalsOneOf(others) {
    return others.some(other => this.equals(other));
  }

  setValidators(attribute, validators) {
    this.validators[attribute] = validators;
  }

  /**
   * Convert the instance to a JSON representation.
   * Proxies to calling `get` with no keys.
   * This means get all values gotten from the DB, and apply all custom getters.
   *
   * @see
   * {@link Model#get}
   *
   * @returns {object}
   */
  toJSON() {
    return _.cloneDeep(
      this.get({
        plain: true
      })
    );
  }

  /**
   * Creates a 1:m association between this (the source) and the provided target.
   * The foreign key is added on the target.
   *
   * @param {Model}               target Target model
   * @param {object}              [options] hasMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string|object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}              [options.onUpdate='CASCADE'] Set `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {HasMany}
   *
   * @example
   * User.hasMany(Profile) // This will add userId to the profile table
   */
  static hasMany(target, options) {} // eslint-disable-line

  /**
   * Create an N:M association with a join table. Defining `through` is required.
   *
   * @param {Model}               target Target model
   * @param {object}              options belongsToMany association options
   * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {Model|string|object} options.through The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.
   * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.
   * @param {object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)
   * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)
   * @param {string|object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target
   * @param {string|object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string|object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)
   * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps
   * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m
   * @param {string}              [options.onUpdate='CASCADE'] Sets `ON UPDATE`
   * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsToMany}
   *
   * @example
   * // Automagically generated join model
   * User.belongsToMany(Project, { through: 'UserProjects' })
   * Project.belongsToMany(User, { through: 'UserProjects' })
   *
   * // Join model with additional attributes
   * const UserProjects = sequelize.define('UserProjects', {
   *   started: Sequelize.BOOLEAN
   * })
   * User.belongsToMany(Project, { through: UserProjects })
   * Project.belongsToMany(User, { through: UserProjects })
   */
  static belongsToMany(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the target.
   *
   * @param {Model}           target Target model
   * @param {object}          [options] hasOne association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source
   * @param {string}          [options.sourceKey] The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   * @param {string}          [options.uniqueKey] The custom name for unique constraint.
   *
   * @returns {HasOne}
   *
   * @example
   * User.hasOne(Profile) // This will add userId to the profile table
   */
  static hasOne(target, options) {} // eslint-disable-line

  /**
   * Creates an association between this (the source) and the provided target. The foreign key is added on the source.
   *
   * @param {Model}           target The target model
   * @param {object}          [options] belongsTo association options
   * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks
   * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target
   * @param {string|object}   [options.foreignKey] The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target
   * @param {string}          [options.targetKey] The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table
   * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise
   * @param {string}          [options.onUpdate='CASCADE'] Sets 'ON UPDATE'
   * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.
   *
   * @returns {BelongsTo}
   *
   * @example
   * Profile.belongsTo(User) // This will add userId to the profile table
   */
  static belongsTo(target, options) {} // eslint-disable-line
}

Object.assign(Model, associationsMixin);
Hooks.applyTo(Model, true);

module.exports = Model;


/***/ }),

/***/ "./node_modules/sequelize/lib/operators.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/operators.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * Operator symbols to be used when querying data
 *
 * @see {@link Model#where}
 *
 * @property eq
 * @property ne
 * @property gte
 * @property gt
 * @property lte
 * @property lt
 * @property not
 * @property is
 * @property in
 * @property notIn
 * @property like
 * @property notLike
 * @property iLike
 * @property notILike
 * @property startsWith
 * @property endsWith
 * @property substring
 * @property regexp
 * @property notRegexp
 * @property iRegexp
 * @property notIRegexp
 * @property between
 * @property notBetween
 * @property overlap
 * @property contains
 * @property contained
 * @property adjacent
 * @property strictLeft
 * @property strictRight
 * @property noExtendRight
 * @property noExtendLeft
 * @property and
 * @property or
 * @property any
 * @property all
 * @property values
 * @property col
 * @property placeholder
 * @property join
 */
const Op = {
  eq: Symbol.for('eq'),
  ne: Symbol.for('ne'),
  gte: Symbol.for('gte'),
  gt: Symbol.for('gt'),
  lte: Symbol.for('lte'),
  lt: Symbol.for('lt'),
  not: Symbol.for('not'),
  is: Symbol.for('is'),
  in: Symbol.for('in'),
  notIn: Symbol.for('notIn'),
  like: Symbol.for('like'),
  notLike: Symbol.for('notLike'),
  iLike: Symbol.for('iLike'),
  notILike: Symbol.for('notILike'),
  startsWith: Symbol.for('startsWith'),
  endsWith: Symbol.for('endsWith'),
  substring: Symbol.for('substring'),
  regexp: Symbol.for('regexp'),
  notRegexp: Symbol.for('notRegexp'),
  iRegexp: Symbol.for('iRegexp'),
  notIRegexp: Symbol.for('notIRegexp'),
  between: Symbol.for('between'),
  notBetween: Symbol.for('notBetween'),
  overlap: Symbol.for('overlap'),
  contains: Symbol.for('contains'),
  contained: Symbol.for('contained'),
  adjacent: Symbol.for('adjacent'),
  strictLeft: Symbol.for('strictLeft'),
  strictRight: Symbol.for('strictRight'),
  noExtendRight: Symbol.for('noExtendRight'),
  noExtendLeft: Symbol.for('noExtendLeft'),
  and: Symbol.for('and'),
  or: Symbol.for('or'),
  any: Symbol.for('any'),
  all: Symbol.for('all'),
  values: Symbol.for('values'),
  col: Symbol.for('col'),
  placeholder: Symbol.for('placeholder'),
  join: Symbol.for('join'),
  match: Symbol.for('match')
};

module.exports = Op;


/***/ }),

/***/ "./node_modules/sequelize/lib/query-types.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/query-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of query types used by `sequelize.query`
 *
 * @see {@link Sequelize#query}
 *
 * @property SELECT
 * @property INSERT
 * @property UPDATE
 * @property BULKUPDATE
 * @property BULKDELETE
 * @property DELETE
 * @property UPSERT
 * @property VERSION
 * @property SHOWTABLES
 * @property SHOWINDEXES
 * @property DESCRIBE
 * @property RAW
 * @property FOREIGNKEYS
 * @property SHOWCONSTRAINTS
 */
const QueryTypes = module.exports = { // eslint-disable-line
  SELECT: 'SELECT',
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  BULKUPDATE: 'BULKUPDATE',
  BULKDELETE: 'BULKDELETE',
  DELETE: 'DELETE',
  UPSERT: 'UPSERT',
  VERSION: 'VERSION',
  SHOWTABLES: 'SHOWTABLES',
  SHOWINDEXES: 'SHOWINDEXES',
  DESCRIBE: 'DESCRIBE',
  RAW: 'RAW',
  FOREIGNKEYS: 'FOREIGNKEYS',
  SHOWCONSTRAINTS: 'SHOWCONSTRAINTS'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/sequelize.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/sequelize.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const retry = __webpack_require__(/*! retry-as-promised */ "./node_modules/retry-as-promised/index.js");
const _ = __webpack_require__(/*! lodash */ "lodash");

const Utils = __webpack_require__(/*! ./utils */ "./node_modules/sequelize/lib/utils.js");
const Model = __webpack_require__(/*! ./model */ "./node_modules/sequelize/lib/model.js");
const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const Deferrable = __webpack_require__(/*! ./deferrable */ "./node_modules/sequelize/lib/deferrable.js");
const ModelManager = __webpack_require__(/*! ./model-manager */ "./node_modules/sequelize/lib/model-manager.js");
const Transaction = __webpack_require__(/*! ./transaction */ "./node_modules/sequelize/lib/transaction.js");
const QueryTypes = __webpack_require__(/*! ./query-types */ "./node_modules/sequelize/lib/query-types.js");
const TableHints = __webpack_require__(/*! ./table-hints */ "./node_modules/sequelize/lib/table-hints.js");
const IndexHints = __webpack_require__(/*! ./index-hints */ "./node_modules/sequelize/lib/index-hints.js");
const sequelizeErrors = __webpack_require__(/*! ./errors */ "./node_modules/sequelize/lib/errors/index.js");
const Hooks = __webpack_require__(/*! ./hooks */ "./node_modules/sequelize/lib/hooks.js");
const Association = __webpack_require__(/*! ./associations/index */ "./node_modules/sequelize/lib/associations/index.js");
const Validator = __webpack_require__(/*! ./utils/validator-extras */ "./node_modules/sequelize/lib/utils/validator-extras.js").validator;
const Op = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const deprecations = __webpack_require__(/*! ./utils/deprecations */ "./node_modules/sequelize/lib/utils/deprecations.js");

/**
 * This is the main class, the entry point to sequelize.
 */
class Sequelize {
  /**
   * Instantiate sequelize with name of database, username and password.
   *
   * @example
   * // without password / with blank password
   * const sequelize = new Sequelize('database', 'username', null, {
   *   dialect: 'mysql'
   * })
   *
   * // with password and options
   * const sequelize = new Sequelize('my_database', 'john', 'doe', {
   *   dialect: 'postgres'
   * })
   *
   * // with database, username, and password in the options object
   * const sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });
   *
   * // with uri
   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})
   *
   * // option examples
   * const sequelize = new Sequelize('database', 'username', 'password', {
   *   // the sql dialect of the database
   *   // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'
   *   dialect: 'mysql',
   *
   *   // custom host; default: localhost
   *   host: 'my.server.tld',
   *   // for postgres, you can also specify an absolute path to a directory
   *   // containing a UNIX socket to connect over
   *   // host: '/sockets/psql_sockets'.
   *
   *   // custom port; default: dialect default
   *   port: 12345,
   *
   *   // custom protocol; default: 'tcp'
   *   // postgres only, useful for Heroku
   *   protocol: null,
   *
   *   // disable logging or provide a custom logging function; default: console.log
   *   logging: false,
   *
   *   // you can also pass any dialect options to the underlying dialect library
   *   // - default is empty
   *   // - currently supported: 'mysql', 'postgres', 'mssql'
   *   dialectOptions: {
   *     socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',
   *     supportBigNumbers: true,
   *     bigNumberStrings: true
   *   },
   *
   *   // the storage engine for sqlite
   *   // - default ':memory:'
   *   storage: 'path/to/database.sqlite',
   *
   *   // disable inserting undefined values as NULL
   *   // - default: false
   *   omitNull: true,
   *
   *   // a flag for using a native library or not.
   *   // in the case of 'pg' -- set this to true will allow SSL support
   *   // - default: false
   *   native: true,
   *
   *   // Specify options, which are used when sequelize.define is called.
   *   // The following example:
   *   //   define: { timestamps: false }
   *   // is basically the same as:
   *   //   Model.init(attributes, { timestamps: false });
   *   //   sequelize.define(name, attributes, { timestamps: false });
   *   // so defining the timestamps for each model will be not necessary
   *   define: {
   *     underscored: false,
   *     freezeTableName: false,
   *     charset: 'utf8',
   *     dialectOptions: {
   *       collate: 'utf8_general_ci'
   *     },
   *     timestamps: true
   *   },
   *
   *   // similar for sync: you can define this to always force sync for models
   *   sync: { force: true },
   *
   *   // pool configuration used to pool database connections
   *   pool: {
   *     max: 5,
   *     idle: 30000,
   *     acquire: 60000,
   *   },
   *
   *   // isolation level of each transaction
   *   // defaults to dialect default
   *   isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
   * })
   *
   * @param {string}   [database] The name of the database
   * @param {string}   [username=null] The username which is used to authenticate against the database.
   * @param {string}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.
   * @param {object}   [options={}] An object with options.
   * @param {string}   [options.host='localhost'] The host of the relational database.
   * @param {number}   [options.port=] The port of the relational database.
   * @param {string}   [options.username=null] The username which is used to authenticate against the database.
   * @param {string}   [options.password=null] The password which is used to authenticate against the database.
   * @param {string}   [options.database=null] The name of the database
   * @param {string}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.
   * @param {string}   [options.dialectModule=null] If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require("pg.js")' here
   * @param {string}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here
   * @param {object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library
   * @param {string}   [options.storage] Only used by sqlite. Defaults to ':memory:'
   * @param {string}   [options.protocol='tcp'] The protocol of the relational database.
   * @param {object}   [options.define={}] Default options for model definitions. See {@link Model.init}.
   * @param {object}   [options.query={}] Default options for sequelize.query
   * @param {string}   [options.schema=null] A schema to use
   * @param {object}   [options.set={}] Default options for sequelize.set
   * @param {object}   [options.sync={}] Default options for sequelize.sync
   * @param {string}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.
   * @param {string|boolean} [options.clientMinMessages='warning'] The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default.
   * @param {boolean}  [options.standardConformingStrings=true] The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something. Function may receive multiple parameters but only first one is printed by `console.log`. To print all values use `(...msg) => console.log(msg)`
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {boolean}  [options.omitNull=false] A flag that defines if null values should be passed as values to CREATE/UPDATE SQL queries or not.
   * @param {boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   * @param {boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`
   * @param {object}   [options.pool] sequelize connection pool configuration
   * @param {number}   [options.pool.max=5] Maximum number of connection in pool
   * @param {number}   [options.pool.min=0] Minimum number of connection in pool
   * @param {number}   [options.pool.idle=10000] The maximum time, in milliseconds, that a connection can be idle before being released.
   * @param {number}   [options.pool.acquire=60000] The maximum time, in milliseconds, that pool will try to get connection before throwing error
   * @param {number}   [options.pool.evict=1000] The time interval, in milliseconds, after which sequelize-pool will remove idle connections.
   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected
   * @param {number}   [options.pool.maxUses=Infinity] The number of times a connection can be used before discarding it for a replacement, [`used for eventual cluster rebalancing`](https://github.com/sequelize/sequelize-pool).
   * @param {boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {string}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.
   * @param {object}   [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {number}   [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.
   * @param {boolean}  [options.typeValidation=false] Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.
   * @param {object}   [options.operatorsAliases] String based operator alias. Pass object to limit set of aliased operators.
   * @param {object}   [options.hooks] An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here.
   * @param {boolean}  [options.minifyAliases=false] A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)
   * @param {boolean}  [options.logQueryParameters=false] A flag that defines if show bind parameters in log.
   */
  constructor(database, username, password, options) {
    let config;

    if (arguments.length === 1 && typeof database === 'object') {
      // new Sequelize({ ... options })
      options = database;
      config = _.pick(options, 'host', 'port', 'database', 'username', 'password');
    } else if (arguments.length === 1 && typeof database === 'string' || arguments.length === 2 && typeof username === 'object') {
      // new Sequelize(URI, { ... options })

      config = {};
      options = username || {};

      const urlParts = url.parse(arguments[0], true);

      options.dialect = urlParts.protocol.replace(/:$/, '');
      options.host = urlParts.hostname;

      if (options.dialect === 'sqlite' && urlParts.pathname && !urlParts.pathname.startsWith('/:memory')) {
        const storagePath = path.join(options.host, urlParts.pathname);
        options.storage = path.resolve(options.storage || storagePath);
      }

      if (urlParts.pathname) {
        config.database = urlParts.pathname.replace(/^\//, '');
      }

      if (urlParts.port) {
        options.port = urlParts.port;
      }

      if (urlParts.auth) {
        const authParts = urlParts.auth.split(':');

        config.username = authParts[0];

        if (authParts.length > 1)
          config.password = authParts.slice(1).join(':');
      }

      if (urlParts.query) {
        // Allow host query argument to override the url host.
        // Enables specifying domain socket hosts which cannot be specified via the typical
        // host part of a url.
        if (urlParts.query.host) {
          options.host = urlParts.query.host;
        }

        if (options.dialectOptions) {
          Object.assign(options.dialectOptions, urlParts.query);
        } else {
          options.dialectOptions = urlParts.query;
          if (urlParts.query.options) {
            try {
              const o = JSON.parse(urlParts.query.options);
              options.dialectOptions.options = o;
            } catch (e) {
              // Nothing to do, string is not a valid JSON
              // an thus does not need any further processing
            }
          }
        }
      }
    } else {
      // new Sequelize(database, username, password, { ... options })
      options = options || {};
      config = { database, username, password };
    }

    Sequelize.runHooks('beforeInit', config, options);

    this.options = {
      dialect: null,
      dialectModule: null,
      dialectModulePath: null,
      host: 'localhost',
      protocol: 'tcp',
      define: {},
      query: {},
      sync: {},
      timezone: '+00:00',
      clientMinMessages: 'warning',
      standardConformingStrings: true,
      // eslint-disable-next-line no-console
      logging: console.log,
      omitNull: false,
      native: false,
      replication: false,
      ssl: undefined,
      pool: {},
      quoteIdentifiers: true,
      hooks: {},
      retry: {
        max: 5,
        match: [
          'SQLITE_BUSY: database is locked'
        ]
      },
      transactionType: Transaction.TYPES.DEFERRED,
      isolationLevel: null,
      databaseVersion: 0,
      typeValidation: false,
      benchmark: false,
      minifyAliases: false,
      logQueryParameters: false,
      ...options
    };

    if (!this.options.dialect) {
      throw new Error('Dialect needs to be explicitly supplied as of v4.0.0');
    }

    if (this.options.dialect === 'postgresql') {
      this.options.dialect = 'postgres';
    }

    if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {
      throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');
    }

    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      // eslint-disable-next-line no-console
      this.options.logging = console.log;
    }

    this._setupHooks(options.hooks);

    this.config = {
      database: config.database || this.options.database,
      username: config.username || this.options.username,
      password: config.password || this.options.password || null,
      host: config.host || this.options.host,
      port: config.port || this.options.port,
      pool: this.options.pool,
      protocol: this.options.protocol,
      native: this.options.native,
      ssl: this.options.ssl,
      replication: this.options.replication,
      dialectModule: this.options.dialectModule,
      dialectModulePath: this.options.dialectModulePath,
      keepDefaultTimezone: this.options.keepDefaultTimezone,
      dialectOptions: this.options.dialectOptions
    };

    let Dialect;
    // Requiring the dialect in a switch-case to keep the
    // require calls static. (Browserify fix)
    switch (this.getDialect()) {
      case 'mariadb':
        Dialect = __webpack_require__(/*! ./dialects/mariadb */ "./node_modules/sequelize/lib/dialects/mariadb/index.js");
        break;
      case 'mssql':
        Dialect = __webpack_require__(/*! ./dialects/mssql */ "./node_modules/sequelize/lib/dialects/mssql/index.js");
        break;
      case 'mysql':
        Dialect = __webpack_require__(/*! ./dialects/mysql */ "./node_modules/sequelize/lib/dialects/mysql/index.js");
        break;
      case 'postgres':
        Dialect = __webpack_require__(/*! ./dialects/postgres */ "./node_modules/sequelize/lib/dialects/postgres/index.js");
        break;
      case 'sqlite':
        Dialect = __webpack_require__(/*! ./dialects/sqlite */ "./node_modules/sequelize/lib/dialects/sqlite/index.js");
        break;
      default:
        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, postgres, and sqlite.`);
    }

    this.dialect = new Dialect(this);
    this.dialect.queryGenerator.typeValidation = options.typeValidation;

    if (_.isPlainObject(this.options.operatorsAliases)) {
      deprecations.noStringOperators();
      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);
    } else if (typeof this.options.operatorsAliases === 'boolean') {
      deprecations.noBoolOperatorAliases();
    }

    this.queryInterface = this.dialect.queryInterface;

    /**
     * Models are stored here under the name given to `sequelize.define`
     */
    this.models = {};
    this.modelManager = new ModelManager(this);
    this.connectionManager = this.dialect.connectionManager;

    Sequelize.runHooks('afterInit', this);
  }

  /**
   * Refresh data types and parsers.
   *
   * @private
   */
  refreshTypes() {
    this.connectionManager.refreshTypeParser(DataTypes);
  }

  /**
   * Returns the specified dialect.
   *
   * @returns {string} The specified dialect.
   */
  getDialect() {
    return this.options.dialect;
  }

  /**
   * Returns the database name.
   *
   * @returns {string} The database name.
   */
  getDatabaseName() {
    return this.config.database;
  }

  /**
   * Returns an instance of QueryInterface.
   *
   * @returns {QueryInterface} An instance (singleton) of QueryInterface.
   */
  getQueryInterface() {
    return this.queryInterface;
  }

  /**
   * Define a new model, representing a table in the database.
   *
   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column
   *
   * @param {string} modelName The name of the model. The model will be stored in `sequelize.models` under this name
   * @param {object} attributes An object, where each attribute is a column of the table. See {@link Model.init}
   * @param {object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()
   *
   * @see
   * {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @returns {Model} Newly defined model
   *
   * @example
   * sequelize.define('modelName', {
   *   columnA: {
   *       type: Sequelize.BOOLEAN,
   *       validate: {
   *         is: ["[a-z]",'i'],        // will only allow letters
   *         max: 23,                  // only allow values <= 23
   *         isIn: {
   *           args: [['en', 'zh']],
   *           msg: "Must be English or Chinese"
   *         }
   *       },
   *       field: 'column_a'
   *   },
   *   columnB: Sequelize.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * });
   *
   * sequelize.models.modelName // The model will now be available in models under the name given to define
   */
  define(modelName, attributes, options = {}) {
    options.modelName = modelName;
    options.sequelize = this;

    const model = class extends Model {};

    model.init(attributes, options);

    return model;
  }

  /**
   * Fetch a Model which is already defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)
   * @returns {Model} Specified model
   */
  model(modelName) {
    if (!this.isDefined(modelName)) {
      throw new Error(`${modelName} has not been defined`);
    }

    return this.modelManager.getModel(modelName);
  }

  /**
   * Checks whether a model with the given name is defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @returns {boolean} Returns true if model is already defined, otherwise false
   */
  isDefined(modelName) {
    return !!this.modelManager.models.find(model => model.name === modelName);
  }

  /**
   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.
   *
   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.
   *
   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:
   *
   * ```js
   * const [results, metadata] = await sequelize.query('SELECT...'); // Raw query - use array destructuring
   *
   * const results = await sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }); // SELECT query - no destructuring
   * ```
   *
   * @param {string}          sql
   * @param {object}          [options={}] Query options.
   * @param {boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result
   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under
   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   * @param {boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified
   * @param {boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row
   * @param {object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.
   * @param {object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.
   * @param {boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Model}           [options.instance] A sequelize model instance whose Model is to be used to build the query result
   * @param {typeof Model}    [options.model] A sequelize model used to build the returned model instances
   * @param {object}          [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.
   * @param {string}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)
   * @param {boolean}         [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.
   * @param {object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.
   *
   * @returns {Promise}
   *
   * @see {@link Model.build} for more information about instance option.
   */

  async query(sql, options) {
    options = { ...this.options.query, ...options };

    if (options.instance && !options.model) {
      options.model = options.instance.constructor;
    }

    if (!options.instance && !options.model) {
      options.raw = true;
    }

    // map raw fields to model attributes
    if (options.mapToModel) {
      options.fieldMap = _.get(options, 'model.fieldAttributeMap', {});
    }

    options = _.defaults(options, {
      // eslint-disable-next-line no-console
      logging: Object.prototype.hasOwnProperty.call(this.options, 'logging') ? this.options.logging : console.log,
      searchPath: Object.prototype.hasOwnProperty.call(this.options, 'searchPath') ? this.options.searchPath : 'DEFAULT'
    });

    if (!options.type) {
      if (options.model || options.nest || options.plain) {
        options.type = QueryTypes.SELECT;
      } else {
        options.type = QueryTypes.RAW;
      }
    }

    //if dialect doesn't support search_path or dialect option
    //to prepend searchPath is not true delete the searchPath option
    if (
      !this.dialect.supports.searchPath ||
      !this.options.dialectOptions ||
      !this.options.dialectOptions.prependSearchPath ||
      options.supportsSearchPath === false
    ) {
      delete options.searchPath;
    } else if (!options.searchPath) {
      //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)
      //then set to DEFAULT if none is provided
      options.searchPath = 'DEFAULT';
    }

    if (typeof sql === 'object') {
      if (sql.values !== undefined) {
        if (options.replacements !== undefined) {
          throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');
        }
        options.replacements = sql.values;
      }

      if (sql.bind !== undefined) {
        if (options.bind !== undefined) {
          throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');
        }
        options.bind = sql.bind;
      }

      if (sql.query !== undefined) {
        sql = sql.query;
      }
    }

    sql = sql.trim();

    if (options.replacements && options.bind) {
      throw new Error('Both `replacements` and `bind` cannot be set at the same time');
    }

    if (options.replacements) {
      if (Array.isArray(options.replacements)) {
        sql = Utils.format([sql].concat(options.replacements), this.options.dialect);
      } else {
        sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);
      }
    }

    let bindParameters;

    if (options.bind) {
      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);
    }

    const checkTransaction = () => {
      if (options.transaction && options.transaction.finished && !options.completesTransaction) {
        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);
        error.sql = sql;
        throw error;
      }
    };

    const retryOptions = { ...this.options.retry, ...options.retry };

    return retry(async () => {
      if (options.transaction === undefined && Sequelize._cls) {
        options.transaction = Sequelize._cls.get('transaction');
      }

      checkTransaction();

      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));
      const query = new this.dialect.Query(connection, this, options);

      try {
        await this.runHooks('beforeQuery', options, query);
        checkTransaction();
        return await query.run(sql, bindParameters);
      } finally {
        await this.runHooks('afterQuery', options, query);
        if (!options.transaction) {
          await this.connectionManager.releaseConnection(connection);
        }
      }
    }, retryOptions);
  }

  /**
   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.
   * Only works for MySQL.
   *
   * @param {object}        variables Object with multiple variables.
   * @param {object}        [options] query options.
   * @param {Transaction}   [options.transaction] The transaction that the query should be executed under
   *
   * @memberof Sequelize
   *
   * @returns {Promise}
   */
  async set(variables, options) {

    // Prepare options
    options = { ...this.options.set, ...typeof options === 'object' && options };

    if (this.options.dialect !== 'mysql') {
      throw new Error('sequelize.set is only supported for mysql');
    }
    if (!options.transaction || !(options.transaction instanceof Transaction) ) {
      throw new TypeError('options.transaction is required');
    }

    // Override some options, since this isn't a SELECT
    options.raw = true;
    options.plain = true;
    options.type = 'SET';

    // Generate SQL Query
    const query =
      `SET ${
        _.map(variables, (v, k) => `@${k} := ${typeof v === 'string' ? `"${v}"` : v}`).join(', ')}`;

    return await this.query(query, options);
  }

  /**
   * Escape value.
   *
   * @param {string} value string value to escape
   *
   * @returns {string}
   */
  escape(value) {
    return this.dialect.queryGenerator.escape(value);
  }

  /**
   * Create a new database schema.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this command will do nothing.
   *
   * @see
   * {@link Model.schema}
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async createSchema(schema, options) {
    return await this.getQueryInterface().createSchema(schema, options);
  }

  /**
   * Show all defined schemas
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this will show all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async showAllSchemas(options) {
    return await this.getQueryInterface().showAllSchemas(options);
  }

  /**
   * Drop a single schema
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this drop a table matching the schema name
   *
   * @param {string} schema Name of the schema
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropSchema(schema, options) {
    return await this.getQueryInterface().dropSchema(schema, options);
  }

  /**
   * Drop all schemas.
   *
   * **Note:** this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.
   *
   * @param {object} [options={}] query options
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async dropAllSchemas(options) {
    return await this.getQueryInterface().dropAllSchemas(options);
  }

  /**
   * Sync all defined models to the DB.
   *
   * @param {object} [options={}] sync options
   * @param {boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table
   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code
   * @param {boolean|Function} [options.logging=console.log] A function that logs sql queries, or false for no logging
   * @param {string} [options.schema='public'] The schema that the tables should be created in. This can be overridden for each table in sequelize.define
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called
   * @param {boolean|object} [options.alter=false] Alters tables to fit models. Provide an object for additional configuration. Not recommended for production use. If not further configured deletes data in columns that were removed or had their type changed in the model.
   * @param {boolean} [options.alter.drop=true] Prevents any drop statements while altering a table when set to `false`
   *
   * @returns {Promise}
   */
  async sync(options) {
    options = {
      ...this.options,
      ...this.options.sync,
      ...options,
      hooks: options ? options.hooks !== false : true
    };

    if (options.match) {
      if (!options.match.test(this.config.database)) {
        throw new Error(`Database "${this.config.database}" does not match sync match parameter "${options.match}"`);
      }
    }

    if (options.hooks) {
      await this.runHooks('beforeBulkSync', options);
    }
    if (options.force) {
      await this.drop(options);
    }
    const models = [];

    // Topologically sort by foreign key constraints to give us an appropriate
    // creation order
    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      } else {
        // DB should throw an SQL error if referencing non-existent table
      }
    });

    // no models defined, just authenticate
    if (!models.length) {
      await this.authenticate(options);
    } else {
      for (const model of models) await model.sync(options);
    }
    if (options.hooks) {
      await this.runHooks('afterBulkSync', options);
    }
    return this;
  }

  /**
   * Truncate all tables defined through the sequelize models.
   * This is done by calling `Model.truncate()` on each model.
   *
   * @param {object} [options] The options passed to Model.destroy in addition to truncate
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   * @returns {Promise}
   *
   * @see
   * {@link Model.truncate} for more information
   */
  async truncate(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    if (options && options.cascade) {
      for (const model of models) await model.truncate(options);
    } else {
      await Promise.all(models.map(model => model.truncate(options)));
    }
  }

  /**
   * Drop all tables defined through this sequelize instance.
   * This is done by calling Model.drop on each model.
   *
   * @see
   * {@link Model.drop} for options
   *
   * @param {object} [options] The options passed to each call to Model.drop
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async drop(options) {
    const models = [];

    this.modelManager.forEachModel(model => {
      if (model) {
        models.push(model);
      }
    }, { reverse: false });

    for (const model of models) await model.drop(options);
  }

  /**
   * Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.
   *
   * @param {object} [options={}] query options
   *
   * @returns {Promise}
   */
  async authenticate(options) {
    options = {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT,
      ...options
    };

    await this.query('SELECT 1+1 AS result', options);

    return;
  }

  async databaseVersion(options) {
    return await this.getQueryInterface().databaseVersion(options);
  }

  /**
   * Get the fn for random based on the dialect
   *
   * @returns {Sequelize.fn}
   */
  random() {
    const dia = this.getDialect();
    if (dia === 'postgres' || dia === 'sqlite') {
      return this.fn('RANDOM');
    }
    return this.fn('RAND');
  }

  /**
   * Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.
   * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.
   *
   * @see
   * {@link Model.findAll}
   * @see
   * {@link Sequelize.define}
   * @see
   * {@link Sequelize.col}
   *
   * @param {string} fn The function you want to call
   * @param {any} args All further arguments will be passed as arguments to the function
   *
   * @since v2.0.0-dev3
   * @memberof Sequelize
   * @returns {Sequelize.fn}
   *
   * @example <caption>Convert a user's username to upper case</caption>
   * instance.update({
   *   username: sequelize.fn('upper', sequelize.col('username'))
   * });
   */
  static fn(fn, ...args) {
    return new Utils.Fn(fn, args);
  }

  /**
   * Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.
   *
   * @see
   * {@link Sequelize#fn}
   *
   * @param {string} col The name of the column
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.col}
   */
  static col(col) {
    return new Utils.Col(col);
  }

  /**
   * Creates an object representing a call to the cast function.
   *
   * @param {any} val The value to cast
   * @param {string} type The type to cast it to
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.cast}
   */
  static cast(val, type) {
    return new Utils.Cast(val, type);
  }

  /**
   * Creates an object representing a literal, i.e. something that will not be escaped.
   *
   * @param {any} val literal value
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.literal}
   */
  static literal(val) {
    return new Utils.Literal(val);
  }

  /**
   * An AND query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by AND
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.and}
   */
  static and(...args) {
    return { [Op.and]: args };
  }

  /**
   * An OR query
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {...string|object} args Each argument will be joined by OR
   * @since v2.0.0-dev3
   * @memberof Sequelize
   *
   * @returns {Sequelize.or}
   */
  static or(...args) {
    return { [Op.or]: args };
  }

  /**
   * Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {string|object} conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres/sqlite/mysql json syntax.
   * @param {string|number|boolean} [value] An optional value to compare against. Produces a string of the form "<json path> = '<value>'".
   * @memberof Sequelize
   *
   * @returns {Sequelize.json}
   */
  static json(conditionsOrPath, value) {
    return new Utils.Json(conditionsOrPath, value);
  }

  /**
   * A way of specifying attr = condition.
   *
   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The
   * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)
   *
   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.
   *
   * @see
   * {@link Model.findAll}
   *
   * @param {object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax
   * @param {symbol} [comparator='Op.eq'] operator
   * @param {string|object} logic The condition. Can be both a simply type, or a further condition (`or`, `and`, `.literal` etc.)
   * @since v2.0.0-dev3
   */
  static where(attr, comparator, logic) {
    return new Utils.Where(attr, comparator, logic);
  }

  /**
   * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see {@link Transaction}
   *
   * If you have [CLS](https://github.com/Jeff-Lewis/cls-hooked) enabled, the transaction will automatically be passed to any query that runs within the callback
   *
   * @example
   *
   * try {
   *   const transaction = await sequelize.transaction();
   *   const user = await User.findOne(..., { transaction });
   *   await user.update(..., { transaction });
   *   await transaction.commit();
   * } catch {
   *   await transaction.rollback()
   * }
   *
   * @example <caption>A syntax for automatically committing or rolling back based on the promise chain resolution is also supported</caption>
   *
   * try {
   *   await sequelize.transaction(transaction => { // Note that we pass a callback rather than awaiting the call with no arguments
   *     const user = await User.findOne(..., {transaction});
   *     await user.update(..., {transaction});
   *   });
   *   // Committed
   * } catch(err) {
   *   // Rolled back
   *   console.error(err);
   * }
   * @example <caption>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</caption>
   *
   * const cls = require('cls-hooked');
   * const namespace = cls.createNamespace('....');
   * const Sequelize = require('sequelize');
   * Sequelize.useCLS(namespace);
   *
   * // Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace
   *
   * @param {object}   [options] Transaction options
   * @param {string}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options
   * @param {string}   [options.deferrable] Sets the constraints to be deferred or immediately checked. See `Sequelize.Deferrable`. PostgreSQL Only
   * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Function} [autoCallback] The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back
   *
   * @returns {Promise}
   */
  async transaction(options, autoCallback) {
    if (typeof options === 'function') {
      autoCallback = options;
      options = undefined;
    }

    const transaction = new Transaction(this, options);

    if (!autoCallback) {
      await transaction.prepareEnvironment(false);
      return transaction;
    }

    // autoCallback provided
    return Sequelize._clsRun(async () => {
      try {
        await transaction.prepareEnvironment();
        const result = await autoCallback(transaction);
        await transaction.commit();
        return await result;
      } catch (err) {
        try {
          if (!transaction.finished) {
            await transaction.rollback();
          } else {
            // release the connection, even if we don't need to rollback
            await transaction.cleanup();
          }
        } catch (err0) {
          // ignore
        }
        throw err;
      }
    });
  }

  /**
   * Use CLS (Continuation Local Storage) with Sequelize. With Continuation
   * Local Storage, all queries within the transaction callback will
   * automatically receive the transaction object.
   *
   * CLS namespace provided is stored as `Sequelize._cls`
   *
   * @param {object} ns CLS namespace
   * @returns {object} Sequelize constructor
   */
  static useCLS(ns) {
    // check `ns` is valid CLS namespace
    if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new Error('Must provide CLS namespace');

    // save namespace as `Sequelize._cls`
    this._cls = ns;

    // return Sequelize for chaining
    return this;
  }

  /**
   * Run function in CLS context.
   * If no CLS context in use, just runs the function normally
   *
   * @private
   * @param {Function} fn Function to run
   * @returns {*} Return value of function
   */
  static _clsRun(fn) {
    const ns = Sequelize._cls;
    if (!ns) return fn();

    let res;
    ns.run(context => res = fn(context));
    return res;
  }

  log(...args) {
    let options;

    const last = _.last(args);

    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, 'logging')) {
      options = last;

      // remove options from set of logged arguments if options.logging is equal to console.log
      // eslint-disable-next-line no-console
      if (options.logging === console.log) {
        args.splice(args.length - 1, 1);
      }
    } else {
      options = this.options;
    }

    if (options.logging) {
      if (options.logging === true) {
        deprecations.noTrueLogging();
        // eslint-disable-next-line no-console
        options.logging = console.log;
      }

      // second argument is sql-timings, when benchmarking option enabled
      // eslint-disable-next-line no-console
      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {
        args = [`${args[0]} Elapsed time: ${args[1]}ms`];
      }

      options.logging(...args);
    }
  }

  /**
   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.
   *
   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want
   * to garbage collect some of them.
   *
   * @returns {Promise}
   */
  close() {
    return this.connectionManager.close();
  }

  normalizeDataType(Type) {
    let type = typeof Type === 'function' ? new Type() : Type;
    const dialectTypes = this.dialect.DataTypes || {};

    if (dialectTypes[type.key]) {
      type = dialectTypes[type.key].extend(type);
    }

    if (type instanceof DataTypes.ARRAY) {
      if (!type.type) {
        throw new Error('ARRAY is missing type definition for its values.');
      }
      if (dialectTypes[type.type.key]) {
        type.type = dialectTypes[type.type.key].extend(type.type);
      }
    }

    return type;
  }

  normalizeAttribute(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = { type: attribute };
    }

    if (!attribute.type) return attribute;

    attribute.type = this.normalizeDataType(attribute.type);

    if (Object.prototype.hasOwnProperty.call(attribute, 'defaultValue')) {
      if (typeof attribute.defaultValue === 'function' && (
        attribute.defaultValue === DataTypes.NOW ||
          attribute.defaultValue === DataTypes.UUIDV1 ||
          attribute.defaultValue === DataTypes.UUIDV4
      )) {
        attribute.defaultValue = new attribute.defaultValue();
      }
    }

    if (attribute.type instanceof DataTypes.ENUM) {
      // The ENUM is a special case where the type is an object containing the values
      if (attribute.values) {
        attribute.type.values = attribute.type.options.values = attribute.values;
      } else {
        attribute.values = attribute.type.values;
      }

      if (!attribute.values.length) {
        throw new Error('Values for ENUM have not been defined.');
      }
    }

    return attribute;
  }
}

// Aliases
Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;

/**
 * Sequelize version number.
 */
Sequelize.version = __webpack_require__(/*! ../package.json */ "./node_modules/sequelize/package.json").version;

Sequelize.options = { hooks: {} };

/**
 * @private
 */
Sequelize.Utils = Utils;

/**
 * Operators symbols to be used for querying data
 *
 * @see  {@link Operators}
 */
Sequelize.Op = Op;

/**
 * Available table hints to be used for querying data in mssql for table hints
 *
 * @see {@link TableHints}
 */
Sequelize.TableHints = TableHints;

/**
 * Available index hints to be used for querying data in mysql for index hints
 *
 * @see {@link IndexHints}
 */
Sequelize.IndexHints = IndexHints;

/**
 * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction
 *
 * @see {@link Transaction}
 * @see {@link Sequelize.transaction}
 */
Sequelize.Transaction = Transaction;

/**
 * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.
 *
 * @see {@link Sequelize}
 */
Sequelize.prototype.Sequelize = Sequelize;

/**
 * Available query types for use with `sequelize.query`
 *
 * @see {@link QueryTypes}
 */
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;

/**
 * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.
 *
 * @see https://github.com/chriso/validator.js
 */
Sequelize.prototype.Validator = Sequelize.Validator = Validator;

Sequelize.Model = Model;

Sequelize.DataTypes = DataTypes;
for (const dataType in DataTypes) {
  Sequelize[dataType] = DataTypes[dataType];
}

/**
 * A reference to the deferrable collection. Use this to access the different deferrable options.
 *
 * @see {@link Transaction.Deferrable}
 * @see {@link Sequelize#transaction}
 */
Sequelize.Deferrable = Deferrable;

/**
 * A reference to the sequelize association class.
 *
 * @see {@link Association}
 */
Sequelize.prototype.Association = Sequelize.Association = Association;

/**
 * Provide alternative version of `inflection` module to be used by `Utils.pluralize` etc.
 *
 * @param {object} _inflection - `inflection` module
 */
Sequelize.useInflection = Utils.useInflection;

/**
 * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models
 * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()
 */
Hooks.applyTo(Sequelize);
Hooks.applyTo(Sequelize.prototype);

/**
 * Expose various errors available
 */

// expose alias to BaseError
Sequelize.Error = sequelizeErrors.BaseError;

for (const error of Object.keys(sequelizeErrors)) {
  Sequelize[error] = sequelizeErrors[error];
}

module.exports = Sequelize;
module.exports.Sequelize = Sequelize;
module.exports.default = Sequelize;


/***/ }),

/***/ "./node_modules/sequelize/lib/sql-string.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/sql-string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const dataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const { logger } = __webpack_require__(/*! ./utils/logger */ "./node_modules/sequelize/lib/utils/logger.js");

function arrayToList(array, timeZone, dialect, format) {
  return array.reduce((sql, val, i) => {
    if (i !== 0) {
      sql += ', ';
    }
    if (Array.isArray(val)) {
      sql += `(${arrayToList(val, timeZone, dialect, format)})`;
    } else {
      sql += escape(val, timeZone, dialect, format);
    }
    return sql;
  }, '');
}
exports.arrayToList = arrayToList;

function escape(val, timeZone, dialect, format) {
  let prependN = false;
  if (val === undefined || val === null) {
    return 'NULL';
  }
  switch (typeof val) {
    case 'boolean':
    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0
    // for us. Postgres actually has a boolean type with true/false literals,
    // but sequelize doesn't use it yet.
      if (dialect === 'sqlite' || dialect === 'mssql') {
        return +!!val;
      }
      return (!!val).toString();
    case 'number':
      return val.toString();
    case 'string':
    // In mssql, prepend N to all quoted vals which are originally a string (for
    // unicode compatibility)
      prependN = dialect === 'mssql';
      break;
  }

  if (val instanceof Date) {
    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });
  }

  if (Buffer.isBuffer(val)) {
    if (dataTypes[dialect].BLOB) {
      return dataTypes[dialect].BLOB.prototype.stringify(val);
    }

    return dataTypes.BLOB.prototype.stringify(val);
  }

  if (Array.isArray(val)) {
    const partialEscape = escVal => escape(escVal, timeZone, dialect, format);
    if (dialect === 'postgres' && !format) {
      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });
    }
    return arrayToList(val, timeZone, dialect, format);
  }

  if (!val.replace) {
    throw new Error(`Invalid value ${logger.inspect(val)}`);
  }

  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {
    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS
    // http://stackoverflow.com/q/603572/130598
    val = val.replace(/'/g, "''");

    if (dialect === 'postgres') {
      // null character is not allowed in Postgres
      val = val.replace(/\0/g, '\\0');
    }
  } else {
    // eslint-disable-next-line no-control-regex
    val = val.replace(/[\0\n\r\b\t\\'"\x1a]/g, s => {
      switch (s) {
        case '\0': return '\\0';
        case '\n': return '\\n';
        case '\r': return '\\r';
        case '\b': return '\\b';
        case '\t': return '\\t';
        case '\x1a': return '\\Z';
        default: return `\\${s}`;
      }
    });
  }
  return `${(prependN ? "N'" : "'") + val}'`;
}
exports.escape = escape;

function format(sql, values, timeZone, dialect) {
  values = [].concat(values);

  if (typeof sql !== 'string') {
    throw new Error(`Invalid SQL string provided: ${sql}`);
  }

  return sql.replace(/\?/g, match => {
    if (!values.length) {
      return match;
    }

    return escape(values.shift(), timeZone, dialect, true);
  });
}
exports.format = format;

function formatNamedParameters(sql, values, timeZone, dialect) {
  return sql.replace(/:+(?!\d)(\w+)/g, (value, key) => {
    if ('postgres' === dialect && '::' === value.slice(0, 2)) {
      return value;
    }

    if (values[key] !== undefined) {
      return escape(values[key], timeZone, dialect, true);
    }
    throw new Error(`Named parameter "${value}" has no value in the given object.`);
  });
}
exports.formatNamedParameters = formatNamedParameters;


/***/ }),

/***/ "./node_modules/sequelize/lib/table-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/table-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * An enum of table hints to be used in mssql for querying with table hints
 *
 * @property NOLOCK
 * @property READUNCOMMITTED
 * @property UPDLOCK
 * @property REPEATABLEREAD
 * @property SERIALIZABLE
 * @property READCOMMITTED
 * @property TABLOCK
 * @property TABLOCKX
 * @property PAGLOCK
 * @property ROWLOCK
 * @property NOWAIT
 * @property READPAST
 * @property XLOCK
 * @property SNAPSHOT
 * @property NOEXPAND
 */
const TableHints = module.exports = { // eslint-disable-line
  NOLOCK: 'NOLOCK',
  READUNCOMMITTED: 'READUNCOMMITTED',
  UPDLOCK: 'UPDLOCK',
  REPEATABLEREAD: 'REPEATABLEREAD',
  SERIALIZABLE: 'SERIALIZABLE',
  READCOMMITTED: 'READCOMMITTED',
  TABLOCK: 'TABLOCK',
  TABLOCKX: 'TABLOCKX',
  PAGLOCK: 'PAGLOCK',
  ROWLOCK: 'ROWLOCK',
  NOWAIT: 'NOWAIT',
  READPAST: 'READPAST',
  XLOCK: 'XLOCK',
  SNAPSHOT: 'SNAPSHOT',
  NOEXPAND: 'NOEXPAND'
};


/***/ }),

/***/ "./node_modules/sequelize/lib/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/transaction.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/**
 * The transaction object is used to identify a running transaction.
 * It is created by calling `Sequelize.transaction()`.
 * To run a query under a transaction, you should pass the transaction in the options object.
 *
 * @class Transaction
 * @see {@link Sequelize.transaction}
 */
class Transaction {
  /**
   * Creates a new transaction instance
   *
   * @param {Sequelize} sequelize A configured sequelize Instance
   * @param {object} options An object with options
   * @param {string} [options.type] Sets the type of the transaction. Sqlite only
   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.
   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only
   */
  constructor(sequelize, options) {
    this.sequelize = sequelize;
    this.savepoints = [];
    this._afterCommitHooks = [];

    // get dialect specific transaction options
    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;

    this.options = {
      type: sequelize.options.transactionType,
      isolationLevel: sequelize.options.isolationLevel,
      readOnly: false,
      ...options
    };

    this.parent = this.options.transaction;

    if (this.parent) {
      this.id = this.parent.id;
      this.parent.savepoints.push(this);
      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;
    } else {
      this.id = this.name = generateTransactionId();
    }

    delete this.options.transaction;
  }

  /**
   * Commit the transaction
   *
   * @returns {Promise}
   */
  async commit() {
    if (this.finished) {
      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);
    }

    try {
      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);
    } finally {
      this.finished = 'commit';
      this.cleanup();
      for (const hook of this._afterCommitHooks) {
        await hook.apply(this, [this]);
      }
    }
  }

  /**
   * Rollback (abort) the transaction
   *
   * @returns {Promise}
   */
  async rollback() {
    if (this.finished) {
      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);
    }

    if (!this.connection) {
      throw new Error('Transaction cannot be rolled back because it never started');
    }

    try {
      return await this
        .sequelize
        .getQueryInterface()
        .rollbackTransaction(this, this.options);
    } finally {
      this.cleanup();
    }
  }

  /**
   * Called to acquire a connection to use and set the correct options on the connection.
   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.
   *
   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.
   * @returns {Promise}
   */
  async prepareEnvironment(useCLS) {
    let connectionPromise;

    if (useCLS === undefined) {
      useCLS = true;
    }

    if (this.parent) {
      connectionPromise = Promise.resolve(this.parent.connection);
    } else {
      const acquireOptions = { uuid: this.id };
      if (this.options.readOnly) {
        acquireOptions.type = 'SELECT';
      }
      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);
    }

    let result;
    const connection = await connectionPromise;
    this.connection = connection;
    this.connection.uuid = this.id;

    try {
      await this.begin();
      result = await this.setDeferrable();
    } catch (setupErr) {
      try {
        result = await this.rollback();
      } finally {
        throw setupErr; // eslint-disable-line no-unsafe-finally
      }
    }

    if (useCLS && this.sequelize.constructor._cls) {
      this.sequelize.constructor._cls.set('transaction', this);
    }

    return result;
  }

  async setDeferrable() {
    if (this.options.deferrable) {
      return await this
        .sequelize
        .getQueryInterface()
        .deferConstraints(this, this.options);
    }
  }

  async begin() {
    const queryInterface = this.sequelize.getQueryInterface();

    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {
      await queryInterface.startTransaction(this, this.options);
      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);
    }

    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);

    return queryInterface.startTransaction(this, this.options);
  }

  cleanup() {
    // Don't release the connection if there's a parent transaction or
    // if we've already cleaned up
    if (this.parent || this.connection.uuid === undefined) return;

    this._clearCls();
    const res = this.sequelize.connectionManager.releaseConnection(this.connection);
    this.connection.uuid = undefined;
    return res;
  }

  _clearCls() {
    const cls = this.sequelize.constructor._cls;

    if (cls) {
      if (cls.get('transaction') === this) {
        cls.set('transaction', null);
      }
    }
  }

  /**
   * A hook that is run after a transaction is committed
   *
   * @param {Function} fn   A callback function that is called with the committed transaction
   * @name afterCommit
   * @memberof Sequelize.Transaction
   */
  afterCommit(fn) {
    if (!fn || typeof fn !== 'function') {
      throw new Error('"fn" must be a function');
    }
    this._afterCommitHooks.push(fn);
  }

  /**
   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.
   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.
   * Sqlite only.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {
   *      // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property DEFERRED
   * @property IMMEDIATE
   * @property EXCLUSIVE
   */
  static get TYPES() {
    return {
      DEFERRED: 'DEFERRED',
      IMMEDIATE: 'IMMEDIATE',
      EXCLUSIVE: 'EXCLUSIVE'
    };
  }

  /**
   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.
   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.
   *
   * Pass in the desired level as the first argument:
   *
   * @example
   * try {
   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {
   *     // your transactions
   *   });
   *   // transaction has been committed. Do something after the commit if required.
   * } catch(err) {
   *   // do something with the err.
   * }
   *
   * @property READ_UNCOMMITTED
   * @property READ_COMMITTED
   * @property REPEATABLE_READ
   * @property SERIALIZABLE
   */
  static get ISOLATION_LEVELS() {
    return {
      READ_UNCOMMITTED: 'READ UNCOMMITTED',
      READ_COMMITTED: 'READ COMMITTED',
      REPEATABLE_READ: 'REPEATABLE READ',
      SERIALIZABLE: 'SERIALIZABLE'
    };
  }


  /**
   * Possible options for row locking. Used in conjunction with `find` calls:
   *
   * @example
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: t1.LOCK...
   * });
   *
   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>
   * UserModel.findAll({
   *   where: ...,
   *   include: [TaskModel, ...],
   *   transaction: t1,
   *   lock: {
   *     level: t1.LOCK...,
   *     of: UserModel
   *   }
   * });
   *
   * # UserModel will be locked but TaskModel won't!
   *
   * @example <caption>You can also skip locked rows:</caption>
   * // t1 is a transaction
   * Model.findAll({
   *   where: ...,
   *   transaction: t1,
   *   lock: true,
   *   skipLocked: true
   * });
   * # The query will now return any rows that aren't locked by another transaction
   *
   * @returns {object}
   * @property UPDATE
   * @property SHARE
   * @property KEY_SHARE Postgres 9.3+ only
   * @property NO_KEY_UPDATE Postgres 9.3+ only
   */
  static get LOCK() {
    return {
      UPDATE: 'UPDATE',
      SHARE: 'SHARE',
      KEY_SHARE: 'KEY SHARE',
      NO_KEY_UPDATE: 'NO KEY UPDATE'
    };
  }

  /**
   * Please see {@link Transaction.LOCK}
   */
  get LOCK() {
    return Transaction.LOCK;
  }
}

module.exports = Transaction;
module.exports.Transaction = Transaction;
module.exports.default = Transaction;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const DataTypes = __webpack_require__(/*! ./data-types */ "./node_modules/sequelize/lib/data-types.js");
const SqlString = __webpack_require__(/*! ./sql-string */ "./node_modules/sequelize/lib/sql-string.js");
const _ = __webpack_require__(/*! lodash */ "lodash");
const baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ "lodash/_baseIsNative");
const uuidv1 = __webpack_require__(/*! uuid */ "uuid").v1;
const uuidv4 = __webpack_require__(/*! uuid */ "uuid").v4;
const operators = __webpack_require__(/*! ./operators */ "./node_modules/sequelize/lib/operators.js");
const operatorsSet = new Set(Object.values(operators));

let inflection = __webpack_require__(/*! inflection */ "./node_modules/inflection/lib/inflection.js");

exports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ "./node_modules/sequelize/lib/utils/class-to-invokable.js").classToInvokable;
exports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ "./node_modules/sequelize/lib/utils/join-sql-fragments.js").joinSQLFragments;

function useInflection(_inflection) {
  inflection = _inflection;
}
exports.useInflection = useInflection;

function camelizeIf(str, condition) {
  let result = str;

  if (condition) {
    result = camelize(str);
  }

  return result;
}
exports.camelizeIf = camelizeIf;

function underscoredIf(str, condition) {
  let result = str;

  if (condition) {
    result = underscore(str);
  }

  return result;
}
exports.underscoredIf = underscoredIf;

function isPrimitive(val) {
  const type = typeof val;
  return type === 'string' || type === 'number' || type === 'boolean';
}
exports.isPrimitive = isPrimitive;

// Same concept as _.merge, but don't overwrite properties that have already been assigned
function mergeDefaults(a, b) {
  return _.mergeWith(a, b, (objectValue, sourceValue) => {
    // If it's an object, let _ handle it this time, we will be called again for each property
    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {
      // _.isNative includes a check for core-js and throws an error if present.
      // Depending on _baseIsNative bypasses the core-js check.
      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {
        return sourceValue || objectValue;
      }
      return objectValue;
    }
  });
}
exports.mergeDefaults = mergeDefaults;

// An alternative to _.merge, which doesn't clone its arguments
// Cloning is a bad idea because options arguments may contain references to sequelize
// models - which again reference database libs which don't like to be cloned (in particular pg-native)
function merge() {
  const result = {};

  for (const obj of arguments) {
    _.forOwn(obj, (value, key) => {
      if (value !== undefined) {
        if (!result[key]) {
          result[key] = value;
        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {
          result[key] = merge(result[key], value);
        } else if (Array.isArray(value) && Array.isArray(result[key])) {
          result[key] = value.concat(result[key]);
        } else {
          result[key] = value;
        }
      }
    });
  }

  return result;
}
exports.merge = merge;

function spliceStr(str, index, count, add) {
  return str.slice(0, index) + add + str.slice(index + count);
}
exports.spliceStr = spliceStr;

function camelize(str) {
  return str.trim().replace(/[-_\s]+(.)?/g, (match, c) => c.toUpperCase());
}
exports.camelize = camelize;

function underscore(str) {
  return inflection.underscore(str);
}
exports.underscore = underscore;

function singularize(str) {
  return inflection.singularize(str);
}
exports.singularize = singularize;

function pluralize(str) {
  return inflection.pluralize(str);
}
exports.pluralize = pluralize;

function format(arr, dialect) {
  const timeZone = null;
  // Make a clone of the array beacuse format modifies the passed args
  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);
}
exports.format = format;

function formatNamedParameters(sql, parameters, dialect) {
  const timeZone = null;
  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);
}
exports.formatNamedParameters = formatNamedParameters;

function cloneDeep(obj, onlyPlain) {
  obj = obj || {};
  return _.cloneDeepWith(obj, elem => {
    // Do not try to customize cloning of arrays or POJOs
    if (Array.isArray(elem) || _.isPlainObject(elem)) {
      return undefined;
    }

    // If we specified to clone only plain objects & arrays, we ignore everyhing else
    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances
    if (onlyPlain || typeof elem === 'object') {
      return elem;
    }

    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain
    if (elem && typeof elem.clone === 'function') {
      return elem.clone();
    }
  });
}
exports.cloneDeep = cloneDeep;

/* Expand and normalize finder options */
function mapFinderOptions(options, Model) {
  if (options.attributes && Array.isArray(options.attributes)) {
    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);
    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));
  }

  mapOptionFieldNames(options, Model);

  return options;
}
exports.mapFinderOptions = mapFinderOptions;

/* Used to map field names in attributes and where conditions */
function mapOptionFieldNames(options, Model) {
  if (Array.isArray(options.attributes)) {
    options.attributes = options.attributes.map(attr => {
      // Object lookups will force any variable to strings, we don't want that for special objects etc
      if (typeof attr !== 'string') return attr;
      // Map attributes to aliased syntax attributes
      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {
        return [Model.rawAttributes[attr].field, attr];
      }
      return attr;
    });
  }

  if (options.where && _.isPlainObject(options.where)) {
    options.where = mapWhereFieldNames(options.where, Model);
  }

  return options;
}
exports.mapOptionFieldNames = mapOptionFieldNames;

function mapWhereFieldNames(attributes, Model) {
  if (attributes) {
    getComplexKeys(attributes).forEach(attribute => {
      const rawAttribute = Model.rawAttributes[attribute];

      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {
        attributes[rawAttribute.field] = attributes[attribute];
        delete attributes[attribute];
      }

      if (_.isPlainObject(attributes[attribute])
        && !(rawAttribute && (
          rawAttribute.type instanceof DataTypes.HSTORE
          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields
        attributes[attribute] = mapOptionFieldNames({
          where: attributes[attribute]
        }, Model).where;
      }

      if (Array.isArray(attributes[attribute])) {
        attributes[attribute].forEach((where, index) => {
          if (_.isPlainObject(where)) {
            attributes[attribute][index] = mapWhereFieldNames(where, Model);
          }
        });
      }

    });
  }

  return attributes;
}
exports.mapWhereFieldNames = mapWhereFieldNames;

/* Used to map field names in values */
function mapValueFieldNames(dataValues, fields, Model) {
  const values = {};

  for (const attr of fields) {
    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {
      // Field name mapping
      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {
        values[Model.rawAttributes[attr].field] = dataValues[attr];
      } else {
        values[attr] = dataValues[attr];
      }
    }
  }

  return values;
}
exports.mapValueFieldNames = mapValueFieldNames;

function isColString(value) {
  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';
}
exports.isColString = isColString;

function canTreatArrayAsAnd(arr) {
  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);
}
exports.canTreatArrayAsAnd = canTreatArrayAsAnd;

function combineTableNames(tableName1, tableName2) {
  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;
}
exports.combineTableNames = combineTableNames;

function toDefaultValue(value, dialect) {
  if (typeof value === 'function') {
    const tmp = value();
    if (tmp instanceof DataTypes.ABSTRACT) {
      return tmp.toSql();
    }
    return tmp;
  }
  if (value instanceof DataTypes.UUIDV1) {
    return uuidv1();
  }
  if (value instanceof DataTypes.UUIDV4) {
    return uuidv4();
  }
  if (value instanceof DataTypes.NOW) {
    return now(dialect);
  }
  if (Array.isArray(value)) {
    return value.slice();
  }
  if (_.isPlainObject(value)) {
    return { ...value };
  }
  return value;
}
exports.toDefaultValue = toDefaultValue;

/**
 * Determine if the default value provided exists and can be described
 * in a db schema using the DEFAULT directive.
 *
 * @param  {*} value Any default value.
 * @returns {boolean} yes / no.
 * @private
 */
function defaultValueSchemable(value) {
  if (value === undefined) { return false; }

  // TODO this will be schemable when all supported db
  // have been normalized for this case
  if (value instanceof DataTypes.NOW) { return false; }

  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }

  return typeof value !== 'function';
}
exports.defaultValueSchemable = defaultValueSchemable;

function removeNullValuesFromHash(hash, omitNull, options) {
  let result = hash;

  options = options || {};
  options.allowNull = options.allowNull || [];

  if (omitNull) {
    const _hash = {};

    _.forIn(hash, (val, key) => {
      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {
        _hash[key] = val;
      }
    });

    result = _hash;
  }

  return result;
}
exports.removeNullValuesFromHash = removeNullValuesFromHash;

const dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);

function now(dialect) {
  const d = new Date();
  if (!dialects.has(dialect)) {
    d.setMilliseconds(0);
  }
  return d;
}
exports.now = now;

// Note: Use the `quoteIdentifier()` and `escape()` methods on the
// `QueryInterface` instead for more portable code.

const TICK_CHAR = '`';
exports.TICK_CHAR = TICK_CHAR;

function addTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return tickChar + removeTicks(s, tickChar) + tickChar;
}
exports.addTicks = addTicks;

function removeTicks(s, tickChar) {
  tickChar = tickChar || TICK_CHAR;
  return s.replace(new RegExp(tickChar, 'g'), '');
}
exports.removeTicks = removeTicks;

/**
 * Receives a tree-like object and returns a plain object which depth is 1.
 *
 * - Input:
 *
 *  {
 *    name: 'John',
 *    address: {
 *      street: 'Fake St. 123',
 *      coordinates: {
 *        longitude: 55.6779627,
 *        latitude: 12.5964313
 *      }
 *    }
 *  }
 *
 * - Output:
 *
 *  {
 *    name: 'John',
 *    address.street: 'Fake St. 123',
 *    address.coordinates.latitude: 55.6779627,
 *    address.coordinates.longitude: 12.5964313
 *  }
 *
 * @param {object} value an Object
 * @returns {object} a flattened object
 * @private
 */
function flattenObjectDeep(value) {
  if (!_.isPlainObject(value)) return value;
  const flattenedObj = {};

  function flattenObject(obj, subPath) {
    Object.keys(obj).forEach(key => {
      const pathToProperty = subPath ? `${subPath}.${key}` : key;
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        flattenObject(obj[key], pathToProperty);
      } else {
        flattenedObj[pathToProperty] = _.get(obj, key);
      }
    });
    return flattenedObj;
  }

  return flattenObject(value, undefined);
}
exports.flattenObjectDeep = flattenObjectDeep;

/**
 * Utility functions for representing SQL functions, and columns that should be escaped.
 * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.
 *
 * @private
 */
class SequelizeMethod {}
exports.SequelizeMethod = SequelizeMethod;

class Fn extends SequelizeMethod {
  constructor(fn, args) {
    super();
    this.fn = fn;
    this.args = args;
  }
  clone() {
    return new Fn(this.fn, this.args);
  }
}
exports.Fn = Fn;

class Col extends SequelizeMethod {
  constructor(col, ...args) {
    super();
    if (args.length > 0) {
      col = args;
    }
    this.col = col;
  }
}
exports.Col = Col;

class Cast extends SequelizeMethod {
  constructor(val, type, json) {
    super();
    this.val = val;
    this.type = (type || '').trim();
    this.json = json || false;
  }
}
exports.Cast = Cast;

class Literal extends SequelizeMethod {
  constructor(val) {
    super();
    this.val = val;
  }
}
exports.Literal = Literal;

class Json extends SequelizeMethod {
  constructor(conditionsOrPath, value) {
    super();
    if (_.isObject(conditionsOrPath)) {
      this.conditions = conditionsOrPath;
    } else {
      this.path = conditionsOrPath;
      if (value) {
        this.value = value;
      }
    }
  }
}
exports.Json = Json;

class Where extends SequelizeMethod {
  constructor(attribute, comparator, logic) {
    super();
    if (logic === undefined) {
      logic = comparator;
      comparator = '=';
    }

    this.attribute = attribute;
    this.comparator = comparator;
    this.logic = logic;
  }
}
exports.Where = Where;

//Collection of helper methods to make it easier to work with symbol operators

/**
 * getOperators
 *
 * @param  {object} obj
 * @returns {Array<symbol>} All operators properties of obj
 * @private
 */
function getOperators(obj) {
  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));
}
exports.getOperators = getOperators;

/**
 * getComplexKeys
 *
 * @param  {object} obj
 * @returns {Array<string|symbol>} All keys including operators
 * @private
 */
function getComplexKeys(obj) {
  return getOperators(obj).concat(Object.keys(obj));
}
exports.getComplexKeys = getComplexKeys;

/**
 * getComplexSize
 *
 * @param  {object|Array} obj
 * @returns {number}      Length of object properties including operators if obj is array returns its length
 * @private
 */
function getComplexSize(obj) {
  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;
}
exports.getComplexSize = getComplexSize;

/**
 * Returns true if a where clause is empty, even with Symbols
 *
 * @param  {object} obj
 * @returns {boolean}
 * @private
 */
function isWhereEmpty(obj) {
  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;
}
exports.isWhereEmpty = isWhereEmpty;

/**
 * Returns ENUM name by joining table and column name
 *
 * @param {string} tableName
 * @param {string} columnName
 * @returns {string}
 * @private
 */
function generateEnumName(tableName, columnName) {
  return `enum_${tableName}_${columnName}`;
}
exports.generateEnumName = generateEnumName;

/**
 * Returns an new Object which keys are camelized
 *
 * @param {object} obj
 * @returns {string}
 * @private
 */
function camelizeObjectKeys(obj) {
  const newObj = new Object();
  Object.keys(obj).forEach(key => {
    newObj[camelize(key)] = obj[key];
  });
  return newObj;
}
exports.camelizeObjectKeys = camelizeObjectKeys;

/**
 * Assigns own and inherited enumerable string and symbol keyed properties of source
 * objects to the destination object.
 *
 * https://lodash.com/docs/4.17.4#defaults
 *
 * **Note:** This method mutates `object`.
 *
 * @param {object} object The destination object.
 * @param {...object} [sources] The source objects.
 * @returns {object} Returns `object`.
 * @private
 */
function defaults(object, ...sources) {
  object = Object(object);

  sources.forEach(source => {
    if (source) {
      source = Object(source);

      getComplexKeys(source).forEach(key => {
        const value = object[key];
        if (
          value === undefined ||
            _.eq(value, Object.prototype[key]) &&
            !Object.prototype.hasOwnProperty.call(object, key)

        ) {
          object[key] = source[key];
        }
      });
    }
  });

  return object;
}
exports.defaults = defaults;

/**
 *
 * @param {object} index
 * @param {Array}  index.fields
 * @param {string} [index.name]
 * @param {string|object} tableName
 *
 * @returns {object}
 * @private
 */
function nameIndex(index, tableName) {
  if (tableName.tableName) tableName = tableName.tableName;

  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {
    const fields = index.fields.map(
      field => typeof field === 'string' ? field : field.name || field.attribute
    );
    index.name = underscore(`${tableName}_${fields.join('_')}`);
  }

  return index;
}
exports.nameIndex = nameIndex;

/**
 * Checks if 2 arrays intersect.
 *
 * @param {Array} arr1
 * @param {Array} arr2
 * @private
 */
function intersects(arr1, arr2) {
  return arr1.some(v => arr2.includes(v));
}
exports.intersects = intersects;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Wraps a constructor to not need the `new` keyword using a proxy.
 * Only used for data types.
 *
 * @param {Function} Class The class instance to wrap as invocable.
 * @returns {Proxy} Wrapped class instance.
 * @private
 */
function classToInvokable(Class) {
  return new Proxy(Class, {
    apply(Target, thisArg, args) {
      return new Target(...args);
    },
    construct(Target, args) {
      return new Target(...args);
    },
    get(target, p) {
      return target[p];
    }
  });
}
exports.classToInvokable = classToInvokable;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/deprecations.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/deprecations.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const { deprecate } = __webpack_require__(/*! util */ "util");

const noop = () => {};

exports.noRawAttributes = deprecate(noop, 'Use sequelize.fn / sequelize.literal to construct attributes', 'SEQUELIZE0001');
exports.noTrueLogging = deprecate(noop, 'The logging-option should be either a function or false. Default: console.log', 'SEQUELIZE0002');
exports.noStringOperators = deprecate(noop, 'String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators', 'SEQUELIZE0003');
exports.noBoolOperatorAliases = deprecate(noop, 'A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.', 'SEQUELIZE0004');
exports.noDoubleNestedGroup = deprecate(noop, 'Passing a double nested nested array to `group` is unsupported and will be removed in v6.', 'SEQUELIZE0005');
exports.unsupportedEngine = deprecate(noop, 'This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md', 'SEQUELIZE0006');


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function doesNotWantLeadingSpace(str) {
  return /^[;,)]/.test(str);
}
function doesNotWantTrailingSpace(str) {
  return /\($/.test(str);
}

/**
 * Joins an array of strings with a single space between them,
 * except for:
 * 
 * - Strings starting with ';', ',' and ')', which do not get a leading space.
 * - Strings ending with '(', which do not get a trailing space.
 * 
 * @param {string[]} parts
 * @returns {string}
 * @private
 */
function singleSpaceJoinHelper(parts) {
  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {
    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {
      result += part.trim();
    } else {
      result += ` ${part.trim()}`;
    }
    return {
      skipNextLeadingSpace: doesNotWantTrailingSpace(part),
      result
    };
  }, {
    skipNextLeadingSpace: true,
    result: ''
  }).result;
}

/**
 * Joins an array with a single space, auto trimming when needed.
 * 
 * Certain elements do not get leading/trailing spaces.
 * 
 * @param {any[]} array The array to be joined. Falsy values are skipped. If an
 * element is another array, this function will be called recursively on that array.
 * Otherwise, if a non-string, non-falsy value is present, a TypeError will be thrown.
 * 
 * @returns {string} The joined string.
 * 
 * @private
 */
function joinSQLFragments(array) {
  if (array.length === 0) return '';

  // Skip falsy fragments
  array = array.filter(x => x);

  // Resolve recursive calls
  array = array.map(fragment => {
    if (Array.isArray(fragment)) {
      return joinSQLFragments(fragment);
    }
    return fragment;
  });

  // Ensure strings
  for (const fragment of array) {
    if (fragment && typeof fragment !== 'string') {
      const error = new TypeError(`Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);
      error.args = array;
      error.fragment = fragment;
      throw error;
    }
  }

  // Trim fragments
  array = array.map(x => x.trim());

  // Skip full-whitespace fragments (empty after the above trim)
  array = array.filter(x => x !== '');

  return singleSpaceJoinHelper(array);
}
exports.joinSQLFragments = joinSQLFragments;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/logger.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Sequelize module for debug and deprecation messages.
 * It require a `context` for which messages will be printed.
 *
 * @module logging
 * @private
 */

const debug = __webpack_require__(/*! debug */ "debug");
const util = __webpack_require__(/*! util */ "util");

class Logger {
  constructor(config) {

    this.config = {
      context: 'sequelize',
      debug: true,
      ...config
    };
  }

  warn(message) {
    // eslint-disable-next-line no-console
    console.warn(`(${this.config.context}) Warning: ${message}`);
  }

  inspect(value) {
    return util.inspect(value, false, 3);
  }

  debugContext(name) {
    return debug(`${this.config.context}:${name}`);
  }
}

exports.logger = new Logger();

exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/sequelize/lib/utils/validator-extras.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/validator-extras.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const _ = __webpack_require__(/*! lodash */ "lodash");
const validator = _.cloneDeep(__webpack_require__(/*! validator */ "./node_modules/validator/index.js"));
const moment = __webpack_require__(/*! moment */ "moment");

const extensions = {
  extend(name, fn) {
    this[name] = fn;

    return this;
  },
  notEmpty(str) {
    return !str.match(/^[\s\t\r\n]*$/);
  },
  len(str, min, max) {
    return this.isLength(str, min, max);
  },
  isUrl(str) {
    return this.isURL(str);
  },
  isIPv6(str) {
    return this.isIP(str, 6);
  },
  isIPv4(str) {
    return this.isIP(str, 4);
  },
  notIn(str, values) {
    return !this.isIn(str, values);
  },
  regex(str, pattern, modifiers) {
    str += '';
    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {
      pattern = new RegExp(pattern, modifiers);
    }
    return str.match(pattern);
  },
  notRegex(str, pattern, modifiers) {
    return !this.regex(str, pattern, modifiers);
  },
  isDecimal(str) {
    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);
  },
  min(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number >= val;
  },
  max(str, val) {
    const number = parseFloat(str);
    return isNaN(number) || number <= val;
  },
  not(str, pattern, modifiers) {
    return this.notRegex(str, pattern, modifiers);
  },
  contains(str, elem) {
    return !!elem && str.includes(elem);
  },
  notContains(str, elem) {
    return !this.contains(str, elem);
  },
  is(str, pattern, modifiers) {
    return this.regex(str, pattern, modifiers);
  }
};
exports.extensions = extensions;

// instance based validators
validator.isImmutable = function(value, validatorArgs, field, modelInstance) {
  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];
};

// extra validators
validator.notNull = function(val) {
  return val !== null && val !== undefined;
};

// https://github.com/chriso/validator.js/blob/6.2.0/validator.js
_.forEach(extensions, (extend, key) => {
  validator[key] = extend;
});

// map isNull to isEmpty
// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125
validator.isNull = validator.isEmpty;

// isDate removed in 7.0.0
// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9
validator.isDate = function(dateString) {
  // avoid http://momentjs.com/guides/#/warnings/js-date/
  // by doing a preliminary check on `dateString`
  const parsed = Date.parse(dateString);
  if (isNaN(parsed)) {
    // fail if we can't parse it
    return false;
  }
  // otherwise convert to ISO 8601 as moment prefers
  // http://momentjs.com/docs/#/parsing/string/
  const date = new Date(parsed);
  return moment(date.toISOString()).isValid();
};

exports.validator = validator;


/***/ }),

/***/ "./node_modules/sequelize/package.json":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"sequelize","description":"Multi dialect ORM for Node.JS","version":"6.6.2","maintainers":["Sascha Depold <sascha@depold.com>","Jan Aagaard Meier <janzeh@gmail.com>","Daniel Durante <me@danieldurante.com>","Mick Hansen <mick.kasper.hansen@gmail.com>","Sushant Dhiman <sushantdhiman@outlook.com>","Pedro Augusto de Paula Barbosa <papb1996@gmail.com>"],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"index.js","types":"types","engines":{"node":">=10.0.0"},"files":["lib","types/index.d.ts","types/lib","types/type-helpers"],"license":"MIT","dependencies":{"debug":"^4.1.1","dottie":"^2.0.0","inflection":"1.12.0","lodash":"^4.17.20","moment":"^2.26.0","moment-timezone":"^0.5.31","retry-as-promised":"^3.2.0","semver":"^7.3.2","sequelize-pool":"^6.0.0","toposort-class":"^1.0.1","uuid":"^8.1.0","validator":"^10.11.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^11.0.0","@commitlint/config-angular":"^11.0.0","@types/node":"^12.12.42","@types/validator":"^10.11.0","acorn":"^8.0.4","chai":"^4.x","chai-as-promised":"^7.x","chai-datetime":"^1.6.0","cheerio":"^1.0.0-rc.3","cls-hooked":"^4.2.2","cross-env":"^7.0.2","delay":"^4.3.0","env-cmd":"^10.1.0","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^6.8.0","eslint-plugin-jsdoc":"^20.4.0","eslint-plugin-mocha":"^6.2.2","expect-type":"^0.11.0","fs-jetpack":"^4.1.0","husky":"^4.2.5","js-combinatorics":"^0.5.5","lcov-result-merger":"^3.0.0","lint-staged":"^10.2.6","mariadb":"^2.3.1","markdownlint-cli":"^0.26.0","marked":"^1.1.0","mocha":"^7.1.2","mysql2":"^2.1.0","nyc":"^15.0.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.2.1","pg-hstore":"^2.x","rimraf":"^3.0.2","semantic-release":"^17.3.0","sinon":"^9.0.2","sinon-chai":"^3.3.0","sqlite3":"^4.2.0","tedious":"8.3.0","typescript":"^4.1.3"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","mssql","orm","nodejs","object relational mapper"],"options":{"env_cmd":"-f ./test/config/.docker.env"},"commitlint":{"extends":["@commitlint/config-angular"]},"lint-staged":{"*.js":"eslint"},"husky":{"hooks":{"pre-commit":"lint-staged","commit-msg":"commitlint -E HUSKY_GIT_PARAMS"}},"release":{"branches":["v6"],"verifyConditions":["@semantic-release/npm","@semantic-release/github"]},"publishConfig":{"tag":"latest"},"scripts":{"lint":"eslint lib test --quiet","lint-docs":"markdownlint docs","test":"npm run teaser && npm run test-unit && npm run test-integration","test-docker":"npm run test-docker-unit && npm run test-docker-integration","test-docker-unit":"npm run test-unit","test-docker-integration":"env-cmd $npm_package_options_env_cmd npm run test-integration","docs":"rimraf esdoc && esdoc -c docs/esdoc-config.js && cp docs/favicon.ico esdoc/favicon.ico && cp docs/ROUTER.txt esdoc/ROUTER && node docs/run-docs-transforms.js && node docs/redirects/create-redirects.js && rimraf esdoc/file esdoc/source.html","teaser":"node scripts/teaser","test-unit":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/unit/**/*.js\\"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite","test-integration":"mocha --globals setImmediate,clearImmediate --exit --check-leaks --colors -t 30000 --reporter spec \\"test/integration/**/*.test.js\\"","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-all":"npm run test-integration-mariadb && npm run test-integration-mysql && npm run test-integration-postgres && npm run test-integration-postgres-native && npm run test-integration-mssql && npm run test-integration-sqlite","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-pgsql":"npm run test-postgres","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-postgresn":"npm run test-postgres-native","test-mssql":"cross-env DIALECT=mssql npm test","test-all":"npm run test-mariadb && npm run test-mysql && npm run test-sqlite && npm run test-postgres && npm run test-postgres-native && npm run test-mssql","test-typings":"tsc -b types/tsconfig.json && tsc -b types/test/tsconfig.json","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/integration/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly mocha -t 30000 --exit \\"test/unit/**/*.test.js\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","sscce":"env-cmd $npm_package_options_env_cmd node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb npm run sscce","sscce-mysql":"cross-env DIALECT=mysql npm run sscce","sscce-postgres":"cross-env DIALECT=postgres npm run sscce","sscce-sqlite":"cross-env DIALECT=sqlite npm run sscce","sscce-mssql":"cross-env DIALECT=mssql npm run sscce","setup-mssql":"env-cmd $npm_package_options_env_cmd ./scripts/setup-mssql","semantic-release":"semantic-release"}}');

/***/ }),

/***/ "./node_modules/toposort-class/build/toposort.js":
/*!*******************************************************!*\
  !*** ./node_modules/toposort-class/build/toposort.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Gustavo Henke and Aaron Trent
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ****/
(function( global, factory ) {
    if( true ) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var mod; }
})( this, function( exports, module ) {
    "use strict";

    function _classCallCheck( instance, Constructor ) {
        if( !(instance instanceof Constructor) ) {
            throw new TypeError( "Cannot call a class as a function" );
        }
    }

    var Toposort = (function() {
        function Toposort() {
            _classCallCheck( this, Toposort );

            this.edges = [];
            this.Toposort = Toposort;
        }

        /**
         * Adds dependency edges.
         *
         * @since   0.1.0
         * @param   {String} item               An dependent name. Must be an string and not empty
         * @param   {String[]|String} [deps]    An dependency or array of dependencies
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.add = function add( item, deps ) {
            if( typeof item !== "string" || !item ) {
                throw new TypeError( "Dependent name must be given as a not empty string" );
            }

            deps = Array.isArray( deps ) ? deps : [deps];

            if( deps.length > 0 ) {
                for( var _iterator = deps, _isArray = Array.isArray( _iterator ), _i = 0, _iterator = _isArray ?
                                                                                                      _iterator :
                                                                                                      _iterator[Symbol.iterator](); ; ) {
                    var _ref;

                    if( _isArray ) {
                        if( _i >= _iterator.length ) {
                            break;
                        }
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if( _i.done ) {
                            break;
                        }
                        _ref = _i.value;
                    }

                    var dep = _ref;

                    if( typeof dep !== "string" || !dep ) {
                        throw new TypeError( "Dependency name must be given as a not empty string" );
                    }

                    this.edges.push( [item, dep] );
                }
            } else {
                this.edges.push( [item] );
            }

            return this;
        };

        /**
         * Runs the toposorting and return an ordered array of strings
         *
         * @since   0.1.0
         * @returns {String[]}  The list of items topologically sorted.
         */

        Toposort.prototype.sort = function sort() {
            var _this = this;

            var nodes = [];

            //accumulate unique nodes into a large list
            for( var _iterator2 = this.edges, _isArray2 = Array.isArray( _iterator2 ), _i2 = 0, _iterator2 = _isArray2 ?
                                                                                                             _iterator2 :
                                                                                                             _iterator2[Symbol.iterator](); ; ) {
                var _ref2;

                if( _isArray2 ) {
                    if( _i2 >= _iterator2.length ) {
                        break;
                    }
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if( _i2.done ) {
                        break;
                    }
                    _ref2 = _i2.value;
                }

                var edge = _ref2;

                for( var _iterator3 = edge, _isArray3 = Array.isArray( _iterator3 ), _i3 = 0, _iterator3 = _isArray3 ?
                                                                                                           _iterator3 :
                                                                                                           _iterator3[Symbol.iterator](); ; ) {
                    var _ref3;

                    if( _isArray3 ) {
                        if( _i3 >= _iterator3.length ) {
                            break;
                        }
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if( _i3.done ) {
                            break;
                        }
                        _ref3 = _i3.value;
                    }

                    var node = _ref3;

                    if( nodes.indexOf( node ) === -1 ) {
                        nodes.push( node );
                    }
                }
            }

            //initialize the placement of nodes into the sorted array at the end
            var place = nodes.length;

            //initialize the sorted array with the same length as the unique nodes array
            var sorted = new Array( nodes.length );

            //define a visitor function that recursively traverses dependencies.
            var visit = function visit( node, predecessors ) {
                //check if a node is dependent of itself
                if( predecessors.length !== 0 && predecessors.indexOf( node ) !== -1 ) {
                    throw new Error( "Cyclic dependency found. " + node + " is dependent of itself.\nDependency chain: "
                                     + predecessors.join( " -> " ) + " => " + node );
                }

                var index = nodes.indexOf( node );

                //if the node still exists, traverse its dependencies
                if( index !== -1 ) {
                    var copy = false;

                    //mark the node as false to exclude it from future iterations
                    nodes[index] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator4 = _this.edges, _isArray4 = Array.isArray( _iterator4 ), _i4 = 0, _iterator4 = _isArray4 ?
                                                                                                                      _iterator4 :
                                                                                                                      _iterator4[Symbol.iterator](); ; ) {
                        var _ref4;

                        if( _isArray4 ) {
                            if( _i4 >= _iterator4.length ) {
                                break;
                            }
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if( _i4.done ) {
                                break;
                            }
                            _ref4 = _i4.value;
                        }

                        var edge = _ref4;

                        if( edge[0] === node ) {
                            //lazily create a copy of predecessors with the current node concatenated onto it
                            copy = copy || predecessors.concat( [node] );

                            //recurse to node dependencies
                            visit( edge[1], copy );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            };

            for( var i = 0; i < nodes.length; i++ ) {
                var node = nodes[i];

                //ignore nodes that have been excluded
                if( node !== false ) {
                    //mark the node as false to exclude it from future iterations
                    nodes[i] = false;

                    //loop through all edges and follow dependencies of the current node
                    for( var _iterator5 = this.edges, _isArray5 = Array.isArray( _iterator5 ), _i5 = 0, _iterator5 = _isArray5 ?
                                                                                                                     _iterator5 :
                                                                                                                     _iterator5[Symbol.iterator](); ; ) {
                        var _ref5;

                        if( _isArray5 ) {
                            if( _i5 >= _iterator5.length ) {
                                break;
                            }
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if( _i5.done ) {
                                break;
                            }
                            _ref5 = _i5.value;
                        }

                        var edge = _ref5;

                        if( edge[0] === node ) {
                            //recurse to node dependencies
                            visit( edge[1], [node] );
                        }
                    }

                    //add the node to the next place in the sorted array
                    sorted[--place] = node;
                }
            }

            return sorted;
        };

        /**
         * Clears edges
         *
         * @since   0.4.0
         * @returns {Toposort}                  The Toposort instance
         */

        Toposort.prototype.clear = function clear() {
            this.edges = [];

            return this;
        };

        return Toposort;
    })();

    module.exports = Toposort;
} );


/***/ }),

/***/ "./node_modules/toposort-class/index.js":
/*!**********************************************!*\
  !*** ./node_modules/toposort-class/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./build/toposort.js */ "./node_modules/toposort-class/build/toposort.js");


/***/ }),

/***/ "./src/configs/sequalize.ts":
/*!**********************************!*\
  !*** ./src/configs/sequalize.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.init = exports.sequelize = void 0;
var sequelize_typescript_1 = __webpack_require__(/*! sequelize-typescript */ "./node_modules/sequelize-typescript/dist/index.js");
var init = function () { return __awaiter(void 0, void 0, void 0, function () {
    var e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                exports.sequelize = new sequelize_typescript_1.Sequelize({
                    models: [__dirname + '/database/models/**/*.model.ts'],
                    modelMatch: function (filename, member) {
                        return filename.substring(0, filename.indexOf('.model')) === member.toLowerCase();
                    },
                    host: "localhost",
                    database: 'default',
                    dialect: 'mysql',
                    username: 'root',
                    password: ''
                });
                return [4, exports.sequelize.authenticate()];
            case 1:
                _a.sent();
                console.log("DB Connected");
                return [3, 3];
            case 2:
                e_1 = _a.sent();
                console.error("Unable to connect to DB", e_1);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
exports.init = init;


/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var apollo_server_1 = __webpack_require__(/*! apollo-server */ "apollo-server");
var index_1 = __importDefault(__webpack_require__(/*! ./typeDefs/index */ "./src/typeDefs/index.ts"));
var index_2 = __importDefault(__webpack_require__(/*! ./resolvers/index */ "./src/resolvers/index.ts"));
var sequalize_1 = __webpack_require__(/*! ./configs/sequalize */ "./src/configs/sequalize.ts");
var server = new apollo_server_1.ApolloServer({ typeDefs: index_1.default, resolvers: index_2.default });
server.listen()
    .then(function (_a) {
    var url = _a.url;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    console.log("Server ready at " + url + ".");
                    return [4, sequalize_1.init()];
                case 1:
                    _b.sent();
                    return [2];
            }
        });
    });
});


/***/ }),

/***/ "./node_modules/validator/index.js":
/*!*****************************************!*\
  !*** ./node_modules/validator/index.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./lib/toDate */ "./node_modules/validator/lib/toDate.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./lib/toFloat */ "./node_modules/validator/lib/toFloat.js"));

var _toInt = _interopRequireDefault(__webpack_require__(/*! ./lib/toInt */ "./node_modules/validator/lib/toInt.js"));

var _toBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/toBoolean */ "./node_modules/validator/lib/toBoolean.js"));

var _equals = _interopRequireDefault(__webpack_require__(/*! ./lib/equals */ "./node_modules/validator/lib/equals.js"));

var _contains = _interopRequireDefault(__webpack_require__(/*! ./lib/contains */ "./node_modules/validator/lib/contains.js"));

var _matches = _interopRequireDefault(__webpack_require__(/*! ./lib/matches */ "./node_modules/validator/lib/matches.js"));

var _isEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmail */ "./node_modules/validator/lib/isEmail.js"));

var _isURL = _interopRequireDefault(__webpack_require__(/*! ./lib/isURL */ "./node_modules/validator/lib/isURL.js"));

var _isMACAddress = _interopRequireDefault(__webpack_require__(/*! ./lib/isMACAddress */ "./node_modules/validator/lib/isMACAddress.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./lib/isIP */ "./node_modules/validator/lib/isIP.js"));

var _isIPRange = _interopRequireDefault(__webpack_require__(/*! ./lib/isIPRange */ "./node_modules/validator/lib/isIPRange.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./lib/isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isBoolean = _interopRequireDefault(__webpack_require__(/*! ./lib/isBoolean */ "./node_modules/validator/lib/isBoolean.js"));

var _isAlpha = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlpha */ "./node_modules/validator/lib/isAlpha.js"));

var _isAlphanumeric = _interopRequireWildcard(__webpack_require__(/*! ./lib/isAlphanumeric */ "./node_modules/validator/lib/isAlphanumeric.js"));

var _isNumeric = _interopRequireDefault(__webpack_require__(/*! ./lib/isNumeric */ "./node_modules/validator/lib/isNumeric.js"));

var _isPort = _interopRequireDefault(__webpack_require__(/*! ./lib/isPort */ "./node_modules/validator/lib/isPort.js"));

var _isLowercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isLowercase */ "./node_modules/validator/lib/isLowercase.js"));

var _isUppercase = _interopRequireDefault(__webpack_require__(/*! ./lib/isUppercase */ "./node_modules/validator/lib/isUppercase.js"));

var _isAscii = _interopRequireDefault(__webpack_require__(/*! ./lib/isAscii */ "./node_modules/validator/lib/isAscii.js"));

var _isFullWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isFullWidth */ "./node_modules/validator/lib/isFullWidth.js"));

var _isHalfWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js"));

var _isVariableWidth = _interopRequireDefault(__webpack_require__(/*! ./lib/isVariableWidth */ "./node_modules/validator/lib/isVariableWidth.js"));

var _isMultibyte = _interopRequireDefault(__webpack_require__(/*! ./lib/isMultibyte */ "./node_modules/validator/lib/isMultibyte.js"));

var _isSurrogatePair = _interopRequireDefault(__webpack_require__(/*! ./lib/isSurrogatePair */ "./node_modules/validator/lib/isSurrogatePair.js"));

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./lib/isInt */ "./node_modules/validator/lib/isInt.js"));

var _isFloat = _interopRequireWildcard(__webpack_require__(/*! ./lib/isFloat */ "./node_modules/validator/lib/isFloat.js"));

var _isDecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isDecimal */ "./node_modules/validator/lib/isDecimal.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

var _isDivisibleBy = _interopRequireDefault(__webpack_require__(/*! ./lib/isDivisibleBy */ "./node_modules/validator/lib/isDivisibleBy.js"));

var _isHexColor = _interopRequireDefault(__webpack_require__(/*! ./lib/isHexColor */ "./node_modules/validator/lib/isHexColor.js"));

var _isISRC = _interopRequireDefault(__webpack_require__(/*! ./lib/isISRC */ "./node_modules/validator/lib/isISRC.js"));

var _isMD = _interopRequireDefault(__webpack_require__(/*! ./lib/isMD5 */ "./node_modules/validator/lib/isMD5.js"));

var _isHash = _interopRequireDefault(__webpack_require__(/*! ./lib/isHash */ "./node_modules/validator/lib/isHash.js"));

var _isJWT = _interopRequireDefault(__webpack_require__(/*! ./lib/isJWT */ "./node_modules/validator/lib/isJWT.js"));

var _isJSON = _interopRequireDefault(__webpack_require__(/*! ./lib/isJSON */ "./node_modules/validator/lib/isJSON.js"));

var _isEmpty = _interopRequireDefault(__webpack_require__(/*! ./lib/isEmpty */ "./node_modules/validator/lib/isEmpty.js"));

var _isLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isLength */ "./node_modules/validator/lib/isLength.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./lib/isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isUUID = _interopRequireDefault(__webpack_require__(/*! ./lib/isUUID */ "./node_modules/validator/lib/isUUID.js"));

var _isMongoId = _interopRequireDefault(__webpack_require__(/*! ./lib/isMongoId */ "./node_modules/validator/lib/isMongoId.js"));

var _isAfter = _interopRequireDefault(__webpack_require__(/*! ./lib/isAfter */ "./node_modules/validator/lib/isAfter.js"));

var _isBefore = _interopRequireDefault(__webpack_require__(/*! ./lib/isBefore */ "./node_modules/validator/lib/isBefore.js"));

var _isIn = _interopRequireDefault(__webpack_require__(/*! ./lib/isIn */ "./node_modules/validator/lib/isIn.js"));

var _isCreditCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isCreditCard */ "./node_modules/validator/lib/isCreditCard.js"));

var _isIdentityCard = _interopRequireDefault(__webpack_require__(/*! ./lib/isIdentityCard */ "./node_modules/validator/lib/isIdentityCard.js"));

var _isISIN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISIN */ "./node_modules/validator/lib/isISIN.js"));

var _isISBN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISBN */ "./node_modules/validator/lib/isISBN.js"));

var _isISSN = _interopRequireDefault(__webpack_require__(/*! ./lib/isISSN */ "./node_modules/validator/lib/isISSN.js"));

var _isMobilePhone = _interopRequireWildcard(__webpack_require__(/*! ./lib/isMobilePhone */ "./node_modules/validator/lib/isMobilePhone.js"));

var _isCurrency = _interopRequireDefault(__webpack_require__(/*! ./lib/isCurrency */ "./node_modules/validator/lib/isCurrency.js"));

var _isISO = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO8601 */ "./node_modules/validator/lib/isISO8601.js"));

var _isRFC = _interopRequireDefault(__webpack_require__(/*! ./lib/isRFC3339 */ "./node_modules/validator/lib/isRFC3339.js"));

var _isISO31661Alpha = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha2 */ "./node_modules/validator/lib/isISO31661Alpha2.js"));

var _isISO31661Alpha2 = _interopRequireDefault(__webpack_require__(/*! ./lib/isISO31661Alpha3 */ "./node_modules/validator/lib/isISO31661Alpha3.js"));

var _isBase = _interopRequireDefault(__webpack_require__(/*! ./lib/isBase64 */ "./node_modules/validator/lib/isBase64.js"));

var _isDataURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isDataURI */ "./node_modules/validator/lib/isDataURI.js"));

var _isMagnetURI = _interopRequireDefault(__webpack_require__(/*! ./lib/isMagnetURI */ "./node_modules/validator/lib/isMagnetURI.js"));

var _isMimeType = _interopRequireDefault(__webpack_require__(/*! ./lib/isMimeType */ "./node_modules/validator/lib/isMimeType.js"));

var _isLatLong = _interopRequireDefault(__webpack_require__(/*! ./lib/isLatLong */ "./node_modules/validator/lib/isLatLong.js"));

var _isPostalCode = _interopRequireWildcard(__webpack_require__(/*! ./lib/isPostalCode */ "./node_modules/validator/lib/isPostalCode.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./lib/ltrim */ "./node_modules/validator/lib/ltrim.js"));

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./lib/rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _trim = _interopRequireDefault(__webpack_require__(/*! ./lib/trim */ "./node_modules/validator/lib/trim.js"));

var _escape = _interopRequireDefault(__webpack_require__(/*! ./lib/escape */ "./node_modules/validator/lib/escape.js"));

var _unescape = _interopRequireDefault(__webpack_require__(/*! ./lib/unescape */ "./node_modules/validator/lib/unescape.js"));

var _stripLow = _interopRequireDefault(__webpack_require__(/*! ./lib/stripLow */ "./node_modules/validator/lib/stripLow.js"));

var _whitelist = _interopRequireDefault(__webpack_require__(/*! ./lib/whitelist */ "./node_modules/validator/lib/whitelist.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./lib/blacklist */ "./node_modules/validator/lib/blacklist.js"));

var _isWhitelisted = _interopRequireDefault(__webpack_require__(/*! ./lib/isWhitelisted */ "./node_modules/validator/lib/isWhitelisted.js"));

var _normalizeEmail = _interopRequireDefault(__webpack_require__(/*! ./lib/normalizeEmail */ "./node_modules/validator/lib/normalizeEmail.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./lib/util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = '10.11.0';
var validator = {
  version: version,
  toDate: _toDate.default,
  toFloat: _toFloat.default,
  toInt: _toInt.default,
  toBoolean: _toBoolean.default,
  equals: _equals.default,
  contains: _contains.default,
  matches: _matches.default,
  isEmail: _isEmail.default,
  isURL: _isURL.default,
  isMACAddress: _isMACAddress.default,
  isIP: _isIP.default,
  isIPRange: _isIPRange.default,
  isFQDN: _isFQDN.default,
  isBoolean: _isBoolean.default,
  isAlpha: _isAlpha.default,
  isAlphaLocales: _isAlpha.locales,
  isAlphanumeric: _isAlphanumeric.default,
  isAlphanumericLocales: _isAlphanumeric.locales,
  isNumeric: _isNumeric.default,
  isPort: _isPort.default,
  isLowercase: _isLowercase.default,
  isUppercase: _isUppercase.default,
  isAscii: _isAscii.default,
  isFullWidth: _isFullWidth.default,
  isHalfWidth: _isHalfWidth.default,
  isVariableWidth: _isVariableWidth.default,
  isMultibyte: _isMultibyte.default,
  isSurrogatePair: _isSurrogatePair.default,
  isInt: _isInt.default,
  isFloat: _isFloat.default,
  isFloatLocales: _isFloat.locales,
  isDecimal: _isDecimal.default,
  isHexadecimal: _isHexadecimal.default,
  isDivisibleBy: _isDivisibleBy.default,
  isHexColor: _isHexColor.default,
  isISRC: _isISRC.default,
  isMD5: _isMD.default,
  isHash: _isHash.default,
  isJWT: _isJWT.default,
  isJSON: _isJSON.default,
  isEmpty: _isEmpty.default,
  isLength: _isLength.default,
  isByteLength: _isByteLength.default,
  isUUID: _isUUID.default,
  isMongoId: _isMongoId.default,
  isAfter: _isAfter.default,
  isBefore: _isBefore.default,
  isIn: _isIn.default,
  isCreditCard: _isCreditCard.default,
  isIdentityCard: _isIdentityCard.default,
  isISIN: _isISIN.default,
  isISBN: _isISBN.default,
  isISSN: _isISSN.default,
  isMobilePhone: _isMobilePhone.default,
  isMobilePhoneLocales: _isMobilePhone.locales,
  isPostalCode: _isPostalCode.default,
  isPostalCodeLocales: _isPostalCode.locales,
  isCurrency: _isCurrency.default,
  isISO8601: _isISO.default,
  isRFC3339: _isRFC.default,
  isISO31661Alpha2: _isISO31661Alpha.default,
  isISO31661Alpha3: _isISO31661Alpha2.default,
  isBase64: _isBase.default,
  isDataURI: _isDataURI.default,
  isMagnetURI: _isMagnetURI.default,
  isMimeType: _isMimeType.default,
  isLatLong: _isLatLong.default,
  ltrim: _ltrim.default,
  rtrim: _rtrim.default,
  trim: _trim.default,
  escape: _escape.default,
  unescape: _unescape.default,
  stripLow: _stripLow.default,
  whitelist: _whitelist.default,
  blacklist: _blacklist.default,
  isWhitelisted: _isWhitelisted.default,
  normalizeEmail: _normalizeEmail.default,
  toString: _toString.default
};
var _default = validator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/alpha.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/alpha.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.commaDecimal = exports.dotDecimal = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
var alpha = {
  'en-US': /^[A-Z]+$/i,
  'bg-BG': /^[-]+$/i,
  'cs-CZ': /^[A-Z]+$/i,
  'da-DK': /^[A-Z]+$/i,
  'de-DE': /^[A-Z]+$/i,
  'el-GR': /^[-]+$/i,
  'es-ES': /^[A-Z]+$/i,
  'fr-FR': /^[A-Z]+$/i,
  'it-IT': /^[A-Z]+$/i,
  'nb-NO': /^[A-Z]+$/i,
  'nl-NL': /^[A-Z]+$/i,
  'nn-NO': /^[A-Z]+$/i,
  'hu-HU': /^[A-Z]+$/i,
  'pl-PL': /^[A-Z]+$/i,
  'pt-PT': /^[A-Z]+$/i,
  'ru-RU': /^[-]+$/i,
  'sl-SI': /^[A-Z]+$/i,
  'sk-SK': /^[A-Z]+$/i,
  'sr-RS@latin': /^[A-Z]+$/i,
  'sr-RS': /^[-]+$/i,
  'sv-SE': /^[A-Z]+$/i,
  'tr-TR': /^[A-Z]+$/i,
  'uk-UA': /^[-I]+$/i,
  'ku-IQ': /^[]+$/i,
  ar: /^[]+$/
};
exports.alpha = alpha;
var alphanumeric = {
  'en-US': /^[0-9A-Z]+$/i,
  'bg-BG': /^[0-9-]+$/i,
  'cs-CZ': /^[0-9A-Z]+$/i,
  'da-DK': /^[0-9A-Z]+$/i,
  'de-DE': /^[0-9A-Z]+$/i,
  'el-GR': /^[0-9-]+$/i,
  'es-ES': /^[0-9A-Z]+$/i,
  'fr-FR': /^[0-9A-Z]+$/i,
  'it-IT': /^[0-9A-Z]+$/i,
  'hu-HU': /^[0-9A-Z]+$/i,
  'nb-NO': /^[0-9A-Z]+$/i,
  'nl-NL': /^[0-9A-Z]+$/i,
  'nn-NO': /^[0-9A-Z]+$/i,
  'pl-PL': /^[0-9A-Z]+$/i,
  'pt-PT': /^[0-9A-Z]+$/i,
  'ru-RU': /^[0-9-]+$/i,
  'sl-SI': /^[0-9A-Z]+$/i,
  'sk-SK': /^[0-9A-Z]+$/i,
  'sr-RS@latin': /^[0-9A-Z]+$/i,
  'sr-RS': /^[0-9-]+$/i,
  'sv-SE': /^[0-9A-Z]+$/i,
  'tr-TR': /^[0-9A-Z]+$/i,
  'uk-UA': /^[0-9-I]+$/i,
  'ku-IQ': /^[0-9]+$/i,
  ar: /^[0-9]+$/
};
exports.alphanumeric = alphanumeric;
var decimal = {
  'en-US': '.',
  ar: ''
};
exports.decimal = decimal;
var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
exports.englishLocales = englishLocales;

for (var locale, i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha['en-US'];
  alphanumeric[locale] = alphanumeric['en-US'];
  decimal[locale] = decimal['en-US'];
} // Source: http://www.localeplanet.com/java/


var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
exports.arabicLocales = arabicLocales;

for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
} // Source: https://en.wikipedia.org/wiki/Decimal_mark


var dotDecimal = [];
exports.dotDecimal = dotDecimal;
var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'es-ES', 'fr-FR', 'it-IT', 'ku-IQ', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA'];
exports.commaDecimal = commaDecimal;

for (var _i2 = 0; _i2 < dotDecimal.length; _i2++) {
  decimal[dotDecimal[_i2]] = decimal['en-US'];
}

for (var _i3 = 0; _i3 < commaDecimal.length; _i3++) {
  decimal[commaDecimal[_i3]] = ',';
}

alpha['pt-BR'] = alpha['pt-PT'];
alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
decimal['pt-BR'] = decimal['pt-PT']; // see #862

alpha['pl-Pl'] = alpha['pl-PL'];
alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
decimal['pl-Pl'] = decimal['pl-PL'];

/***/ }),

/***/ "./node_modules/validator/lib/blacklist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/blacklist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = blacklist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function blacklist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/contains.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/contains.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = contains;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, elem) {
  (0, _assertString.default)(str);
  return str.indexOf((0, _toString.default)(elem)) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/equals.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/equals.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = equals;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function equals(str, comparison) {
  (0, _assertString.default)(str);
  return str === comparison;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/escape.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/escape.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = escape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function escape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAfter.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAfter.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAfter;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAfter(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original > comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isAlpha.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAlpha.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlpha;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlpha(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alpha) {
    return _alpha.alpha[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alpha);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAlphanumeric.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isAlphanumeric.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAlphanumeric;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAlphanumeric(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString.default)(str);

  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str);
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(_alpha.alphanumeric);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isAscii.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isAscii.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isAscii;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var ascii = /^[\x00-\x7F]+$/;
/* eslint-enable no-control-regex */

function isAscii(str) {
  (0, _assertString.default)(str);
  return ascii.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBase64.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBase64.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBase64;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var notBase64 = /[^A-Z0-9+\/=]/i;

function isBase64(str) {
  (0, _assertString.default)(str);
  var len = str.length;

  if (!len || len % 4 !== 0 || notBase64.test(str)) {
    return false;
  }

  var firstPaddingChar = str.indexOf('=');
  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBefore.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isBefore.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBefore;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toDate = _interopRequireDefault(__webpack_require__(/*! ./toDate */ "./node_modules/validator/lib/toDate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBefore(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString.default)(str);
  var comparison = (0, _toDate.default)(date);
  var original = (0, _toDate.default)(str);
  return !!(original && comparison && original < comparison);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBoolean(str) {
  (0, _assertString.default)(str);
  return ['true', 'false', '1', '0'].indexOf(str) >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isByteLength.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isByteLength.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isByteLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCreditCard.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isCreditCard.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCreditCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
/* eslint-enable max-len */

function isCreditCard(str) {
  (0, _assertString.default)(str);
  var sanitized = str.replace(/[- ]+/g, '');

  if (!creditCard.test(sanitized)) {
    return false;
  }

  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble;

  for (var i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum % 10 + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return !!(sum % 10 === 0 ? sanitized : false);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isCurrency.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isCurrency.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isCurrency;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function currencyRegex(options) {
  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
  options.digits_after_decimal.forEach(function (digit, index) {
    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
  });
  var symbol = "(\\".concat(options.symbol.replace(/\./g, '\\.'), ")").concat(options.require_symbol ? '' : '?'),
      negative = '-?',
      whole_dollar_amount_without_sep = '[1-9]\\d*',
      whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
      valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
      whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
      decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : ''); // default is negative sign before symbol, but there are two other options (besides parens)

  if (options.allow_negatives && !options.parens_for_negatives) {
    if (options.negative_sign_after_digits) {
      pattern += negative;
    } else if (options.negative_sign_before_digits) {
      pattern = negative + pattern;
    }
  } // South African Rand, for example, uses R 123 (space) and R-123 (no space)


  if (options.allow_negative_sign_placeholder) {
    pattern = "( (?!\\-))?".concat(pattern);
  } else if (options.allow_space_after_symbol) {
    pattern = " ?".concat(pattern);
  } else if (options.allow_space_after_digits) {
    pattern += '( (?!$))?';
  }

  if (options.symbol_after_digits) {
    pattern += symbol;
  } else {
    pattern = symbol + pattern;
  }

  if (options.allow_negatives) {
    if (options.parens_for_negatives) {
      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
      pattern = negative + pattern;
    }
  } // ensure there's a dollar and/or decimal amount, and that
  // it doesn't start with a space or a negative sign followed by a space


  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
}

var default_currency_options = {
  symbol: '$',
  require_symbol: false,
  allow_space_after_symbol: false,
  symbol_after_digits: false,
  allow_negatives: true,
  parens_for_negatives: false,
  negative_sign_before_digits: false,
  negative_sign_after_digits: false,
  allow_negative_sign_placeholder: false,
  thousands_separator: ',',
  decimal_separator: '.',
  allow_decimal: true,
  require_decimal: false,
  digits_after_decimal: [2],
  allow_space_after_digits: false
};

function isCurrency(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_currency_options);
  return currencyRegex(options).test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDataURI.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDataURI.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDataURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validMediaType = /^[a-z]+\/[a-z0-9\-\+]+$/i;
var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;

function isDataURI(str) {
  (0, _assertString.default)(str);
  var data = str.split(',');

  if (data.length < 2) {
    return false;
  }

  var attributes = data.shift().trim().split(';');
  var schemeAndMediaType = attributes.shift();

  if (schemeAndMediaType.substr(0, 5) !== 'data:') {
    return false;
  }

  var mediaType = schemeAndMediaType.substr(5);

  if (mediaType !== '' && !validMediaType.test(mediaType)) {
    return false;
  }

  for (var i = 0; i < attributes.length; i++) {
    if (i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') {// ok
    } else if (!validAttribute.test(attributes[i])) {
      return false;
    }
  }

  for (var _i = 0; _i < data.length; _i++) {
    if (!validData.test(data[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDecimal.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isDecimal.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDecimal;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function decimalRegExp(options) {
  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
  return regExp;
}

var default_decimal_options = {
  force_decimal: false,
  decimal_digits: '1,',
  locale: 'en-US'
};
var blacklist = ['', '-', '+'];

function isDecimal(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_decimal_options);

  if (options.locale in _alpha.decimal) {
    return !(0, _includes.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
  }

  throw new Error("Invalid locale '".concat(options.locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isDivisibleBy.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isDivisibleBy.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isDivisibleBy;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toFloat = _interopRequireDefault(__webpack_require__(/*! ./toFloat */ "./node_modules/validator/lib/toFloat.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isDivisibleBy(str, num) {
  (0, _assertString.default)(str);
  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmail.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmail.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmail;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

var _isByteLength = _interopRequireDefault(__webpack_require__(/*! ./isByteLength */ "./node_modules/validator/lib/isByteLength.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};
/* eslint-disable max-len */

/* eslint-disable no-control-regex */

var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */

/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_email_options);

  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(displayName);

    if (display_email) {
      str = display_email[1];
    } else if (options.require_display_name) {
      return false;
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');
  var lower_domain = domain.toLowerCase();

  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
    /*
      Previously we removed dots for gmail addresses before validating.
      This was removed because it allows `multiple..dots@gmail.com`
      to be reported as valid, but it is not.
      Gmail only normalizes single dots, removing them from here is pointless,
      should be done in normalizeEmail
    */
    user = user.toLowerCase(); // Removing sub-address from username before gmail validation

    var username = user.split('+')[0]; // Dots are not included in gmail length restriction

    if (!(0, _isByteLength.default)(username.replace('.', ''), {
      min: 6,
      max: 30
    })) {
      return false;
    }

    var _user_parts = username.split('.');

    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }

  if (!(0, _isByteLength.default)(user, {
    max: 64
  }) || !(0, _isByteLength.default)(domain, {
    max: 254
  })) {
    return false;
  }

  if (!(0, _isFQDN.default)(domain, {
    require_tld: options.require_tld
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }

    if (!(0, _isIP.default)(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }

      var noBracketdomain = domain.substr(1, domain.length - 2);

      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
        return false;
      }
    }
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  var user_parts = user.split('.');

  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isEmpty.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isEmpty.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isEmpty;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_is_empty_options = {
  ignore_whitespace: false
};

function isEmpty(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_is_empty_options);
  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFQDN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isFQDN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFQDN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFQDN(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_fqdn_options);
  /* Remove the optional trailing dot before checking validity */

  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }

  var parts = str.split('.');

  for (var i = 0; i < parts.length; i++) {
    if (parts[i].length > 63) {
      return false;
    }
  }

  if (options.require_tld) {
    var tld = parts.pop();

    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    } // disallow spaces


    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
      return false;
    }
  }

  for (var part, _i = 0; _i < parts.length; _i++) {
    part = parts[_i];

    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }

    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    } // disallow full-width chars


    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }

    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/isFloat.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFloat;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _alpha = __webpack_require__(/*! ./alpha */ "./node_modules/validator/lib/alpha.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFloat(str, options) {
  (0, _assertString.default)(str);
  options = options || {};
  var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));

  if (str === '' || str === '.' || str === '-' || str === '+') {
    return false;
  }

  var value = parseFloat(str.replace(',', '.'));
  return float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);
}

var locales = Object.keys(_alpha.decimal);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isFullWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isFullWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isFullWidth;
exports.fullWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.fullWidth = fullWidth;

function isFullWidth(str) {
  (0, _assertString.default)(str);
  return fullWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHalfWidth.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isHalfWidth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHalfWidth;
exports.halfWidth = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
exports.halfWidth = halfWidth;

function isHalfWidth(str) {
  (0, _assertString.default)(str);
  return halfWidth.test(str);
}

/***/ }),

/***/ "./node_modules/validator/lib/isHash.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isHash.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHash;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengths = {
  md5: 32,
  md4: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8
};

function isHash(str, algorithm) {
  (0, _assertString.default)(str);
  var hash = new RegExp("^[a-f0-9]{".concat(lengths[algorithm], "}$"));
  return hash.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexColor.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isHexColor.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexColor;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

function isHexColor(str) {
  (0, _assertString.default)(str);
  return hexcolor.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isHexadecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isHexadecimal.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isHexadecimal;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hexadecimal = /^[0-9A-F]+$/i;

function isHexadecimal(str) {
  (0, _assertString.default)(str);
  return hexadecimal.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIP.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIP.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIP;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
var ipv6Block = /^[0-9A-F]{1,4}$/i;

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  } else if (version === '4') {
    if (!ipv4Maybe.test(str)) {
      return false;
    }

    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  } else if (version === '6') {
    var blocks = str.split(':');
    var foundOmissionBlock = false; // marker to indicate ::
    // At least some OS accept the last 32 bits of an IPv6 address
    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
    // and '::a.b.c.d' is deprecated, but also valid.

    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

    if (blocks.length > expectedNumberOfBlocks) {
      return false;
    } // initial or final ::


    if (str === '::') {
      return true;
    } else if (str.substr(0, 2) === '::') {
      blocks.shift();
      blocks.shift();
      foundOmissionBlock = true;
    } else if (str.substr(str.length - 2) === '::') {
      blocks.pop();
      blocks.pop();
      foundOmissionBlock = true;
    }

    for (var i = 0; i < blocks.length; ++i) {
      // test for a :: which can not be at the string start/end
      // since those cases have been handled above
      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
        if (foundOmissionBlock) {
          return false; // multiple :: in address
        }

        foundOmissionBlock = true;
      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {// it has been checked before that the last
        // block is a valid IPv4 address
      } else if (!ipv6Block.test(blocks[i])) {
        return false;
      }
    }

    if (foundOmissionBlock) {
      return blocks.length >= 1;
    }

    return blocks.length === expectedNumberOfBlocks;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIPRange.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isIPRange.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIPRange;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subnetMaybe = /^\d{1,2}$/;

function isIPRange(str) {
  (0, _assertString.default)(str);
  var parts = str.split('/'); // parts[0] -> ip, parts[1] -> subnet

  if (parts.length !== 2) {
    return false;
  }

  if (!subnetMaybe.test(parts[1])) {
    return false;
  } // Disallow preceding 0 i.e. 01, 02, ...


  if (parts[1].length > 1 && parts[1].startsWith('0')) {
    return false;
  }

  return (0, _isIP.default)(parts[0], 4) && parts[1] <= 32 && parts[1] >= 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISBN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISBN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISBN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
var isbn13Maybe = /^(?:[0-9]{13})$/;
var factor = [1, 3];

function isISBN(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isISBN(str, 10) || isISBN(str, 13);
  }

  var sanitized = str.replace(/[\s-]+/g, '');
  var checksum = 0;
  var i;

  if (version === '10') {
    if (!isbn10Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 9; i++) {
      checksum += (i + 1) * sanitized.charAt(i);
    }

    if (sanitized.charAt(9) === 'X') {
      checksum += 10 * 10;
    } else {
      checksum += 10 * sanitized.charAt(9);
    }

    if (checksum % 11 === 0) {
      return !!sanitized;
    }
  } else if (version === '13') {
    if (!isbn13Maybe.test(sanitized)) {
      return false;
    }

    for (i = 0; i < 12; i++) {
      checksum += factor[i % 2] * sanitized.charAt(i);
    }

    if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
      return !!sanitized;
    }
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISIN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISIN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISIN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

function isISIN(str) {
  (0, _assertString.default)(str);

  if (!isin.test(str)) {
    return false;
  }

  var checksumStr = str.replace(/[A-Z]/g, function (character) {
    return parseInt(character, 36);
  });
  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble = true;

  for (var i = checksumStr.length - 2; i >= 0; i--) {
    digit = checksumStr.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);

    if (shouldDouble) {
      tmpNum *= 2;

      if (tmpNum >= 10) {
        sum += tmpNum + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }

    shouldDouble = !shouldDouble;
  }

  return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha2.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha2.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha2;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
var validISO31661Alpha2CountriesCodes = ['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW'];

function isISO31661Alpha2(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha2CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO31661Alpha3.js":
/*!********************************************************!*\
  !*** ./node_modules/validator/lib/isISO31661Alpha3.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO31661Alpha3;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _includes = _interopRequireDefault(__webpack_require__(/*! ./util/includes */ "./node_modules/validator/lib/util/includes.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
var validISO31661Alpha3CountriesCodes = ['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE'];

function isISO31661Alpha3(str) {
  (0, _assertString.default)(str);
  return (0, _includes.default)(validISO31661Alpha3CountriesCodes, str.toUpperCase());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISO8601.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isISO8601.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISO8601;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */

var isValidDate = function isValidDate(str) {
  // str must have passed the ISO8601 check
  // this check is meant to catch invalid dates
  // like 2009-02-31
  // first check for ordinal dates
  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);

  if (ordinalMatch) {
    var oYear = Number(ordinalMatch[1]);
    var oDay = Number(ordinalMatch[2]); // if is leap year

    if (oYear % 4 === 0 && oYear % 100 !== 0) return oDay <= 366;
    return oDay <= 365;
  }

  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
  var year = match[1];
  var month = match[2];
  var day = match[3];
  var monthString = month ? "0".concat(month).slice(-2) : month;
  var dayString = day ? "0".concat(day).slice(-2) : day; // create a date object and compare

  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
  if (isNaN(d.getUTCFullYear())) return false;

  if (month && day) {
    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
  }

  return true;
};

function isISO8601(str, options) {
  (0, _assertString.default)(str);
  var check = iso8601.test(str);
  if (!options) return check;
  if (check && options.strict) return isValidDate(str);
  return check;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISRC.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISRC.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISRC;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;

function isISRC(str) {
  (0, _assertString.default)(str);
  return isrc.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isISSN.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isISSN.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isISSN;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var issn = '^\\d{4}-?\\d{3}[\\dX]$';

function isISSN(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString.default)(str);
  var testIssn = issn;
  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');

  if (!testIssn.test(str)) {
    return false;
  }

  var digits = str.replace('-', '').toUpperCase();
  var checksum = 0;

  for (var i = 0; i < digits.length; i++) {
    var digit = digits[i];
    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
  }

  return checksum % 11 === 0;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIdentityCard.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/isIdentityCard.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIdentityCard;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validators = {
  ES: function ES(str) {
    (0, _assertString.default)(str);
    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
    var charsValue = {
      X: 0,
      Y: 1,
      Z: 2
    };
    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E']; // sanitize user input

    var sanitized = str.trim().toUpperCase(); // validate the data structure

    if (!DNI.test(sanitized)) {
      return false;
    } // validate the control digit


    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (char) {
      return charsValue[char];
    });
    return sanitized.endsWith(controlDigits[number % 23]);
  }
};

function isIdentityCard(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
  (0, _assertString.default)(str);

  if (locale in validators) {
    return validators[locale](str);
  } else if (locale === 'any') {
    for (var key in validators) {
      if (validators.hasOwnProperty(key)) {
        var validator = validators[key];

        if (validator(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isIn.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/isIn.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isIn;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./util/toString */ "./node_modules/validator/lib/util/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isIn(str, options) {
  (0, _assertString.default)(str);
  var i;

  if (Object.prototype.toString.call(options) === '[object Array]') {
    var array = [];

    for (i in options) {
      if ({}.hasOwnProperty.call(options, i)) {
        array[i] = (0, _toString.default)(options[i]);
      }
    }

    return array.indexOf(str) >= 0;
  } else if (_typeof(options) === 'object') {
    return options.hasOwnProperty(str);
  } else if (options && typeof options.indexOf === 'function') {
    return options.indexOf(str) >= 0;
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
var intLeadingZeroes = /^[-+]?[0-9]+$/;

function isInt(str, options) {
  (0, _assertString.default)(str);
  options = options || {}; // Get the regex to use for testing, based on whether
  // leading zeroes are allowed or not.

  var regex = options.hasOwnProperty('allow_leading_zeroes') && !options.allow_leading_zeroes ? int : intLeadingZeroes; // Check min/max/lt/gt

  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isJSON.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJSON;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isJSON(str) {
  (0, _assertString.default)(str);

  try {
    var obj = JSON.parse(str);
    return !!obj && _typeof(obj) === 'object';
  } catch (e) {
    /* ignore */
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isJWT.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isJWT.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isJWT;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jwt = /^([A-Za-z0-9\-_~+\/]+[=]{0,2})\.([A-Za-z0-9\-_~+\/]+[=]{0,2})(?:\.([A-Za-z0-9\-_~+\/]+[=]{0,2}))?$/;

function isJWT(str) {
  (0, _assertString.default)(str);
  return jwt.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLatLong.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isLatLong.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;

function _default(str) {
  (0, _assertString.default)(str);
  if (!str.includes(',')) return false;
  var pair = str.split(',');
  return lat.test(pair[0]) && long.test(pair[1]);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLength.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/isLength.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLength;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable prefer-rest-params */
function isLength(str, options) {
  (0, _assertString.default)(str);
  var min;
  var max;

  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }

  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  var len = str.length - surrogatePairs.length;
  return len >= min && (typeof max === 'undefined' || len <= max);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isLowercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isLowercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isLowercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isLowercase(str) {
  (0, _assertString.default)(str);
  return str === str.toLowerCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMACAddress.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isMACAddress.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMACAddress;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
var macAddressNoColons = /^([0-9a-fA-F]){12}$/;

function isMACAddress(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_colons) {
    return macAddressNoColons.test(str);
  }

  return macAddress.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMD5.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isMD5.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMD5;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md5 = /^[a-f0-9]{32}$/;

function isMD5(str) {
  (0, _assertString.default)(str);
  return md5.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMagnetURI.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMagnetURI.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMagnetURI;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var magnetURI = /^magnet:\?xt=urn:[a-z0-9]+:[a-z0-9]{32,40}&dn=.+&tr=.+$/i;

function isMagnetURI(url) {
  (0, _assertString.default)(url);
  return magnetURI.test(url.trim());
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMimeType.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/isMimeType.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMimeType;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/
// Match simple MIME types
// NB :
//   Subtype length must not exceed 100 characters.
//   This rule does not comply to the RFC specs (what is the max length ?).
var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+]{1,100}$/i; // eslint-disable-line max-len
// Handle "charset" in "text/*"

var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len
// Handle "boundary" in "multipart/*"

var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

function isMimeType(str) {
  (0, _assertString.default)(str);
  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMobilePhone.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isMobilePhone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMobilePhone;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
var phones = {
  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
  'ar-EG': /^((\+?20)|0)?1[012]\d{8}$/,
  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
  'ar-KW': /^(\+?965)[569]\d{7}$/,
  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
  'bn-BD': /\+?(88)?0?1[356789][0-9]{8}\b/,
  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'de-DE': /^(\+49)?0?1(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7}$/,
  'el-GR': /^(\+?30|0)?(69\d{8})$/,
  'en-AU': /^(\+?61|0)4\d{8}$/,
  'en-GB': /^(\+?44|0)7\d{9}$/,
  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28)\d{7}$/,
  'en-HK': /^(\+?852\-?)?[456789]\d{3}\-?\d{4}$/,
  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
  'en-KE': /^(\+?254|0)?[7]\d{8}$/,
  'en-MU': /^(\+?230|0)?\d{8}$/,
  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
  'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
  'en-SG': /^(\+65)?[89]\d{7}$/,
  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  'en-ZA': /^(\+?27|0)\d{9}$/,
  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
  'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  'ja-JP': /^(\+?81|0)[789]0[ \-]?[1-9]\d{2}[ \-]?\d{5}$/,
  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  'lt-LT': /^(\+370|8)\d{8}$/,
  'ms-MY': /^(\+?6?01){1}(([0145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
  'nb-NO': /^(\+?47)?[49]\d{7}$/,
  'nl-BE': /^(\+?32|0)4?\d{8}$/,
  'nn-NO': /^(\+?47)?[49]\d{7}$/,
  'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
  'pt-BR': /(?=^(\+?5{2}\-?|0)[1-9]{2}\-?\d{4}\-?\d{4}$)(^(\+?5{2}\-?|0)[1-9]{2}\-?[6-9]{1}\d{3}\-?\d{4}$)|(^(\+?5{2}\-?|0)[1-9]{2}\-?9[6-9]{1}\d{3}\-?\d{4}$)/,
  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
  'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
  'ru-RU': /^(\+?7|8)?9\d{9}$/,
  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  'th-TH': /^(\+66|66|0)\d{9}$/,
  'tr-TR': /^(\+?90|0)?5\d{9}$/,
  'uk-UA': /^(\+?38|8)?0\d{9}$/,
  'vi-VN': /^(\+?84|0)((3([2-9]))|(5([689]))|(7([0|6-9]))|(8([1-5]))|(9([0-9])))([0-9]{7})$/,
  'zh-CN': /^((\+|00)86)?1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$/,
  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
};
/* eslint-enable max-len */
// aliases

phones['en-CA'] = phones['en-US'];
phones['fr-BE'] = phones['nl-BE'];
phones['zh-HK'] = phones['en-HK'];

function isMobilePhone(str, locale, options) {
  (0, _assertString.default)(str);

  if (options && options.strictMode && !str.startsWith('+')) {
    return false;
  }

  if (Array.isArray(locale)) {
    return locale.some(function (key) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }

      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str); // alias falsey locale as 'any'
  } else if (!locale || locale === 'any') {
    for (var key in phones) {
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];

        if (phone.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

var locales = Object.keys(phones);
exports.locales = locales;

/***/ }),

/***/ "./node_modules/validator/lib/isMongoId.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isMongoId.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMongoId;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isHexadecimal = _interopRequireDefault(__webpack_require__(/*! ./isHexadecimal */ "./node_modules/validator/lib/isHexadecimal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isMongoId(str) {
  (0, _assertString.default)(str);
  return (0, _isHexadecimal.default)(str) && str.length === 24;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isMultibyte.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isMultibyte.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isMultibyte;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-control-regex */
var multibyte = /[^\x00-\x7F]/;
/* eslint-enable no-control-regex */

function isMultibyte(str) {
  (0, _assertString.default)(str);
  return multibyte.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isNumeric.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isNumeric.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isNumeric;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var numeric = /^[+-]?([0-9]*[.])?[0-9]+$/;
var numericNoSymbols = /^[0-9]+$/;

function isNumeric(str, options) {
  (0, _assertString.default)(str);

  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }

  return numeric.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPort.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isPort.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isPort;

var _isInt = _interopRequireDefault(__webpack_require__(/*! ./isInt */ "./node_modules/validator/lib/isInt.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPort(str) {
  return (0, _isInt.default)(str, {
    min: 0,
    max: 65535
  });
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isPostalCode.js":
/*!****************************************************!*\
  !*** ./node_modules/validator/lib/isPostalCode.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = _default;
exports.locales = void 0;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// common patterns
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  BE: fourDigit,
  BG: fourDigit,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: fiveDigit,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HU: fourDigit,
  IL: fiveDigit,
  IN: sixDigit,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  MX: fiveDigit,
  NL: /^\d{4}\s?[a-z]{2}$/i,
  NO: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^\d{3}\s?\d{2}$/,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales = Object.keys(patterns);
exports.locales = locales;

function _default(str, locale) {
  (0, _assertString.default)(str);

  if (locale in patterns) {
    return patterns[locale].test(str);
  } else if (locale === 'any') {
    for (var key in patterns) {
      if (patterns.hasOwnProperty(key)) {
        var pattern = patterns[key];

        if (pattern.test(str)) {
          return true;
        }
      }
    }

    return false;
  }

  throw new Error("Invalid locale '".concat(locale, "'"));
}

/***/ }),

/***/ "./node_modules/validator/lib/isRFC3339.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/isRFC3339.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isRFC3339;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */
var dateFullYear = /[0-9]{4}/;
var dateMonth = /(0[1-9]|1[0-2])/;
var dateMDay = /([12]\d|0[1-9]|3[01])/;
var timeHour = /([01][0-9]|2[0-3])/;
var timeMinute = /[0-5][0-9]/;
var timeSecond = /([0-5][0-9]|60)/;
var timeSecFrac = /(\.[0-9]+)?/;
var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
var rfc3339 = new RegExp("".concat(fullDate.source, "[ tT]").concat(fullTime.source));

function isRFC3339(str) {
  (0, _assertString.default)(str);
  return rfc3339.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isSurrogatePair.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isSurrogatePair.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isSurrogatePair;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

function isSurrogatePair(str) {
  (0, _assertString.default)(str);
  return surrogatePair.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isURL.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/isURL.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isURL;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFQDN = _interopRequireDefault(__webpack_require__(/*! ./isFQDN */ "./node_modules/validator/lib/isFQDN.js"));

var _isIP = _interopRequireDefault(__webpack_require__(/*! ./isIP */ "./node_modules/validator/lib/isIP.js"));

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];

    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }

  return false;
}

function isURL(url, options) {
  (0, _assertString.default)(url);

  if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
    return false;
  }

  if (url.indexOf('mailto:') === 0) {
    return false;
  }

  options = (0, _merge.default)(options, default_url_options);
  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');

  if (split.length > 1) {
    protocol = split.shift().toLowerCase();

    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.substr(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }

    split[0] = url.substr(2);
  }

  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');

  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }

    auth = split.shift();

    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
  }

  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);

  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();

    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null) {
    port = parseInt(port_str, 10);

    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  }

  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
    return false;
  }

  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUUID.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/isUUID.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUUID;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuid = {
  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};

function isUUID(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
  (0, _assertString.default)(str);
  var pattern = uuid[version];
  return pattern && pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isUppercase.js":
/*!***************************************************!*\
  !*** ./node_modules/validator/lib/isUppercase.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isUppercase;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isUppercase(str) {
  (0, _assertString.default)(str);
  return str === str.toUpperCase();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isVariableWidth.js":
/*!*******************************************************!*\
  !*** ./node_modules/validator/lib/isVariableWidth.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isVariableWidth;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _isFullWidth = __webpack_require__(/*! ./isFullWidth */ "./node_modules/validator/lib/isFullWidth.js");

var _isHalfWidth = __webpack_require__(/*! ./isHalfWidth */ "./node_modules/validator/lib/isHalfWidth.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isVariableWidth(str) {
  (0, _assertString.default)(str);
  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/isWhitelisted.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/isWhitelisted.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = isWhitelisted;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isWhitelisted(str, chars) {
  (0, _assertString.default)(str);

  for (var i = str.length - 1; i >= 0; i--) {
    if (chars.indexOf(str[i]) === -1) {
      return false;
    }
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/ltrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/ltrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = ltrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ltrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("^[".concat(chars, "]+"), 'g') : /^\s+/g;
  return str.replace(pattern, '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/matches.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/matches.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = matches;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matches(str, pattern, modifiers) {
  (0, _assertString.default)(str);

  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
    pattern = new RegExp(pattern, modifiers);
  }

  return pattern.test(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/normalizeEmail.js":
/*!******************************************************!*\
  !*** ./node_modules/validator/lib/normalizeEmail.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = normalizeEmail;

var _merge = _interopRequireDefault(__webpack_require__(/*! ./util/merge */ "./node_modules/validator/lib/util/merge.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_normalize_email_options = {
  // The following options apply to all email addresses
  // Lowercases the local part of the email address.
  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
  // The domain is always lowercased, as per RFC 1035
  all_lowercase: true,
  // The following conversions are specific to GMail
  // Lowercases the local part of the GMail address (known to be case-insensitive)
  gmail_lowercase: true,
  // Removes dots from the local part of the email address, as that's ignored by GMail
  gmail_remove_dots: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  gmail_remove_subaddress: true,
  // Conversts the googlemail.com domain to gmail.com
  gmail_convert_googlemaildotcom: true,
  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
  outlookdotcom_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  outlookdotcom_remove_subaddress: true,
  // The following conversions are specific to Yahoo
  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
  yahoo_lowercase: true,
  // Removes the subaddress (e.g. "-foo") from the email address
  yahoo_remove_subaddress: true,
  // The following conversions are specific to Yandex
  // Lowercases the local part of the Yandex address (known to be case-insensitive)
  yandex_lowercase: true,
  // The following conversions are specific to iCloud
  // Lowercases the local part of the iCloud address (known to be case-insensitive)
  icloud_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  icloud_remove_subaddress: true
}; // List of domains used by iCloud

var icloud_domains = ['icloud.com', 'me.com']; // List of domains used by Outlook.com and its predecessors
// This list is likely incomplete.
// Partial reference:
// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/

var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com']; // List of domains used by Yahoo Mail
// This list is likely incomplete

var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com']; // List of domains used by yandex.ru

var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru']; // replace single dots, but not multiple consecutive dots

function dotsReplacer(match) {
  if (match.length > 1) {
    return match;
  }

  return '';
}

function normalizeEmail(email, options) {
  options = (0, _merge.default)(options, default_normalize_email_options);
  var raw_parts = email.split('@');
  var domain = raw_parts.pop();
  var user = raw_parts.join('@');
  var parts = [user, domain]; // The domain is always lowercased, as it's case-insensitive per RFC 1035

  parts[1] = parts[1].toLowerCase();

  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
    // Address is GMail
    if (options.gmail_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (options.gmail_remove_dots) {
      // this does not replace consecutive dots like example..email@gmail.com
      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.gmail_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
    // Address is iCloud
    if (options.icloud_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.icloud_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
    // Address is Outlook.com
    if (options.outlookdotcom_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.outlookdotcom_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
    // Address is Yahoo
    if (options.yahoo_remove_subaddress) {
      var components = parts[0].split('-');
      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
    }

    if (!parts[0].length) {
      return false;
    }

    if (options.all_lowercase || options.yahoo_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
    if (options.all_lowercase || options.yandex_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }

    parts[1] = 'yandex.ru'; // all yandex domains are equal, 1st preffered
  } else if (options.all_lowercase) {
    // Any other address
    parts[0] = parts[0].toLowerCase();
  }

  return parts.join('@');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/rtrim.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/rtrim.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = rtrim;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rtrim(str, chars) {
  (0, _assertString.default)(str);
  var pattern = chars ? new RegExp("[".concat(chars, "]")) : /\s/;
  var idx = str.length - 1;

  for (; idx >= 0 && pattern.test(str[idx]); idx--) {
    ;
  }

  return idx < str.length ? str.substr(0, idx + 1) : str;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/stripLow.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/stripLow.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = stripLow;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

var _blacklist = _interopRequireDefault(__webpack_require__(/*! ./blacklist */ "./node_modules/validator/lib/blacklist.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stripLow(str, keep_new_lines) {
  (0, _assertString.default)(str);
  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
  return (0, _blacklist.default)(str, chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/toBoolean.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toBoolean;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBoolean(str, strict) {
  (0, _assertString.default)(str);

  if (strict) {
    return str === '1' || str === 'true';
  }

  return str !== '0' && str !== 'false' && str !== '';
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toDate.js":
/*!**********************************************!*\
  !*** ./node_modules/validator/lib/toDate.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toDate;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toDate(date) {
  (0, _assertString.default)(date);
  date = Date.parse(date);
  return !isNaN(date) ? new Date(date) : null;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toFloat.js":
/*!***********************************************!*\
  !*** ./node_modules/validator/lib/toFloat.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toFloat;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toFloat(str) {
  (0, _assertString.default)(str);
  return parseFloat(str);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/toInt.js":
/*!*********************************************!*\
  !*** ./node_modules/validator/lib/toInt.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toInt;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toInt(str, radix) {
  (0, _assertString.default)(str);
  return parseInt(str, radix || 10);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/trim.js":
/*!********************************************!*\
  !*** ./node_modules/validator/lib/trim.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = trim;

var _rtrim = _interopRequireDefault(__webpack_require__(/*! ./rtrim */ "./node_modules/validator/lib/rtrim.js"));

var _ltrim = _interopRequireDefault(__webpack_require__(/*! ./ltrim */ "./node_modules/validator/lib/ltrim.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trim(str, chars) {
  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/unescape.js":
/*!************************************************!*\
  !*** ./node_modules/validator/lib/unescape.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = unescape;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unescape(str) {
  (0, _assertString.default)(str);
  return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/assertString.js":
/*!*********************************************************!*\
  !*** ./node_modules/validator/lib/util/assertString.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = assertString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    var invalidType;

    if (input === null) {
      invalidType = 'null';
    } else {
      invalidType = _typeof(input);

      if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
        invalidType = input.constructor.name;
      } else {
        invalidType = "a ".concat(invalidType);
      }
    }

    throw new TypeError("Expected string but received ".concat(invalidType, "."));
  }
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/includes.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/includes.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var includes = function includes(arr, val) {
  return arr.some(function (arrVal) {
    return val === arrVal;
  });
};

var _default = includes;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/validator/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = merge;

function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }

  return obj;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/util/toString.js":
/*!*****************************************************!*\
  !*** ./node_modules/validator/lib/util/toString.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = toString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function toString(input) {
  if (_typeof(input) === 'object' && input !== null) {
    if (typeof input.toString === 'function') {
      input = input.toString();
    } else {
      input = '[object Object]';
    }
  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
    input = '';
  }

  return String(input);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/validator/lib/whitelist.js":
/*!*************************************************!*\
  !*** ./node_modules/validator/lib/whitelist.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = whitelist;

var _assertString = _interopRequireDefault(__webpack_require__(/*! ./util/assertString */ "./node_modules/validator/lib/util/assertString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function whitelist(str, chars) {
  (0, _assertString.default)(str);
  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),

/***/ "./node_modules/wkx/lib/binaryreader.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binaryreader.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryReader;

function BinaryReader(buffer, isBigEndian) {
    this.buffer = buffer;
    this.position = 0;
    this.isBigEndian = isBigEndian || false;
}

function _read(readLE, readBE, size) {
    return function () {
        var value;

        if (this.isBigEndian)
            value = readBE.call(this.buffer, this.position);
        else
            value = readLE.call(this.buffer, this.position);

        this.position += size;

        return value;
    };
}

BinaryReader.prototype.readUInt8 = _read(Buffer.prototype.readUInt8, Buffer.prototype.readUInt8, 1);
BinaryReader.prototype.readUInt16 = _read(Buffer.prototype.readUInt16LE, Buffer.prototype.readUInt16BE, 2);
BinaryReader.prototype.readUInt32 = _read(Buffer.prototype.readUInt32LE, Buffer.prototype.readUInt32BE, 4);
BinaryReader.prototype.readInt8 = _read(Buffer.prototype.readInt8, Buffer.prototype.readInt8, 1);
BinaryReader.prototype.readInt16 = _read(Buffer.prototype.readInt16LE, Buffer.prototype.readInt16BE, 2);
BinaryReader.prototype.readInt32 = _read(Buffer.prototype.readInt32LE, Buffer.prototype.readInt32BE, 4);
BinaryReader.prototype.readFloat = _read(Buffer.prototype.readFloatLE, Buffer.prototype.readFloatBE, 4);
BinaryReader.prototype.readDouble = _read(Buffer.prototype.readDoubleLE, Buffer.prototype.readDoubleBE, 8);

BinaryReader.prototype.readVarInt = function () {
    var nextByte,
        result = 0,
        bytesRead = 0;

    do {
        nextByte = this.buffer[this.position + bytesRead];
        result += (nextByte & 0x7F) << (7 * bytesRead);
        bytesRead++;
    } while (nextByte >= 0x80);

    this.position += bytesRead;

    return result;
};


/***/ }),

/***/ "./node_modules/wkx/lib/binarywriter.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/binarywriter.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = BinaryWriter;

function BinaryWriter(size, allowResize) {
    this.buffer = new Buffer(size);
    this.position = 0;
    this.allowResize = allowResize;
}

function _write(write, size) {
    return function (value, noAssert) {
        this.ensureSize(size);

        write.call(this.buffer, value, this.position, noAssert);
        this.position += size;
    };
}

BinaryWriter.prototype.writeUInt8 = _write(Buffer.prototype.writeUInt8, 1);
BinaryWriter.prototype.writeUInt16LE = _write(Buffer.prototype.writeUInt16LE, 2);
BinaryWriter.prototype.writeUInt16BE = _write(Buffer.prototype.writeUInt16BE, 2);
BinaryWriter.prototype.writeUInt32LE = _write(Buffer.prototype.writeUInt32LE, 4);
BinaryWriter.prototype.writeUInt32BE = _write(Buffer.prototype.writeUInt32BE, 4);
BinaryWriter.prototype.writeInt8 = _write(Buffer.prototype.writeInt8, 1);
BinaryWriter.prototype.writeInt16LE = _write(Buffer.prototype.writeInt16LE, 2);
BinaryWriter.prototype.writeInt16BE = _write(Buffer.prototype.writeInt16BE, 2);
BinaryWriter.prototype.writeInt32LE = _write(Buffer.prototype.writeInt32LE, 4);
BinaryWriter.prototype.writeInt32BE = _write(Buffer.prototype.writeInt32BE, 4);
BinaryWriter.prototype.writeFloatLE = _write(Buffer.prototype.writeFloatLE, 4);
BinaryWriter.prototype.writeFloatBE = _write(Buffer.prototype.writeFloatBE, 4);
BinaryWriter.prototype.writeDoubleLE = _write(Buffer.prototype.writeDoubleLE, 8);
BinaryWriter.prototype.writeDoubleBE = _write(Buffer.prototype.writeDoubleBE, 8);

BinaryWriter.prototype.writeBuffer = function (buffer) {
    this.ensureSize(buffer.length);

    buffer.copy(this.buffer, this.position, 0, buffer.length);
    this.position += buffer.length;
};

BinaryWriter.prototype.writeVarInt = function (value) {
    var length = 1;

    while ((value & 0xFFFFFF80) !== 0) {
        this.writeUInt8((value & 0x7F) | 0x80);
        value >>>= 7;
        length++;
    }

    this.writeUInt8(value & 0x7F);

    return length;
};

BinaryWriter.prototype.ensureSize = function (size) {
    if (this.buffer.length < this.position + size) {
        if (this.allowResize) {
            var tempBuffer = new Buffer(this.position + size);
            this.buffer.copy(tempBuffer, 0, 0, this.buffer.length);
            this.buffer = tempBuffer;
        }
        else {
            throw new RangeError('index out of range');
        }
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometry.js":
/*!******************************************!*\
  !*** ./node_modules/wkx/lib/geometry.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Geometry;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
var MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
var MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
var GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");
var BinaryReader = __webpack_require__(/*! ./binaryreader */ "./node_modules/wkx/lib/binaryreader.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var WktParser = __webpack_require__(/*! ./wktparser */ "./node_modules/wkx/lib/wktparser.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Geometry() {
    this.srid = undefined;
    this.hasZ = false;
    this.hasM = false;
}

Geometry.parse = function (value, options) {
    var valueType = typeof value;

    if (valueType === 'string' || value instanceof WktParser)
        return Geometry._parseWkt(value);
    else if (Buffer.isBuffer(value) || value instanceof BinaryReader)
        return Geometry._parseWkb(value, options);
    else
        throw new Error('first argument must be a string or Buffer');
};

Geometry._parseWkt = function (value) {
    var wktParser,
        srid;

    if (value instanceof WktParser)
        wktParser = value;
    else
        wktParser = new WktParser(value);

    var match = wktParser.matchRegex([/^SRID=(\d+);/]);
    if (match)
        srid = parseInt(match[1], 10);

    var geometryType = wktParser.matchType();
    var dimension = wktParser.matchDimension();

    var options = {
        srid: srid,
        hasZ: dimension.hasZ,
        hasM: dimension.hasM
    };

    switch (geometryType) {
        case Types.wkt.Point:
            return Point._parseWkt(wktParser, options);
        case Types.wkt.LineString:
            return LineString._parseWkt(wktParser, options);
        case Types.wkt.Polygon:
            return Polygon._parseWkt(wktParser, options);
        case Types.wkt.MultiPoint:
            return MultiPoint._parseWkt(wktParser, options);
        case Types.wkt.MultiLineString:
            return MultiLineString._parseWkt(wktParser, options);
        case Types.wkt.MultiPolygon:
            return MultiPolygon._parseWkt(wktParser, options);
        case Types.wkt.GeometryCollection:
            return GeometryCollection._parseWkt(wktParser, options);
    }
};

Geometry._parseWkb = function (value, parentOptions) {
    var binaryReader,
        wkbType,
        geometryType,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    binaryReader.isBigEndian = !binaryReader.readInt8();

    wkbType = binaryReader.readUInt32();

    options.hasSrid = (wkbType & 0x20000000) === 0x20000000;
    options.isEwkb = (wkbType & 0x20000000) || (wkbType & 0x40000000) || (wkbType & 0x80000000);

    if (options.hasSrid)
        options.srid = binaryReader.readUInt32();

    options.hasZ = false;
    options.hasM = false;

    if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {
        if (wkbType >= 1000 && wkbType < 2000) {
            options.hasZ = true;
            geometryType = wkbType - 1000;
        }
        else if (wkbType >= 2000 && wkbType < 3000) {
            options.hasM = true;
            geometryType = wkbType - 2000;
        }
        else if (wkbType >= 3000 && wkbType < 4000) {
            options.hasZ = true;
            options.hasM = true;
            geometryType = wkbType - 3000;
        }
        else {
            geometryType = wkbType;
        }
    }
    else {
        if (wkbType & 0x80000000)
            options.hasZ = true;
        if (wkbType & 0x40000000)
            options.hasM = true;

        geometryType = wkbType & 0xF;
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseWkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseWkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseWkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseWkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseWkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseWkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseWkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseTwkb = function (value) {
    var binaryReader,
        options = {};

    if (value instanceof BinaryReader)
        binaryReader = value;
    else
        binaryReader = new BinaryReader(value);

    var type = binaryReader.readUInt8();
    var metadataHeader = binaryReader.readUInt8();

    var geometryType = type & 0x0F;
    options.precision = ZigZag.decode(type >> 4);
    options.precisionFactor = Math.pow(10, options.precision);

    options.hasBoundingBox = metadataHeader >> 0 & 1;
    options.hasSizeAttribute = metadataHeader >> 1 & 1;
    options.hasIdList = metadataHeader >> 2 & 1;
    options.hasExtendedPrecision = metadataHeader >> 3 & 1;
    options.isEmpty = metadataHeader >> 4 & 1;

    if (options.hasExtendedPrecision) {
        var extendedPrecision = binaryReader.readUInt8();
        options.hasZ = (extendedPrecision & 0x01) === 0x01;
        options.hasM = (extendedPrecision & 0x02) === 0x02;

        options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);
        options.zPrecisionFactor = Math.pow(10, options.zPrecision);

        options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);
        options.mPrecisionFactor = Math.pow(10, options.mPrecision);
    }
    else {
        options.hasZ = false;
        options.hasM = false;
    }

    if (options.hasSizeAttribute)
        binaryReader.readVarInt();
    if (options.hasBoundingBox) {
        var dimensions = 2;

        if (options.hasZ)
            dimensions++;
        if (options.hasM)
            dimensions++;

        for (var i = 0; i < dimensions; i++) {
            binaryReader.readVarInt();
            binaryReader.readVarInt();
        }
    }

    switch (geometryType) {
        case Types.wkb.Point:
            return Point._parseTwkb(binaryReader, options);
        case Types.wkb.LineString:
            return LineString._parseTwkb(binaryReader, options);
        case Types.wkb.Polygon:
            return Polygon._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPoint:
            return MultiPoint._parseTwkb(binaryReader, options);
        case Types.wkb.MultiLineString:
            return MultiLineString._parseTwkb(binaryReader, options);
        case Types.wkb.MultiPolygon:
            return MultiPolygon._parseTwkb(binaryReader, options);
        case Types.wkb.GeometryCollection:
            return GeometryCollection._parseTwkb(binaryReader, options);
        default:
            throw new Error('GeometryType ' + geometryType + ' not supported');
    }
};

Geometry.parseGeoJSON = function (value) {
    return Geometry._parseGeoJSON(value);
};

Geometry._parseGeoJSON = function (value, isSubGeometry) {
    var geometry;

    switch (value.type) {
        case Types.geoJSON.Point:
            geometry = Point._parseGeoJSON(value); break;
        case Types.geoJSON.LineString:
            geometry = LineString._parseGeoJSON(value); break;
        case Types.geoJSON.Polygon:
            geometry = Polygon._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPoint:
            geometry = MultiPoint._parseGeoJSON(value); break;
        case Types.geoJSON.MultiLineString:
            geometry = MultiLineString._parseGeoJSON(value); break;
        case Types.geoJSON.MultiPolygon:
            geometry = MultiPolygon._parseGeoJSON(value); break;
        case Types.geoJSON.GeometryCollection:
            geometry = GeometryCollection._parseGeoJSON(value); break;
        default:
            throw new Error('GeometryType ' + value.type + ' not supported');
    }

    if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {
        var crs = value.crs.properties.name;

        if (crs.indexOf('EPSG:') === 0)
            geometry.srid = parseInt(crs.substring(5));
        else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0)
            geometry.srid = parseInt(crs.substring(22));
        else
            throw new Error('Unsupported crs: ' + crs);
    }
    else if (!isSubGeometry) {
        geometry.srid = 4326;
    }

    return geometry;
};

Geometry.prototype.toEwkt = function () {
    return 'SRID=' + this.srid + ';' + this.toWkt();
};

Geometry.prototype.toEwkb = function () {
    var ewkb = new BinaryWriter(this._getWkbSize() + 4);
    var wkb = this.toWkb();

    ewkb.writeInt8(1);
    ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);
    ewkb.writeUInt32LE(this.srid);

    ewkb.writeBuffer(wkb.slice(5));

    return ewkb.buffer;
};

Geometry.prototype._getWktType = function (wktType, isEmpty) {
    var wkt = wktType;

    if (this.hasZ && this.hasM)
        wkt += ' ZM ';
    else if (this.hasZ)
        wkt += ' Z ';
    else if (this.hasM)
        wkt += ' M ';

    if (isEmpty && !this.hasZ && !this.hasM)
        wkt += ' ';

    if (isEmpty)
        wkt += 'EMPTY';

    return wkt;
};

Geometry.prototype._getWktCoordinate = function (point) {
    var coordinates = point.x + ' ' + point.y;

    if (this.hasZ)
        coordinates += ' ' + point.z;
    if (this.hasM)
        coordinates += ' ' + point.m;

    return coordinates;
};

Geometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {
    var dimensionType = 0;

    if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {
        if (this.hasZ && this.hasM)
            dimensionType += 3000;
        else if (this.hasZ)
            dimensionType += 1000;
        else if (this.hasM)
            dimensionType += 2000;
    }
    else {
        if (this.hasZ)
            dimensionType |= 0x80000000;
        if (this.hasM)
            dimensionType |= 0x40000000;
    }

    wkb.writeUInt32LE((dimensionType + geometryType) >>> 0, true);
};

Geometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {
    return {
        xy: xyPrecision,
        z: zPrecision,
        m: mPrecision,
        xyFactor: Math.pow(10, xyPrecision),
        zFactor: Math.pow(10, zPrecision),
        mFactor: Math.pow(10, mPrecision)
    };
};

Geometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {
    var type = (ZigZag.encode(precision.xy) << 4) + geometryType;
    var metadataHeader = (this.hasZ || this.hasM) << 3;
    metadataHeader += isEmpty << 4;

    twkb.writeUInt8(type);
    twkb.writeUInt8(metadataHeader);

    if (this.hasZ || this.hasM) {
        var extendedPrecision = 0;
        if (this.hasZ)
            extendedPrecision |= 0x1;
        if (this.hasM)
            extendedPrecision |= 0x2;

        twkb.writeUInt8(extendedPrecision);
    }
};

Geometry.prototype.toGeoJSON = function (options) {
    var geoJSON = {};

    if (this.srid) {
        if (options) {
            if (options.shortCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'EPSG:' + this.srid
                    }
                };
            }
            else if (options.longCrs) {
                geoJSON.crs = {
                    type: 'name',
                    properties: {
                        name: 'urn:ogc:def:crs:EPSG::' + this.srid
                    }
                };
            }
        }
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/geometrycollection.js":
/*!****************************************************!*\
  !*** ./node_modules/wkx/lib/geometrycollection.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = GeometryCollection;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function GeometryCollection(geometries, srid) {
    Geometry.call(this);

    this.geometries = geometries || [];
	this.srid = srid;

    if (this.geometries.length > 0) {
        this.hasZ = this.geometries[0].hasZ;
        this.hasM = this.geometries[0].hasM;
    }
}

util.inherits(GeometryCollection, Geometry);

GeometryCollection.Z = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    return geometryCollection;
};

GeometryCollection.M = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection.ZM = function (geometries, srid) {
    var geometryCollection = new GeometryCollection(geometries, srid);
    geometryCollection.hasZ = true;
    geometryCollection.hasM = true;
    return geometryCollection;
};

GeometryCollection._parseWkt = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return geometryCollection;

    value.expectGroupStart();

    do {
        geometryCollection.geometries.push(Geometry.parse(value));
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return geometryCollection;
};

GeometryCollection._parseWkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.srid = options.srid;
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    var geometryCount = value.readUInt32();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parse(value, options));

    return geometryCollection;
};

GeometryCollection._parseTwkb = function (value, options) {
    var geometryCollection = new GeometryCollection();
    geometryCollection.hasZ = options.hasZ;
    geometryCollection.hasM = options.hasM;

    if (options.isEmpty)
        return geometryCollection;

    var geometryCount = value.readVarInt();

    for (var i = 0; i < geometryCount; i++)
        geometryCollection.geometries.push(Geometry.parseTwkb(value));

    return geometryCollection;
};

GeometryCollection._parseGeoJSON = function (value) {
    var geometryCollection = new GeometryCollection();

    for (var i = 0; i < value.geometries.length; i++)
        geometryCollection.geometries.push(Geometry._parseGeoJSON(value.geometries[i], true));

    if (geometryCollection.geometries.length > 0)
        geometryCollection.hasZ = geometryCollection.geometries[0].hasZ;

    return geometryCollection;
};

GeometryCollection.prototype.toWkt = function () {
    if (this.geometries.length === 0)
        return this._getWktType(Types.wkt.GeometryCollection, true);

    var wkt = this._getWktType(Types.wkt.GeometryCollection, false) + '(';

    for (var i = 0; i < this.geometries.length; i++)
        wkt += this.geometries[i].toWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

GeometryCollection.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.GeometryCollection);
    wkb.writeUInt32LE(this.geometries.length);

    for (var i = 0; i < this.geometries.length; i++)
        wkb.writeBuffer(this.geometries[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

GeometryCollection.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.geometries.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.GeometryCollection, precision, isEmpty);

    if (this.geometries.length > 0) {
        twkb.writeVarInt(this.geometries.length);

        for (var i = 0; i < this.geometries.length; i++)
            twkb.writeBuffer(this.geometries[i].toTwkb());
    }

    return twkb.buffer;
};

GeometryCollection.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.geometries.length; i++)
        size += this.geometries[i]._getWkbSize();

    return size;
};

GeometryCollection.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.GeometryCollection;
    geoJSON.geometries = [];

    for (var i = 0; i < this.geometries.length; i++)
        geoJSON.geometries.push(this.geometries[i].toGeoJSON());

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/linestring.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/linestring.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = LineString;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function LineString(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;

    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(LineString, Geometry);

LineString.Z = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    return lineString;
};

LineString.M = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasM = true;
    return lineString;
};

LineString.ZM = function (points, srid) {
    var lineString = new LineString(points, srid);
    lineString.hasZ = true;
    lineString.hasM = true;
    return lineString;
};

LineString._parseWkt = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return lineString;

    value.expectGroupStart();
    lineString.points.push.apply(lineString.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return lineString;
};

LineString._parseWkb = function (value, options) {
    var lineString = new LineString();
    lineString.srid = options.srid;
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readWkbPoint(value, options));

    return lineString;
};

LineString._parseTwkb = function (value, options) {
    var lineString = new LineString();
    lineString.hasZ = options.hasZ;
    lineString.hasM = options.hasM;

    if (options.isEmpty)
        return lineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return lineString;
};

LineString._parseGeoJSON = function (value) {
    var lineString = new LineString();

    if (value.coordinates.length > 0)
        lineString.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        lineString.points.push(Point._readGeoJSONPoint(value.coordinates[i]));

    return lineString;
};

LineString.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.LineString, true);

    return this._getWktType(Types.wkt.LineString, false) + this._toInnerWkt();
};

LineString.prototype._toInnerWkt = function () {
    var innerWkt = '(';

    for (var i = 0; i < this.points.length; i++)
        innerWkt += this._getWktCoordinate(this.points[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    return innerWkt;
};

LineString.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.LineString, parentOptions);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        this.points[i]._writeWkbPoint(wkb);

    return wkb.buffer;
};

LineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.LineString, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

LineString.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

LineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.LineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++) {
        if (this.hasZ)
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y, this.points[i].z]);
        else
            geoJSON.coordinates.push([this.points[i].x, this.points[i].y]);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multilinestring.js":
/*!*************************************************!*\
  !*** ./node_modules/wkx/lib/multilinestring.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiLineString;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiLineString(lineStrings, srid) {
    Geometry.call(this);

    this.lineStrings = lineStrings || [];
	this.srid = srid;

    if (this.lineStrings.length > 0) {
        this.hasZ = this.lineStrings[0].hasZ;
        this.hasM = this.lineStrings[0].hasM;
    }
}

util.inherits(MultiLineString, Geometry);

MultiLineString.Z = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    return multiLineString;
};

MultiLineString.M = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString.ZM = function (lineStrings, srid) {
    var multiLineString = new MultiLineString(lineStrings, srid);
    multiLineString.hasZ = true;
    multiLineString.hasM = true;
    return multiLineString;
};

MultiLineString._parseWkt = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiLineString;

    value.expectGroupStart();

    do {
        value.expectGroupStart();
        multiLineString.lineStrings.push(new LineString(value.matchCoordinates(options)));
        value.expectGroupEnd();
    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiLineString;
};

MultiLineString._parseWkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.srid = options.srid;
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    var lineStringCount = value.readUInt32();

    for (var i = 0; i < lineStringCount; i++)
        multiLineString.lineStrings.push(Geometry.parse(value, options));

    return multiLineString;
};

MultiLineString._parseTwkb = function (value, options) {
    var multiLineString = new MultiLineString();
    multiLineString.hasZ = options.hasZ;
    multiLineString.hasM = options.hasM;

    if (options.isEmpty)
        return multiLineString;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var lineStringCount = value.readVarInt();

    for (var i = 0; i < lineStringCount; i++) {
        var lineString = new LineString();
        lineString.hasZ = options.hasZ;
        lineString.hasM = options.hasM;

        var pointCount = value.readVarInt();

        for (var j = 0; j < pointCount; j++)
            lineString.points.push(Point._readTwkbPoint(value, options, previousPoint));

        multiLineString.lineStrings.push(lineString);
    }

    return multiLineString;
};

MultiLineString._parseGeoJSON = function (value) {
    var multiLineString = new MultiLineString();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        multiLineString.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiLineString.lineStrings.push(LineString._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiLineString;
};

MultiLineString.prototype.toWkt = function () {
    if (this.lineStrings.length === 0)
        return this._getWktType(Types.wkt.MultiLineString, true);

    var wkt = this._getWktType(Types.wkt.MultiLineString, false) + '(';

    for (var i = 0; i < this.lineStrings.length; i++)
        wkt += this.lineStrings[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiLineString.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiLineString);
    wkb.writeUInt32LE(this.lineStrings.length);

    for (var i = 0; i < this.lineStrings.length; i++)
        wkb.writeBuffer(this.lineStrings[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiLineString.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.lineStrings.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiLineString, precision, isEmpty);

    if (this.lineStrings.length > 0) {
        twkb.writeVarInt(this.lineStrings.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.lineStrings.length; i++) {
            twkb.writeVarInt(this.lineStrings[i].points.length);

            for (var j = 0; j < this.lineStrings[i].points.length; j++)
                this.lineStrings[i].points[j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

MultiLineString.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.lineStrings.length; i++)
        size += this.lineStrings[i]._getWkbSize();

    return size;
};

MultiLineString.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiLineString;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.lineStrings.length; i++)
        geoJSON.coordinates.push(this.lineStrings[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipoint.js":
/*!********************************************!*\
  !*** ./node_modules/wkx/lib/multipoint.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPoint;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPoint(points, srid) {
    Geometry.call(this);

    this.points = points || [];
	this.srid = srid;
	
    if (this.points.length > 0) {
        this.hasZ = this.points[0].hasZ;
        this.hasM = this.points[0].hasM;
    }
}

util.inherits(MultiPoint, Geometry);

MultiPoint.Z = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    return multiPoint;
};

MultiPoint.M = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint.ZM = function (points, srid) {
    var multiPoint = new MultiPoint(points, srid);
    multiPoint.hasZ = true;
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint._parseWkt = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPoint;

    value.expectGroupStart();
    multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates(options));
    value.expectGroupEnd();

    return multiPoint;
};

MultiPoint._parseWkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Geometry.parse(value, options));

    return multiPoint;
};

MultiPoint._parseTwkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (options.isEmpty)
        return multiPoint;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return multiPoint;
};

MultiPoint._parseGeoJSON = function (value) {
    var multiPoint = new MultiPoint();

    if (value.coordinates.length > 0)
        multiPoint.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPoint.points.push(Point._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPoint;
};

MultiPoint.prototype.toWkt = function () {
    if (this.points.length === 0)
        return this._getWktType(Types.wkt.MultiPoint, true);

    var wkt = this._getWktType(Types.wkt.MultiPoint, false) + '(';

    for (var i = 0; i < this.points.length; i++)
        wkt += this._getWktCoordinate(this.points[i]) + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPoint.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPoint);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        wkb.writeBuffer(this.points[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPoint.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPoint, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

MultiPoint.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    coordinateSize += 5;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

MultiPoint.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPoint;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++)
        geoJSON.coordinates.push(this.points[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/multipolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/wkx/lib/multipolygon.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = MultiPolygon;

var util = __webpack_require__(/*! util */ "util");

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function MultiPolygon(polygons, srid) {
    Geometry.call(this);

    this.polygons = polygons || [];
	this.srid = srid;

    if (this.polygons.length > 0) {
        this.hasZ = this.polygons[0].hasZ;
        this.hasM = this.polygons[0].hasM;
    }
}

util.inherits(MultiPolygon, Geometry);

MultiPolygon.Z = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    return multiPolygon;
};

MultiPolygon.M = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon.ZM = function (polygons, srid) {
    var multiPolygon = new MultiPolygon(polygons, srid);
    multiPolygon.hasZ = true;
    multiPolygon.hasM = true;
    return multiPolygon;
};

MultiPolygon._parseWkt = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return multiPolygon;

    value.expectGroupStart();

    do {
        value.expectGroupStart();

        var exteriorRing = [];
        var interiorRings = [];

        value.expectGroupStart();
        exteriorRing.push.apply(exteriorRing, value.matchCoordinates(options));
        value.expectGroupEnd();

        while (value.isMatch([','])) {
            value.expectGroupStart();
            interiorRings.push(value.matchCoordinates(options));
            value.expectGroupEnd();
        }

        multiPolygon.polygons.push(new Polygon(exteriorRing, interiorRings));

        value.expectGroupEnd();

    } while (value.isMatch([',']));

    value.expectGroupEnd();

    return multiPolygon;
};

MultiPolygon._parseWkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.srid = options.srid;
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    var polygonCount = value.readUInt32();

    for (var i = 0; i < polygonCount; i++)
        multiPolygon.polygons.push(Geometry.parse(value, options));

    return multiPolygon;
};

MultiPolygon._parseTwkb = function (value, options) {
    var multiPolygon = new MultiPolygon();
    multiPolygon.hasZ = options.hasZ;
    multiPolygon.hasM = options.hasM;

    if (options.isEmpty)
        return multiPolygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var polygonCount = value.readVarInt();

    for (var i = 0; i < polygonCount; i++) {
        var polygon = new Polygon();
        polygon.hasZ = options.hasZ;
        polygon.hasM = options.hasM;

        var ringCount = value.readVarInt();
        var exteriorRingCount = value.readVarInt();

        for (var j = 0; j < exteriorRingCount; j++)
            polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        for (j = 1; j < ringCount; j++) {
            var interiorRing = [];

            var interiorRingCount = value.readVarInt();

            for (var k = 0; k < interiorRingCount; k++)
                interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

            polygon.interiorRings.push(interiorRing);
        }

        multiPolygon.polygons.push(polygon);
    }

    return multiPolygon;
};

MultiPolygon._parseGeoJSON = function (value) {
    var multiPolygon = new MultiPolygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0 && value.coordinates[0][0].length > 0)
        multiPolygon.hasZ = value.coordinates[0][0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPolygon.polygons.push(Polygon._parseGeoJSON({ coordinates: value.coordinates[i] }));

    return multiPolygon;
};

MultiPolygon.prototype.toWkt = function () {
    if (this.polygons.length === 0)
        return this._getWktType(Types.wkt.MultiPolygon, true);

    var wkt = this._getWktType(Types.wkt.MultiPolygon, false) + '(';

    for (var i = 0; i < this.polygons.length; i++)
        wkt += this.polygons[i]._toInnerWkt() + ',';

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPolygon.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.MultiPolygon);
    wkb.writeUInt32LE(this.polygons.length);

    for (var i = 0; i < this.polygons.length; i++)
        wkb.writeBuffer(this.polygons[i].toWkb({ srid: this.srid }));

    return wkb.buffer;
};

MultiPolygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.polygons.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPolygon, precision, isEmpty);

    if (this.polygons.length > 0) {
        twkb.writeVarInt(this.polygons.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.polygons.length; i++) {
            twkb.writeVarInt(1 + this.polygons[i].interiorRings.length);

            twkb.writeVarInt(this.polygons[i].exteriorRing.length);

            for (var j = 0; j < this.polygons[i].exteriorRing.length; j++)
                this.polygons[i].exteriorRing[j]._writeTwkbPoint(twkb, precision, previousPoint);

            for (j = 0; j < this.polygons[i].interiorRings.length; j++) {
                twkb.writeVarInt(this.polygons[i].interiorRings[j].length);

                for (var k = 0; k < this.polygons[i].interiorRings[j].length; k++)
                    this.polygons[i].interiorRings[j][k]._writeTwkbPoint(twkb, precision, previousPoint);
            }
        }
    }

    return twkb.buffer;
};

MultiPolygon.prototype._getWkbSize = function () {
    var size = 1 + 4 + 4;

    for (var i = 0; i < this.polygons.length; i++)
        size += this.polygons[i]._getWkbSize();

    return size;
};

MultiPolygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPolygon;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.polygons.length; i++)
        geoJSON.coordinates.push(this.polygons[i].toGeoJSON().coordinates);

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/point.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/point.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Point;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");
var ZigZag = __webpack_require__(/*! ./zigzag.js */ "./node_modules/wkx/lib/zigzag.js");

function Point(x, y, z, m, srid) {
    Geometry.call(this);

    this.x = x;
    this.y = y;
    this.z = z;
    this.m = m;
	this.srid = srid;

    this.hasZ = typeof this.z !== 'undefined';
    this.hasM = typeof this.m !== 'undefined';
}

util.inherits(Point, Geometry);

Point.Z = function (x, y, z, srid) {
    var point = new Point(x, y, z, undefined, srid);
    point.hasZ = true;
    return point;
};

Point.M = function (x, y, m, srid) {
    var point = new Point(x, y, undefined, m, srid);
    point.hasM = true;
    return point;
};

Point.ZM = function (x, y, z, m, srid) {
    var point = new Point(x, y, z, m, srid);
    point.hasZ = true;
    point.hasM = true;
    return point;
};

Point._parseWkt = function (value, options) {
    var point = new Point();
    point.srid = options.srid;
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return point;

    value.expectGroupStart();

    var coordinate = value.matchCoordinate(options);

    point.x = coordinate.x;
    point.y = coordinate.y;
    point.z = coordinate.z;
    point.m = coordinate.m;

    value.expectGroupEnd();

    return point;
};

Point._parseWkb = function (value, options) {
    var point = Point._readWkbPoint(value, options);
    point.srid = options.srid;
    return point;
};

Point._readWkbPoint = function (value, options) {
    return new Point(value.readDouble(), value.readDouble(),
        options.hasZ ? value.readDouble() : undefined,
        options.hasM ? value.readDouble() : undefined);
};

Point._parseTwkb = function (value, options) {
    var point = new Point();
    point.hasZ = options.hasZ;
    point.hasM = options.hasM;

    if (options.isEmpty)
        return point;

    point.x = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.y = ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    point.z = options.hasZ ? ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor : undefined;
    point.m = options.hasM ? ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor : undefined;

    return point;
};

Point._readTwkbPoint = function (value, options, previousPoint) {
    previousPoint.x += ZigZag.decode(value.readVarInt()) / options.precisionFactor;
    previousPoint.y += ZigZag.decode(value.readVarInt()) / options.precisionFactor;

    if (options.hasZ)
        previousPoint.z += ZigZag.decode(value.readVarInt()) / options.zPrecisionFactor;
    if (options.hasM)
        previousPoint.m += ZigZag.decode(value.readVarInt()) / options.mPrecisionFactor;

    return new Point(previousPoint.x, previousPoint.y, previousPoint.z, previousPoint.m);
};

Point._parseGeoJSON = function (value) {
    return Point._readGeoJSONPoint(value.coordinates);
};

Point._readGeoJSONPoint = function (coordinates) {
    if (coordinates.length === 0)
        return new Point();

    if (coordinates.length > 2)
        return new Point(coordinates[0], coordinates[1], coordinates[2]);

    return new Point(coordinates[0], coordinates[1]);
};

Point.prototype.toWkt = function () {
    if (typeof this.x === 'undefined' && typeof this.y === 'undefined' &&
        typeof this.z === 'undefined' && typeof this.m === 'undefined')
        return this._getWktType(Types.wkt.Point, true);

    return this._getWktType(Types.wkt.Point, false) + '(' + this._getWktCoordinate(this) + ')';
};

Point.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);
    this._writeWkbType(wkb, Types.wkb.Point, parentOptions);

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined') {
        wkb.writeDoubleLE(NaN);
        wkb.writeDoubleLE(NaN);

        if (this.hasZ)
            wkb.writeDoubleLE(NaN);
        if (this.hasM)
            wkb.writeDoubleLE(NaN);
    }
    else {
        this._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Point.prototype._writeWkbPoint = function (wkb) {
    wkb.writeDoubleLE(this.x);
    wkb.writeDoubleLE(this.y);

    if (this.hasZ)
        wkb.writeDoubleLE(this.z);
    if (this.hasM)
        wkb.writeDoubleLE(this.m);
};

Point.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = typeof this.x === 'undefined' && typeof this.y === 'undefined';

    this._writeTwkbHeader(twkb, Types.wkb.Point, precision, isEmpty);

    if (!isEmpty)
        this._writeTwkbPoint(twkb, precision, new Point(0, 0, 0, 0));

    return twkb.buffer;
};

Point.prototype._writeTwkbPoint = function (twkb, precision, previousPoint) {
    var x = this.x * precision.xyFactor;
    var y = this.y * precision.xyFactor;
    var z = this.z * precision.zFactor;
    var m = this.m * precision.mFactor;

    twkb.writeVarInt(ZigZag.encode(x - previousPoint.x));
    twkb.writeVarInt(ZigZag.encode(y - previousPoint.y));
    if (this.hasZ)
        twkb.writeVarInt(ZigZag.encode(z - previousPoint.z));
    if (this.hasM)
        twkb.writeVarInt(ZigZag.encode(m - previousPoint.m));

    previousPoint.x = x;
    previousPoint.y = y;
    previousPoint.z = z;
    previousPoint.m = m;
};

Point.prototype._getWkbSize = function () {
    var size = 1 + 4 + 8 + 8;

    if (this.hasZ)
        size += 8;
    if (this.hasM)
        size += 8;

    return size;
};

Point.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Point;

    if (typeof this.x === 'undefined' && typeof this.y === 'undefined')
        geoJSON.coordinates = [];
    else if (typeof this.z !== 'undefined')
        geoJSON.coordinates = [this.x, this.y, this.z];
    else
        geoJSON.coordinates = [this.x, this.y];

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/wkx/lib/polygon.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Polygon;

var util = __webpack_require__(/*! util */ "util");

var Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
var BinaryWriter = __webpack_require__(/*! ./binarywriter */ "./node_modules/wkx/lib/binarywriter.js");

function Polygon(exteriorRing, interiorRings, srid) {
    Geometry.call(this);

    this.exteriorRing = exteriorRing || [];
    this.interiorRings = interiorRings || [];
	this.srid = srid;

    if (this.exteriorRing.length > 0) {
        this.hasZ = this.exteriorRing[0].hasZ;
        this.hasM = this.exteriorRing[0].hasM;
    }
}

util.inherits(Polygon, Geometry);

Polygon.Z = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    return polygon;
};

Polygon.M = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasM = true;
    return polygon;
};

Polygon.ZM = function (exteriorRing, interiorRings, srid) {
    var polygon = new Polygon(exteriorRing, interiorRings, srid);
    polygon.hasZ = true;
    polygon.hasM = true;
    return polygon;
};

Polygon._parseWkt = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (value.isMatch(['EMPTY']))
        return polygon;

    value.expectGroupStart();

    value.expectGroupStart();
    polygon.exteriorRing.push.apply(polygon.exteriorRing, value.matchCoordinates(options));
    value.expectGroupEnd();

    while (value.isMatch([','])) {
        value.expectGroupStart();
        polygon.interiorRings.push(value.matchCoordinates(options));
        value.expectGroupEnd();
    }

    value.expectGroupEnd();

    return polygon;
};

Polygon._parseWkb = function (value, options) {
    var polygon = new Polygon();
    polygon.srid = options.srid;
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    var ringCount = value.readUInt32();

    if (ringCount > 0) {
        var exteriorRingCount = value.readUInt32();

        for (var i = 0; i < exteriorRingCount; i++)
            polygon.exteriorRing.push(Point._readWkbPoint(value, options));

        for (i = 1; i < ringCount; i++) {
            var interiorRing = [];

            var interiorRingCount = value.readUInt32();

            for (var j = 0; j < interiorRingCount; j++)
                interiorRing.push(Point._readWkbPoint(value, options));

            polygon.interiorRings.push(interiorRing);
        }
    }

    return polygon;
};

Polygon._parseTwkb = function (value, options) {
    var polygon = new Polygon();
    polygon.hasZ = options.hasZ;
    polygon.hasM = options.hasM;

    if (options.isEmpty)
        return polygon;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var ringCount = value.readVarInt();
    var exteriorRingCount = value.readVarInt();

    for (var i = 0; i < exteriorRingCount; i++)
        polygon.exteriorRing.push(Point._readTwkbPoint(value, options, previousPoint));

    for (i = 1; i < ringCount; i++) {
        var interiorRing = [];

        var interiorRingCount = value.readVarInt();

        for (var j = 0; j < interiorRingCount; j++)
            interiorRing.push(Point._readTwkbPoint(value, options, previousPoint));

        polygon.interiorRings.push(interiorRing);
    }

    return polygon;
};

Polygon._parseGeoJSON = function (value) {
    var polygon = new Polygon();

    if (value.coordinates.length > 0 && value.coordinates[0].length > 0)
        polygon.hasZ = value.coordinates[0][0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++) {
        if (i > 0)
            polygon.interiorRings.push([]);

        for (var j = 0; j  < value.coordinates[i].length; j++) {
            if (i === 0)
                polygon.exteriorRing.push(Point._readGeoJSONPoint(value.coordinates[i][j]));
            else
                polygon.interiorRings[i - 1].push(Point._readGeoJSONPoint(value.coordinates[i][j]));
        }
    }

    return polygon;
};

Polygon.prototype.toWkt = function () {
    if (this.exteriorRing.length === 0)
        return this._getWktType(Types.wkt.Polygon, true);

    return this._getWktType(Types.wkt.Polygon, false) + this._toInnerWkt();
};

Polygon.prototype._toInnerWkt = function () {
    var innerWkt = '((';

    for (var i = 0; i < this.exteriorRing.length; i++)
        innerWkt += this._getWktCoordinate(this.exteriorRing[i]) + ',';

    innerWkt = innerWkt.slice(0, -1);
    innerWkt += ')';

    for (i = 0; i < this.interiorRings.length; i++) {
        innerWkt += ',(';

        for (var j = 0; j < this.interiorRings[i].length; j++) {
            innerWkt += this._getWktCoordinate(this.interiorRings[i][j]) + ',';
        }

        innerWkt = innerWkt.slice(0, -1);
        innerWkt += ')';
    }

    innerWkt += ')';

    return innerWkt;
};

Polygon.prototype.toWkb = function (parentOptions) {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

    this._writeWkbType(wkb, Types.wkb.Polygon, parentOptions);

    if (this.exteriorRing.length > 0) {
        wkb.writeUInt32LE(1 + this.interiorRings.length);
        wkb.writeUInt32LE(this.exteriorRing.length);
    }
    else {
        wkb.writeUInt32LE(0);
    }

    for (var i = 0; i < this.exteriorRing.length; i++)
        this.exteriorRing[i]._writeWkbPoint(wkb);

    for (i = 0; i < this.interiorRings.length; i++) {
        wkb.writeUInt32LE(this.interiorRings[i].length);

        for (var j = 0; j < this.interiorRings[i].length; j++)
            this.interiorRings[i][j]._writeWkbPoint(wkb);
    }

    return wkb.buffer;
};

Polygon.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.exteriorRing.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.Polygon, precision, isEmpty);

    if (this.exteriorRing.length > 0) {
        twkb.writeVarInt(1 + this.interiorRings.length);

        twkb.writeVarInt(this.exteriorRing.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.exteriorRing.length; i++)
            this.exteriorRing[i]._writeTwkbPoint(twkb, precision, previousPoint);

        for (i = 0; i < this.interiorRings.length; i++) {
            twkb.writeVarInt(this.interiorRings[i].length);

            for (var j = 0; j < this.interiorRings[i].length; j++)
                this.interiorRings[i][j]._writeTwkbPoint(twkb, precision, previousPoint);
        }
    }

    return twkb.buffer;
};

Polygon.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    var size = 1 + 4 + 4;

    if (this.exteriorRing.length > 0)
        size += 4 + (this.exteriorRing.length * coordinateSize);

    for (var i = 0; i < this.interiorRings.length; i++)
        size += 4 + (this.interiorRings[i].length * coordinateSize);

    return size;
};

Polygon.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.Polygon;
    geoJSON.coordinates = [];

    if (this.exteriorRing.length > 0) {
        var exteriorRing = [];

        for (var i = 0; i < this.exteriorRing.length; i++) {
            if (this.hasZ)
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y, this.exteriorRing[i].z]);
            else
                exteriorRing.push([this.exteriorRing[i].x, this.exteriorRing[i].y]);
        }

        geoJSON.coordinates.push(exteriorRing);
    }

    for (var j = 0; j < this.interiorRings.length; j++) {
        var interiorRing = [];

        for (var k = 0; k < this.interiorRings[j].length; k++) {
            if (this.hasZ)
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y, this.interiorRings[j][k].z]);
            else
                interiorRing.push([this.interiorRings[j][k].x, this.interiorRings[j][k].y]);
        }

        geoJSON.coordinates.push(interiorRing);
    }

    return geoJSON;
};


/***/ }),

/***/ "./node_modules/wkx/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/wkx/lib/types.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = {
    wkt: {
        Point: 'POINT',
        LineString: 'LINESTRING',
        Polygon: 'POLYGON',
        MultiPoint: 'MULTIPOINT',
        MultiLineString: 'MULTILINESTRING',
        MultiPolygon: 'MULTIPOLYGON',
        GeometryCollection: 'GEOMETRYCOLLECTION'
    },
    wkb: {
        Point: 1,
        LineString: 2,
        Polygon: 3,
        MultiPoint: 4,
        MultiLineString: 5,
        MultiPolygon: 6,
        GeometryCollection: 7
    },
    geoJSON: {
        Point: 'Point',
        LineString: 'LineString',
        Polygon: 'Polygon',
        MultiPoint: 'MultiPoint',
        MultiLineString: 'MultiLineString',
        MultiPolygon: 'MultiPolygon',
        GeometryCollection: 'GeometryCollection'
    }
};


/***/ }),

/***/ "./node_modules/wkx/lib/wktparser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkx/lib/wktparser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = WktParser;

var Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
var Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");

function WktParser(value) {
    this.value = value;
    this.position = 0;
}

WktParser.prototype.match = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return tokens[i];
        }
    }

    return null;
};

WktParser.prototype.matchRegex = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        var match = this.value.substring(this.position).match(tokens[i]);

        if (match) {
            this.position += match[0].length;
            return match;
        }
    }

    return null;
};

WktParser.prototype.isMatch = function (tokens) {
    this.skipWhitespaces();

    for (var i = 0; i < tokens.length; i++) {
        if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {
            this.position += tokens[i].length;
            return true;
        }
    }

    return false;
};

WktParser.prototype.matchType = function () {
    var geometryType = this.match([Types.wkt.Point, Types.wkt.LineString, Types.wkt.Polygon, Types.wkt.MultiPoint,
    Types.wkt.MultiLineString, Types.wkt.MultiPolygon, Types.wkt.GeometryCollection]);

    if (!geometryType)
        throw new Error('Expected geometry type');

    return geometryType;
};

WktParser.prototype.matchDimension = function () {
    var dimension = this.match(['ZM', 'Z', 'M']);

    switch (dimension) {
        case 'ZM': return { hasZ: true, hasM: true };
        case 'Z': return { hasZ: true, hasM: false };
        case 'M': return { hasZ: false, hasM: true };
        default: return { hasZ: false, hasM: false };
    }
};

WktParser.prototype.expectGroupStart = function () {
    if (!this.isMatch(['(']))
        throw new Error('Expected group start');
};

WktParser.prototype.expectGroupEnd = function () {
    if (!this.isMatch([')']))
        throw new Error('Expected group end');
};

WktParser.prototype.matchCoordinate = function (options) {
    var match;

    if (options.hasZ && options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else if (options.hasZ || options.hasM)
        match = this.matchRegex([/^(\S*)\s+(\S*)\s+([^\s,)]*)/]);
    else
        match = this.matchRegex([/^(\S*)\s+([^\s,)]*)/]);

    if (!match)
        throw new Error('Expected coordinates');

    if (options.hasZ && options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4]));
    else if (options.hasZ)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]));
    else if (options.hasM)
        return new Point(parseFloat(match[1]), parseFloat(match[2]), undefined, parseFloat(match[3]));
    else
        return new Point(parseFloat(match[1]), parseFloat(match[2]));
};

WktParser.prototype.matchCoordinates = function (options) {
    var coordinates = [];

    do {
        var startsWithBracket = this.isMatch(['(']);

        coordinates.push(this.matchCoordinate(options));

        if (startsWithBracket)
            this.expectGroupEnd();
    } while (this.isMatch([',']));

    return coordinates;
};

WktParser.prototype.skipWhitespaces = function () {
    while (this.position < this.value.length && this.value[this.position] === ' ')
        this.position++;
};


/***/ }),

/***/ "./node_modules/wkx/lib/wkx.js":
/*!*************************************!*\
  !*** ./node_modules/wkx/lib/wkx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.Types = __webpack_require__(/*! ./types */ "./node_modules/wkx/lib/types.js");
exports.Geometry = __webpack_require__(/*! ./geometry */ "./node_modules/wkx/lib/geometry.js");
exports.Point = __webpack_require__(/*! ./point */ "./node_modules/wkx/lib/point.js");
exports.LineString = __webpack_require__(/*! ./linestring */ "./node_modules/wkx/lib/linestring.js");
exports.Polygon = __webpack_require__(/*! ./polygon */ "./node_modules/wkx/lib/polygon.js");
exports.MultiPoint = __webpack_require__(/*! ./multipoint */ "./node_modules/wkx/lib/multipoint.js");
exports.MultiLineString = __webpack_require__(/*! ./multilinestring */ "./node_modules/wkx/lib/multilinestring.js");
exports.MultiPolygon = __webpack_require__(/*! ./multipolygon */ "./node_modules/wkx/lib/multipolygon.js");
exports.GeometryCollection = __webpack_require__(/*! ./geometrycollection */ "./node_modules/wkx/lib/geometrycollection.js");

/***/ }),

/***/ "./node_modules/wkx/lib/zigzag.js":
/*!****************************************!*\
  !*** ./node_modules/wkx/lib/zigzag.js ***!
  \****************************************/
/***/ ((module) => {

module.exports = {
    encode: function (value) {
        return (value << 1) ^ (value >> 31);
    },
    decode: function (value) {
        return (value >> 1) ^ (-(value & 1));
    }
};


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("debug");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("glob");;

/***/ }),

/***/ "lodash/_baseIsNative":
/*!***************************************!*\
  !*** external "lodash/_baseIsNative" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/_baseIsNative");;

/***/ }),

/***/ "lru-cache":
/*!****************************!*\
  !*** external "lru-cache" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("lru-cache");;

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment");;

/***/ }),

/***/ "moment-timezone":
/*!**********************************!*\
  !*** external "moment-timezone" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment-timezone");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");;

/***/ })

};
exports.runtime =
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ "use strict";
/******/ 
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("f60a69dc81bb51648bb8")
/******/ })();
/******/ 
/******/ }
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2UvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYW55LXByb21pc2V8c3luYyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9kb3R0aWUvZG90dGllLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2luZmxlY3Rpb24vbGliL2luZmxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JldHJ5LWFzLXByb21pc2VkL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcmNvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS1wb29sL2xpYi9BZ2dyZWdhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvRGVmZXJyZWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1Bvb2wuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXBvb2wvbGliL1RpbWVvdXRFcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtcG9vbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYWxpYXMtaW5mZXJlbmNlL2FsaWFzLWluZmVyZW5jZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueS1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvYmVsb25ncy10by9iZWxvbmdzLXRvLWFzc29jaWF0aW9uLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8vYmVsb25ncy10by5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtYXNzb2NpYXRpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9hc3NvY2lhdGlvbnMvaGFzL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL2hhcy9oYXMtb25lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvYXNzb2NpYXRpb25zL3NoYXJlZC9hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvYmFzZS1hc3NvY2lhdGlvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy9zaGFyZWQvdW5pb24tYXNzb2NpYXRpb24tb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2Fzc29jaWF0aW9ucy90aHJvdWdoL3Rocm91Z2gtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXJlc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1zeW5jLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3MvYnVsay9iZWZvcmUvYmVmb3JlLWJ1bGstdXBkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL2hvb2stb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NoYXJlZC9ob29rcy1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2hhcmVkL3ZhbGlkYXRpb24tZmFpbGVkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWNvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1kZXN0cm95LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWZpbmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItaW5pdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXNhdmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItc3luYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItdXBzZXJ0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXZhbGlkYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY29ubmVjdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNvdW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY3JlYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVmaW5lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWZpbmQtYWZ0ZXItZXhwYW5kLWluY2x1ZGUtYWxsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC1hZnRlci1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWluaXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1yZXN0b3JlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtc2F2ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXN5bmMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cGRhdGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cHNlcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS12YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2FsbG93LW51bGwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvY29tbWVudC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9kZWZhdWx0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL3VuaXF1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvYXV0by1pbmNyZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vcHJpbWFyeS1rZXkvcHJpbWFyeS1rZXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy9jcmVhdGVkLWF0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvY29sdW1uL3RpbWVzdGFtcHMvZGVsZXRlZC1hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL2NvbHVtbi90aW1lc3RhbXBzL3VwZGF0ZWQtYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9pbmRleC9jcmVhdGUtaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtZGVjb3JhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvaW5kZXgvaW5kZXgtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWFjdGlvbi1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvYXNzb2NpYXRpb24vYXNzb2NpYXRpb24tY291bnQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWdldC1vcHRpb25zLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvbW9kZWwvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9tb2RlbC9zaGFyZWQvbW9kZWwtY2xhc3MtZ2V0dGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvbW9kZWwvdGFibGUvdGFibGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L21vZGVsL3RhYmxlL3RhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL2RlZmF1bHQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGUtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3Njb3Blcy9zY29wZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2NvcGVzL3Njb3BlLXRhYmxlLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zY29wZXMvc2NvcGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9kYXRhLXR5cGUvZGF0YS10eXBlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3JlcG9zaXRvcnkvcmVwb3NpdG9yeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3NlcXVlbGl6ZS9zZXF1ZWxpemUvc2VxdWVsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZS1zZXJ2aWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplfHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvdmFsaWRhdGlvbi1vbmx5L2RiLWRpYWxlY3QtZHVtbXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zaGFyZWQvb2JqZWN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3Qvc2hhcmVkL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtYWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1hbHBoYW51bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWFycmF5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1iZWZvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWNyZWRpdC1jYXJkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kYXRlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1kZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1lbWFpbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pbnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWlwLXY0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy1pcC12Ni5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtaXAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLWxvd2VyY2FzZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtbnVtZXJpYy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vaXMtdXBwZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9pcy11cmwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLXV1aWQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL2lzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL21heC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC92YWxpZGF0aW9uL25vdC1lbXB0eS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LWluLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi9ub3QtbnVsbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vbm90LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS10eXBlc2NyaXB0L2Rpc3QvdmFsaWRhdGlvbi92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUtdHlwZXNjcmlwdC9kaXN0L3ZhbGlkYXRpb24vdmFsaWRhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1tYW55LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1vbmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9taXhpbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvaGVscGVycy9xdW90ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0fHN5bmMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktaW50ZXJmYWNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9hZ2dyZWdhdGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9idWxrLXJlY29yZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vYWNjZXNzLWRlbmllZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tYWNxdWlyZS10aW1lb3V0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2VhZ2VyLWxvYWRpbmctZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luZGV4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luc3RhbmNlLWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL29wdGltaXN0aWMtbG9jay1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9xdWVyeS1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9zZXF1ZWxpemUtc2NvcGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaG9va3MuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luc3RhbmNlLXZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL21vZGVsLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL29wZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3F1ZXJ5LXR5cGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc2VxdWVsaXplLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc3FsLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3RhYmxlLWhpbnRzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2RlcHJlY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvYnVpbGQvdG9wb3NvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvY29uZmlncy9zZXF1YWxpemUudHMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9zcmMvc2VydmVyLnRzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2FscGhhLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvYmxhY2tsaXN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0FmdGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNBbHBoYS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQWxwaGFudW1lcmljLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNBc2NpaS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzQmFzZTY0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNCZWZvcmUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0Jvb2xlYW4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0J5dGVMZW5ndGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0NyZWRpdENhcmQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0N1cnJlbmN5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEYXRhVVJJLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEZWNpbWFsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNEaXZpc2libGVCeS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRW1haWwuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0VtcHR5LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGUUROLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNGbG9hdC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRnVsbFdpZHRoLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNIYWxmV2lkdGguanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hhc2guanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0hleENvbG9yLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNIZXhhZGVjaW1hbC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVAuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lQUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTQk4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTSU4uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0lTTzMxNjYxQWxwaGEyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJU08zMTY2MUFscGhhMy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNPODYwMS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNSQy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSVNTTi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSWRlbnRpdHlDYXJkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNJbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzSW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNKU09OLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNKV1QuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0xhdExvbmcuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTG93ZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNQUNBZGRyZXNzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNRDUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01hZ25ldFVSSS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzTWltZVR5cGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc01vYmlsZVBob25lLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNb25nb0lkLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNNdWx0aWJ5dGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc051bWVyaWMuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1BvcnQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1Bvc3RhbENvZGUuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1JGQzMzMzkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1N1cnJvZ2F0ZVBhaXIuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9pc1VSTC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzVVVJRC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzVXBwZXJjYXNlLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNWYXJpYWJsZVdpZHRoLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNXaGl0ZWxpc3RlZC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2x0cmltLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvbWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL25vcm1hbGl6ZUVtYWlsLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvcnRyaW0uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi9zdHJpcExvdy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvQm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvRGF0ZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RvRmxvYXQuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi90b0ludC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3RyaW0uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91bmVzY2FwZS5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvYXNzZXJ0U3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL2xpYi91dGlsL3RvU3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvd2hpdGVsaXN0LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvYmluYXJ5cmVhZGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvYmluYXJ5d3JpdGVyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvZ2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9nZW9tZXRyeWNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvd2t4L2xpYi9saW5lc3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvbXVsdGlsaW5lc3RyaW5nLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvbXVsdGlwb2ludC5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL211bHRpcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3BvaW50LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy93a3gvbGliL3R5cGVzLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvd2t0cGFyc2VyLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvd2t4LmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3dreC9saWIvemlnemFnLmpzIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImRlYnVnXCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwiZ2xvYlwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibG9kYXNoL19iYXNlSXNOYXRpdmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcImxydS1jYWNoZVwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwibW9tZW50XCIiLCJ3ZWJwYWNrOi8vbm9kZS1hcGktdGVtcGxhdGUvZXh0ZXJuYWwgXCJtb21lbnQtdGltZXpvbmVcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly9ub2RlLWFwaS10ZW1wbGF0ZS9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXRpbFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL2V4dGVybmFsIFwidXVpZFwiIiwid2VicGFjazovL25vZGUtYXBpLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUJBQWlCLG1CQUFPLENBQUMsMERBQVk7Ozs7Ozs7Ozs7OztBQ0F6QjtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdFWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxpRUFBUSxjQUFjLENBQUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVM7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxLQUE2QjtBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5Qjs7QUFFekIsUUFBUSxJQUE0QjtBQUNwQyxNQUFNLGlDQUFPLEVBQUUsbUNBQUUsYUFBYSxlQUFlLEVBQUU7QUFBQSxrR0FBQztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUMvTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUU7QUFDeEIsR0FBRyxLQUFLLEVBSUw7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3REFBd0QsdUNBQXVDO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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cEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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QTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsV0FBVyxTQUFTLEVBQUU7QUFDckY7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbmxCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDYmE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw4REFBVTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBMkI7QUFDckQsa0JBQWtCLHVIQUE2QztBQUMvRCxPQUFPLFlBQVksR0FBRyxtQkFBTyxDQUFDLGtCQUFNOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsRUFBRTtBQUNmLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7O0FBRUE7O0FBRUE7QUFDQSw4REFBOEQsY0FBYyxNQUFNLE1BQU0sWUFBWSw4Q0FBOEM7QUFDbEo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DLEdBQUcsTUFBTTs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQyxzQkFBc0I7Ozs7Ozs7Ozs7OztBQ2phVDs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDekMsVUFBVSxtQkFBTyxDQUFDLHNCQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUMvRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixXQUFXLEdBQUcsY0FBYztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQixzQkFBc0I7Ozs7Ozs7Ozs7OztBQ2pHVDs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLHNCQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFL0IsY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLE9BQU8sU0FBUyxHQUFHLG1CQUFPLENBQUMsb0VBQWdCO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBZ0M7QUFDOUQsMEJBQTBCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLGtFQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLDhEQUFVO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFxQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBeUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWM7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLDBCQUEwQixtQkFBTyxDQUFDLGdGQUFzQjtBQUN4RCxXQUFXLG1CQUFPLENBQUMsOERBQWE7QUFDaEMsT0FBTyxzQkFBc0IsR0FBRyxtQkFBTyxDQUFDLGdGQUFzQjs7O0FBRzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVCQUF1QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sWUFBWTtBQUNoQyxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE4RixZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsZUFBZTtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUSxzQkFBc0IsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLHlEQUF5RCxtREFBbUQ7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULHVCQUF1QixlQUFlLEdBQUcsS0FBSztBQUM5Qzs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEUsd0NBQXdDO0FBQ3BIO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLFlBQVksSUFBSSxZQUFZO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEdBQTBHLFlBQVk7QUFDdEgsOEhBQThILFlBQVk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxvRUFBb0UsMERBQTBEO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsaUJBQWlCLFFBQVE7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkZBQWtDOztBQUV0RCxxQkFBcUIsVUFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FB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Q0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0VBQW9FO0FBQ3ZIO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUMvWEE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QixZQUFZLG1CQUFPLENBQUMsZ0RBQVM7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNEQUFZO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFnQjs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLDRCQUE0QjtBQUMvQyxrREFBa0Qsa0JBQWtCOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLDRCQUE0QjtBQUMvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw0QkFBNEI7QUFDL0M7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUN4S0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QixlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGdEQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxnREFBUztBQUM3QixtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw4QkFBOEI7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakxBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFekIsWUFBWSxtQkFBTyxDQUFDLGdEQUFTO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTtBQUNuQyxZQUFZLG1CQUFPLENBQUMsZ0RBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsMERBQWM7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsOERBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw4QkFBOEI7QUFDakQsbUVBQW1FLG9DQUFvQzs7QUFFdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLDZCQUE2QjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbURBQW1ELGtCQUFrQjs7QUFFckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7O0FBRUEsMkJBQTJCLHVDQUF1QztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNkJBQTZCO0FBQ2hEOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUxBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFekIsWUFBWSxtQkFBTyxDQUFDLGdEQUFTO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTtBQUNuQyxZQUFZLG1CQUFPLENBQUMsZ0RBQVM7QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsOERBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pELG9EQUFvRCxvQ0FBb0M7O0FBRXhGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDLDhDQUE4QyxrQkFBa0I7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQzs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQzNLQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCLFlBQVksbUJBQU8sQ0FBQyxnREFBUztBQUM3QixlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGdEQUFTO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxvREFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5Qzs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQTs7QUFFQSwyQkFBMkIsdUJBQXVCO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pELDBEQUEwRCxvQ0FBb0M7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDLGdEQUFnRCxrQkFBa0I7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEOztBQUVBOztBQUVBLDJCQUEyQiwwQ0FBMEM7QUFDckU7O0FBRUEsdUJBQXVCLDJDQUEyQztBQUNsRTs7QUFFQSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDBCQUEwQjtBQUM3Qzs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTtBQUNuQyxZQUFZLG1CQUFPLENBQUMsZ0RBQVM7QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsOERBQWdCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxxREFBYTs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUN4TkE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QixlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGdEQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxnREFBUztBQUM3QixtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5Qzs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQTs7QUFFQSwyQkFBMkIsdUJBQXVCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7O0FBRUEsZUFBZSxlQUFlO0FBQzlCOztBQUVBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUEsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiw4QkFBOEI7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLCtCQUErQjtBQUM5Qzs7QUFFQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCO0FBQ2pEOztBQUVBLGVBQWUsK0JBQStCO0FBQzlDOztBQUVBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLDhCQUE4QjtBQUNyRDs7QUFFQSxtQkFBbUIsK0JBQStCO0FBQ2xEOztBQUVBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7O0FBRUEsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxnREFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsZ0RBQVM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNIQSxxRkFBa0M7QUFDbEMsOEZBQXdDO0FBQ3hDLHFGQUFrQztBQUNsQyxvR0FBNEM7QUFDNUMsMkZBQXNDO0FBQ3RDLG9HQUE0QztBQUM1QyxtSEFBc0Q7QUFDdEQsMEdBQWdEO0FBQ2hELDRIQUE0RCxDOzs7Ozs7Ozs7O0FDUjVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEEsb0M7Ozs7Ozs7Ozs7O0FDQUEsb0M7Ozs7Ozs7Ozs7O0FDQUEsbUM7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsa0Q7Ozs7Ozs7Ozs7O0FDQUEsdUM7Ozs7Ozs7Ozs7O0FDQUEsb0M7Ozs7Ozs7Ozs7O0FDQUEsNkM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsaUM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O1VDQUEsc0QiLCJmaWxlIjoibWFpbi5kODgzYTYwYWUzYWJmYzRkYzAwMy5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlZ2lzdGVyJykoKS5Qcm9taXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuICAgIC8vIGdsb2JhbCBrZXkgZm9yIHVzZXIgcHJlZmVycmVkIHJlZ2lzdHJhdGlvblxudmFyIFJFR0lTVFJBVElPTl9LRVkgPSAnQEBhbnktcHJvbWlzZS9SRUdJU1RSQVRJT04nLFxuICAgIC8vIFByaW9yIHJlZ2lzdHJhdGlvbiAocHJlZmVycmVkIG9yIGRldGVjdGVkKVxuICAgIHJlZ2lzdGVyZWQgPSBudWxsXG5cbi8qKlxuICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBpbXBsZW1lbnRhdGlvbi4gIEFuIGltcGxlbWVudGF0aW9uIG11c3RcbiAqIGJlIHJlZ2lzdGVyZWQgcHJpb3IgdG8gYW55IGNhbGwgdG8gYHJlcXVpcmUoXCJhbnktcHJvbWlzZVwiKWAsXG4gKiB0eXBpY2FsbHkgb24gYXBwbGljYXRpb24gbG9hZC5cbiAqXG4gKiBJZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHdpbGwgcmV0dXJuIHJlZ2lzdHJhdGlvbiBpblxuICogZm9sbG93aW5nIHByaW9yaXR5OlxuICpcbiAqIEZvciBOb2RlLmpzOlxuICpcbiAqIDEuIFByZXZpb3VzIHJlZ2lzdHJhdGlvblxuICogMi4gZ2xvYmFsLlByb21pc2UgaWYgbm9kZS5qcyB2ZXJzaW9uID49IDAuMTJcbiAqIDMuIEF1dG8gZGV0ZWN0ZWQgcHJvbWlzZSBiYXNlZCBvbiBmaXJzdCBzdWNlc3NmdWwgcmVxdWlyZSBvZlxuICogICAga25vd24gcHJvbWlzZSBsaWJyYXJpZXMuIE5vdGUgdGhpcyBpcyBhIGxhc3QgcmVzb3J0LCBhcyB0aGVcbiAqICAgIGxvYWRlZCBsaWJyYXJ5IGlzIG5vbi1kZXRlcm1pbmlzdGljLiBub2RlLmpzID49IDAuMTIgd2lsbFxuICogICAgYWx3YXlzIHVzZSBnbG9iYWwuUHJvbWlzZSBvdmVyIHRoaXMgcHJpb3JpdHkgbGlzdC5cbiAqIDQuIFRocm93cyBlcnJvci5cbiAqXG4gKiBGb3IgQnJvd3NlcjpcbiAqXG4gKiAxLiBQcmV2aW91cyByZWdpc3RyYXRpb25cbiAqIDIuIHdpbmRvdy5Qcm9taXNlXG4gKiAzLiBUaHJvd3MgZXJyb3IuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiBQcm9taXNlOiBEZXNpcmVkIFByb21pc2UgY29uc3RydWN0b3JcbiAqIGdsb2JhbDogQm9vbGVhbiAtIFNob3VsZCB0aGUgcmVnaXN0cmF0aW9uIGJlIGNhY2hlZCBpbiBhIGdsb2JhbCB2YXJpYWJsZSB0b1xuICogYWxsb3cgY3Jvc3MgZGVwZW5kZW5jeS9idW5kbGUgcmVnaXN0cmF0aW9uPyAgKGRlZmF1bHQgdHJ1ZSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyb290LCBsb2FkSW1wbGVtZW50YXRpb24pe1xuICByZXR1cm4gZnVuY3Rpb24gcmVnaXN0ZXIoaW1wbGVtZW50YXRpb24sIG9wdHMpe1xuICAgIGltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb24gfHwgbnVsbFxuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvbiB1bmxlc3MgZXhwbGljaXRseSAge2dsb2JhbDogZmFsc2V9IGluIG9wdGlvbnMgKGRlZmF1bHQgdHJ1ZSlcbiAgICB2YXIgcmVnaXN0ZXJHbG9iYWwgPSBvcHRzLmdsb2JhbCAhPT0gZmFsc2U7XG5cbiAgICAvLyBsb2FkIGFueSBwcmV2aW91cyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgaWYocmVnaXN0ZXJlZCA9PT0gbnVsbCAmJiByZWdpc3Rlckdsb2JhbCl7XG4gICAgICByZWdpc3RlcmVkID0gcm9vdFtSRUdJU1RSQVRJT05fS0VZXSB8fCBudWxsXG4gICAgfVxuXG4gICAgaWYocmVnaXN0ZXJlZCAhPT0gbnVsbFxuICAgICAgICAmJiBpbXBsZW1lbnRhdGlvbiAhPT0gbnVsbFxuICAgICAgICAmJiByZWdpc3RlcmVkLmltcGxlbWVudGF0aW9uICE9PSBpbXBsZW1lbnRhdGlvbil7XG4gICAgICAvLyBUaHJvdyBlcnJvciBpZiBhdHRlbXB0aW5nIHRvIHJlZGVmaW5lIGltcGxlbWVudGF0aW9uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FueS1wcm9taXNlIGFscmVhZHkgZGVmaW5lZCBhcyBcIicrcmVnaXN0ZXJlZC5pbXBsZW1lbnRhdGlvbitcbiAgICAgICAgJ1wiLiAgWW91IGNhbiBvbmx5IHJlZ2lzdGVyIGFuIGltcGxlbWVudGF0aW9uIGJlZm9yZSB0aGUgZmlyc3QgJytcbiAgICAgICAgJyBjYWxsIHRvIHJlcXVpcmUoXCJhbnktcHJvbWlzZVwiKSBhbmQgYW4gaW1wbGVtZW50YXRpb24gY2Fubm90IGJlIGNoYW5nZWQnKVxuICAgIH1cblxuICAgIGlmKHJlZ2lzdGVyZWQgPT09IG51bGwpe1xuICAgICAgLy8gdXNlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9uXG4gICAgICBpZihpbXBsZW1lbnRhdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5Qcm9taXNlICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIHJlZ2lzdGVyZWQgPSB7XG4gICAgICAgICAgUHJvbWlzZTogb3B0cy5Qcm9taXNlLFxuICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXF1aXJlIGltcGxlbWVudGF0aW9uIGlmIGltcGxlbWVudGF0aW9uIGlzIHNwZWNpZmllZCBidXQgbm90IHByb3ZpZGVkXG4gICAgICAgIHJlZ2lzdGVyZWQgPSBsb2FkSW1wbGVtZW50YXRpb24oaW1wbGVtZW50YXRpb24pXG4gICAgICB9XG5cbiAgICAgIGlmKHJlZ2lzdGVyR2xvYmFsKXtcbiAgICAgICAgLy8gcmVnaXN0ZXIgcHJlZmVyZW5jZSBnbG9iYWxseSBpbiBjYXNlIG11bHRpcGxlIGluc3RhbGxhdGlvbnNcbiAgICAgICAgcm9vdFtSRUdJU1RSQVRJT05fS0VZXSA9IHJlZ2lzdGVyZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJlZFxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xvYWRlcicpKGdsb2JhbCwgbG9hZEltcGxlbWVudGF0aW9uKTtcblxuLyoqXG4gKiBOb2RlLmpzIHZlcnNpb24gb2YgbG9hZEltcGxlbWVudGF0aW9uLlxuICpcbiAqIFJlcXVpcmVzIHRoZSBnaXZlbiBpbXBsZW1lbnRhdGlvbiBhbmQgcmV0dXJucyB0aGUgcmVnaXN0cmF0aW9uXG4gKiBjb250YWluaW5nIHtQcm9taXNlLCBpbXBsZW1lbnRhdGlvbn1cbiAqXG4gKiBJZiBpbXBsZW1lbnRhdGlvbiBpcyB1bmRlZmluZWQgb3IgZ2xvYmFsLlByb21pc2UsIGxvYWRzIGl0XG4gKiBPdGhlcndpc2UgdXNlcyByZXF1aXJlXG4gKi9cbmZ1bmN0aW9uIGxvYWRJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbil7XG4gIHZhciBpbXBsID0gbnVsbFxuXG4gIGlmKHNob3VsZFByZWZlckdsb2JhbFByb21pc2UoaW1wbGVtZW50YXRpb24pKXtcbiAgICAvLyBpZiBubyBpbXBsZW1lbnRhdGlvbiBvciBlbnYgc3BlY2lmaWVkIHVzZSBnbG9iYWwuUHJvbWlzZVxuICAgIGltcGwgPSB7XG4gICAgICBQcm9taXNlOiBnbG9iYWwuUHJvbWlzZSxcbiAgICAgIGltcGxlbWVudGF0aW9uOiAnZ2xvYmFsLlByb21pc2UnXG4gICAgfVxuICB9IGVsc2UgaWYoaW1wbGVtZW50YXRpb24pe1xuICAgIC8vIGlmIGltcGxlbWVudGF0aW9uIHNwZWNpZmllZCwgcmVxdWlyZSBpdFxuICAgIHZhciBsaWIgPSByZXF1aXJlKGltcGxlbWVudGF0aW9uKVxuICAgIGltcGwgPSB7XG4gICAgICBQcm9taXNlOiBsaWIuUHJvbWlzZSB8fCBsaWIsXG4gICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdHJ5IHRvIGF1dG8gZGV0ZWN0IGltcGxlbWVudGF0aW9uLiBUaGlzIGlzIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgLy8gYW5kIHNob3VsZCBwcmVmZXIgb3RoZXIgYnJhbmNoZXMsIGJ1dCB0aGlzIGlzIG91ciBsYXN0IGNoYW5jZVxuICAgIC8vIHRvIGxvYWQgc29tZXRoaW5nIHdpdGhvdXQgdGhyb3dpbmcgZXJyb3JcbiAgICBpbXBsID0gdHJ5QXV0b0RldGVjdCgpXG4gIH1cblxuICBpZihpbXBsID09PSBudWxsKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGFueS1wcm9taXNlIGltcGxlbWVudGF0aW9uIG5vcicrXG4gICAgICAnIGdsb2JhbC5Qcm9taXNlLiBZb3UgbXVzdCBpbnN0YWxsIHBvbHlmaWxsIG9yIGNhbGwnK1xuICAgICAgJyByZXF1aXJlKFwiYW55LXByb21pc2UvcmVnaXN0ZXJcIikgd2l0aCB5b3VyIHByZWZlcnJlZCcrXG4gICAgICAnIGltcGxlbWVudGF0aW9uLCBlLmcuIHJlcXVpcmUoXCJhbnktcHJvbWlzZS9yZWdpc3Rlci9ibHVlYmlyZFwiKScrXG4gICAgICAnIG9uIGFwcGxpY2F0aW9uIGxvYWQgcHJpb3IgdG8gYW55IHJlcXVpcmUoXCJhbnktcHJvbWlzZVwiKS4nKVxuICB9XG5cbiAgcmV0dXJuIGltcGxcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnbG9iYWwuUHJvbWlzZSBzaG91bGQgYmUgcHJlZmVycmVkIGlmIGFuIGltcGxlbWVudGF0aW9uXG4gKiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJlZmVyR2xvYmFsUHJvbWlzZShpbXBsZW1lbnRhdGlvbil7XG4gIGlmKGltcGxlbWVudGF0aW9uKXtcbiAgICByZXR1cm4gaW1wbGVtZW50YXRpb24gPT09ICdnbG9iYWwuUHJvbWlzZSdcbiAgfSBlbHNlIGlmKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIC8vIExvYWQgZ2xvYmFsIHByb21pc2UgaWYgaW1wbGVtZW50YXRpb24gbm90IHNwZWNpZmllZFxuICAgIC8vIFZlcnNpb25zIDwgMC4xMSBkaWQgbm90IGhhdmUgZ2xvYmFsIFByb21pc2VcbiAgICAvLyBEbyBub3QgdXNlIGZvciB2ZXJzaW9uIDwgMC4xMiBhcyB2ZXJzaW9uIDAuMTEgY29udGFpbmVkIGJ1Z2d5IHZlcnNpb25zXG4gICAgdmFyIHZlcnNpb24gPSAoL3YoXFxkKylcXC4oXFxkKylcXC4oXFxkKykvKS5leGVjKHByb2Nlc3MudmVyc2lvbilcbiAgICByZXR1cm4gISh2ZXJzaW9uICYmICt2ZXJzaW9uWzFdID09IDAgJiYgK3ZlcnNpb25bMl0gPCAxMilcbiAgfVxuXG4gIC8vIGRvIG5vdCBoYXZlIGdsb2JhbC5Qcm9taXNlIG9yIGFub3RoZXIgaW1wbGVtZW50YXRpb24gd2FzIHNwZWNpZmllZFxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBMb29rIGZvciBjb21tb24gbGlicyBhcyBsYXN0IHJlc29ydCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdFxuICogdGhpcyB3aWxsIHJldHVybiBhIGRlc2lyZWQgaW1wbGVtZW50YXRpb24gb3IgZXZlbiBiZSBkZXRlcm1pbmlzdGljLlxuICogVGhlIHByaW9yaXR5IGlzIGFsc28gbmVhcmx5IGFyYml0cmFyeS4gV2UgYXJlIG9ubHkgZG9pbmcgdGhpc1xuICogZm9yIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgPDAuMTIgdGhhdCBkbyBub3QgaGF2ZSBhIHJlYXNvbmFibGVcbiAqIGdsb2JhbC5Qcm9taXNlIGltcGxlbWVudGF0aW9uIGFuZCB3ZSB0aGUgdXNlciBoYXMgbm90IHJlZ2lzdGVyZWRcbiAqIHRoZSBwcmVmZXJlbmNlLiBUaGlzIHByZXNlcnZlcyB0aGUgYmVoYXZpb3Igb2YgYW55LXByb21pc2UgPD0gMC4xXG4gKiBhbmQgbWF5IGJlIGRlcHJlY2F0ZWQgb3IgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXG4gKi9cbmZ1bmN0aW9uIHRyeUF1dG9EZXRlY3QoKXtcbiAgdmFyIGxpYnMgPSBbXG4gICAgICBcImVzNi1wcm9taXNlXCIsXG4gICAgICBcInByb21pc2VcIixcbiAgICAgIFwibmF0aXZlLXByb21pc2Utb25seVwiLFxuICAgICAgXCJibHVlYmlyZFwiLFxuICAgICAgXCJyc3ZwXCIsXG4gICAgICBcIndoZW5cIixcbiAgICAgIFwicVwiLFxuICAgICAgXCJwaW5raWVcIixcbiAgICAgIFwibGllXCIsXG4gICAgICBcInZvd1wiXVxuICB2YXIgaSA9IDAsIGxlbiA9IGxpYnMubGVuZ3RoXG4gIGZvcig7IGkgPCBsZW47IGkrKyl7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2FkSW1wbGVtZW50YXRpb24obGlic1tpXSlcbiAgICB9IGNhdGNoKGUpe31cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL2FueS1wcm9taXNlIHN5bmMgcmVjdXJzaXZlXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7IiwiKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gV2VpcmQgSUUgc2hpdCwgb2JqZWN0cyBkbyBub3QgaGF2ZSBoYXNPd24sIGJ1dCB0aGUgcHJvdG90eXBlIGRvZXMuLi5cbiAgdmFyIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIHZhciByZXZlcnNlRHVwQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ICA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgYXJyYXlNYXhJbmRleCA9IGluZGV4IC0gMTtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICByZXN1bHRbYXJyYXlNYXhJbmRleCAtIGluZGV4XSA9IGFycmF5W2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBEb3R0aWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMikge1xuICAgICAgcmV0dXJuIERvdHRpZS5maW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gRG90dGllLnRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcblxuICAvLyBMZWdhY3kgc3ludGF4LCBjaGFuZ2VkIHN5bnRheCB0byBoYXZlIGdldC9zZXQgYmUgc2ltaWxhciBpbiBhcmcgb3JkZXJcbiAgRG90dGllLmZpbmQgPSBmdW5jdGlvbihwYXRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gRG90dGllLmdldChvYmplY3QsIHBhdGgpO1xuICB9O1xuXG4gIC8vIERvdHRpZSBtZW1vaXphdGlvbiBmbGFnXG4gIERvdHRpZS5tZW1vaXplUGF0aCA9IHRydWU7XG4gIHZhciBtZW1vaXplZCA9IHt9O1xuXG4gIC8vIFRyYXZlcnNlIG9iamVjdCBhY2NvcmRpbmcgdG8gcGF0aCwgcmV0dXJuIHZhbHVlIGlmIGZvdW5kIC0gUmV0dXJuIHVuZGVmaW5lZCBpZiBkZXN0aW5hdGlvbiBpcyB1bnJlYWNoYWJsZVxuICBEb3R0aWUuZ2V0ID0gZnVuY3Rpb24ob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsKSB7XG4gICAgaWYgKChvYmplY3QgPT09IHVuZGVmaW5lZCkgfHwgKG9iamVjdCA9PT0gbnVsbCkgfHwgKHBhdGggPT09IHVuZGVmaW5lZCkgfHwgKHBhdGggPT09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsO1xuICAgIH1cblxuICAgIHZhciBuYW1lcztcblxuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKERvdHRpZS5tZW1vaXplUGF0aCkge1xuICAgICAgICBpZiAobWVtb2l6ZWRbcGF0aF0pIHtcbiAgICAgICAgICBuYW1lcyA9IG1lbW9pemVkW3BhdGhdLnNsaWNlKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWVzID0gcGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKTtcbiAgICAgICAgICBtZW1vaXplZFtwYXRoXSA9IG5hbWVzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICBuYW1lcyA9IHJldmVyc2VEdXBBcnJheShwYXRoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmFtZXMubGVuZ3RoICYmIChvYmplY3QgPSBvYmplY3RbbmFtZXMucG9wKCldKSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCAhPT0gbnVsbCk7XG5cbiAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgYWNjZXNzaW5nIGEgY2hpbGRwcm9wIG9mIGEgbnVsbCB2YWx1ZVxuICAgIGlmIChvYmplY3QgPT09IG51bGwgJiYgbmFtZXMubGVuZ3RoKSBvYmplY3QgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gKG9iamVjdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbCA6IG9iamVjdCk7XG4gIH07XG5cbiAgRG90dGllLmV4aXN0cyA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCkge1xuICAgIHJldHVybiBEb3R0aWUuZ2V0KG9iamVjdCwgcGF0aCkgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvLyBTZXQgbmVzdGVkIHZhbHVlXG4gIERvdHRpZS5zZXQgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIHBpZWNlcyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpLCBjdXJyZW50ID0gb2JqZWN0LCBwaWVjZSwgbGVuZ3RoID0gcGllY2VzLmxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgaXMgbm90IGFuIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBwaWVjZSA9IHBpZWNlc1tpbmRleF07XG5cbiAgICAgIC8vIENyZWF0ZSBuYW1lc3BhY2UgKG9iamVjdCkgd2hlcmUgbm9uZSBleGlzdHMuXG4gICAgICAvLyBJZiBgZm9yY2UgPT09IHRydWVgLCBicnV0ZWZvcmNlIHRoZSBwYXRoIHdpdGhvdXQgdGhyb3dpbmcgZXJyb3JzLlxuICAgICAgaWYgKCFoYXNPd25Qcm9wLmNhbGwoY3VycmVudCwgcGllY2UpIHx8IGN1cnJlbnRbcGllY2VdID09PSB1bmRlZmluZWQgfHwgKHR5cGVvZiBjdXJyZW50W3BpZWNlXSAhPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlID09PSB0cnVlKSkge1xuICAgICAgICBjdXJyZW50W3BpZWNlXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT0gKGxlbmd0aCAtIDEpKSB7XG4gICAgICAgIC8vIFNldCBmaW5hbCB2YWx1ZVxuICAgICAgICBjdXJyZW50W3BpZWNlXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IG92ZXJ3cml0ZSBleGlzdGluZyBwYXRoIHBpZWNlcyBieSBkZWZhdWx0XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudFtwaWVjZV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQga2V5IFwiJyArIHBpZWNlICsgJ1wiIGlzIG5vdCBzdWl0YWJsZSBmb3IgYSBuZXN0ZWQgdmFsdWUuIChJdCBpcyBpbiB1c2UgYXMgbm9uLW9iamVjdC4gU2V0IGBmb3JjZWAgdG8gYHRydWVgIHRvIG92ZXJyaWRlLiknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIG5leHQgaW4gcGF0aFxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwaWVjZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlcmUgYW55IGNhc2Ugd2hlbiB0aGlzIGlzIHJlbGV2YW50PyBJdCdzIGFsc28gdGhlIGxhc3QgbGluZSBpbiB0aGUgYWJvdmUgZm9yLWxvb3BcbiAgICBjdXJyZW50W3BpZWNlXSA9IHZhbHVlO1xuICB9O1xuXG4gIC8vIFNldCBkZWZhdWx0IG5lc3RlZCB2YWx1ZVxuICBEb3R0aWVbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICBpZiAoRG90dGllLmdldChvYmplY3QsIHBhdGgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIERvdHRpZS5zZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRyYW5zZm9ybSB1bm5lc3RlZCBvYmplY3Qgd2l0aCAuLXNlcGVyYXRlZCBrZXlzIGludG8gYSBuZXN0ZWQgb2JqZWN0LlxuICBEb3R0aWUudHJhbnNmb3JtID0gZnVuY3Rpb24gRG90dGllJHRyYW5zZm9ybWZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBvYmplY3QubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIERvdHRpZS50cmFuc2Zvcm0obywgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcuJztcblxuICAgIHZhciBwaWVjZXNcbiAgICAgICwgcGllY2VzTGVuZ3RoXG4gICAgICAsIHBpZWNlXG4gICAgICAsIGN1cnJlbnRcbiAgICAgICwgdHJhbnNmb3JtZWQgPSB7fVxuICAgICAgLCBrZXlcbiAgICAgICwga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleS5pbmRleE9mKG9wdGlvbnMuZGVsaW1pdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgcGllY2VzID0ga2V5LnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICAgICAgcGllY2VzTGVuZ3RoID0gcGllY2VzLmxlbmd0aDtcbiAgICAgICAgY3VycmVudCA9IHRyYW5zZm9ybWVkO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwaWVjZXNMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBwaWVjZSA9IHBpZWNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKGluZGV4ICE9IChwaWVjZXNMZW5ndGggLSAxKSAmJiAhY3VycmVudC5oYXNPd25Qcm9wZXJ0eShwaWVjZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbcGllY2VdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluZGV4ID09IChwaWVjZXNMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgY3VycmVudFtwaWVjZV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwaWVjZV07XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtZWRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfTtcblxuICBEb3R0aWUuZmxhdHRlbiA9IGZ1bmN0aW9uKG9iamVjdCwgc2VwZXJhdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBlcmF0b3IgPT09IFwidW5kZWZpbmVkXCIpIHNlcGVyYXRvciA9ICcuJztcbiAgICB2YXIgZmxhdHRlbmVkID0ge31cbiAgICAgICwgY3VycmVudFxuICAgICAgLCBuZXN0ZWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjdXJyZW50ID0gb2JqZWN0W2tleV07XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY3VycmVudCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICBuZXN0ZWQgPSBEb3R0aWUuZmxhdHRlbihjdXJyZW50LCBzZXBlcmF0b3IpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBuZXN0ZWQpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFtrZXkrc2VwZXJhdG9yK19rZXldID0gbmVzdGVkW19rZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuZWRba2V5XSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9O1xuXG4gIERvdHRpZS5wYXRocyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJlZml4ZXMpIHtcbiAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGtleTtcblxuICAgIHByZWZpeGVzID0gcHJlZml4ZXMgfHwgW107XG5cbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgcGF0aHMgPSBwYXRocy5jb25jYXQoRG90dGllLnBhdGhzKHZhbHVlLCBwcmVmaXhlcy5jb25jYXQoW2tleV0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aHMucHVzaChwcmVmaXhlcy5jb25jYXQoa2V5KS5qb2luKCcuJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aHMgd2FzIGNhbGxlZCB3aXRoIG5vbi1vYmplY3QgYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdHRpZTtcbiAgfSBlbHNlIHtcbiAgICByb290WydEb3R0aWUnXSA9IERvdHRpZTtcbiAgICByb290WydEb3QnXSA9IERvdHRpZTsgLy9CQ1xuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiBEb3R0aWU7IH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsIi8qIVxuICogaW5mbGVjdGlvblxuICogQ29weXJpZ2h0KGMpIDIwMTEgQmVuIExpbiA8YmVuQGRyZWFtZXJzbGFiLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICpcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEEgcG9ydCBvZiBpbmZsZWN0aW9uLWpzIHRvIG5vZGUuanMgbW9kdWxlLlxuICovXG5cbiggZnVuY3Rpb24gKCByb290LCBmYWN0b3J5ICl7XG4gIGlmKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKXtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkgKTtcbiAgfWVsc2UgaWYoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApe1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9ZWxzZXtcbiAgICByb290LmluZmxlY3Rpb24gPSBmYWN0b3J5KCk7XG4gIH1cbn0oIHRoaXMsIGZ1bmN0aW9uICgpe1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBhIGxpc3Qgb2Ygbm91bnMgdGhhdCB1c2UgdGhlIHNhbWUgZm9ybSBmb3IgYm90aCBzaW5ndWxhciBhbmQgcGx1cmFsLlxuICAgKiAgICAgICAgICAgICAgVGhpcyBsaXN0IHNob3VsZCByZW1haW4gZW50aXJlbHkgaW4gbG93ZXIgY2FzZSB0byBjb3JyZWN0bHkgbWF0Y2ggU3RyaW5ncy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciB1bmNvdW50YWJsZV93b3JkcyA9IFtcbiAgICAvLyAnYWNjZXNzJyxcbiAgICAnYWNjb21tb2RhdGlvbicsXG4gICAgJ2FkdWx0aG9vZCcsXG4gICAgJ2FkdmVydGlzaW5nJyxcbiAgICAnYWR2aWNlJyxcbiAgICAnYWdncmVzc2lvbicsXG4gICAgJ2FpZCcsXG4gICAgJ2FpcicsXG4gICAgJ2FpcmNyYWZ0JyxcbiAgICAnYWxjb2hvbCcsXG4gICAgJ2FuZ2VyJyxcbiAgICAnYXBwbGF1c2UnLFxuICAgICdhcml0aG1ldGljJyxcbiAgICAvLyAnYXJ0JyxcbiAgICAnYXNzaXN0YW5jZScsXG4gICAgJ2F0aGxldGljcycsXG4gICAgLy8gJ2F0dGVudGlvbicsXG5cbiAgICAnYmFjb24nLFxuICAgICdiYWdnYWdlJyxcbiAgICAvLyAnYmFsbGV0JyxcbiAgICAvLyAnYmVhdXR5JyxcbiAgICAnYmVlZicsXG4gICAgLy8gJ2JlZXInLFxuICAgIC8vICdiZWhhdmlvcicsXG4gICAgJ2Jpb2xvZ3knLFxuICAgIC8vICdiaWxsaWFyZHMnLFxuICAgICdibG9vZCcsXG4gICAgJ2JvdGFueScsXG4gICAgLy8gJ2Jvd2VscycsXG4gICAgJ2JyZWFkJyxcbiAgICAvLyAnYnVzaW5lc3MnLFxuICAgICdidXR0ZXInLFxuXG4gICAgJ2NhcmJvbicsXG4gICAgJ2NhcmRib2FyZCcsXG4gICAgJ2Nhc2gnLFxuICAgICdjaGFsaycsXG4gICAgJ2NoYW9zJyxcbiAgICAnY2hlc3MnLFxuICAgICdjcm9zc3JvYWRzJyxcbiAgICAnY291bnRyeXNpZGUnLFxuXG4gICAgLy8gJ2RhbWFnZScsXG4gICAgJ2RhbmNpbmcnLFxuICAgIC8vICdkYW5nZXInLFxuICAgICdkZWVyJyxcbiAgICAvLyAnZGVsaWdodCcsXG4gICAgLy8gJ2Rlc3NlcnQnLFxuICAgICdkaWduaXR5JyxcbiAgICAnZGlydCcsXG4gICAgLy8gJ2Rpc3RyaWJ1dGlvbicsXG4gICAgJ2R1c3QnLFxuXG4gICAgJ2Vjb25vbWljcycsXG4gICAgJ2VkdWNhdGlvbicsXG4gICAgJ2VsZWN0cmljaXR5JyxcbiAgICAvLyAnZW1wbG95bWVudCcsXG4gICAgLy8gJ2VuZXJneScsXG4gICAgJ2VuZ2luZWVyaW5nJyxcbiAgICAnZW5qb3ltZW50JyxcbiAgICAvLyAnZW50ZXJ0YWlubWVudCcsXG4gICAgJ2VudnknLFxuICAgICdlcXVpcG1lbnQnLFxuICAgICdldGhpY3MnLFxuICAgICdldmlkZW5jZScsXG4gICAgJ2V2b2x1dGlvbicsXG5cbiAgICAvLyAnZmFpbHVyZScsXG4gICAgLy8gJ2ZhaXRoJyxcbiAgICAnZmFtZScsXG4gICAgJ2ZpY3Rpb24nLFxuICAgIC8vICdmaXNoJyxcbiAgICAnZmxvdXInLFxuICAgICdmbHUnLFxuICAgICdmb29kJyxcbiAgICAvLyAnZnJlZWRvbScsXG4gICAgLy8gJ2ZydWl0JyxcbiAgICAnZnVlbCcsXG4gICAgJ2Z1bicsXG4gICAgLy8gJ2Z1bmVyYWwnLFxuICAgICdmdXJuaXR1cmUnLFxuXG4gICAgJ2dhbGxvd3MnLFxuICAgICdnYXJiYWdlJyxcbiAgICAnZ2FybGljJyxcbiAgICAvLyAnZ2FzJyxcbiAgICAnZ2VuZXRpY3MnLFxuICAgIC8vICdnbGFzcycsXG4gICAgJ2dvbGQnLFxuICAgICdnb2xmJyxcbiAgICAnZ29zc2lwJyxcbiAgICAnZ3JhbW1hcicsXG4gICAgLy8gJ2dyYXNzJyxcbiAgICAnZ3JhdGl0dWRlJyxcbiAgICAnZ3JpZWYnLFxuICAgIC8vICdncm91bmQnLFxuICAgICdndWlsdCcsXG4gICAgJ2d5bW5hc3RpY3MnLFxuXG4gICAgLy8gJ2hhaXInLFxuICAgICdoYXBwaW5lc3MnLFxuICAgICdoYXJkd2FyZScsXG4gICAgJ2hhcm0nLFxuICAgICdoYXRlJyxcbiAgICAnaGF0cmVkJyxcbiAgICAnaGVhbHRoJyxcbiAgICAnaGVhdCcsXG4gICAgLy8gJ2hlaWdodCcsXG4gICAgJ2hlbHAnLFxuICAgICdob21ld29yaycsXG4gICAgJ2hvbmVzdHknLFxuICAgICdob25leScsXG4gICAgJ2hvc3BpdGFsaXR5JyxcbiAgICAnaG91c2V3b3JrJyxcbiAgICAnaHVtb3VyJyxcbiAgICAnaHVuZ2VyJyxcbiAgICAnaHlkcm9nZW4nLFxuXG4gICAgJ2ljZScsXG4gICAgJ2ltcG9ydGFuY2UnLFxuICAgICdpbmZsYXRpb24nLFxuICAgICdpbmZvcm1hdGlvbicsXG4gICAgLy8gJ2luanVzdGljZScsXG4gICAgJ2lubm9jZW5jZScsXG4gICAgLy8gJ2ludGVsbGlnZW5jZScsXG4gICAgJ2lyb24nLFxuICAgICdpcm9ueScsXG5cbiAgICAnamFtJyxcbiAgICAvLyAnamVhbG91c3knLFxuICAgIC8vICdqZWxseScsXG4gICAgJ2pld2VscnknLFxuICAgIC8vICdqb3knLFxuICAgICdqdWRvJyxcbiAgICAvLyAnanVpY2UnLFxuICAgIC8vICdqdXN0aWNlJyxcblxuICAgICdrYXJhdGUnLFxuICAgIC8vICdraW5kbmVzcycsXG4gICAgJ2tub3dsZWRnZScsXG5cbiAgICAvLyAnbGFib3VyJyxcbiAgICAnbGFjaycsXG4gICAgLy8gJ2xhbmQnLFxuICAgICdsYXVnaHRlcicsXG4gICAgJ2xhdmEnLFxuICAgICdsZWF0aGVyJyxcbiAgICAnbGVpc3VyZScsXG4gICAgJ2xpZ2h0bmluZycsXG4gICAgJ2xpbmd1aW5lJyxcbiAgICAnbGluZ3VpbmknLFxuICAgICdsaW5ndWlzdGljcycsXG4gICAgJ2xpdGVyYXR1cmUnLFxuICAgICdsaXR0ZXInLFxuICAgICdsaXZlc3RvY2snLFxuICAgICdsb2dpYycsXG4gICAgJ2xvbmVsaW5lc3MnLFxuICAgIC8vICdsb3ZlJyxcbiAgICAnbHVjaycsXG4gICAgJ2x1Z2dhZ2UnLFxuXG4gICAgJ21hY2Fyb25pJyxcbiAgICAnbWFjaGluZXJ5JyxcbiAgICAnbWFnaWMnLFxuICAgIC8vICdtYWlsJyxcbiAgICAnbWFuYWdlbWVudCcsXG4gICAgJ21hbmtpbmQnLFxuICAgICdtYXJibGUnLFxuICAgICdtYXRoZW1hdGljcycsXG4gICAgJ21heW9ubmFpc2UnLFxuICAgICdtZWFzbGVzJyxcbiAgICAvLyAnbWVhdCcsXG4gICAgLy8gJ21ldGFsJyxcbiAgICAnbWV0aGFuZScsXG4gICAgJ21pbGsnLFxuICAgICdtaW51cycsXG4gICAgJ21vbmV5JyxcbiAgICAvLyAnbW9vc2UnLFxuICAgICdtdWQnLFxuICAgICdtdXNpYycsXG4gICAgJ211bXBzJyxcblxuICAgICduYXR1cmUnLFxuICAgICduZXdzJyxcbiAgICAnbml0cm9nZW4nLFxuICAgICdub25zZW5zZScsXG4gICAgJ251cnR1cmUnLFxuICAgICdudXRyaXRpb24nLFxuXG4gICAgJ29iZWRpZW5jZScsXG4gICAgJ29iZXNpdHknLFxuICAgIC8vICdvaWwnLFxuICAgICdveHlnZW4nLFxuXG4gICAgLy8gJ3BhcGVyJyxcbiAgICAvLyAncGFzc2lvbicsXG4gICAgJ3Bhc3RhJyxcbiAgICAncGF0aWVuY2UnLFxuICAgIC8vICdwZXJtaXNzaW9uJyxcbiAgICAncGh5c2ljcycsXG4gICAgJ3BvZXRyeScsXG4gICAgJ3BvbGx1dGlvbicsXG4gICAgJ3BvdmVydHknLFxuICAgIC8vICdwb3dlcicsXG4gICAgJ3ByaWRlJyxcbiAgICAvLyAncHJvZHVjdGlvbicsXG4gICAgLy8gJ3Byb2dyZXNzJyxcbiAgICAvLyAncHJvbnVuY2lhdGlvbicsXG4gICAgJ3BzeWNob2xvZ3knLFxuICAgICdwdWJsaWNpdHknLFxuICAgICdwdW5jdHVhdGlvbicsXG5cbiAgICAvLyAncXVhbGl0eScsXG4gICAgLy8gJ3F1YW50aXR5JyxcbiAgICAncXVhcnR6JyxcblxuICAgICdyYWNpc20nLFxuICAgIC8vICdyYWluJyxcbiAgICAvLyAncmVjcmVhdGlvbicsXG4gICAgJ3JlbGF4YXRpb24nLFxuICAgICdyZWxpYWJpbGl0eScsXG4gICAgJ3Jlc2VhcmNoJyxcbiAgICAncmVzcGVjdCcsXG4gICAgJ3JldmVuZ2UnLFxuICAgICdyaWNlJyxcbiAgICAncnViYmlzaCcsXG4gICAgJ3J1bScsXG5cbiAgICAnc2FmZXR5JyxcbiAgICAvLyAnc2FsYWQnLFxuICAgIC8vICdzYWx0JyxcbiAgICAvLyAnc2FuZCcsXG4gICAgLy8gJ3NhdGlyZScsXG4gICAgJ3NjZW5lcnknLFxuICAgICdzZWFmb29kJyxcbiAgICAnc2Vhc2lkZScsXG4gICAgJ3NlcmllcycsXG4gICAgJ3NoYW1lJyxcbiAgICAnc2hlZXAnLFxuICAgICdzaG9wcGluZycsXG4gICAgLy8gJ3NpbGVuY2UnLFxuICAgICdzbGVlcCcsXG4gICAgLy8gJ3NsYW5nJ1xuICAgICdzbW9rZScsXG4gICAgJ3Ntb2tpbmcnLFxuICAgICdzbm93JyxcbiAgICAnc29hcCcsXG4gICAgJ3NvZnR3YXJlJyxcbiAgICAnc29pbCcsXG4gICAgLy8gJ3NvcnJvdycsXG4gICAgLy8gJ3NvdXAnLFxuICAgICdzcGFnaGV0dGknLFxuICAgIC8vICdzcGVlZCcsXG4gICAgJ3NwZWNpZXMnLFxuICAgIC8vICdzcGVsbGluZycsXG4gICAgLy8gJ3Nwb3J0JyxcbiAgICAnc3RlYW0nLFxuICAgIC8vICdzdHJlbmd0aCcsXG4gICAgJ3N0dWZmJyxcbiAgICAnc3R1cGlkaXR5JyxcbiAgICAvLyAnc3VjY2VzcycsXG4gICAgLy8gJ3N1Z2FyJyxcbiAgICAnc3Vuc2hpbmUnLFxuICAgICdzeW1tZXRyeScsXG5cbiAgICAvLyAndGVhJyxcbiAgICAndGVubmlzJyxcbiAgICAndGhpcnN0JyxcbiAgICAndGh1bmRlcicsXG4gICAgJ3RpbWJlcicsXG4gICAgLy8gJ3RpbWUnLFxuICAgIC8vICd0b2FzdCcsXG4gICAgLy8gJ3RvbGVyYW5jZScsXG4gICAgLy8gJ3RyYWRlJyxcbiAgICAndHJhZmZpYycsXG4gICAgJ3RyYW5zcG9ydGF0aW9uJyxcbiAgICAvLyAndHJhdmVsJyxcbiAgICAndHJ1c3QnLFxuXG4gICAgLy8gJ3VuZGVyc3RhbmRpbmcnLFxuICAgICd1bmRlcndlYXInLFxuICAgICd1bmVtcGxveW1lbnQnLFxuICAgICd1bml0eScsXG4gICAgLy8gJ3VzYWdlJyxcblxuICAgICd2YWxpZGl0eScsXG4gICAgJ3ZlYWwnLFxuICAgICd2ZWdldGF0aW9uJyxcbiAgICAndmVnZXRhcmlhbmlzbScsXG4gICAgJ3ZlbmdlYW5jZScsXG4gICAgJ3Zpb2xlbmNlJyxcbiAgICAvLyAndmlzaW9uJyxcbiAgICAndml0YWxpdHknLFxuXG4gICAgJ3dhcm10aCcsXG4gICAgLy8gJ3dhdGVyJyxcbiAgICAnd2VhbHRoJyxcbiAgICAnd2VhdGhlcicsXG4gICAgLy8gJ3dlaWdodCcsXG4gICAgJ3dlbGZhcmUnLFxuICAgICd3aGVhdCcsXG4gICAgLy8gJ3doaXNrZXknLFxuICAgIC8vICd3aWR0aCcsXG4gICAgJ3dpbGRsaWZlJyxcbiAgICAvLyAnd2luZScsXG4gICAgJ3dpc2RvbScsXG4gICAgLy8gJ3dvb2QnLFxuICAgIC8vICd3b29sJyxcbiAgICAvLyAnd29yaycsXG5cbiAgICAvLyAneWVhc3QnLFxuICAgICd5b2dhJyxcblxuICAgICd6aW5jJyxcbiAgICAnem9vbG9neSdcbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoZXNlIHJ1bGVzIHRyYW5zbGF0ZSBmcm9tIHRoZSBzaW5ndWxhciBmb3JtIG9mIGEgbm91biB0byBpdHMgcGx1cmFsIGZvcm0uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciByZWdleCA9IHtcbiAgICBwbHVyYWwgOiB7XG4gICAgICBtZW4gICAgICAgOiBuZXcgUmVnRXhwKCAnXihtfHdvbSllbiQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHBlb3BsZSAgICA6IG5ldyBSZWdFeHAoICcocGUpb3BsZSQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY2hpbGRyZW4gIDogbmV3IFJlZ0V4cCggJyhjaGlsZClyZW4kJyAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB0aWEgICAgICAgOiBuZXcgUmVnRXhwKCAnKFt0aV0pYSQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGFuYWx5c2VzICA6IG5ldyBSZWdFeHAoICcoKGEpbmFseXwoYilhfChkKWlhZ25vfChwKWFyZW50aGV8KHApcm9nbm98KHMpeW5vcHwodCloZSlzZXMkJywnZ2knICksXG4gICAgICBoaXZlcyAgICAgOiBuZXcgUmVnRXhwKCAnKGhpfHRpKXZlcyQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGN1cnZlcyAgICA6IG5ldyBSZWdFeHAoICcoY3VydmUpcyQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbHJ2ZXMgICAgIDogbmV3IFJlZ0V4cCggJyhbbHJdKXZlcyQnICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhdmVzICAgICAgOiBuZXcgUmVnRXhwKCAnKFthXSl2ZXMkJyAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGZvdmVzICAgICA6IG5ldyBSZWdFeHAoICcoW15mb10pdmVzJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbW92aWVzICAgIDogbmV3IFJlZ0V4cCggJyhtKW92aWVzJCcgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhZWlvdXlpZXMgOiBuZXcgUmVnRXhwKCAnKFteYWVpb3V5XXxxdSlpZXMkJyAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHNlcmllcyAgICA6IG5ldyBSZWdFeHAoICcocyllcmllcyQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgeGVzICAgICAgIDogbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKWVzJCcgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBtaWNlICAgICAgOiBuZXcgUmVnRXhwKCAnKFttfGxdKWljZSQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGJ1c2VzICAgICA6IG5ldyBSZWdFeHAoICcoYnVzKWVzJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgb2VzICAgICAgIDogbmV3IFJlZ0V4cCggJyhvKWVzJCcgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzaG9lcyAgICAgOiBuZXcgUmVnRXhwKCAnKHNob2UpcyQnICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNyaXNlcyAgICA6IG5ldyBSZWdFeHAoICcoY3Jpc3xheHx0ZXN0KWVzJCcgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgb2N0b3BpICAgIDogbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpaSQnICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBhbGlhc2VzICAgOiBuZXcgUmVnRXhwKCAnKGFsaWFzfGNhbnZhc3xzdGF0dXN8Y2FtcHVzKWVzJCcsICdnaScgKSxcbiAgICAgIHN1bW1vbnNlcyA6IG5ldyBSZWdFeHAoICdeKHN1bW1vbnMpZXMkJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgb3hlbiAgICAgIDogbmV3IFJlZ0V4cCggJ14ob3gpZW4nICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBtYXRyaWNlcyAgOiBuZXcgUmVnRXhwKCAnKG1hdHIpaWNlcyQnICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHZlcnRpY2VzICA6IG5ldyBSZWdFeHAoICcodmVydHxpbmQpaWNlcyQnICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZmVldCAgICAgIDogbmV3IFJlZ0V4cCggJ15mZWV0JCcgICAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB0ZWV0aCAgICAgOiBuZXcgUmVnRXhwKCAnXnRlZXRoJCcgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGdlZXNlICAgICA6IG5ldyBSZWdFeHAoICdeZ2Vlc2UkJyAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcXVpenplcyAgIDogbmV3IFJlZ0V4cCggJyhxdWl6KXplcyQnICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICB3aGVyZWFzZXMgOiBuZXcgUmVnRXhwKCAnXih3aGVyZWFzKWVzJCcgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIGNyaXRlcmlhICA6IG5ldyBSZWdFeHAoICdeKGNyaXRlcmkpYSQnICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZ2VuZXJhICAgIDogbmV3IFJlZ0V4cCggJ15nZW5lcmEkJyAgICAgICAgICAgICAgICAgICAgICAgLCAnZ2knICksXG4gICAgICBzcyAgICAgICAgOiBuZXcgUmVnRXhwKCAnc3MkJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdnaScgKSxcbiAgICAgIHMgICAgICAgICA6IG5ldyBSZWdFeHAoICdzJCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApXG4gICAgfSxcblxuICAgIHNpbmd1bGFyIDoge1xuICAgICAgbWFuICAgICAgIDogbmV3IFJlZ0V4cCggJ14obXx3b20pYW4kJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcGVyc29uICAgIDogbmV3IFJlZ0V4cCggJyhwZSlyc29uJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY2hpbGQgICAgIDogbmV3IFJlZ0V4cCggJyhjaGlsZCkkJyAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgb3ggICAgICAgIDogbmV3IFJlZ0V4cCggJ14ob3gpJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYXhpcyAgICAgIDogbmV3IFJlZ0V4cCggJyhheHx0ZXN0KWlzJCcgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgb2N0b3B1cyAgIDogbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpdXMkJyAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYWxpYXMgICAgIDogbmV3IFJlZ0V4cCggJyhhbGlhc3xzdGF0dXN8Y2FudmFzfGNhbXB1cykkJywgJ2dpJyApLFxuICAgICAgc3VtbW9ucyAgIDogbmV3IFJlZ0V4cCggJ14oc3VtbW9ucykkJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYnVzICAgICAgIDogbmV3IFJlZ0V4cCggJyhidSlzJCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYnVmZmFsbyAgIDogbmV3IFJlZ0V4cCggJyhidWZmYWx8dG9tYXR8cG90YXQpbyQnICAgICAgICwgJ2dpJyApLFxuICAgICAgdGl1bSAgICAgIDogbmV3IFJlZ0V4cCggJyhbdGldKXVtJCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgc2lzICAgICAgIDogbmV3IFJlZ0V4cCggJ3NpcyQnICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZmZlICAgICAgIDogbmV3IFJlZ0V4cCggJyg/OihbXmZdKWZlfChbbHJdKWYpJCcgICAgICAgICwgJ2dpJyApLFxuICAgICAgaGl2ZSAgICAgIDogbmV3IFJlZ0V4cCggJyhoaXx0aSl2ZSQnICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgYWVpb3V5eSAgIDogbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpeSQnICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgeCAgICAgICAgIDogbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKSQnICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbWF0cml4ICAgIDogbmV3IFJlZ0V4cCggJyhtYXRyKWl4JCcgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgdmVydGV4ICAgIDogbmV3IFJlZ0V4cCggJyh2ZXJ0fGluZClleCQnICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgbW91c2UgICAgIDogbmV3IFJlZ0V4cCggJyhbbXxsXSlvdXNlJCcgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZm9vdCAgICAgIDogbmV3IFJlZ0V4cCggJ15mb290JCcgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgdG9vdGggICAgIDogbmV3IFJlZ0V4cCggJ150b290aCQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZ29vc2UgICAgIDogbmV3IFJlZ0V4cCggJ15nb29zZSQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcXVpeiAgICAgIDogbmV3IFJlZ0V4cCggJyhxdWl6KSQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgd2hlcmVhcyAgIDogbmV3IFJlZ0V4cCggJ14od2hlcmVhcykkJyAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY3JpdGVyaW9uIDogbmV3IFJlZ0V4cCggJ14oY3JpdGVyaSlvbiQnICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgZ2VudXMgICAgIDogbmV3IFJlZ0V4cCggJ15nZW51cyQnICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgcyAgICAgICAgIDogbmV3IFJlZ0V4cCggJ3MkJyAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApLFxuICAgICAgY29tbW9uICAgIDogbmV3IFJlZ0V4cCggJyQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2dpJyApXG4gICAgfVxuICB9O1xuXG4gIHZhciBwbHVyYWxfcnVsZXMgPSBbXG5cbiAgICAvLyBkbyBub3QgcmVwbGFjZSBpZiBpdHMgYWxyZWFkeSBhIHBsdXJhbCB3b3JkXG4gICAgWyByZWdleC5wbHVyYWwubWVuICAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwucGVvcGxlICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY2hpbGRyZW4gIF0sXG4gICAgWyByZWdleC5wbHVyYWwudGlhICAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYW5hbHlzZXMgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuaGl2ZXMgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY3VydmVzICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwubHJ2ZXMgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZm92ZXMgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYWVpb3V5aWVzIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc2VyaWVzICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwubW92aWVzICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwueGVzICAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwubWljZSAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYnVzZXMgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwub2VzICAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc2hvZXMgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY3Jpc2VzICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwub2N0b3BpICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYWxpYXNlcyAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuc3VtbW9uc2VzIF0sXG4gICAgWyByZWdleC5wbHVyYWwub3hlbiAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwubWF0cmljZXMgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZmVldCAgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwudGVldGggICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZ2Vlc2UgICAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwucXVpenplcyAgIF0sXG4gICAgWyByZWdleC5wbHVyYWwud2hlcmVhc2VzIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY3JpdGVyaWEgIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZ2VuZXJhICAgIF0sXG5cbiAgICAvLyBvcmlnaW5hbCBydWxlXG4gICAgWyByZWdleC5zaW5ndWxhci5tYW4gICAgICAsICckMWVuJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIucGVyc29uICAgLCAnJDFvcGxlJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuY2hpbGQgICAgLCAnJDFyZW4nIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5veCAgICAgICAsICckMWVuJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYXhpcyAgICAgLCAnJDFlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm9jdG9wdXMgICwgJyQxaScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmFsaWFzICAgICwgJyQxZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5zdW1tb25zICAsICckMWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuYnVzICAgICAgLCAnJDFzZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5idWZmYWxvICAsICckMW9lcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnRpdW0gICAgICwgJyQxYScgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnNpcyAgICAgICwgJ3NlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmZmZSAgICAgICwgJyQxJDJ2ZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5oaXZlICAgICAsICckMXZlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmFlaW91eXkgICwgJyQxaWVzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIubWF0cml4ICAgLCAnJDFpY2VzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIudmVydGV4ICAgLCAnJDFpY2VzJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIueCAgICAgICAgLCAnJDFlcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLm1vdXNlICAgICwgJyQxaWNlJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZm9vdCAgICAgLCAnZmVldCcgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnRvb3RoICAgICwgJ3RlZXRoJyBdLFxuICAgIFsgcmVnZXguc2luZ3VsYXIuZ29vc2UgICAgLCAnZ2Vlc2UnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5xdWl6ICAgICAsICckMXplcycgXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLndoZXJlYXMgICwgJyQxZXMnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5jcml0ZXJpb24sICckMWEnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5nZW51cyAgICAsICdnZW5lcmEnIF0sXG5cbiAgICBbIHJlZ2V4LnNpbmd1bGFyLnMgICAgICwgJ3MnIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5jb21tb24sICdzJyBdXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBydWxlcyB0cmFuc2xhdGUgZnJvbSB0aGUgcGx1cmFsIGZvcm0gb2YgYSBub3VuIHRvIGl0cyBzaW5ndWxhciBmb3JtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHNpbmd1bGFyX3J1bGVzID0gW1xuXG4gICAgLy8gZG8gbm90IHJlcGxhY2UgaWYgaXRzIGFscmVhZHkgYSBzaW5ndWxhciB3b3JkXG4gICAgWyByZWdleC5zaW5ndWxhci5tYW4gICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5wZXJzb24gIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5jaGlsZCAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5veCAgICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5heGlzICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5vY3RvcHVzIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5hbGlhcyAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5zdW1tb25zIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5idXMgICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5idWZmYWxvIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci50aXVtICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5zaXMgICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5mZmUgICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5oaXZlICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5hZWlvdXl5IF0sXG4gICAgWyByZWdleC5zaW5ndWxhci54ICAgICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5tYXRyaXggIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5tb3VzZSAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5mb290ICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci50b290aCAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5nb29zZSAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5xdWl6ICAgIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci53aGVyZWFzIF0sXG4gICAgWyByZWdleC5zaW5ndWxhci5jcml0ZXJpb24gXSxcbiAgICBbIHJlZ2V4LnNpbmd1bGFyLmdlbnVzIF0sXG5cbiAgICAvLyBvcmlnaW5hbCBydWxlXG4gICAgWyByZWdleC5wbHVyYWwubWVuICAgICAgLCAnJDFhbicgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5wZW9wbGUgICAsICckMXJzb24nIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY2hpbGRyZW4gLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZ2VuZXJhICAgLCAnZ2VudXMnXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5jcml0ZXJpYSAsICckMW9uJ10sXG4gICAgWyByZWdleC5wbHVyYWwudGlhICAgICAgLCAnJDF1bScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hbmFseXNlcyAsICckMSQyc2lzJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmhpdmVzICAgICwgJyQxdmUnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuY3VydmVzICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwubHJ2ZXMgICAgLCAnJDFmJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmF2ZXMgICAgICwgJyQxdmUnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZm92ZXMgICAgLCAnJDFmZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5tb3ZpZXMgICAsICckMW92aWUnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuYWVpb3V5aWVzLCAnJDF5JyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnNlcmllcyAgICwgJyQxZXJpZXMnIF0sXG4gICAgWyByZWdleC5wbHVyYWwueGVzICAgICAgLCAnJDEnIF0sXG4gICAgWyByZWdleC5wbHVyYWwubWljZSAgICAgLCAnJDFvdXNlJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmJ1c2VzICAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLm9lcyAgICAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnNob2VzICAgICwgJyQxJyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLmNyaXNlcyAgICwgJyQxaXMnIF0sXG4gICAgWyByZWdleC5wbHVyYWwub2N0b3BpICAgLCAnJDF1cycgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5hbGlhc2VzICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5zdW1tb25zZXMsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5veGVuICAgICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5tYXRyaWNlcyAsICckMWl4JyBdLFxuICAgIFsgcmVnZXgucGx1cmFsLnZlcnRpY2VzICwgJyQxZXgnIF0sXG4gICAgWyByZWdleC5wbHVyYWwuZmVldCAgICAgLCAnZm9vdCcgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC50ZWV0aCAgICAsICd0b290aCcgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5nZWVzZSAgICAsICdnb29zZScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC5xdWl6emVzICAsICckMScgXSxcbiAgICBbIHJlZ2V4LnBsdXJhbC53aGVyZWFzZXMsICckMScgXSxcblxuICAgIFsgcmVnZXgucGx1cmFsLnNzLCAnc3MnIF0sXG4gICAgWyByZWdleC5wbHVyYWwucyAsICcnIF1cbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkIG5vdCBiZSBjYXBpdGFsaXplZCBmb3IgdGl0bGUgY2FzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBub25fdGl0bGVjYXNlZF93b3JkcyA9IFtcbiAgICAnYW5kJywgJ29yJywgJ25vcicsICdhJywgJ2FuJywgJ3RoZScsICdzbycsICdidXQnLCAndG8nLCAnb2YnLCAnYXQnLCdieScsXG4gICAgJ2Zyb20nLCAnaW50bycsICdvbicsICdvbnRvJywgJ29mZicsICdvdXQnLCAnaW4nLCAnb3ZlcicsICd3aXRoJywgJ2ZvcidcbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoZXNlIGFyZSByZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBTdHJpbmcgZm9ybWF0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBpZF9zdWZmaXggICAgICAgICA9IG5ldyBSZWdFeHAoICcoX2lkc3xfaWQpJCcsICdnJyApO1xuICB2YXIgdW5kZXJiYXIgICAgICAgICAgPSBuZXcgUmVnRXhwKCAnXycsICdnJyApO1xuICB2YXIgc3BhY2Vfb3JfdW5kZXJiYXIgPSBuZXcgUmVnRXhwKCAnW1xcIF9dJywgJ2cnICk7XG4gIHZhciB1cHBlcmNhc2UgICAgICAgICA9IG5ldyBSZWdFeHAoICcoW0EtWl0pJywgJ2cnICk7XG4gIHZhciB1bmRlcmJhcl9wcmVmaXggICA9IG5ldyBSZWdFeHAoICdeXycgKTtcblxuICB2YXIgaW5mbGVjdG9yID0ge1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBhcHBsaWVzIHJ1bGVzIGJhc2VkIHJlcGxhY2VtZW50IHRvIGEgU3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gbW9kaWZ5IGFuZCByZXR1cm4gYmFzZWQgb24gdGhlIHBhc3NlZCBydWxlcy5cbiAgICogQHBhcmFtIHtBcnJheTogW1JlZ0V4cCwgU3RyaW5nXX0gcnVsZXMgUmVnZXhwIHRvIG1hdGNoIHBhaXJlZCB3aXRoIFN0cmluZyB0byB1c2UgZm9yIHJlcGxhY2VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXk6IFtTdHJpbmddfSBza2lwIFN0cmluZ3MgdG8gc2tpcCBpZiB0aGV5IG1hdGNoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvdmVycmlkZSBTdHJpbmcgdG8gcmV0dXJuIGFzIHRob3VnaCB0aGlzIG1ldGhvZCBzdWNjZWVkZWQgKHVzZWQgdG8gY29uZm9ybSB0byBBUElzKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gcGFzc2VkIFN0cmluZyBtb2RpZmllZCBieSBwYXNzZWQgcnVsZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB0aGlzLl9hcHBseV9ydWxlcyggJ2Nvd3MnLCBzaW5ndWxhcl9ydWxlcyApOyAvLyA9PT0gJ2NvdydcbiAgICovXG4gICAgX2FwcGx5X3J1bGVzIDogZnVuY3Rpb24gKCBzdHIsIHJ1bGVzLCBza2lwLCBvdmVycmlkZSApe1xuICAgICAgaWYoIG92ZXJyaWRlICl7XG4gICAgICAgIHN0ciA9IG92ZXJyaWRlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHZhciBpZ25vcmUgPSAoIGluZmxlY3Rvci5pbmRleE9mKCBza2lwLCBzdHIudG9Mb3dlckNhc2UoKSkgPiAtMSApO1xuXG4gICAgICAgIGlmKCAhaWdub3JlICl7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBqID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgICAgIGlmKCBzdHIubWF0Y2goIHJ1bGVzWyBpIF1bIDAgXSkpe1xuICAgICAgICAgICAgICBpZiggcnVsZXNbIGkgXVsgMSBdICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggcnVsZXNbIGkgXVsgMCBdLCBydWxlc1sgaSBdWyAxIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGxldHMgdXMgZGV0ZWN0IGlmIGFuIEFycmF5IGNvbnRhaW5zIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBzdWJqZWN0IGFycmF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBPYmplY3QgdG8gbG9jYXRlIGluIHRoZSBBcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21faW5kZXggU3RhcnRzIGNoZWNraW5nIGZyb20gdGhpcyBwb3NpdGlvbiBpbiB0aGUgQXJyYXkuKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlX2Z1bmMgRnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIEFycmF5IGl0ZW0gdnMgcGFzc2VkIGl0ZW0uKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm4gaW5kZXggcG9zaXRpb24gaW4gdGhlIEFycmF5IG9mIHRoZSBwYXNzZWQgaXRlbS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmluZGV4T2YoWyAnaGknLCd0aGVyZScgXSwgJ2d1eXMnICk7IC8vID09PSAtMVxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmRleE9mKFsgJ2hpJywndGhlcmUnIF0sICdoaScgKTsgLy8gPT09IDBcbiAgICovXG4gICAgaW5kZXhPZiA6IGZ1bmN0aW9uICggYXJyLCBpdGVtLCBmcm9tX2luZGV4LCBjb21wYXJlX2Z1bmMgKXtcbiAgICAgIGlmKCAhZnJvbV9pbmRleCApe1xuICAgICAgICBmcm9tX2luZGV4ID0gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGkgICAgID0gZnJvbV9pbmRleDtcbiAgICAgIHZhciBqICAgICA9IGFyci5sZW5ndGg7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIGlmKCBhcnJbIGkgXSAgPT09IGl0ZW0gfHwgY29tcGFyZV9mdW5jICYmIGNvbXBhcmVfZnVuYyggYXJyWyBpIF0sIGl0ZW0gKSl7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHBsdXJhbGl6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdXJhbCBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gU2luZ3VsYXIgRW5nbGlzaCBsYW5ndWFnZSBub3VucyBhcmUgcmV0dXJuZWQgaW4gcGx1cmFsIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdwZXJzb24nICk7IC8vID09PSAncGVvcGxlJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdvY3RvcHVzJyApOyAvLyA9PT0gJ29jdG9waSdcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAnSGF0JyApOyAvLyA9PT0gJ0hhdHMnXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ3BlcnNvbicsICdndXlzJyApOyAvLyA9PT0gJ2d1eXMnXG4gICAqL1xuICAgIHBsdXJhbGl6ZSA6IGZ1bmN0aW9uICggc3RyLCBwbHVyYWwgKXtcbiAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHBsdXJhbF9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHBsdXJhbCApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgc2luZ3VsYXJpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaW5ndWxhciBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gUGx1cmFsIEVuZ2xpc2ggbGFuZ3VhZ2Ugbm91bnMgYXJlIHJldHVybmVkIGluIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ3Blb3BsZScgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnb2N0b3BpJyApOyAvLyA9PT0gJ29jdG9wdXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnSGF0cycgKTsgLy8gPT09ICdIYXQnXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnZ3V5cycsICdwZXJzb24nICk7IC8vID09PSAncGVyc29uJ1xuICAgKi9cbiAgICBzaW5ndWxhcml6ZSA6IGZ1bmN0aW9uICggc3RyLCBzaW5ndWxhciApe1xuICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgc2luZ3VsYXJfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBzaW5ndWxhciApO1xuICAgIH0sXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHBsdXJhbGl6ZSBvciBzaW5ndWxhcmxpemUgYSBTdHJpbmcgYXBwcm9wcmlhdGVseSBiYXNlZCBvbiBhbiBpbnRlZ2VyIHZhbHVlXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciB0byBiYXNlIHBsdXJhbGl6YXRpb24gb2ZmIG9mLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2luZ3VsYXIgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVyYWwgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEVuZ2xpc2ggbGFuZ3VhZ2Ugbm91bnMgYXJlIHJldHVybmVkIGluIHRoZSBwbHVyYWwgb3Igc2luZ3VsYXIgZm9ybSBiYXNlZCBvbiB0aGUgY291bnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAncGVvcGxlJyAxICk7IC8vID09PSAncGVyc29uJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAnb2N0b3BpJyAxICk7IC8vID09PSAnb2N0b3B1cydcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ0hhdHMnIDEgKTsgLy8gPT09ICdIYXQnXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdndXlzJywgMSAsICdwZXJzb24nICk7IC8vID09PSAncGVyc29uJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAncGVyc29uJywgMiApOyAvLyA9PT0gJ3Blb3BsZSdcbiAgICogICAgIGluZmxlY3Rpb24uaW5mbGVjdCggJ29jdG9wdXMnLCAyICk7IC8vID09PSAnb2N0b3BpJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5pbmZsZWN0KCAnSGF0JywgMiApOyAvLyA9PT0gJ0hhdHMnXG4gICAqICAgICBpbmZsZWN0aW9uLmluZmxlY3QoICdwZXJzb24nLCAyLCBudWxsLCAnZ3V5cycgKTsgLy8gPT09ICdndXlzJ1xuICAgKi9cbiAgICBpbmZsZWN0IDogZnVuY3Rpb24gKCBzdHIsIGNvdW50LCBzaW5ndWxhciwgcGx1cmFsICl7XG4gICAgICBjb3VudCA9IHBhcnNlSW50KCBjb3VudCwgMTAgKTtcblxuICAgICAgaWYoIGlzTmFOKCBjb3VudCApKSByZXR1cm4gc3RyO1xuXG4gICAgICBpZiggY291bnQgPT09IDAgfHwgY291bnQgPiAxICl7XG4gICAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHBsdXJhbF9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHBsdXJhbCApO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHNpbmd1bGFyX3J1bGVzLCB1bmNvdW50YWJsZV93b3Jkcywgc2luZ3VsYXIgKTtcbiAgICAgIH1cbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNhbWVsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvd19maXJzdF9sZXR0ZXIgRGVmYXVsdCBpcyB0byBjYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHJlc3VsdHMuKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIGxvd2VyY2FzZSBpdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gTG93ZXIgY2FzZSB1bmRlcnNjb3JlZCB3b3JkcyB3aWxsIGJlIHJldHVybmVkIGluIGNhbWVsIGNhc2UuXG4gICAqICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbGx5ICcvJyBpcyB0cmFuc2xhdGVkIHRvICc6OidcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmNhbWVsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2VQcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5jYW1lbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlUHJvcGVydGllcydcbiAgICovXG4gICAgY2FtZWxpemUgOiBmdW5jdGlvbiAoIHN0ciwgbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgdmFyIHN0cl9wYXRoID0gc3RyLnNwbGl0KCAnLycgKTtcbiAgICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICAgPSBzdHJfcGF0aC5sZW5ndGg7XG4gICAgICB2YXIgc3RyX2FyciwgaW5pdF94LCBrLCBsLCBmaXJzdDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgc3RyX2FyciA9IHN0cl9wYXRoWyBpIF0uc3BsaXQoICdfJyApO1xuICAgICAgICBrICAgICAgID0gMDtcbiAgICAgICAgbCAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuXG4gICAgICAgIGZvciggOyBrIDwgbDsgaysrICl7XG4gICAgICAgICAgaWYoIGsgIT09IDAgKXtcbiAgICAgICAgICAgIHN0cl9hcnJbIGsgXSA9IHN0cl9hcnJbIGsgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpcnN0ID0gc3RyX2FyclsgayBdLmNoYXJBdCggMCApO1xuICAgICAgICAgIGZpcnN0ID0gbG93X2ZpcnN0X2xldHRlciAmJiBpID09PSAwICYmIGsgPT09IDBcbiAgICAgICAgICAgID8gZmlyc3QudG9Mb3dlckNhc2UoKSA6IGZpcnN0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgc3RyX2FyclsgayBdID0gZmlyc3QgKyBzdHJfYXJyWyBrIF0uc3Vic3RyaW5nKCAxICk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX2Fyci5qb2luKCAnJyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyX3BhdGguam9pbiggJzo6JyApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdW5kZXJzY29yZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbF91cHBlcl9jYXNlIERlZmF1bHQgaXMgdG8gbG93ZXJjYXNlIGFuZCBhZGQgdW5kZXJzY29yZSBwcmVmaXguKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIHJldHVybiBhcyBlbnRlcmVkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDYW1lbCBjYXNlZCB3b3JkcyBhcmUgcmV0dXJuZWQgYXMgbG93ZXIgY2FzZWQgYW5kIHVuZGVyc2NvcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxseSAnOjonIGlzIHRyYW5zbGF0ZWQgdG8gJy8nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ01lc3NhZ2VQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ21lc3NhZ2VQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ01QJywgdHJ1ZSApOyAvLyA9PT0gJ01QJ1xuICAgKi9cbiAgICB1bmRlcnNjb3JlIDogZnVuY3Rpb24gKCBzdHIsIGFsbF91cHBlcl9jYXNlICl7XG4gICAgICBpZiggYWxsX3VwcGVyX2Nhc2UgJiYgc3RyID09PSBzdHIudG9VcHBlckNhc2UoKSkgcmV0dXJuIHN0cjtcblxuICAgICAgdmFyIHN0cl9wYXRoID0gc3RyLnNwbGl0KCAnOjonICk7XG4gICAgICB2YXIgaSAgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgID0gc3RyX3BhdGgubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX3BhdGhbIGkgXS5yZXBsYWNlKCB1cHBlcmNhc2UsICdfJDEnICk7XG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfcGF0aFsgaSBdLnJlcGxhY2UoIHVuZGVyYmFyX3ByZWZpeCwgJycgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9wYXRoLmpvaW4oICcvJyApLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBodW1hbml6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvd19maXJzdF9sZXR0ZXIgRGVmYXVsdCBpcyB0byBjYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHJlc3VsdHMuKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIGxvd2VyY2FzZSBpdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gTG93ZXIgY2FzZSB1bmRlcnNjb3JlZCB3b3JkcyB3aWxsIGJlIHJldHVybmVkIGluIGh1bWFuaXplZCBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uaHVtYW5pemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5odW1hbml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqL1xuICAgIGh1bWFuaXplIDogZnVuY3Rpb24gKCBzdHIsIGxvd19maXJzdF9sZXR0ZXIgKXtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIGlkX3N1ZmZpeCwgJycgKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCB1bmRlcmJhciwgJyAnICk7XG5cbiAgICAgIGlmKCAhbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgICBzdHIgPSBpbmZsZWN0b3IuY2FwaXRhbGl6ZSggc3RyICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjYXBpdGFsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBbGwgY2hhcmFjdGVycyB3aWxsIGJlIGxvd2VyIGNhc2UgYW5kIHRoZSBmaXJzdCB3aWxsIGJlIHVwcGVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FwaXRhbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlX3Byb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhcGl0YWxpemUoICdtZXNzYWdlIHByb3BlcnRpZXMnLCB0cnVlICk7IC8vID09PSAnTWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYXBpdGFsaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwbGFjZXMgdW5kZXJzY29yZXMgd2l0aCBkYXNoZXMgaW4gdGhlIHN0cmluZy5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJlcGxhY2VzIGFsbCBzcGFjZXMgb3IgdW5kZXJzY29yZXMgd2l0aCBkYXNoZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5kYXNoZXJpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZS1wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5kYXNoZXJpemUoICdNZXNzYWdlIFByb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZS1Qcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBkYXNoZXJpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCBzcGFjZV9vcl91bmRlcmJhciwgJy0nICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB0aXRsZWl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDYXBpdGFsaXplcyB3b3JkcyBhcyB5b3Ugd291bGQgZm9yIGEgYm9vayB0aXRsZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnRpdGxlaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UgUHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udGl0bGVpemUoICdtZXNzYWdlIHByb3BlcnRpZXMgdG8ga2VlcCcgKTsgLy8gPT09ICdNZXNzYWdlIFByb3BlcnRpZXMgdG8gS2VlcCdcbiAgICovXG4gICAgdGl0bGVpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyICAgICAgICAgPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCB1bmRlcmJhciwgJyAnICk7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJyAnICk7XG4gICAgICB2YXIgaSAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuICAgICAgdmFyIGQsIGssIGw7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIGQgPSBzdHJfYXJyWyBpIF0uc3BsaXQoICctJyApO1xuICAgICAgICBrID0gMDtcbiAgICAgICAgbCA9IGQubGVuZ3RoO1xuXG4gICAgICAgIGZvciggOyBrIDwgbDsgaysrKXtcbiAgICAgICAgICBpZiggaW5mbGVjdG9yLmluZGV4T2YoIG5vbl90aXRsZWNhc2VkX3dvcmRzLCBkWyBrIF0udG9Mb3dlckNhc2UoKSkgPCAwICl7XG4gICAgICAgICAgICBkWyBrIF0gPSBpbmZsZWN0b3IuY2FwaXRhbGl6ZSggZFsgayBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJfYXJyWyBpIF0gPSBkLmpvaW4oICctJyApO1xuICAgICAgfVxuXG4gICAgICBzdHIgPSBzdHJfYXJyLmpvaW4oICcgJyApO1xuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZyggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBkZW1vZHVsaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJlbW92ZXMgbW9kdWxlIG5hbWVzIGxlYXZpbmcgb25seSBjbGFzcyBuYW1lcy4oUnVieSBzdHlsZSlcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmRlbW9kdWxpemUoICdNZXNzYWdlOjpCdXM6OlByb3BlcnRpZXMnICk7IC8vID09PSAnUHJvcGVydGllcydcbiAgICovXG4gICAgZGVtb2R1bGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJzo6JyApO1xuXG4gICAgICByZXR1cm4gc3RyX2Fyclsgc3RyX2Fyci5sZW5ndGggLSAxIF07XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB0YWJsZWl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gY2FtZWwgY2FzZWQgd29yZHMgaW50byB0aGVpciB1bmRlcnNjb3JlZCBwbHVyYWwgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnRhYmxlaXplKCAnTWVzc2FnZUJ1c1Byb3BlcnR5JyApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnRpZXMnXG4gICAqL1xuICAgIHRhYmxlaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci51bmRlcnNjb3JlKCBzdHIgKTtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5wbHVyYWxpemUoIHN0ciApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgY2xhc3NpZmljYXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVW5kZXJzY29yZWQgcGx1cmFsIG5vdW5zIGJlY29tZSB0aGUgY2FtZWwgY2FzZWQgc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmNsYXNzaWZ5KCAnbWVzc2FnZV9idXNfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlQnVzUHJvcGVydHknXG4gICAqL1xuICAgIGNsYXNzaWZ5IDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5jYW1lbGl6ZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3Iuc2luZ3VsYXJpemUoIHN0ciApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZm9yZWlnbiBrZXkgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkcm9wX2lkX3ViYXIgRGVmYXVsdCBpcyB0byBzZXBlcmF0ZSBpZCB3aXRoIGFuIHVuZGVyYmFyIGF0IHRoZSBlbmQgb2YgdGhlIGNsYXNzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5b3UgY2FuIHBhc3MgdHJ1ZSB0byBza2lwIGl0LihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gVW5kZXJzY29yZWQgcGx1cmFsIG5vdW5zIGJlY29tZSB0aGUgY2FtZWwgY2FzZWQgc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmZvcmVpZ25fa2V5KCAnTWVzc2FnZUJ1c1Byb3BlcnR5JyApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnR5X2lkJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5mb3JlaWduX2tleSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0eWlkJ1xuICAgKi9cbiAgICBmb3JlaWduX2tleSA6IGZ1bmN0aW9uICggc3RyLCBkcm9wX2lkX3ViYXIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5kZW1vZHVsaXplKCBzdHIgKTtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci51bmRlcnNjb3JlKCBzdHIgKSArICgoIGRyb3BfaWRfdWJhciApID8gKCAnJyApIDogKCAnXycgKSkgKyAnaWQnO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgb3JkaW5hbGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gYWxsIGZvdW5kIG51bWJlcnMgdGhlaXIgc2VxdWVuY2UgbGlrZSAnMjJuZCcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5vcmRpbmFsaXplKCAndGhlIDEgcGl0Y2gnICk7IC8vID09PSAndGhlIDFzdCBwaXRjaCdcbiAgICovXG4gICAgb3JkaW5hbGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJyAnICk7XG4gICAgICB2YXIgaSAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICB2YXIgayA9IHBhcnNlSW50KCBzdHJfYXJyWyBpIF0sIDEwICk7XG5cbiAgICAgICAgaWYoICFpc05hTiggayApKXtcbiAgICAgICAgICB2YXIgbHRkID0gc3RyX2FyclsgaSBdLnN1YnN0cmluZyggc3RyX2FyclsgaSBdLmxlbmd0aCAtIDIgKTtcbiAgICAgICAgICB2YXIgbGQgID0gc3RyX2FyclsgaSBdLnN1YnN0cmluZyggc3RyX2FyclsgaSBdLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgICB2YXIgc3VmID0gJ3RoJztcblxuICAgICAgICAgIGlmKCBsdGQgIT0gJzExJyAmJiBsdGQgIT0gJzEyJyAmJiBsdGQgIT0gJzEzJyApe1xuICAgICAgICAgICAgaWYoIGxkID09PSAnMScgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ3N0JztcbiAgICAgICAgICAgIH1lbHNlIGlmKCBsZCA9PT0gJzInICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICduZCc7XG4gICAgICAgICAgICB9ZWxzZSBpZiggbGQgPT09ICczJyApe1xuICAgICAgICAgICAgICBzdWYgPSAncmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0cl9hcnJbIGkgXSArPSBzdWY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9hcnIuam9pbiggJyAnICk7XG4gICAgfSxcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBtdWx0aXBsZSBpbmZsZWN0aW9uIG1ldGhvZHMgb24gYSBzdHJpbmdcbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBbiBhcnJheSBvZiBpbmZsZWN0aW9uIG1ldGhvZHMuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50cmFuc2Zvcm0oICdhbGwgam9iJywgWyAncGx1cmFsaXplJywgJ2NhcGl0YWxpemUnLCAnZGFzaGVyaXplJyBdKTsgLy8gPT09ICdBbGwtam9icydcbiAgICovXG4gICAgdHJhbnNmb3JtIDogZnVuY3Rpb24gKCBzdHIsIGFyciApe1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDtpIDwgajsgaSsrICl7XG4gICAgICAgIHZhciBtZXRob2QgPSBhcnJbIGkgXTtcblxuICAgICAgICBpZiggaW5mbGVjdG9yLmhhc093blByb3BlcnR5KCBtZXRob2QgKSl7XG4gICAgICAgICAgc3RyID0gaW5mbGVjdG9yWyBtZXRob2QgXSggc3RyICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG4gIGluZmxlY3Rvci52ZXJzaW9uID0gJzEuMTIuMCc7XG5cbiAgcmV0dXJuIGluZmxlY3Rvcjtcbn0pKTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIFJlZmxlY3Q7XG4oZnVuY3Rpb24gKFJlZmxlY3QpIHtcbiAgICAvLyBNZXRhZGF0YSBQcm9wb3NhbFxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvXG4gICAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XG4gICAgICAgIHZhciBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihSZWZsZWN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290LlJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJvb3QuUmVmbGVjdCA9IFJlZmxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihyb290LlJlZmxlY3QsIGV4cG9ydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3J5KGV4cG9ydGVyKTtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUV4cG9ydGVyKHRhcmdldCwgcHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKGZ1bmN0aW9uIChleHBvcnRlcikge1xuICAgICAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgLy8gZmVhdHVyZSB0ZXN0IGZvciBTeW1ib2wgc3VwcG9ydFxuICAgICAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIHZhciB0b1ByaW1pdGl2ZVN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wudG9QcmltaXRpdmUgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wudG9QcmltaXRpdmUgOiBcIkBAdG9QcmltaXRpdmVcIjtcbiAgICAgICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC5pdGVyYXRvciA6IFwiQEBpdGVyYXRvclwiO1xuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxuICAgICAgICB2YXIgc3VwcG9ydHNQcm90byA9IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXk7IC8vIGZlYXR1cmUgdGVzdCBmb3IgX19wcm90b19fIHN1cHBvcnRcbiAgICAgICAgdmFyIGRvd25MZXZlbCA9ICFzdXBwb3J0c0NyZWF0ZSAmJiAhc3VwcG9ydHNQcm90bztcbiAgICAgICAgdmFyIEhhc2hNYXAgPSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IGluIGRpY3Rpb25hcnkgbW9kZSAoYS5rLmEuIFwic2xvd1wiIG1vZGUgaW4gdjgpXG4gICAgICAgICAgICBjcmVhdGU6IHN1cHBvcnRzQ3JlYXRlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxuICAgICAgICAgICAgICAgIDogc3VwcG9ydHNQcm90b1xuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KHsgX19wcm90b19fOiBudWxsIH0pOyB9XG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9LFxuICAgICAgICAgICAgaGFzOiBkb3duTGV2ZWxcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH0sXG4gICAgICAgICAgICBnZXQ6IGRvd25MZXZlbFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSkgPyBtYXBba2V5XSA6IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9hZCBnbG9iYWwgb3Igc2hpbSB2ZXJzaW9ucyBvZiBNYXAsIFNldCwgYW5kIFdlYWtNYXBcbiAgICAgICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcbiAgICAgICAgdmFyIHVzZVBvbHlmaWxsID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbXCJSRUZMRUNUX01FVEFEQVRBX1VTRV9NQVBfUE9MWUZJTExcIl0gPT09IFwidHJ1ZVwiO1xuICAgICAgICB2YXIgX01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gTWFwIDogQ3JlYXRlTWFwUG9seWZpbGwoKTtcbiAgICAgICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XG4gICAgICAgIHZhciBfV2Vha01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpO1xuICAgICAgICAvLyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdFxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcbiAgICAgICAgdmFyIE1ldGFkYXRhID0gbmV3IF9XZWFrTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgc2V0IG9mIGRlY29yYXRvcnMgdG8gYSBwcm9wZXJ0eSBvZiBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBkZWNvcmF0b3JzIEFuIGFycmF5IG9mIGRlY29yYXRvcnMuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVjb3JhdGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcmVtYXJrcyBEZWNvcmF0b3JzIGFyZSBhcHBsaWVkIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIEV4YW1wbGUgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIikpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcbiAgICAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIikpKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChhdHRyaWJ1dGVzKSAmJiAhSXNVbmRlZmluZWQoYXR0cmlidXRlcykgJiYgIUlzTnVsbChhdHRyaWJ1dGVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmIChJc051bGwoYXR0cmlidXRlcykpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlY29yYXRlXCIsIGRlY29yYXRlKTtcbiAgICAgICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jcmVmbGVjdC5tZXRhZGF0YVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWZhdWx0IG1ldGFkYXRhIGRlY29yYXRvciBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgb24gYSBjbGFzcywgY2xhc3MgbWVtYmVyLCBvciBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBUaGUga2V5IGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxuICAgICAgICAgKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvbi5cbiAgICAgICAgICogQHJlbWFya3NcbiAgICAgICAgICogSWYgYG1ldGFkYXRhS2V5YCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoZSB0YXJnZXQgYW5kIHRhcmdldCBrZXksIHRoZVxuICAgICAgICAgKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvciwgVHlwZVNjcmlwdCBvbmx5KVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlLCBUeXBlU2NyaXB0IG9ubHkpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIHByb3BlcnR5O1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZCgpIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZCgpIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkgJiYgIUlzUHJvcGVydHlLZXkocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwibWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgQSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGF0dGFjaGVkIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGRlY29yYXRvciBmYWN0b3J5IGFzIG1ldGFkYXRhLXByb2R1Y2luZyBhbm5vdGF0aW9uLlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xuICAgICAgICAgKiAgICAgICAgIHJldHVybiAodGFyZ2V0LCBrZXk/KSA9PiBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgdGFyZ2V0LCBrZXkpO1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZGVmaW5lTWV0YWRhdGFcIiwgZGVmaW5lTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiaGFzTWV0YWRhdGFcIiwgaGFzTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNPd25NZXRhZGF0YVwiLCBoYXNPd25NZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhXCIsIGdldE1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhXCIsIGdldE93bk1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRNZXRhZGF0YUtleXNcIiwgZ2V0TWV0YWRhdGFLZXlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHVuaXF1ZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHVuaXF1ZSBtZXRhZGF0YSBrZXlzLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhS2V5c1wiLCBnZXRPd25NZXRhZGF0YUtleXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBlbnRyeSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgcHJvcGVydHlLZXksIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhTWFwLmRlbGV0ZShtZXRhZGF0YUtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhTWFwLnNpemUgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5kZWxldGUocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE1ldGFkYXRhLnNpemUgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVsZXRlKHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlbGV0ZU1ldGFkYXRhXCIsIGRlbGV0ZU1ldGFkYXRhKTtcbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKGRlY29yYXRlZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChkZWNvcmF0ZWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQodGFyZ2V0TWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIE1ldGFkYXRhLnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSB0YXJnZXRNZXRhZGF0YS5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjEuMSBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc21ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIGlmIChoYXNPd24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc293bm1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIGlmIChoYXNPd24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNC4xIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlkZWZpbmVvd25tZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnltZXRhZGF0YWtleXNcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcbiAgICAgICAgICAgIHZhciBwYXJlbnRLZXlzID0gT3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRLZXlzLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xuICAgICAgICAgICAgaWYgKG93bktleXMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG93bktleXNfMSA9IG93bktleXM7IF9pIDwgb3duS2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBhcmVudEtleXNfMSA9IHBhcmVudEtleXM7IF9hIDwgcGFyZW50S2V5c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJlbnRLZXlzXzFbX2FdO1xuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gR2V0SXRlcmF0b3Ioa2V5c09iaik7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5c1trXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXNcbiAgICAgICAgZnVuY3Rpb24gVHlwZSh4KSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBOdWxsICovO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6IHJldHVybiAyIC8qIEJvb2xlYW4gKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gMyAvKiBTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gNSAvKiBOdW1iZXIgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4geCA9PT0gbnVsbCA/IDEgLyogTnVsbCAqLyA6IDYgLyogT2JqZWN0ICovO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy11bmRlZmluZWQtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc1VuZGVmaW5lZCh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS4yIFRoZSBOdWxsIFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNOdWxsKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS41IFRoZSBTeW1ib2wgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXN5bWJvbC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNPYmplY3QoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xIFR5cGUgQ29udmVyc2lvblxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cbiAgICAgICAgLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4gICAgICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKFR5cGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFVuZGVmaW5lZCAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEJvb2xlYW4gKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBOdW1iZXIgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICB2YXIgZXhvdGljVG9QcmltID0gR2V0TWV0aG9kKGlucHV0LCB0b1ByaW1pdGl2ZVN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xuICAgICAgICAgICAgICAgIGlmIChJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSBcImRlZmF1bHRcIiA/IFwibnVtYmVyXCIgOiBoaW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMS4xIE9yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcbiAgICAgICAgICAgIGlmIChoaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzEgPSBPLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18xLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZU9mLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSBPLnZhbHVlT2Y7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzIgPSBPLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4yIFRvQm9vbGVhbihhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy10b2Jvb2xlYW5cbiAgICAgICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gISFhcmd1bWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nXG4gICAgICAgIGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xNCBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG4gICAgICAgIGZ1bmN0aW9uIFRvUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBUb1ByaW1pdGl2ZShhcmd1bWVudCwgMyAvKiBTdHJpbmcgKi8pO1xuICAgICAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIHJldHVybiBUb1N0cmluZyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMiBUZXN0aW5nIGFuZCBDb21wYXJpc29uIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVzdGluZy1hbmQtY29tcGFyaXNvbi1vcGVyYXRpb25zXG4gICAgICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbiAgICAgICAgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudCBpbnN0YW5jZW9mIE9iamVjdFxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuICAgICAgICBmdW5jdGlvbiBJc0NhbGxhYmxlKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxuICAgICAgICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc3Byb3BlcnR5a2V5XG4gICAgICAgIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcGVyYXRpb25zLW9uLW9iamVjdHNcbiAgICAgICAgLy8gNy4zLjkgR2V0TWV0aG9kKFYsIFApXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxuICAgICAgICBmdW5jdGlvbiBHZXRNZXRob2QoViwgUCkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xuICAgICAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUoZnVuYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcGVyYXRpb25zLW9uLWl0ZXJhdG9yLW9iamVjdHNcbiAgICAgICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKG1ldGhvZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBmcm9tIENhbGxcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGl0ZXJhdG9yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yc3RlcFxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyBmYWxzZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcmNsb3NlXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBmID0gaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuMSBPcmRpbmFyeSBPYmplY3QgSW50ZXJuYWwgTWV0aG9kcyBhbmQgSW50ZXJuYWwgU2xvdHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXG4gICAgICAgIC8vIDkuMS4xLjEgT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeWdldHByb3RvdHlwZW9mXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xuICAgICAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBPICE9PSBcImZ1bmN0aW9uXCIgfHwgTyA9PT0gZnVuY3Rpb25Qcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHNldCBfX3Byb3RvX18gaW4gRVM1LCBhcyBpdCdzIG5vbi1zdGFuZGFyZC5cbiAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuIENvbXBhdGlibGUgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXG4gICAgICAgICAgICAvLyBvciBlbnN1cmUgZWFjaCBjbGFzcyBoYXMgYSB2YWxpZCBgY29uc3RydWN0b3JgIHByb3BlcnR5IG9uIGl0cyBwcm90b3R5cGUgdGhhdFxuICAgICAgICAgICAgLy8gcG9pbnRzIGJhY2sgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVuIGluIEVTNiBvciB3aGVuIHVzaW5nIF9fcHJvdG9fXyBpbiBhIGNvbXBhdGlibGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChwcm90byAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHN1cGVyIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlLCBudWxsLCBvciB1bmRlZmluZWQsIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gTy5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XG4gICAgICAgICAgICBpZiAocHJvdG90eXBlUHJvdG8gPT0gbnVsbCB8fCBwcm90b3R5cGVQcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvdG90eXBlUHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21lIGtpbmQgb2Ygc2VsZi1yZWZlcmVuY2UsIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXR0eSBnb29kIGd1ZXNzIGF0IHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBNYXAgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XG4gICAgICAgICAgICB2YXIgYXJyYXlTZW50aW5lbCA9IFtdO1xuICAgICAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKGtleXMsIHZhbHVlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zZWxlY3Rvcih0aGlzLl9rZXlzW2luZGV4XSwgdGhpcy5fdmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IHRoaXMuX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2kgLSAxXSA9IHRoaXMuX2tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2kgLSAxXSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLl9jYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEtleSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0RW50cnkpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKGtleSwgaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKHRoaXMuX2NhY2hlS2V5ID0ga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVJbmRleCA8IDAgJiYgaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlSW5kZXg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEtleShrZXksIF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoXywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVTZXRQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmFpdmUgV2Vha01hcCBzaGltXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcbiAgICAgICAgICAgIHZhciBrZXlzID0gSGFzaE1hcC5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZhciByb290S2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZSAhPT0gdW5kZWZpbmVkID8gSGFzaE1hcC5oYXModGFibGUsIHRoaXMuX2tleSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVbdGhpcy5fa2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVVbmlxdWVLZXkoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcIkBAV2Vha01hcEBAXCIgKyBDcmVhdGVVVUlEKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xuICAgICAgICAgICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0YXJnZXQsIHJvb3RLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcm9vdEtleSwgeyB2YWx1ZTogSGFzaE1hcC5jcmVhdGUoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtyb290S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gTWF0aC5yYW5kb20oKSAqIDB4ZmYgfCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBHZW5SYW5kb21CeXRlcyhzaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgVWludDhBcnJheShzaXplKSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IEFycmF5KHNpemUpLCBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBHZW5SYW5kb21CeXRlcyhVVUlEX1NJWkUpO1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgcmFuZG9tIC0gUkZDIDQxMjIgwqcgNC40XG4gICAgICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcbiAgICAgICAgICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSAmIDB4YmYgfCAweDgwO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IDQgfHwgb2Zmc2V0ID09PSA2IHx8IG9mZnNldCA9PT0gOClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGUgPCAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlcyBhIGhldXJpc3RpYyB1c2VkIGJ5IHY4IGFuZCBjaGFrcmEgdG8gZm9yY2UgYW4gb2JqZWN0IGludG8gZGljdGlvbmFyeSBtb2RlLlxuICAgICAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcbiAgICAgICAgICAgIG9iai5fXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX187XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSk7XG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCdhbnktcHJvbWlzZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZm9ybWF0ID0gdXRpbC5mb3JtYXQ7XG5cbmZ1bmN0aW9uIFRpbWVvdXRFcnJvcihtZXNzYWdlLCBlcnIpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGltZW91dEVycm9yKTtcbiAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMucHJldmlvdXMgPSBlcnI7XG59XG5cbnV0aWwuaW5oZXJpdHMoVGltZW91dEVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIG1hdGNoZXMobWF0Y2gsIGVycikge1xuICBpZiAobWF0Y2ggPT09IHRydWUpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBtYXRjaCkgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuICEhbWF0Y2goZXJyKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoID09PSBlcnIudG9TdHJpbmcoKSkgcmV0dXJuIHRydWU7XG4gIGlmIChtYXRjaCA9PT0gZXJyLm1lc3NhZ2UpIHJldHVybiB0cnVlO1xuICByZXR1cm4gbWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAmJiAobWF0Y2gudGVzdChlcnIubWVzc2FnZSkgfHwgbWF0Y2gudGVzdChlcnIudG9TdHJpbmcoKSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJldHJ5QXNQcm9taXNlZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3JldHJ5LWFzLXByb21pc2VkIG11c3QgYmUgcGFzc2VkIGEgY2FsbGJhY2sgYW5kIGEgb3B0aW9ucyBzZXQgb3IgYSBudW1iZXInXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4OiBvcHRpb25zXG4gICAgfTtcbiAgfVxuXG4gIC8vIFN1cGVyIGNoZWFwIGNsb25lXG4gIG9wdGlvbnMgPSB7XG4gICAgJGN1cnJlbnQ6IG9wdGlvbnMuJGN1cnJlbnQgfHwgMSxcbiAgICBtYXg6IG9wdGlvbnMubWF4LFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCB1bmRlZmluZWQsXG4gICAgbWF0Y2g6IG9wdGlvbnMubWF0Y2ggfHwgW10sXG4gICAgYmFja29mZkJhc2U6IG9wdGlvbnMuYmFja29mZkJhc2UgPT09IHVuZGVmaW5lZCA/IDEwMCA6IG9wdGlvbnMuYmFja29mZkJhc2UsXG4gICAgYmFja29mZkV4cG9uZW50OiBvcHRpb25zLmJhY2tvZmZFeHBvbmVudCB8fCAxLjEsXG4gICAgcmVwb3J0OiBvcHRpb25zLnJlcG9ydCB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUgfHwgY2FsbGJhY2submFtZSB8fCAndW5rbm93bidcbiAgfTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXRjaCkpIG9wdGlvbnMubWF0Y2ggPSBbb3B0aW9ucy5tYXRjaF07XG4gIG9wdGlvbnMucmVwb3J0KCdUcnlpbmcgJyArIG9wdGlvbnMubmFtZSArICcgIycgKyBvcHRpb25zLiRjdXJyZW50ICsgJyBhdCAnICsgbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lb3V0LCBiYWNrb2ZmVGltZW91dCwgbGFzdEVycm9yO1xuXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChiYWNrb2ZmVGltZW91dCkgY2xlYXJUaW1lb3V0KGJhY2tvZmZUaW1lb3V0KTtcbiAgICAgICAgcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3Iob3B0aW9ucy5uYW1lICsgJyB0aW1lZCBvdXQnLCBsYXN0RXJyb3IpKTtcbiAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgfVxuXG4gICAgUHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrKHsgY3VycmVudDogb3B0aW9ucy4kY3VycmVudCB9KSlcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgaWYgKGJhY2tvZmZUaW1lb3V0KSBjbGVhclRpbWVvdXQoYmFja29mZlRpbWVvdXQpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgaWYgKGJhY2tvZmZUaW1lb3V0KSBjbGVhclRpbWVvdXQoYmFja29mZlRpbWVvdXQpO1xuXG4gICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgb3B0aW9ucy5yZXBvcnQoKGVyciAmJiBlcnIudG9TdHJpbmcoKSkgfHwgZXJyLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IHJldHJ5IGlmIG1heCBoYXMgYmVlbiByZWFjaGVkXG4gICAgICAgIHZhciBzaG91bGRSZXRyeSA9IG9wdGlvbnMuJGN1cnJlbnQgPCBvcHRpb25zLm1heDtcbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeSkgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBzaG91bGRSZXRyeSA9IG9wdGlvbnMubWF0Y2gubGVuZ3RoID09PSAwIHx8IG9wdGlvbnMubWF0Y2guc29tZShmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcyhtYXRjaCwgZXJyKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeSkgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgIHZhciByZXRyeURlbGF5ID0gTWF0aC5wb3coXG4gICAgICAgICAgb3B0aW9ucy5iYWNrb2ZmQmFzZSxcbiAgICAgICAgICBNYXRoLnBvdyhvcHRpb25zLmJhY2tvZmZFeHBvbmVudCwgb3B0aW9ucy4kY3VycmVudCAtIDEpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRG8gc29tZSBhY2NvdW50aW5nXG4gICAgICAgIG9wdGlvbnMuJGN1cnJlbnQrKztcbiAgICAgICAgb3B0aW9ucy5yZXBvcnQoZm9ybWF0KCdSZXRyeWluZyAlcyAoJXMpJywgb3B0aW9ucy5uYW1lLCBvcHRpb25zLiRjdXJyZW50KSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHJldHJ5RGVsYXkpIHtcbiAgICAgICAgICAvLyBVc2UgYmFja29mZiBmdW5jdGlvbiB0byBlYXNlIHJldHJ5IHJhdGVcbiAgICAgICAgICBvcHRpb25zLnJlcG9ydChmb3JtYXQoJ0RlbGF5aW5nIHJldHJ5IG9mICVzIGJ5ICVzJywgb3B0aW9ucy5uYW1lLCByZXRyeURlbGF5KSwgb3B0aW9ucyk7XG4gICAgICAgICAgYmFja29mZlRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0cnlBc1Byb21pc2VkKGNhbGxiYWNrLCBvcHRpb25zKVxuICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRyeUFzUHJvbWlzZWQoY2FsbGJhY2ssIG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbiIsImNvbnN0IEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgQ29tcGFyYXRvciB7XG4gIHN0YXRpYyBnZXQgQU5ZICgpIHtcbiAgICByZXR1cm4gQU5ZXG4gIH1cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvblxuICAgIGNvbnN0IGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpXG4gICAgY29uc3Qgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgICAgY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG5cbiAgICByZXR1cm4gKFxuICAgICAgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHxcbiAgICAgIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiIsIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgvXFxzKlxcfFxcfFxccyovKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHJhbmdlID0+IHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7cmFuZ2V9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXRcbiAgICAgIC5tYXAoKGNvbXBzKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ3x8JylcbiAgICAgIC50cmltKClcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UudHJpbSgpXG5cbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykuam9pbignLCcpXG4gICAgY29uc3QgbWVtb0tleSA9IGBwYXJzZVJhbmdlOiR7bWVtb09wdHN9OiR7cmFuZ2V9YFxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpXG4gICAgICByZXR1cm4gY2FjaGVkXG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW3QuQ09NUEFSQVRPUlRSSU1dKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcblxuICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG5cbiAgICAvLyBub3JtYWxpemUgc3BhY2VzXG4gICAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgY29uc3QgY29tcFJlID0gbG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIC5maWx0ZXIodGhpcy5vcHRpb25zLmxvb3NlID8gY29tcCA9PiAhIWNvbXAubWF0Y2goY29tcFJlKSA6ICgpID0+IHRydWUpXG4gICAgICAubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsID0gcmFuZ2VMaXN0Lmxlbmd0aFxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHJhbmdlTGlzdCkge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSlcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKVxuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpXG5jb25zdCBjYWNoZSA9IG5ldyBMUlUoeyBtYXg6IDEwMDAgfSlcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jb21wYXJhdG9yJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3Qge1xuICByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8JylcbiAgICAgICAgcHIgPSAnLTAnXG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gKGAke2Zyb219ICR7dG99YCkudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlfWApXG4gICAgfVxuICAgIHRoaXMuZm9ybWF0KClcbiAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vbmVxJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9ndCcpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2d0ZScpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9sdGUnKVxuXG5jb25zdCBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmXG4gICAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGxcblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYxID0gcGFyc2UodmVyc2lvbjEpXG4gICAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICBjb25zdCBoYXNQcmUgPSB2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aFxuICAgIGNvbnN0IHByZWZpeCA9IGhhc1ByZSA/ICdwcmUnIDogJydcbiAgICBjb25zdCBkZWZhdWx0UmVzdWx0ID0gaGFzUHJlID8gJ3ByZXJlbGVhc2UnIDogJydcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGtleVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtYWpvciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3Jcbm1vZHVsZS5leHBvcnRzID0gbWFqb3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwiY29uc3Qge01BWF9MRU5HVEh9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgcHJlcmVsZWFzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlcmVsZWFzZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbm1vZHVsZS5leHBvcnRzID0ge1xuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJykuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgU2VtVmVyOiByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJyksXG4gIGNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLnJjb21wYXJlSWRlbnRpZmllcnMsXG4gIHBhcnNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpLFxuICB2YWxpZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKSxcbiAgY2xlYW46IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJyksXG4gIGluYzogcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJyksXG4gIGRpZmY6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKSxcbiAgbWFqb3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJyksXG4gIG1pbm9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpLFxuICBwYXRjaDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKSxcbiAgcHJlcmVsZWFzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpLFxuICBjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJyksXG4gIHJjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpLFxuICBjb21wYXJlTG9vc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKSxcbiAgY29tcGFyZUJ1aWxkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJyksXG4gIHNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKSxcbiAgcnNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JyksXG4gIGd0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpLFxuICBsdDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKSxcbiAgZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJyksXG4gIG5lcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJyksXG4gIGd0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJyksXG4gIGx0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJyksXG4gIGNtcDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJyksXG4gIGNvZXJjZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJyksXG4gIENvbXBhcmF0b3I6IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJyksXG4gIFJhbmdlOiByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKSxcbiAgc2F0aXNmaWVzOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKSxcbiAgdG9Db21wYXJhdG9yczogcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKSxcbiAgbWF4U2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKSxcbiAgbWluU2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKSxcbiAgbWluVmVyc2lvbjogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKSxcbiAgdmFsaWRSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKSxcbiAgb3V0c2lkZTogcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpLFxuICBndHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpLFxuICBsdHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpLFxuICBpbnRlcnNlY3RzOiByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJyksXG4gIHNpbXBsaWZ5UmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JyksXG4gIHN1YnNldDogcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0JyksXG59XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnNcbn1cbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXQgc28gd2UgYWx3YXlzIGdldCBhIGNvbnNpc3RlbnRcbi8vIG9iaiB3aXRoIGtleXMgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuY29uc3Qgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ11cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT5cbiAgIW9wdGlvbnMgPyB7fVxuICA6IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgbG9vc2U6IHRydWUgfVxuICA6IG9wdHMuZmlsdGVyKGsgPT4gb3B0aW9uc1trXSkucmVkdWNlKChvcHRpb25zLCBrKSA9PiB7XG4gICAgb3B0aW9uc1trXSA9IHRydWVcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9LCB7fSlcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCB7IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJylcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJylcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcLjBcXC4wXFxcXHMqJCcpXG5jcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjAtMFxcXFxzKiQnKVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgaW50ZXJzZWN0cyA9IChyMSwgcjIsIG9wdGlvbnMpID0+IHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0c1xuIiwiY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmNvbnN0IGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBsdHJcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbmNvbnN0IG1heFNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtYXggPSBudWxsXG4gIGxldCBtYXhTViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxubW9kdWxlLmV4cG9ydHMgPSBtYXhTYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcblxuY29uc3QgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIGxldCBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IHNldE1pbiA9IG51bGxcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIXNldE1pbiB8fCBndChjb21wdmVyLCBzZXRNaW4pKSB7XG4gICAgICAgICAgICBzZXRNaW4gPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvcGVyYXRpb246ICR7Y29tcGFyYXRvci5vcGVyYXRvcn1gKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHNldE1pbiAmJiAoIW1pbnZlciB8fCBndChtaW52ZXIsIHNldE1pbikpKVxuICAgICAgbWludmVyID0gc2V0TWluXG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblZlcnNpb25cbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3Qge0FOWX0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgbWluID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFtaW4pXG4gICAgICAgIG1pbiA9IHZlcnNpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW21pbiwgcHJldl0pXG4gICAgICB9XG4gICAgICBwcmV2ID0gbnVsbFxuICAgICAgbWluID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAobWluKVxuICAgIHNldC5wdXNoKFttaW4sIG51bGxdKVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpXG4gICAgICByYW5nZXMucHVzaChtaW4pXG4gICAgZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pXG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgZWxzZSBpZiAoIW1heClcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgZWxzZSBpZiAobWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goYDw9JHttYXh9YClcbiAgICBlbHNlXG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pXG4gICAgcmV0dXJuIHRydWVcblxuICBzdWIgPSBuZXcgUmFuZ2Uoc3ViLCBvcHRpb25zKVxuICBkb20gPSBuZXcgUmFuZ2UoZG9tLCBvcHRpb25zKVxuICBsZXQgc2F3Tm9uTnVsbCA9IGZhbHNlXG5cbiAgT1VURVI6IGZvciAoY29uc3Qgc2ltcGxlU3ViIG9mIHN1Yi5zZXQpIHtcbiAgICBmb3IgKGNvbnN0IHNpbXBsZURvbSBvZiBkb20uc2V0KSB7XG4gICAgICBjb25zdCBpc1N1YiA9IHNpbXBsZVN1YnNldChzaW1wbGVTdWIsIHNpbXBsZURvbSwgb3B0aW9ucylcbiAgICAgIHNhd05vbk51bGwgPSBzYXdOb25OdWxsIHx8IGlzU3ViICE9PSBudWxsXG4gICAgICBpZiAoaXNTdWIpXG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pXG4gICAgcmV0dXJuIHRydWVcblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpXG4gICAgICBzdWIgPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKSBdXG4gICAgZWxzZVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlXG4gICAgICBkb20gPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJykgXVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKVxuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICBlbHNlIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9JylcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICBlbHNlXG4gICAgICBlcVNldC5hZGQoYy5zZW12ZXIpXG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpXG4gICAgcmV0dXJuIG51bGxcblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIGVsc2UgaWYgKGd0bHRDb21wID09PSAwICYmIChndC5vcGVyYXRvciAhPT0gJz49JyB8fCBsdC5vcGVyYXRvciAhPT0gJzw9JykpXG4gICAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gd2lsbCBpdGVyYXRlIG9uZSBvciB6ZXJvIHRpbWVzXG4gIGZvciAoY29uc3QgZXEgb2YgZXFTZXQpIHtcbiAgICBpZiAoZ3QgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKGx0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgIGlmICghc2F0aXNmaWVzKGVxLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoZ3Qub3BlcmF0b3IgPT09ICc+PScgJiYgIXNhdGlzZmllcyhndC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gJzw9JyAmJiAhc2F0aXNmaWVzKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSlcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wID4gMCA/IGFcbiAgICA6IGNvbXAgPCAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJz4nICYmIGEub3BlcmF0b3IgPT09ICc+PScgPyBiXG4gICAgOiBhXG59XG5cbi8vIDw9MS4yLjMgaXMgaGlnaGVyIHRoYW4gPDEuMi4zXG5jb25zdCBsb3dlckxUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKVxuICAgIHJldHVybiBiXG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSAocmFuZ2UsIG9wdGlvbnMpID0+XG4gIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0XG4gICAgLm1hcChjb21wID0+IGNvbXAubWFwKGMgPT4gYy52YWx1ZSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQ29tcGFyYXRvcnNcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCB2YWxpZFJhbmdlID0gKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRSYW5nZVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFnZ3JlZ2F0ZUVycm9yID0gdm9pZCAwO1xuY2xhc3MgQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBBZ2dyZWdhdGVFcnJvciBvZjpcXG4ke3RoaXMuZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlcnJvcikgPT4gZXJyb3IgPT09IHRoaXNcbiAgICAgICAgICAgID8gJ1tDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl0nXG4gICAgICAgICAgICA6IGVycm9yIGluc3RhbmNlb2YgQWdncmVnYXRlRXJyb3JcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXFxuJC8sICcnKS5yZXBsYWNlKC9eL2dtLCAnICAnKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9eL2dtLCAnICAgICcpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKX1cXG5gO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59XG5leHBvcnRzLkFnZ3JlZ2F0ZUVycm9yID0gQWdncmVnYXRlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZ2dyZWdhdGVFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmZXJyZWQgPSB2b2lkIDA7XG5jb25zdCBUaW1lb3V0RXJyb3JfMSA9IHJlcXVpcmUoXCIuL1RpbWVvdXRFcnJvclwiKTtcbmNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJUaW1lb3V0KHRpbWVvdXRJbk1pbGxpcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgVGltZW91dEVycm9yXzEuVGltZW91dEVycm9yKCdPcGVyYXRpb24gdGltZW91dCcpKTtcbiAgICAgICAgfSwgdGltZW91dEluTWlsbGlzKTtcbiAgICB9XG4gICAgX2NsZWFyVGltZW91dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90aW1lb3V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgfVxuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgICByZWplY3QoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmZXJyZWQgPSBEZWZlcnJlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmVycmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvb2wgPSB2b2lkIDA7XG5jb25zdCBEZWZlcnJlZF8xID0gcmVxdWlyZShcIi4vRGVmZXJyZWRcIik7XG5jb25zdCBBZ2dyZWdhdGVFcnJvcl8xID0gcmVxdWlyZShcIi4vQWdncmVnYXRlRXJyb3JcIik7XG5jbGFzcyBQb29sIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMubG9nID0gZmFsc2U7XG4gICAgICAgIGlmICghZmFjdG9yeS5jcmVhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmYWN0b3J5LmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdHJveSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmFjdG9yeS52YWxpZGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0ZSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeS5taW4gIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBmYWN0b3J5Lm1pbiA8IDAgfHxcbiAgICAgICAgICAgIGZhY3RvcnkubWluICE9PSBNYXRoLnJvdW5kKGZhY3RvcnkubWluKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW4gbXVzdCBiZSBhbiBpbnRlZ2VyID49IDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkubWF4ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgZmFjdG9yeS5tYXggPD0gMCB8fFxuICAgICAgICAgICAgZmFjdG9yeS5tYXggIT09IE1hdGgucm91bmQoZmFjdG9yeS5tYXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heCBtdXN0IGJlIGFuIGludGVnZXIgPiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhY3RvcnkubWluID4gZmFjdG9yeS5tYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IGlzIHNtYWxsZXIgdGhhbiBtaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFjdG9yeS5tYXhVc2VzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICh0eXBlb2YgZmFjdG9yeS5tYXhVc2VzICE9PSAnbnVtYmVyJyB8fCBmYWN0b3J5Lm1heFVzZXMgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhVc2VzIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGxlVGltZW91dE1pbGxpcyA9IGZhY3RvcnkuaWRsZVRpbWVvdXRNaWxsaXMgfHwgMzAwMDA7XG4gICAgICAgIHRoaXMuYWNxdWlyZVRpbWVvdXRNaWxsaXMgPSBmYWN0b3J5LmFjcXVpcmVUaW1lb3V0TWlsbGlzIHx8IDMwMDAwO1xuICAgICAgICB0aGlzLnJlYXBJbnRlcnZhbE1pbGxpcyA9IGZhY3RvcnkucmVhcEludGVydmFsTWlsbGlzIHx8IDEwMDA7XG4gICAgICAgIHRoaXMubWF4VXNlc1BlclJlc291cmNlID0gZmFjdG9yeS5tYXhVc2VzIHx8IEluZmluaXR5O1xuICAgICAgICB0aGlzLmxvZyA9IGZhY3RvcnkubG9nIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICB0aGlzLl9kcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWNxdWlyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5Vc2VPYmplY3RzID0gW107XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZU9iamVjdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50O1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkubmFtZTtcbiAgICB9XG4gICAgZ2V0IGF2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgdXNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pblVzZU9iamVjdHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgd2FpdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBtYXhTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5tYXg7XG4gICAgfVxuICAgIGdldCBtaW5TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5taW47XG4gICAgfVxuICAgIF9sb2cobWVzc2FnZSwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5sb2cobWVzc2FnZSwgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubG9nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtsZXZlbC50b1VwcGVyQ2FzZSgpfSBwb29sICR7dGhpcy5uYW1lIHx8ICcnfSAtICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVtb3ZlSWRsZSgpIHtcbiAgICAgICAgY29uc3QgdG9SZW1vdmUgPSBbXTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBhdmFpbGFibGUgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4UmVtb3ZhYmxlID0gdGhpcy5zaXplIC0gdGhpcy5taW5TaXplO1xuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXZhaWxhYmxlICYmIG1heFJlbW92YWJsZSA+IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0c1tpXS50aW1lb3V0O1xuICAgICAgICAgICAgaWYgKG5vdyA+PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdyZW1vdmVJZGxlKCkgZGVzdHJveWluZyBvYmogLSBub3c6JyArIG5vdyArICcgdGltZW91dDonICsgdGltZW91dCwgJ3ZlcmJvc2UnKTtcbiAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKHRoaXMuX2F2YWlsYWJsZU9iamVjdHNbaV0ucmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2godGhpcy5kZXN0cm95LCB0aGlzKTtcbiAgICAgICAgYXZhaWxhYmxlID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIGlmIChhdmFpbGFibGUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ3RoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoPScgKyBhdmFpbGFibGUsICd2ZXJib3NlJyk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVJlbW92ZUlkbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygncmVtb3ZlSWRsZSgpIGFsbCBvYmplY3RzIHJlbW92ZWQnLCAndmVyYm9zZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zY2hlZHVsZVJlbW92ZUlkbGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVtb3ZlSWRsZVNjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJZGxlKCk7XG4gICAgICAgICAgICB9LCB0aGlzLnJlYXBJbnRlcnZhbE1pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Rpc3BlbnNlKCkge1xuICAgICAgICBsZXQgd3JhcHBlZFJlc291cmNlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgd2FpdGluZ0NvdW50ID0gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fbG9nKGBkaXNwZW5zZSgpIGNsaWVudHM9JHt3YWl0aW5nQ291bnR9IGF2YWlsYWJsZT0ke3RoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RofWAsICdpbmZvJyk7XG4gICAgICAgIGlmICh3YWl0aW5nQ291bnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdkaXNwZW5zZSgpIC0gcmV1c2luZyBvYmonLCAndmVyYm9zZScpO1xuICAgICAgICAgICAgd3JhcHBlZFJlc291cmNlID0gdGhpcy5fYXZhaWxhYmxlT2JqZWN0c1t0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9mYWN0b3J5LnZhbGlkYXRlKHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kod3JhcHBlZFJlc291cmNlLnJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZU9iamVjdHMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZXNvdXJjZVRvSW5Vc2VPYmplY3RzKHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSwgd3JhcHBlZFJlc291cmNlLnVzZUNvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSh3cmFwcGVkUmVzb3VyY2UucmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpemUgPCB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZVJlc291cmNlKCkge1xuICAgICAgICB0aGlzLl9jb3VudCArPSAxO1xuICAgICAgICB0aGlzLl9sb2coYGNyZWF0ZVJlc291cmNlKCkgLSBjcmVhdGluZyBvYmogLSBjb3VudD0ke3RoaXMuc2l6ZX0gbWluPSR7dGhpcy5taW5TaXplfSBtYXg9JHt0aGlzLm1heFNpemV9YCwgJ3ZlcmJvc2UnKTtcbiAgICAgICAgdGhpcy5fZmFjdG9yeVxuICAgICAgICAgICAgLmNyZWF0ZSgpXG4gICAgICAgICAgICAudGhlbigocmVzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSZXNvdXJjZVRvSW5Vc2VPYmplY3RzKHJlc291cmNlLCAwKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJlc291cmNlVG9BdmFpbGFibGVPYmplY3RzKHJlc291cmNlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl9jb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50IDwgMClcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGVuc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZFJlc291cmNlVG9BdmFpbGFibGVPYmplY3RzKHJlc291cmNlLCB1c2VDb3VudCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkUmVzb3VyY2UgPSB7XG4gICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICAgICAgICB1c2VDb3VudDogdXNlQ291bnQsXG4gICAgICAgICAgICB0aW1lb3V0OiBEYXRlLm5vdygpICsgdGhpcy5pZGxlVGltZW91dE1pbGxpcyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlT2JqZWN0cy5wdXNoKHdyYXBwZWRSZXNvdXJjZSk7XG4gICAgICAgIHRoaXMuX2Rpc3BlbnNlKCk7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVtb3ZlSWRsZSgpO1xuICAgIH1cbiAgICBfYWRkUmVzb3VyY2VUb0luVXNlT2JqZWN0cyhyZXNvdXJjZSwgdXNlQ291bnQpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFJlc291cmNlID0ge1xuICAgICAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlLFxuICAgICAgICAgICAgdXNlQ291bnQ6IHVzZUNvdW50LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pblVzZU9iamVjdHMucHVzaCh3cmFwcGVkUmVzb3VyY2UpO1xuICAgIH1cbiAgICBfZW5zdXJlTWluaW11bSgpIHtcbiAgICAgICAgbGV0IGksIGRpZmY7XG4gICAgICAgIGlmICghdGhpcy5fZHJhaW5pbmcgJiYgdGhpcy5zaXplIDwgdGhpcy5taW5TaXplKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5taW5TaXplIC0gdGhpcy5zaXplO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RyYWluaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdwb29sIGlzIGRyYWluaW5nIGFuZCBjYW5ub3QgYWNjZXB0IHdvcmsnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRfMS5EZWZlcnJlZCgpO1xuICAgICAgICBkZWZlcnJlZC5yZWdpc3RlclRpbWVvdXQodGhpcy5hY3F1aXJlVGltZW91dE1pbGxpcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0FjcXVpcmVzID0gdGhpcy5fcGVuZGluZ0FjcXVpcmVzLmZpbHRlcigocGVuZGluZykgPT4gcGVuZGluZyAhPT0gZGVmZXJyZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0FjcXVpcmVzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICB0aGlzLl9kaXNwZW5zZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH1cbiAgICByZWxlYXNlKHJlc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdmFpbGFibGVPYmplY3RzLnNvbWUoKHJlc291cmNlV2l0aFRpbWVvdXQpID0+IHJlc291cmNlV2l0aFRpbWVvdXQucmVzb3VyY2UgPT09IHJlc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdyZWxlYXNlIGNhbGxlZCB0d2ljZSBmb3IgdGhlIHNhbWUgcmVzb3VyY2U6ICcgKyBuZXcgRXJyb3IoKS5zdGFjaywgJ2Vycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pblVzZU9iamVjdHMuZmluZEluZGV4KCh3cmFwcGVkUmVzb3VyY2UpID0+IHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ2F0dGVtcHQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkIHJlc291cmNlOiAnICsgbmV3IEVycm9yKCkuc3RhY2ssICdlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRSZXNvdXJjZSA9IHRoaXMuX2luVXNlT2JqZWN0c1tpbmRleF07XG4gICAgICAgIHdyYXBwZWRSZXNvdXJjZS51c2VDb3VudCArPSAxO1xuICAgICAgICBpZiAod3JhcHBlZFJlc291cmNlLnVzZUNvdW50ID49IHRoaXMubWF4VXNlc1BlclJlc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ3JlbGVhc2UoKSBkZXN0cm95aW5nIG9iaiAtIHVzZUNvdW50OicgK1xuICAgICAgICAgICAgICAgIHdyYXBwZWRSZXNvdXJjZS51c2VDb3VudCArXG4gICAgICAgICAgICAgICAgJyBtYXhVc2VzUGVyUmVzb3VyY2U6JyArXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhVc2VzUGVyUmVzb3VyY2UsICd2ZXJib3NlJyk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kod3JhcHBlZFJlc291cmNlLnJlc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BlbnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pblVzZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFJlc291cmNlVG9BdmFpbGFibGVPYmplY3RzKHdyYXBwZWRSZXNvdXJjZS5yZXNvdXJjZSwgd3JhcHBlZFJlc291cmNlLnVzZUNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHVzaW5nID0gdGhpcy5faW5Vc2VPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZU9iamVjdHMgPSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmZpbHRlcigob2JqZWN0KSA9PiBvYmplY3QucmVzb3VyY2UgIT09IHJlc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2luVXNlT2JqZWN0cyA9IHRoaXMuX2luVXNlT2JqZWN0cy5maWx0ZXIoKG9iamVjdCkgPT4gb2JqZWN0LnJlc291cmNlICE9PSByZXNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlID09PSB0aGlzLl9hdmFpbGFibGVPYmplY3RzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHVzaW5nID09PSB0aGlzLl9pblVzZU9iamVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlTWluaW11bSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnQgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fZmFjdG9yeS5kZXN0cm95KHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZU1pbmltdW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICB0aGlzLl9sb2coJ2RyYWluaW5nJywgJ2luZm8nKTtcbiAgICAgICAgdGhpcy5fZHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBjaGVjayA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdBY3F1aXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGVuc2UoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubGVuZ3RoICE9PSB0aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGVjayhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNoZWNrKHJlc29sdmUpKTtcbiAgICB9XG4gICAgZGVzdHJveUFsbE5vdygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnZm9yY2UgZGVzdHJveWluZyBhbGwgb2JqZWN0cycsICdpbmZvJyk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlSWRsZVRpbWVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuX2F2YWlsYWJsZU9iamVjdHMubWFwKChyZXNvdXJjZSkgPT4gcmVzb3VyY2UucmVzb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGVzdHJveShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ0Vycm9yIGRlc3Ryb3lpbmcgcmVzb3VyY2U6ICcgKyBleC5zdGFjaywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3JfMS5BZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBvb2wgPSBQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9vbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gdm9pZCAwO1xuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lb3V0RXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKFwiLi9UaW1lb3V0RXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lb3V0RXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcjsgfSB9KTtcbnZhciBQb29sXzEgPSByZXF1aXJlKFwiLi9Qb29sXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9vbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9vbF8xLlBvb2w7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5mZXJBbGlhcyA9IHZvaWQgMDtcbmNvbnN0IGFzc29jaWF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbi8qKlxuICogUHJlIGNvbmZvcm0gaW5jbHVkZXMsIHNvIHRoYXQgXCJhc1wiIHZhbHVlIGNhbiBiZSBpbmZlcnJlZCBmcm9tIHNvdXJjZVxuICovXG5mdW5jdGlvbiBpbmZlckFsaWFzKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLy8gaWYgaW5jbHVkZSBpcyBub3QgYW4gYXJyYXksIHdyYXAgaW4gYW4gYXJyYXlcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlKSkge1xuICAgICAgICBvcHRpb25zLmluY2x1ZGUgPSBbb3B0aW9ucy5pbmNsdWRlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW5jbHVkZTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYWxsIGluY2x1ZGVkIGVsZW1lbnRzIHRvIHsgbW9kZWw6IE1vZGVsIH0gZm9ybVxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZS5tYXAoKGluY2x1ZGUpID0+IHtcbiAgICAgICAgaW5jbHVkZSA9IGluZmVyQWxpYXNGb3JJbmNsdWRlKGluY2x1ZGUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5pbmZlckFsaWFzID0gaW5mZXJBbGlhcztcbi8qKlxuICogUHJlIGNvbmZvcm0gaW5jbHVkZSwgc28gdGhhdCBhbGlhcyAoXCJhc1wiKSB2YWx1ZSBjYW4gYmUgaW5mZXJyZWQgZnJvbSBzb3VyY2UgY2xhc3NcbiAqL1xuZnVuY3Rpb24gaW5mZXJBbGlhc0ZvckluY2x1ZGUoaW5jbHVkZSwgc291cmNlKSB7XG4gICAgY29uc3QgaGFzTW9kZWxPcHRpb25XaXRob3V0QXNPcHRpb24gPSAhIShpbmNsdWRlLm1vZGVsICYmICFpbmNsdWRlLmFzKTtcbiAgICBjb25zdCBoYXNJbmNsdWRlT3B0aW9ucyA9ICEhaW5jbHVkZS5pbmNsdWRlO1xuICAgIGNvbnN0IGlzQ29uc3RydWN0b3JGbiA9IGluY2x1ZGUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICBpZiAoaXNDb25zdHJ1Y3RvckZuIHx8IGhhc01vZGVsT3B0aW9uV2l0aG91dEFzT3B0aW9uKSB7XG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yRm4pIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSB7IG1vZGVsOiBpbmNsdWRlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0UHJvdG90eXBlID0gc291cmNlLnByb3RvdHlwZSB8fCBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRDbGFzcyA9IGluY2x1ZGUubW9kZWw7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IGFzc29jaWF0aW9uX3NlcnZpY2VfMS5nZXRBc3NvY2lhdGlvbnNCeVJlbGF0aW9uKHRhcmdldFByb3RvdHlwZSwgcmVsYXRlZENsYXNzKTtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsaWFzIGNhbm5vdCBiZSBpbmZlcnJlZDogXCIke3NvdXJjZS5uYW1lfVwiIGhhcyBtdWx0aXBsZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHJlbGF0aW9ucyB3aXRoIFwiJHtpbmNsdWRlLm1vZGVsLm5hbWV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY2x1ZGUuYXMgPSBhc3NvY2lhdGlvbnNbMF0uZ2V0QXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29uc3RydWN0b3JGbiAmJiBoYXNJbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBpbmNsdWRlID0gaW5mZXJBbGlhcyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGluY2x1ZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGlhcy1pbmZlcmVuY2Utc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVsb25nc1RvTWFueUFzc29jaWF0aW9uID0gdm9pZCAwO1xuY29uc3QgYmFzZV9hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9iYXNlLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvc2hhcmVkL21vZGVsLW5vdC1pbml0aWFsaXplZC1lcnJvclwiKTtcbmNvbnN0IGZvcmVpZ25fa2V5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9mb3JlaWduLWtleS9mb3JlaWduLWtleS1zZXJ2aWNlXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb25cIik7XG5jbGFzcyBCZWxvbmdzVG9NYW55QXNzb2NpYXRpb24gZXh0ZW5kcyBiYXNlX2Fzc29jaWF0aW9uXzEuQmFzZUFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0QXNzb2NpYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbl8xLkFzc29jaWF0aW9uLkJlbG9uZ3NUb01hbnk7XG4gICAgfVxuICAgIGdldFNlcXVlbGl6ZU9wdGlvbnMobW9kZWwsIHNlcXVlbGl6ZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRlZENsYXNzID0gdGhpcy5nZXRBc3NvY2lhdGVkQ2xhc3MoKTtcbiAgICAgICAgY29uc3QgdGhyb3VnaE9wdGlvbnMgPSB0aGlzLmdldFRocm91Z2hPcHRpb25zKHNlcXVlbGl6ZSk7XG4gICAgICAgIGNvbnN0IHRocm91Z2hNb2RlbCA9IHR5cGVvZiB0aHJvdWdoT3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm91Z2hPcHRpb25zLm1vZGVsICE9PSBcInN0cmluZ1wiID8gdGhyb3VnaE9wdGlvbnMubW9kZWwgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMudGhyb3VnaCA9IHRocm91Z2hPcHRpb25zO1xuICAgICAgICBvcHRpb25zLmZvcmVpZ25LZXkgPSBmb3JlaWduX2tleV9zZXJ2aWNlXzEuZ2V0Rm9yZWlnbktleU9wdGlvbnMobW9kZWwsIHRocm91Z2hNb2RlbCwgdGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICBvcHRpb25zLm90aGVyS2V5ID0gZm9yZWlnbl9rZXlfc2VydmljZV8xLmdldEZvcmVpZ25LZXlPcHRpb25zKGFzc29jaWF0ZWRDbGFzcywgdGhyb3VnaE1vZGVsLCB0aGlzLm9wdGlvbnMub3RoZXJLZXkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0VGhyb3VnaE9wdGlvbnMoc2VxdWVsaXplKSB7XG4gICAgICAgIGNvbnN0IHRocm91Z2ggPSB0aGlzLm9wdGlvbnMudGhyb3VnaDtcbiAgICAgICAgY29uc3QgdGhyb3VnaE1vZGVsID0gdHlwZW9mIHRocm91Z2ggPT09ICdvYmplY3QnID8gdGhyb3VnaC5tb2RlbCA6IHRocm91Z2g7XG4gICAgICAgIGNvbnN0IHRocm91Z2hPcHRpb25zID0gdHlwZW9mIHRocm91Z2ggPT09ICdvYmplY3QnID8gT2JqZWN0LmFzc2lnbih7fSwgdGhyb3VnaCkgOiB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aHJvdWdoTW9kZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHRocm91Z2hNb2RlbENsYXNzID0gc2VxdWVsaXplLm1vZGVsKHRocm91Z2hNb2RlbCgpKTtcbiAgICAgICAgICAgIGlmICghdGhyb3VnaE1vZGVsQ2xhc3MuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMS5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IodGhyb3VnaE1vZGVsQ2xhc3MsICdBc3NvY2lhdGlvbiBjYW5ub3QgYmUgcmVzb2x2ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdWdoT3B0aW9ucy5tb2RlbCA9IHRocm91Z2hNb2RlbENsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRocm91Z2hNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhyb3VnaE9wdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5CZWxvbmdzVG9NYW55QXNzb2NpYXRpb24gPSBCZWxvbmdzVG9NYW55QXNzb2NpYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLW1hbnktYXNzb2NpYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLW1hbnktb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVsb25nc1RvTWFueSA9IHZvaWQgMDtcbmNvbnN0IGJlbG9uZ3NfdG9fbWFueV9hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4vYmVsb25ncy10by1tYW55LWFzc29jaWF0aW9uXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVsb25nc1RvTWFueShhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIHRocm91Z2hPck9wdGlvbnMsIGZvcmVpZ25LZXksIG90aGVyS2V5KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHsgZm9yZWlnbktleSwgb3RoZXJLZXkgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aHJvdWdoT3JPcHRpb25zID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRocm91Z2hPck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGhyb3VnaCA9IHRocm91Z2hPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyb3VnaE9yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmFzKVxuICAgICAgICAgICAgb3B0aW9ucy5hcyA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgYXNzb2NpYXRpb25fc2VydmljZV8xLmFkZEFzc29jaWF0aW9uKHRhcmdldCwgbmV3IGJlbG9uZ3NfdG9fbWFueV9hc3NvY2lhdGlvbl8xLkJlbG9uZ3NUb01hbnlBc3NvY2lhdGlvbihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5CZWxvbmdzVG9NYW55ID0gQmVsb25nc1RvTWFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8tbWFueS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVsb25nc1RvQXNzb2NpYXRpb24gPSB2b2lkIDA7XG5jb25zdCBiYXNlX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Jhc2UtYXNzb2NpYXRpb25cIik7XG5jb25zdCBmb3JlaWduX2tleV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZm9yZWlnbi1rZXkvZm9yZWlnbi1rZXktc2VydmljZVwiKTtcbmNvbnN0IGFzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uXCIpO1xuY2xhc3MgQmVsb25nc1RvQXNzb2NpYXRpb24gZXh0ZW5kcyBiYXNlX2Fzc29jaWF0aW9uXzEuQmFzZUFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0QXNzb2NpYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbl8xLkFzc29jaWF0aW9uLkJlbG9uZ3NUbztcbiAgICB9XG4gICAgZ2V0U2VxdWVsaXplT3B0aW9ucyhtb2RlbCkge1xuICAgICAgICBjb25zdCBhc3NvY2lhdGVkQ2xhc3MgPSB0aGlzLmdldEFzc29jaWF0ZWRDbGFzcygpO1xuICAgICAgICBjb25zdCBmb3JlaWduS2V5ID0gZm9yZWlnbl9rZXlfc2VydmljZV8xLmdldEZvcmVpZ25LZXlPcHRpb25zKGFzc29jaWF0ZWRDbGFzcywgbW9kZWwsIHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgeyBmb3JlaWduS2V5IH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmVsb25nc1RvQXNzb2NpYXRpb24gPSBCZWxvbmdzVG9Bc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8tYXNzb2NpYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlbG9uZ3NUbyA9IHZvaWQgMDtcbmNvbnN0IGJlbG9uZ3NfdG9fYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG8tYXNzb2NpYXRpb25cIik7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWxvbmdzVG8oYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zT3JGb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXNzb2NpYXRpb25fc2VydmljZV8xLmdldFByZXBhcmVkQXNzb2NpYXRpb25PcHRpb25zKG9wdGlvbnNPckZvcmVpZ25LZXkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXMpXG4gICAgICAgICAgICBvcHRpb25zLmFzID0gcHJvcGVydHlOYW1lO1xuICAgICAgICBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuYWRkQXNzb2NpYXRpb24odGFyZ2V0LCBuZXcgYmVsb25nc190b19hc3NvY2lhdGlvbl8xLkJlbG9uZ3NUb0Fzc29jaWF0aW9uKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucykpO1xuICAgIH07XG59XG5leHBvcnRzLkJlbG9uZ3NUbyA9IEJlbG9uZ3NUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZvcmVpZ25LZXlzID0gZXhwb3J0cy5hZGRGb3JlaWduS2V5ID0gZXhwb3J0cy5nZXRGb3JlaWduS2V5T3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEZPUkVJR05fS0VZU19LRVkgPSAnc2VxdWVsaXplOmZvcmVpZ25LZXlzJztcbmZ1bmN0aW9uIGdldEZvcmVpZ25LZXlPcHRpb25zKHJlbGF0ZWRDbGFzcywgY2xhc3NXaXRoRm9yZWlnbktleSwgZm9yZWlnbktleSkge1xuICAgIGxldCBmb3JlaWduS2V5T3B0aW9ucyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZm9yZWlnbktleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yZWlnbktleU9wdGlvbnMubmFtZSA9IGZvcmVpZ25LZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmVpZ25LZXkgJiYgdHlwZW9mIGZvcmVpZ25LZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvcmVpZ25LZXlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZm9yZWlnbktleSk7XG4gICAgfVxuICAgIGlmICghZm9yZWlnbktleU9wdGlvbnMubmFtZSAmJiBjbGFzc1dpdGhGb3JlaWduS2V5KSB7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gZ2V0Rm9yZWlnbktleXMoY2xhc3NXaXRoRm9yZWlnbktleS5wcm90b3R5cGUpIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmb3JlaWduS2V5cykge1xuICAgICAgICAgICAgaWYgKGtleS5yZWxhdGVkQ2xhc3NHZXR0ZXIoKSA9PT0gcmVsYXRlZENsYXNzIHx8XG4gICAgICAgICAgICAgICAgcmVsYXRlZENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIGtleS5yZWxhdGVkQ2xhc3NHZXR0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGZvcmVpZ25LZXlPcHRpb25zLm5hbWUgPSBrZXkuZm9yZWlnbktleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvcmVpZ25LZXlPcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JlaWduIGtleSBmb3IgXCIke3JlbGF0ZWRDbGFzcy5uYW1lfVwiIGlzIG1pc3NpbmcgYCArXG4gICAgICAgICAgICBgb24gXCIke2NsYXNzV2l0aEZvcmVpZ25LZXkubmFtZX1cIi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcmVpZ25LZXlPcHRpb25zO1xufVxuZXhwb3J0cy5nZXRGb3JlaWduS2V5T3B0aW9ucyA9IGdldEZvcmVpZ25LZXlPcHRpb25zO1xuLyoqXG4gKiBBZGRzIGZvcmVpZ24ga2V5IG1ldGEgZGF0YSBmb3Igc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGFkZEZvcmVpZ25LZXkodGFyZ2V0LCByZWxhdGVkQ2xhc3NHZXR0ZXIsIGZvcmVpZ25LZXkpIHtcbiAgICBsZXQgZm9yZWlnbktleXMgPSBnZXRGb3JlaWduS2V5cyh0YXJnZXQpO1xuICAgIGlmICghZm9yZWlnbktleXMpIHtcbiAgICAgICAgZm9yZWlnbktleXMgPSBbXTtcbiAgICB9XG4gICAgZm9yZWlnbktleXMucHVzaCh7XG4gICAgICAgIHJlbGF0ZWRDbGFzc0dldHRlcixcbiAgICAgICAgZm9yZWlnbktleSxcbiAgICB9KTtcbiAgICBzZXRGb3JlaWduS2V5cyh0YXJnZXQsIGZvcmVpZ25LZXlzKTtcbn1cbmV4cG9ydHMuYWRkRm9yZWlnbktleSA9IGFkZEZvcmVpZ25LZXk7XG4vKipcbiAqIFJldHVybnMgZm9yZWlnbiBrZXkgbWV0YSBkYXRhIGZyb20gc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGdldEZvcmVpZ25LZXlzKHRhcmdldCkge1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShGT1JFSUdOX0tFWVNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChmb3JlaWduS2V5cykge1xuICAgICAgICByZXR1cm4gWy4uLmZvcmVpZ25LZXlzXTtcbiAgICB9XG59XG5leHBvcnRzLmdldEZvcmVpZ25LZXlzID0gZ2V0Rm9yZWlnbktleXM7XG4vKipcbiAqIFNldHMgZm9yZWlnbiBrZXkgbWV0YSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHNldEZvcmVpZ25LZXlzKHRhcmdldCwgZm9yZWlnbktleXMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKEZPUkVJR05fS0VZU19LRVksIGZvcmVpZ25LZXlzLCB0YXJnZXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yZWlnbi1rZXktc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm9yZWlnbktleSA9IHZvaWQgMDtcbmNvbnN0IGZvcmVpZ25fa2V5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2ZvcmVpZ24ta2V5LXNlcnZpY2VcIik7XG5mdW5jdGlvbiBGb3JlaWduS2V5KHJlbGF0ZWRDbGFzc0dldHRlcikge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgZm9yZWlnbl9rZXlfc2VydmljZV8xLmFkZEZvcmVpZ25LZXkodGFyZ2V0LCByZWxhdGVkQ2xhc3NHZXR0ZXIsIHByb3BlcnR5TmFtZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuRm9yZWlnbktleSA9IEZvcmVpZ25LZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JlaWduLWtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzQXNzb2NpYXRpb24gPSB2b2lkIDA7XG5jb25zdCBiYXNlX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Jhc2UtYXNzb2NpYXRpb25cIik7XG5jb25zdCBmb3JlaWduX2tleV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vZm9yZWlnbi1rZXkvZm9yZWlnbi1rZXktc2VydmljZVwiKTtcbmNsYXNzIEhhc0Fzc29jaWF0aW9uIGV4dGVuZHMgYmFzZV9hc3NvY2lhdGlvbl8xLkJhc2VBc3NvY2lhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXNzb2NpYXRlZENsYXNzR2V0dGVyLCBvcHRpb25zLCBhc3NvY2lhdGlvbikge1xuICAgICAgICBzdXBlcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9uID0gYXNzb2NpYXRpb247XG4gICAgfVxuICAgIGdldEFzc29jaWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NvY2lhdGlvbjtcbiAgICB9XG4gICAgZ2V0U2VxdWVsaXplT3B0aW9ucyhtb2RlbCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRlZENsYXNzID0gdGhpcy5nZXRBc3NvY2lhdGVkQ2xhc3MoKTtcbiAgICAgICAgb3B0aW9ucy5mb3JlaWduS2V5ID0gZm9yZWlnbl9rZXlfc2VydmljZV8xLmdldEZvcmVpZ25LZXlPcHRpb25zKG1vZGVsLCBhc3NvY2lhdGVkQ2xhc3MsIG9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzQXNzb2NpYXRpb24gPSBIYXNBc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1hc3NvY2lhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzTWFueSA9IHZvaWQgMDtcbmNvbnN0IGhhc19hc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4vaGFzLWFzc29jaWF0aW9uXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvbi1zZXJ2aWNlXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYXNzb2NpYXRpb25cIik7XG5mdW5jdGlvbiBIYXNNYW55KGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9uc09yRm9yZWlnbktleSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFzc29jaWF0aW9uX3NlcnZpY2VfMS5nZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyhvcHRpb25zT3JGb3JlaWduS2V5KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFzKVxuICAgICAgICAgICAgb3B0aW9ucy5hcyA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgYXNzb2NpYXRpb25fc2VydmljZV8xLmFkZEFzc29jaWF0aW9uKHRhcmdldCwgbmV3IGhhc19hc3NvY2lhdGlvbl8xLkhhc0Fzc29jaWF0aW9uKGFzc29jaWF0ZWRDbGFzc0dldHRlciwgb3B0aW9ucywgYXNzb2NpYXRpb25fMS5Bc3NvY2lhdGlvbi5IYXNNYW55KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuSGFzTWFueSA9IEhhc01hbnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtbWFueS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzT25lID0gdm9pZCAwO1xuY29uc3QgaGFzX2Fzc29jaWF0aW9uXzEgPSByZXF1aXJlKFwiLi9oYXMtYXNzb2NpYXRpb25cIik7XG5jb25zdCBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Fzc29jaWF0aW9uLXNlcnZpY2VcIik7XG5jb25zdCBhc3NvY2lhdGlvbl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9hc3NvY2lhdGlvblwiKTtcbmZ1bmN0aW9uIEhhc09uZShhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnNPckZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NvY2lhdGlvbl9zZXJ2aWNlXzEuZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMob3B0aW9uc09yRm9yZWlnbktleSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcylcbiAgICAgICAgICAgIG9wdGlvbnMuYXMgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIGFzc29jaWF0aW9uX3NlcnZpY2VfMS5hZGRBc3NvY2lhdGlvbih0YXJnZXQsIG5ldyBoYXNfYXNzb2NpYXRpb25fMS5IYXNBc3NvY2lhdGlvbihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMsIGFzc29jaWF0aW9uXzEuQXNzb2NpYXRpb24uSGFzT25lKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuSGFzT25lID0gSGFzT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLW9uZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXNzb2NpYXRpb25zQnlSZWxhdGlvbiA9IGV4cG9ydHMuc2V0QXNzb2NpYXRpb25zID0gZXhwb3J0cy5nZXRBc3NvY2lhdGlvbnMgPSBleHBvcnRzLmFkZEFzc29jaWF0aW9uID0gZXhwb3J0cy5nZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucyA9IHZvaWQgMDtcbnJlcXVpcmUoXCJyZWZsZWN0LW1ldGFkYXRhXCIpO1xuY29uc3QgQVNTT0NJQVRJT05TX0tFWSA9ICdzZXF1ZWxpemU6YXNzb2NpYXRpb25zJztcbi8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aFxuZnVuY3Rpb24gZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMob3B0aW9uc09yRm9yZWlnbktleSkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnNPckZvcmVpZ25LZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JGb3JlaWduS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucy5mb3JlaWduS2V5ID0gb3B0aW9uc09yRm9yZWlnbktleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zT3JGb3JlaWduS2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMuZ2V0UHJlcGFyZWRBc3NvY2lhdGlvbk9wdGlvbnMgPSBnZXRQcmVwYXJlZEFzc29jaWF0aW9uT3B0aW9ucztcbi8qKlxuICogU3RvcmVzIGFzc29jaWF0aW9uIG1ldGEgZGF0YSBmb3Igc3BlY2lmaWVkIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGFkZEFzc29jaWF0aW9uKHRhcmdldCwgYXNzb2NpYXRpb24pIHtcbiAgICBsZXQgYXNzb2NpYXRpb25zID0gZ2V0QXNzb2NpYXRpb25zKHRhcmdldCk7XG4gICAgaWYgKCFhc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgYXNzb2NpYXRpb25zID0gW107XG4gICAgfVxuICAgIGFzc29jaWF0aW9ucy5wdXNoKGFzc29jaWF0aW9uKTtcbiAgICBzZXRBc3NvY2lhdGlvbnModGFyZ2V0LCBhc3NvY2lhdGlvbnMpO1xufVxuZXhwb3J0cy5hZGRBc3NvY2lhdGlvbiA9IGFkZEFzc29jaWF0aW9uO1xuLyoqXG4gKiBSZXR1cm5zIGFzc29jaWF0aW9uIG1ldGEgZGF0YSBmcm9tIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRBc3NvY2lhdGlvbnModGFyZ2V0KSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb25zID0gUmVmbGVjdC5nZXRNZXRhZGF0YShBU1NPQ0lBVElPTlNfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChhc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5hc3NvY2lhdGlvbnNdO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0QXNzb2NpYXRpb25zID0gZ2V0QXNzb2NpYXRpb25zO1xuZnVuY3Rpb24gc2V0QXNzb2NpYXRpb25zKHRhcmdldCwgYXNzb2NpYXRpb25zKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShBU1NPQ0lBVElPTlNfS0VZLCBhc3NvY2lhdGlvbnMsIHRhcmdldCk7XG59XG5leHBvcnRzLnNldEFzc29jaWF0aW9ucyA9IHNldEFzc29jaWF0aW9ucztcbmZ1bmN0aW9uIGdldEFzc29jaWF0aW9uc0J5UmVsYXRpb24odGFyZ2V0LCByZWxhdGVkQ2xhc3MpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSBnZXRBc3NvY2lhdGlvbnModGFyZ2V0KTtcbiAgICByZXR1cm4gKGFzc29jaWF0aW9ucyB8fCBbXSkuZmlsdGVyKGFzc29jaWF0aW9uID0+IHtcbiAgICAgICAgY29uc3QgX3JlbGF0ZWRDbGFzcyA9IGFzc29jaWF0aW9uLmdldEFzc29jaWF0ZWRDbGFzcygpO1xuICAgICAgICByZXR1cm4gKF9yZWxhdGVkQ2xhc3MucHJvdG90eXBlID09PSByZWxhdGVkQ2xhc3MucHJvdG90eXBlIHx8XG4gICAgICAgICAgICByZWxhdGVkQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgX3JlbGF0ZWRDbGFzcyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldEFzc29jaWF0aW9uc0J5UmVsYXRpb24gPSBnZXRBc3NvY2lhdGlvbnNCeVJlbGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24tc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNzb2NpYXRpb24gPSB2b2lkIDA7XG52YXIgQXNzb2NpYXRpb247XG4oZnVuY3Rpb24gKEFzc29jaWF0aW9uKSB7XG4gICAgQXNzb2NpYXRpb25bXCJCZWxvbmdzVG9NYW55XCJdID0gXCJiZWxvbmdzVG9NYW55XCI7XG4gICAgQXNzb2NpYXRpb25bXCJCZWxvbmdzVG9cIl0gPSBcImJlbG9uZ3NUb1wiO1xuICAgIEFzc29jaWF0aW9uW1wiSGFzTWFueVwiXSA9IFwiaGFzTWFueVwiO1xuICAgIEFzc29jaWF0aW9uW1wiSGFzT25lXCJdID0gXCJoYXNPbmVcIjtcbn0pKEFzc29jaWF0aW9uID0gZXhwb3J0cy5Bc3NvY2lhdGlvbiB8fCAoZXhwb3J0cy5Bc3NvY2lhdGlvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUFzc29jaWF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQmFzZUFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3NvY2lhdGVkQ2xhc3NHZXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGVkQ2xhc3NHZXR0ZXIgPSBhc3NvY2lhdGVkQ2xhc3NHZXR0ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldEFzc29jaWF0ZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzb2NpYXRlZENsYXNzR2V0dGVyKCk7XG4gICAgfVxuICAgIGdldEFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFzc29jaWF0aW9uID0gQmFzZUFzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1hc3NvY2lhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaW9uLWFzc29jaWF0aW9uLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdWdoLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQnVsa0NyZWF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQnVsa0NyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckJ1bGtDcmVhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJCdWxrQ3JlYXRlID0gQWZ0ZXJCdWxrQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItYnVsay1jcmVhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQnVsa0Rlc3Ryb3kgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckJ1bGtEZXN0cm95KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQnVsa0Rlc3Ryb3knLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJCdWxrRGVzdHJveSA9IEFmdGVyQnVsa0Rlc3Ryb3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1idWxrLWRlc3Ryb3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQnVsa1Jlc3RvcmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckJ1bGtSZXN0b3JlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQnVsa1Jlc3RvcmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJCdWxrUmVzdG9yZSA9IEFmdGVyQnVsa1Jlc3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1idWxrLXJlc3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQnVsa1N5bmMgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckJ1bGtTeW5jKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQnVsa1N5bmMnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJCdWxrU3luYyA9IEFmdGVyQnVsa1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1idWxrLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyQnVsa1VwZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQnVsa1VwZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckJ1bGtVcGRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJCdWxrVXBkYXRlID0gQWZ0ZXJCdWxrVXBkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItYnVsay11cGRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUJ1bGtDcmVhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVCdWxrQ3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUJ1bGtDcmVhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQnVsa0NyZWF0ZSA9IEJlZm9yZUJ1bGtDcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtYnVsay1jcmVhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUJ1bGtEZXN0cm95ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQnVsa0Rlc3Ryb3koLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQnVsa0Rlc3Ryb3knLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQnVsa0Rlc3Ryb3kgPSBCZWZvcmVCdWxrRGVzdHJveTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1idWxrLWRlc3Ryb3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUJ1bGtSZXN0b3JlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQnVsa1Jlc3RvcmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQnVsa1Jlc3RvcmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQnVsa1Jlc3RvcmUgPSBCZWZvcmVCdWxrUmVzdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1idWxrLXJlc3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUJ1bGtTeW5jID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlQnVsa1N5bmMoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQnVsa1N5bmMnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQnVsa1N5bmMgPSBCZWZvcmVCdWxrU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1idWxrLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUJ1bGtVcGRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVCdWxrVXBkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUJ1bGtVcGRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQnVsa1VwZGF0ZSA9IEJlZm9yZUJ1bGtVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtYnVsay11cGRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldEhvb2tzID0gZXhwb3J0cy5nZXRIb29rcyA9IGV4cG9ydHMuYWRkSG9vayA9IGV4cG9ydHMuaW1wbGVtZW50SG9va0RlY29yYXRvciA9IGV4cG9ydHMuaW5zdGFsbEhvb2tzID0gdm9pZCAwO1xucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XG5jb25zdCBIT09LU19LRVkgPSAnc2VxdWVsaXplOmhvb2tzJztcbi8qKlxuICogSW5zdGFsbHMgaG9va3Mgb24gdGhlIHNwZWNpZmllZCBtb2RlbHNcbiAqL1xuZnVuY3Rpb24gaW5zdGFsbEhvb2tzKG1vZGVscykge1xuICAgIG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcbiAgICAgICAgY29uc3QgaG9va3MgPSBnZXRIb29rcyhtb2RlbCk7XG4gICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgaG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsSG9vayhtb2RlbCwgaG9vayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5pbnN0YWxsSG9va3MgPSBpbnN0YWxsSG9va3M7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGZvciBob29rIGRlY29yYXRvciBmdW5jdGlvbnMuIFRoZXNlIGFyZSBwb2x5bW9ycGhpYy4gV2hlblxuICogY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQgKElIb29rT3B0aW9ucykgdGhleSByZXR1cm4gYSBkZWNvcmF0b3JcbiAqIGZhY3RvcnkgZnVuY3Rpb24uIFdoZW4gY2FsbGVkIHdpdGggbXVsdGlwbGUgYXJndW1lbnRzLCB0aGV5IGFkZCB0aGUgaG9va1xuICogdG8gdGhlIG1vZGVs4oCZcyBtZXRhZGF0YS5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50SG9va0RlY29yYXRvcihob29rVHlwZSwgYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXTtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYWRkSG9vayh0YXJnZXQsIGhvb2tUeXBlLCBwcm9wZXJ0eU5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gYXJnc1sxXTtcbiAgICAgICAgYWRkSG9vayh0YXJnZXQsIGhvb2tUeXBlLCBwcm9wZXJ0eU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW1wbGVtZW50SG9va0RlY29yYXRvciA9IGltcGxlbWVudEhvb2tEZWNvcmF0b3I7XG4vKipcbiAqIEFkZHMgaG9vayBtZXRhIGRhdGEgZm9yIHNwZWNpZmllZCBtb2RlbFxuICogQHRocm93cyBpZiBhcHBsaWVkIHRvIGEgbm9uLXN0YXRpYyBtZXRob2RcbiAqIEB0aHJvd3MgaWYgdGhlIGhvb2sgbWV0aG9kIG5hbWUgaXMgcmVzZXJ2ZWRcbiAqL1xuZnVuY3Rpb24gYWRkSG9vayh0YXJnZXQsIGhvb2tUeXBlLCBtZXRob2ROYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvb2sgbWV0aG9kICcke21ldGhvZE5hbWV9JyBpcyBub3QgYSBzdGF0aWMgbWV0aG9kLiBgICtcbiAgICAgICAgICAgIGBPbmx5IHN0YXRpYyBtZXRob2RzIGNhbiBiZSB1c2VkIGZvciBob29rc2ApO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGhvb2sgbmFtZSBkb2VzbuKAmXQgY29uZmxpY3Qgd2l0aCBTZXF1ZWxpemXigJlzIGV4aXN0aW5nIG1ldGhvZHNcbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gaG9va1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb29rIG1ldGhvZCBjYW5ub3QgYmUgbmFtZWQgJyR7bWV0aG9kTmFtZX0nLiBUaGF0IG5hbWUgaXMgYCArXG4gICAgICAgICAgICBgcmVzZXJ2ZWQgYnkgU2VxdWVsaXplYCk7XG4gICAgfVxuICAgIGNvbnN0IGhvb2tzID0gZ2V0SG9va3ModGFyZ2V0KSB8fCBbXTtcbiAgICBob29rcy5wdXNoKHtcbiAgICAgICAgaG9va1R5cGUsXG4gICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICBzZXRIb29rcyh0YXJnZXQsIGhvb2tzKTtcbn1cbmV4cG9ydHMuYWRkSG9vayA9IGFkZEhvb2s7XG4vKipcbiAqIEluc3RhbGwgYSBob29rXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxIb29rKG1vZGVsLCBob29rKSB7XG4gICAgaWYgKGhvb2sub3B0aW9ucyAmJiBob29rLm9wdGlvbnMubmFtZSkge1xuICAgICAgICBtb2RlbC5hZGRIb29rKGhvb2suaG9va1R5cGUsIGhvb2sub3B0aW9ucy5uYW1lLCBtb2RlbFtob29rLm1ldGhvZE5hbWVdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb2RlbC5hZGRIb29rKGhvb2suaG9va1R5cGUsIG1vZGVsW2hvb2subWV0aG9kTmFtZV0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGhvb2tzIG1ldGEgZGF0YSBmcm9tIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRIb29rcyh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoSE9PS1NfS0VZLCB0YXJnZXQpO1xuICAgIGlmIChob29rcykge1xuICAgICAgICByZXR1cm4gWy4uLmhvb2tzXTtcbiAgICB9XG59XG5leHBvcnRzLmdldEhvb2tzID0gZ2V0SG9va3M7XG4vKipcbiAqIFNhdmVzIGhvb2tzIG1ldGEgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBjbGFzc1xuICovXG5mdW5jdGlvbiBzZXRIb29rcyh0YXJnZXQsIGhvb2tzKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShIT09LU19LRVksIGhvb2tzLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRIb29rcyA9IHNldEhvb2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3Mtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdGlvbkZhaWxlZCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBWYWxpZGF0aW9uRmFpbGVkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ3ZhbGlkYXRpb25GYWlsZWQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkZhaWxlZCA9IFZhbGlkYXRpb25GYWlsZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLWZhaWxlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJDb25uZWN0ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJDb25uZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQ29ubmVjdCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckNvbm5lY3QgPSBBZnRlckNvbm5lY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1jb25uZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckNyZWF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyQ3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyQ3JlYXRlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyQ3JlYXRlID0gQWZ0ZXJDcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1jcmVhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyRGVmaW5lID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJEZWZpbmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJEZWZpbmUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJEZWZpbmUgPSBBZnRlckRlZmluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWRlZmluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJEZXN0cm95ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJEZXN0cm95KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyRGVzdHJveScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlckRlc3Ryb3kgPSBBZnRlckRlc3Ryb3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1kZXN0cm95LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlckZpbmQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlckZpbmQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJGaW5kJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyRmluZCA9IEFmdGVyRmluZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLWZpbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVySW5pdCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVySW5pdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlckluaXQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJJbml0ID0gQWZ0ZXJJbml0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItaW5pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJSZXN0b3JlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWZ0ZXJSZXN0b3JlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyUmVzdG9yZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclJlc3RvcmUgPSBBZnRlclJlc3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci1yZXN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclNhdmUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclNhdmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYWZ0ZXJTYXZlJywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyU2F2ZSA9IEFmdGVyU2F2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXNhdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyU3luYyA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyU3luYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclN5bmMnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJTeW5jID0gQWZ0ZXJTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWZ0ZXJVcGRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclVwZGF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdhZnRlclVwZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5BZnRlclVwZGF0ZSA9IEFmdGVyVXBkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItdXBkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZnRlclVwc2VydCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEFmdGVyVXBzZXJ0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyVXBzZXJ0JywgYXJncyk7XG59XG5leHBvcnRzLkFmdGVyVXBzZXJ0ID0gQWZ0ZXJVcHNlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci11cHNlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFmdGVyVmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBBZnRlclZhbGlkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2FmdGVyVmFsaWRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQWZ0ZXJWYWxpZGF0ZSA9IEFmdGVyVmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZnRlci12YWxpZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlQ29ubmVjdCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUNvbm5lY3QoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlQ29ubmVjdCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVDb25uZWN0ID0gQmVmb3JlQ29ubmVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1jb25uZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVDb3VudCA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUNvdW50KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUNvdW50JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUNvdW50ID0gQmVmb3JlQ291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtY291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUNyZWF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZUNyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVDcmVhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlQ3JlYXRlID0gQmVmb3JlQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlRGVmaW5lID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlRGVmaW5lKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZURlZmluZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVEZWZpbmUgPSBCZWZvcmVEZWZpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtZGVmaW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVEZXN0cm95ID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlRGVzdHJveSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVEZXN0cm95JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZURlc3Ryb3kgPSBCZWZvcmVEZXN0cm95O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWRlc3Ryb3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGwgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGwnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbCA9IEJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtZmluZC1hZnRlci1leHBhbmQtaW5jbHVkZS1hbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUZpbmRBZnRlck9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVGaW5kQWZ0ZXJPcHRpb25zKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUZpbmRBZnRlck9wdGlvbnMnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlRmluZEFmdGVyT3B0aW9ucyA9IEJlZm9yZUZpbmRBZnRlck9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtZmluZC1hZnRlci1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVGaW5kID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlRmluZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVGaW5kJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZUZpbmQgPSBCZWZvcmVGaW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLWZpbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZUluaXQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVJbml0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZUluaXQnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlSW5pdCA9IEJlZm9yZUluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtaW5pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlUmVzdG9yZSA9IHZvaWQgMDtcbmNvbnN0IGhvb2tzX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvaG9va3Mtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEJlZm9yZVJlc3RvcmUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlUmVzdG9yZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVSZXN0b3JlID0gQmVmb3JlUmVzdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS1yZXN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVTYXZlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlU2F2ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGhvb2tzX3NlcnZpY2VfMS5pbXBsZW1lbnRIb29rRGVjb3JhdG9yKCdiZWZvcmVTYXZlJywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVNhdmUgPSBCZWZvcmVTYXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVmb3JlLXNhdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVN5bmMgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVTeW5jKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVN5bmMnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlU3luYyA9IEJlZm9yZVN5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVmb3JlVXBkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlVXBkYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gaG9va3Nfc2VydmljZV8xLmltcGxlbWVudEhvb2tEZWNvcmF0b3IoJ2JlZm9yZVVwZGF0ZScsIGFyZ3MpO1xufVxuZXhwb3J0cy5CZWZvcmVVcGRhdGUgPSBCZWZvcmVVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWZvcmUtdXBkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWZvcmVVcHNlcnQgPSB2b2lkIDA7XG5jb25zdCBob29rc19zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2hvb2tzLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBCZWZvcmVVcHNlcnQoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlVXBzZXJ0JywgYXJncyk7XG59XG5leHBvcnRzLkJlZm9yZVVwc2VydCA9IEJlZm9yZVVwc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS11cHNlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZm9yZVZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQmVmb3JlVmFsaWRhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBob29rc19zZXJ2aWNlXzEuaW1wbGVtZW50SG9va0RlY29yYXRvcignYmVmb3JlVmFsaWRhdGUnLCBhcmdzKTtcbn1cbmV4cG9ydHMuQmVmb3JlVmFsaWRhdGUgPSBCZWZvcmVWYWxpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlZm9yZS12YWxpZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvL2JlbG9uZ3MtdG9cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvL2JlbG9uZ3MtdG8tYXNzb2NpYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnkvYmVsb25ncy10by1tYW55XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55L2JlbG9uZ3MtdG8tbWFueS1hc3NvY2lhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS9iZWxvbmdzLXRvLW1hbnktb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2ZvcmVpZ24ta2V5L2ZvcmVpZ24ta2V5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzL2hhcy1hc3NvY2lhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy9oYXMtb25lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzL2hhcy1tYW55XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvc2hhcmVkL2Fzc29jaWF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvc2hhcmVkL2Jhc2UtYXNzb2NpYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWFjdGlvbi1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvc2hhcmVkL3VuaW9uLWFzc29jaWF0aW9uLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL3Rocm91Z2gvdGhyb3VnaC1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstY3JlYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstZGVzdHJveVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3MvYnVsay9hZnRlci9hZnRlci1idWxrLXJlc3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYWZ0ZXIvYWZ0ZXItYnVsay1zeW5jXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2FmdGVyL2FmdGVyLWJ1bGstdXBkYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9idWxrL2JlZm9yZS9iZWZvcmUtYnVsay1jcmVhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLWRlc3Ryb3lcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXJlc3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXN5bmNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL2J1bGsvYmVmb3JlL2JlZm9yZS1idWxrLXVwZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWNvbm5lY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1jcmVhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1kZWZpbmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1kZXN0cm95XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItZmluZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLWluaXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci1yZXN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYWZ0ZXIvYWZ0ZXItc2F2ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2FmdGVyL2FmdGVyLXN5bmNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci11cGRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci11cHNlcnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9hZnRlci9hZnRlci12YWxpZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY29ubmVjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtY291bnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLWNyZWF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZGVmaW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1kZXN0cm95XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1maW5kXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1maW5kLWFmdGVyLWV4cGFuZC1pbmNsdWRlLWFsbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtZmluZC1hZnRlci1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1pbml0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1yZXN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1zYXZlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS1zeW5jXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaW5nbGUvYmVmb3JlL2JlZm9yZS11cGRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NpbmdsZS9iZWZvcmUvYmVmb3JlLXVwc2VydFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9va3Mvc2luZ2xlL2JlZm9yZS9iZWZvcmUtdmFsaWRhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NoYXJlZC9ob29rLW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvb2tzL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ob29rcy9zaGFyZWQvdmFsaWRhdGlvbi1mYWlsZWRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy9hbGxvdy1udWxsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vY29sdW1uLW9wdGlvbnMvY29tbWVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL2NvbHVtbi1vcHRpb25zL2RlZmF1bHRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9jb2x1bW4tb3B0aW9ucy91bmlxdWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9wcmltYXJ5LWtleS9hdXRvLWluY3JlbWVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvY29sdW1uL3ByaW1hcnkta2V5L3ByaW1hcnkta2V5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy9jcmVhdGVkLWF0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy9kZWxldGVkLWF0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vdGltZXN0YW1wcy91cGRhdGVkLWF0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2NvbHVtbi9jb2x1bW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWNvdW50LW9wdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL21vZGVsL2Fzc29jaWF0aW9uL2Fzc29jaWF0aW9uLWdldC1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9tb2RlbC9tb2RlbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvc2hhcmVkL21vZGVsLWNsYXNzLWdldHRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWwvc2hhcmVkL21vZGVsLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL3RhYmxlL3RhYmxlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC90YWJsZS90YWJsZS1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9pbmRleC9jcmVhdGUtaW5kZXgtZGVjb3JhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbC9pbmRleC9pbmRleC1kZWNvcmF0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsL2luZGV4L2luZGV4LXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Njb3Blcy9kZWZhdWx0LXNjb3BlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY29wZXMvc2NvcGUtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NvcGVzL3Njb3BlLXNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Njb3Blcy9zY29wZS10YWJsZS1vcHRpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY29wZXMvc2NvcGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvZGF0YS10eXBlL2RhdGEtdHlwZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemUtb3B0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL3ZhbGlkYXRpb24tb25seS9kYi1kaWFsZWN0LWR1bW15XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXF1ZWxpemUvc2VxdWVsaXplL3NlcXVlbGl6ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL3NlcXVlbGl6ZS9zZXF1ZWxpemUtc2VydmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VxdWVsaXplL3JlcG9zaXRvcnkvcmVwb3NpdG9yeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9jb250YWluc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9lcXVhbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtYWZ0ZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtYWxwaGFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtYWxwaGFudW1lcmljXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWJlZm9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1jcmVkaXQtY2FyZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1kYXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWRlY2ltYWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtZW1haWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtZmxvYXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtaW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtaW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWlwXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWlwLXY0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWFycmF5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWlwLXY2XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLWxvd2VyY2FzZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy1udWxsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLW51bWVyaWNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vaXMtdXBwZXJjYXNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2lzLXVybFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9pcy11dWlkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL2xlbmd0aFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9tYXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbWluXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL25vdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9ub3QtY29udGFpbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vbm90LWVtcHR5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uL25vdC1pblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi9ub3QtbnVsbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi92YWxpZGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi92YWxpZGF0b3JcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZEF0dHJpYnV0ZU9wdGlvbnMgPSBleHBvcnRzLmFkZEF0dHJpYnV0ZSA9IGV4cG9ydHMuc2V0QXR0cmlidXRlcyA9IGV4cG9ydHMuZ2V0QXR0cmlidXRlcyA9IHZvaWQgMDtcbmNvbnN0IG9iamVjdF8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9vYmplY3RcIik7XG5jb25zdCBBVFRSSUJVVEVTX0tFWSA9ICdzZXF1ZWxpemU6YXR0cmlidXRlcyc7XG4vKipcbiAqIFJldHVybnMgbW9kZWwgYXR0cmlidXRlcyBmcm9tIGNsYXNzIGJ5IHJlc3RvcmluZyB0aGlzXG4gKiBpbmZvcm1hdGlvbiBmcm9tIHJlZmxlY3QgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyh0YXJnZXQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShBVFRSSUJVVEVTX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgICAgICAua2V5cyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLnJlZHVjZSgoY29weSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG5leHBvcnRzLmdldEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzO1xuLyoqXG4gKiBTZXRzIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyh0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKEFUVFJJQlVURVNfS0VZLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG4vKipcbiAqIEFkZHMgbW9kZWwgYXR0cmlidXRlIGJ5IHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGFuZFxuICogc2VxdWVsaXplIGF0dHJpYnV0ZSBvcHRpb25zIGFuZCBzdG9yZXMgdGhpcyBpbmZvcm1hdGlvblxuICogdGhyb3VnaCByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXModGFyZ2V0KTtcbiAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzW25hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgc2V0QXR0cmlidXRlcyh0YXJnZXQsIGF0dHJpYnV0ZXMpO1xufVxuZXhwb3J0cy5hZGRBdHRyaWJ1dGUgPSBhZGRBdHRyaWJ1dGU7XG4vKipcbiAqIEFkZHMgYXR0cmlidXRlIG9wdGlvbnMgZm9yIHNwZWNpZmljIGF0dHJpYnV0ZVxuICovXG5mdW5jdGlvbiBhZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXModGFyZ2V0KTtcbiAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgIWF0dHJpYnV0ZXNbcHJvcGVydHlOYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBDb2x1bW4gYW5ub3RhdGlvbiBpcyBtaXNzaW5nIGZvciBcIiR7cHJvcGVydHlOYW1lfVwiIG9mIGNsYXNzIFwiJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX1cImAgK1xuICAgICAgICAgICAgYCBvciBhbm5vdGF0aW9uIG9yZGVyIGlzIHdyb25nLmApO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0gPSBvYmplY3RfMS5kZWVwQXNzaWduKGF0dHJpYnV0ZXNbcHJvcGVydHlOYW1lXSwgb3B0aW9ucyk7XG4gICAgc2V0QXR0cmlidXRlcyh0YXJnZXQsIGF0dHJpYnV0ZXMpO1xufVxuZXhwb3J0cy5hZGRBdHRyaWJ1dGVPcHRpb25zID0gYWRkQXR0cmlidXRlT3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbGxvd051bGwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gQWxsb3dOdWxsKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgYWxsb3dOdWxsID0gYXJnc1swXTtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7IGFsbG93TnVsbCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGFyZ3NbMV07XG4gICAgICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgYWxsb3dOdWxsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWxsb3dOdWxsID0gQWxsb3dOdWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsb3ctbnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbWVudCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBjb21tZW50IHZhbHVlIGZvciB0aGUgYW5ub3RhdGVkIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIENvbW1lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgY29tbWVudDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuQ29tbWVudCA9IENvbW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBhbm5vdGF0ZWQgZmllbGRcbiAqL1xuZnVuY3Rpb24gRGVmYXVsdCh2YWx1ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLkRlZmF1bHQgPSBEZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pcXVlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmZ1bmN0aW9uIFVuaXF1ZSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFtvcHRpb25zXSA9IGFyZ3M7XG4gICAgICAgIHJldHVybiAoX3RhcmdldCwgX3Byb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgYW5ub3RhdGUoX3RhcmdldCwgX3Byb3BlcnR5TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IFt0YXJnZXQsIHByb3BlcnR5TmFtZV0gPSBhcmdzO1xuICAgIGFubm90YXRlKHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbn1cbmV4cG9ydHMuVW5pcXVlID0gVW5pcXVlO1xuZnVuY3Rpb24gYW5ub3RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIG9wdGlvbiA9IHRydWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdW5pcXVlOiBvcHRpb24sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbHVtbiA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbmNvbnN0IGRhdGFfdHlwZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2VxdWVsaXplL2RhdGEtdHlwZS9kYXRhLXR5cGUtc2VydmljZVwiKTtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmZ1bmN0aW9uIENvbHVtbiguLi5hcmdzKSB7XG4gICAgLy8gSW4gY2FzZSBvZiBubyBzcGVjaWZpZWQgb3B0aW9ucywgd2UgaW5mZXIgdGhlXG4gICAgLy8gc2VxdWVsaXplIGRhdGEgdHlwZSBieSB0aGUgdHlwZSBvZiB0aGUgcHJvcGVydHlcbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhcmdzWzFdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBhcmdzWzJdO1xuICAgICAgICBhbm5vdGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcbiAgICAgICAgYW5ub3RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5RGVzY3JpcHRvciwgYXJnc1swXSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuQ29sdW1uID0gQ29sdW1uO1xuZnVuY3Rpb24gYW5ub3RhdGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5RGVzY3JpcHRvciwgb3B0aW9uc09yRGF0YVR5cGUgPSB7fSkge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChkYXRhX3R5cGVfc2VydmljZV8xLmlzRGF0YVR5cGUob3B0aW9uc09yRGF0YVR5cGUpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0eXBlOiBvcHRpb25zT3JEYXRhVHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnNPckRhdGFUeXBlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IG1vZGVsX3NlcnZpY2VfMS5nZXRTZXF1ZWxpemVUeXBlQnlEZXNpZ25UeXBlKHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmdldCA9IHByb3BlcnR5RGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2V0ID0gcHJvcGVydHlEZXNjcmlwdG9yLnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2x1bW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF1dG9JbmNyZW1lbnQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBTZXRzIGF1dG8gaW5jcmVtZW50IHRydWUgZm9yIGFubm90YXRlZCBmaWVsZFxuICovXG5mdW5jdGlvbiBBdXRvSW5jcmVtZW50KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuQXV0b0luY3JlbWVudCA9IEF1dG9JbmNyZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvLWluY3JlbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpbWFyeUtleSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFNldHMgcHJpbWFyeSBrZXkgb3B0aW9uIHRydWUgZm9yIGFubm90YXRlZCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gUHJpbWFyeUtleSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICBwcmltYXJ5S2V5OiB0cnVlXG4gICAgfSk7XG59XG5leHBvcnRzLlByaW1hcnlLZXkgPSBQcmltYXJ5S2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpbWFyeS1rZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNyZWF0ZWRBdCA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmZ1bmN0aW9uIENyZWF0ZWRBdCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIG1vZGVsX3NlcnZpY2VfMS5hZGRPcHRpb25zKHRhcmdldCwge1xuICAgICAgICBjcmVhdGVkQXQ6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgdGltZXN0YW1wczogdHJ1ZVxuICAgIH0pO1xufVxuZXhwb3J0cy5DcmVhdGVkQXQgPSBDcmVhdGVkQXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVkLWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWxldGVkQXQgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBEZWxldGVkQXQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuYWRkT3B0aW9ucyh0YXJnZXQsIHtcbiAgICAgICAgZGVsZXRlZEF0OiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHRpbWVzdGFtcHM6IHRydWUsXG4gICAgICAgIHBhcmFub2lkOiB0cnVlXG4gICAgfSk7XG59XG5leHBvcnRzLkRlbGV0ZWRBdCA9IERlbGV0ZWRBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGV0ZWQtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVwZGF0ZWRBdCA9IHZvaWQgMDtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmZ1bmN0aW9uIFVwZGF0ZWRBdCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIG1vZGVsX3NlcnZpY2VfMS5hZGRPcHRpb25zKHRhcmdldCwge1xuICAgICAgICB1cGRhdGVkQXQ6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgdGltZXN0YW1wczogdHJ1ZVxuICAgIH0pO1xufVxuZXhwb3J0cy5VcGRhdGVkQXQgPSBVcGRhdGVkQXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVkLWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVJbmRleERlY29yYXRvciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2luZGV4LXNlcnZpY2VcIik7XG5mdW5jdGlvbiBjcmVhdGVJbmRleERlY29yYXRvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQgaW5kZXhJZDtcbiAgICByZXR1cm4gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBbdGFyZ2V0LCBwcm9wZXJ0eU5hbWVdID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkT3B0aW9ucyA9IHsgbmFtZTogcHJvcGVydHlOYW1lIH07XG4gICAgICAgICAgICBpbmRleElkID0gaW5kZXhfc2VydmljZV8xLmFkZEZpZWxkVG9JbmRleCh0YXJnZXQsIGZpZWxkT3B0aW9ucywgb3B0aW9ucywgaW5kZXhJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IHByb3BlcnR5TmFtZSB9LCBhcmdzWzBdKTtcbiAgICAgICAgICAgIGluZGV4SWQgPSBpbmRleF9zZXJ2aWNlXzEuYWRkRmllbGRUb0luZGV4KHRhcmdldCwgZmllbGRPcHRpb25zLCBvcHRpb25zLCBpbmRleElkKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5kZXhEZWNvcmF0b3IgPSBjcmVhdGVJbmRleERlY29yYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1pbmRleC1kZWNvcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFubm90YXRlTW9kZWxXaXRoSW5kZXggPSBleHBvcnRzLkluZGV4ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfc2VydmljZV8xID0gcmVxdWlyZShcIi4vaW5kZXgtc2VydmljZVwiKTtcbmZ1bmN0aW9uIEluZGV4KC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICBjb25zdCBbdGFyZ2V0LCBwcm9wZXJ0eU5hbWVdID0gYXJncztcbiAgICAgICAgYW5ub3RhdGVNb2RlbFdpdGhJbmRleCh0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBhbm5vdGF0ZU1vZGVsV2l0aEluZGV4KHRhcmdldCwgcHJvcGVydHlOYW1lLCBhcmdzWzBdKTtcbiAgICB9O1xufVxuZXhwb3J0cy5JbmRleCA9IEluZGV4O1xuZnVuY3Rpb24gYW5ub3RhdGVNb2RlbFdpdGhJbmRleCh0YXJnZXQsIHByb3BlcnR5TmFtZSwgb3B0aW9uc09yTmFtZSA9IHt9LCBpbmRleElkKSB7XG4gICAgbGV0IGluZGV4T3B0aW9ucztcbiAgICBsZXQgZmllbGRPcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZXhPcHRpb25zID0geyBuYW1lOiBvcHRpb25zT3JOYW1lIH07XG4gICAgICAgIGZpZWxkT3B0aW9ucyA9IHsgbmFtZTogcHJvcGVydHlOYW1lIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlbmd0aCwgb3JkZXIsIGNvbGxhdGUgfSA9IG9wdGlvbnNPck5hbWUsIHJlc3QgPSBfX3Jlc3Qob3B0aW9uc09yTmFtZSwgW1wibGVuZ3RoXCIsIFwib3JkZXJcIiwgXCJjb2xsYXRlXCJdKTtcbiAgICAgICAgaW5kZXhPcHRpb25zID0gcmVzdDtcbiAgICAgICAgZmllbGRPcHRpb25zID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgICAgICBjb2xsYXRlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhfc2VydmljZV8xLmFkZEZpZWxkVG9JbmRleCh0YXJnZXQsIGZpZWxkT3B0aW9ucywgaW5kZXhPcHRpb25zLCBpbmRleElkKTtcbn1cbmV4cG9ydHMuYW5ub3RhdGVNb2RlbFdpdGhJbmRleCA9IGFubm90YXRlTW9kZWxXaXRoSW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1kZWNvcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZEZpZWxkVG9JbmRleCA9IGV4cG9ydHMuc2V0SW5kZXhlcyA9IGV4cG9ydHMuZ2V0SW5kZXhlcyA9IHZvaWQgMDtcbnJlcXVpcmUoXCJyZWZsZWN0LW1ldGFkYXRhXCIpO1xuY29uc3QgSU5ERVhFU19LRVkgPSAnc2VxdWVsaXplOmluZGV4ZXMnO1xuLyoqXG4gKiBSZXR1cm5zIG1vZGVsIGluZGV4ZXMgZnJvbSBjbGFzcyBieSByZXN0b3JpbmcgdGhpc1xuICogaW5mb3JtYXRpb24gZnJvbSByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4ZXModGFyZ2V0KSB7XG4gICAgY29uc3QgeyBuYW1lZCA9IHt9LCB1bm5hbWVkID0gW10gfSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoSU5ERVhFU19LRVksIHRhcmdldCkgfHwge307XG4gICAgcmV0dXJuIHsgbmFtZWQ6IE9iamVjdC5hc3NpZ24oe30sIG5hbWVkKSwgdW5uYW1lZDogWy4uLnVubmFtZWRdIH07XG59XG5leHBvcnRzLmdldEluZGV4ZXMgPSBnZXRJbmRleGVzO1xuLyoqXG4gKiBTZXRzIGluZGV4ZXNcbiAqL1xuZnVuY3Rpb24gc2V0SW5kZXhlcyh0YXJnZXQsIGluZGV4ZXMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKElOREVYRVNfS0VZLCBpbmRleGVzLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5zZXRJbmRleGVzID0gc2V0SW5kZXhlcztcbi8qKlxuICogQWRkcyBmaWVsZCB0byBpbmRleCBieSBzZXF1ZWxpemUgaW5kZXggYW5kIGluZGV4IGZpZWxkIG9wdGlvbnMsXG4gKiBhbmQgc3RvcmVzIHRoaXMgaW5mb3JtYXRpb24gdGhyb3VnaCByZWZsZWN0IG1ldGFkYXRhLiBSZXR1cm5zIGluZGV4IElELlxuICovXG5mdW5jdGlvbiBhZGRGaWVsZFRvSW5kZXgodGFyZ2V0LCBmaWVsZE9wdGlvbnMsIGluZGV4T3B0aW9ucywgaW5kZXhJZCkge1xuICAgIGNvbnN0IGluZGV4ZXMgPSBnZXRJbmRleGVzKHRhcmdldCk7XG4gICAgY29uc3QgY2hvc2VuSWQgPSB0eXBlb2YgaW5kZXhJZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBpbmRleElkXG4gICAgICAgIDogaW5kZXhPcHRpb25zLm5hbWUgfHwgaW5kZXhlcy51bm5hbWVkLmxlbmd0aDtcbiAgICBjb25zdCBpbmRleFN0b3JlID0gdHlwZW9mIGNob3NlbklkID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGluZGV4ZXMubmFtZWRcbiAgICAgICAgOiBpbmRleGVzLnVubmFtZWQ7XG4gICAgaWYgKCFpbmRleFN0b3JlW2Nob3NlbklkXSlcbiAgICAgICAgaW5kZXhTdG9yZVtjaG9zZW5JZF0gPSBPYmplY3QuYXNzaWduKHt9LCBpbmRleE9wdGlvbnMpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5kZXhTdG9yZVtjaG9zZW5JZF07XG4gICAgaWYgKCFpbmRleC5maWVsZHMpXG4gICAgICAgIGluZGV4LmZpZWxkcyA9IFtdO1xuICAgIGluZGV4LmZpZWxkcy5wdXNoKGZpZWxkT3B0aW9ucyk7XG4gICAgc2V0SW5kZXhlcyh0YXJnZXQsIGluZGV4ZXMpO1xuICAgIHJldHVybiBjaG9zZW5JZDtcbn1cbmV4cG9ydHMuYWRkRmllbGRUb0luZGV4ID0gYWRkRmllbGRUb0luZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtc2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLWFjdGlvbi1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24tY291bnQtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLWdldC1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JTkZFUl9BTElBU19NQVAgPSBleHBvcnRzLk1vZGVsID0gdm9pZCAwO1xuY29uc3Qgc2VxdWVsaXplXzEgPSByZXF1aXJlKFwic2VxdWVsaXplXCIpO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL3N0cmluZ1wiKTtcbmNvbnN0IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL2FsaWFzLWluZmVyZW5jZS9hbGlhcy1pbmZlcmVuY2Utc2VydmljZVwiKTtcbmNvbnN0IG1vZGVsX25vdF9pbml0aWFsaXplZF9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3NoYXJlZC9tb2RlbC1ub3QtaW5pdGlhbGl6ZWQtZXJyb3JcIik7XG5jb25zdCBvYmplY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvb2JqZWN0XCIpO1xuY2xhc3MgTW9kZWwgZXh0ZW5kcyBzZXF1ZWxpemVfMS5Nb2RlbCB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghbmV3LnRhcmdldC5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbW9kZWxfbm90X2luaXRpYWxpemVkX2Vycm9yXzEuTW9kZWxOb3RJbml0aWFsaXplZEVycm9yKG5ldy50YXJnZXQsIGAke25ldy50YXJnZXQubmFtZX0gY2Fubm90IGJlIGluc3RhbnRpYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih2YWx1ZXMsIGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhvcHRpb25zLCBuZXcudGFyZ2V0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gc3VwZXIuaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyByZWxhdGlvbiBiZXR3ZWVuIHNwZWNpZmllZCBpbnN0YW5jZXMgYW5kIHNvdXJjZSBpbnN0YW5jZVxuICAgICAqL1xuICAgICRhZGQocHJvcGVydHlLZXksIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1snYWRkJyArIHN0cmluZ18xLmNhcGl0YWxpemUocHJvcGVydHlLZXkpXShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHJlbGF0aW9uIGJldHdlZW4gc3BlY2lmaWVkIGluc3RhbmNlcyBhbmQgc291cmNlIGluc3RhbmNlXG4gICAgICogKHJlcGxhY2VzIG9sZCByZWxhdGlvbnMpXG4gICAgICovXG4gICAgJHNldChwcm9wZXJ0eUtleSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydzZXQnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVsYXRlZCBpbnN0YW5jZSAoc3BlY2lmaWVkIGJ5IHByb3BlcnR5S2V5KSBvZiBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkZ2V0KHByb3BlcnR5S2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydnZXQnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgcmVsYXRlZCBpbnN0YW5jZXMgKHNwZWNpZmllZCBieSBwcm9wZXJ0eUtleSkgb2Ygc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJGNvdW50KHByb3BlcnR5S2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydjb3VudCcgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2VzIGFuZCByZWxhdGUgdGhlbSB0byBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkY3JlYXRlKHByb3BlcnR5S2V5LCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2NyZWF0ZScgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0odmFsdWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCBpbnN0YW5jZXMgaXMgcmVsYXRlZCB0byBzb3VyY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAkaGFzKHByb3BlcnR5S2V5LCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2hhcycgKyBzdHJpbmdfMS5jYXBpdGFsaXplKHByb3BlcnR5S2V5KV0oaW5zdGFuY2VzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBzcGVjaWZpZWQgaW5zdGFuY2VzIGZyb20gc291cmNlIGluc3RhbmNlXG4gICAgICovXG4gICAgJHJlbW92ZShwcm9wZXJ0eUtleSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydyZW1vdmUnICsgc3RyaW5nXzEuY2FwaXRhbGl6ZShwcm9wZXJ0eUtleSldKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJlbG9hZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZWxvYWQoYWxpYXNfaW5mZXJlbmNlX3NlcnZpY2VfMS5pbmZlckFsaWFzKG9wdGlvbnMsIHRoaXMpKTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVsID0gTW9kZWw7XG5Nb2RlbC5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4vKipcbiAqIEluZGljYXRlcyB3aGljaCBzdGF0aWMgbWV0aG9kcyBvZiBNb2RlbCBoYXMgdG8gYmUgcHJveGllZCxcbiAqIHRvIHByZXBhcmUgaW5jbHVkZSBvcHRpb24gdG8gYXV0b21hdGljYWxseSByZXNvbHZlIGFsaWFzO1xuICogVGhlIGluZGV4IHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBvcHRpb25zIG9mIHRoZVxuICogY29ycmVzcG9uZGluZyBtZXRob2QgcGFyYW1ldGVyXG4gKi9cbmV4cG9ydHMuSU5GRVJfQUxJQVNfTUFQID0ge1xuICAgIGJ1bGtCdWlsZDogMSxcbiAgICBidWlsZDogMSxcbiAgICBjcmVhdGU6IDEsXG4gICAgYWdncmVnYXRlOiAyLFxuICAgIGFsbDogMCxcbiAgICBmaW5kOiAwLFxuICAgIGZpbmRBbGw6IDAsXG4gICAgZmluZEFuZENvdW50OiAwLFxuICAgIGZpbmRBbmRDb3VudEFsbDogMCxcbiAgICBmaW5kQnlJZDogMSxcbiAgICBmaW5kQnlQcmltYXJ5OiAxLFxuICAgIGZpbmRDcmVhdGVGaW5kOiAwLFxuICAgIGZpbmRPbmU6IDAsXG4gICAgZmluZE9yQnVpbGQ6IDAsXG4gICAgZmluZE9yQ3JlYXRlOiAwLFxuICAgIGZpbmRPckluaXRpYWxpemU6IDAsXG4gICAgcmVsb2FkOiAwLFxufTtcbmNvbnN0IHN0YXRpY01vZGVsRnVuY3Rpb25Qcm9wZXJ0aWVzID0gb2JqZWN0XzEuZ2V0QWxsUHJvcGVydHlOYW1lcyhzZXF1ZWxpemVfMS5Nb2RlbClcbiAgICAuZmlsdGVyKGtleSA9PiAhaXNGb3JiaWRkZW5NZW1iZXIoa2V5KSAmJlxuICAgIGlzRnVuY3Rpb25NZW1iZXIoa2V5LCBzZXF1ZWxpemVfMS5Nb2RlbCkgJiZcbiAgICAhaXNQcml2YXRlTWVtYmVyKGtleSkpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbk1lbWJlcihwcm9wZXJ0eUtleSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0YXJnZXRbcHJvcGVydHlLZXldID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNGb3JiaWRkZW5NZW1iZXIocHJvcGVydHlLZXkpIHtcbiAgICBjb25zdCBGT1JCSURERU5fS0VZUyA9IFsnbmFtZScsICdjb25zdHJ1Y3RvcicsICdsZW5ndGgnLCAncHJvdG90eXBlJywgJ2NhbGxlcicsICdhcmd1bWVudHMnLCAnYXBwbHknLFxuICAgICAgICAncXVlcnlJbnRlcmZhY2UnLCAncXVlcnlHZW5lcmF0b3InLCAnaW5pdCcsICdyZXBsYWNlSG9va0FsaWFzZXMnLCAncmVmcmVzaEF0dHJpYnV0ZXMnLCAnaW5zcGVjdCddO1xuICAgIHJldHVybiBGT1JCSURERU5fS0VZUy5pbmRleE9mKHByb3BlcnR5S2V5KSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc1ByaXZhdGVNZW1iZXIocHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gKHByb3BlcnR5S2V5LmNoYXJBdCgwKSA9PT0gJ18nKTtcbn1cbmZ1bmN0aW9uIGFkZFRocm93Tm90SW5pdGlhbGl6ZWRQcm94eSgpIHtcbiAgICBzdGF0aWNNb2RlbEZ1bmN0aW9uUHJvcGVydGllc1xuICAgICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBzdXBlckZuID0gTW9kZWxba2V5XTtcbiAgICAgICAgTW9kZWxba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMS5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IodGhpcywgYE1lbWJlciBcIiR7a2V5fVwiIGNhbm5vdCBiZSBjYWxsZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VwZXJGbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkSW5mZXJBbGlhc092ZXJyaWRlcygpIHtcbiAgICBPYmplY3RcbiAgICAgICAgLmtleXMoZXhwb3J0cy5JTkZFUl9BTElBU19NQVApXG4gICAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkluZGV4ID0gZXhwb3J0cy5JTkZFUl9BTElBU19NQVBba2V5XTtcbiAgICAgICAgY29uc3Qgc3VwZXJGbiA9IE1vZGVsW2tleV07XG4gICAgICAgIE1vZGVsW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgYXJnc1tvcHRpb25JbmRleF0gPSBhbGlhc19pbmZlcmVuY2Vfc2VydmljZV8xLmluZmVyQWxpYXMoYXJnc1tvcHRpb25JbmRleF0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyRm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmFkZFRocm93Tm90SW5pdGlhbGl6ZWRQcm94eSgpO1xuYWRkSW5mZXJBbGlhc092ZXJyaWRlcygpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC1jbGFzcy1nZXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvciA9IHZvaWQgMDtcbmNsYXNzIE1vZGVsTm90SW5pdGlhbGl6ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbENsYXNzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgTW9kZWwgbm90IGluaXRpYWxpemVkOiAke2FkZGl0aW9uYWxNZXNzYWdlfSBcIiR7bW9kZWxDbGFzcy5uYW1lfVwiIGAgK1xuICAgICAgICAgICAgYG5lZWRzIHRvIGJlIGFkZGVkIHRvIGEgU2VxdWVsaXplIGluc3RhbmNlLmA7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IgPSBNb2RlbE5vdEluaXRpYWxpemVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC1ub3QtaW5pdGlhbGl6ZWQtZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVNb2RlbEdldHRlciA9IGV4cG9ydHMuZ2V0U2VxdWVsaXplVHlwZUJ5RGVzaWduVHlwZSA9IGV4cG9ydHMuYWRkT3B0aW9ucyA9IGV4cG9ydHMuc2V0T3B0aW9ucyA9IGV4cG9ydHMuZ2V0T3B0aW9ucyA9IGV4cG9ydHMuZ2V0TW9kZWxOYW1lID0gZXhwb3J0cy5zZXRNb2RlbE5hbWUgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF8xID0gcmVxdWlyZShcIi4uL21vZGVsL21vZGVsXCIpO1xuY29uc3QgZGF0YV90eXBlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZXF1ZWxpemUvZGF0YS10eXBlL2RhdGEtdHlwZS1zZXJ2aWNlXCIpO1xuY29uc3QgTU9ERUxfTkFNRV9LRVkgPSAnc2VxdWVsaXplOm1vZGVsTmFtZSc7XG5jb25zdCBPUFRJT05TX0tFWSA9ICdzZXF1ZWxpemU6b3B0aW9ucyc7XG4vKipcbiAqIFNldHMgbW9kZWwgbmFtZSBmcm9tIGNsYXNzIGJ5IHN0b3JpbmcgdGhpc1xuICogaW5mb3JtYXRpb24gdGhyb3VnaCByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVsTmFtZSh0YXJnZXQsIG1vZGVsTmFtZSkge1xuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoTU9ERUxfTkFNRV9LRVksIG1vZGVsTmFtZSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuc2V0TW9kZWxOYW1lID0gc2V0TW9kZWxOYW1lO1xuLyoqXG4gKiBSZXR1cm5zIG1vZGVsIG5hbWUgZnJvbSBjbGFzcyBieSByZXN0b3JpbmcgdGhpc1xuICogaW5mb3JtYXRpb24gZnJvbSByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVsTmFtZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRNZXRhZGF0YShNT0RFTF9OQU1FX0tFWSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuZ2V0TW9kZWxOYW1lID0gZ2V0TW9kZWxOYW1lO1xuLyoqXG4gKiBSZXR1cm5zIHNlcXVlbGl6ZSBkZWZpbmUgb3B0aW9ucyBmcm9tIGNsYXNzIHByb3RvdHlwZVxuICogYnkgcmVzdG9yaW5nIHRoaXMgaW5mb3JtYXRpb24gZnJvbSByZWZsZWN0IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldE9wdGlvbnModGFyZ2V0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoT1BUSU9OU19LRVksIHRhcmdldCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0T3B0aW9ucyA9IGdldE9wdGlvbnM7XG4vKipcbiAqIFNldHMgc2V1cWxpemUgZGVmaW5lIG9wdGlvbnMgdG8gY2xhc3MgcHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHNldE9wdGlvbnModGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShPUFRJT05TX0tFWSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHRhcmdldCk7XG59XG5leHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuLyoqXG4gKiBBZGRzIG9wdGlvbnMgYmUgYXNzaWduaW5nIG5ldyBvcHRpb25zIHRvIG9sZCBvbmVcbiAqL1xuZnVuY3Rpb24gYWRkT3B0aW9ucyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgX29wdGlvbnMgPSBnZXRPcHRpb25zKHRhcmdldCk7XG4gICAgaWYgKCFfb3B0aW9ucykge1xuICAgICAgICBfb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKHRhcmdldCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9vcHRpb25zKSwgb3B0aW9ucyksIHsgdmFsaWRhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9vcHRpb25zLnZhbGlkYXRlIHx8IHt9KSksIChvcHRpb25zLnZhbGlkYXRlIHx8IHt9KSkgfSkpO1xufVxuZXhwb3J0cy5hZGRPcHRpb25zID0gYWRkT3B0aW9ucztcbi8qKlxuICogTWFwcyBkZXNpZ24gdHlwZXMgdG8gc2VxdWVsaXplIGRhdGEgdHlwZXM7XG4gKiBAdGhyb3dzIGlmIGRlc2lnbiB0eXBlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IG1hcHBlZCB0b1xuICogYSBzZXF1ZWxpemUgZGF0YSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNlcXVlbGl6ZVR5cGVCeURlc2lnblR5cGUodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gUmVmbGVjdC5nZXRNZXRhZGF0YSgnZGVzaWduOnR5cGUnLCB0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBkYXRhX3R5cGVfc2VydmljZV8xLmluZmVyRGF0YVR5cGUodHlwZSk7XG4gICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgIHJldHVybiBkYXRhVHlwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTcGVjaWZpZWQgdHlwZSBvZiBwcm9wZXJ0eSAnJHtwcm9wZXJ0eU5hbWV9J1xuICAgICAgICAgICAgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYSBzZXF1ZWxpemUgZGF0YSB0eXBlLiBQbGVhc2VcbiAgICAgICAgICAgIGRlZmluZSB0aGUgZGF0YSB0eXBlIG1hbnVhbGx5YCk7XG59XG5leHBvcnRzLmdldFNlcXVlbGl6ZVR5cGVCeURlc2lnblR5cGUgPSBnZXRTZXF1ZWxpemVUeXBlQnlEZXNpZ25UeXBlO1xuLyoqXG4gKiBSZXNvbHZlcyBhbGwgbW9kZWwgZ2V0dGVycyBvZiBzcGVjaWZpZWQgb3B0aW9ucyBvYmplY3RcbiAqIHJlY3Vyc2l2ZWx5LlxuICogU28gdGhhdCB7bW9kZWw6ICgpID0+IFBlcnNvbn0gd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAqIHttb2RlbDogUGVyc29ufVxuICovXG5mdW5jdGlvbiByZXNvbHZlTW9kZWxHZXR0ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IG1heWJlTW9kZWxHZXR0ZXIgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IGlzTW9kZWwgPSB2YWx1ZSA9PiB2YWx1ZSAmJiB2YWx1ZS5wcm90b3R5cGUgJiYgdmFsdWUucHJvdG90eXBlIGluc3RhbmNlb2YgbW9kZWxfMS5Nb2RlbDtcbiAgICBjb25zdCBpc09wdGlvbk9iamVjdE9yQXJyYXkgPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIHJldHVybiBPYmplY3RcbiAgICAgICAgLmtleXMob3B0aW9ucylcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIGlmIChtYXliZU1vZGVsR2V0dGVyKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbWF5YmVNb2RlbCA9IHZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoaXNNb2RlbChtYXliZU1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gbWF5YmVNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09wdGlvbk9iamVjdE9yQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHJlc29sdmVNb2RlbEdldHRlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBBcnJheS5pc0FycmF5KG9wdGlvbnMpID8gWy4uLm9wdGlvbnNdIDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xufVxuZXhwb3J0cy5yZXNvbHZlTW9kZWxHZXR0ZXIgPSByZXNvbHZlTW9kZWxHZXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFibGUgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBUYWJsZShhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbm5vdGF0ZShhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGFyZyk7XG4gICAgICAgIHJldHVybiAodGFyZ2V0KSA9PiBhbm5vdGF0ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGFibGUgPSBUYWJsZTtcbmZ1bmN0aW9uIGFubm90YXRlKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbW9kZWxfc2VydmljZV8xLnNldE1vZGVsTmFtZSh0YXJnZXQucHJvdG90eXBlLCBvcHRpb25zLm1vZGVsTmFtZSB8fCB0YXJnZXQubmFtZSk7XG4gICAgbW9kZWxfc2VydmljZV8xLmFkZE9wdGlvbnModGFyZ2V0LnByb3RvdHlwZSwgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmYXVsdFNjb3BlID0gdm9pZCAwO1xuY29uc3Qgc2NvcGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2NvcGUtc2VydmljZVwiKTtcbi8qKlxuICogRGVjb3JhdG9yIGZvciBkZWZpbmluZyBkZWZhdWx0IE1vZGVsIHNjb3BlXG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRTY29wZShzY29wZU9yU3NvcGVHZXR0ZXIpIHtcbiAgICByZXR1cm4gKHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNjb3BlT3JTc29wZUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2NvcGVfc2VydmljZV8xLmFkZFNjb3BlT3B0aW9uc0dldHRlcih0YXJnZXQucHJvdG90eXBlLCB7IGdldERlZmF1bHRTY29wZTogc2NvcGVPclNzb3BlR2V0dGVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NvcGVfc2VydmljZV8xLmFkZFNjb3BlT3B0aW9ucyh0YXJnZXQucHJvdG90eXBlLCB7IGRlZmF1bHRTY29wZTogc2NvcGVPclNzb3BlR2V0dGVyIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuRGVmYXVsdFNjb3BlID0gRGVmYXVsdFNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjb3BlT3B0aW9ucyA9IGV4cG9ydHMuYWRkU2NvcGVPcHRpb25zID0gZXhwb3J0cy5yZXNvbHZlc0RlcHJlY2F0ZWRTY29wZXMgPSBleHBvcnRzLnNldFNjb3BlT3B0aW9uc0dldHRlcnMgPSBleHBvcnRzLmdldFNjb3BlT3B0aW9uc0dldHRlcnMgPSBleHBvcnRzLmFkZFNjb3BlT3B0aW9uc0dldHRlciA9IGV4cG9ydHMucmVzb2x2ZVNjb3BlID0gZXhwb3J0cy5yZXNvbHZlU2NvcGVzID0gdm9pZCAwO1xuY29uc3Qgb2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL29iamVjdFwiKTtcbmNvbnN0IG1vZGVsX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9zaGFyZWQvbW9kZWwtc2VydmljZVwiKTtcbmNvbnN0IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXNzb2NpYXRpb25zL2FsaWFzLWluZmVyZW5jZS9hbGlhcy1pbmZlcmVuY2Utc2VydmljZVwiKTtcbmNvbnN0IFNDT1BFU19LRVkgPSAnc2VxdWVsaXplOnNjb3Blcyc7XG5jb25zdCBTQ09QRVNfT1BUSU9OU19LRVkgPSAnc2VxdWVsaXplOnNjb3Blcy1vcHRpb25zJztcbi8qKlxuICogUmVzb2x2ZXMgc2NvcGVzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHNwZWNpZmllZCBtb2RlbHNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNjb3Blcyhtb2RlbHMpIHtcbiAgICBtb2RlbHMuZm9yRWFjaChtb2RlbCA9PiB7XG4gICAgICAgIGV4cG9ydHMucmVzb2x2ZXNEZXByZWNhdGVkU2NvcGVzKG1vZGVsKTtcbiAgICAgICAgY29uc3QgeyBnZXREZWZhdWx0U2NvcGUsIGdldFNjb3BlcyB9ID0gZXhwb3J0cy5nZXRTY29wZU9wdGlvbnNHZXR0ZXJzKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChnZXREZWZhdWx0U2NvcGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRlZmF1bHRTY29wZTogZ2V0RGVmYXVsdFNjb3BlKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFNjb3Blcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIGdldFNjb3BlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3RcbiAgICAgICAgICAgIC5rZXlzKG9wdGlvbnMpXG4gICAgICAgICAgICAuZm9yRWFjaChrZXkgPT4gZXhwb3J0cy5yZXNvbHZlU2NvcGUoa2V5LCBtb2RlbCwgb3B0aW9uc1trZXldKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlc29sdmVTY29wZXMgPSByZXNvbHZlU2NvcGVzO1xuY29uc3QgcmVzb2x2ZVNjb3BlID0gKHNjb3BlTmFtZSwgbW9kZWwsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgZm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gKC4uLmFyZ3MpID0+IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhmbiguLi5hcmdzKSwgbW9kZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhvcHRpb25zLCBtb2RlbCk7XG4gICAgfVxuICAgIG1vZGVsLmFkZFNjb3BlKHNjb3BlTmFtZSwgb3B0aW9ucywgeyBvdmVycmlkZTogdHJ1ZSB9KTtcbn07XG5leHBvcnRzLnJlc29sdmVTY29wZSA9IHJlc29sdmVTY29wZTtcbmNvbnN0IGFkZFNjb3BlT3B0aW9uc0dldHRlciA9ICh0YXJnZXQsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjdXJyZW50T3B0aW9ucyA9IGV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zR2V0dGVycyh0YXJnZXQpIHx8IHt9O1xuICAgIGV4cG9ydHMuc2V0U2NvcGVPcHRpb25zR2V0dGVycyh0YXJnZXQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudE9wdGlvbnMpLCBvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5hZGRTY29wZU9wdGlvbnNHZXR0ZXIgPSBhZGRTY29wZU9wdGlvbnNHZXR0ZXI7XG5jb25zdCBnZXRTY29wZU9wdGlvbnNHZXR0ZXJzID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFNDT1BFU19PUFRJT05TX0tFWSwgdGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5leHBvcnRzLmdldFNjb3BlT3B0aW9uc0dldHRlcnMgPSBnZXRTY29wZU9wdGlvbnNHZXR0ZXJzO1xuY29uc3Qgc2V0U2NvcGVPcHRpb25zR2V0dGVycyA9ICh0YXJnZXQsIG9wdGlvbnMpID0+IHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFNDT1BFU19PUFRJT05TX0tFWSwgb3B0aW9ucywgdGFyZ2V0KTtcbn07XG5leHBvcnRzLnNldFNjb3BlT3B0aW9uc0dldHRlcnMgPSBzZXRTY29wZU9wdGlvbnNHZXR0ZXJzO1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCByZXNvbHZlc0RlcHJlY2F0ZWRTY29wZXMgPSAobW9kZWwpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0U2NvcGVPcHRpb25zKG1vZGVsLnByb3RvdHlwZSkgfHwge307XG4gICAgT2JqZWN0XG4gICAgICAgIC5rZXlzKG9wdGlvbnMpXG4gICAgICAgIC5mb3JFYWNoKGtleSA9PiByZXNvbHZlRGVwcmVjYXRlZFNjb3BlKGtleSwgbW9kZWwsIG9wdGlvbnNba2V5XSkpO1xufTtcbmV4cG9ydHMucmVzb2x2ZXNEZXByZWNhdGVkU2NvcGVzID0gcmVzb2x2ZXNEZXByZWNhdGVkU2NvcGVzO1xuLyoqXG4gKiBBZGRzIHNjb3BlIG9wdGlvbiBtZXRhIGRhdGEgZm9yIHNwZWNpZmllZCBwcm90b3R5cGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGFkZFNjb3BlT3B0aW9ucyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IGdldFNjb3BlT3B0aW9ucyh0YXJnZXQpIHx8IHt9O1xuICAgIHNldFNjb3BlT3B0aW9ucyh0YXJnZXQsIG9iamVjdF8xLmRlZXBBc3NpZ24oe30sIF9vcHRpb25zLCBvcHRpb25zKSk7XG59XG5leHBvcnRzLmFkZFNjb3BlT3B0aW9ucyA9IGFkZFNjb3BlT3B0aW9ucztcbi8qKlxuICogUmV0dXJucyBzY29wZSBvcHRpb24gbWV0YSBkYXRhIGZyb20gc3BlY2lmaWVkIHRhcmdldFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0U2NvcGVPcHRpb25zKHRhcmdldCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFNDT1BFU19LRVksIHRhcmdldCk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdF8xLmRlZXBBc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NvcGVPcHRpb25zID0gZ2V0U2NvcGVPcHRpb25zO1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiByZXNvbHZlRGVwcmVjYXRlZFNjb3BlKHNjb3BlTmFtZSwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgZm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gKC4uLmFyZ3MpID0+IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhmbiguLi5hcmdzKSwgbW9kZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IGFsaWFzX2luZmVyZW5jZV9zZXJ2aWNlXzEuaW5mZXJBbGlhcyhtb2RlbF9zZXJ2aWNlXzEucmVzb2x2ZU1vZGVsR2V0dGVyKG9wdGlvbnMpLCBtb2RlbCk7XG4gICAgfVxuICAgIG1vZGVsLmFkZFNjb3BlKHNjb3BlTmFtZSwgb3B0aW9ucywgeyBvdmVycmlkZTogdHJ1ZSB9KTtcbn1cbi8qKlxuICogU2V0IHNjb3BlIG9wdGlvbiBtZXRhIGRhdGEgZm9yIHNwZWNpZmllZCBwcm90b3R5cGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHNldFNjb3BlT3B0aW9ucyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFNDT1BFU19LRVksIG9wdGlvbnMsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUtdGFibGUtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NvcGVzID0gdm9pZCAwO1xuY29uc3Qgc2NvcGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2NvcGUtc2VydmljZVwiKTtcbi8qKlxuICogRGVjb3JhdG9yIGZvciBkZWZpbmluZyBNb2RlbCBzY29wZXNcbiAqL1xuZnVuY3Rpb24gU2NvcGVzKHNjb3Blc09yU2NvcGVzR2V0dGVyKSB7XG4gICAgcmV0dXJuICh0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZXNPclNjb3Blc0dldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2NvcGVfc2VydmljZV8xLmFkZFNjb3BlT3B0aW9uc0dldHRlcih0YXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgZ2V0U2NvcGVzOiBzY29wZXNPclNjb3Blc0dldHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NvcGVfc2VydmljZV8xLmFkZFNjb3BlT3B0aW9ucyh0YXJnZXQucHJvdG90eXBlLCBzY29wZXNPclNjb3Blc0dldHRlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5TY29wZXMgPSBTY29wZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZmVyRGF0YVR5cGUgPSBleHBvcnRzLmlzRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBzZXF1ZWxpemVfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemVcIik7XG4vKlxuICogQ2hlY2tzIGlmIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHNlcXVlbGl6ZSBkYXRhIHR5cGUgKEFCU1RSQUNULCBTVFJJTkcuLi4pXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlKHt9KSBpbnN0YW5jZW9mIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5BQlNUUkFDVCkgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuQUJTVFJBQ1Q7XG59XG5leHBvcnRzLmlzRGF0YVR5cGUgPSBpc0RhdGFUeXBlO1xuLyoqXG4gKiBJbmZlcnMgc2VxdWVsaXplIGRhdGEgdHlwZSBieSBkZXNpZ24gdHlwZVxuICovXG5mdW5jdGlvbiBpbmZlckRhdGFUeXBlKGRlc2lnblR5cGUpIHtcbiAgICBzd2l0Y2ggKGRlc2lnblR5cGUpIHtcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLlNUUklORztcbiAgICAgICAgY2FzZSBCaWdJbnQ6XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLkJJR0lOVDtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVsaXplXzEuRGF0YVR5cGVzLklOVEVHRVI7XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuQk9PTEVBTjtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbGl6ZV8xLkRhdGFUeXBlcy5EQVRFO1xuICAgICAgICBjYXNlIEJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZWxpemVfMS5EYXRhVHlwZXMuQkxPQjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxufVxuZXhwb3J0cy5pbmZlckRhdGFUeXBlID0gaW5mZXJEYXRhVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHNlcXVlbGl6ZV8xID0gcmVxdWlyZShcInNlcXVlbGl6ZVwiKTtcbmV4cG9ydHMuRGF0YVR5cGUgPSBzZXF1ZWxpemVfMS5EYXRhVHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvc2l0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVsaXplLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE1vZGVscyA9IGV4cG9ydHMucHJlcGFyZUFyZ3MgPSBleHBvcnRzLnByZXBhcmVPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBnbG9iID0gcmVxdWlyZShcImdsb2JcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9hcnJheVwiKTtcbi8qKlxuICogUHJlcGFyZXMgc2VxdWVsaXplIGNvbmZpZyBwYXNzZWQgdG8gb3JpZ2luYWwgc2VxdWVsaXplIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbGlkYXRpb25Pbmx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wcmVwYXJlT3B0aW9ucyA9IHByZXBhcmVPcHRpb25zO1xuZnVuY3Rpb24gcHJlcGFyZUFyZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgb3B0aW9ucyA9IGxhc3RBcmcgJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdvYmplY3QnXG4gICAgICAgID8gcHJlcGFyZU9wdGlvbnMobGFzdEFyZykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gb3B0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJlcGFyZWRBcmdzOiBhcmdzLCBvcHRpb25zIH07XG59XG5leHBvcnRzLnByZXBhcmVBcmdzID0gcHJlcGFyZUFyZ3M7XG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9uT25seU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRpYWxlY3Q6ICdzcWxpdGUnLCBkaWFsZWN0TW9kdWxlUGF0aDogX19kaXJuYW1lICsgJy8uLi92YWxpZGF0aW9uLW9ubHkvZGItZGlhbGVjdC1kdW1teScgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgbW9kZWxzIGZyb20gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZWxzKGFyZywgbW9kZWxNYXRjaCkge1xuICAgIGNvbnN0IGhhc1N1cHBvcnRlZEV4dGVuc2lvbiA9IHBhdGggPT4gWycudHMnLCAnLmpzJ10uaW5kZXhPZihwYXRoXzEuZXh0bmFtZShwYXRoKSkgIT09IC0xO1xuICAgIGlmIChhcmcgJiYgdHlwZW9mIGFyZ1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5yZWR1Y2UoKG1vZGVscywgZGlyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWdsb2IuaGFzTWFnaWMoZGlyKSAmJiAhaGFzU3VwcG9ydGVkRXh0ZW5zaW9uKGRpcikpXG4gICAgICAgICAgICAgICAgZGlyID0gcGF0aF8xLmpvaW4oZGlyLCAnLyonKTtcbiAgICAgICAgICAgIGNvbnN0IF9tb2RlbHMgPSBnbG9iXG4gICAgICAgICAgICAgICAgLnN5bmMoZGlyKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXNJbXBvcnRhYmxlKVxuICAgICAgICAgICAgICAgIC5tYXAoZ2V0RnVsbGZpbGVwYXRoV2l0aG91dEV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGFycmF5XzEudW5pcXVlRmlsdGVyKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVsbFBhdGggPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHJlcXVpcmUoZnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aF8xLmJhc2VuYW1lKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkTWVtYmVyS2V5ID0gT2JqZWN0LmtleXMobW9kdWxlKS5maW5kKG0gPT4gbW9kZWxNYXRjaChmaWxlTmFtZSwgbSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRNZW1iZXIgPSBtYXRjaGVkTWVtYmVyS2V5ID8gbW9kdWxlW21hdGNoZWRNZW1iZXJLZXldIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZE1lbWJlciAmJiAhbW9kdWxlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZhdWx0IGV4cG9ydCBkZWZpbmVkIGZvciBmaWxlIFwiJHtmaWxlTmFtZX1cIiBvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBvcnQgZG9lcyBub3Qgc2F0aXNmeSBmaWxlbmFtZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRNZW1iZXIgfHwgbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVscy5wdXNoKC4uLl9tb2RlbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xufVxuZXhwb3J0cy5nZXRNb2RlbHMgPSBnZXRNb2RlbHM7XG4vKipcbiAqIENoZWNrcyBpZiBzcGVjaWZpZWQgZmlsZW5hbWUgaXMgaW1wb3J0YWJsZSBvciBub3Q7XG4gKiBXaGljaCBtZWFucyB0aGF0LCBpdCBuZWVkcyB0byBoYXZlIGEgc3BlY2lmaWMgZmlsZSBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gaXNJbXBvcnRhYmxlKGZpbGUpIHtcbiAgICBjb25zdCBmaWxlUGFydCA9IGZpbGUuc2xpY2UoLTMpO1xuICAgIHJldHVybiBmaWxlUGFydCA9PT0gJy5qcycgfHwgKGZpbGVQYXJ0ID09PSAnLnRzJyAmJiBmaWxlLnNsaWNlKC01KSAhPT0gJy5kLnRzJyk7XG59XG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZ1bGwgcGF0aCB3aXRoIGZpbGVuYW1lLCB3aXRob3V0IGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiBnZXRGdWxsZmlsZXBhdGhXaXRob3V0RXh0ZW5zaW9uKGZpbGUpIHtcbiAgICBjb25zdCBwYXJzZWRGaWxlID0gcGF0aF8xLnBhcnNlKGZpbGUpO1xuICAgIHJldHVybiBwYXRoXzEuam9pbihwYXJzZWRGaWxlLmRpciwgcGFyc2VkRmlsZS5uYW1lKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbGl6ZS1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXF1ZWxpemUgPSB2b2lkIDA7XG5jb25zdCBzZXF1ZWxpemVfMSA9IHJlcXVpcmUoXCJzZXF1ZWxpemVcIik7XG5jb25zdCBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9zaGFyZWQvbW9kZWwtbm90LWluaXRpYWxpemVkLWVycm9yXCIpO1xuY29uc3Qgc2VxdWVsaXplX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS1zZXJ2aWNlXCIpO1xuY29uc3QgbW9kZWxfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL3NoYXJlZC9tb2RlbC1zZXJ2aWNlXCIpO1xuY29uc3Qgc2NvcGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3Njb3Blcy9zY29wZS1zZXJ2aWNlXCIpO1xuY29uc3QgaG9va3Nfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2hvb2tzL3NoYXJlZC9ob29rcy1zZXJ2aWNlXCIpO1xuY29uc3QgYXNzb2NpYXRpb25fc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9zaGFyZWQvYXNzb2NpYXRpb24tc2VydmljZVwiKTtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuY29uc3QgaW5kZXhfc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL2luZGV4L2luZGV4LXNlcnZpY2VcIik7XG5jbGFzcyBTZXF1ZWxpemUgZXh0ZW5kcyBzZXF1ZWxpemVfMS5TZXF1ZWxpemUge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBwcmVwYXJlZEFyZ3MsIG9wdGlvbnMgfSA9IHNlcXVlbGl6ZV9zZXJ2aWNlXzEucHJlcGFyZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHN1cGVyKC4uLnByZXBhcmVkQXJncyk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRvcnlNb2RlID0gISFvcHRpb25zLnJlcG9zaXRvcnlNb2RlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZWxzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTW9kZWxzKG9wdGlvbnMubW9kZWxzKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZGVsUGF0aHMpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNb2RlbHMob3B0aW9ucy5tb2RlbFBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdG9yeU1vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb2RlbChtb2RlbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZGVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLm1vZGVsKG1vZGVsX3NlcnZpY2VfMS5nZXRNb2RlbE5hbWUobW9kZWwucHJvdG90eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLm1vZGVsKG1vZGVsKTtcbiAgICB9XG4gICAgYWRkTW9kZWxzKGFyZywgbW9kZWxNYXRjaCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0TW9kZWxNYXRjaCA9IChmaWxlbmFtZSwgbWVtYmVyKSA9PiBmaWxlbmFtZSA9PT0gbWVtYmVyO1xuICAgICAgICBjb25zdCBtb2RlbHMgPSBzZXF1ZWxpemVfc2VydmljZV8xLmdldE1vZGVscyhhcmcsIG1vZGVsTWF0Y2ggfHwgdGhpcy5vcHRpb25zLm1vZGVsTWF0Y2ggfHwgZGVmYXVsdE1vZGVsTWF0Y2gpO1xuICAgICAgICBjb25zdCBkZWZpbmVkTW9kZWxzID0gdGhpcy5kZWZpbmVNb2RlbHMobW9kZWxzKTtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGVNb2RlbHMoZGVmaW5lZE1vZGVscyk7XG4gICAgICAgIHNjb3BlX3NlcnZpY2VfMS5yZXNvbHZlU2NvcGVzKGRlZmluZWRNb2RlbHMpO1xuICAgICAgICBob29rc19zZXJ2aWNlXzEuaW5zdGFsbEhvb2tzKGRlZmluZWRNb2RlbHMpO1xuICAgIH1cbiAgICBnZXRSZXBvc2l0b3J5KG1vZGVsQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwobW9kZWxDbGFzcyk7XG4gICAgfVxuICAgIGFzc29jaWF0ZU1vZGVscyhtb2RlbHMpIHtcbiAgICAgICAgbW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25zID0gYXNzb2NpYXRpb25fc2VydmljZV8xLmdldEFzc29jaWF0aW9ucyhtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXNzb2NpYXRpb25zLmZvckVhY2goYXNzb2NpYXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NvY2lhdGlvbi5nZXRTZXF1ZWxpemVPcHRpb25zKG1vZGVsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGVkQ2xhc3MgPSB0aGlzLm1vZGVsKGFzc29jaWF0aW9uLmdldEFzc29jaWF0ZWRDbGFzcygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzc29jaWF0ZWRDbGFzcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBtb2RlbF9ub3RfaW5pdGlhbGl6ZWRfZXJyb3JfMS5Nb2RlbE5vdEluaXRpYWxpemVkRXJyb3IoYXNzb2NpYXRlZENsYXNzLCBgQXNzb2NpYXRpb24gYmV0d2VlbiAke2Fzc29jaWF0ZWRDbGFzcy5uYW1lfSBhbmQgJHttb2RlbC5uYW1lfSBjYW5ub3QgYmUgcmVzb2x2ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVsW2Fzc29jaWF0aW9uLmdldEFzc29jaWF0aW9uKCldKGFzc29jaWF0ZWRDbGFzcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmluZU1vZGVscyhtb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVscy5tYXAobW9kZWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gbW9kZWxfc2VydmljZV8xLmdldE1vZGVsTmFtZShtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuZ2V0QXR0cmlidXRlcyhtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4X3NlcnZpY2VfMS5nZXRJbmRleGVzKG1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE9wdGlvbnMgPSBtb2RlbF9zZXJ2aWNlXzEuZ2V0T3B0aW9ucyhtb2RlbC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbE9wdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAVGFibGUgYW5ub3RhdGlvbiBpcyBtaXNzaW5nIG9uIGNsYXNzIFwiJHttb2RlbFsnbmFtZSddfVwiYCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleEFycmF5ID0gT2JqZWN0LmtleXMoaW5kZXhlcy5uYW1lZClcbiAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBpbmRleGVzLm5hbWVkW2tleV0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChpbmRleGVzLnVubmFtZWQpO1xuICAgICAgICAgICAgY29uc3QgaW5pdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGluZGV4QXJyYXkubGVuZ3RoID4gMCAmJiB7IGluZGV4ZXM6IGluZGV4QXJyYXkgfSkpLCBtb2RlbE9wdGlvbnMpLCB7IG1vZGVsTmFtZSwgc2VxdWVsaXplOiB0aGlzIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5lZE1vZGVsID0gdGhpcy5yZXBvc2l0b3J5TW9kZVxuICAgICAgICAgICAgICAgID8gdGhpcy5jcmVhdGVSZXBvc2l0b3J5TW9kZWwobW9kZWwpXG4gICAgICAgICAgICAgICAgOiBtb2RlbDtcbiAgICAgICAgICAgIGRlZmluZWRNb2RlbC5pbml0KGF0dHJpYnV0ZXMsIGluaXRPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkTW9kZWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVSZXBvc2l0b3J5TW9kZWwobW9kZWxDbGFzcykge1xuICAgICAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBtb2RlbENsYXNzIHtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbGl6ZS5qcy5tYXAiLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9ICgpID0+IChbXSk7XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplLXR5cGVzY3JpcHQvZGlzdC9zZXF1ZWxpemUvc2VxdWVsaXplIHN5bmMgcmVjdXJzaXZlXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIER1bW15IGRhdGFiYXNlIGZpbGUsIHdoaWNoIGdldHMgcmVxdWlyZWQgYnkgc2VxdWVsaXplLCB0b1xuICogbWFrZSB2YWxpZGF0aW9uIG9mIG1vZGVscyBwb3NzaWJsZSB3aXRob3V0IHVzaW5nIHRoZVxuICogYWN0dWFsIE9STSBvciBhbnkgZGF0YWJhc2UgY29ubmVjdGlvbi5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJib3NlID0gdm9pZCAwO1xuZnVuY3Rpb24gdmVyYm9zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLnZlcmJvc2UgPSB2ZXJib3NlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGItZGlhbGVjdC1kdW1teS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pcXVlRmlsdGVyID0gZXhwb3J0cy51bmlxdWUgPSB2b2lkIDA7XG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIHNwZWNpZmllZCBhcnJheVxuICovXG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZXhwb3J0cy51bmlxdWVGaWx0ZXIpO1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgaXRlbXMsIHRoYXQgb25seSBleGlzdHMgb25jZSBvbiBhbiBhcnJheVxuICovXG5jb25zdCB1bmlxdWVGaWx0ZXIgPSAoaXRlbSwgaW5kZXgsIGFycikgPT4gYXJyLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuZXhwb3J0cy51bmlxdWVGaWx0ZXIgPSB1bmlxdWVGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QWxsUHJvcGVydHlOYW1lcyA9IGV4cG9ydHMuY2xvbmVSZWdFeHAgPSBleHBvcnRzLmRlZXBBc3NpZ24gPSB2b2lkIDA7XG5mdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICBPYmplY3RcbiAgICAgICAgICAgIC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiBhc3NpZ24oa2V5LCB0YXJnZXQsIHNvdXJjZSkpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAgICAgLmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IGFzc2lnbihrZXksIHRhcmdldCwgc291cmNlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICAgIGZ1bmN0aW9uIGFzc2lnbihrZXksIF90YXJnZXQsIF9zb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBfc291cmNlW2tleV07XG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VmFsdWUgPSBfdGFyZ2V0W2tleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZS5mb3JFYWNoKChfLCBpbmRleCkgPT4gYXNzaWduKGxlbmd0aCArIGluZGV4LCB0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBjbG9uZVJlZ0V4cChzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IG5ldyBEYXRlKHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBPYmplY3QuY3JlYXRlKHNvdXJjZVZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVlcEFzc2lnbih0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlID0gc291cmNlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGFyZ2V0W2tleV0gPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVlcEFzc2lnbiA9IGRlZXBBc3NpZ247XG4vKipcbiAqIEkgY2xvbmUgdGhlIGdpdmVuIFJlZ0V4cCBvYmplY3QsIGFuZCBlbnN1cmUgdGhhdCB0aGUgZ2l2ZW4gZmxhZ3MgZXhpc3Qgb25cbiAqIHRoZSBjbG9uZS4gVGhlIGluamVjdEZsYWdzIHBhcmFtZXRlciBpcyBwdXJlbHkgYWRkaXRpdmUgLSBpdCBjYW5ub3QgcmVtb3ZlXG4gKiBmbGFncyB0aGF0IGFscmVhZHkgZXhpc3Qgb24gdGhlXG4gKlxuICogQHBhcmFtIGlucHV0IFJlZ0V4cCAtIEkgYW0gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgYmVpbmcgY2xvbmVkLlxuICogQHBhcmFtIGluamVjdEZsYWdzIFN0cmluZyggT3B0aW9uYWwgKSAtIEkgYW0gdGhlIGZsYWdzIHRvIGVuZm9yY2Ugb24gdGhlIGNsb25lLlxuICogQHNvdXJjZSBodHRwczovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjY0LWNsb25pbmctcmVnZXhwLXJlZ3VsYXItZXhwcmVzc2lvbi1vYmplY3RzLWluLWphdmFzY3JpcHQuaHRtXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKGlucHV0LCBpbmplY3RGbGFncykge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBpbnB1dC5zb3VyY2U7XG4gICAgbGV0IGZsYWdzID0gXCJcIjtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmFtZXRlciBpcyBhIGRlZmluZWQgc3RyaW5nIC0gaXQgd2lsbCBtYWtlIHRoZSBjb25kaXRpb25hbFxuICAgIC8vIGxvZ2ljIGVhc2llciB0byByZWFkLlxuICAgIGluamVjdEZsYWdzID0gKGluamVjdEZsYWdzIHx8IFwiXCIpO1xuICAgIC8vIFRlc3QgZm9yIGdsb2JhbC5cbiAgICBpZiAoaW5wdXQuZ2xvYmFsIHx8ICgvZy9pKS50ZXN0KGluamVjdEZsYWdzKSkge1xuICAgICAgICBmbGFncyArPSBcImdcIjtcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgaWdub3JlQ2FzZS5cbiAgICBpZiAoaW5wdXQuaWdub3JlQ2FzZSB8fCAoL2kvaSkudGVzdChpbmplY3RGbGFncykpIHtcbiAgICAgICAgZmxhZ3MgKz0gXCJpXCI7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIG11bHRpbGluZS5cbiAgICBpZiAoaW5wdXQubXVsdGlsaW5lIHx8ICgvbS9pKS50ZXN0KGluamVjdEZsYWdzKSkge1xuICAgICAgICBmbGFncyArPSBcIm1cIjtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgY2xvbmUgd2l0aCB0aGUgYWRkaXRpdmUgZmxhZ3MuXG4gICAgcmV0dXJuIChuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSk7XG59XG5leHBvcnRzLmNsb25lUmVnRXhwID0gY2xvbmVSZWdFeHA7XG5mdW5jdGlvbiBnZXRBbGxQcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgY29uc3QgZXhpc3RzID0ge307XG4gICAgZG8ge1xuICAgICAgICBuYW1lcy5wdXNoLmFwcGx5KG5hbWVzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKTtcbiAgICAgICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgfSB3aGlsZSAob2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcbiAgICByZXR1cm4gbmFtZXMuZmlsdGVyKG5hbWUgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gIWV4aXN0c1tuYW1lXSAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InO1xuICAgICAgICBleGlzdHNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0QWxsUHJvcGVydHlOYW1lcyA9IGdldEFsbFByb3BlcnR5TmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhcGl0YWxpemUgPSB2b2lkIDA7XG4vKipcbiAqIENhcGl0YWxpemUgc3BlY2lmaWVkIHN0cmluZyB2YWx1ZVxuICovXG5mdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCk7XG59XG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250YWlucyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBGb3JjZSBzcGVjaWZpYyBzdWJzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5zKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBjb250YWluczogdmFsdWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Db250YWlucyA9IENvbnRhaW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVxdWFscyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93IGEgc3BlY2lmaWMgdmFsdWVcbiAqL1xuZnVuY3Rpb24gRXF1YWxzKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBlcXVhbHM6IHZhbHVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuRXF1YWxzID0gRXF1YWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0FmdGVyID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgZGF0ZSBzdHJpbmdzIGFmdGVyIGEgc3BlY2lmaWMgZGF0ZVxuICovXG5mdW5jdGlvbiBJc0FmdGVyKGRhdGUpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQWZ0ZXI6IGRhdGVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0FmdGVyID0gSXNBZnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFmdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0FscGhhID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdpbGwgb25seSBhbGxvdyBsZXR0ZXJzXG4gKi9cbmZ1bmN0aW9uIElzQWxwaGEodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzQWxwaGE6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0FscGhhID0gSXNBbHBoYTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFscGhhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0FscGhhbnVtZXJpYyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBXaWxsIG9ubHkgYWxsb3cgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIHNvIFwiX2FiY1wiIHdpbGwgZmFpbFxuICovXG5mdW5jdGlvbiBJc0FscGhhbnVtZXJpYyh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNBbHBoYW51bWVyaWM6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0FscGhhbnVtZXJpYyA9IElzQWxwaGFudW1lcmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYWxwaGFudW1lcmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0FycmF5ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdpbGwgb25seSBhbGxvdyBhcnJheXNcbiAqL1xuZnVuY3Rpb24gSXNBcnJheSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzQXJyYXkgPSBJc0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzQmVmb3JlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgZGF0ZSBzdHJpbmdzIGJlZm9yZSBhIHNwZWNpZmljIGRhdGVcbiAqL1xuZnVuY3Rpb24gSXNCZWZvcmUoZGF0ZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNCZWZvcmU6IGRhdGVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0JlZm9yZSA9IElzQmVmb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYmVmb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0NyZWRpdENhcmQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2sgZm9yIHZhbGlkIGNyZWRpdCBjYXJkIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gSXNDcmVkaXRDYXJkKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0NyZWRpdENhcmQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0NyZWRpdENhcmQgPSBJc0NyZWRpdENhcmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1jcmVkaXQtY2FyZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNEYXRlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIE9ubHkgYWxsb3cgZGF0ZSBzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIElzRGF0ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNEYXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNEYXRlID0gSXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNEZWNpbWFsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgYW55IG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gSXNEZWNpbWFsKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0RlY2ltYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0RlY2ltYWwgPSBJc0RlY2ltYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1kZWNpbWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0VtYWlsID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgZW1haWwgZm9ybWF0IChmb29AYmFyLmNvbSlcbiAqL1xuZnVuY3Rpb24gSXNFbWFpbCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNFbWFpbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzRW1haWwgPSBJc0VtYWlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZW1haWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzRmxvYXQgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciB2YWxpZCBmbG9hdGluZyBwb2ludCBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIElzRmxvYXQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzRmxvYXQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Jc0Zsb2F0ID0gSXNGbG9hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWZsb2F0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc0luID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrIHRoZSB2YWx1ZSBpcyBvbmUgb2YgdGhlc2VcbiAqL1xuZnVuY3Rpb24gSXNJbihhcmcpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzSW46IGFyZ1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzSW4gPSBJc0luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzSW50ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgdmFsaWQgaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gSXNJbnQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzSW50OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNJbnQgPSBJc0ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNJUHY0ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgSVB2NCAoMTI5Ljg5LjIzLjEpXG4gKi9cbmZ1bmN0aW9uIElzSVB2NCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNJUHY0OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNJUHY0ID0gSXNJUHY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaXAtdjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzSVB2NiA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBDaGVja3MgZm9yIElQdjYgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIElzSVB2Nih0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNJUHY2OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNJUHY2ID0gSXNJUHY2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaXAtdjYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzSVAgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciBJUHY0ICgxMjkuODkuMjMuMSkgb3IgSVB2NiBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gSXNJUCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNJUDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzSVAgPSBJc0lQO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzTG93ZXJjYXNlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrcyBmb3IgbG93ZXJjYXNlXG4gKi9cbmZ1bmN0aW9uIElzTG93ZXJjYXNlKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBpc0xvd2VyY2FzZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzTG93ZXJjYXNlID0gSXNMb3dlcmNhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1sb3dlcmNhc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzTnVsbCA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBPbmx5IGFsbG93cyBudWxsXG4gKi9cbmZ1bmN0aW9uIElzTnVsbCh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNOdWxsOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNOdWxsID0gSXNOdWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNOdW1lcmljID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdpbGwgb25seSBhbGxvdyBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIElzTnVtZXJpYyh0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgaXNOdW1lcmljOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNOdW1lcmljID0gSXNOdW1lcmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNVcHBlcmNhc2UgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciB1cHBlcmNhc2VcbiAqL1xuZnVuY3Rpb24gSXNVcHBlcmNhc2UodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzVXBwZXJjYXNlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNVcHBlcmNhc2UgPSBJc1VwcGVyY2FzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXVwcGVyY2FzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNVcmwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogQ2hlY2tzIGZvciB1cmwgZm9ybWF0IChodHRwOi8vZm9vLmNvbSlcbiAqL1xuZnVuY3Rpb24gSXNVcmwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzVXJsOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuSXNVcmwgPSBJc1VybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXVybC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXNVVUlEID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKlxuICogT25seSBhbGxvdyB1dWlkcy5cbiAqIFZlcnNpb24ncyByZWd1bGFyIGV4cHJlc3Npb25zOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvYmxvYi9iNTkxMzNiMTcyN2I2YWYzNTViNDAzYTlhOTdhMTkyMjZjY2ViMzRiL2xpYi9pc1VVSUQuanMjTDE0LUwxOS5cbiAqL1xuZnVuY3Rpb24gSXNVVUlEKHZlcnNpb24pIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGlzVVVJRDogdmVyc2lvblxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLklzVVVJRCA9IElzVVVJRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXV1aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG5mdW5jdGlvbiBJcyguLi5hcmdzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IGFyZ0lzRnVuY3Rpb24gPSB0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoYXJnSXNGdW5jdGlvbiB8fCAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBsZXQgdmFsaWRhdG9yO1xuICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgaWYgKGFyZ0lzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhbGlkYXRvciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBuYW1lID0gdmFsaWRhdG9yLm5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXNzZWQgdmFsaWRhdG9yIGZ1bmN0aW9uIG11c3QgaGF2ZSBhIG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBhcmdzWzBdO1xuICAgICAgICAgICAgdmFsaWRhdG9yID0gYXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zW2BpcyR7bmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoKX1gXSA9IHZhbGlkYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuaXMgPSBhcmdzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuSXMgPSBJcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MZW5ndGggPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyB2YWx1ZXMgd2l0aCBsZW5ndGggYmV0d2VlbiBtaW4gYW5kIG1heFxuICovXG5mdW5jdGlvbiBMZW5ndGgoeyBtc2csIG1pbiwgbWF4IH0pIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBjb25zdCBsZW5ndGggPSBbbWluIHx8IDAsIG1heF07XG4gICAgb3B0aW9ucyA9IG1zZyA/IHsgYXJnczogbGVuZ3RoLCBtc2c6IG1zZyB9IDogbGVuZ3RoO1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbGVuOiBvcHRpb25zXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTGVuZ3RoID0gTGVuZ3RoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXggPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyB2YWx1ZXMgPD0gbGltaXRcbiAqL1xuZnVuY3Rpb24gTWF4KGxpbWl0KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBtYXg6IGxpbWl0XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTWF4ID0gTWF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaW4gPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogT25seSBhbGxvdyB2YWx1ZXMgPj0gbGltaXRcbiAqL1xuZnVuY3Rpb24gTWluKGxpbWl0KSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBtaW46IGxpbWl0XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTWluID0gTWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3RDb250YWlucyA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuLyoqXG4gKiBEb24ndCBhbGxvdyBzcGVjaWZpYyBzdWJzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIE5vdENvbnRhaW5zKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBub3RDb250YWluczogdmFsdWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Ob3RDb250YWlucyA9IE5vdENvbnRhaW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3RFbXB0eSA9IHZvaWQgMDtcbmNvbnN0IGF0dHJpYnV0ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvY29sdW1uL2F0dHJpYnV0ZS1zZXJ2aWNlXCIpO1xuZnVuY3Rpb24gTm90RW1wdHkoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXTtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5TmFtZSkgPT4gYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgICAgIG5vdEVtcHR5OiBvcHRpb25zLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGFyZ3NbMV07XG4gICAgICAgIGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgICAgICBub3RFbXB0eTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdEVtcHR5ID0gTm90RW1wdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QtZW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdEluID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIENoZWNrIHRoZSB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZXNlXG4gKi9cbmZ1bmN0aW9uIE5vdEluKGFyZykge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbm90SW46IGFyZ1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLk5vdEluID0gTm90SW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QtaW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdE51bGwgPSB2b2lkIDA7XG5jb25zdCBhdHRyaWJ1dGVfc2VydmljZV8xID0gcmVxdWlyZShcIi4uL21vZGVsL2NvbHVtbi9hdHRyaWJ1dGUtc2VydmljZVwiKTtcbi8qKlxuICogV29uJ3QgYWxsb3cgbnVsbFxuICovXG5mdW5jdGlvbiBOb3ROdWxsKHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgYXR0cmlidXRlX3NlcnZpY2VfMS5hZGRBdHRyaWJ1dGVPcHRpb25zKHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICBub3ROdWxsOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuTm90TnVsbCA9IE5vdE51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QtbnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90ID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFdpbGwgbm90IGFsbG93IHZhbHVlcywgdGhhdCBtYXRjaCB0aGUgc3RyaW5nIHJlZ2V4IG9yIHJlYWwgcmVnZXhcbiAqL1xuZnVuY3Rpb24gTm90KGFyZykge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpID0+IGF0dHJpYnV0ZV9zZXJ2aWNlXzEuYWRkQXR0cmlidXRlT3B0aW9ucyh0YXJnZXQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgbm90OiBhcmdcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5Ob3QgPSBOb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgYXR0cmlidXRlX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbC9jb2x1bW4vYXR0cmlidXRlLXNlcnZpY2VcIik7XG4vKipcbiAqIFNldHMgdmFsaWRhdGlvbiBvcHRpb25zIGZvciBhbm5vdGF0ZWQgZmllbGRcbiAqL1xuZnVuY3Rpb24gVmFsaWRhdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlOYW1lKSA9PiBhdHRyaWJ1dGVfc2VydmljZV8xLmFkZEF0dHJpYnV0ZU9wdGlvbnModGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuVmFsaWRhdGUgPSBWYWxpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0b3IgPSB2b2lkIDA7XG5jb25zdCBtb2RlbF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbW9kZWwvc2hhcmVkL21vZGVsLXNlcnZpY2VcIik7XG5jb25zdCBWYWxpZGF0b3IgPSAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBtb2RlbF9zZXJ2aWNlXzEuYWRkT3B0aW9ucyh0YXJnZXQsIHtcbiAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eU5hbWVdOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICAqIFRoZSBlbnRyeSBwb2ludC5cbiAgKlxuICAqIEBtb2R1bGUgU2VxdWVsaXplXG4gICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3NlcXVlbGl6ZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEFzc29jaWF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJy4vLi4vZXJyb3JzJyk7XG5cbi8qKlxuICogQ3JlYXRpbmcgYXNzb2NpYXRpb25zIGluIHNlcXVlbGl6ZSBpcyBkb25lIGJ5IGNhbGxpbmcgb25lIG9mIHRoZSBiZWxvbmdzVG8gLyBoYXNPbmUgLyBoYXNNYW55IC8gYmVsb25nc1RvTWFueSBmdW5jdGlvbnMgb24gYSBtb2RlbCAodGhlIHNvdXJjZSksIGFuZCBwcm92aWRpbmcgYW5vdGhlciBtb2RlbCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uICh0aGUgdGFyZ2V0KS5cbiAqXG4gKiAqIGhhc09uZSAtIGFkZHMgYSBmb3JlaWduIGtleSB0byB0aGUgdGFyZ2V0IGFuZCBzaW5ndWxhciBhc3NvY2lhdGlvbiBtaXhpbnMgdG8gdGhlIHNvdXJjZS5cbiAqICogYmVsb25nc1RvIC0gYWRkIGEgZm9yZWlnbiBrZXkgYW5kIHNpbmd1bGFyIGFzc29jaWF0aW9uIG1peGlucyB0byB0aGUgc291cmNlLlxuICogKiBoYXNNYW55IC0gYWRkcyBhIGZvcmVpZ24ga2V5IHRvIHRhcmdldCBhbmQgcGx1cmFsIGFzc29jaWF0aW9uIG1peGlucyB0byB0aGUgc291cmNlLlxuICogKiBiZWxvbmdzVG9NYW55IC0gY3JlYXRlcyBhbiBOOk0gYXNzb2NpYXRpb24gd2l0aCBhIGpvaW4gdGFibGUgYW5kIGFkZHMgcGx1cmFsIGFzc29jaWF0aW9uIG1peGlucyB0byB0aGUgc291cmNlLiBUaGUganVuY3Rpb24gdGFibGUgaXMgY3JlYXRlZCB3aXRoIHNvdXJjZUlkIGFuZCB0YXJnZXRJZC5cbiAqXG4gKiBDcmVhdGluZyBhbiBhc3NvY2lhdGlvbiB3aWxsIGFkZCBhIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgdG8gdGhlIGF0dHJpYnV0ZXMuIEFsbCBhc3NvY2lhdGlvbnMgdXNlIGBDQVNDQURFYCBvbiB1cGRhdGUgYW5kIGBTRVQgTlVMTGAgb24gZGVsZXRlLCBleGNlcHQgZm9yIG46bSwgd2hpY2ggYWxzbyB1c2VzIGBDQVNDQURFYCBvbiBkZWxldGUuXG4gKlxuICogV2hlbiBjcmVhdGluZyBhc3NvY2lhdGlvbnMsIHlvdSBjYW4gcHJvdmlkZSBhbiBhbGlhcywgdmlhIHRoZSBgYXNgIG9wdGlvbi4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIHNhbWUgbW9kZWwgaXMgYXNzb2NpYXRlZCB0d2ljZSwgb3IgeW91IHdhbnQgeW91ciBhc3NvY2lhdGlvbiB0byBiZSBjYWxsZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIG5hbWUgb2YgdGhlIHRhcmdldCBtb2RlbC5cbiAqXG4gKiBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgY2FzZSB3aGVyZSB1c2VycyBoYXZlIG1hbnkgcGljdHVyZXMsIG9uZSBvZiB3aGljaCBpcyB0aGVpciBwcm9maWxlIHBpY3R1cmUuIEFsbCBwaWN0dXJlcyBoYXZlIGEgYHVzZXJJZGAsIGJ1dCBpbiBhZGRpdGlvbiB0aGUgdXNlciBtb2RlbCBhbHNvIGhhcyBhIGBwcm9maWxlUGljdHVyZUlkYCwgdG8gYmUgYWJsZSB0byBlYXNpbHkgbG9hZCB0aGUgdXNlcidzIHByb2ZpbGUgcGljdHVyZS5cbiAqXG4gKiBgYGBqc1xuICogVXNlci5oYXNNYW55KFBpY3R1cmUpXG4gKiBVc2VyLmJlbG9uZ3NUbyhQaWN0dXJlLCB7IGFzOiAnUHJvZmlsZVBpY3R1cmUnLCBjb25zdHJhaW50czogZmFsc2UgfSlcbiAqXG4gKiB1c2VyLmdldFBpY3R1cmVzKCkgLy8gZ2V0cyB5b3UgYWxsIHBpY3R1cmVzXG4gKiB1c2VyLmdldFByb2ZpbGVQaWN0dXJlKCkgLy8gZ2V0cyB5b3Ugb25seSB0aGUgcHJvZmlsZSBwaWN0dXJlXG4gKlxuICogVXNlci5maW5kQWxsKHtcbiAqICAgd2hlcmU6IC4uLixcbiAqICAgaW5jbHVkZTogW1xuICogICAgIHsgbW9kZWw6IFBpY3R1cmUgfSwgLy8gbG9hZCBhbGwgcGljdHVyZXNcbiAqICAgICB7IG1vZGVsOiBQaWN0dXJlLCBhczogJ1Byb2ZpbGVQaWN0dXJlJyB9LCAvLyBsb2FkIHRoZSBwcm9maWxlIHBpY3R1cmUuXG4gKiAgICAgLy8gTm90aWNlIHRoYXQgdGhlIHNwZWxsaW5nIG11c3QgYmUgdGhlIGV4YWN0IHNhbWUgYXMgdGhlIG9uZSBpbiB0aGUgYXNzb2NpYXRpb25cbiAqICAgXVxuICogfSlcbiAqIGBgYFxuICogVG8gZ2V0IGZ1bGwgY29udHJvbCBvdmVyIHRoZSBmb3JlaWduIGtleSBjb2x1bW4gYWRkZWQgYnkgc2VxdWVsaXplLCB5b3UgY2FuIHVzZSB0aGUgYGZvcmVpZ25LZXlgIG9wdGlvbi4gSXQgY2FuIGVpdGhlciBiZSBhIHN0cmluZywgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUsIG9yIGFuZCBvYmplY3QgdHlwZSBkZWZpbml0aW9uLFxuICogZXF1aXZhbGVudCB0byB0aG9zZSBwYXNzZWQgdG8gYHNlcXVlbGl6ZS5kZWZpbmVgLlxuICpcbiAqIGBgYGpzXG4gKiBVc2VyLmhhc01hbnkoUGljdHVyZSwgeyBmb3JlaWduS2V5OiAndWlkJyB9KVxuICogYGBgXG4gKlxuICogVGhlIGZvcmVpZ24ga2V5IGNvbHVtbiBpbiBQaWN0dXJlIHdpbGwgbm93IGJlIGNhbGxlZCBgdWlkYCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGB1c2VySWRgLlxuICpcbiAqIGBgYGpzXG4gKiBVc2VyLmhhc01hbnkoUGljdHVyZSwge1xuICogICBmb3JlaWduS2V5OiB7XG4gKiAgICAgbmFtZTogJ3VpZCcsXG4gKiAgICAgYWxsb3dOdWxsOiBmYWxzZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogVGhpcyBzcGVjaWZpZXMgdGhhdCB0aGUgYHVpZGAgY29sdW1uIGNhbm5vdCBiZSBudWxsLiBJbiBtb3N0IGNhc2VzIHRoaXMgd2lsbCBhbHJlYWR5IGJlIGNvdmVyZWQgYnkgdGhlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzLCB3aGljaCBzZXF1ZWxpemUgY3JlYXRlcyBhdXRvbWF0aWNhbGx5LCBidXQgY2FuIGJlIHVzZWZ1bCBpbiBjYXNlIHdoZXJlIHRoZSBmb3JlaWduIGtleXMgYXJlIGRpc2FibGVkLCBlLmcuIGR1ZSB0byBjaXJjdWxhciByZWZlcmVuY2VzIChzZWUgYGNvbnN0cmFpbnRzOiBmYWxzZWAgYmVsb3cpLlxuICpcbiAqIFdoZW4gZmV0Y2hpbmcgYXNzb2NpYXRlZCBtb2RlbHMsIHlvdSBjYW4gbGltaXQgeW91ciBxdWVyeSB0byBvbmx5IGxvYWQgc29tZSBtb2RlbHMuIFRoZXNlIHF1ZXJpZXMgYXJlIHdyaXR0ZW4gaW4gdGhlIHNhbWUgd2F5IGFzIHF1ZXJpZXMgdG8gYGZpbmRgL2BmaW5kQWxsYC4gVG8gb25seSBnZXQgcGljdHVyZXMgaW4gSlBHLCB5b3UgY2FuIGRvOlxuICpcbiAqIGBgYGpzXG4gKiB1c2VyLmdldFBpY3R1cmVzKHtcbiAqICAgd2hlcmU6IHtcbiAqICAgICBmb3JtYXQ6ICdqcGcnXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHVwZGF0ZSBhbmQgYWRkIG5ldyBhc3NvY2lhdGlvbnMuIENvbnRpbnVpbmcgd2l0aCBvdXIgZXhhbXBsZSBvZiB1c2VycyBhbmQgcGljdHVyZXM6XG4gKiBgYGBqc1xuICogdXNlci5hZGRQaWN0dXJlKHApIC8vIEFkZCBhIHNpbmdsZSBwaWN0dXJlXG4gKiB1c2VyLnNldFBpY3R1cmVzKFtwMSwgcDJdKSAvLyBBc3NvY2lhdGUgdXNlciB3aXRoIE9OTFkgdGhlc2UgdHdvIHBpY3R1cmUsIGFsbCBvdGhlciBhc3NvY2lhdGlvbnMgd2lsbCBiZSBkZWxldGVkXG4gKiB1c2VyLmFkZFBpY3R1cmVzKFtwMSwgcDJdKSAvLyBBc3NvY2lhdGUgdXNlciB3aXRoIHRoZXNlIHR3byBwaWN0dXJlcywgYnV0IGRvbid0IHRvdWNoIGFueSBjdXJyZW50IGFzc29jaWF0aW9uc1xuICogYGBgXG4gKlxuICogWW91IGRvbid0IGhhdmUgdG8gcGFzcyBpbiBhIGNvbXBsZXRlIG9iamVjdCB0byB0aGUgYXNzb2NpYXRpb24gZnVuY3Rpb25zLCBpZiB5b3VyIGFzc29jaWF0ZWQgbW9kZWwgaGFzIGEgc2luZ2xlIHByaW1hcnkga2V5OlxuICpcbiAqIGBgYGpzXG4gKiB1c2VyLmFkZFBpY3R1cmUocmVxLnF1ZXJ5LnBpZCkgLy8gSGVyZSBwaWQgaXMganVzdCBhbiBpbnRlZ2VyLCByZXByZXNlbnRpbmcgdGhlIHByaW1hcnkga2V5IG9mIHRoZSBwaWN0dXJlXG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBhYm92ZSB3ZSBoYXZlIHNwZWNpZmllZCB0aGF0IGEgdXNlciBiZWxvbmdzIHRvIGhpcyBwcm9maWxlIHBpY3R1cmUuIENvbmNlcHR1YWxseSwgdGhpcyBtaWdodCBub3QgbWFrZSBzZW5zZSwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gYWRkIHRoZSBmb3JlaWduIGtleSB0byB0aGUgdXNlciBtb2RlbCB0aGlzIGlzIHRoZSB3YXkgdG8gZG8gaXQuXG4gKlxuICogTm90ZSBob3cgd2UgYWxzbyBzcGVjaWZpZWQgYGNvbnN0cmFpbnRzOiBmYWxzZWAgZm9yIHByb2ZpbGUgcGljdHVyZS4gVGhpcyBpcyBiZWNhdXNlIHdlIGFkZCBhIGZvcmVpZ24ga2V5IGZyb20gdXNlciB0byBwaWN0dXJlIChwcm9maWxlUGljdHVyZUlkKSwgYW5kIGZyb20gcGljdHVyZSB0byB1c2VyICh1c2VySWQpLiBJZiB3ZSB3ZXJlIHRvIGFkZCBmb3JlaWduIGtleXMgdG8gYm90aCwgaXQgd291bGQgY3JlYXRlIGEgY3ljbGljIGRlcGVuZGVuY3ksIGFuZCBzZXF1ZWxpemUgd291bGQgbm90IGtub3cgd2hpY2ggdGFibGUgdG8gY3JlYXRlIGZpcnN0LCBzaW5jZSB1c2VyIGRlcGVuZHMgb24gcGljdHVyZSwgYW5kIHBpY3R1cmUgZGVwZW5kcyBvbiB1c2VyLiBUaGVzZSBraW5kcyBvZiBwcm9ibGVtcyBhcmUgZGV0ZWN0ZWQgYnkgc2VxdWVsaXplIGJlZm9yZSB0aGUgbW9kZWxzIGFyZSBzeW5jZWQgdG8gdGhlIGRhdGFiYXNlLCBhbmQgeW91IHdpbGwgZ2V0IGFuIGVycm9yIGFsb25nIHRoZSBsaW5lcyBvZiBgRXJyb3I6IEN5Y2xpYyBkZXBlbmRlbmN5IGZvdW5kLiAndXNlcnMnIGlzIGRlcGVuZGVudCBvZiBpdHNlbGZgLiBJZiB5b3UgZW5jb3VudGVyIHRoaXMsIHlvdSBzaG91bGQgZWl0aGVyIGRpc2FibGUgc29tZSBjb25zdHJhaW50cywgb3IgcmV0aGluayB5b3VyIGFzc29jaWF0aW9ucyBjb21wbGV0ZWx5LlxuICovXG5jbGFzcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TW9kZWx9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TW9kZWx9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2NvcGUgPSBvcHRpb25zLnNjb3BlO1xuICAgIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPSB0aGlzLnNvdXJjZSA9PT0gdGhpcy50YXJnZXQ7XG4gICAgdGhpcy5hcyA9IG9wdGlvbnMuYXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgYXNzb2NpYXRpb24uIE9uZSBvZiBgSGFzTWFueWAsIGBCZWxvbmdzVG9gLCBgSGFzT25lYCwgYEJlbG9uZ3NUb01hbnlgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gJyc7XG5cbiAgICBpZiAoc291cmNlLmhhc0FsaWFzKG9wdGlvbnMuYXMpKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcihgWW91IGhhdmUgdXNlZCB0aGUgYWxpYXMgJHtvcHRpb25zLmFzfSBpbiB0d28gc2VwYXJhdGUgYXNzb2NpYXRpb25zLiBgICtcbiAgICAgICdBbGlhc2VkIGFzc29jaWF0aW9ucyBtdXN0IGhhdmUgdW5pcXVlIGFsaWFzZXMuJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBpbnB1dCBpdCBtYXkgYmUgYXJyYXkgb3Igc2luZ2xlIG9iaiwgaW5zdGFuY2Ugb3IgcHJpbWFyeSBrZXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBidWlsdCBvYmplY3RzXG4gICAqL1xuICB0b0luc3RhbmNlQXJyYXkoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0Lm1hcChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHJldHVybiBlbGVtZW50O1xuXG4gICAgICBjb25zdCB0bXBJbnN0YW5jZSA9IHt9O1xuICAgICAgdG1wSW5zdGFuY2VbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBlbGVtZW50O1xuXG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQuYnVpbGQodG1wSW5zdGFuY2UsIHsgaXNOZXdSZWNvcmQ6IGZhbHNlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgIHJldHVybiB0aGlzLmFzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzb2NpYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYmVsb25ncy10bycpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoJy4vaGFzLW1hbnknKTtcbmNvbnN0IEhhc09uZSA9IHJlcXVpcmUoJy4vaGFzLW9uZScpO1xuY29uc3QgQXNzb2NpYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLkFzc29jaWF0aW9uRXJyb3I7XG5jb25zdCBFbXB0eVJlc3VsdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuRW1wdHlSZXN1bHRFcnJvcjtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzJyk7XG5cbi8qKlxuICogTWFueS10by1tYW55IGFzc29jaWF0aW9uIHdpdGggYSBqb2luIHRhYmxlLlxuICpcbiAqIFdoZW4gdGhlIGpvaW4gdGFibGUgaGFzIGFkZGl0aW9uYWwgYXR0cmlidXRlcywgdGhlc2UgY2FuIGJlIHBhc3NlZCBpbiB0aGUgb3B0aW9ucyBvYmplY3Q6XG4gKlxuICogYGBganNcbiAqIFVzZXJQcm9qZWN0ID0gc2VxdWVsaXplLmRlZmluZSgndXNlcl9wcm9qZWN0Jywge1xuICogICByb2xlOiBTZXF1ZWxpemUuU1RSSU5HXG4gKiB9KTtcbiAqIFVzZXIuYmVsb25nc1RvTWFueShQcm9qZWN0LCB7IHRocm91Z2g6IFVzZXJQcm9qZWN0IH0pO1xuICogUHJvamVjdC5iZWxvbmdzVG9NYW55KFVzZXIsIHsgdGhyb3VnaDogVXNlclByb2plY3QgfSk7XG4gKiAvLyB0aHJvdWdoIGlzIHJlcXVpcmVkIVxuICpcbiAqIHVzZXIuYWRkUHJvamVjdChwcm9qZWN0LCB7IHRocm91Z2g6IHsgcm9sZTogJ21hbmFnZXInIH19KTtcbiAqIGBgYFxuICpcbiAqIEFsbCBtZXRob2RzIGFsbG93IHlvdSB0byBwYXNzIGVpdGhlciBhIHBlcnNpc3RlZCBpbnN0YW5jZSwgaXRzIHByaW1hcnkga2V5LCBvciBhIG1peHR1cmU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IHByb2plY3QgPSBhd2FpdCBQcm9qZWN0LmNyZWF0ZSh7IGlkOiAxMSB9KTtcbiAqIGF3YWl0IHVzZXIuYWRkUHJvamVjdHMoW3Byb2plY3QsIDEyXSk7XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBzZXQgc2V2ZXJhbCB0YXJnZXQgaW5zdGFuY2VzLCBidXQgd2l0aCBkaWZmZXJlbnQgYXR0cmlidXRlcyB5b3UgaGF2ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZXMgb24gdGhlIGluc3RhbmNlLCB1c2luZyBhIHByb3BlcnR5IHdpdGggdGhlIG5hbWUgb2YgdGhlIHRocm91Z2ggbW9kZWw6XG4gKlxuICogYGBganNcbiAqIHAxLlVzZXJQcm9qZWN0cyA9IHtcbiAqICAgc3RhcnRlZDogdHJ1ZVxuICogfVxuICogdXNlci5zZXRQcm9qZWN0cyhbcDEsIHAyXSwgeyB0aHJvdWdoOiB7IHN0YXJ0ZWQ6IGZhbHNlIH19KSAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZSwgYnV0IHAxIG92ZXJyaWRlcyB0aGF0LlxuICogYGBgXG4gKlxuICogU2ltaWxhcmx5LCB3aGVuIGZldGNoaW5nIHRocm91Z2ggYSBqb2luIHRhYmxlIHdpdGggY3VzdG9tIGF0dHJpYnV0ZXMsIHRoZXNlIGF0dHJpYnV0ZXMgd2lsbCBiZSBhdmFpbGFibGUgYXMgYW4gb2JqZWN0IHdpdGggdGhlIG5hbWUgb2YgdGhlIHRocm91Z2ggbW9kZWwuXG4gKiBgYGBqc1xuICogY29uc3QgcHJvamVjdHMgPSBhd2FpdCB1c2VyLmdldFByb2plY3RzKCk7XG4gKiBjb25zdCBwMSA9IHByb2plY3RzWzBdO1xuICogcDEuVXNlclByb2plY3RzLnN0YXJ0ZWQgLy8gSXMgdGhpcyBwcm9qZWN0IHN0YXJ0ZWQgeWV0P1xuICogfSlcbiAqIGBgYFxuICpcbiAqIEluIHRoZSBBUEkgcmVmZXJlbmNlIGJlbG93LCBhZGQgdGhlIG5hbWUgb2YgdGhlIGFzc29jaWF0aW9uIHRvIHRoZSBtZXRob2QsIGUuZy4gZm9yIGBVc2VyLmJlbG9uZ3NUb01hbnkoUHJvamVjdClgIHRoZSBnZXR0ZXIgd2lsbCBiZSBgdXNlci5nZXRQcm9qZWN0cygpYC5cbiAqXG4gKiBAc2VlIHtAbGluayBNb2RlbC5iZWxvbmdzVG9NYW55fVxuICovXG5jbGFzcyBCZWxvbmdzVG9NYW55IGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy50aHJvdWdoID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy50aHJvdWdoID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcihgJHtzb3VyY2UubmFtZX0uYmVsb25nc1RvTWFueSgke3RhcmdldC5uYW1lfSkgcmVxdWlyZXMgdGhyb3VnaCBvcHRpb24sIHBhc3MgZWl0aGVyIGEgc3RyaW5nIG9yIGEgbW9kZWxgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGhyb3VnaCA9IHtcbiAgICAgICAgbW9kZWw6IG9wdGlvbnMudGhyb3VnaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9ICdCZWxvbmdzVG9NYW55JztcbiAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNvdXJjZS5zZXF1ZWxpemU7XG4gICAgdGhpcy50aHJvdWdoID0geyAuLi50aGlzLm9wdGlvbnMudGhyb3VnaCB9O1xuICAgIHRoaXMuaXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmRvdWJsZUxpbmtlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmFzICYmIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKCdcXCdhc1xcJyBtdXN0IGJlIGRlZmluZWQgZm9yIG1hbnktdG8tbWFueSBzZWxmLWFzc29jaWF0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG5cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5hcykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLmFzO1xuICAgICAgICB0aGlzLmFzID0gdGhpcy5hcy5wbHVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgICBwbHVyYWw6IHRoaXMuYXMsXG4gICAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUucGx1cmFsO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgdGhpcy5jb21iaW5lZFRhYmxlTmFtZSA9IFV0aWxzLmNvbWJpbmVUYWJsZU5hbWVzKFxuICAgICAgdGhpcy5zb3VyY2UudGFibGVOYW1lLFxuICAgICAgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA/IHRoaXMuYXMgfHwgdGhpcy50YXJnZXQudGFibGVOYW1lIDogdGhpcy50YXJnZXQudGFibGVOYW1lXG4gICAgKTtcblxuICAgIC8qXG4gICAgKiBJZiBzZWxmIGFzc29jaWF0aW9uLCB0aGlzIGlzIHRoZSB0YXJnZXQgYXNzb2NpYXRpb24gLSBVbmxlc3Mgd2UgZmluZCBhIHBhaXJpbmcgYXNzb2NpYXRpb25cbiAgICAqL1xuICAgIGlmICh0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICogRmluZCBwYWlyZWQgYXNzb2NpYXRpb24gKGlmIGV4aXN0cylcbiAgICAqL1xuICAgIF8uZWFjaCh0aGlzLnRhcmdldC5hc3NvY2lhdGlvbnMsIGFzc29jaWF0aW9uID0+IHtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUgIT09ICdCZWxvbmdzVG9NYW55JykgcmV0dXJuO1xuICAgICAgaWYgKGFzc29jaWF0aW9uLnRhcmdldCAhPT0gdGhpcy5zb3VyY2UpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoLm1vZGVsID09PSBhc3NvY2lhdGlvbi5vcHRpb25zLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgdGhpcy5wYWlyZWQgPSBhc3NvY2lhdGlvbjtcbiAgICAgICAgYXNzb2NpYXRpb24ucGFpcmVkID0gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgKiBEZWZhdWx0L2dlbmVyYXRlZCBzb3VyY2UvdGFyZ2V0IGtleXNcbiAgICAqL1xuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0S2V5KSB7XG4gICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMub3B0aW9ucy50YXJnZXRLZXk7XG4gICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RGVmYXVsdCA9IHRydWU7XG4gICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRocm91Z2gubW9kZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmlzRGVmaW5lZCh0aGlzLnRocm91Z2gubW9kZWwpKSB7XG4gICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbCA9IHRoaXMuc2VxdWVsaXplLmRlZmluZSh0aGlzLnRocm91Z2gubW9kZWwsIHt9LCBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywge1xuICAgICAgICAgIHRhYmxlTmFtZTogdGhpcy50aHJvdWdoLm1vZGVsLFxuICAgICAgICAgIGluZGV4ZXM6IFtdLCAvL3dlIGRvbid0IHdhbnQgaW5kZXhlcyBoZXJlIChhcyByZWZlcmVuY2VkIGluICMyNDE2KVxuICAgICAgICAgIHBhcmFub2lkOiB0aGlzLnRocm91Z2gucGFyYW5vaWQgPyB0aGlzLnRocm91Z2gucGFyYW5vaWQgOiBmYWxzZSwgLy8gRGVmYXVsdCB0byBub24tcGFyYW5vaWQgam9pbiAocmVmZXJlbmNlZCBpbiAjMTE5OTEpXG4gICAgICAgICAgdmFsaWRhdGU6IHt9IC8vIERvbid0IHByb3BhZ2F0ZSBtb2RlbC1sZXZlbCB2YWxpZGF0aW9uc1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwgPSB0aGlzLnNlcXVlbGl6ZS5tb2RlbCh0aGlzLnRocm91Z2gubW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBfLnBpY2sodGhpcy50aHJvdWdoLm1vZGVsLm9wdGlvbnMsIFtcbiAgICAgICd0aW1lc3RhbXBzJywgJ2NyZWF0ZWRBdCcsICd1cGRhdGVkQXQnLCAnZGVsZXRlZEF0JywgJ3BhcmFub2lkJ1xuICAgIF0pKTtcblxuICAgIGlmICh0aGlzLnBhaXJlZCkge1xuICAgICAgbGV0IG5lZWRJbmplY3RQYWlyZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMudGFyZ2V0S2V5RGVmYXVsdCkge1xuICAgICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMucGFpcmVkLnNvdXJjZUtleTtcbiAgICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMucGFpcmVkLnNvdXJjZUtleUZpZWxkO1xuICAgICAgICB0aGlzLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWlyZWQudGFyZ2V0S2V5RGVmYXVsdCkge1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgcGFpcmVkLm90aGVyS2V5IGRlcGVuZHMgb24gcGFpcmVkLnRhcmdldEtleSxcbiAgICAgICAgLy8gc28gY2xlYW51cCBwcmV2aW91c2x5IHdyb25nIGdlbmVyYXRlZCBvdGhlcktleVxuICAgICAgICBpZiAodGhpcy5wYWlyZWQudGFyZ2V0S2V5ICE9PSB0aGlzLnNvdXJjZUtleSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV07XG4gICAgICAgICAgdGhpcy5wYWlyZWQudGFyZ2V0S2V5ID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgICAgICAgdGhpcy5wYWlyZWQudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnNvdXJjZUtleUZpZWxkO1xuICAgICAgICAgIHRoaXMucGFpcmVkLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG4gICAgICAgICAgbmVlZEluamVjdFBhaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLnBhaXJlZC5mb3JlaWduS2V5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpcmVkLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgICAvLyBJZiBwYWlyZWQgb3RoZXJLZXkgd2FzIGluZmVycmVkIHdlIHNob3VsZCBtYWtlIHN1cmUgdG8gY2xlYW4gaXQgdXBcbiAgICAgICAgLy8gYmVmb3JlIGFkZGluZyBhIG5ldyBvbmUgdGhhdCBtYXRjaGVzIHRoZSBmb3JlaWduS2V5XG4gICAgICAgIGlmICh0aGlzLnBhaXJlZC5vdGhlcktleSAhPT0gdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC5vdGhlcktleSA9IHRoaXMuZm9yZWlnbktleTtcbiAgICAgICAgICBuZWVkSW5qZWN0UGFpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmVlZEluamVjdFBhaXJlZCkge1xuICAgICAgICB0aGlzLnBhaXJlZC5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRocm91Z2gpIHtcbiAgICAgIHRoaXMudGhyb3VnaE1vZGVsID0gdGhpcy50aHJvdWdoLm1vZGVsO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy50YWJsZU5hbWUgPSB0aGlzLmNvbWJpbmVkTmFtZSA9IHRoaXMudGhyb3VnaC5tb2RlbCA9PT0gT2JqZWN0KHRoaXMudGhyb3VnaC5tb2RlbCkgPyB0aGlzLnRocm91Z2gubW9kZWwudGFibGVOYW1lIDogdGhpcy50aHJvdWdoLm1vZGVsO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcblxuICAgIC8vIEdldCBzaW5ndWxhciBhbmQgcGx1cmFsIG5hbWVzLCB0cnlpbmcgdG8gdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIsIHVubGVzcyB0aGUgbW9kZWwgZm9yYmlkcyBpdFxuICAgIGNvbnN0IHBsdXJhbCA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5wbHVyYWwpO1xuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcblxuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtwbHVyYWx9YCxcbiAgICAgIHNldDogYHNldCR7cGx1cmFsfWAsXG4gICAgICBhZGRNdWx0aXBsZTogYGFkZCR7cGx1cmFsfWAsXG4gICAgICBhZGQ6IGBhZGQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmU6IGByZW1vdmUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmVNdWx0aXBsZTogYHJlbW92ZSR7cGx1cmFsfWAsXG4gICAgICBoYXNTaW5nbGU6IGBoYXMke3Npbmd1bGFyfWAsXG4gICAgICBoYXNBbGw6IGBoYXMke3BsdXJhbH1gLFxuICAgICAgY291bnQ6IGBjb3VudCR7cGx1cmFsfWBcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKSB7XG4gICAgLypcbiAgICAqIERlZmF1bHQvZ2VuZXJhdGVkIGZvcmVpZ24vb3RoZXIga2V5c1xuICAgICovXG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXkgfHwgVXRpbHMuY2FtZWxpemUoXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLnNvdXJjZS5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgICAgdGhpcy5zb3VyY2VLZXlcbiAgICAgICAgXS5qb2luKCdfJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLm90aGVyS2V5KSkge1xuICAgICAgdGhpcy5vdGhlcktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5vdGhlcktleTtcbiAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLm90aGVyS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5vdGhlcktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm90aGVyS2V5KSB7XG4gICAgICAgIHRoaXMub3RoZXJLZXlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdGhlcktleUF0dHJpYnV0ZSA9IHt9O1xuICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMub3B0aW9ucy5vdGhlcktleSB8fCBVdGlscy5jYW1lbGl6ZShcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPyBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKSA6IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgICB0aGlzLnRhcmdldEtleVxuICAgICAgICBdLmpvaW4oJ18nKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgaWQgaXMgaW4gdGhlIHRhcmdldCB0YWJsZVxuICAvLyBvciBpbiBhbiBleHRyYSB0YWJsZSB3aGljaCBjb25uZWN0cyB0d28gdGFibGVzXG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25JZGVudGlmaWVyID0gdGhpcy5vdGhlcktleTtcblxuICAgIC8vIHJlbW92ZSBhbnkgUEtzIHByZXZpb3VzbHkgZGVmaW5lZCBieSBzZXF1ZWxpemVcbiAgICAvLyBidXQgaWdub3JlIGFueSBrZXlzIHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBhc3NvY2lhdGlvbiAoIzU4NjUpXG4gICAgXy5lYWNoKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkgPT09IHRydWUgJiYgYXR0cmlidXRlLl9hdXRvR2VuZXJhdGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSB0aGlzLmZvcmVpZ25LZXkgfHwgYXR0cmlidXRlTmFtZSA9PT0gdGhpcy5vdGhlcktleSkge1xuICAgICAgICAgIC8vIHRoaXMga2V5IGlzIHN0aWxsIG5lZWRlZCBhcyBpdCdzIHBhcnQgb2YgdGhlIGFzc29jaWF0aW9uXG4gICAgICAgICAgLy8gc28ganVzdCBzZXQgcHJpbWFyeUtleSB0byBmYWxzZVxuICAgICAgICAgIGF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbWFyeUtleURlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc291cmNlS2V5ID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV07XG4gICAgY29uc3Qgc291cmNlS2V5VHlwZSA9IHNvdXJjZUtleS50eXBlO1xuICAgIGNvbnN0IHNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2VLZXlGaWVsZDtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XTtcbiAgICBjb25zdCB0YXJnZXRLZXlUeXBlID0gdGFyZ2V0S2V5LnR5cGU7XG4gICAgY29uc3QgdGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldEtleUZpZWxkO1xuICAgIGNvbnN0IHNvdXJjZUF0dHJpYnV0ZSA9IHsgdHlwZTogc291cmNlS2V5VHlwZSwgLi4udGhpcy5mb3JlaWduS2V5QXR0cmlidXRlIH07XG4gICAgY29uc3QgdGFyZ2V0QXR0cmlidXRlID0geyB0eXBlOiB0YXJnZXRLZXlUeXBlLCAuLi50aGlzLm90aGVyS2V5QXR0cmlidXRlIH07XG5cbiAgICBpZiAodGhpcy5wcmltYXJ5S2V5RGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLnByaW1hcnlLZXkgPSBzb3VyY2VBdHRyaWJ1dGUucHJpbWFyeUtleSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRocm91Z2gudW5pcXVlICE9PSBmYWxzZSkge1xuICAgICAgbGV0IHVuaXF1ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVuaXF1ZUtleSA9PT0gJ3N0cmluZycgJiYgdGhpcy5vcHRpb25zLnVuaXF1ZUtleSAhPT0gJycpIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gdGhpcy5vcHRpb25zLnVuaXF1ZUtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IFt0aGlzLnRocm91Z2gubW9kZWwudGFibGVOYW1lLCB0aGlzLmZvcmVpZ25LZXksIHRoaXMub3RoZXJLZXksICd1bmlxdWUnXS5qb2luKCdfJyk7XG4gICAgICB9XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUudW5pcXVlID0gc291cmNlQXR0cmlidXRlLnVuaXF1ZSA9IHVuaXF1ZUtleTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0pIHtcbiAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldID0ge1xuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgc291cmNlQXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLnNvdXJjZS5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiBzb3VyY2VLZXlGaWVsZFxuICAgICAgfTtcbiAgICAgIC8vIEZvciB0aGUgc291cmNlIGF0dHJpYnV0ZSB0aGUgcGFzc2VkIG9wdGlvbiBpcyB0aGUgcHJpb3JpdHlcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLm9uRGVsZXRlO1xuICAgICAgc291cmNlQXR0cmlidXRlLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0ub25VcGRhdGU7XG5cbiAgICAgIGlmICghc291cmNlQXR0cmlidXRlLm9uRGVsZXRlKSBzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUgPSAnQ0FTQ0FERSc7XG4gICAgICBpZiAoIXNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSkgc291cmNlQXR0cmlidXRlLm9uVXBkYXRlID0gJ0NBU0NBREUnO1xuXG4gICAgICB0YXJnZXRBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMudGFyZ2V0LmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IHRhcmdldEtleUZpZWxkXG4gICAgICB9O1xuICAgICAgLy8gQnV0IHRoZSBmb3IgdGFyZ2V0IGF0dHJpYnV0ZSB0aGUgcHJldmlvdXNseSBkZWZpbmVkIG9wdGlvbiBpcyB0aGUgcHJpb3JpdHkgKHNpbmNlIGl0IGNvdWxkJ3ZlIGJlZW4gc2V0IGJ5IGFub3RoZXIgYmVsb25nc1RvTWFueSBjYWxsKVxuICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0ub25EZWxldGUgfHwgdGhpcy5vcHRpb25zLm9uRGVsZXRlO1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0ub25VcGRhdGUgfHwgdGhpcy5vcHRpb25zLm9uVXBkYXRlO1xuXG4gICAgICBpZiAoIXRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSkgdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlID0gJ0NBU0NBREUnO1xuICAgICAgaWYgKCF0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUpIHRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSA9ICdDQVNDQURFJztcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHNvdXJjZUF0dHJpYnV0ZSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSwgdGFyZ2V0QXR0cmlidXRlKTtcblxuICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yZWZyZXNoQXR0cmlidXRlcygpO1xuXG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25JZGVudGlmaWVyRmllbGQgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5maWVsZCB8fCB0aGlzLm90aGVyS2V5O1xuXG4gICAgaWYgKHRoaXMucGFpcmVkICYmICF0aGlzLnBhaXJlZC5mb3JlaWduSWRlbnRpZmllckZpZWxkKSB7XG4gICAgICB0aGlzLnBhaXJlZC5mb3JlaWduSWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldLmZpZWxkIHx8IHRoaXMucGFpcmVkLm90aGVyS2V5O1xuICAgIH1cblxuICAgIHRoaXMudG9Tb3VyY2UgPSBuZXcgQmVsb25nc1RvKHRoaXMudGhyb3VnaC5tb2RlbCwgdGhpcy5zb3VyY2UsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleVxuICAgIH0pO1xuICAgIHRoaXMubWFueUZyb21Tb3VyY2UgPSBuZXcgSGFzTWFueSh0aGlzLnNvdXJjZSwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXlcbiAgICB9KTtcbiAgICB0aGlzLm9uZUZyb21Tb3VyY2UgPSBuZXcgSGFzT25lKHRoaXMuc291cmNlLCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleSxcbiAgICAgIHNvdXJjZUtleTogdGhpcy5zb3VyY2VLZXksXG4gICAgICBhczogdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICB9KTtcblxuICAgIHRoaXMudG9UYXJnZXQgPSBuZXcgQmVsb25nc1RvKHRoaXMudGhyb3VnaC5tb2RlbCwgdGhpcy50YXJnZXQsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXlcbiAgICB9KTtcbiAgICB0aGlzLm1hbnlGcm9tVGFyZ2V0ID0gbmV3IEhhc01hbnkodGhpcy50YXJnZXQsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleVxuICAgIH0pO1xuICAgIHRoaXMub25lRnJvbVRhcmdldCA9IG5ldyBIYXNPbmUodGhpcy50YXJnZXQsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleSxcbiAgICAgIHNvdXJjZUtleTogdGhpcy50YXJnZXRLZXksXG4gICAgICBhczogdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnBhaXJlZCAmJiB0aGlzLnBhaXJlZC5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgIHRoaXMucGFpcmVkLnRvVGFyZ2V0ID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLCB0aGlzLnBhaXJlZC50YXJnZXQsIHtcbiAgICAgICAgZm9yZWlnbktleTogdGhpcy5wYWlyZWQub3RoZXJLZXlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnBhaXJlZC5vbmVGcm9tVGFyZ2V0ID0gbmV3IEhhc09uZSh0aGlzLnBhaXJlZC50YXJnZXQsIHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwsIHtcbiAgICAgICAgZm9yZWlnbktleTogdGhpcy5wYWlyZWQub3RoZXJLZXksXG4gICAgICAgIHNvdXJjZUtleTogdGhpcy5wYWlyZWQudGFyZ2V0S2V5LFxuICAgICAgICBhczogdGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gWydnZXQnLCAnY291bnQnLCAnaGFzU2luZ2xlJywgJ2hhc0FsbCcsICdzZXQnLCAnYWRkJywgJ2FkZE11bHRpcGxlJywgJ3JlbW92ZScsICdyZW1vdmVNdWx0aXBsZScsICdjcmVhdGUnXTtcbiAgICBjb25zdCBhbGlhc2VzID0ge1xuICAgICAgaGFzU2luZ2xlOiAnaGFzJyxcbiAgICAgIGhhc0FsbDogJ2hhcycsXG4gICAgICBhZGRNdWx0aXBsZTogJ2FkZCcsXG4gICAgICByZW1vdmVNdWx0aXBsZTogJ3JlbW92ZSdcbiAgICB9O1xuXG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzLCBhbGlhc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXZlcnl0aGluZyBjdXJyZW50bHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMsIHVzaW5nIGFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZS5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWx9IGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBpbnN0YW5jZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2hlcmVdIEFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZSB0byBsaW1pdCB0aGUgYXNzb2NpYXRlZCBtb2RlbHNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWFdIEFwcGx5IGEgc2NoZW1hIG9uIHRoZSByZWxhdGVkIG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50aHJvdWdoLndoZXJlXSBBbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UgYXBwbGllZCB0byB0aHJvdWdoIG1vZGVsIChqb2luIHRhYmxlKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRocm91Z2gucGFyYW5vaWQ9dHJ1ZV0gSWYgdHJ1ZSwgb25seSBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGUgam9pbiB0YWJsZS4gSWYgZmFsc2UsIGJvdGggZGVsZXRlZCBhbmQgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHJldHVybmVkLiBPbmx5IGFwcGxpZXMgaWYgdGhyb3VnaCBtb2RlbCBpcyBwYXJhbm9pZFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNb2RlbD4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcblxuICAgIGNvbnN0IHRocm91Z2ggPSB0aGlzLnRocm91Z2g7XG4gICAgbGV0IHNjb3BlV2hlcmU7XG4gICAgbGV0IHRocm91Z2hXaGVyZTtcblxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBzY29wZVdoZXJlID0geyAuLi50aGlzLnNjb3BlIH07XG4gICAgfVxuXG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHNjb3BlV2hlcmUsXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgaWYgKE9iamVjdCh0aHJvdWdoLm1vZGVsKSA9PT0gdGhyb3VnaC5tb2RlbCkge1xuICAgICAgdGhyb3VnaFdoZXJlID0ge307XG4gICAgICB0aHJvdWdoV2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG5cbiAgICAgIGlmICh0aHJvdWdoLnNjb3BlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhyb3VnaFdoZXJlLCB0aHJvdWdoLnNjb3BlKTtcbiAgICAgIH1cblxuICAgICAgLy9JZiBhIHVzZXIgcGFzcyBhIHdoZXJlIG9uIHRoZSBvcHRpb25zIHRocm91Z2ggb3B0aW9ucywgbWFrZSBhbiBcImFuZFwiIHdpdGggdGhlIGN1cnJlbnQgdGhyb3VnaFdoZXJlXG4gICAgICBpZiAob3B0aW9ucy50aHJvdWdoICYmIG9wdGlvbnMudGhyb3VnaC53aGVyZSkge1xuICAgICAgICB0aHJvdWdoV2hlcmUgPSB7XG4gICAgICAgICAgW09wLmFuZF06IFt0aHJvdWdoV2hlcmUsIG9wdGlvbnMudGhyb3VnaC53aGVyZV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlIHx8IFtdO1xuICAgICAgb3B0aW9ucy5pbmNsdWRlLnB1c2goe1xuICAgICAgICBhc3NvY2lhdGlvbjogdGhpcy5vbmVGcm9tVGFyZ2V0LFxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zLmpvaW5UYWJsZUF0dHJpYnV0ZXMsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBwYXJhbm9pZDogXy5nZXQob3B0aW9ucy50aHJvdWdoLCAncGFyYW5vaWQnLCB0cnVlKSxcbiAgICAgICAgd2hlcmU6IHRocm91Z2hXaGVyZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IG1vZGVsID0gdGhpcy50YXJnZXQ7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NvcGUnKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NoZW1hJykpIHtcbiAgICAgIG1vZGVsID0gbW9kZWwuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsLmZpbmRBbGwob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ291bnQgZXZlcnl0aGluZyBjdXJyZW50bHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMsIHVzaW5nIGFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gaW5zdGFuY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLndoZXJlXSBBbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UgdG8gbGltaXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgY291bnQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXF1ZWxpemUgPSB0aGlzLnRhcmdldC5zZXF1ZWxpemU7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFtcbiAgICAgIFtzZXF1ZWxpemUuZm4oJ0NPVU5UJywgc2VxdWVsaXplLmNvbChbdGhpcy50YXJnZXQubmFtZSwgdGhpcy50YXJnZXRLZXlGaWVsZF0uam9pbignLicpKSksICdjb3VudCddXG4gICAgXTtcbiAgICBvcHRpb25zLmpvaW5UYWJsZUF0dHJpYnV0ZXMgPSBbXTtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldChpbnN0YW5jZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LmNvdW50LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgb25lIG9yIG1vcmUgaW5zdGFuY2UocykgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzLiBJZiBhIGxpc3Qgb2YgaW5zdGFuY2VzIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiBfYWxsXyBpbnN0YW5jZXMgYXJlIGFzc29jaWF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlIHRvIGNoZWNrIGZvciBhbiBhc3NvY2lhdGlvbiB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmdbXXxzdHJpbmd8bnVtYmVyW118bnVtYmVyfSBbaW5zdGFuY2VzXSBDYW4gYmUgYW4gYXJyYXkgb2YgaW5zdGFuY2VzIG9yIHRoZWlyIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGdldEFzc29jaWF0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGhhcyhzb3VyY2VJbnN0YW5jZSwgaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2NvcGU6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlczogW3RoaXMudGFyZ2V0S2V5XSxcbiAgICAgIGpvaW5UYWJsZUF0dHJpYnV0ZXM6IFtdXG4gICAgfTtcblxuICAgIGNvbnN0IGluc3RhbmNlUHJpbWFyeUtleXMgPSBpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS53aGVyZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3RoaXMudGFyZ2V0S2V5XTogaW5zdGFuY2VcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgeyBbT3Aub3JdOiBpbnN0YW5jZVByaW1hcnlLZXlzIH0sXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgY29uc3QgYXNzb2NpYXRlZE9iamVjdHMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlV2l0aChpbnN0YW5jZVByaW1hcnlLZXlzLCBhc3NvY2lhdGVkT2JqZWN0cyxcbiAgICAgIChhLCBiKSA9PiBfLmlzRXF1YWwoYVt0aGlzLnRhcmdldEtleV0sIGJbdGhpcy50YXJnZXRLZXldKSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXNzb2NpYXRlZCBtb2RlbHMgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBpbnN0YW5jZXMgb3IgdGhlaXIgcHJpbWFyeSBrZXlzLlxuICAgKiBFdmVyeXRoaW5nIHRoYXQgaXQgbm90IGluIHRoZSBwYXNzZWQgYXJyYXkgd2lsbCBiZSB1bi1hc3NvY2lhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2UgdG8gYXNzb2NpYXRlIG5ldyBpbnN0YW5jZXMgd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW25ld0Fzc29jaWF0ZWRPYmplY3RzXSBBIHNpbmdsZSBpbnN0YW5jZSBvciBwcmltYXJ5IGtleSwgb3IgYSBtaXhlZCBhcnJheSBvZiBwZXJzaXN0ZWQgaW5zdGFuY2VzIG9yIHByaW1hcnkga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIHRvIGB0aHJvdWdoLmZpbmRBbGxgLCBgYnVsa0NyZWF0ZWAsIGB1cGRhdGVgIGFuZCBgZGVzdHJveWBcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnZhbGlkYXRlXSBSdW4gdmFsaWRhdGlvbiBmb3IgdGhlIGpvaW4gbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnRocm91Z2hdIEFkZGl0aW9uYWwgYXR0cmlidXRlcyBmb3IgdGhlIGpvaW4gdGFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBuZXdBc3NvY2lhdGVkT2JqZWN0cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qgc291cmNlS2V5ID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy50YXJnZXRLZXk7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcjtcbiAgICBjb25zdCBmb3JlaWduSWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbklkZW50aWZpZXI7XG5cbiAgICBpZiAobmV3QXNzb2NpYXRlZE9iamVjdHMgPT09IG51bGwpIHtcbiAgICAgIG5ld0Fzc29jaWF0ZWRPYmplY3RzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Fzc29jaWF0ZWRPYmplY3RzID0gdGhpcy50b0luc3RhbmNlQXJyYXkobmV3QXNzb2NpYXRlZE9iamVjdHMpO1xuICAgIH1cbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAuLi50aGlzLnRocm91Z2guc2NvcGVcbiAgICB9O1xuXG4gICAgY29uc3QgdXBkYXRlQXNzb2NpYXRpb25zID0gY3VycmVudFJvd3MgPT4ge1xuICAgICAgY29uc3Qgb2Jzb2xldGVBc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlcyA9IG9wdGlvbnMudGhyb3VnaCB8fCB7fTtcblxuICAgICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IG5ld0Fzc29jaWF0ZWRPYmplY3RzLmZpbHRlcihvYmogPT5cbiAgICAgICAgIWN1cnJlbnRSb3dzLnNvbWUoY3VycmVudFJvdyA9PiBjdXJyZW50Um93W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKVxuICAgICAgKTtcblxuICAgICAgZm9yIChjb25zdCBjdXJyZW50Um93IG9mIGN1cnJlbnRSb3dzKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IG5ld0Fzc29jaWF0ZWRPYmplY3RzLmZpbmQob2JqID0+IGN1cnJlbnRSb3dbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpO1xuXG4gICAgICAgIGlmICghbmV3T2JqKSB7XG4gICAgICAgICAgb2Jzb2xldGVBc3NvY2lhdGlvbnMucHVzaChjdXJyZW50Um93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgdGhyb3VnaEF0dHJpYnV0ZXMgPSBuZXdPYmpbdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIC8vIFF1aWNrLWZpeCBmb3Igc3VidGxlIGJ1ZyB3aGVuIHVzaW5nIGV4aXN0aW5nIG9iamVjdHMgdGhhdCBtaWdodCBoYXZlIHRoZSB0aHJvdWdoIG1vZGVsIGF0dGFjaGVkIChub3QgYXMgYW4gYXR0cmlidXRlIG9iamVjdClcbiAgICAgICAgICBpZiAodGhyb3VnaEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiB0aGlzLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgICAgIHRocm91Z2hBdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRocm91Z2hBdHRyaWJ1dGVzIH07XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwudXBkYXRlKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogbmV3T2JqLmdldCh0YXJnZXRLZXkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Jzb2xldGVBc3NvY2lhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC5kZXN0cm95KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBvYnNvbGV0ZUFzc29jaWF0aW9ucy5tYXAob2Jzb2xldGVBc3NvY2lhdGlvbiA9PiBvYnNvbGV0ZUFzc29jaWF0aW9uW2ZvcmVpZ25JZGVudGlmaWVyXSksXG4gICAgICAgICAgICAgIC4uLnRoaXMudGhyb3VnaC5zY29wZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYnVsayA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKHVuYXNzb2NpYXRlZE9iamVjdCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgLi4udW5hc3NvY2lhdGVkT2JqZWN0W3RoaXMudGhyb3VnaC5tb2RlbC5uYW1lXSxcbiAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRhcmdldEtleSksXG4gICAgICAgICAgICAuLi50aGlzLnRocm91Z2guc2NvcGVcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGhyb3VnaC5tb2RlbC5idWxrQ3JlYXRlKGJ1bGssIHsgdmFsaWRhdGU6IHRydWUsIC4uLm9wdGlvbnMgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFJvd3MgPSBhd2FpdCB0aGlzLnRocm91Z2gubW9kZWwuZmluZEFsbCh7IC4uLm9wdGlvbnMsIHdoZXJlLCByYXc6IHRydWUgfSk7XG4gICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQXNzb2NpYXRpb25zKGN1cnJlbnRSb3dzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRW1wdHlSZXN1bHRFcnJvcikgcmV0dXJuIHVwZGF0ZUFzc29jaWF0aW9ucyhbXSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlIG9uZSBvciBzZXZlcmFsIHJvd3Mgd2l0aCBzb3VyY2UgaW5zdGFuY2UuIEl0IHdpbGwgbm90IHVuLWFzc29jaWF0ZSBhbnkgYWxyZWFkeSBhc3NvY2lhdGVkIGluc3RhbmNlXG4gICAqIHRoYXQgbWF5IGJlIG1pc3NpbmcgZnJvbSBgbmV3SW5zdGFuY2VzYC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2Ugc291cmNlIGluc3RhbmNlIHRvIGFzc29jaWF0ZSBuZXcgaW5zdGFuY2VzIHdpdGhcbiAgICogQHBhcmFtIHtNb2RlbHxNb2RlbFtdfHN0cmluZ1tdfHN0cmluZ3xudW1iZXJbXXxudW1iZXJ9IFtuZXdJbnN0YW5jZXNdIEEgc2luZ2xlIGluc3RhbmNlIG9yIHByaW1hcnkga2V5LCBvciBhIG1peGVkIGFycmF5IG9mIHBlcnNpc3RlZCBpbnN0YW5jZXMgb3IgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRocm91Z2guZmluZEFsbGAsIGBidWxrQ3JlYXRlYCBhbmQgYHVwZGF0ZWBcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnZhbGlkYXRlXSBSdW4gdmFsaWRhdGlvbiBmb3IgdGhlIGpvaW4gbW9kZWwuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50aHJvdWdoXSBBZGRpdGlvbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBqb2luIHRhYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZChzb3VyY2VJbnN0YW5jZSwgbmV3SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgLy8gSWYgbmV3SW5zdGFuY2VzIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBuby1vcFxuICAgIGlmICghbmV3SW5zdGFuY2VzKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgY29uc3Qgc291cmNlS2V5ID0gYXNzb2NpYXRpb24uc291cmNlS2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IGFzc29jaWF0aW9uLnRhcmdldEtleTtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gYXNzb2NpYXRpb24uaWRlbnRpZmllcjtcbiAgICBjb25zdCBmb3JlaWduSWRlbnRpZmllciA9IGFzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyO1xuICAgIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0gb3B0aW9ucy50aHJvdWdoIHx8IHt9O1xuXG4gICAgbmV3SW5zdGFuY2VzID0gYXNzb2NpYXRpb24udG9JbnN0YW5jZUFycmF5KG5ld0luc3RhbmNlcyk7XG5cbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBuZXdJbnN0YW5jZXMubWFwKG5ld0luc3RhbmNlID0+IG5ld0luc3RhbmNlLmdldCh0YXJnZXRLZXkpKSxcbiAgICAgIC4uLmFzc29jaWF0aW9uLnRocm91Z2guc2NvcGVcbiAgICB9O1xuXG4gICAgY29uc3QgdXBkYXRlQXNzb2NpYXRpb25zID0gY3VycmVudFJvd3MgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSBbXTtcbiAgICAgIGNvbnN0IGNoYW5nZWRBc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIG5ld0luc3RhbmNlcykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0Fzc29jaWF0aW9uID0gY3VycmVudFJvd3MgJiYgY3VycmVudFJvd3MuZmluZChjdXJyZW50ID0+IGN1cnJlbnRbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpO1xuXG4gICAgICAgIGlmICghZXhpc3RpbmdBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHVuYXNzb2NpYXRlZE9iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gb2JqW2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHsgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsIC4uLnRocm91Z2hBdHRyaWJ1dGVzIH07XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykuc29tZShhdHRyaWJ1dGUgPT4gYXR0cmlidXRlc1thdHRyaWJ1dGVdICE9PSBleGlzdGluZ0Fzc29jaWF0aW9uW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgICBjaGFuZ2VkQXNzb2NpYXRpb25zLnB1c2gob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBidWxrID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAodW5hc3NvY2lhdGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IHVuYXNzb2NpYXRlZE9iamVjdFthc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLCAuLi50aHJvdWdoQXR0cmlidXRlcyB9O1xuXG4gICAgICAgICAgYXR0cmlidXRlc1tpZGVudGlmaWVyXSA9IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpO1xuICAgICAgICAgIGF0dHJpYnV0ZXNbZm9yZWlnbklkZW50aWZpZXJdID0gdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0YXJnZXRLZXkpO1xuXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBhc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlKTtcblxuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuYnVsa0NyZWF0ZShidWxrLCB7IHZhbGlkYXRlOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBhc3NvYyBvZiBjaGFuZ2VkQXNzb2NpYXRpb25zKSB7XG4gICAgICAgIGxldCB0aHJvdWdoQXR0cmlidXRlcyA9IGFzc29jW2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLCAuLi50aHJvdWdoQXR0cmlidXRlcyB9O1xuICAgICAgICAvLyBRdWljay1maXggZm9yIHN1YnRsZSBidWcgd2hlbiB1c2luZyBleGlzdGluZyBvYmplY3RzIHRoYXQgbWlnaHQgaGF2ZSB0aGUgdGhyb3VnaCBtb2RlbCBhdHRhY2hlZCAobm90IGFzIGFuIGF0dHJpYnV0ZSBvYmplY3QpXG4gICAgICAgIGlmICh0aHJvdWdoQXR0cmlidXRlcyBpbnN0YW5jZW9mIGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgICB0aHJvdWdoQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaChhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnVwZGF0ZShhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgd2hlcmU6IHtcbiAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IGFzc29jLmdldCh0YXJnZXRLZXkpXG4gICAgICAgIH0gfSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3dzID0gYXdhaXQgYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5maW5kQWxsKHsgLi4ub3B0aW9ucywgd2hlcmUsIHJhdzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IFthc3NvY2lhdGlvbnNdID0gYXdhaXQgdXBkYXRlQXNzb2NpYXRpb25zKGN1cnJlbnRSb3dzKTtcbiAgICAgIHJldHVybiBhc3NvY2lhdGlvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVtcHR5UmVzdWx0RXJyb3IpIHJldHVybiB1cGRhdGVBc3NvY2lhdGlvbnMoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbi1hc3NvY2lhdGUgb25lIG9yIG1vcmUgaW5zdGFuY2UocykuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIGluc3RhbmNlIHRvIHVuIGFzc29jaWF0ZSBpbnN0YW5jZXMgd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nfHN0cmluZ1tdfG51bWJlcnxudW1iZXJbXX0gW29sZEFzc29jaWF0ZWRPYmplY3RzXSBDYW4gYmUgYW4gSW5zdGFuY2Ugb3IgaXRzIHByaW1hcnkga2V5LCBvciBhIG1peGVkIGFycmF5IG9mIGluc3RhbmNlcyBhbmQgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRocm91Z2guZGVzdHJveWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICByZW1vdmUoc291cmNlSW5zdGFuY2UsIG9sZEFzc29jaWF0ZWRPYmplY3RzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBvbGRBc3NvY2lhdGVkT2JqZWN0cyA9IGFzc29jaWF0aW9uLnRvSW5zdGFuY2VBcnJheShvbGRBc3NvY2lhdGVkT2JqZWN0cyk7XG5cbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFthc3NvY2lhdGlvbi5pZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLnNvdXJjZUtleSksXG4gICAgICBbYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXJdOiBvbGRBc3NvY2lhdGVkT2JqZWN0cy5tYXAobmV3SW5zdGFuY2UgPT4gbmV3SW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLnRhcmdldEtleSkpXG4gICAgfTtcblxuICAgIHJldHVybiBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmRlc3Ryb3koeyAuLi5vcHRpb25zLCB3aGVyZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGFzc29jaWF0ZWQgbW9kZWwgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc10gdmFsdWVzIGZvciB0YXJnZXQgbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBjcmVhdGUgYW5kIGFkZFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGhyb3VnaF0gQWRkaXRpb25hbCBhdHRyaWJ1dGVzIGZvciB0aGUgam9pbiB0YWJsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGZpZWxkczogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoYXNzb2NpYXRpb24uc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCBhc3NvY2lhdGlvbi5zY29wZSk7XG4gICAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcy5jb25jYXQoT2JqZWN0LmtleXMoYXNzb2NpYXRpb24uc2NvcGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHJlbGF0ZWQgbW9kZWwgaW5zdGFuY2VcbiAgICBjb25zdCBuZXdBc3NvY2lhdGVkT2JqZWN0ID0gYXdhaXQgYXNzb2NpYXRpb24udGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuXG4gICAgYXdhaXQgc291cmNlSW5zdGFuY2VbYXNzb2NpYXRpb24uYWNjZXNzb3JzLmFkZF0obmV3QXNzb2NpYXRlZE9iamVjdCwgXy5vbWl0KG9wdGlvbnMsIFsnZmllbGRzJ10pKTtcbiAgICByZXR1cm4gbmV3QXNzb2NpYXRlZE9iamVjdDtcbiAgfVxuXG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cblxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5wbHVyYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5wbHVyYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJlbG9uZ3NUb01hbnk7XG5tb2R1bGUuZXhwb3J0cy5CZWxvbmdzVG9NYW55ID0gQmVsb25nc1RvTWFueTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBCZWxvbmdzVG9NYW55O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG4vKipcbiAqIE9uZS10by1vbmUgYXNzb2NpYXRpb25cbiAqXG4gKiBJbiB0aGUgQVBJIHJlZmVyZW5jZSBiZWxvdywgYWRkIHRoZSBuYW1lIG9mIHRoZSBhc3NvY2lhdGlvbiB0byB0aGUgbWV0aG9kLCBlLmcuIGZvciBgVXNlci5iZWxvbmdzVG8oUHJvamVjdClgIHRoZSBnZXR0ZXIgd2lsbCBiZSBgdXNlci5nZXRQcm9qZWN0KClgLlxuICpcbiAqIEBzZWUge0BsaW5rIE1vZGVsLmJlbG9uZ3NUb31cbiAqL1xuY2xhc3MgQmVsb25nc1RvIGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gJ0JlbG9uZ3NUbyc7XG4gICAgdGhpcy5pc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcblxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgc2luZ3VsYXI6IHRoaXMuYXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXI7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLmFzLFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgXS5qb2luKCdfJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5pZGVudGlmaWVyID0gdGhpcy5mb3JlaWduS2V5O1xuICAgIGlmICh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuaWRlbnRpZmllcl0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmlkZW50aWZpZXJdLmZpZWxkIHx8IHRoaXMuaWRlbnRpZmllcjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0S2V5XG4gICAgICAmJiAhdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLm9wdGlvbnMudGFyZ2V0S2V5XVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBcIiR7dGhpcy5vcHRpb25zLnRhcmdldEtleX1cIiBwYXNzZWQgYXMgdGFyZ2V0S2V5LCBkZWZpbmUgdGhpcyBhdHRyaWJ1dGUgb24gbW9kZWwgXCIke3RoaXMudGFyZ2V0Lm5hbWV9XCIgZmlyc3RgKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMub3B0aW9ucy50YXJnZXRLZXkgfHwgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgdGhpcy50YXJnZXRLZXlJc1ByaW1hcnkgPSB0aGlzLnRhcmdldEtleSA9PT0gdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnRhcmdldElkZW50aWZpZXIgPSB0aGlzLnRhcmdldEtleTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5vcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy51c2VIb29rcztcblxuICAgIC8vIEdldCBzaW5ndWxhciBuYW1lLCB0cnlpbmcgdG8gdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIsIHVubGVzcyB0aGUgbW9kZWwgZm9yYmlkcyBpdFxuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcblxuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtzaW5ndWxhcn1gLFxuICAgICAgc2V0OiBgc2V0JHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRoZSBpZCBpcyBpbiB0aGUgc291cmNlIHRhYmxlXG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XToge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWUsXG4gICAgICAgIC4uLnRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCAoc291cmNlLmFsbG93TnVsbCA/ICdTRVQgTlVMTCcgOiAnTk8gQUNUSU9OJyk7XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgJ0NBU0NBREUnO1xuICAgIH1cblxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy50YXJnZXQsIHRoaXMuc291cmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMudGFyZ2V0S2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy5zb3VyY2UucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnNvdXJjZS5yZWZyZXNoQXR0cmlidXRlcygpO1xuXG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuXG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ3NldCcsICdjcmVhdGUnXTtcblxuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfEFycmF5PE1vZGVsPn0gaW5zdGFuY2VzIHNvdXJjZSBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICBbb3B0aW9ucy5zY2hlbWFdIEFwcGx5IGEgc2NoZW1hIG9uIHRoZSByZWxhdGVkIG1vZGVsXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRPbmV9IGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICBsZXQgVGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3Njb3BlJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY2hlbWEnKSkge1xuICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB3aGVyZVt0aGlzLnRhcmdldEtleV0gPSB7XG4gICAgICAgIFtPcC5pbl06IGluc3RhbmNlcy5tYXAoX2luc3RhbmNlID0+IF9pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldEtleUlzUHJpbWFyeSAmJiAhb3B0aW9ucy53aGVyZSkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0LmZpbmRCeVBrKGluc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHdoZXJlW3RoaXMudGFyZ2V0S2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgICAgb3B0aW9ucy5saW1pdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgP1xuICAgICAgeyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDpcbiAgICAgIHdoZXJlO1xuXG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFRhcmdldC5maW5kQWxsKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMudGFyZ2V0S2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBfaW5zdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRhcmdldC5maW5kT25lKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXNzb2NpYXRlZCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez88TW9kZWw+fHN0cmluZ3xudW1iZXJ9IFthc3NvY2lhdGVkSW5zdGFuY2VdIEFuIHBlcnNpc3RlZCBpbnN0YW5jZSBvciB0aGUgcHJpbWFyeSBrZXkgb2YgYW4gaW5zdGFuY2UgdG8gYXNzb2NpYXRlIHdpdGggdGhpcy4gUGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIHRoZSBhc3NvY2lhdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBvcHRpb25zIHBhc3NlZCB0byBgdGhpcy5zYXZlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNhdmU9dHJ1ZV0gU2tpcCBzYXZpbmcgdGhpcyBhZnRlciBzZXR0aW5nIHRoZSBmb3JlaWduIGtleSBpZiBmYWxzZS5cbiAgICpcbiAgICogIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBhc3NvY2lhdGVkSW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB2YWx1ZSA9IGFzc29jaWF0ZWRJbnN0YW5jZTtcblxuICAgIGlmIChhc3NvY2lhdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgdmFsdWUgPSBhc3NvY2lhdGVkSW5zdGFuY2VbdGhpcy50YXJnZXRLZXldO1xuICAgIH1cblxuICAgIHNvdXJjZUluc3RhbmNlLnNldCh0aGlzLmZvcmVpZ25LZXksIHZhbHVlKTtcblxuICAgIGlmIChvcHRpb25zLnNhdmUgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgZmllbGRzOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgIGFsbG93TnVsbDogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICBhc3NvY2lhdGlvbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gcGFzc2VzIHRoZSBjaGFuZ2VkIGZpZWxkIHRvIHNhdmUsIHNvIG9ubHkgdGhhdCBmaWVsZCBnZXQgdXBkYXRlZC5cbiAgICByZXR1cm4gYXdhaXQgc291cmNlSW5zdGFuY2Uuc2F2ZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGFzc29jaWF0ZWQgbW9kZWwgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXM9e31dIHZhbHVlcyB0byBjcmVhdGUgYXNzb2NpYXRlZCBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC5jcmVhdGVgIGFuZCBzZXRBc3NvY2lhdGlvbi5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjY3JlYXRlfSAgZm9yIGEgZnVsbCBleHBsYW5hdGlvbiBvZiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn0gVGhlIGNyZWF0ZWQgdGFyZ2V0IG1vZGVsXG4gICAqL1xuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IG5ld0Fzc29jaWF0ZWRPYmplY3QgPSBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzb3VyY2VJbnN0YW5jZVt0aGlzLmFjY2Vzc29ycy5zZXRdKG5ld0Fzc29jaWF0ZWRPYmplY3QsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ld0Fzc29jaWF0ZWRPYmplY3Q7XG4gIH1cblxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMuc2luZ3VsYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5zaW5ndWxhcjtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmVsb25nc1RvO1xubW9kdWxlLmV4cG9ydHMuQmVsb25nc1RvID0gQmVsb25nc1RvO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEJlbG9uZ3NUbztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuLyoqXG4gKiBPbmUtdG8tbWFueSBhc3NvY2lhdGlvblxuICpcbiAqIEluIHRoZSBBUEkgcmVmZXJlbmNlIGJlbG93LCBhZGQgdGhlIG5hbWUgb2YgdGhlIGFzc29jaWF0aW9uIHRvIHRoZSBtZXRob2QsIGUuZy4gZm9yIGBVc2VyLmhhc01hbnkoUHJvamVjdClgIHRoZSBnZXR0ZXIgd2lsbCBiZSBgdXNlci5nZXRQcm9qZWN0cygpYC5cbiAqIElmIHRoZSBhc3NvY2lhdGlvbiBpcyBhbGlhc2VkLCB1c2UgdGhlIGFsaWFzIGluc3RlYWQsIGUuZy4gYFVzZXIuaGFzTWFueShQcm9qZWN0LCB7IGFzOiAnam9icycgfSlgIHdpbGwgYmUgYHVzZXIuZ2V0Sm9icygpYC5cbiAqXG4gKiBAc2VlIHtAbGluayBNb2RlbC5oYXNNYW55fVxuICovXG5jbGFzcyBIYXNNYW55IGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gJ0hhc01hbnknO1xuICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc291cmNlLnNlcXVlbGl6ZTtcbiAgICB0aGlzLmlzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTjpNIGFzc29jaWF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGhhc01hbnkuIFVzZSBiZWxvbmdzVG9NYW55IGluc3RlYWQnKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogSWYgc2VsZiBhc3NvY2lhdGlvbiwgdGhpcyBpcyB0aGUgdGFyZ2V0IGFzc29jaWF0aW9uXG4gICAgKi9cbiAgICBpZiAodGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLmFzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMuYXM7XG4gICAgICAgIHRoaXMuYXMgPSB0aGlzLmFzLnBsdXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICAgIHBsdXJhbDogdGhpcy5hcyxcbiAgICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5wbHVyYWw7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZvcmVpZ24ga2V5IHNldHVwXG4gICAgICovXG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IFV0aWxzLmNhbWVsaXplKFxuICAgICAgICBbXG4gICAgICAgICAgdGhpcy5zb3VyY2Uub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICAgIHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgXS5qb2luKCdfJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogU291cmNlIGtleSBzZXR1cFxuICAgICAqL1xuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuXG4gICAgaWYgKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldKSB7XG4gICAgICB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMuc291cmNlS2V5O1xuICAgICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUZpZWxkO1xuICAgIH1cblxuICAgIC8vIEdldCBzaW5ndWxhciBhbmQgcGx1cmFsIG5hbWVzXG4gICAgLy8gdHJ5IHRvIHVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyLCB1bmxlc3MgdGhlIG1vZGVsIGZvcmJpZHMgaXRcbiAgICBjb25zdCBwbHVyYWwgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUucGx1cmFsKTtcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG5cbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtwbHVyYWx9YCxcbiAgICAgIHNldDogYHNldCR7cGx1cmFsfWAsXG4gICAgICBhZGRNdWx0aXBsZTogYGFkZCR7cGx1cmFsfWAsXG4gICAgICBhZGQ6IGBhZGQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmU6IGByZW1vdmUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmVNdWx0aXBsZTogYHJlbW92ZSR7cGx1cmFsfWAsXG4gICAgICBoYXNTaW5nbGU6IGBoYXMke3Npbmd1bGFyfWAsXG4gICAgICBoYXNBbGw6IGBoYXMke3BsdXJhbH1gLFxuICAgICAgY291bnQ6IGBjb3VudCR7cGx1cmFsfWBcbiAgICB9O1xuICB9XG5cbiAgLy8gdGhlIGlkIGlzIGluIHRoZSB0YXJnZXQgdGFibGVcbiAgLy8gb3IgaW4gYW4gZXh0cmEgdGFibGUgd2hpY2ggY29ubmVjdHMgdHdvIHRhYmxlc1xuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlLFxuICAgICAgICAuLi50aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IGZvciB1c2Ugd2l0aCBhZGRGb3JlaWduS2V5Q29uc3RyYWludHMsIHRvIGF2b2lkIHBvbGx1dGluZyB0aGlzLm9wdGlvbnMgaW4gY2FzZSBpdCBpcyBsYXRlciB1c2VkIGZvciBhIG46bVxuICAgIGNvbnN0IGNvbnN0cmFpbnRPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgY29uc3RyYWludE9wdGlvbnMub25EZWxldGUgPSBjb25zdHJhaW50T3B0aW9ucy5vbkRlbGV0ZSB8fCAodGFyZ2V0LmFsbG93TnVsbCA/ICdTRVQgTlVMTCcgOiAnQ0FTQ0FERScpO1xuICAgICAgY29uc3RyYWludE9wdGlvbnMub25VcGRhdGUgPSBjb25zdHJhaW50T3B0aW9ucy5vblVwZGF0ZSB8fCAnQ0FTQ0FERSc7XG4gICAgfVxuXG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnNvdXJjZSwgdGhpcy50YXJnZXQsIGNvbnN0cmFpbnRPcHRpb25zLCB0aGlzLnNvdXJjZUtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy50YXJnZXQucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLnNvdXJjZS5yZWZyZXNoQXR0cmlidXRlcygpO1xuXG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbktleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG5cbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gWydnZXQnLCAnY291bnQnLCAnaGFzU2luZ2xlJywgJ2hhc0FsbCcsICdzZXQnLCAnYWRkJywgJ2FkZE11bHRpcGxlJywgJ3JlbW92ZScsICdyZW1vdmVNdWx0aXBsZScsICdjcmVhdGUnXTtcbiAgICBjb25zdCBhbGlhc2VzID0ge1xuICAgICAgaGFzU2luZ2xlOiAnaGFzJyxcbiAgICAgIGhhc0FsbDogJ2hhcycsXG4gICAgICBhZGRNdWx0aXBsZTogJ2FkZCcsXG4gICAgICByZW1vdmVNdWx0aXBsZTogJ3JlbW92ZSdcbiAgICB9O1xuXG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzLCBhbGlhc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXZlcnl0aGluZyBjdXJyZW50bHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMsIHVzaW5nIGFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbHxBcnJheTxNb2RlbD59IGluc3RhbmNlcyBzb3VyY2UgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy53aGVyZV0gQW4gb3B0aW9uYWwgd2hlcmUgY2xhdXNlIHRvIGxpbWl0IHRoZSBhc3NvY2lhdGVkIG1vZGVsc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5zY29wZV0gQXBwbHkgYSBzY29wZSBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgb3IgcmVtb3ZlIGl0cyBkZWZhdWx0IHNjb3BlIGJ5IHBhc3NpbmcgZmFsc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNjaGVtYV0gQXBwbHkgYSBzY2hlbWEgb24gdGhlIHJlbGF0ZWQgbW9kZWxcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gIGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNb2RlbD4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcblxuICAgIGxldCBNb2RlbCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBsZXQgdmFsdWVzO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHdoZXJlLCB0aGlzLnNjb3BlKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB2YWx1ZXMgPSBpbnN0YW5jZXMubWFwKF9pbnN0YW5jZSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbWl0ICYmIGluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9wdGlvbnMuZ3JvdXBlZExpbWl0ID0ge1xuICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICAgIG9uOiB0aGlzLCAvLyBhc3NvY2lhdGlvblxuICAgICAgICAgIHZhbHVlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmxpbWl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgICBbT3AuaW5dOiB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZ3JvdXBlZExpbWl0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/XG4gICAgICB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOlxuICAgICAgd2hlcmU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY29wZScpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgTW9kZWwgPSBNb2RlbC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTW9kZWwgPSBNb2RlbC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzY2hlbWEnKSkge1xuICAgICAgTW9kZWwgPSBNb2RlbC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgTW9kZWwuZmluZEFsbChvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UpIHJldHVybiByZXN1bHRzO1xuXG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSldID0gW107XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0ucHVzaChfaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ291bnQgZXZlcnl0aGluZyBjdXJyZW50bHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMsIHVzaW5nIGFuIG9wdGlvbmFsIHdoZXJlIGNsYXVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgIGluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnNdIGZpbmQgJiBjb3VudCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zLndoZXJlXSBBbiBvcHRpb25hbCB3aGVyZSBjbGF1c2UgdG8gbGltaXQgdGhlIGFzc29jaWF0ZWQgbW9kZWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLnNjb3BlXSBBcHBseSBhIHNjb3BlIG9uIHRoZSByZWxhdGVkIG1vZGVsLCBvciByZW1vdmUgaXRzIGRlZmF1bHQgc2NvcGUgYnkgcGFzc2luZyBmYWxzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgY291bnQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW1xuICAgICAgW1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5mbihcbiAgICAgICAgICAnQ09VTlQnLFxuICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmNvbChgJHt0aGlzLnRhcmdldC5uYW1lfS4ke3RoaXMudGFyZ2V0LnByaW1hcnlLZXlGaWVsZH1gKVxuICAgICAgICApLFxuICAgICAgICAnY291bnQnXG4gICAgICBdXG4gICAgXTtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldChpbnN0YW5jZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LmNvdW50LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgb25lIG9yIG1vcmUgcm93cyBhcmUgYXNzb2NpYXRlZCB3aXRoIGB0aGlzYC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW3RhcmdldEluc3RhbmNlc10gQ2FuIGJlIGFuIGFycmF5IG9mIGluc3RhbmNlcyBvciB0aGVpciBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBnZXRBc3NvY2lhdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBoYXMoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0SW5zdGFuY2VzKSkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gW3RhcmdldEluc3RhbmNlc107XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzY29wZTogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0sXG4gICAgICByYXc6IHRydWVcbiAgICB9O1xuXG4gICAgd2hlcmVbT3Aub3JdID0gdGFyZ2V0SW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uud2hlcmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogaW5zdGFuY2VcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgY29uc3QgYXNzb2NpYXRlZE9iamVjdHMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID09PSB0YXJnZXRJbnN0YW5jZXMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXNzb2NpYXRlZCBtb2RlbHMgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBwZXJzaXN0ZWQgaW5zdGFuY2VzIG9yIHRoZWlyIHByaW1hcnkga2V5cy4gRXZlcnl0aGluZyB0aGF0IGlzIG5vdCBpbiB0aGUgcGFzc2VkIGFycmF5IHdpbGwgYmUgdW4tYXNzb2NpYXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBzb3VyY2VJbnN0YW5jZSBzb3VyY2UgaW5zdGFuY2UgdG8gYXNzb2NpYXRlIG5ldyBpbnN0YW5jZXMgd2l0aFxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW3RhcmdldEluc3RhbmNlc10gQW4gYXJyYXkgb2YgcGVyc2lzdGVkIGluc3RhbmNlcyBvciBwcmltYXJ5IGtleSBvZiBpbnN0YW5jZXMgdG8gYXNzb2NpYXRlIHdpdGggdGhpcy4gUGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIGFsbCBhc3NvY2lhdGlvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC5maW5kQWxsYCBhbmQgYHVwZGF0ZWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy52YWxpZGF0ZV0gUnVuIHZhbGlkYXRpb24gZm9yIHRoZSBqb2luIG1vZGVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0SW5zdGFuY2VzID09PSBudWxsKSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRBc3NvY2lhdGlvbnMgPSBhd2FpdCB0aGlzLmdldChzb3VyY2VJbnN0YW5jZSwgeyAuLi5vcHRpb25zLCBzY29wZTogZmFsc2UsIHJhdzogdHJ1ZSB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IG9ic29sZXRlQXNzb2NpYXRpb25zID0gb2xkQXNzb2NpYXRpb25zLmZpbHRlcihvbGQgPT5cbiAgICAgICF0YXJnZXRJbnN0YW5jZXMuZmluZChvYmogPT5cbiAgICAgICAgb2JqW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBvbGRbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHVuYXNzb2NpYXRlZE9iamVjdHMgPSB0YXJnZXRJbnN0YW5jZXMuZmlsdGVyKG9iaiA9PlxuICAgICAgIW9sZEFzc29jaWF0aW9ucy5maW5kKG9sZCA9PlxuICAgICAgICBvYmpbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG9sZFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgKVxuICAgICk7XG4gICAgbGV0IHVwZGF0ZVdoZXJlO1xuICAgIGxldCB1cGRhdGU7XG5cbiAgICBpZiAob2Jzb2xldGVBc3NvY2lhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlID0ge307XG4gICAgICB1cGRhdGVbdGhpcy5mb3JlaWduS2V5XSA9IG51bGw7XG5cbiAgICAgIHVwZGF0ZVdoZXJlID0ge1xuICAgICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IG9ic29sZXRlQXNzb2NpYXRpb25zLm1hcChhc3NvY2lhdGVkT2JqZWN0ID0+XG4gICAgICAgICAgYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgICApXG4gICAgICB9O1xuXG5cbiAgICAgIHByb21pc2VzLnB1c2godGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUoXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgd2hlcmU6IHVwZGF0ZVdoZXJlXG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH1cblxuICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVwZGF0ZVdoZXJlID0ge307XG5cbiAgICAgIHVwZGF0ZSA9IHt9O1xuICAgICAgdXBkYXRlW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuXG4gICAgICBPYmplY3QuYXNzaWduKHVwZGF0ZSwgdGhpcy5zY29wZSk7XG4gICAgICB1cGRhdGVXaGVyZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKHVuYXNzb2NpYXRlZE9iamVjdCA9PlxuICAgICAgICB1bmFzc29jaWF0ZWRPYmplY3RbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgICk7XG5cbiAgICAgIHByb21pc2VzLnB1c2godGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUoXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgd2hlcmU6IHVwZGF0ZVdoZXJlXG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIHJldHVybiBzb3VyY2VJbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGUgb25lIG9yIG1vcmUgdGFyZ2V0IHJvd3Mgd2l0aCBgdGhpc2AuIFRoaXMgbWV0aG9kIGFjY2VwdHMgYSBNb2RlbCAvIHN0cmluZyAvIG51bWJlciB0byBhc3NvY2lhdGUgYSBzaW5nbGUgcm93LFxuICAgKiBvciBhIG1peGVkIGFycmF5IG9mIE1vZGVsIC8gc3RyaW5nIC8gbnVtYmVycyB0byBhc3NvY2lhdGUgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge01vZGVsfE1vZGVsW118c3RyaW5nW118c3RyaW5nfG51bWJlcltdfG51bWJlcn0gW3RhcmdldEluc3RhbmNlc10gQSBzaW5nbGUgaW5zdGFuY2Ugb3IgcHJpbWFyeSBrZXksIG9yIGEgbWl4ZWQgYXJyYXkgb2YgcGVyc2lzdGVkIGluc3RhbmNlcyBvciBwcmltYXJ5IGtleXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LnVwZGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWRkKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGFyZ2V0SW5zdGFuY2VzKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblxuICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG5cbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KSxcbiAgICAgIC4uLnRoaXMuc2NvcGVcbiAgICB9O1xuXG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IHRhcmdldEluc3RhbmNlcy5tYXAodW5hc3NvY2lhdGVkT2JqZWN0ID0+XG4gICAgICAgIHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZSlcbiAgICAgIClcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCB7IC4uLm9wdGlvbnMsIHdoZXJlIH0pO1xuXG4gICAgcmV0dXJuIHNvdXJjZUluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuLWFzc29jaWF0ZSBvbmUgb3Igc2V2ZXJhbCB0YXJnZXQgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgaW5zdGFuY2UgdG8gdW4gYXNzb2NpYXRlIGluc3RhbmNlcyB3aXRoXG4gICAqIEBwYXJhbSB7TW9kZWx8TW9kZWxbXXxzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfSBbdGFyZ2V0SW5zdGFuY2VzXSBDYW4gYmUgYW4gSW5zdGFuY2Ugb3IgaXRzIHByaW1hcnkga2V5LCBvciBhIG1peGVkIGFycmF5IG9mIGluc3RhbmNlcyBhbmQgcHJpbWFyeSBrZXlzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gYHRhcmdldC51cGRhdGVgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBudWxsXG4gICAgfTtcblxuICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG5cbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpLFxuICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiB0YXJnZXRJbnN0YW5jZXMubWFwKHRhcmdldEluc3RhbmNlID0+XG4gICAgICAgIHRhcmdldEluc3RhbmNlLmdldCh0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlKVxuICAgICAgKVxuICAgIH07XG5cbiAgICBhd2FpdCB0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIHsgLi4ub3B0aW9ucywgd2hlcmUgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGFzc29jaWF0ZWQgbW9kZWwgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc10gdmFsdWVzIGZvciB0YXJnZXQgbW9kZWwgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LmNyZWF0ZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGZpZWxkczogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlcyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyh0aGlzLnNjb3BlKSkge1xuICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IHRoaXMuc2NvcGVbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSBvcHRpb25zLmZpZWxkcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVzW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcykgb3B0aW9ucy5maWVsZHMucHVzaCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cblxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5wbHVyYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5wbHVyYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc01hbnk7XG5tb2R1bGUuZXhwb3J0cy5IYXNNYW55ID0gSGFzTWFueTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBIYXNNYW55O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG4vKipcbiAqIE9uZS10by1vbmUgYXNzb2NpYXRpb25cbiAqXG4gKiBJbiB0aGUgQVBJIHJlZmVyZW5jZSBiZWxvdywgYWRkIHRoZSBuYW1lIG9mIHRoZSBhc3NvY2lhdGlvbiB0byB0aGUgbWV0aG9kLCBlLmcuIGZvciBgVXNlci5oYXNPbmUoUHJvamVjdClgIHRoZSBnZXR0ZXIgd2lsbCBiZSBgdXNlci5nZXRQcm9qZWN0KClgLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgYGJlbG9uZ3NUb2Agd2l0aCBvbmUgZXhjZXB0aW9uIC0gVGhlIGZvcmVpZ24ga2V5IHdpbGwgYmUgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG1vZGVsLlxuICpcbiAqIEBzZWUge0BsaW5rIE1vZGVsLmhhc09uZX1cbiAqL1xuY2xhc3MgSGFzT25lIGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gJ0hhc09uZSc7XG4gICAgdGhpcy5pc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcblxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgc2luZ3VsYXI6IHRoaXMuYXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXI7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoXG4gICAgICAgIFtcbiAgICAgICAgICBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLm9wdGlvbnMuYXMgfHwgdGhpcy5zb3VyY2UubmFtZSksXG4gICAgICAgICAgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICBdLmpvaW4oJ18nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMuc291cmNlS2V5XG4gICAgICAmJiAhdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLm9wdGlvbnMuc291cmNlS2V5XVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBcIiR7dGhpcy5vcHRpb25zLnNvdXJjZUtleX1cIiBwYXNzZWQgYXMgc291cmNlS2V5LCBkZWZpbmUgdGhpcyBhdHRyaWJ1dGUgb24gbW9kZWwgXCIke3RoaXMuc291cmNlLm5hbWV9XCIgZmlyc3RgKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICB0aGlzLnNvdXJjZUtleUlzUHJpbWFyeSA9IHRoaXMuc291cmNlS2V5ID09PSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuXG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLm9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLnVzZUhvb2tzO1xuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIH1cblxuICAgIC8vIEdldCBzaW5ndWxhciBuYW1lLCB0cnlpbmcgdG8gdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIsIHVubGVzcyB0aGUgbW9kZWwgZm9yYmlkcyBpdFxuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcblxuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtzaW5ndWxhcn1gLFxuICAgICAgc2V0OiBgc2V0JHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRoZSBpZCBpcyBpbiB0aGUgdGFyZ2V0IHRhYmxlXG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XToge1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWUsXG4gICAgICAgIC4uLnRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCAodGFyZ2V0LmFsbG93TnVsbCA/ICdTRVQgTlVMTCcgOiAnQ0FTQ0FERScpO1xuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8ICdDQVNDQURFJztcbiAgICB9XG5cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMuc291cmNlLCB0aGlzLnRhcmdldCwgdGhpcy5vcHRpb25zLCB0aGlzLnNvdXJjZUtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy50YXJnZXQucmVmcmVzaEF0dHJpYnV0ZXMoKTtcblxuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcblxuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdzZXQnLCAnY3JlYXRlJ107XG5cbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbHxBcnJheTxNb2RlbD59IGluc3RhbmNlcyBzb3VyY2UgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zXSBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuc2NvcGVdIEFwcGx5IGEgc2NvcGUgb24gdGhlIHJlbGF0ZWQgbW9kZWwsIG9yIHJlbW92ZSBpdHMgZGVmYXVsdCBzY29wZSBieSBwYXNzaW5nIGZhbHNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWFdIEFwcGx5IGEgc2NoZW1hIG9uIHRoZSByZWxhdGVkIG1vZGVsXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRPbmV9IGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcblxuICAgIGxldCBUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2NvcGUnKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NjaGVtYScpKSB7XG4gICAgICBUYXJnZXQgPSBUYXJnZXQuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgIFtPcC5pbl06IGluc3RhbmNlcy5tYXAoX2luc3RhbmNlID0+IF9pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24od2hlcmUsIHRoaXMuc2NvcGUpO1xuICAgIH1cblxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID9cbiAgICAgIHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6XG4gICAgICB3aGVyZTtcblxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBUYXJnZXQuZmluZEFsbChvcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldID0gX2luc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBUYXJnZXQuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFzc29jaWF0ZWQgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9IHNvdXJjZUluc3RhbmNlIHRoZSBzb3VyY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/PE1vZGVsPnxzdHJpbmd8bnVtYmVyfSBbYXNzb2NpYXRlZEluc3RhbmNlXSBBbiBwZXJzaXN0ZWQgaW5zdGFuY2Ugb3IgdGhlIHByaW1hcnkga2V5IG9mIGFuIGluc3RhbmNlIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMuIFBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgIHRvIHJlbW92ZSB0aGUgYXNzb2NpYXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgdG8gZ2V0QXNzb2NpYXRpb24gYW5kIGB0YXJnZXQuc2F2ZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIGFzc29jaWF0ZWRJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHNjb3BlOiBmYWxzZSB9O1xuXG4gICAgY29uc3Qgb2xkSW5zdGFuY2UgPSBhd2FpdCBzb3VyY2VJbnN0YW5jZVt0aGlzLmFjY2Vzc29ycy5nZXRdKG9wdGlvbnMpO1xuICAgIC8vIFRPRE8gVXNlIGVxdWFscyBtZXRob2Qgb25jZSAjNTYwNSBpcyByZXNvbHZlZFxuICAgIGNvbnN0IGFscmVhZHlBc3NvY2lhdGVkID0gb2xkSW5zdGFuY2UgJiYgYXNzb2NpYXRlZEluc3RhbmNlICYmIHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVzLmV2ZXJ5KGF0dHJpYnV0ZSA9PlxuICAgICAgb2xkSW5zdGFuY2UuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IChhc3NvY2lhdGVkSW5zdGFuY2UuZ2V0ID8gYXNzb2NpYXRlZEluc3RhbmNlLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pIDogYXNzb2NpYXRlZEluc3RhbmNlKVxuICAgICk7XG5cbiAgICBpZiAob2xkSW5zdGFuY2UgJiYgIWFscmVhZHlBc3NvY2lhdGVkKSB7XG4gICAgICBvbGRJbnN0YW5jZVt0aGlzLmZvcmVpZ25LZXldID0gbnVsbDtcblxuICAgICAgYXdhaXQgb2xkSW5zdGFuY2Uuc2F2ZSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGZpZWxkczogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICAgIGFsbG93TnVsbDogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICAgIGFzc29jaWF0aW9uOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFzc29jaWF0ZWRJbnN0YW5jZSAmJiAhYWxyZWFkeUFzc29jaWF0ZWQpIHtcbiAgICAgIGlmICghKGFzc29jaWF0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSkge1xuICAgICAgICBjb25zdCB0bXBJbnN0YW5jZSA9IHt9O1xuICAgICAgICB0bXBJbnN0YW5jZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IGFzc29jaWF0ZWRJbnN0YW5jZTtcbiAgICAgICAgYXNzb2NpYXRlZEluc3RhbmNlID0gdGhpcy50YXJnZXQuYnVpbGQodG1wSW5zdGFuY2UsIHtcbiAgICAgICAgICBpc05ld1JlY29yZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oYXNzb2NpYXRlZEluc3RhbmNlLCB0aGlzLnNjb3BlKTtcbiAgICAgIGFzc29jaWF0ZWRJbnN0YW5jZS5zZXQodGhpcy5mb3JlaWduS2V5LCBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUpKTtcblxuICAgICAgcmV0dXJuIGFzc29jaWF0ZWRJbnN0YW5jZS5zYXZlKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYXNzb2NpYXRlZCBtb2RlbCBhbmQgYXNzb2NpYXRlIGl0IHdpdGggdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gc291cmNlSW5zdGFuY2UgdGhlIHNvdXJjZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlcz17fV0gdmFsdWVzIHRvIGNyZWF0ZSBhc3NvY2lhdGVkIG1vZGVsIGluc3RhbmNlIHdpdGhcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCB0byBgdGFyZ2V0LmNyZWF0ZWAgYW5kIHNldEFzc29jaWF0aW9uLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNjcmVhdGV9IGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59IFRoZSBjcmVhdGVkIHRhcmdldCBtb2RlbFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXModGhpcy5zY29wZSkpIHtcbiAgICAgICAgdmFsdWVzW2F0dHJpYnV0ZV0gPSB0aGlzLnNjb3BlW2F0dHJpYnV0ZV07XG4gICAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc1t0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5QXR0cmlidXRlKTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godGhpcy5mb3JlaWduS2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cblxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMuc2luZ3VsYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5zaW5ndWxhcjtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzT25lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja05hbWluZ0NvbGxpc2lvbihhc3NvY2lhdGlvbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFzc29jaWF0aW9uLnNvdXJjZS5yYXdBdHRyaWJ1dGVzLCBhc3NvY2lhdGlvbi5hcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTmFtaW5nIGNvbGxpc2lvbiBiZXR3ZWVuIGF0dHJpYnV0ZSAnJHthc3NvY2lhdGlvbi5hc30nYCArXG4gICAgICBgIGFuZCBhc3NvY2lhdGlvbiAnJHthc3NvY2lhdGlvbi5hc30nIG9uIG1vZGVsICR7YXNzb2NpYXRpb24uc291cmNlLm5hbWV9YCArXG4gICAgICAnLiBUbyByZW1lZHkgdGhpcywgY2hhbmdlIGVpdGhlciBmb3JlaWduS2V5IG9yIGFzIGluIHlvdXIgYXNzb2NpYXRpb24gZGVmaW5pdGlvbidcbiAgICApO1xuICB9XG59XG5leHBvcnRzLmNoZWNrTmFtaW5nQ29sbGlzaW9uID0gY2hlY2tOYW1pbmdDb2xsaXNpb247XG5cbmZ1bmN0aW9uIGFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGUsIHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zLCBrZXkpIHtcbiAgLy8gRksgY29uc3RyYWludHMgYXJlIG9wdC1pbjogdXNlcnMgbXVzdCBlaXRoZXIgc2V0IGBmb3JlaWduS2V5Q29uc3RyYWludHNgXG4gIC8vIG9uIHRoZSBhc3NvY2lhdGlvbiwgb3IgcmVxdWVzdCBhbiBgb25EZWxldGVgIG9yIGBvblVwZGF0ZWAgYmVoYXZpb3JcblxuICBpZiAob3B0aW9ucy5mb3JlaWduS2V5Q29uc3RyYWludCB8fCBvcHRpb25zLm9uRGVsZXRlIHx8IG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICAvLyBGaW5kIHByaW1hcnkga2V5czogY29tcG9zaXRlIGtleXMgbm90IHN1cHBvcnRlZCB3aXRoIHRoaXMgYXBwcm9hY2hcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZS5wcmltYXJ5S2V5cylcbiAgICAgIC5tYXAocHJpbWFyeUtleUF0dHJpYnV0ZSA9PiBzb3VyY2UucmF3QXR0cmlidXRlc1twcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCB8fCBwcmltYXJ5S2V5QXR0cmlidXRlKTtcblxuICAgIGlmIChwcmltYXJ5S2V5cy5sZW5ndGggPT09IDEgfHwgIXByaW1hcnlLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIG5ld0F0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogc291cmNlLmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IGtleSB8fCBwcmltYXJ5S2V5c1swXVxuICAgICAgfTtcblxuICAgICAgbmV3QXR0cmlidXRlLm9uRGVsZXRlID0gb3B0aW9ucy5vbkRlbGV0ZTtcbiAgICAgIG5ld0F0dHJpYnV0ZS5vblVwZGF0ZSA9IG9wdGlvbnMub25VcGRhdGU7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyA9IGFkZEZvcmVpZ25LZXlDb25zdHJhaW50cztcblxuLyoqXG4gKiBNaXhpbiAoaW5qZWN0KSBhc3NvY2lhdGlvbiBtZXRob2RzIHRvIG1vZGVsIHByb3RvdHlwZVxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFzc29jaWF0aW9uIGluc3RhbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIE1vZGVsIHByb3RvdHlwZVxuICogQHBhcmFtIHtBcnJheX0gbWV0aG9kcyBNZXRob2QgbmFtZXMgdG8gaW5qZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gYWxpYXNlcyBNYXBwaW5nIGJldHdlZW4gbW9kZWwgYW5kIGFzc29jaWF0aW9uIG1ldGhvZCBuYW1lc1xuICpcbiAqL1xuZnVuY3Rpb24gbWl4aW5NZXRob2RzKGFzc29jaWF0aW9uLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpIHtcbiAgYWxpYXNlcyA9IGFsaWFzZXMgfHwge307XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgIC8vIGRvbid0IG92ZXJyaWRlIGN1c3RvbSBtZXRob2RzXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBhc3NvY2lhdGlvbi5hY2Nlc3NvcnNbbWV0aG9kXSkpIHtcbiAgICAgIGNvbnN0IHJlYWxNZXRob2QgPSBhbGlhc2VzW21ldGhvZF0gfHwgbWV0aG9kO1xuXG4gICAgICBvYmpbYXNzb2NpYXRpb24uYWNjZXNzb3JzW21ldGhvZF1dID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbltyZWFsTWV0aG9kXSh0aGlzLCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMubWl4aW5NZXRob2RzID0gbWl4aW5NZXRob2RzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG5Bc3NvY2lhdGlvbi5CZWxvbmdzVG8gPSByZXF1aXJlKCcuL2JlbG9uZ3MtdG8nKTtcbkFzc29jaWF0aW9uLkhhc09uZSA9IHJlcXVpcmUoJy4vaGFzLW9uZScpO1xuQXNzb2NpYXRpb24uSGFzTWFueSA9IHJlcXVpcmUoJy4vaGFzLW1hbnknKTtcbkFzc29jaWF0aW9uLkJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKCcuL2JlbG9uZ3MtdG8tbWFueScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc29jaWF0aW9uO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFzc29jaWF0aW9uO1xubW9kdWxlLmV4cG9ydHMuQXNzb2NpYXRpb24gPSBBc3NvY2lhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgSGFzT25lID0gcmVxdWlyZSgnLi9oYXMtb25lJyk7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZSgnLi9oYXMtbWFueScpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoJy4vYmVsb25ncy10by1tYW55Jyk7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKCcuL2JlbG9uZ3MtdG8nKTtcblxuZnVuY3Rpb24gaXNNb2RlbChtb2RlbCwgc2VxdWVsaXplKSB7XG4gIHJldHVybiBtb2RlbFxuICAgICYmIG1vZGVsLnByb3RvdHlwZVxuICAgICYmIG1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIHNlcXVlbGl6ZS5TZXF1ZWxpemUuTW9kZWw7XG59XG5cbmNvbnN0IE1peGluID0ge1xuICBoYXNNYW55KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgdGhpcy5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfS5oYXNNYW55IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcblxuICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBtaXhpbiwgd2UnbGwgbmVlZCBhIHVuaXF1ZSBsZXRpYWJsZSBuYW1lIGZvciBob29rcyAoc2luY2UgTW9kZWwgd2lsbCBvdmVycmlkZSBvdXIgaG9va3Mgb3B0aW9uKVxuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG5cbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIF8ub21pdChzb3VyY2Uub3B0aW9ucywgWydob29rcyddKSk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogSGFzTWFueSB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaWQgaXMgaW4gdGhlIGZvcmVpZ24gdGFibGUgb3IgaW4gYSBjb25uZWN0aW5nIHRhYmxlXG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgSGFzTWFueShzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuXG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKCdhZnRlckFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEhhc01hbnksIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfSxcblxuICBiZWxvbmdzVG9NYW55KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgdGhpcy5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfS5iZWxvbmdzVG9NYW55IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcblxuICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBtaXhpbiwgd2UnbGwgbmVlZCBhIHVuaXF1ZSBsZXRpYWJsZSBuYW1lIGZvciBob29rcyAoc2luY2UgTW9kZWwgd2lsbCBvdmVycmlkZSBvdXIgaG9va3Mgb3B0aW9uKVxuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG4gICAgb3B0aW9ucy50aW1lc3RhbXBzID0gb3B0aW9ucy50aW1lc3RhbXBzID09PSB1bmRlZmluZWQgPyB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWVzdGFtcHMgOiBvcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBfLm9taXQoc291cmNlLm9wdGlvbnMsIFsnaG9va3MnLCAndGltZXN0YW1wcycsICdzY29wZXMnLCAnZGVmYXVsdFNjb3BlJ10pKTtcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBCZWxvbmdzVG9NYW55IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0aGUgaWQgaXMgaW4gdGhlIGZvcmVpZ24gdGFibGUgb3IgaW4gYSBjb25uZWN0aW5nIHRhYmxlXG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgQmVsb25nc1RvTWFueShzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuXG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKCdhZnRlckFzc29jaWF0ZScsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEJlbG9uZ3NUb01hbnksIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfSxcblxuICBnZXRBc3NvY2lhdGlvbnModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5hc3NvY2lhdGlvbnMpLmZpbHRlcihhc3NvY2lhdGlvbiA9PiBhc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gdGFyZ2V0Lm5hbWUpO1xuICB9LFxuXG4gIGdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0LCBhbGlhcykge1xuICAgIC8vIFR3byBhc3NvY2lhdGlvbnMgY2Fubm90IGhhdmUgdGhlIHNhbWUgYWxpYXMsIHNvIHdlIGNhbiB1c2UgZmluZCBpbnN0ZWFkIG9mIGZpbHRlclxuICAgIHJldHVybiB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXQpLmZpbmQoYXNzb2NpYXRpb24gPT4gYXNzb2NpYXRpb24udmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykpIHx8IG51bGw7XG4gIH1cbn07XG5cbi8vIFRoZSBsb2dpYyBmb3IgaGFzT25lIGFuZCBiZWxvbmdzVG8gaXMgZXhhY3RseSB0aGUgc2FtZVxuZnVuY3Rpb24gc2luZ2xlTGlua2VkKFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgc291cmNlLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzb3VyY2UubmFtZX0uJHtfLmxvd2VyRmlyc3QoVHlwZS5uYW1lKX0gY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG5cblxuICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBtaXhpbiwgd2UnbGwgbmVlZCBhIHVuaXF1ZSBsZXRpYWJsZSBuYW1lIGZvciBob29rcyAoc2luY2UgTW9kZWwgd2lsbCBvdmVycmlkZSBvdXIgaG9va3Mgb3B0aW9uKVxuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG5cbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgc291cmNlLnJ1bkhvb2tzKCdiZWZvcmVBc3NvY2lhdGUnLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBUeXBlIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0aGUgaWQgaXMgaW4gdGhlIGZvcmVpZ24gdGFibGVcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBUeXBlKHNvdXJjZSwgdGFyZ2V0LCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHNvdXJjZS5vcHRpb25zKSk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuXG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcblxuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICBzb3VyY2UucnVuSG9va3MoJ2FmdGVyQXNzb2NpYXRlJywgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogVHlwZSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9O1xufVxuXG5NaXhpbi5oYXNPbmUgPSBzaW5nbGVMaW5rZWQoSGFzT25lKTtcbk1peGluLmJlbG9uZ3NUbyA9IHNpbmdsZUxpbmtlZChCZWxvbmdzVG8pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1peGluO1xubW9kdWxlLmV4cG9ydHMuTWl4aW4gPSBNaXhpbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBNaXhpbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHdreCA9IHJlcXVpcmUoJ3dreCcpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhcycpLnZhbGlkYXRvcjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuL3V0aWxzL2xvZ2dlcicpO1xuY29uc3Qgd2FybmluZ3MgPSB7fTtcbmNvbnN0IHsgY2xhc3NUb0ludm9rYWJsZSB9ID0gcmVxdWlyZSgnLi91dGlscy9jbGFzcy10by1pbnZva2FibGUnKTtcbmNvbnN0IHsgam9pblNRTEZyYWdtZW50cyB9ID0gcmVxdWlyZSgnLi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMnKTtcblxuY2xhc3MgQUJTVFJBQ1Qge1xuICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TcWwob3B0aW9ucyk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9XG4gIHN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9zdHJpbmdpZnkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2JpbmRQYXJhbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHN0YXRpYyB3YXJuKGxpbmssIHRleHQpIHtcbiAgICBpZiAoIXdhcm5pbmdzW3RleHRdKSB7XG4gICAgICB3YXJuaW5nc1t0ZXh0XSA9IHRydWU7XG4gICAgICBsb2dnZXIud2FybihgJHt0ZXh0fSBcXG4+PiBDaGVjazogJHtsaW5rfWApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZXh0ZW5kKG9sZFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob2xkVHlwZS5vcHRpb25zKTtcbiAgfVxufVxuXG5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gJyc7XG5cbi8qKlxuICogU1RSSU5HIEEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZ1xuICovXG5jbGFzcyBTVFJJTkcgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0yNTVdIGxlbmd0aCBvZiBzdHJpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBbYmluYXJ5PWZhbHNlXSBJcyB0aGlzIGJpbmFyeT9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgYmluYXJ5KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBiaW5hcnkgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2JpbmFyeSA9IG9wdGlvbnMuYmluYXJ5O1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IDI1NTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYCxcbiAgICAgIHRoaXMuX2JpbmFyeSAmJiAnQklOQVJZJ1xuICAgIF0pO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmFyeSAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgQklOQVJZKCkge1xuICAgIHRoaXMuX2JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEJJTkFSWSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5CSU5BUlk7XG4gIH1cbn1cblxuLyoqXG4gKiBDSEFSIEEgZml4ZWQgbGVuZ3RoIHN0cmluZ1xuICovXG5jbGFzcyBDSEFSIGV4dGVuZHMgU1RSSU5HIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTI1NV0gbGVuZ3RoIG9mIHN0cmluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtiaW5hcnk9ZmFsc2VdIElzIHRoaXMgYmluYXJ5P1xuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoLCBiaW5hcnkpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGJpbmFyeSB9KTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgQ0hBUigke3RoaXMuX2xlbmd0aH0pYCxcbiAgICAgIHRoaXMuX2JpbmFyeSAmJiAnQklOQVJZJ1xuICAgIF0pO1xuICB9XG59XG5cbi8qKlxuICogVW5saW1pdGVkIGxlbmd0aCBURVhUIGNvbHVtblxuICovXG5jbGFzcyBURVhUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9JyddIGNvdWxkIGJlIHRpbnksIG1lZGl1bSwgbG9uZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgJyc7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAndGlueSc6XG4gICAgICAgIHJldHVybiAnVElOWVRFWFQnO1xuICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgcmV0dXJuICdNRURJVU1URVhUJztcbiAgICAgIGNhc2UgJ2xvbmcnOlxuICAgICAgICByZXR1cm4gJ0xPTkdURVhUJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZycsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQW4gdW5saW1pdGVkIGxlbmd0aCBjYXNlLWluc2Vuc2l0aXZlIHRleHQgY29sdW1uLlxuICogT3JpZ2luYWwgY2FzZSBpcyBwcmVzZXJ2ZWQgYnV0IGFjdHMgY2FzZS1pbnNlbnNpdGl2ZSB3aGVuIGNvbXBhcmluZyB2YWx1ZXMgKHN1Y2ggYXMgd2hlbiBmaW5kaW5nIG9yIHVuaXF1ZSBjb25zdHJhaW50cykuXG4gKiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3JlcyBhbmQgU1FMaXRlLlxuICpcbiAqL1xuY2xhc3MgQ0lURVhUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gJ0NJVEVYVCc7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZycsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQmFzZSBudW1iZXIgdHlwZSB3aGljaCBpcyB1c2VkIHRvIGJ1aWxkIG90aGVyIHR5cGVzXG4gKi9cbmNsYXNzIE5VTUJFUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHR5cGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmxlbmd0aF0gbGVuZ3RoIG9mIHR5cGUsIGxpa2UgYElOVCg0KWBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy56ZXJvZmlsbF0gSXMgemVybyBmaWxsZWQ/XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudW5zaWduZWRdIElzIHVuc2lnbmVkP1xuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmRlY2ltYWxzXSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIHVzZWQgd2l0aCBsZW5ndGggYEZMT0FUKDUsIDQpYFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLnByZWNpc2lvbl0gZGVmaW5lcyBwcmVjaXNpb24gZm9yIGRlY2ltYWwgdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLnNjYWxlXSBkZWZpbmVzIHNjYWxlIGZvciBkZWNpbWFsIHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbGVuZ3RoOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuX3plcm9maWxsID0gb3B0aW9ucy56ZXJvZmlsbDtcbiAgICB0aGlzLl9kZWNpbWFscyA9IG9wdGlvbnMuZGVjaW1hbHM7XG4gICAgdGhpcy5fcHJlY2lzaW9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgdGhpcy5fc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIHRoaXMuX3Vuc2lnbmVkID0gb3B0aW9ucy51bnNpZ25lZDtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9sZW5ndGh9YDtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVjaW1hbHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fZGVjaW1hbHN9YDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgfVxuICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgcmVzdWx0ICs9ICcgVU5TSUdORUQnO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgIHJlc3VsdCArPSAnIFpFUk9GSUxMJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRmxvYXQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KGAlaiBpcyBub3QgYSB2YWxpZCAke3RoaXMua2V5LnRvTG93ZXJDYXNlKCl9YCwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeShudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG51bWJlciA9PT0gJ2Jvb2xlYW4nIHx8IG51bWJlciA9PT0gbnVsbCB8fCBudW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBudW1iZXIudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIGdldCBVTlNJR05FRCgpIHtcbiAgICB0aGlzLl91bnNpZ25lZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCBaRVJPRklMTCgpIHtcbiAgICB0aGlzLl96ZXJvZmlsbCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLnplcm9maWxsID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgVU5TSUdORUQoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuVU5TSUdORUQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFpFUk9GSUxMKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLlpFUk9GSUxMO1xuICB9XG59XG5cbi8qKlxuICogQSAzMiBiaXQgaW50ZWdlclxuICovXG5jbGFzcyBJTlRFR0VSIGV4dGVuZHMgTlVNQkVSIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0ludChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoYCVqIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5rZXkudG9Mb3dlckNhc2UoKX1gLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgOCBiaXQgaW50ZWdlclxuICovXG5jbGFzcyBUSU5ZSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5cbi8qKlxuICogQSAxNiBiaXQgaW50ZWdlclxuICovXG5jbGFzcyBTTUFMTElOVCBleHRlbmRzIElOVEVHRVIge1xufVxuXG4vKipcbiAqIEEgMjQgYml0IGludGVnZXJcbiAqL1xuY2xhc3MgTUVESVVNSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5cbi8qKlxuICogQSA2NCBiaXQgaW50ZWdlclxuICovXG5jbGFzcyBCSUdJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cblxuLyoqXG4gKiBGbG9hdGluZyBwb2ludCBudW1iZXIgKDQtYnl0ZSBwcmVjaXNpb24pLlxuICovXG5jbGFzcyBGTE9BVCBleHRlbmRzIE5VTUJFUiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0eXBlLCBsaWtlIGBGTE9BVCg0KWBcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZGVjaW1hbHNdIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgdXNlZCB3aXRoIGxlbmd0aCBgRkxPQVQoNSwgNClgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRmxvYXQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBmbG9hdCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRmxvYXRpbmcgcG9pbnQgbnVtYmVyICg0LWJ5dGUgcHJlY2lzaW9uKS5cbiAqL1xuY2xhc3MgUkVBTCBleHRlbmRzIE5VTUJFUiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0eXBlLCBsaWtlIGBSRUFMKDQpYFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkZWNpbWFsc10gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCB1c2VkIHdpdGggbGVuZ3RoIGBSRUFMKDUsIDQpYFxuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbG9hdGluZyBwb2ludCBudW1iZXIgKDgtYnl0ZSBwcmVjaXNpb24pLlxuICovXG5jbGFzcyBET1VCTEUgZXh0ZW5kcyBOVU1CRVIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdHlwZSwgbGlrZSBgRE9VQkxFIFBSRUNJU0lPTigyNSlgXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2RlY2ltYWxzXSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIHVzZWQgd2l0aCBsZW5ndGggYERPVUJMRSBQUkVDSVNJT04oMjUsIDEwKWBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSAnb2JqZWN0JyAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGVjaW1hbCB0eXBlLCB2YXJpYWJsZSBwcmVjaXNpb24sIHRha2UgbGVuZ3RoIGFzIHNwZWNpZmllZCBieSB1c2VyXG4gKi9cbmNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBOVU1CRVIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbcHJlY2lzaW9uXSBkZWZpbmVzIHByZWNpc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtzY2FsZV0gZGVmaW5lcyBzY2FsZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJlY2lzaW9uLCBzY2FsZSkge1xuICAgIHN1cGVyKHR5cGVvZiBwcmVjaXNpb24gPT09ICdvYmplY3QnICYmIHByZWNpc2lvbiB8fCB7IHByZWNpc2lvbiwgc2NhbGUgfSk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgaWYgKHRoaXMuX3ByZWNpc2lvbiB8fCB0aGlzLl9zY2FsZSkge1xuICAgICAgcmV0dXJuIGBERUNJTUFMKCR7W3RoaXMuX3ByZWNpc2lvbiwgdGhpcy5fc2NhbGVdLmZpbHRlcihfLmlkZW50aXR5KS5qb2luKCcsJyl9KWA7XG4gICAgfVxuICAgIHJldHVybiAnREVDSU1BTCc7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0RlY2ltYWwoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBkZWNpbWFsJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gVE9ETzogQ3JlYXRlIGludGVybWVkaWF0ZSBjbGFzc1xuY29uc3QgcHJvdG9FeHRlbnNpb25zID0ge1xuICBlc2NhcGU6IGZhbHNlLFxuICBfdmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ05hTic7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgICByZXR1cm4gYCR7c2lnbn1JbmZpbml0eWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGAnJHt0aGlzLl92YWx1ZSh2YWx1ZSl9J2A7XG4gIH0sXG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWUpKTtcbiAgfVxufTtcblxuZm9yIChjb25zdCBmbG9hdGluZyBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTF0pIHtcbiAgT2JqZWN0LmFzc2lnbihmbG9hdGluZy5wcm90b3R5cGUsIHByb3RvRXh0ZW5zaW9ucyk7XG59XG5cbi8qKlxuICogQSBib29sZWFuIC8gdGlueWludCBjb2x1bW4sIGRlcGVuZGluZyBvbiBkaWFsZWN0XG4gKi9cbmNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnVElOWUlOVCgxKSc7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Jvb2xlYW4oU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBib29sZWFuJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBCaXQgZmllbGRzIGFyZSByZXR1cm5lZCBhcyBidWZmZXJzXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIE9ubHkgdGFrZSBhY3Rpb24gb24gdmFsaWQgYm9vbGVhbiBzdHJpbmdzLlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gT25seSB0YWtlIGFjdGlvbiBvbiB2YWxpZCBib29sZWFuIGludGVnZXJzLlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgPyB0cnVlIDogdmFsdWUgPT09IDAgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuXG5CT09MRUFOLnBhcnNlID0gQk9PTEVBTi5wcm90b3R5cGUuX3Nhbml0aXplO1xuXG4vKipcbiAqIEEgdGltZSBjb2x1bW5cbiAqXG4gKi9cbmNsYXNzIFRJTUUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnVElNRSc7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRlIGNvbHVtbiB3aXRoIHRpbWV6b25lLCBkZWZhdWx0IGlzIFVUQ1xuICovXG5jbGFzcyBEQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbGVuZ3RoXSBwcmVjaXNpb24gdG8gYWxsb3cgc3RvcmluZyBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09ICdvYmplY3QnICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgJyc7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdEQVRFVElNRSc7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0RhdGUoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBkYXRlJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEhdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfaXNDaGFuZ2VkKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSB7XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgISF2YWx1ZSAmJlxuICAgICAgKHZhbHVlID09PSBvcmlnaW5hbFZhbHVlIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiBvcmlnaW5hbFZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZS5nZXRUaW1lKCkgPT09IG9yaWdpbmFsVmFsdWUuZ2V0VGltZSgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBub3QgY2hhbmdlZCB3aGVuIHNldCB0byBzYW1lIGVtcHR5IHZhbHVlXG4gICAgaWYgKCFvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGltZXpvbmUpIHtcbiAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHJldHVybiBtb21lbnRUeihkYXRlKS50eihvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlID0gbW9tZW50KGRhdGUpLnV0Y09mZnNldChvcHRpb25zLnRpbWV6b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudFR6KGRhdGUpO1xuICB9XG4gIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgIC8vIFogaGVyZSBtZWFucyBjdXJyZW50IHRpbWV6b25lLCBfbm90XyBVVENcbiAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW06c3MuU1NTIFonKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZGF0ZSBvbmx5IGNvbHVtbiAobm8gdGltZXN0YW1wKVxuICovXG5jbGFzcyBEQVRFT05MWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuICdEQVRFJztcbiAgfVxuICBfc3RyaW5naWZ5KGRhdGUpIHtcbiAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEhdmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX2lzQ2hhbmdlZCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkge1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICYmICEhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbm90IGNoYW5nZWQgd2hlbiBzZXQgdG8gc2FtZSBlbXB0eSB2YWx1ZVxuICAgIGlmICghb3JpZ2luYWxWYWx1ZSAmJiAhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGtleSAvIHZhbHVlIHN0b3JlIGNvbHVtbi4gT25seSBhdmFpbGFibGUgaW4gUG9zdGdyZXMuXG4gKi9cbmNsYXNzIEhTVE9SRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBoc3RvcmUnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgSlNPTiBzdHJpbmcgY29sdW1uLiBBdmFpbGFibGUgaW4gTXlTUUwsIFBvc3RncmVzIGFuZCBTUUxpdGVcbiAqL1xuY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQSBiaW5hcnkgc3RvcmFnZSBKU09OIGNvbHVtbi4gT25seSBhdmFpbGFibGUgaW4gUG9zdGdyZXMuXG4gKi9cbmNsYXNzIEpTT05CIGV4dGVuZHMgSlNPTlRZUEUge1xufVxuXG4vKipcbiAqIEEgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAqL1xuY2xhc3MgTk9XIGV4dGVuZHMgQUJTVFJBQ1Qge1xufVxuXG4vKipcbiAqIEJpbmFyeSBzdG9yYWdlXG4gKi9cbmNsYXNzIEJMT0IgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nJ10gY291bGQgYmUgdGlueSwgbWVkaXVtLCBsb25nLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAnJztcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICd0aW55JzpcbiAgICAgICAgcmV0dXJuICdUSU5ZQkxPQic7XG4gICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICByZXR1cm4gJ01FRElVTUJMT0InO1xuICAgICAgY2FzZSAnbG9uZyc6XG4gICAgICAgIHJldHVybiAnTE9OR0JMT0InO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdCgnJWogaXMgbm90IGEgdmFsaWQgYmxvYicsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZXggPSB2YWx1ZS50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2hleGlmeShoZXgpO1xuICB9XG4gIF9oZXhpZnkoaGV4KSB7XG4gICAgcmV0dXJuIGBYJyR7aGV4fSdgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICB9XG59XG5cblxuQkxPQi5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbi8qKlxuICogUmFuZ2UgdHlwZXMgYXJlIGRhdGEgdHlwZXMgcmVwcmVzZW50aW5nIGEgcmFuZ2Ugb2YgdmFsdWVzIG9mIHNvbWUgZWxlbWVudCB0eXBlIChjYWxsZWQgdGhlIHJhbmdlJ3Mgc3VidHlwZSkuXG4gKiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z3Jlcy4gU2VlIFt0aGUgUG9zdGdyZXMgZG9jdW1lbnRhdGlvbl0oaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuNC9zdGF0aWMvcmFuZ2V0eXBlcy5odG1sKSBmb3IgbW9yZSBkZXRhaWxzXG4gKi9cbmNsYXNzIFJBTkdFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtBQlNUUkFDVH0gc3VidHlwZSBBIHN1YnR5cGUgZm9yIHJhbmdlLCBsaWtlIFJBTkdFKERBVEUpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdWJ0eXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHN1YnR5cGUpID8gc3VidHlwZSA6IHsgc3VidHlwZSB9O1xuICAgIGlmICghb3B0aW9ucy5zdWJ0eXBlKVxuICAgICAgb3B0aW9ucy5zdWJ0eXBlID0gbmV3IElOVEVHRVIoKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3VidHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucy5zdWJ0eXBlID0gbmV3IG9wdGlvbnMuc3VidHlwZSgpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJ0eXBlID0gb3B0aW9ucy5zdWJ0eXBlLmtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHJhbmdlJywgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IoJ0EgcmFuZ2UgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBlbGVtZW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29sdW1uIHN0b3JpbmcgYSB1bmlxdWUgdW5pdmVyc2FsIGlkZW50aWZpZXIuXG4gKiBVc2Ugd2l0aCBgVVVJRFYxYCBvciBgVVVJRFY0YCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKi9cbmNsYXNzIFVVSUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHV1aWQnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZGVmYXVsdCB1bmlxdWUgdW5pdmVyc2FsIGlkZW50aWZpZXIgZ2VuZXJhdGVkIGZvbGxvd2luZyB0aGUgVVVJRCB2MSBzdGFuZGFyZFxuICovXG5jbGFzcyBVVUlEVjEgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHV1aWQnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZGVmYXVsdCB1bmlxdWUgdW5pdmVyc2FsIGlkZW50aWZpZXIgZ2VuZXJhdGVkIGZvbGxvd2luZyB0aGUgVVVJRCB2NCBzdGFuZGFyZFxuICovXG5jbGFzcyBVVUlEVjQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUsIDQpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIHV1aWR2NCcsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQSB2aXJ0dWFsIHZhbHVlIHRoYXQgaXMgbm90IHN0b3JlZCBpbiB0aGUgREIuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGluIHlvdXIgbW9kZWwgdGhhdCBpcyByZXR1cm5lZCB0byB0aGUgdXNlciBidXQgbm90IHN0b3JlZCBpbiB0aGUgREIuXG4gKlxuICogWW91IGNvdWxkIGFsc28gdXNlIGl0IHRvIHZhbGlkYXRlIGEgdmFsdWUgYmVmb3JlIHBlcm11dGluZyBhbmQgc3RvcmluZyBpdC4gVklSVFVBTCBhbHNvIHRha2VzIGEgcmV0dXJuIHR5cGUgYW5kIGRlcGVuZGVuY3kgZmllbGRzIGFzIGFyZ3VtZW50c1xuICogSWYgYSB2aXJ0dWFsIGF0dHJpYnV0ZSBpcyBwcmVzZW50IGluIGBhdHRyaWJ1dGVzYCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgcHVsbCBpbiB0aGUgZXh0cmEgZmllbGRzIGFzIHdlbGwuXG4gKiBSZXR1cm4gdHlwZSBpcyBtb3N0bHkgdXNlZnVsIGZvciBzZXR1cHMgdGhhdCByZWx5IG9uIHR5cGVzIGxpa2UgR3JhcGhRTC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DaGVja2luZyBwYXNzd29yZCBsZW5ndGggYmVmb3JlIGhhc2hpbmcgaXQ8L2NhcHRpb24+XG4gKiBzZXF1ZWxpemUuZGVmaW5lKCd1c2VyJywge1xuICogICBwYXNzd29yZF9oYXNoOiBEYXRhVHlwZXMuU1RSSU5HLFxuICogICBwYXNzd29yZDoge1xuICogICAgIHR5cGU6IERhdGFUeXBlcy5WSVJUVUFMLFxuICogICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICogICAgICAgIC8vIFJlbWVtYmVyIHRvIHNldCB0aGUgZGF0YSB2YWx1ZSwgb3RoZXJ3aXNlIGl0IHdvbid0IGJlIHZhbGlkYXRlZFxuICogICAgICAgIHRoaXMuc2V0RGF0YVZhbHVlKCdwYXNzd29yZCcsIHZhbCk7XG4gKiAgICAgICAgdGhpcy5zZXREYXRhVmFsdWUoJ3Bhc3N3b3JkX2hhc2gnLCB0aGlzLnNhbHQgKyB2YWwpO1xuICogICAgICB9LFxuICogICAgICB2YWxpZGF0ZToge1xuICogICAgICAgICBpc0xvbmdFbm91Z2g6IGZ1bmN0aW9uICh2YWwpIHtcbiAqICAgICAgICAgICBpZiAodmFsLmxlbmd0aCA8IDcpIHtcbiAqICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBjaG9vc2UgYSBsb25nZXIgcGFzc3dvcmRcIilcbiAqICAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKlxuICogIyBJbiB0aGUgYWJvdmUgY29kZSB0aGUgcGFzc3dvcmQgaXMgc3RvcmVkIHBsYWlubHkgaW4gdGhlIHBhc3N3b3JkIGZpZWxkIHNvIGl0IGNhbiBiZSB2YWxpZGF0ZWQsIGJ1dCBpcyBuZXZlciBzdG9yZWQgaW4gdGhlIERCLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZpcnR1YWwgd2l0aCBkZXBlbmRlbmN5IGZpZWxkczwvY2FwdGlvbj5cbiAqIHtcbiAqICAgYWN0aXZlOiB7XG4gKiAgICAgdHlwZTogbmV3IERhdGFUeXBlcy5WSVJUVUFMKERhdGFUeXBlcy5CT09MRUFOLCBbJ2NyZWF0ZWRBdCddKSxcbiAqICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjcmVhdGVkQXQnKSA+IERhdGUubm93KCkgLSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICovXG5jbGFzcyBWSVJUVUFMIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtBQlNUUkFDVH0gW1JldHVyblR5cGVdIHJldHVybiB0eXBlIGZvciB2aXJ0dWFsIHR5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2ZpZWxkc10gYXJyYXkgb2YgZmllbGRzIHRoaXMgdmlydHVhbCB0eXBlIGlzIGRlcGVuZGVudCBvblxuICAgKi9cbiAgY29uc3RydWN0b3IoUmV0dXJuVHlwZSwgZmllbGRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIFJldHVyblR5cGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBSZXR1cm5UeXBlID0gbmV3IFJldHVyblR5cGUoKTtcbiAgICB0aGlzLnJldHVyblR5cGUgPSBSZXR1cm5UeXBlO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24sIFBvc3RncmVzIE9ubHlcbiAqXG4gKiBAZXhhbXBsZVxuICogRGF0YVR5cGVzLkVOVU0oJ3ZhbHVlJywgJ2Fub3RoZXIgdmFsdWUnKVxuICogRGF0YVR5cGVzLkVOVU0oWyd2YWx1ZScsICdhbm90aGVyIHZhbHVlJ10pXG4gKiBEYXRhVHlwZXMuRU5VTSh7XG4gKiAgIHZhbHVlczogWyd2YWx1ZScsICdhbm90aGVyIHZhbHVlJ11cbiAqIH0pXG4gKi9cbmNsYXNzIEVOVU0gZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueXx7IHZhbHVlczogYW55W10gfXxhbnlbXX0gYXJncyBlaXRoZXIgYXJyYXkgb2YgdmFsdWVzIG9yIG9wdGlvbnMgb2JqZWN0IHdpdGggdmFsdWVzIGFycmF5LiBJdCBhbHNvIHN1cHBvcnRzIHZhcmlhZGljIHZhbHVlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSB8fCB7XG4gICAgICB2YWx1ZXM6IGFyZ3MucmVkdWNlKChyZXN1bHQsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoQXJyYXkuaXNBcnJheShlbGVtZW50KSA/IGVsZW1lbnQgOiBbZWxlbWVudF0pO1xuICAgICAgfSwgW10pXG4gICAgfTtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGNob2ljZSBpbiAlaicsIHZhbHVlLCB0aGlzLnZhbHVlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGFycmF5IG9mIGB0eXBlYC4gT25seSBhdmFpbGFibGUgaW4gUG9zdGdyZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIERhdGFUeXBlcy5BUlJBWShEYXRhVHlwZXMuREVDSU1BTClcbiAqL1xuY2xhc3MgQVJSQVkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FCU1RSQUNUfSB0eXBlIHR5cGUgb2YgYXJyYXkgdmFsdWVzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gdHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBvcHRpb25zLnR5cGUoKSA6IG9wdGlvbnMudHlwZTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy50eXBlLnRvU3FsKCl9W11gO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIGFycmF5JywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGlzKG9iaiwgdHlwZSkge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBBUlJBWSAmJiBvYmoudHlwZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbHVtbiBzdG9yaW5nIEdlb21ldHJ5IGluZm9ybWF0aW9uLlxuICogSXQgaXMgb25seSBhdmFpbGFibGUgaW4gUG9zdGdyZVNRTCAod2l0aCBQb3N0R0lTKSwgTWFyaWFEQiBvciBNeVNRTC5cbiAqXG4gKiBHZW9KU09OIGlzIGFjY2VwdGVkIGFzIGlucHV0IGFuZCByZXR1cm5lZCBhcyBvdXRwdXQuXG4gKlxuICogSW4gUG9zdEdJUywgdGhlIEdlb0pTT04gaXMgcGFyc2VkIHVzaW5nIHRoZSBQb3N0R0lTIGZ1bmN0aW9uIGBTVF9HZW9tRnJvbUdlb0pTT05gLlxuICogSW4gTXlTUUwgaXQgaXMgcGFyc2VkIHVzaW5nIHRoZSBmdW5jdGlvbiBgR2VvbUZyb21UZXh0YC5cbiAqXG4gKiBUaGVyZWZvcmUsIG9uZSBjYW4ganVzdCBmb2xsb3cgdGhlIFtHZW9KU09OIHNwZWNdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSBmb3IgaGFuZGxpbmcgZ2VvbWV0cnkgb2JqZWN0cy4gIFNlZSB0aGUgZm9sbG93aW5nIGV4YW1wbGVzOlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlZmluaW5nIGEgR2VvbWV0cnkgdHlwZSBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gKiBEYXRhVHlwZXMuR0VPTUVUUllcbiAqIERhdGFUeXBlcy5HRU9NRVRSWSgnUE9JTlQnKVxuICogRGF0YVR5cGVzLkdFT01FVFJZKCdQT0lOVCcsIDQzMjYpXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgbmV3IHBvaW50PC9jYXB0aW9uPlxuICogY29uc3QgcG9pbnQgPSB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbMzkuODA3MjIyLC03Ni45ODQ3MjJdfTtcbiAqXG4gKiBVc2VyLmNyZWF0ZSh7dXNlcm5hbWU6ICd1c2VybmFtZScsIGdlb21ldHJ5OiBwb2ludCB9KTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGUgYSBuZXcgbGluZXN0cmluZzwvY2FwdGlvbj5cbiAqIGNvbnN0IGxpbmUgPSB7IHR5cGU6ICdMaW5lU3RyaW5nJywgJ2Nvb3JkaW5hdGVzJzogWyBbMTAwLjAsIDAuMF0sIFsxMDEuMCwgMS4wXSBdIH07XG4gKlxuICogVXNlci5jcmVhdGUoe3VzZXJuYW1lOiAndXNlcm5hbWUnLCBnZW9tZXRyeTogbGluZSB9KTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGUgYSBuZXcgcG9seWdvbjwvY2FwdGlvbj5cbiAqIGNvbnN0IHBvbHlnb24gPSB7IHR5cGU6ICdQb2x5Z29uJywgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICAgICAgICAgICBbIFsxMDAuMCwgMC4wXSwgWzEwMS4wLCAwLjBdLCBbMTAxLjAsIDEuMF0sXG4gKiAgICAgICAgICAgICAgICAgICBbMTAwLjAsIDEuMF0sIFsxMDAuMCwgMC4wXSBdXG4gKiAgICAgICAgICAgICAgICAgXX07XG4gKlxuICogVXNlci5jcmVhdGUoe3VzZXJuYW1lOiAndXNlcm5hbWUnLCBnZW9tZXRyeTogcG9seWdvbiB9KTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGUgYSBuZXcgcG9pbnQgd2l0aCBhIGN1c3RvbSBTUklEPC9jYXB0aW9uPlxuICogY29uc3QgcG9pbnQgPSB7XG4gKiAgIHR5cGU6ICdQb2ludCcsXG4gKiAgIGNvb3JkaW5hdGVzOiBbMzkuODA3MjIyLC03Ni45ODQ3MjJdLFxuICogICBjcnM6IHsgdHlwZTogJ25hbWUnLCBwcm9wZXJ0aWVzOiB7IG5hbWU6ICdFUFNHOjQzMjYnfSB9XG4gKiB9O1xuICpcbiAqIFVzZXIuY3JlYXRlKHt1c2VybmFtZTogJ3VzZXJuYW1lJywgZ2VvbWV0cnk6IHBvaW50IH0pXG4gKlxuICpcbiAqIEBzZWUge0BsaW5rIERhdGFUeXBlcy5HRU9HUkFQSFl9XG4gKi9cbmNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUeXBlIG9mIGdlb21ldHJ5IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmlkXSBTUklEIG9mIHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlLCBzcmlkIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5zcmlkID0gb3B0aW9ucy5zcmlkO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYEdlb21Gcm9tVGV4dCgke29wdGlvbnMuZXNjYXBlKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYEdlb21Gcm9tVGV4dCgke29wdGlvbnMuYmluZFBhcmFtKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG59XG5cbkdFT01FVFJZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcblxuLyoqXG4gKiBBIGdlb2dyYXBoeSBkYXRhdHlwZSByZXByZXNlbnRzIHR3byBkaW1lbnNpb25hbCBzcGFjaWFsIG9iamVjdHMgaW4gYW4gZWxsaXB0aWMgY29vcmQgc3lzdGVtLlxuICpcbiAqIF9fVGhlIGRpZmZlcmVuY2UgZnJvbSBnZW9tZXRyeSBhbmQgZ2VvZ3JhcGh5IHR5cGU6X19cbiAqXG4gKiBQb3N0R0lTIDEuNSBpbnRyb2R1Y2VkIGEgbmV3IHNwYXRpYWwgdHlwZSBjYWxsZWQgZ2VvZ3JhcGh5LCB3aGljaCB1c2VzIGdlb2RldGljIG1lYXN1cmVtZW50IGluc3RlYWQgb2YgQ2FydGVzaWFuIG1lYXN1cmVtZW50LlxuICogQ29vcmRpbmF0ZSBwb2ludHMgaW4gdGhlIGdlb2dyYXBoeSB0eXBlIGFyZSBhbHdheXMgcmVwcmVzZW50ZWQgaW4gV0dTIDg0IGxvbiBsYXQgZGVncmVlcyAoU1JJRCA0MzI2KSxcbiAqIGJ1dCBtZWFzdXJlbWVudCBmdW5jdGlvbnMgYW5kIHJlbGF0aW9uc2hpcHMgU1RfRGlzdGFuY2UsIFNUX0RXaXRoaW4sIFNUX0xlbmd0aCwgYW5kIFNUX0FyZWEgYWx3YXlzIHJldHVybiBhbnN3ZXJzIGluIG1ldGVycyBvciBhc3N1bWUgaW5wdXRzIGluIG1ldGVycy5cbiAqXG4gKiBfX1doYXQgaXMgYmVzdCB0byB1c2U/IEl0IGRlcGVuZHM6X19cbiAqXG4gKiBXaGVuIGNob29zaW5nIGJldHdlZW4gdGhlIGdlb21ldHJ5IGFuZCBnZW9ncmFwaHkgdHlwZSBmb3IgZGF0YSBzdG9yYWdlLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHdoYXQgeW914oCZbGwgYmUgdXNpbmcgaXQgZm9yLlxuICogSWYgYWxsIHlvdSBkbyBhcmUgc2ltcGxlIG1lYXN1cmVtZW50cyBhbmQgcmVsYXRpb25zaGlwIGNoZWNrcyBvbiB5b3VyIGRhdGEsIGFuZCB5b3VyIGRhdGEgY292ZXJzIGEgZmFpcmx5IGxhcmdlIGFyZWEsIHRoZW4gbW9zdCBsaWtlbHkgeW914oCZbGwgYmUgYmV0dGVyIG9mZiBzdG9yaW5nIHlvdXIgZGF0YSB1c2luZyB0aGUgbmV3IGdlb2dyYXBoeSB0eXBlLlxuICogQWx0aG91Z2ggdGhlIG5ldyBnZW9ncmFwaHkgZGF0YSB0eXBlIGNhbiBjb3ZlciB0aGUgZ2xvYmUsIHRoZSBnZW9tZXRyeSB0eXBlIGlzIGZhciBmcm9tIG9ic29sZXRlLlxuICogVGhlIGdlb21ldHJ5IHR5cGUgaGFzIGEgbXVjaCByaWNoZXIgc2V0IG9mIGZ1bmN0aW9ucyB0aGFuIGdlb2dyYXBoeSwgcmVsYXRpb25zaGlwIGNoZWNrcyBhcmUgZ2VuZXJhbGx5IGZhc3RlciwgYW5kIGl0IGhhcyB3aWRlciBzdXBwb3J0IGN1cnJlbnRseSBhY3Jvc3MgZGVza3RvcCBhbmQgd2ViLW1hcHBpbmcgdG9vbHNcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZpbmluZyBhIEdlb2dyYXBoeSB0eXBlIGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAqIERhdGFUeXBlcy5HRU9HUkFQSFlcbiAqIERhdGFUeXBlcy5HRU9HUkFQSFkoJ1BPSU5UJylcbiAqIERhdGFUeXBlcy5HRU9HUkFQSFkoJ1BPSU5UJywgNDMyNilcbiAqL1xuY2xhc3MgR0VPR1JBUEhZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUeXBlIG9mIGdlb2dyYXBoeSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3JpZF0gU1JJRCBvZiB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSwgc3JpZCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuc3JpZCA9IG9wdGlvbnMuc3JpZDtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBHZW9tRnJvbVRleHQoJHtvcHRpb25zLmVzY2FwZSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBHZW9tRnJvbVRleHQoJHtvcHRpb25zLmJpbmRQYXJhbSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxufVxuXG5cbkdFT0dSQVBIWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGNpZHIgdHlwZSBob2xkcyBhbiBJUHY0IG9yIElQdjYgbmV0d29yayBzcGVjaWZpY2F0aW9uLiBUYWtlcyA3IG9yIDE5IGJ5dGVzLlxuICpcbiAqIE9ubHkgYXZhaWxhYmxlIGZvciBQb3N0Z3Jlc1xuICovXG5jbGFzcyBDSURSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNJUFJhbmdlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIENJRFInLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBJTkVUIHR5cGUgaG9sZHMgYW4gSVB2NCBvciBJUHY2IGhvc3QgYWRkcmVzcywgYW5kIG9wdGlvbmFsbHkgaXRzIHN1Ym5ldC4gVGFrZXMgNyBvciAxOSBieXRlc1xuICpcbiAqIE9ubHkgYXZhaWxhYmxlIGZvciBQb3N0Z3Jlc1xuICovXG5jbGFzcyBJTkVUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNJUCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBJTkVUJywgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgTUFDQUREUiB0eXBlIHN0b3JlcyBNQUMgYWRkcmVzc2VzLiBUYWtlcyA2IGJ5dGVzXG4gKlxuICogT25seSBhdmFpbGFibGUgZm9yIFBvc3RncmVzXG4gKlxuICovXG5jbGFzcyBNQUNBRERSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFWYWxpZGF0b3IuaXNNQUNBZGRyZXNzKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoJyVqIGlzIG5vdCBhIHZhbGlkIE1BQ0FERFInLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBUU1ZFQ1RPUiB0eXBlIHN0b3JlcyB0ZXh0IHNlYXJjaCB2ZWN0b3JzLlxuICpcbiAqIE9ubHkgYXZhaWxhYmxlIGZvciBQb3N0Z3Jlc1xuICpcbiAqL1xuY2xhc3MgVFNWRUNUT1IgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KCclaiBpcyBub3QgYSB2YWxpZCBzdHJpbmcnLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29udmVuaWVuY2UgY2xhc3MgaG9sZGluZyBjb21tb25seSB1c2VkIGRhdGEgdHlwZXMuIFRoZSBkYXRhIHR5cGVzIGFyZSB1c2VkIHdoZW4gZGVmaW5pbmcgYSBuZXcgbW9kZWwgdXNpbmcgYFNlcXVlbGl6ZS5kZWZpbmVgLCBsaWtlIHRoaXM6XG4gKiBgYGBqc1xuICogc2VxdWVsaXplLmRlZmluZSgnbW9kZWwnLCB7XG4gKiAgIGNvbHVtbjogRGF0YVR5cGVzLklOVEVHRVJcbiAqIH0pXG4gKiBgYGBcbiAqIFdoZW4gZGVmaW5pbmcgYSBtb2RlbCB5b3UgY2FuIGp1c3QgYXMgZWFzaWx5IHBhc3MgYSBzdHJpbmcgYXMgdHlwZSwgYnV0IG9mdGVuIHVzaW5nIHRoZSB0eXBlcyBkZWZpbmVkIGhlcmUgaXMgYmVuZWZpY2lhbC4gRm9yIGV4YW1wbGUsIHVzaW5nIGBEYXRhVHlwZXMuQkxPQmAsIG1lYW5cbiAqIHRoYXQgdGhhdCBjb2x1bW4gd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBpbnN0YW5jZSBvZiBgQnVmZmVyYCB3aGVuIGJlaW5nIGZldGNoZWQgYnkgc2VxdWVsaXplLlxuICpcbiAqIFRvIHByb3ZpZGUgYSBsZW5ndGggZm9yIHRoZSBkYXRhIHR5cGUsIHlvdSBjYW4gaW52b2tlIGl0IGxpa2UgYSBmdW5jdGlvbjogYElOVEVHRVIoMilgXG4gKlxuICogU29tZSBkYXRhIHR5cGVzIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGluIG9yZGVyIHRvIGNoYW5nZSB0aGUgZGF0YSB0eXBlLlxuICogRm9yIGV4YW1wbGUsIHRvIGdldCBhbiB1bnNpZ25lZCBpbnRlZ2VyIHdpdGggemVyb2ZpbGwgeW91IGNhbiBkbyBgRGF0YVR5cGVzLklOVEVHRVIuVU5TSUdORUQuWkVST0ZJTExgLlxuICogVGhlIG9yZGVyIHlvdSBhY2Nlc3MgdGhlIHByb3BlcnRpZXMgaW4gZG8gbm90IG1hdHRlciwgc28gYERhdGFUeXBlcy5JTlRFR0VSLlpFUk9GSUxMLlVOU0lHTkVEYCBpcyBmaW5lIGFzIHdlbGwuXG4gKlxuICogKiBBbGwgbnVtYmVyIHR5cGVzIChgSU5URUdFUmAsIGBCSUdJTlRgLCBgRkxPQVRgLCBgRE9VQkxFYCwgYFJFQUxgLCBgREVDSU1BTGApIGV4cG9zZSB0aGUgcHJvcGVydGllcyBgVU5TSUdORURgIGFuZCBgWkVST0ZJTExgXG4gKiAqIFRoZSBgQ0hBUmAgYW5kIGBTVFJJTkdgIHR5cGVzIGV4cG9zZSB0aGUgYEJJTkFSWWAgcHJvcGVydHlcbiAqXG4gKiBUaHJlZSBvZiB0aGUgdmFsdWVzIHByb3ZpZGVkIGhlcmUgKGBOT1dgLCBgVVVJRFYxYCBhbmQgYFVVSURWNGApIGFyZSBzcGVjaWFsIGRlZmF1bHQgdmFsdWVzLCB0aGF0IHNob3VsZCBub3QgYmUgdXNlZCB0byBkZWZpbmUgdHlwZXMuIEluc3RlYWQgdGhleSBhcmUgdXNlZCBhcyBzaG9ydGhhbmRzIGZvclxuICogZGVmaW5pbmcgZGVmYXVsdCB2YWx1ZXMuIEZvciBleGFtcGxlLCB0byBnZXQgYSB1dWlkIGZpZWxkIHdpdGggYSBkZWZhdWx0IHZhbHVlIGdlbmVyYXRlZCBmb2xsb3dpbmcgdjEgb2YgdGhlIFVVSUQgc3RhbmRhcmQ6XG4gKiBgYGBqc1xuICogc2VxdWVsaXplLmRlZmluZSgnbW9kZWwnLCB7XG4gKiAgIHV1aWQ6IHtcbiAqICAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAqICAgICBkZWZhdWx0VmFsdWU6IERhdGFUeXBlcy5VVUlEVjEsXG4gKiAgICAgcHJpbWFyeUtleTogdHJ1ZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBUaGVyZSBtYXkgYmUgdGltZXMgd2hlbiB5b3Ugd2FudCB0byBnZW5lcmF0ZSB5b3VyIG93biBVVUlEIGNvbmZvcm1pbmcgdG8gc29tZSBvdGhlciBhbGdvcml0aG0uIFRoaXMgaXMgYWNjb21wbGlzaGVkXG4gKiB1c2luZyB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5IGFzIHdlbGwsIGJ1dCBpbnN0ZWFkIG9mIHNwZWNpZnlpbmcgb25lIG9mIHRoZSBzdXBwbGllZCBVVUlEIHR5cGVzLCB5b3UgcmV0dXJuIGEgdmFsdWVcbiAqIGZyb20gYSBmdW5jdGlvbi5cbiAqIGBgYGpzXG4gKiBzZXF1ZWxpemUuZGVmaW5lKCdtb2RlbCcsIHtcbiAqICAgdXVpZDoge1xuICogICAgIHR5cGU6IERhdGFUeXBlcy5VVUlELFxuICogICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gZ2VuZXJhdGVNeUlkKClcbiAqICAgICB9LFxuICogICAgIHByaW1hcnlLZXk6IHRydWVcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICovXG5jb25zdCBEYXRhVHlwZXMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJTVFJBQ1QsXG4gIFNUUklORyxcbiAgQ0hBUixcbiAgVEVYVCxcbiAgTlVNQkVSLFxuICBUSU5ZSU5ULFxuICBTTUFMTElOVCxcbiAgTUVESVVNSU5ULFxuICBJTlRFR0VSLFxuICBCSUdJTlQsXG4gIEZMT0FULFxuICBUSU1FLFxuICBEQVRFLFxuICBEQVRFT05MWSxcbiAgQk9PTEVBTixcbiAgTk9XLFxuICBCTE9CLFxuICBERUNJTUFMLFxuICBOVU1FUklDOiBERUNJTUFMLFxuICBVVUlELFxuICBVVUlEVjEsXG4gIFVVSURWNCxcbiAgSFNUT1JFLFxuICBKU09OOiBKU09OVFlQRSxcbiAgSlNPTkIsXG4gIFZJUlRVQUwsXG4gIEFSUkFZLFxuICBFTlVNLFxuICBSQU5HRSxcbiAgUkVBTCxcbiAgJ0RPVUJMRSBQUkVDSVNJT04nOiBET1VCTEUsXG4gIERPVUJMRSxcbiAgR0VPTUVUUlksXG4gIEdFT0dSQVBIWSxcbiAgQ0lEUixcbiAgSU5FVCxcbiAgTUFDQUREUixcbiAgQ0lURVhULFxuICBUU1ZFQ1RPUlxufTtcblxuXy5lYWNoKERhdGFUeXBlcywgKGRhdGFUeXBlLCBuYW1lKSA9PiB7XG4gIC8vIGd1YXJkIGZvciBhbGlhc2VzXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCAna2V5JykpIHtcbiAgICBkYXRhVHlwZS50eXBlcyA9IHt9O1xuICAgIGRhdGFUeXBlLmtleSA9IGRhdGFUeXBlLnByb3RvdHlwZS5rZXkgPSBuYW1lO1xuICB9XG59KTtcblxuY29uc3QgZGlhbGVjdE1hcCA9IHt9O1xuZGlhbGVjdE1hcC5wb3N0Z3JlcyA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvcG9zdGdyZXMvZGF0YS10eXBlcycpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm15c3FsID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzJykoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubWFyaWFkYiA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbWFyaWFkYi9kYXRhLXR5cGVzJykoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAuc3FsaXRlID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlcycpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm1zc3FsID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzJykoRGF0YVR5cGVzKTtcblxuY29uc3QgZGlhbGVjdExpc3QgPSBPYmplY3QudmFsdWVzKGRpYWxlY3RNYXApO1xuXG5mb3IgKGNvbnN0IGRhdGFUeXBlcyBvZiBkaWFsZWN0TGlzdCkge1xuICBfLmVhY2goZGF0YVR5cGVzLCAoRGF0YVR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghRGF0YVR5cGUua2V5KSB7XG4gICAgICBEYXRhVHlwZS5rZXkgPSBEYXRhVHlwZS5wcm90b3R5cGUua2V5ID0ga2V5O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFdyYXAgYWxsIGRhdGEgdHlwZXMgdG8gbm90IHJlcXVpcmUgYG5ld2BcbmZvciAoY29uc3QgZGF0YVR5cGVzIG9mIFtEYXRhVHlwZXMsIC4uLmRpYWxlY3RMaXN0XSkge1xuICBfLmVhY2goZGF0YVR5cGVzLCAoRGF0YVR5cGUsIGtleSkgPT4ge1xuICAgIGRhdGFUeXBlc1trZXldID0gY2xhc3NUb0ludm9rYWJsZShEYXRhVHlwZSk7XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKERhdGFUeXBlcywgZGlhbGVjdE1hcCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgY2xhc3NUb0ludm9rYWJsZSB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5jbGFzcyBBQlNUUkFDVCB7XG4gIHN0YXRpYyB0b1N0cmluZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkudG9TdHJpbmcoLi4uYXJncyk7XG4gIH1cblxuICB0b1N0cmluZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TcWwoLi4uYXJncyk7XG4gIH1cblxuICB0b1NxbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3FsIGltcGxlbWVudGF0aW9uIG1pc3NpbmcnKTtcbiAgfVxufVxuXG5jbGFzcyBJTklUSUFMTFlfREVGRVJSRUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnREVGRVJSQUJMRSBJTklUSUFMTFkgREVGRVJSRUQnO1xuICB9XG59XG5cbmNsYXNzIElOSVRJQUxMWV9JTU1FRElBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnREVGRVJSQUJMRSBJTklUSUFMTFkgSU1NRURJQVRFJztcbiAgfVxufVxuXG5jbGFzcyBOT1QgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiAnTk9UIERFRkVSUkFCTEUnO1xuICB9XG59XG5cbmNsYXNzIFNFVF9ERUZFUlJFRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoY29uc3RyYWludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgfVxuXG4gIHRvU3FsKHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIHF1ZXJ5R2VuZXJhdG9yLnNldERlZmVycmVkUXVlcnkodGhpcy5jb25zdHJhaW50cyk7XG4gIH1cbn1cblxuY2xhc3MgU0VUX0lNTUVESUFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoY29uc3RyYWludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgfVxuXG4gIHRvU3FsKHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIHF1ZXJ5R2VuZXJhdG9yLnNldEltbWVkaWF0ZVF1ZXJ5KHRoaXMuY29uc3RyYWludHMpO1xuICB9XG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHByb3BlcnRpZXMgcmVsYXRlZCB0byBkZWZlcnJhYmxlIGNvbnN0cmFpbnRzLiBJdCBjYW4gYmUgdXNlZCB0b1xuICogbWFrZSBmb3JlaWduIGtleSBjb25zdHJhaW50cyBkZWZlcnJhYmxlIGFuZCB0byBzZXQgdGhlIGNvbnN0cmFpbnRzIHdpdGhpbiBhXG4gKiB0cmFuc2FjdGlvbi4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBQb3N0Z3JlU1FMLlxuICpcbiAqIFRoZSBmb3JlaWduIGtleXMgY2FuIGJlIGNvbmZpZ3VyZWQgbGlrZSB0aGlzLiBJdCB3aWxsIGNyZWF0ZSBhIGZvcmVpZ24ga2V5XG4gKiB0aGF0IHdpbGwgY2hlY2sgdGhlIGNvbnN0cmFpbnRzIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGRhdGEgd2FzIGluc2VydGVkLlxuICpcbiAqIGBgYGpzXG4gKiBzZXF1ZWxpemUuZGVmaW5lKCdNb2RlbCcsIHtcbiAqICAgZm9yZWlnbl9pZDoge1xuICogICAgIHR5cGU6IFNlcXVlbGl6ZS5JTlRFR0VSLFxuICogICAgIHJlZmVyZW5jZXM6IHtcbiAqICAgICAgIG1vZGVsOiBPdGhlck1vZGVsLFxuICogICAgICAga2V5OiAnaWQnLFxuICogICAgICAgZGVmZXJyYWJsZTogU2VxdWVsaXplLkRlZmVycmFibGUuSU5JVElBTExZX0lNTUVESUFURVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgY29uc3RyYWludHMgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gYSB0cmFuc2FjdGlvbiBsaWtlIHRoaXMuIEl0IHdpbGxcbiAqIHRyaWdnZXIgYSBxdWVyeSBvbmNlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzdGFydGVkIGFuZCBzZXQgdGhlIGNvbnN0cmFpbnRzXG4gKiB0byBiZSBjaGVja2VkIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHNlcXVlbGl6ZS50cmFuc2FjdGlvbih7XG4gKiAgIGRlZmVycmFibGU6IFNlcXVlbGl6ZS5EZWZlcnJhYmxlLlNFVF9ERUZFUlJFRFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgSU5JVElBTExZX0RFRkVSUkVEICAgIFVzZSB3aGVuIGRlY2xhcmluZyBhIGNvbnN0cmFpbnQuIEFsbG93IGFuZCBlbmFibGUgYnkgZGVmYXVsdCB0aGlzIGNvbnN0cmFpbnQncyBjaGVja3MgdG8gYmUgZGVmZXJyZWQgYXQgdGhlIGVuZCBvZiB0cmFuc2FjdGlvbnMuXG4gKiBAcHJvcGVydHkgSU5JVElBTExZX0lNTUVESUFURSAgIFVzZSB3aGVuIGRlY2xhcmluZyBhIGNvbnN0cmFpbnQuIEFsbG93IHRoZSBjb25zdHJhaW50J3MgY2hlY2tzIHRvIGJlIGRlZmVycmVkIGF0IHRoZSBlbmQgb2YgdHJhbnNhY3Rpb25zLlxuICogQHByb3BlcnR5IE5PVCAgICAgICAgICAgICAgICAgICBVc2Ugd2hlbiBkZWNsYXJpbmcgYSBjb25zdHJhaW50LiBTZXQgdGhlIGNvbnN0cmFpbnQgdG8gbm90IGRlZmVycmVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGluIFBvc3RncmVTUUwgYW5kIG1ha2VzIGl0IGltcG9zc2libGUgdG8gZHluYW1pY2FsbHkgZGVmZXIgdGhlIGNvbnN0cmFpbnRzIHdpdGhpbiBhIHRyYW5zYWN0aW9uLlxuICogQHByb3BlcnR5IFNFVF9ERUZFUlJFRCAgICAgICAgICBVc2Ugd2hlbiBkZWNsYXJpbmcgYSB0cmFuc2FjdGlvbi4gRGVmZXIgdGhlIGRlZmVycmFibGUgY2hlY2tzIGludm9sdmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gYXQgY29tbWl0LlxuICogQHByb3BlcnR5IFNFVF9JTU1FRElBVEUgICAgICAgICBVc2Ugd2hlbiBkZWNsYXJpbmcgYSB0cmFuc2FjdGlvbi4gRXhlY3V0ZSB0aGUgZGVmZXJyYWJsZSBjaGVja3MgaW52b2x2ZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS5cbiAqL1xuXG5jb25zdCBEZWZlcnJhYmxlID0ge1xuICBJTklUSUFMTFlfREVGRVJSRUQ6IGNsYXNzVG9JbnZva2FibGUoSU5JVElBTExZX0RFRkVSUkVEKSxcbiAgSU5JVElBTExZX0lNTUVESUFURTogY2xhc3NUb0ludm9rYWJsZShJTklUSUFMTFlfSU1NRURJQVRFKSxcbiAgTk9UOiBjbGFzc1RvSW52b2thYmxlKE5PVCksXG4gIFNFVF9ERUZFUlJFRDogY2xhc3NUb0ludm9rYWJsZShTRVRfREVGRVJSRUQpLFxuICBTRVRfSU1NRURJQVRFOiBjbGFzc1RvSW52b2thYmxlKFNFVF9JTU1FRElBVEUpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmVycmFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgUG9vbCwgVGltZW91dEVycm9yIH0gPSByZXF1aXJlKCdzZXF1ZWxpemUtcG9vbCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2RlcHJlY2F0aW9ucycpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdwb29sJyk7XG5cbi8qKlxuICogQWJzdHJhY3QgQ29ubmVjdGlvbiBNYW5hZ2VyXG4gKlxuICogQ29ubmVjdGlvbiBtYW5hZ2VyIHdoaWNoIGhhbmRsZXMgcG9vbGluZyAmIHJlcGxpY2F0aW9uLlxuICogVXNlcyBzZXF1ZWxpemUtcG9vbCBmb3IgcG9vbGluZ1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgY29uc3QgY29uZmlnID0gXy5jbG9uZURlZXAoc2VxdWVsaXplLmNvbmZpZyk7XG5cbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmRpYWxlY3QgPSBkaWFsZWN0O1xuICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuZGlhbGVjdE5hbWUgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3Q7XG5cbiAgICBpZiAoY29uZmlnLnBvb2wgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHBvb2w6ZmFsc2Ugd2FzIHJlbW92ZWQgaW4gdjQuMCcpO1xuICAgIH1cblxuICAgIGNvbmZpZy5wb29sID0gXy5kZWZhdWx0cyhjb25maWcucG9vbCB8fCB7fSwge1xuICAgICAgbWF4OiA1LFxuICAgICAgbWluOiAwLFxuICAgICAgaWRsZTogMTAwMDAsXG4gICAgICBhY3F1aXJlOiA2MDAwMCxcbiAgICAgIGV2aWN0OiAxMDAwLFxuICAgICAgdmFsaWRhdGU6IHRoaXMuX3ZhbGlkYXRlLmJpbmQodGhpcylcbiAgICB9KTtcblxuICAgIHRoaXMuaW5pdFBvb2xzKCk7XG4gIH1cblxuICByZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMpIHtcbiAgICBfLmVhY2goZGF0YVR5cGVzLCBkYXRhVHlwZSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCAncGFyc2UnKSkge1xuICAgICAgICBpZiAoZGF0YVR5cGUudHlwZXNbdGhpcy5kaWFsZWN0TmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZSBmdW5jdGlvbiBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICR7ZGF0YVR5cGUua2V5fSBpbiBkaWFsZWN0ICR7dGhpcy5kaWFsZWN0TmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBsb2FkIGRpYWxlY3QgbW9kdWxlIGZyb20gdmFyaW91cyBjb25maWd1cmVkIG9wdGlvbnMuXG4gICAqIFByaW9yaXR5IGdvZXMgbGlrZSBkaWFsZWN0TW9kdWxlUGF0aCA+IGRpYWxlY3RNb2R1bGUgPiByZXF1aXJlKGRlZmF1bHQpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE5hbWUgb2YgZGlhbGVjdCBtb2R1bGUgdG8gbG9va3VwXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBfbG9hZERpYWxlY3RNb2R1bGUobW9kdWxlTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVpcmUobW9kdWxlTmFtZSk7XG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGRpYWxlY3QgYXQgJHt0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgaW5zdGFsbCAke21vZHVsZU5hbWV9IHBhY2thZ2UgbWFudWFsbHlgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIHdoaWNoIGV4ZWN1dGVzIG9uIHByb2Nlc3MgZXhpdCBvciBjb25uZWN0aW9uIG1hbmFnZXIgc2h1dGRvd25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBfb25Qcm9jZXNzRXhpdCgpIHtcbiAgICBpZiAoIXRoaXMucG9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucG9vbC5kcmFpbigpO1xuICAgIGRlYnVnKCdjb25uZWN0aW9uIGRyYWluIGR1ZSB0byBwcm9jZXNzIGV4aXQnKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvb2wuZGVzdHJveUFsbE5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWluIHRoZSBwb29sIGFuZCBjbG9zZSBpdCBwZXJtYW5lbnRseVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIC8vIE1hcmsgY2xvc2Ugb2YgcG9vbFxuICAgIHRoaXMuZ2V0Q29ubmVjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24gd2FzIGNhbGxlZCBhZnRlciB0aGUgY29ubmVjdGlvbiBtYW5hZ2VyIHdhcyBjbG9zZWQhJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9vblByb2Nlc3NFeGl0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBjb25uZWN0aW9uIHBvb2wuIEJ5IGRlZmF1bHQgcG9vbCBhdXRvc3RhcnQgaXMgc2V0IHRvIGZhbHNlLCBzbyBubyBjb25uZWN0aW9uIHdpbGwgYmVcbiAgICogYmUgY3JlYXRlZCB1bmxlc3MgYHBvb2wuYWNxdWlyZWAgaXMgY2FsbGVkLlxuICAgKi9cbiAgaW5pdFBvb2xzKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgaWYgKCFjb25maWcucmVwbGljYXRpb24pIHtcbiAgICAgIHRoaXMucG9vbCA9IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbGl6ZScsXG4gICAgICAgIGNyZWF0ZTogKCkgPT4gdGhpcy5fY29ubmVjdChjb25maWcpLFxuICAgICAgICBkZXN0cm95OiBhc3luYyBjb25uZWN0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGRlc3Ryb3knKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KTtcblxuICAgICAgZGVidWcoYHBvb2wgY3JlYXRlZCB3aXRoIG1heC9taW46ICR7Y29uZmlnLnBvb2wubWF4fS8ke2NvbmZpZy5wb29sLm1pbn0sIG5vIHJlcGxpY2F0aW9uYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQpKSB7XG4gICAgICBjb25maWcucmVwbGljYXRpb24ucmVhZCA9IFtjb25maWcucmVwbGljYXRpb24ucmVhZF07XG4gICAgfVxuXG4gICAgLy8gTWFwIG1haW4gY29ubmVjdGlvbiBjb25maWdcbiAgICBjb25maWcucmVwbGljYXRpb24ud3JpdGUgPSBfLmRlZmF1bHRzKGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSwgXy5vbWl0KGNvbmZpZywgJ3JlcGxpY2F0aW9uJykpO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdHMgdG8gZWFjaCByZWFkIGNvbmZpZ1xuICAgIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkID0gY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQubWFwKHJlYWRDb25maWcgPT5cbiAgICAgIF8uZGVmYXVsdHMocmVhZENvbmZpZywgXy5vbWl0KHRoaXMuY29uZmlnLCAncmVwbGljYXRpb24nKSlcbiAgICApO1xuXG4gICAgLy8gY3VzdG9tIHBvb2xpbmcgZm9yIHJlcGxpY2F0aW9uIChvcmlnaW5hbCBhdXRob3IgQGphbm1laWVyKVxuICAgIGxldCByZWFkcyA9IDA7XG4gICAgdGhpcy5wb29sID0ge1xuICAgICAgcmVsZWFzZTogY2xpZW50ID0+IHtcbiAgICAgICAgaWYgKGNsaWVudC5xdWVyeVR5cGUgPT09ICdyZWFkJykge1xuICAgICAgICAgIHRoaXMucG9vbC5yZWFkLnJlbGVhc2UoY2xpZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBvb2wud3JpdGUucmVsZWFzZShjbGllbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWNxdWlyZTogKHF1ZXJ5VHlwZSwgdXNlTWFzdGVyKSA9PiB7XG4gICAgICAgIHVzZU1hc3RlciA9IHVzZU1hc3RlciA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB1c2VNYXN0ZXI7XG4gICAgICAgIGlmIChxdWVyeVR5cGUgPT09ICdTRUxFQ1QnICYmICF1c2VNYXN0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb29sLnJlYWQuYWNxdWlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2wud3JpdGUuYWNxdWlyZSgpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGNvbm5lY3Rpb24gPT4ge1xuICAgICAgICB0aGlzLnBvb2xbY29ubmVjdGlvbi5xdWVyeVR5cGVdLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGRlc3Ryb3knKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95QWxsTm93OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICB0aGlzLnBvb2wucmVhZC5kZXN0cm95QWxsTm93KCksXG4gICAgICAgICAgdGhpcy5wb29sLndyaXRlLmRlc3Ryb3lBbGxOb3coKVxuICAgICAgICBdKTtcblxuICAgICAgICBkZWJ1ZygnYWxsIGNvbm5lY3Rpb25zIGRlc3Ryb3llZCcpO1xuICAgICAgfSxcbiAgICAgIGRyYWluOiBhc3luYyAoKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucG9vbC53cml0ZS5kcmFpbigpLFxuICAgICAgICB0aGlzLnBvb2wucmVhZC5kcmFpbigpXG4gICAgICBdKSxcbiAgICAgIHJlYWQ6IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbGl6ZTpyZWFkJyxcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gcm91bmQgcm9iaW4gY29uZmlnXG4gICAgICAgICAgY29uc3QgbmV4dFJlYWQgPSByZWFkcysrICUgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkW25leHRSZWFkXSk7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeVR5cGUgPSAncmVhZCc7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGNvbm5lY3Rpb24gPT4gdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSksXG4gICAgICB3cml0ZTogbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiAnc2VxdWVsaXplOndyaXRlJyxcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5VHlwZSA9ICd3cml0ZSc7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGNvbm5lY3Rpb24gPT4gdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSlcbiAgICB9O1xuXG4gICAgZGVidWcoYHBvb2wgY3JlYXRlZCB3aXRoIG1heC9taW46ICR7Y29uZmlnLnBvb2wubWF4fS8ke2NvbmZpZy5wb29sLm1pbn0sIHdpdGggcmVwbGljYXRpb25gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29ubmVjdGlvbiBmcm9tIHBvb2wuIEl0IHNldHMgZGF0YWJhc2UgdmVyc2lvbiBpZiBpdCdzIG5vdCBhbHJlYWR5IHNldC5cbiAgICogQ2FsbCBwb29sLmFjcXVpcmUgdG8gZ2V0IGEgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9uc10gICAgICAgICAgICAgICAgIFBvb2wgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy50eXBlXSAgICAgICAgICAgIFNldCB3aGljaCByZXBsaWNhIHRvIHVzZS4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIGByZWFkYCBhbmQgYHdyaXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy51c2VNYXN0ZXI9ZmFsc2VdIEZvcmNlIG1hc3RlciBvciB3cml0ZSByZXBsaWNhIHRvIGdldCBjb25uZWN0aW9uIGZyb21cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59XG4gICAqL1xuICBhc3luYyBnZXRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLnZlcnNpb25Qcm9taXNlKSB7XG4gICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdCh0aGlzLmNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSB8fCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBfb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICBfb3B0aW9ucy50cmFuc2FjdGlvbiA9IHsgY29ubmVjdGlvbiB9OyAvLyBDaGVhdCAucXVlcnkgdG8gdXNlIG91ciBwcml2YXRlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIF9vcHRpb25zLmxvZ2dpbmcgPSAoKSA9PiB7fTtcbiAgICAgICAgICAgIF9vcHRpb25zLmxvZ2dpbmcuX190ZXN0TG9nZ2luZ0ZuID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9jb25uZWN0aW9uIG1pZ2h0IGhhdmUgc2V0IGRhdGFiYXNlVmVyc2lvbiB2YWx1ZSBhdCBpbml0aWFsaXphdGlvbixcbiAgICAgICAgICAgIC8vYXZvaWRpbmcgYSB1c2VsZXNzIHJvdW5kIHRyaXBcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUuZGF0YWJhc2VWZXJzaW9uKF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmVyc2lvbiA9IF8uZ2V0KHNlbXZlci5jb2VyY2UodmVyc2lvbiksICd2ZXJzaW9uJykgfHwgdmVyc2lvbjtcbiAgICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIudmFsaWQocGFyc2VkVmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IHBhcnNlZFZlcnNpb25cbiAgICAgICAgICAgICAgICA6IHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbXZlci5sdCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICBkZXByZWNhdGlvbnMudW5zdXBwb3J0ZWRFbmdpbmUoKTtcbiAgICAgICAgICAgICAgZGVidWcoYFVuc3VwcG9ydGVkIGRhdGFiYXNlIGVuZ2luZSB2ZXJzaW9uICR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb259YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnZlcnNpb25Qcm9taXNlO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5wb29sLmFjcXVpcmUob3B0aW9ucy50eXBlLCBvcHRpb25zLnVzZU1hc3Rlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFRpbWVvdXRFcnJvcikgdGhyb3cgbmV3IGVycm9ycy5Db25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBkZWJ1ZygnY29ubmVjdGlvbiBhY3F1aXJlZCcpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGEgcG9vbGVkIGNvbm5lY3Rpb24gc28gaXQgY2FuIGJlIHV0aWxpemVkIGJ5IG90aGVyIGNvbm5lY3Rpb24gcmVxdWVzdHNcbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHRoaXMucG9vbC5yZWxlYXNlKGNvbm5lY3Rpb24pO1xuICAgIGRlYnVnKCdjb25uZWN0aW9uIHJlbGVhc2VkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkaWFsZWN0IGxpYnJhcnkgdG8gZ2V0IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsqfSBjb25maWcgQ29ubmVjdGlvbiBjb25maWdcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59XG4gICAqL1xuICBhc3luYyBfY29ubmVjdChjb25maWcpIHtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYmVmb3JlQ29ubmVjdCcsIGNvbmZpZyk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0KGNvbmZpZyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2FmdGVyQ29ubmVjdCcsIGNvbm5lY3Rpb24sIGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkaWFsZWN0IGxpYnJhcnkgdG8gZGlzY29ubmVjdCBhIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdiZWZvcmVEaXNjb25uZWN0JywgY29ubmVjdGlvbik7XG4gICAgYXdhaXQgdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKCdhZnRlckRpc2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBjb25uZWN0aW9uIGlzIHN0aWxsIHZhbGlkIG9yIG5vdFxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBfdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIGlmICghdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLnZhbGlkYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLnZhbGlkYXRlKGNvbm5lY3Rpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBBYnN0cmFjdERpYWxlY3Qge31cblxuQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IHtcbiAgJ0RFRkFVTFQnOiB0cnVlLFxuICAnREVGQVVMVCBWQUxVRVMnOiBmYWxzZSxcbiAgJ1ZBTFVFUyAoKSc6IGZhbHNlLFxuICAnTElNSVQgT04gVVBEQVRFJzogZmFsc2UsXG4gICdPUkRFUiBOVUxMUyc6IGZhbHNlLFxuICAnVU5JT04nOiB0cnVlLFxuICAnVU5JT04gQUxMJzogdHJ1ZSxcbiAgJ1JJR0hUIEpPSU4nOiB0cnVlLFxuXG4gIC8qIGRvZXMgdGhlIGRpYWxlY3Qgc3VwcG9ydCByZXR1cm5pbmcgdmFsdWVzIGZvciBpbnNlcnRlZC91cGRhdGVkIGZpZWxkcyAqL1xuICByZXR1cm5WYWx1ZXM6IGZhbHNlLFxuXG4gIC8qIGZlYXR1cmVzIHNwZWNpZmljIHRvIGF1dG9JbmNyZW1lbnQgdmFsdWVzICovXG4gIGF1dG9JbmNyZW1lbnQ6IHtcbiAgICAvKiBkb2VzIHRoZSBkaWFsZWN0IHJlcXVpcmUgbW9kaWZpY2F0aW9uIG9mIGluc2VydCBxdWVyaWVzIHdoZW4gaW5zZXJ0aW5nIGF1dG8gaW5jcmVtZW50IGZpZWxkcyAqL1xuICAgIGlkZW50aXR5SW5zZXJ0OiBmYWxzZSxcblxuICAgIC8qIGRvZXMgdGhlIGRpYWxlY3Qgc3VwcG9ydCBpbnNlcnRpbmcgZGVmYXVsdC9udWxsIHZhbHVlcyBmb3IgYXV0b2luY3JlbWVudCBmaWVsZHMgKi9cbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG5cbiAgICAvKiBkb2VzIHRoZSBkaWFsZWN0IHN1cHBvcnQgdXBkYXRpbmcgYXV0b2luY3JlbWVudCBmaWVsZHMgKi9cbiAgICB1cGRhdGU6IHRydWVcbiAgfSxcbiAgLyogRG8gd2UgbmVlZCB0byBzYXkgREVGQVVMVCBmb3IgYnVsayBpbnNlcnQgKi9cbiAgYnVsa0RlZmF1bHQ6IGZhbHNlLFxuICBzY2hlbWFzOiBmYWxzZSxcbiAgdHJhbnNhY3Rpb25zOiB0cnVlLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogdHJ1ZSxcbiAgdHJhbnNhY3Rpb25PcHRpb25zOiB7XG4gICAgdHlwZTogZmFsc2VcbiAgfSxcbiAgbWlncmF0aW9uczogdHJ1ZSxcbiAgdXBzZXJ0czogdHJ1ZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6ICcnLCAvKiBkaWFsZWN0IHNwZWNpZmljIHdvcmRzIGZvciBJTlNFUlQgSUdOT1JFIG9yIERPIE5PVEhJTkcgKi9cbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogZmFsc2UsIC8qIHdoZXRoZXIgZGlhbGVjdCBzdXBwb3J0cyBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSAqL1xuICAgIG9uQ29uZmxpY3REb05vdGhpbmc6ICcnIC8qIGRpYWxlY3Qgc3BlY2lmaWMgd29yZHMgZm9yIE9OIENPTkZMSUNUIERPIE5PVEhJTkcgKi9cbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogdHJ1ZSxcbiAgICBhZGRDb25zdHJhaW50OiB0cnVlLFxuICAgIGRyb3BDb25zdHJhaW50OiB0cnVlLFxuICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBjaGVjazogdHJ1ZSxcbiAgICBmb3JlaWduS2V5OiB0cnVlLFxuICAgIHByaW1hcnlLZXk6IHRydWVcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiB0cnVlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICBjb25jdXJyZW50bHk6IGZhbHNlLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHVzaW5nOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IGZhbHNlLFxuICAgIG9wZXJhdG9yOiBmYWxzZVxuICB9LFxuICBqb2luVGFibGVEZXBlbmRlbnQ6IHRydWUsXG4gIGdyb3VwZWRMaW1pdDogdHJ1ZSxcbiAgaW5kZXhWaWFBbHRlcjogZmFsc2UsXG4gIEpTT046IGZhbHNlLFxuICBkZWZlcnJhYmxlQ29uc3RyYWludHM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0RGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLkFic3RyYWN0RGlhbGVjdCA9IEFic3RyYWN0RGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdERpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2RlcHJlY2F0aW9ucycpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vc3FsLXN0cmluZycpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbCcpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuLi8uLi9hc3NvY2lhdGlvbnMvYmFzZScpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi4vLi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8nKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKCcuLi8uLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55Jyk7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZSgnLi4vLi4vYXNzb2NpYXRpb25zL2hhcy1tYW55Jyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9ycycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IEluZGV4SGludHMgPSByZXF1aXJlKCcuLi8uLi9pbmRleC1oaW50cycpO1xuXG5jb25zdCBRdW90ZUhlbHBlciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yL2hlbHBlcnMvcXVvdGUnKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBRdWVyeSBHZW5lcmF0b3JcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2VxdWVsaXplKSB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5R2VuZXJhdG9yIGluaXRpYWxpemVkIHdpdGhvdXQgb3B0aW9ucy5zZXF1ZWxpemUnKTtcbiAgICBpZiAoIW9wdGlvbnMuX2RpYWxlY3QpIHRocm93IG5ldyBFcnJvcignUXVlcnlHZW5lcmF0b3IgaW5pdGlhbGl6ZWQgd2l0aG91dCBvcHRpb25zLl9kaWFsZWN0Jyk7XG5cbiAgICB0aGlzLnNlcXVlbGl6ZSA9IG9wdGlvbnMuc2VxdWVsaXplO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2VxdWVsaXplLm9wdGlvbnM7XG5cbiAgICAvLyBkaWFsZWN0IG5hbWVcbiAgICB0aGlzLmRpYWxlY3QgPSBvcHRpb25zLl9kaWFsZWN0Lm5hbWU7XG4gICAgdGhpcy5fZGlhbGVjdCA9IG9wdGlvbnMuX2RpYWxlY3Q7XG4gIH1cblxuICBleHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hIHx8ICdwdWJsaWMnLFxuICAgICAgdGFibGVOYW1lOiBfLmlzUGxhaW5PYmplY3QodGFibGVOYW1lKSA/IHRhYmxlTmFtZS50YWJsZU5hbWUgOiB0YWJsZU5hbWUsXG4gICAgICBkZWxpbWl0ZXI6IHRhYmxlTmFtZS5kZWxpbWl0ZXIgfHwgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy4nXG4gICAgfTtcbiAgfVxuXG4gIGFkZFNjaGVtYShwYXJhbSkge1xuICAgIGlmICghcGFyYW0uX3NjaGVtYSkgcmV0dXJuIHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVOYW1lOiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW0sXG4gICAgICB0YWJsZTogcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtLFxuICAgICAgbmFtZTogcGFyYW0ubmFtZSB8fCBwYXJhbSxcbiAgICAgIHNjaGVtYTogcGFyYW0uX3NjaGVtYSxcbiAgICAgIGRlbGltaXRlcjogcGFyYW0uX3NjaGVtYURlbGltaXRlciB8fCAnLicsXG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucXVvdGVUYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZHJvcFNjaGVtYSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5kcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZShcbiAgICAgIHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlclxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGBERVNDUklCRSAke3RhYmxlfTtgO1xuICB9XG5cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfTtgO1xuICB9XG5cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZShiZWZvcmUpfSBSRU5BTUUgVE8gJHt0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpfTtgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5zZXJ0IGludG8gY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlSGFzaCAgICAgICBhdHRyaWJ1dGUgdmFsdWUgcGFpcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsQXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbnNlcnRRdWVyeSh0YWJsZSwgdmFsdWVIYXNoLCBtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBjb25zdCByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZSk7XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gPT09IHVuZGVmaW5lZCA/IHRoaXMuYmluZFBhcmFtKGJpbmQpIDogb3B0aW9ucy5iaW5kUGFyYW07XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGxldCB2YWx1ZVF1ZXJ5ID0gJyc7XG4gICAgbGV0IGVtcHR5UXVlcnkgPSAnJztcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSAnJztcbiAgICBsZXQgcmV0dXJuaW5nRnJhZ21lbnQgPSAnJztcbiAgICBsZXQgaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBsZXQgdG1wVGFibGUgPSAnJzsgLy90bXBUYWJsZSBkZWNsYXJhdGlvbiBmb3IgdHJpZ2dlclxuXG4gICAgaWYgKG1vZGVsQXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKG1vZGVsQXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snREVGQVVMVCBWQUxVRVMnXSkge1xuICAgICAgZW1wdHlRdWVyeSArPSAnIERFRkFVTFQgVkFMVUVTJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbJ1ZBTFVFUyAoKSddKSB7XG4gICAgICBlbXB0eVF1ZXJ5ICs9ICcgVkFMVUVTICgpJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLnB1c2goLi4ucmV0dXJuVmFsdWVzLnJldHVybkZpZWxkcyk7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIHRtcFRhYmxlID0gcmV0dXJuVmFsdWVzLnRtcFRhYmxlIHx8ICcnO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQgfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKF8uZ2V0KHRoaXMsIFsnc2VxdWVsaXplJywgJ29wdGlvbnMnLCAnZGlhbGVjdE9wdGlvbnMnLCAncHJlcGVuZFNlYXJjaFBhdGgnXSkgfHwgb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICAvLyBOb3QgY3VycmVudGx5IHN1cHBvcnRlZCB3aXRoIHNlYXJjaCBwYXRoIChyZXF1aXJlcyBvdXRwdXQgb2YgbXVsdGlwbGUgcXVlcmllcylcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuRVhDRVBUSU9OICYmIG9wdGlvbnMuZXhjZXB0aW9uKSB7XG4gICAgICAvLyBOb3QgY3VycmVudGx5IHN1cHBvcnRlZCB3aXRoIGJpbmQgcGFyYW1ldGVycyAocmVxdWlyZXMgb3V0cHV0IG9mIG11bHRpcGxlIHF1ZXJpZXMpXG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaCh2YWx1ZUhhc2gsIHRoaXMub3B0aW9ucy5vbWl0TnVsbCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVIYXNoKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlSGFzaCwga2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlSGFzaFtrZXldO1xuICAgICAgICBmaWVsZHMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcblxuICAgICAgICAvLyBTRVJJQUxTJyBjYW4ndCBiZSBOVUxMIGluIHBvc3RncmVzcWwsIHVzZSBERUZBVUxUIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBmaWVsZHMuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuREVGQVVMVCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goJ0RFRkFVTFQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5lc2NhcGUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlkZW50aXR5V3JhcHBlclJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ0lOU0VSVCcgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ0lOU0VSVCcgfSwgYmluZFBhcmFtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG9uRHVwbGljYXRlS2V5VXBkYXRlID0gJyc7XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlICYmIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgPT0gJyBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUJykgeyAvLyBwb3N0Z3JlcyAvIHNxbGl0ZVxuICAgICAgICAvLyBJZiBubyBjb25mbGljdCB0YXJnZXQgY29sdW1ucyB3ZXJlIHNwZWNpZmllZCwgdXNlIHRoZSBwcmltYXJ5IGtleSBuYW1lcyBmcm9tIG9wdGlvbnMudXBzZXJ0S2V5c1xuICAgICAgICBjb25zdCBjb25mbGljdEtleXMgPSBvcHRpb25zLnVwc2VydEtleXMubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpO1xuICAgICAgICBjb25zdCB1cGRhdGVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoYXR0ciA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09RVhDTFVERUQuJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gKTtcbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBgIE9OIENPTkZMSUNUICgke2NvbmZsaWN0S2V5cy5qb2luKCcsJyl9KSBETyBVUERBVEUgU0VUICR7dXBkYXRlS2V5cy5qb2luKCcsJyl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKGF0dHIgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PVZBTFVFUygke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSlgKTtcbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgKz0gYCR7dGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlfSAke3ZhbHVlS2V5cy5qb2luKCcsJyl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7XG4gICAgICBpZ25vcmVEdXBsaWNhdGVzOiBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMuaWdub3JlRHVwbGljYXRlcyA6ICcnLFxuICAgICAgb25Db25mbGljdERvTm90aGluZzogb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3REb05vdGhpbmcgOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGZpZWxkcy5qb2luKCcsJyksXG4gICAgICBvdXRwdXQ6IG91dHB1dEZyYWdtZW50LFxuICAgICAgdmFsdWVzOiB2YWx1ZXMuam9pbignLCcpLFxuICAgICAgdG1wVGFibGVcbiAgICB9O1xuXG4gICAgdmFsdWVRdWVyeSA9IGAke3RtcFRhYmxlfUlOU0VSVCR7cmVwbGFjZW1lbnRzLmlnbm9yZUR1cGxpY2F0ZXN9IElOVE8gJHtxdW90ZWRUYWJsZX0gKCR7cmVwbGFjZW1lbnRzLmF0dHJpYnV0ZXN9KSR7cmVwbGFjZW1lbnRzLm91dHB1dH0gVkFMVUVTICgke3JlcGxhY2VtZW50cy52YWx1ZXN9KSR7b25EdXBsaWNhdGVLZXlVcGRhdGV9JHtyZXBsYWNlbWVudHMub25Db25mbGljdERvTm90aGluZ30ke3ZhbHVlUXVlcnl9YDtcbiAgICBlbXB0eVF1ZXJ5ID0gYCR7dG1wVGFibGV9SU5TRVJUJHtyZXBsYWNlbWVudHMuaWdub3JlRHVwbGljYXRlc30gSU5UTyAke3F1b3RlZFRhYmxlfSR7cmVwbGFjZW1lbnRzLm91dHB1dH0ke29uRHVwbGljYXRlS2V5VXBkYXRlfSR7cmVwbGFjZW1lbnRzLm9uQ29uZmxpY3REb05vdGhpbmd9JHtlbXB0eVF1ZXJ5fWA7XG5cbiAgICAvLyBNb3N0bHkgZm9yIGludGVybmFsIHVzZSwgc28gd2UgZXhwZWN0IHRoZSB1c2VyIHRvIGtub3cgd2hhdCBoZSdzIGRvaW5nIVxuICAgIC8vIHBnX3RlbXAgZnVuY3Rpb25zIGFyZSBwcml2YXRlIHBlciBjb25uZWN0aW9uLCBzbyB3ZSBuZXZlciByaXNrIHRoaXMgZnVuY3Rpb24gaW50ZXJmZXJpbmcgd2l0aCBhbm90aGVyIG9uZS5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5FWENFUFRJT04gJiYgb3B0aW9ucy5leGNlcHRpb24pIHtcbiAgICAgIGNvbnN0IGRyb3BGdW5jdGlvbiA9ICdEUk9QIEZVTkNUSU9OIElGIEVYSVNUUyBwZ190ZW1wLnRlc3RmdW5jKCknO1xuXG4gICAgICBpZiAocmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMucHVzaCgnKicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBgJGZ1bmNfJHt1dWlkdjQoKS5yZXBsYWNlKC8tL2csICcnKX0kYDtcbiAgICAgIGNvbnN0IHNlbGVjdFF1ZXJ5ID0gYFNFTEVDVCAodGVzdGZ1bmMucmVzcG9uc2UpLiR7cmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmpvaW4oJywgKHRlc3RmdW5jLnJlc3BvbnNlKS4nKX0sIHRlc3RmdW5jLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uIEZST00gcGdfdGVtcC50ZXN0ZnVuYygpO2A7XG5cbiAgICAgIG9wdGlvbnMuZXhjZXB0aW9uID0gJ1dIRU4gdW5pcXVlX3Zpb2xhdGlvbiBUSEVOIEdFVCBTVEFDS0VEIERJQUdOT1NUSUNTIHNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uID0gUEdfRVhDRVBUSU9OX0RFVEFJTDsnO1xuICAgICAgdmFsdWVRdWVyeSA9IGBDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTiBwZ190ZW1wLnRlc3RmdW5jKE9VVCByZXNwb25zZSAke3F1b3RlZFRhYmxlfSwgT1VUIHNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uIHRleHQpIFJFVFVSTlMgUkVDT1JEIEFTICR7ZGVsaW1pdGVyfSBCRUdJTiAke3ZhbHVlUXVlcnl9IFJFVFVSTklORyAqIElOVE8gcmVzcG9uc2U7IEVYQ0VQVElPTiAke29wdGlvbnMuZXhjZXB0aW9ufSBFTkQgJHtkZWxpbWl0ZXJ9IExBTkdVQUdFIHBscGdzcWw7ICR7c2VsZWN0UXVlcnl9ICR7ZHJvcEZ1bmN0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlUXVlcnkgKz0gcmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICBlbXB0eVF1ZXJ5ICs9IHJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cblxuICAgIHF1ZXJ5ID0gYCR7cmVwbGFjZW1lbnRzLmF0dHJpYnV0ZXMubGVuZ3RoID8gdmFsdWVRdWVyeSA6IGVtcHR5UXVlcnl9O2A7XG4gICAgaWYgKGlkZW50aXR5V3JhcHBlclJlcXVpcmVkICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC5pZGVudGl0eUluc2VydCkge1xuICAgICAgcXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPTjsgJHtxdWVyeX0gU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPRkY7YDtcbiAgICB9XG5cbiAgICAvLyBVc2VkIGJ5IFBvc3RncmVzIHVwc2VydFF1ZXJ5IGFuZCBjYWxscyB0byBoZXJlIHdpdGggb3B0aW9ucy5leGNlcHRpb24gc2V0IHRvIHRydWVcbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgaWYgKG9wdGlvbnMuYmluZFBhcmFtICE9PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmJpbmQgPSBiaW5kO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbnNlcnQgaW50byBjb21tYW5kIGZvciBtdWx0aXBsZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpZWxkVmFsdWVIYXNoZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpZWxkTWFwcGVkQXR0cmlidXRlc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRWYWx1ZUhhc2hlcywgb3B0aW9ucywgZmllbGRNYXBwZWRBdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgY29uc3QgdHVwbGVzID0gW107XG4gICAgY29uc3Qgc2VyaWFscyA9IHt9O1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBsZXQgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSAnJztcblxuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZUhhc2ggb2YgZmllbGRWYWx1ZUhhc2hlcykge1xuICAgICAgXy5mb3JPd24oZmllbGRWYWx1ZUhhc2gsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICghYWxsQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldXG4gICAgICAgICAgJiYgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZVxuICAgICAgICApIHtcbiAgICAgICAgICBzZXJpYWxzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKGtleSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmJ1bGtEZWZhdWx0XG4gICAgICAgICAgJiYgc2VyaWFsc1trZXldID09PSB0cnVlXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlSGFzaFtrZXldIHx8ICdERUZBVUxUJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZShmaWVsZFZhbHVlSGFzaFtrZXldLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSwgeyBjb250ZXh0OiAnSU5TRVJUJyB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0dXBsZXMucHVzaChgKCR7dmFsdWVzLmpvaW4oJywnKX0pYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSAmJiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlID09ICcgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVCcpIHsgLy8gcG9zdGdyZXMgLyBzcWxpdGVcbiAgICAgICAgLy8gSWYgbm8gY29uZmxpY3QgdGFyZ2V0IGNvbHVtbnMgd2VyZSBzcGVjaWZpZWQsIHVzZSB0aGUgcHJpbWFyeSBrZXkgbmFtZXMgZnJvbSBvcHRpb25zLnVwc2VydEtleXNcbiAgICAgICAgY29uc3QgY29uZmxpY3RLZXlzID0gb3B0aW9ucy51cHNlcnRLZXlzLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKGF0dHIgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PUVYQ0xVREVELiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCk7XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gYCBPTiBDT05GTElDVCAoJHtjb25mbGljdEtleXMuam9pbignLCcpfSkgRE8gVVBEQVRFIFNFVCAke3VwZGF0ZUtleXMuam9pbignLCcpfWA7XG4gICAgICB9IGVsc2UgeyAvLyBteXNxbCAvIG1hcmlhXG4gICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUubWFwKGF0dHIgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PVZBTFVFUygke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSlgKTtcbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGV9ICR7dmFsdWVLZXlzLmpvaW4oJywnKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlnbm9yZUR1cGxpY2F0ZXMgPSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMuaWdub3JlRHVwbGljYXRlcyA6ICcnO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcChhdHRyID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKCcsJyk7XG4gICAgY29uc3Qgb25Db25mbGljdERvTm90aGluZyA9IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0RG9Ob3RoaW5nIDogJyc7XG4gICAgbGV0IHJldHVybmluZyA9ICcnO1xuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGZpZWxkTWFwcGVkQXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybmluZyArPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0lOU0VSVCcsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzLFxuICAgICAgJ0lOVE8nLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBgKCR7YXR0cmlidXRlc30pYCxcbiAgICAgICdWQUxVRVMnLFxuICAgICAgdHVwbGVzLmpvaW4oJywnKSxcbiAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlLFxuICAgICAgb25Db25mbGljdERvTm90aGluZyxcbiAgICAgIHJldHVybmluZyxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gdXBkYXRlIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJWYWx1ZUhhc2hcbiAgICogQHBhcmFtIHtvYmplY3R9IHdoZXJlIEEgaGFzaCB3aXRoIGNvbmRpdGlvbnMgKGUuZy4ge25hbWU6ICdmb28nfSkgT1IgYW4gSUQgYXMgaW50ZWdlclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcblxuICAgIGF0dHJWYWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2goYXR0clZhbHVlSGFzaCwgb3B0aW9ucy5vbWl0TnVsbCwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSAnJztcbiAgICBsZXQgdG1wVGFibGUgPSAnJzsgLy8gdG1wVGFibGUgZGVjbGFyYXRpb24gZm9yIHRyaWdnZXJcbiAgICBsZXQgc3VmZml4ID0gJyc7XG5cbiAgICBpZiAoXy5nZXQodGhpcywgWydzZXF1ZWxpemUnLCAnb3B0aW9ucycsICdkaWFsZWN0T3B0aW9ucycsICdwcmVwZW5kU2VhcmNoUGF0aCddKSB8fCBvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIC8vIE5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIHdpdGggc2VhcmNoIHBhdGggKHJlcXVpcmVzIG91dHB1dCBvZiBtdWx0aXBsZSBxdWVyaWVzKVxuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5iaW5kUGFyYW0oYmluZCkgOiBvcHRpb25zLmJpbmRQYXJhbTtcblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydMSU1JVCBPTiBVUERBVEUnXSAmJiBvcHRpb25zLmxpbWl0KSB7XG4gICAgICBpZiAodGhpcy5kaWFsZWN0ICE9PSAnbXNzcWwnKSB7XG4gICAgICAgIHN1ZmZpeCA9IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoYXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICAgIHN1ZmZpeCArPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICB0bXBUYWJsZSA9IHJldHVyblZhbHVlcy50bXBUYWJsZSB8fCAnJztcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50IHx8ICcnO1xuXG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuIG91dHB1dCBpcyBwcm9wZXJseSBtYXBwZWQgdG8gbW9kZWwgZmllbGRzLlxuICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5vdXRwdXQgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgb3B0aW9ucy5tYXBUb01vZGVsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0clZhbHVlSGFzaCkge1xuICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiZcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlICYmXG4gICAgICAgICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQudXBkYXRlKSB7XG4gICAgICAgIC8vIG5vdCBhbGxvd2VkIHRvIHVwZGF0ZSBpZGVudGl0eSBjb2x1bW5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0clZhbHVlSGFzaFtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdW5kZWZpbmVkLCB7IGNvbnRleHQ6ICdVUERBVEUnIH0pfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ1VQREFURScgfSwgYmluZFBhcmFtKX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3aGVyZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGJpbmRQYXJhbSB9O1xuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeSA9IGAke3RtcFRhYmxlfVVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbignLCcpfSR7b3V0cHV0RnJhZ21lbnR9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfSR7c3VmZml4fWAudHJpbSgpO1xuICAgIC8vIFVzZWQgYnkgUG9zdGdyZXMgdXBzZXJ0UXVlcnkgYW5kIGNhbGxzIHRvIGhlcmUgd2l0aCBvcHRpb25zLmV4Y2VwdGlvbiBzZXQgdG8gdHJ1ZVxuICAgIGNvbnN0IHJlc3VsdCA9IHsgcXVlcnkgfTtcbiAgICBpZiAob3B0aW9ucy5iaW5kUGFyYW0gIT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuYmluZCA9IGJpbmQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiB1cGRhdGUgcXVlcnkgdXNpbmcgYXJpdGhtZXRpYyBvcGVyYXRvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgICAgICAgICAgICAgICAgICAgIFN0cmluZyB3aXRoIHRoZSBhcml0aG1ldGljIG9wZXJhdG9yIChlLmcuICcrJyBvciAnLScpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgICAgICAgICAgICAgICAgICAgTmFtZSBvZiB0aGUgdGFibGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHdoZXJlICAgICAgICAgICAgICAgICAgICAgICBBIHBsYWluLW9iamVjdCB3aXRoIGNvbmRpdGlvbnMgKGUuZy4ge25hbWU6ICdmb28nfSkgT1IgYW4gSUQgYXMgaW50ZWdlclxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5jcmVtZW50QW1vdW50c0J5RmllbGQgICAgIEEgcGxhaW4tb2JqZWN0IHdpdGggYXR0cmlidXRlLXZhbHVlLXBhaXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCAgQSBwbGFpbi1vYmplY3Qgd2l0aCBhdHRyaWJ1dGUtdmFsdWUtcGFpcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFyaXRobWV0aWNRdWVyeShvcGVyYXRvciwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB7IHJldHVybmluZzogdHJ1ZSB9KTtcblxuICAgIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCB0aGlzLm9wdGlvbnMub21pdE51bGwpO1xuXG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gJyc7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gJyc7XG5cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobnVsbCwgb3B0aW9ucyk7XG5cbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50O1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlU2V0U3FsRnJhZ21lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCkge1xuICAgICAgY29uc3QgaW5jcmVtZW50QW1vdW50ID0gaW5jcmVtZW50QW1vdW50c0J5RmllbGRbZmllbGRdO1xuICAgICAgY29uc3QgcXVvdGVkRmllbGQgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICBjb25zdCBlc2NhcGVkQW1vdW50ID0gdGhpcy5lc2NhcGUoaW5jcmVtZW50QW1vdW50KTtcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5wdXNoKGAke3F1b3RlZEZpZWxkfT0ke3F1b3RlZEZpZWxkfSR7b3BlcmF0b3J9ICR7ZXNjYXBlZEFtb3VudH1gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZFtmaWVsZF07XG4gICAgICBjb25zdCBxdW90ZWRGaWVsZCA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHRoaXMuZXNjYXBlKG5ld1ZhbHVlKTtcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5wdXNoKGAke3F1b3RlZEZpZWxkfT0ke2VzY2FwZWRWYWx1ZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnVVBEQVRFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ1NFVCcsXG4gICAgICB1cGRhdGVTZXRTcWxGcmFnbWVudHMuam9pbignLCcpLFxuICAgICAgb3V0cHV0RnJhZ21lbnQsXG4gICAgICB0aGlzLndoZXJlUXVlcnkod2hlcmUpLFxuICAgICAgcmV0dXJuaW5nRnJhZ21lbnRcbiAgICBdKTtcbiAgfVxuXG4gIC8qXG4gICAgUmV0dXJucyBhbiBhZGQgaW5kZXggcXVlcnkuXG4gICAgUGFyYW1ldGVyczpcbiAgICAgIC0gdGFibGVOYW1lIC0+IE5hbWUgb2YgYW4gZXhpc3RpbmcgdGFibGUsIHBvc3NpYmx5IHdpdGggc2NoZW1hLlxuICAgICAgLSBvcHRpb25zOlxuICAgICAgICAtIHR5cGU6IFVOSVFVRXxGVUxMVEVYVHxTUEFUSUFMXG4gICAgICAgIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGluZGV4LiBEZWZhdWx0IGlzIDx0YWJsZT5fPGF0dHIxPl88YXR0cjI+XG4gICAgICAgIC0gZmllbGRzOiBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzIGFzIHN0cmluZyBvciBhcyBoYXNoLlxuICAgICAgICAgICAgICAgICAgSWYgdGhlIGF0dHJpYnV0ZSBpcyBhIGhhc2gsIGl0IG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUvY29sdW1uXG4gICAgICAgICAgICAgICAgICAtIGxlbmd0aDogQW4gaW50ZWdlci4gT3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgIC0gb3JkZXI6ICdBU0MnIG9yICdERVNDJy4gT3B0aW9uYWxcbiAgICAgICAgLSBwYXJzZXJcbiAgICAgICAgLSB1c2luZ1xuICAgICAgICAtIG9wZXJhdG9yXG4gICAgICAgIC0gY29uY3VycmVudGx5OiBQYXNzIENPTkNVUlJFTlQgc28gb3RoZXIgb3BlcmF0aW9ucyBydW4gd2hpbGUgdGhlIGluZGV4IGlzIGNyZWF0ZWRcbiAgICAgIC0gcmF3VGFibGVuYW1lLCB0aGUgbmFtZSBvZiB0aGUgdGFibGUsIHdpdGhvdXQgc2NoZW1hLiBVc2VkIHRvIGNyZWF0ZSB0aGUgbmFtZSBvZiB0aGUgaW5kZXhcbiAgIEBwcml2YXRlXG4gICovXG4gIGFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgb3B0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCByYXdUYWJsZW5hbWUgfHwgdGFibGVOYW1lO1xuICAgIGlmIChvcHRpb25zLnByZWZpeCAmJiB0eXBlb2Ygb3B0aW9ucy5wcmVmaXggPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4LnJlcGxhY2UoL1xcLi9nLCAnXycpO1xuICAgICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeC5yZXBsYWNlKC8oXCJ8JykvZywgJycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkc1NxbCA9IG9wdGlvbnMuZmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgIG5hbWU6IGZpZWxkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgICAgIGlmIChmaWVsZC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgZmllbGQubmFtZSA9IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaWVsZC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBpbmRleCBmaWVsZCBoYXMgbm8gbmFtZTogJHt1dGlsLmluc3BlY3QoZmllbGQpfWApO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQubmFtZSk7XG5cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LmNvbGxhdGUgJiYgZmllbGQuY29sbGF0ZSkge1xuICAgICAgICByZXN1bHQgKz0gYCBDT0xMQVRFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQuY29sbGF0ZSl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgub3BlcmF0b3IpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWVsZC5vcGVyYXRvciB8fCBvcHRpb25zLm9wZXJhdG9yO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCAke29wZXJhdG9yfWA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgubGVuZ3RoICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gYCgke2ZpZWxkLmxlbmd0aH0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLm9yZGVyKSB7XG4gICAgICAgIHJlc3VsdCArPSBgICR7ZmllbGQub3JkZXJ9YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAvLyBNb3N0bHkgZm9yIGNhc2VzIHdoZXJlIGFkZEluZGV4IGlzIGNhbGxlZCBkaXJlY3RseSBieSB0aGUgdXNlciB3aXRob3V0IGFuIG9wdGlvbnMgb2JqZWN0IChmb3IgZXhhbXBsZSBpbiBtaWdyYXRpb25zKVxuICAgICAgLy8gQWxsIGNhbGxzIHRoYXQgZ28gdGhyb3VnaCBzZXF1ZWxpemUgc2hvdWxkIGFscmVhZHkgaGF2ZSBhIG5hbWVcbiAgICAgIG9wdGlvbnMgPSBVdGlscy5uYW1lSW5kZXgob3B0aW9ucywgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBNb2RlbC5fY29uZm9ybUluZGV4KG9wdGlvbnMpO1xuXG4gICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnR5cGUpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLndoZXJlUXVlcnkob3B0aW9ucy53aGVyZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uY3VycmVudGx5ID0gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5jb25jdXJyZW50bHkgJiYgb3B0aW9ucy5jb25jdXJyZW50bHkgPyAnQ09OQ1VSUkVOVExZJyA6IHVuZGVmaW5lZDtcbiAgICBsZXQgaW5kO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIpIHtcbiAgICAgIGluZCA9IFtcbiAgICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBjb25jdXJyZW50bHksXG4gICAgICAgICdBREQnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmQgPSBbJ0NSRUFURSddO1xuICAgIH1cblxuICAgIGluZCA9IGluZC5jb25jYXQoXG4gICAgICBvcHRpb25zLnVuaXF1ZSA/ICdVTklRVUUnIDogJycsXG4gICAgICBvcHRpb25zLnR5cGUsICdJTkRFWCcsXG4gICAgICAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyID8gY29uY3VycmVudGx5IDogdW5kZWZpbmVkLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXJzKG9wdGlvbnMubmFtZSksXG4gICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnVzaW5nID09PSAxICYmIG9wdGlvbnMudXNpbmcgPyBgVVNJTkcgJHtvcHRpb25zLnVzaW5nfWAgOiAnJyxcbiAgICAgICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIgPyBgT04gJHt0YWJsZU5hbWV9YCA6IHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudXNpbmcgPT09IDIgJiYgb3B0aW9ucy51c2luZyA/IGBVU0lORyAke29wdGlvbnMudXNpbmd9YCA6ICcnLFxuICAgICAgYCgke2ZpZWxkc1NxbC5qb2luKCcsICcpfSlgLFxuICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5wYXJzZXIgJiYgb3B0aW9ucy5wYXJzZXIgPyBgV0lUSCBQQVJTRVIgJHtvcHRpb25zLnBhcnNlcn1gIDogdW5kZWZpbmVkLFxuICAgICAgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC53aGVyZSAmJiBvcHRpb25zLndoZXJlID8gb3B0aW9ucy53aGVyZSA6IHVuZGVmaW5lZFxuICAgICk7XG5cbiAgICByZXR1cm4gXy5jb21wYWN0KGluZCkuam9pbignICcpO1xuICB9XG5cbiAgYWRkQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0YWJsZU5hbWUsXG4gICAgICAnQUREJyxcbiAgICAgIHRoaXMuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGNvbnN0cmFpbnRTbmlwcGV0LCBjb25zdHJhaW50TmFtZTtcblxuICAgIGNvbnN0IGZpZWxkc1NxbCA9IG9wdGlvbnMuZmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQuYXR0cmlidXRlKSB7XG4gICAgICAgIGZpZWxkLm5hbWUgPSBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmllbGQubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgaW5kZXggZmllbGQgaGFzIG5vIG5hbWU6ICR7ZmllbGR9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5uYW1lKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZpZWxkc1NxbFF1b3RlZFN0cmluZyA9IGZpZWxkc1NxbC5qb2luKCcsICcpO1xuICAgIGNvbnN0IGZpZWxkc1NxbFN0cmluZyA9IGZpZWxkc1NxbC5qb2luKCdfJyk7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdVTklRVUUnOlxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV91a2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFVOSVFVRSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ0hFQ0snOlxuICAgICAgICBvcHRpb25zLndoZXJlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkob3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X2NrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gQ0hFQ0sgKCR7b3B0aW9ucy53aGVyZX0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdERUZBVUxUJzpcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdmFsdWUgbXVzdCBiZSBzcGVjaWZlZCBmb3IgREVGQVVMVCBDT05TVFJBSU5UJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGlhbGVjdC5uYW1lICE9PSAnbXNzcWwnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IGNvbnN0cmFpbnRzIGFyZSBzdXBwb3J0ZWQgb25seSBmb3IgTVNTUUwgZGlhbGVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X2RmYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gREVGQVVMVCAoJHt0aGlzLmVzY2FwZShvcHRpb25zLmRlZmF1bHRWYWx1ZSl9KSBGT1IgJHtmaWVsZHNTcWxbMF19YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQUklNQVJZIEtFWSc6XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X3BrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gUFJJTUFSWSBLRVkgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ZPUkVJR04gS0VZJzpcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IG9wdGlvbnMucmVmZXJlbmNlcztcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VzIHx8ICFyZWZlcmVuY2VzLnRhYmxlIHx8ICEocmVmZXJlbmNlcy5maWVsZCB8fCByZWZlcmVuY2VzLmZpZWxkcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZmVyZW5jZXMgb2JqZWN0IHdpdGggdGFibGUgYW5kIGZpZWxkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fJHtyZWZlcmVuY2VzLnRhYmxlfV9ma2ApO1xuICAgICAgICBjb25zdCBxdW90ZWRSZWZlcmVuY2VzID1cbiAgICAgICAgICB0eXBlb2YgcmVmZXJlbmNlcy5maWVsZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gdGhpcy5xdW90ZUlkZW50aWZpZXIocmVmZXJlbmNlcy5maWVsZClcbiAgICAgICAgICAgIDogcmVmZXJlbmNlcy5maWVsZHMubWFwKGYgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZikpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXNTbmlwcGV0ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHJlZmVyZW5jZXMudGFibGUpfSAoJHtxdW90ZWRSZWZlcmVuY2VzfSlgO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IGA7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGBGT1JFSUdOIEtFWSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KSBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1NuaXBwZXR9YDtcbiAgICAgICAgaWYgKG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIFVQREFURSAke29wdGlvbnMub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uRGVsZXRlKSB7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBERUxFVEUgJHtvcHRpb25zLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLnR5cGV9IGlzIGludmFsaWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGVmZXJyYWJsZSAmJiBbJ1VOSVFVRScsICdQUklNQVJZIEtFWScsICdGT1JFSUdOIEtFWSddLmluY2x1ZGVzKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCAke3RoaXMuZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cmFpbnRTbmlwcGV0O1xuICB9XG5cbiAgcmVtb3ZlQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGFibGVOYW1lLFxuICAgICAgJ0RST1AgQ09OU1RSQUlOVCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcnMoY29uc3RyYWludE5hbWUpXG4gICAgXSk7XG4gIH1cblxuICAvKlxuICAgIFF1b3RlIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgdHlwZS4gVGhpcyBpcyBhIG1vcmUgZ2VuZXJhbCB2ZXJzaW9uIG9mIHF1b3RlSWRlbnRpZmllcnNcbiAgICBTdHJpbmdzOiBzaG91bGQgcHJveHkgdG8gcXVvdGVJZGVudGlmaWVyc1xuICAgIEFycmF5czpcbiAgICAgICogRXhwZWN0cyBhcnJheSBpbiB0aGUgZm9ybTogWzxtb2RlbD4gKG9wdGlvbmFsKSwgPG1vZGVsPiAob3B0aW9uYWwpLC4uLiBTdHJpbmcsIFN0cmluZyAob3B0aW9uYWwpXVxuICAgICAgICBFYWNoIDxtb2RlbD4gY2FuIGJlIGEgbW9kZWwsIG9yIGFuIG9iamVjdCB7bW9kZWw6IE1vZGVsLCBhczogU3RyaW5nfSwgbWF0Y2hpbmcgaW5jbHVkZSwgb3IgYW5cbiAgICAgICAgYXNzb2NpYXRpb24gb2JqZWN0LCBvciB0aGUgbmFtZSBvZiBhbiBhc3NvY2lhdGlvbi5cbiAgICAgICogWmVybyBvciBtb3JlIG1vZGVscyBjYW4gYmUgaW5jbHVkZWQgaW4gdGhlIGFycmF5IGFuZCBhcmUgdXNlZCB0byB0cmFjZSBhIHBhdGggdGhyb3VnaCB0aGUgdHJlZSBvZlxuICAgICAgICBpbmNsdWRlZCBuZXN0ZWQgYXNzb2NpYXRpb25zLiBUaGlzIHByb2R1Y2VzIHRoZSBjb3JyZWN0IHRhYmxlIG5hbWUgZm9yIHRoZSBPUkRFUiBCWS9HUk9VUCBCWSBTUUxcbiAgICAgICAgYW5kIHF1b3RlcyBpdC5cbiAgICAgICogSWYgYSBzaW5nbGUgc3RyaW5nIGlzIGFwcGVuZGVkIHRvIGVuZCBvZiBhcnJheSwgaXQgaXMgcXVvdGVkLlxuICAgICAgICBJZiB0d28gc3RyaW5ncyBhcHBlbmRlZCwgdGhlIDFzdCBzdHJpbmcgaXMgcXVvdGVkLCB0aGUgMm5kIHN0cmluZyB1bnF1b3RlZC5cbiAgICBPYmplY3RzOlxuICAgICAgKiBJZiByYXcgaXMgc2V0LCB0aGF0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCB2ZXJiYXRpbSwgd2l0aG91dCBxdW90aW5nXG4gICAgICAqIElmIGZuIGlzIHNldCwgdGhlIHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCB0aGUgdmFsdWUgb2YgZm4sIHN0YXJ0aW5nIHBhcmVuLCBmb2xsb3dlZCBieVxuICAgICAgICB0aGUgdmFsdWVzIG9mIGNvbHMgKHdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkpLCBxdW90ZWQgYW5kIGpvaW5lZCB3aXRoICcsICcsXG4gICAgICAgIHVubGVzcyB0aGV5IGFyZSB0aGVtc2VsdmVzIG9iamVjdHNcbiAgICAgICogSWYgZGlyZWN0aW9uIGlzIHNldCwgc2hvdWxkIGJlIHByZXBlbmRlZFxuXG4gICAgQ3VycmVudGx5IHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGZvciBvcmRlcmluZyAvIGdyb3VwaW5nIGNvbHVtbnMgYW5kIFNlcXVlbGl6ZS5jb2woKSwgYnV0IGl0IGNvdWxkXG4gICAgcG90ZW50aWFsbHkgYWxzbyBiZSB1c2VkIGZvciBvdGhlciBwbGFjZXMgd2hlcmUgd2Ugd2FudCB0byBiZSBhYmxlIHRvIGNhbGwgU1FMIGZ1bmN0aW9ucyAoZS5nLiBhcyBkZWZhdWx0IHZhbHVlcylcbiAgIEBwcml2YXRlXG4gICovXG4gIHF1b3RlKGNvbGxlY3Rpb24sIHBhcmVudCwgY29ubmVjdG9yKSB7XG4gICAgLy8gaW5pdFxuICAgIGNvbnN0IHZhbGlkT3JkZXJPcHRpb25zID0gW1xuICAgICAgJ0FTQycsXG4gICAgICAnREVTQycsXG4gICAgICAnQVNDIE5VTExTIExBU1QnLFxuICAgICAgJ0RFU0MgTlVMTFMgTEFTVCcsXG4gICAgICAnQVNDIE5VTExTIEZJUlNUJyxcbiAgICAgICdERVNDIE5VTExTIEZJUlNUJyxcbiAgICAgICdOVUxMUyBGSVJTVCcsXG4gICAgICAnTlVMTFMgTEFTVCdcbiAgICBdO1xuXG4gICAgLy8gZGVmYXVsdFxuICAgIGNvbm5lY3RvciA9IGNvbm5lY3RvciB8fCAnLic7XG5cbiAgICAvLyBqdXN0IHF1b3RlIGFzIGlkZW50aWZpZXJzIGlmIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAvLyBpdGVyYXRlIHRocm91Z2ggdGhlIGNvbGxlY3Rpb24gYW5kIG11dGF0ZSBvYmplY3RzIGludG8gYXNzb2NpYXRpb25zXG4gICAgICBjb2xsZWN0aW9uLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gY29sbGVjdGlvbltpbmRleCAtIDFdO1xuICAgICAgICBsZXQgcHJldmlvdXNBc3NvY2lhdGlvbjtcbiAgICAgICAgbGV0IHByZXZpb3VzTW9kZWw7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwcmV2aW91cyBhcyB0aGUgcGFyZW50IHdoZW4gcHJldmlvdXMgaXMgdW5kZWZpbmVkIG9yIHRoZSB0YXJnZXQgb2YgdGhlIGFzc29jaWF0aW9uXG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgcGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcmV2aW91c01vZGVsID0gcGFyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzICYmIHByZXZpb3VzIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBwcmV2aW91c0Fzc29jaWF0aW9uID0gcHJldmlvdXM7XG4gICAgICAgICAgcHJldmlvdXNNb2RlbCA9IHByZXZpb3VzLnRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIGlzIGEgbW9kZWwsIHRoZW4gYXR0ZW1wdCBnZXR0aW5nIGFuIGFzc29jaWF0aW9uXG4gICAgICAgIGlmIChwcmV2aW91c01vZGVsICYmIHByZXZpb3VzTW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgICAgbGV0IGFzO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIHNldFxuICAgICAgICAgICAgbW9kZWwgPSBpdGVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pICYmIGl0ZW0ubW9kZWwgJiYgaXRlbS5tb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgICBtb2RlbCA9IGl0ZW0ubW9kZWw7XG4gICAgICAgICAgICBhcyA9IGl0ZW0uYXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGFzIHRvIGVpdGhlciB0aGUgdGhyb3VnaCBuYW1lIG9yIHRoZSBtb2RlbCBuYW1lXG4gICAgICAgICAgICBpZiAoIWFzICYmIHByZXZpb3VzQXNzb2NpYXRpb24gJiYgcHJldmlvdXNBc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEFzc29jaWF0aW9uICYmIHByZXZpb3VzQXNzb2NpYXRpb24udGhyb3VnaCAmJiBwcmV2aW91c0Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwgPT09IG1vZGVsKSB7XG4gICAgICAgICAgICAgIC8vIGdldCBmcm9tIHByZXZpb3VzIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgIGl0ZW0gPSBuZXcgQXNzb2NpYXRpb24ocHJldmlvdXNNb2RlbCwgbW9kZWwsIHtcbiAgICAgICAgICAgICAgICBhczogbW9kZWwubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGdldCBhc3NvY2lhdGlvbiBmcm9tIHByZXZpb3VzIG1vZGVsXG4gICAgICAgICAgICAgIGl0ZW0gPSBwcmV2aW91c01vZGVsLmdldEFzc29jaWF0aW9uRm9yQWxpYXMobW9kZWwsIGFzKTtcblxuICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIHVzZSB0aGUgbW9kZWwgbmFtZSBpZiB0aGUgaXRlbSBpcyBzdGlsbCBudWxsXG4gICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBwcmV2aW91c01vZGVsLmdldEFzc29jaWF0aW9uRm9yQWxpYXMobW9kZWwsIG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGFzc29jaWF0aW9uXG4gICAgICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnVW5hYmxlIHRvIGZpbmQgYSB2YWxpZCBhc3NvY2lhdGlvbiBmb3IgbW9kZWwsIFxcJyVzXFwnJywgbW9kZWwubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBnZXQgb3JkZXIgaW5kZXhcbiAgICAgICAgICBjb25zdCBvcmRlckluZGV4ID0gdmFsaWRPcmRlck9wdGlvbnMuaW5kZXhPZihpdGVtLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgICAgICAgLy8gc2VlIGlmIHRoaXMgaXMgYW4gb3JkZXJcbiAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIG9yZGVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChgICR7dmFsaWRPcmRlck9wdGlvbnNbb3JkZXJJbmRleF19YCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c01vZGVsICYmIHByZXZpb3VzTW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgZ28gZG93biB0aGlzIHBhdGggaWYgd2UgaGF2ZSBwcmVpdm91cyBtb2RlbCBhbmQgY2hlY2sgb25seSBvbmNlXG4gICAgICAgICAgICBpZiAocHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c01vZGVsLmFzc29jaWF0aW9uc1tpdGVtXSkge1xuICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBpdGVtIHRvIGFuIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgIGl0ZW0gPSBwcmV2aW91c01vZGVsLmFzc29jaWF0aW9uc1tpdGVtXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgJiYgcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1dICYmIGl0ZW0gIT09IHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtXS5maWVsZCkge1xuICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBpdGVtIGF0dHJpYnV0ZSBmcm9tIGl0cyBhbGlhc1xuICAgICAgICAgICAgICBpdGVtID0gcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW1dLmZpZWxkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgaXRlbS5pbmNsdWRlcygnLicpXG4gICAgICAgICAgICAgICYmIHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbVNwbGl0ID0gaXRlbS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbVNwbGl0WzBdXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHF1b3RlIGlkZW50aWZpZXJzIGZvciBub3dcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGAke3ByZXZpb3VzTW9kZWwubmFtZX0uJHtwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbVNwbGl0WzBdXS5maWVsZH1gKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBwYXRoXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGl0ZW1TcGxpdC5zbGljZSgxKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgcGF0aFxuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGlkZW50aWZpZXIsIHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYXBwZW5kIHRoZSBtb2RlbCBuYW1lIHdoZW4gc3RyaW5nXG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsZWN0aW9uW2luZGV4XSA9IGl0ZW07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGFycmF5LCBhZGRpbmcgdGFibGUgbmFtZXMgb2YgbW9kZWxzIHRvIHF1b3RlZFxuICAgICAgY29uc3QgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgY29uc3QgdGFibGVOYW1lcyA9IFtdO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBsZXQgaSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xsZWN0aW9uTGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjb2xsZWN0aW9uW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IGl0ZW0uX21vZGVsQXR0cmlidXRlIHx8IGl0ZW0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICB0YWJsZU5hbWVzW2ldID0gaXRlbS5hcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzdGFydCBidWlsZGluZyBzcWxcbiAgICAgIGxldCBzcWwgPSAnJztcblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHNxbCArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZU5hbWVzLmpvaW4oY29ubmVjdG9yKSl9LmA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xsZWN0aW9uWzBdID09PSAnc3RyaW5nJyAmJiBwYXJlbnQpIHtcbiAgICAgICAgc3FsICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHBhcmVudC5uYW1lKX0uYDtcbiAgICAgIH1cblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGV2ZXJ5dGhpbmcgcGFzdCBpIGFuZCBhcHBlbmQgdG8gdGhlIHNxbFxuICAgICAgY29sbGVjdGlvbi5zbGljZShpKS5mb3JFYWNoKGNvbGxlY3Rpb25JdGVtID0+IHtcbiAgICAgICAgc3FsICs9IHRoaXMucXVvdGUoY29sbGVjdGlvbkl0ZW0sIHBhcmVudCwgY29ubmVjdG9yKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gc3FsO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbi5fbW9kZWxBdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnF1b3RlVGFibGUoY29sbGVjdGlvbi5Nb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihjb2xsZWN0aW9uLmZpZWxkTmFtZSl9YDtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChjb2xsZWN0aW9uKSAmJiBjb2xsZWN0aW9uLnJhdykge1xuICAgICAgLy8gc2ltcGxlIG9iamVjdHMgd2l0aCByYXcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHtyYXc6IFwiLi4uXCJ9YCBzeW50YXggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gIFVzZSBgc2VxdWVsaXplLmxpdGVyYWxgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJ1Y3R1cmUgcGFzc2VkIHRvIG9yZGVyIC8gZ3JvdXA6ICR7dXRpbC5pbnNwZWN0KGNvbGxlY3Rpb24pfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgbGlzdCBvZiBpZGVudGlmaWVycyBieSBcIi5cIiBhbmQgcXVvdGUgZWFjaCBwYXJ0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBRdW90ZUhlbHBlci5xdW90ZUlkZW50aWZpZXIodGhpcy5kaWFsZWN0LCBpZGVudGlmaWVyLCB7XG4gICAgICBmb3JjZSxcbiAgICAgIHF1b3RlSWRlbnRpZmllcnM6IHRoaXMub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzXG4gICAgfSk7XG4gIH1cblxuICBxdW90ZUlkZW50aWZpZXJzKGlkZW50aWZpZXJzKSB7XG4gICAgaWYgKGlkZW50aWZpZXJzLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGlkZW50aWZpZXJzID0gaWRlbnRpZmllcnMuc3BsaXQoJy4nKTtcblxuICAgICAgY29uc3QgaGVhZCA9IGlkZW50aWZpZXJzLnNsaWNlKDAsIGlkZW50aWZpZXJzLmxlbmd0aCAtIDEpLmpvaW4oJy0+Jyk7XG4gICAgICBjb25zdCB0YWlsID0gaWRlbnRpZmllcnNbaWRlbnRpZmllcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihoZWFkKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWlsKX1gO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVycyk7XG4gIH1cblxuICBxdW90ZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIG1vZGVsKSB7XG4gICAgaWYgKG1vZGVsICYmIGF0dHJpYnV0ZSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVycyhhdHRyaWJ1dGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1b3RlIHRhYmxlIG5hbWUgd2l0aCBvcHRpb25hbCBhbGlhcyBhbmQgc2NoZW1hIGF0dHJpYnV0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gIHBhcmFtIHRhYmxlIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gYWxpYXMgYWxpYXMgbmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgcXVvdGVUYWJsZShwYXJhbSwgYWxpYXMpIHtcbiAgICBsZXQgdGFibGUgPSAnJztcblxuICAgIGlmIChhbGlhcyA9PT0gdHJ1ZSkge1xuICAgICAgYWxpYXMgPSBwYXJhbS5hcyB8fCBwYXJhbS5uYW1lIHx8IHBhcmFtO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KHBhcmFtKSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuc2NoZW1hcykge1xuICAgICAgICBpZiAocGFyYW0uc2NoZW1hKSB7XG4gICAgICAgICAgdGFibGUgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0uc2NoZW1hKX0uYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlICs9IHRoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtLnRhYmxlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFyYW0uc2NoZW1hKSB7XG4gICAgICAgICAgdGFibGUgKz0gcGFyYW0uc2NoZW1hICsgKHBhcmFtLmRlbGltaXRlciB8fCAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUgKz0gcGFyYW0udGFibGVOYW1lO1xuICAgICAgICB0YWJsZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbSk7XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICB0YWJsZSArPSBgIEFTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLypcbiAgICBFc2NhcGUgYSB2YWx1ZSAoZS5nLiBhIHN0cmluZywgbnVtYmVyIG9yIGRhdGUpXG4gICAgQHByaXZhdGVcbiAgKi9cbiAgZXNjYXBlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChmaWVsZC50eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICAgIC8vIFVzZXJzIHNob3VsZG4ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRoZXNlIGFyZ3MgLSBqdXN0IGdpdmUgdGhlbSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJnXG4gICAgICAgICAgY29uc3Qgc2ltcGxlRXNjYXBlID0gZXNjVmFsID0+IFNxbFN0cmluZy5lc2NhcGUoZXNjVmFsLCB0aGlzLm9wdGlvbnMudGltZXpvbmUsIHRoaXMuZGlhbGVjdCk7XG5cbiAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnR5cGUuc3RyaW5naWZ5KHZhbHVlLCB7IGVzY2FwZTogc2ltcGxlRXNjYXBlLCBmaWVsZCwgdGltZXpvbmU6IHRoaXMub3B0aW9ucy50aW1lem9uZSwgb3BlcmF0aW9uOiBvcHRpb25zLm9wZXJhdGlvbiB9KTtcblxuICAgICAgICAgIGlmIChmaWVsZC50eXBlLmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhLXR5cGUgYWxyZWFkeSBkaWQgdGhlIHJlcXVpcmVkIGVzY2FwaW5nXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTcWxTdHJpbmcuZXNjYXBlKHZhbHVlLCB0aGlzLm9wdGlvbnMudGltZXpvbmUsIHRoaXMuZGlhbGVjdCk7XG4gIH1cblxuICBiaW5kUGFyYW0oYmluZCkge1xuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICBiaW5kLnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIGAkJHtiaW5kLmxlbmd0aH1gO1xuICAgIH07XG4gIH1cblxuICAvKlxuICAgIFJldHVybnMgYSBiaW5kIHBhcmFtZXRlciByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIChlLmcuIGEgc3RyaW5nLCBudW1iZXIgb3IgZGF0ZSlcbiAgICBAcHJpdmF0ZVxuICAqL1xuICBmb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBiaW5kUGFyYW0pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFzcyBTZXF1ZWxpemVNZXRob2QgYXMgYSBiaW5kIHBhcmFtZXRlciAtIHVzZSBlc2NhcGUgaW5zdGVhZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChmaWVsZC50eXBlLmJpbmRQYXJhbSkge1xuICAgICAgICAgIHJldHVybiBmaWVsZC50eXBlLmJpbmRQYXJhbSh2YWx1ZSwgeyBlc2NhcGU6IF8uaWRlbnRpdHksIGZpZWxkLCB0aW1lem9uZTogdGhpcy5vcHRpb25zLnRpbWV6b25lLCBvcGVyYXRpb246IG9wdGlvbnMub3BlcmF0aW9uLCBiaW5kUGFyYW0gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmluZFBhcmFtKHZhbHVlKTtcbiAgfVxuXG4gIC8qXG4gICAgVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgZmllbGQgc3BlY2lmaWNhdGlvblxuICAgIEBwcml2YXRlXG4gICovXG4gIHZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLnR5cGVWYWxpZGF0aW9uICYmIGZpZWxkLnR5cGUudmFsaWRhdGUgJiYgdmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZShpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgIGVycm9yLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICdWYWxpZGF0aW9uIGVycm9yJyxcbiAgICAgICAgICAgIGZpZWxkLmZpZWxkTmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGAke2ZpZWxkLnR5cGUua2V5fSB2YWxpZGF0b3JgXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0lkZW50aWZpZXJRdW90ZWQoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBRdW90ZUhlbHBlci5pc0lkZW50aWZpZXJRdW90ZWQoaWRlbnRpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IGV4dHJhY3QgSlNPTiBwcm9wZXJ0eSBvZiBnaXZlbiBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgICAgICAgICAgIGNvbHVtbiAgVGhlIEpTT04gY29sdW1uXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gW3BhdGhdICBUaGUgcGF0aCB0byBleHRyYWN0IChvcHRpb25hbClcbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGgpIHtcbiAgICBsZXQgcGF0aHMgPSBfLnRvUGF0aChwYXRoKTtcbiAgICBsZXQgcGF0aFN0cjtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW4gPSB0aGlzLmlzSWRlbnRpZmllclF1b3RlZChjb2x1bW4pXG4gICAgICA/IGNvbHVtblxuICAgICAgOiB0aGlzLnF1b3RlSWRlbnRpZmllcihjb2x1bW4pO1xuXG4gICAgc3dpdGNoICh0aGlzLmRpYWxlY3QpIHtcbiAgICAgIGNhc2UgJ215c3FsJzpcbiAgICAgIGNhc2UgJ21hcmlhZGInOlxuICAgICAgY2FzZSAnc3FsaXRlJzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbiBkaWdpdCBzdWIgcGF0aHMgbmVlZCB0byBiZSBxdW90ZWQgYXMgRUNNQVNjcmlwdCBpZGVudGlmaWVyc1xuICAgICAgICAgKiBodHRwczovL2J1Z3MubXlzcWwuY29tL2J1Zy5waHA/aWQ9ODE4OTZcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRpYWxlY3QgPT09ICdteXNxbCcpIHtcbiAgICAgICAgICBwYXRocyA9IHBhdGhzLm1hcChzdWJQYXRoID0+IHtcbiAgICAgICAgICAgIHJldHVybiAvXFxELy50ZXN0KHN1YlBhdGgpXG4gICAgICAgICAgICAgID8gVXRpbHMuYWRkVGlja3Moc3ViUGF0aCwgJ1wiJylcbiAgICAgICAgICAgICAgOiBzdWJQYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFN0ciA9IHRoaXMuZXNjYXBlKFsnJCddXG4gICAgICAgICAgLmNvbmNhdChwYXRocylcbiAgICAgICAgICAuam9pbignLicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcLihcXGQrKSg/Oig/PVxcLil8JCkvZywgKF9fLCBkaWdpdCkgPT4gYFske2RpZ2l0fV1gKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gJ3NxbGl0ZScpIHtcbiAgICAgICAgICByZXR1cm4gYGpzb25fZXh0cmFjdCgke3F1b3RlZENvbHVtbn0sJHtwYXRoU3RyfSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGBqc29uX3VucXVvdGUoanNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KSlgO1xuXG4gICAgICBjYXNlICdwb3N0Z3Jlcyc6XG4gICAgICAgIHBhdGhTdHIgPSB0aGlzLmVzY2FwZShgeyR7cGF0aHMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIGAoJHtxdW90ZWRDb2x1bW59Iz4+JHtwYXRoU3RyfSlgO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkICR7dGhpcy5kaWFsZWN0fSBmb3IgSlNPTiBvcGVyYXRpb25zYCk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBSZXR1cm5zIGEgcXVlcnkgZm9yIHNlbGVjdGluZyBlbGVtZW50cyBpbiB0aGUgdGFibGUgPHRhYmxlTmFtZT4uXG4gICAgT3B0aW9uczpcbiAgICAgIC0gYXR0cmlidXRlcyAtPiBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzIChlLmcuIFsnbmFtZScsICdiaXJ0aGRheSddKS4gRGVmYXVsdDogKlxuICAgICAgLSB3aGVyZSAtPiBBIGhhc2ggd2l0aCBjb25kaXRpb25zIChlLmcuIHtuYW1lOiAnZm9vJ30pXG4gICAgICAgICAgICAgICAgIE9SIGFuIElEIGFzIGludGVnZXJcbiAgICAgIC0gb3JkZXIgLT4gZS5nLiAnaWQgREVTQydcbiAgICAgIC0gZ3JvdXBcbiAgICAgIC0gbGltaXQgLT4gVGhlIG1heGltdW0gY291bnQgeW91IHdhbnQgdG8gZ2V0LlxuICAgICAgLSBvZmZzZXQgLT4gQW4gb2Zmc2V0IHZhbHVlIHRvIHN0YXJ0IGZyb20uIE9ubHkgdXNlYWJsZSB3aXRoIGxpbWl0IVxuICAgQHByaXZhdGVcbiAgKi9cbiAgc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICBjb25zdCBtYWluUXVlcnlJdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5SXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHVuZGVmaW5lZCA/IGxpbWl0ICYmIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA6IG9wdGlvbnMuc3ViUXVlcnk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IG9wdGlvbnMuYXR0cmlidXRlcyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMuc2xpY2UoKSxcbiAgICAgIHN1YlF1ZXJ5OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBtYWluVGFibGUgPSB7XG4gICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICBxdW90ZWROYW1lOiBudWxsLFxuICAgICAgYXM6IG51bGwsXG4gICAgICBtb2RlbFxuICAgIH07XG4gICAgY29uc3QgdG9wTGV2ZWxJbmZvID0ge1xuICAgICAgbmFtZXM6IG1haW5UYWJsZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzdWJRdWVyeVxuICAgIH07XG4gICAgbGV0IG1haW5Kb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBzdWJKb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBxdWVyeTtcblxuICAgIC8vIEFsaWFzZXMgY2FuIGJlIHBhc3NlZCB0aHJvdWdoIHN1YnF1ZXJpZXMgYW5kIHdlIGRvbid0IHdhbnQgdG8gcmVzZXQgdGhlbVxuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiAhb3B0aW9ucy5hbGlhc2VzTWFwcGluZykge1xuICAgICAgb3B0aW9ucy5hbGlhc2VzTWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICAgIG9wdGlvbnMuYWxpYXNlc0J5VGFibGUgPSB7fTtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUFsaWFzZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0YWJsZSBuYW1lIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy50YWJsZUFzKSB7XG4gICAgICBtYWluVGFibGUuYXMgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLnRhYmxlQXMpO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWFpblRhYmxlLm5hbWUpICYmIG1haW5UYWJsZS5tb2RlbCkge1xuICAgICAgbWFpblRhYmxlLmFzID0gdGhpcy5xdW90ZUlkZW50aWZpZXIobWFpblRhYmxlLm1vZGVsLm5hbWUpO1xuICAgIH1cblxuICAgIG1haW5UYWJsZS5xdW90ZWROYW1lID0gIUFycmF5LmlzQXJyYXkobWFpblRhYmxlLm5hbWUpID8gdGhpcy5xdW90ZVRhYmxlKG1haW5UYWJsZS5uYW1lKSA6IHRhYmxlTmFtZS5tYXAodCA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IHRoaXMucXVvdGVUYWJsZSh0WzBdLCB0WzFdKSA6IHRoaXMucXVvdGVUYWJsZSh0LCB0cnVlKTtcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHN1YlF1ZXJ5ICYmIGF0dHJpYnV0ZXMubWFpbikge1xuICAgICAgZm9yIChjb25zdCBrZXlBdHQgb2YgbWFpblRhYmxlLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG1haW5BdHRyaWJ1dGVzIGNvbnRhaW4gdGhlIHByaW1hcnkga2V5IG9mIHRoZSBtb2RlbCBlaXRoZXIgYXMgYSBmaWVsZCBvciBhbiBhbGlhc2VkIGZpZWxkXG4gICAgICAgIGlmICghYXR0cmlidXRlcy5tYWluLnNvbWUoYXR0ciA9PiBrZXlBdHQgPT09IGF0dHIgfHwga2V5QXR0ID09PSBhdHRyWzBdIHx8IGtleUF0dCA9PT0gYXR0clsxXSkpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChtYWluVGFibGUubW9kZWwucmF3QXR0cmlidXRlc1trZXlBdHRdLmZpZWxkID8gW2tleUF0dCwgbWFpblRhYmxlLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5QXR0XS5maWVsZF0gOiBrZXlBdHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcy5tYWluID0gdGhpcy5lc2NhcGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMubWFpbiwgb3B0aW9ucywgbWFpblRhYmxlLmFzKTtcbiAgICBhdHRyaWJ1dGVzLm1haW4gPSBhdHRyaWJ1dGVzLm1haW4gfHwgKG9wdGlvbnMuaW5jbHVkZSA/IFtgJHttYWluVGFibGUuYXN9LipgXSA6IFsnKiddKTtcblxuICAgIC8vIElmIHN1YnF1ZXJ5LCB3ZSBhZGQgdGhlIG1haW5BdHRyaWJ1dGVzIHRvIHRoZSBzdWJRdWVyeSBhbmQgc2V0IHRoZSBtYWluQXR0cmlidXRlcyB0byBzZWxlY3QgKiBmcm9tIHN1YnF1ZXJ5XG4gICAgaWYgKHN1YlF1ZXJ5IHx8IG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICAvLyBXZSBuZWVkIHByaW1hcnkga2V5c1xuICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMubWFpbjtcbiAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IFtgJHttYWluVGFibGUuYXMgfHwgbWFpblRhYmxlLnF1b3RlZE5hbWV9LipgXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgam9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCB7IGV4dGVybmFsQXM6IG1haW5UYWJsZS5hcywgaW50ZXJuYWxBczogbWFpblRhYmxlLmFzIH0sIHRvcExldmVsSW5mbyk7XG5cbiAgICAgICAgc3ViSm9pblF1ZXJpZXMgPSBzdWJKb2luUXVlcmllcy5jb25jYXQoam9pblF1ZXJpZXMuc3ViUXVlcnkpO1xuICAgICAgICBtYWluSm9pblF1ZXJpZXMgPSBtYWluSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLm1haW5RdWVyeSk7XG5cbiAgICAgICAgaWYgKGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluID0gXy51bmlxKGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBfLnVuaXEoYXR0cmlidXRlcy5zdWJRdWVyeS5jb25jYXQoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICBzdWJRdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMuc3ViUXVlcnksIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChzdWJKb2luUXVlcmllcy5qb2luKCcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmdyb3VwZWRMaW1pdCkge1xuICAgICAgICBpZiAoIW1haW5UYWJsZS5hcykge1xuICAgICAgICAgIG1haW5UYWJsZS5hcyA9IG1haW5UYWJsZS5xdW90ZWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdoZXJlID0geyAuLi5vcHRpb25zLndoZXJlIH07XG4gICAgICAgIGxldCBncm91cGVkTGltaXRPcmRlcixcbiAgICAgICAgICB3aGVyZUtleSxcbiAgICAgICAgICBpbmNsdWRlLFxuICAgICAgICAgIGdyb3VwZWRUYWJsZU5hbWUgPSBtYWluVGFibGUuYXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB3aGVyZUtleSA9IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uIGluc3RhbmNlb2YgSGFzTWFueSkge1xuICAgICAgICAgIHdoZXJlS2V5ID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbktleUZpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgIC8vIEJUTSBpbmNsdWRlcyBuZWVkcyB0byBqb2luIHRoZSB0aHJvdWdoIHRhYmxlIG9uIHRvIGNoZWNrIElEXG4gICAgICAgICAgZ3JvdXBlZFRhYmxlTmFtZSA9IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLm1hbnlGcm9tU291cmNlLmFzO1xuICAgICAgICAgIGNvbnN0IGdyb3VwZWRMaW1pdE9wdGlvbnMgPSBNb2RlbC5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKHtcbiAgICAgICAgICAgIGluY2x1ZGU6IFt7XG4gICAgICAgICAgICAgIGFzc29jaWF0aW9uOiBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5tYW55RnJvbVNvdXJjZSxcbiAgICAgICAgICAgICAgZHVwbGljYXRpbmc6IGZhbHNlLCAvLyBUaGUgVU5JT04nZWQgcXVlcnkgbWF5IGNvbnRhaW4gZHVwbGljYXRlcywgYnV0IGVhY2ggc3ViLXF1ZXJ5IGNhbm5vdFxuICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBbT3AucGxhY2Vob2xkZXJdOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2ggJiYgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaC53aGVyZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG1vZGVsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgYXR0cmlidXRlcyBmcm9tIHRoZSBqb2luIHRhYmxlIGFyZSBtYXBwZWQgYmFjayB0byBtb2RlbHNcbiAgICAgICAgICBvcHRpb25zLmhhc0pvaW4gPSB0cnVlO1xuICAgICAgICAgIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgICAgICAgb3B0aW9ucy5pbmNsdWRlTWFwID0gT2JqZWN0LmFzc2lnbihncm91cGVkTGltaXRPcHRpb25zLmluY2x1ZGVNYXAsIG9wdGlvbnMuaW5jbHVkZU1hcCk7XG4gICAgICAgICAgb3B0aW9ucy5pbmNsdWRlTmFtZXMgPSBncm91cGVkTGltaXRPcHRpb25zLmluY2x1ZGVOYW1lcy5jb25jYXQob3B0aW9ucy5pbmNsdWRlTmFtZXMgfHwgW10pO1xuICAgICAgICAgIGluY2x1ZGUgPSBncm91cGVkTGltaXRPcHRpb25zLmluY2x1ZGU7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIG9yZGVyIGJ5IGF0dHJpYnV0ZXMgYXJlIGF2YWlsYWJsZSB0byB0aGUgcGFyZW50IHF1ZXJ5XG4gICAgICAgICAgICBvcHRpb25zLm9yZGVyLmZvckVhY2goKG9yZGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yZGVyKSkge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXJbMF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgYWxpYXMgPSBgc3VicXVlcnlfb3JkZXJfJHtpfWA7XG4gICAgICAgICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy5wdXNoKFtvcmRlciwgYWxpYXNdKTtcblxuICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHByZXBlbmQgbW9kZWwgbmFtZSB3aGVuIHdlIGFsaWFzIHRoZSBhdHRyaWJ1dGVzLCBzbyBxdW90ZSB0aGVtIGhlcmVcbiAgICAgICAgICAgICAgYWxpYXMgPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGUoYWxpYXMpKTtcblxuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JkZXJbaV1bMF0gPSBhbGlhcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9yZGVyW2ldID0gYWxpYXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBlZExpbWl0T3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPcmRlcmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJxdWVyaWVzLCBzbyBvcmRlcmluZyB0aGUgVU5JT04nZWQgcmVzdWx0IGlzIG5vdCBuZWVkZWRcbiAgICAgICAgICBncm91cGVkTGltaXRPcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgd2hlcmVbT3AucGxhY2Vob2xkZXJdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hpbmcgdGhlIGJhc2UgcXVlcnkgYW5kIHNwbGljaW5nIHRoZSB3aGVyZSBwYXJ0IGludG8gaXQgaXMgY29uc2lzdGVudGx5ID4gdHdpY2VcbiAgICAgICAgLy8gYXMgZmFzdCB0aGFuIGdlbmVyYXRpbmcgZnJvbSBzY3JhdGNoIGVhY2ggdGltZSBmb3IgdmFsdWVzLmxlbmd0aCA+PSA1XG4gICAgICAgIGNvbnN0IGJhc2VRdWVyeSA9IGBTRUxFQ1QgKiBGUk9NICgke3RoaXMuc2VsZWN0UXVlcnkoXG4gICAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgICAgICAgICBsaW1pdDogb3B0aW9ucy5ncm91cGVkTGltaXQubGltaXQsXG4gICAgICAgICAgICBvcmRlcjogZ3JvdXBlZExpbWl0T3JkZXIsXG4gICAgICAgICAgICBhbGlhc2VzTWFwcGluZzogb3B0aW9ucy5hbGlhc2VzTWFwcGluZyxcbiAgICAgICAgICAgIGFsaWFzZXNCeVRhYmxlOiBvcHRpb25zLmFsaWFzZXNCeVRhYmxlLFxuICAgICAgICAgICAgd2hlcmUsXG4gICAgICAgICAgICBpbmNsdWRlLFxuICAgICAgICAgICAgbW9kZWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vZGVsXG4gICAgICAgICkucmVwbGFjZSgvOyQvLCAnJyl9KSBBUyBzdWJgOyAvLyBFdmVyeSBkZXJpdmVkIHRhYmxlIG11c3QgaGF2ZSBpdHMgb3duIGFsaWFzXG4gICAgICAgIGNvbnN0IHBsYWNlSG9sZGVyID0gdGhpcy53aGVyZUl0ZW1RdWVyeShPcC5wbGFjZWhvbGRlciwgdHJ1ZSwgeyBtb2RlbCB9KTtcbiAgICAgICAgY29uc3Qgc3BsaWNlUG9zID0gYmFzZVF1ZXJ5LmluZGV4T2YocGxhY2VIb2xkZXIpO1xuXG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgYCgke1xuICAgICAgICAgIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwV2hlcmU7XG4gICAgICAgICAgICBpZiAod2hlcmVLZXkpIHtcbiAgICAgICAgICAgICAgZ3JvdXBXaGVyZSA9IHtcbiAgICAgICAgICAgICAgICBbd2hlcmVLZXldOiB2YWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgZ3JvdXBXaGVyZSA9IHtcbiAgICAgICAgICAgICAgICBbb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbklkZW50aWZpZXJGaWVsZF06IHZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBVdGlscy5zcGxpY2VTdHIoYmFzZVF1ZXJ5LCBzcGxpY2VQb3MsIHBsYWNlSG9sZGVyLmxlbmd0aCwgdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoZ3JvdXBXaGVyZSwgZ3JvdXBlZFRhYmxlTmFtZSkpO1xuICAgICAgICAgIH0pLmpvaW4oXG4gICAgICAgICAgICB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzWydVTklPTiBBTEwnXSA/ICcgVU5JT04gQUxMICcgOiAnIFVOSU9OICdcbiAgICAgICAgICApXG4gICAgICAgIH0pYCwgbWFpblRhYmxlLmFzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIH1cblxuICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChtYWluSm9pblF1ZXJpZXMuam9pbignJykpO1xuICAgIH1cblxuICAgIC8vIEFkZCBXSEVSRSB0byBzdWIgb3IgbWFpbiBxdWVyeVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3doZXJlJykgJiYgIW9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBvcHRpb25zLndoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMob3B0aW9ucy53aGVyZSwgbWFpblRhYmxlLmFzIHx8IHRhYmxlTmFtZSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgV0hFUkUgJHtvcHRpb25zLndoZXJlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBXSEVSRSAke29wdGlvbnMud2hlcmV9YCk7XG4gICAgICAgICAgLy8gV2FsayB0aGUgbWFpbiBxdWVyeSB0byB1cGRhdGUgYWxsIHNlbGVjdHNcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnU0VMRUNUJykpIHtcbiAgICAgICAgICAgICAgbWFpblF1ZXJ5SXRlbXNba2V5XSA9IHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcywgb3B0aW9ucy53aGVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgR1JPVVAgQlkgdG8gc3ViIG9yIG1haW4gcXVlcnlcbiAgICBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgb3B0aW9ucy5ncm91cCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5ncm91cCkgPyBvcHRpb25zLmdyb3VwLm1hcCh0ID0+IHRoaXMuYWxpYXNHcm91cGluZyh0LCBtb2RlbCwgbWFpblRhYmxlLmFzLCBvcHRpb25zKSkuam9pbignLCAnKSA6IHRoaXMuYWxpYXNHcm91cGluZyhvcHRpb25zLmdyb3VwLCBtb2RlbCwgbWFpblRhYmxlLmFzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHN1YlF1ZXJ5ICYmIG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgR1JPVVAgQlkgJHtvcHRpb25zLmdyb3VwfWApO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBHUk9VUCBCWSAke29wdGlvbnMuZ3JvdXB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIEhBVklORyB0byBzdWIgb3IgbWFpbiBxdWVyeVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2hhdmluZycpKSB7XG4gICAgICBvcHRpb25zLmhhdmluZyA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKG9wdGlvbnMuaGF2aW5nLCB0YWJsZU5hbWUsIG1vZGVsLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICBpZiAob3B0aW9ucy5oYXZpbmcpIHtcbiAgICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgSEFWSU5HICR7b3B0aW9ucy5oYXZpbmd9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIEhBVklORyAke29wdGlvbnMuaGF2aW5nfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIE9SREVSIHRvIHN1YiBvciBtYWluIHF1ZXJ5XG4gICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIGNvbnN0IG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIHN1YlF1ZXJ5KTtcbiAgICAgIGlmIChvcmRlcnMubWFpblF1ZXJ5T3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBPUkRFUiBCWSAke29yZGVycy5tYWluUXVlcnlPcmRlci5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgICAgaWYgKG9yZGVycy5zdWJRdWVyeU9yZGVyLmxlbmd0aCkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBPUkRFUiBCWSAke29yZGVycy5zdWJRdWVyeU9yZGVyLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIExJTUlULCBPRkZTRVQgdG8gc3ViIG9yIG1haW4gcXVlcnlcbiAgICBjb25zdCBsaW1pdE9yZGVyID0gdGhpcy5hZGRMaW1pdEFuZE9mZnNldChvcHRpb25zLCBtYWluVGFibGUubW9kZWwpO1xuICAgIGlmIChsaW1pdE9yZGVyICYmICFvcHRpb25zLmdyb3VwZWRMaW1pdCkge1xuICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChsaW1pdE9yZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2gobGltaXRPcmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMubWFpbiwgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGUuYXMgfSk7XG4gICAgICBxdWVyeSA9IGBTRUxFQ1QgJHthdHRyaWJ1dGVzLm1haW4uam9pbignLCAnKX0gRlJPTSAoJHtzdWJRdWVyeUl0ZW1zLmpvaW4oJycpfSkgQVMgJHttYWluVGFibGUuYXN9JHttYWluSm9pblF1ZXJpZXMuam9pbignJyl9JHttYWluUXVlcnlJdGVtcy5qb2luKCcnKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IG1haW5RdWVyeUl0ZW1zLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvY2sgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5sb2NrKSB7XG4gICAgICBsZXQgbG9jayA9IG9wdGlvbnMubG9jaztcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NrID09PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NrID0gb3B0aW9ucy5sb2NrLmxldmVsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMubG9ja0tleSAmJiAobG9jayA9PT0gJ0tFWSBTSEFSRScgfHwgbG9jayA9PT0gJ05PIEtFWSBVUERBVEUnKSkge1xuICAgICAgICBxdWVyeSArPSBgIEZPUiAke2xvY2t9YDtcbiAgICAgIH0gZWxzZSBpZiAobG9jayA9PT0gJ1NIQVJFJykge1xuICAgICAgICBxdWVyeSArPSBgICR7dGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5mb3JTaGFyZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkgKz0gJyBGT1IgVVBEQVRFJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2tPZiAmJiBvcHRpb25zLmxvY2sub2YgJiYgb3B0aW9ucy5sb2NrLm9mLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgT0YgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy5sb2NrLm9mLm5hbWUpfWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5za2lwTG9ja2VkICYmIG9wdGlvbnMuc2tpcExvY2tlZCkge1xuICAgICAgICBxdWVyeSArPSAnIFNLSVAgTE9DS0VEJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cblxuICBhbGlhc0dyb3VwaW5nKGZpZWxkLCBtb2RlbCwgdGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3JjID0gQXJyYXkuaXNBcnJheShmaWVsZCkgPyBmaWVsZFswXSA6IGZpZWxkO1xuXG4gICAgcmV0dXJuIHRoaXMucXVvdGUodGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIHNyYywgb3B0aW9ucykgfHwgc3JjLCBtb2RlbCk7XG4gIH1cblxuICBlc2NhcGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1haW5UYWJsZUFzKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5tYXAoYXR0ciA9PiB7XG4gICAgICBsZXQgYWRkVGFibGUgPSB0cnVlO1xuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkge1xuICAgICAgICBpZiAoYXR0ci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SlNPTi5zdHJpbmdpZnkoYXR0cil9IGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBkZWZpbml0aW9uLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBbJ2F0dHJpYnV0ZSBkZWZpbml0aW9uJywgJ2FsaWFzJ11gKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyID0gYXR0ci5zbGljZSgpO1xuXG4gICAgICAgIGlmIChhdHRyWzBdIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgICAgYXR0clswXSA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHJbMF0pO1xuICAgICAgICAgIGFkZFRhYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0dHJbMF0uaW5jbHVkZXMoJygnKSAmJiAhYXR0clswXS5pbmNsdWRlcygnKScpKSB7XG4gICAgICAgICAgYXR0clswXSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHJlY2F0aW9ucy5ub1Jhd0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWxpYXMgPSBhdHRyWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgbWFpblRhYmxlQXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0ciA9IFthdHRyWzBdLCB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcyldLmpvaW4oJyBBUyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHIgPSAhYXR0ci5pbmNsdWRlcyhVdGlscy5USUNLX0NIQVIpICYmICFhdHRyLmluY2x1ZGVzKCdcIicpXG4gICAgICAgICAgPyB0aGlzLnF1b3RlQXR0cmlidXRlKGF0dHIsIG9wdGlvbnMubW9kZWwpXG4gICAgICAgICAgOiB0aGlzLmVzY2FwZShhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmICghXy5pc0VtcHR5KG9wdGlvbnMuaW5jbHVkZSkgJiYgIWF0dHIuaW5jbHVkZXMoJy4nKSAmJiBhZGRUYWJsZSkge1xuICAgICAgICBhdHRyID0gYCR7bWFpblRhYmxlQXN9LiR7YXR0cn1gO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9KTtcbiAgfVxuXG4gIGdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCBwYXJlbnRUYWJsZU5hbWUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IGpvaW5RdWVyaWVzID0ge1xuICAgICAgbWFpblF1ZXJ5OiBbXSxcbiAgICAgIHN1YlF1ZXJ5OiBbXVxuICAgIH07XG4gICAgY29uc3QgbWFpbkNoaWxkSW5jbHVkZXMgPSBbXTtcbiAgICBjb25zdCBzdWJDaGlsZEluY2x1ZGVzID0gW107XG4gICAgbGV0IHJlcXVpcmVkTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbmNsdWRlQXMgPSB7XG4gICAgICBpbnRlcm5hbEFzOiBpbmNsdWRlLmFzLFxuICAgICAgZXh0ZXJuYWxBczogaW5jbHVkZS5hc1xuICAgIH07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgam9pblF1ZXJ5O1xuXG4gICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMua2V5c0VzY2FwZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRvcExldmVsSW5mby5uYW1lcy5uYW1lICE9PSBwYXJlbnRUYWJsZU5hbWUuZXh0ZXJuYWxBcyAmJiB0b3BMZXZlbEluZm8ubmFtZXMuYXMgIT09IHBhcmVudFRhYmxlTmFtZS5leHRlcm5hbEFzKSB7XG4gICAgICBpbmNsdWRlQXMuaW50ZXJuYWxBcyA9IGAke3BhcmVudFRhYmxlTmFtZS5pbnRlcm5hbEFzfS0+JHtpbmNsdWRlLmFzfWA7XG4gICAgICBpbmNsdWRlQXMuZXh0ZXJuYWxBcyA9IGAke3BhcmVudFRhYmxlTmFtZS5leHRlcm5hbEFzfS4ke2luY2x1ZGUuYXN9YDtcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlSWdub3JlQXR0cmlidXRlcyBpcyB1c2VkIGJ5IGFnZ3JlZ2F0ZSBmdW5jdGlvbnNcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICBpbmNsdWRlLm1vZGVsLl9leHBhbmRBdHRyaWJ1dGVzKGluY2x1ZGUpO1xuICAgICAgVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcblxuICAgICAgY29uc3QgaW5jbHVkZUF0dHJpYnV0ZXMgPSBpbmNsdWRlLmF0dHJpYnV0ZXMubWFwKGF0dHIgPT4ge1xuICAgICAgICBsZXQgYXR0ckFzID0gYXR0cjtcbiAgICAgICAgbGV0IHZlcmJhdGltID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikgJiYgYXR0ci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBpZiAoYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCAmJiAoXG4gICAgICAgICAgICBhdHRyWzBdIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkNhc3QgfHxcbiAgICAgICAgICAgIGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5GblxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHZlcmJhdGltID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdHRyID0gYXR0ci5tYXAoYXR0ciA9PiBhdHRyIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kID8gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0cikgOiBhdHRyKTtcblxuICAgICAgICAgIGF0dHJBcyA9IGF0dHJbMV07XG4gICAgICAgICAgYXR0ciA9IGF0dHJbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIudmFsOyAvLyBXZSB0cnVzdCB0aGUgdXNlciB0byByZW5hbWUgdGhlIGZpZWxkIGNvcnJlY3RseVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCB8fCBhdHRyIGluc3RhbmNlb2YgVXRpbHMuRm4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVHJpZWQgdG8gc2VsZWN0IGF0dHJpYnV0ZXMgdXNpbmcgU2VxdWVsaXplLmNhc3Qgb3IgU2VxdWVsaXplLmZuIHdpdGhvdXQgc3BlY2lmeWluZyBhbiBhbGlhcyBmb3IgdGhlIHJlc3VsdCwgZHVyaW5nIGVhZ2VyIGxvYWRpbmcuICcgK1xuICAgICAgICAgICAgJ1RoaXMgbWVhbnMgdGhlIGF0dHJpYnV0ZSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgcmV0dXJuZWQgaW5zdGFuY2UnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHByZWZpeCA9IGF0dHI7XG4gICAgICAgIH0gZWxzZSBpZiAoLyM+PnwtPj4vLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS4ke2F0dHIucmVwbGFjZSgvXFwofFxcKS9nLCAnJyl9KWA7XG4gICAgICAgIH0gZWxzZSBpZiAoL2pzb25fZXh0cmFjdFxcKC8udGVzdChhdHRyKSkge1xuICAgICAgICAgIHByZWZpeCA9IGF0dHIucmVwbGFjZSgvanNvbl9leHRyYWN0XFwoL2ksIGBqc29uX2V4dHJhY3QoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWZpeCA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGlhcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke2F0dHJBc31gO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgaW5jbHVkZUFzLmludGVybmFsQXMsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgJ0FTJyxcbiAgICAgICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcywgdHJ1ZSlcbiAgICAgICAgXSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgaW5jbHVkZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBpbmNsdWRlQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy90aHJvdWdoXG4gICAgaWYgKGluY2x1ZGUudGhyb3VnaCkge1xuICAgICAgam9pblF1ZXJ5ID0gdGhpcy5nZW5lcmF0ZVRocm91Z2hKb2luKGluY2x1ZGUsIGluY2x1ZGVBcywgcGFyZW50VGFibGVOYW1lLmludGVybmFsQXMsIHRvcExldmVsSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pO1xuICAgICAgam9pblF1ZXJ5ID0gdGhpcy5nZW5lcmF0ZUpvaW4oaW5jbHVkZSwgdG9wTGV2ZWxJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcG9zc2libGUgbmV3IGF0dHJpYnV0ZXMgY3JlYXRlZCBpbiBqb2luXG4gICAgaWYgKGpvaW5RdWVyeS5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlcy5tYWluID0gYXR0cmlidXRlcy5tYWluLmNvbmNhdChqb2luUXVlcnkuYXR0cmlidXRlcy5tYWluKTtcbiAgICB9XG5cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkSW5jbHVkZSBvZiBpbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgaWYgKGNoaWxkSW5jbHVkZS5zZXBhcmF0ZSB8fCBjaGlsZEluY2x1ZGUuX3BzZXVkbykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRKb2luUXVlcmllcyA9IHRoaXMuZ2VuZXJhdGVJbmNsdWRlKGNoaWxkSW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pO1xuXG4gICAgICAgIGlmIChpbmNsdWRlLnJlcXVpcmVkID09PSBmYWxzZSAmJiBjaGlsZEluY2x1ZGUucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXF1aXJlZE1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgY2hpbGQgaXMgYSBzdWIgcXVlcnkgd2UganVzdCBnaXZlIGl0IHRvIHRoZVxuICAgICAgICBpZiAoY2hpbGRJbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICAgIHN1YkNoaWxkSW5jbHVkZXMucHVzaChjaGlsZEpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5tYWluUXVlcnkpIHtcbiAgICAgICAgICBtYWluQ2hpbGRJbmNsdWRlcy5wdXNoKGNoaWxkSm9pblF1ZXJpZXMubWFpblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkgJiYgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICBpZiAocmVxdWlyZWRNaXNtYXRjaCAmJiBzdWJDaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICggJHtqb2luUXVlcnkuYm9keX0ke3N1YkNoaWxkSW5jbHVkZXMuam9pbignJyl9ICkgT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICR7am9pblF1ZXJ5LmJvZHl9IE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgICAgaWYgKHN1YkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goc3ViQ2hpbGRJbmNsdWRlcy5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKG1haW5DaGlsZEluY2x1ZGVzLmpvaW4oJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlcXVpcmVkTWlzbWF0Y2ggJiYgbWFpbkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICggJHtqb2luUXVlcnkuYm9keX0ke21haW5DaGlsZEluY2x1ZGVzLmpvaW4oJycpfSApIE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gJHtqb2luUXVlcnkuYm9keX0gT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgICBpZiAobWFpbkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKG1haW5DaGlsZEluY2x1ZGVzLmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChzdWJDaGlsZEluY2x1ZGVzLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWFpblF1ZXJ5OiBqb2luUXVlcmllcy5tYWluUXVlcnkuam9pbignJyksXG4gICAgICBzdWJRdWVyeTogam9pblF1ZXJpZXMuc3ViUXVlcnkuam9pbignJyksXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZS1hbGlhcyBpbiBjYXNlIG9mIGEgc3VicXVlcnlcbiAgICBpZiAob3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF07XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFsaWFzIGN1c3RvbSBzdXF1ZXJ5X29yZGVyc1xuICAgIGlmIChhbGlhcy5tYXRjaCgvc3VicXVlcnlfb3JkZXJfWzAtOV0vKSkge1xuICAgICAgcmV0dXJuIGFsaWFzO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbmlmaWVkQWxpYXMgPSBgXyR7b3B0aW9ucy5hbGlhc2VzTWFwcGluZy5zaXplfWA7XG5cbiAgICBvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNldChtaW5pZmllZEFsaWFzLCBhbGlhcyk7XG4gICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXSA9IG1pbmlmaWVkQWxpYXM7XG5cbiAgICByZXR1cm4gbWluaWZpZWRBbGlhcztcbiAgfVxuXG4gIF9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgZmllbGQsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2ZpZWxkfWBdKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2ZpZWxkfWBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgcGFyZW50ID0gaW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgcGFyZW50SXNUb3AgPSAhIXBhcmVudCAmJiAhaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwubmFtZSA9PT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubW9kZWwubmFtZTtcbiAgICBsZXQgJHBhcmVudDtcbiAgICBsZXQgam9pbldoZXJlO1xuICAgIC8qIEF0dHJpYnV0ZXMgZm9yIHRoZSBsZWZ0IHNpZGUgKi9cbiAgICBjb25zdCBsZWZ0ID0gYXNzb2NpYXRpb24uc291cmNlO1xuICAgIGNvbnN0IGF0dHJMZWZ0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gP1xuICAgICAgYXNzb2NpYXRpb24uaWRlbnRpZmllciA6XG4gICAgICBhc3NvY2lhdGlvbi5zb3VyY2VLZXlBdHRyaWJ1dGUgfHwgbGVmdC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IGZpZWxkTGVmdCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID9cbiAgICAgIGFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCA6XG4gICAgICBsZWZ0LnJhd0F0dHJpYnV0ZXNbYXNzb2NpYXRpb24uc291cmNlS2V5QXR0cmlidXRlIHx8IGxlZnQucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgbGV0IGFzTGVmdDtcbiAgICAvKiBBdHRyaWJ1dGVzIGZvciB0aGUgcmlnaHQgc2lkZSAqL1xuICAgIGNvbnN0IHJpZ2h0ID0gaW5jbHVkZS5tb2RlbDtcbiAgICBjb25zdCB0YWJsZVJpZ2h0ID0gcmlnaHQuZ2V0VGFibGVOYW1lKCk7XG4gICAgY29uc3QgZmllbGRSaWdodCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID9cbiAgICAgIHJpZ2h0LnJhd0F0dHJpYnV0ZXNbYXNzb2NpYXRpb24udGFyZ2V0SWRlbnRpZmllciB8fCByaWdodC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCA6XG4gICAgICBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgbGV0IGFzUmlnaHQgPSBpbmNsdWRlLmFzO1xuXG4gICAgd2hpbGUgKCgkcGFyZW50ID0gJHBhcmVudCAmJiAkcGFyZW50LnBhcmVudCB8fCBpbmNsdWRlLnBhcmVudCkgJiYgJHBhcmVudC5hc3NvY2lhdGlvbikge1xuICAgICAgaWYgKGFzTGVmdCkge1xuICAgICAgICBhc0xlZnQgPSBgJHskcGFyZW50LmFzfS0+JHthc0xlZnR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzTGVmdCA9ICRwYXJlbnQuYXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhc0xlZnQpIGFzTGVmdCA9IHBhcmVudC5hcyB8fCBwYXJlbnQubW9kZWwubmFtZTtcbiAgICBlbHNlIGFzUmlnaHQgPSBgJHthc0xlZnR9LT4ke2FzUmlnaHR9YDtcblxuICAgIGxldCBqb2luT24gPSBgJHt0aGlzLnF1b3RlVGFibGUoYXNMZWZ0KX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZExlZnQpfWA7XG4gICAgY29uc3Qgc3VicXVlcnlBdHRyaWJ1dGVzID0gW107XG5cbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuZ3JvdXBlZExpbWl0ICYmIHBhcmVudElzVG9wIHx8IHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSkge1xuICAgICAgaWYgKHBhcmVudElzVG9wKSB7XG4gICAgICAgIC8vIFRoZSBtYWluIG1vZGVsIGF0dHJpYnV0ZXMgaXMgbm90IGFsaWFzZWQgdG8gYSBwcmVmaXhcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHBhcmVudC5hcyB8fCBwYXJlbnQubW9kZWwubmFtZSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBvdGVudGlhbCBhbGlhc2VkIEpPSU4gY29uZGl0aW9uXG4gICAgICAgIGpvaW5PbiA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBhdHRyTGVmdCwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IGAke3RhYmxlTmFtZX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyTGVmdCl9YDtcblxuICAgICAgICBpZiAodG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3VicXVlcnlBdHRyaWJ1dGVzLnB1c2goYCR7dGFibGVOYW1lfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkTGVmdCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGpvaW5Tb3VyY2UgPSBgJHthc0xlZnQucmVwbGFjZSgvLT4vZywgJy4nKX0uJHthdHRyTGVmdH1gO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBwb3RlbnRpYWwgYWxpYXNlZCBKT0lOIGNvbmRpdGlvblxuICAgICAgICBqb2luT24gPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKGFzTGVmdCwgam9pblNvdXJjZSwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IHRoaXMucXVvdGVJZGVudGlmaWVyKGpvaW5Tb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGpvaW5PbiArPSBgID0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhc1JpZ2h0KX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZFJpZ2h0KX1gO1xuXG4gICAgaWYgKGluY2x1ZGUub24pIHtcbiAgICAgIGpvaW5PbiA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGluY2x1ZGUub24sIHtcbiAgICAgICAgcHJlZml4OiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpKSxcbiAgICAgICAgbW9kZWw6IGluY2x1ZGUubW9kZWxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLndoZXJlKSB7XG4gICAgICBqb2luV2hlcmUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShpbmNsdWRlLndoZXJlLCB7XG4gICAgICAgIHByZWZpeDogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihhc1JpZ2h0KSksXG4gICAgICAgIG1vZGVsOiBpbmNsdWRlLm1vZGVsXG4gICAgICB9KTtcbiAgICAgIGlmIChqb2luV2hlcmUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUub3IpIHtcbiAgICAgICAgICBqb2luT24gKz0gYCBPUiAke2pvaW5XaGVyZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpvaW5PbiArPSBgIEFORCAke2pvaW5XaGVyZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIGFzUmlnaHQubGVuZ3RoID4gNjMpIHtcbiAgICAgIGNvbnN0IGFsaWFzID0gYCUke3RvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVBbGlhc2VzLnNpemV9YDtcblxuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2V0KGFsaWFzLCBhc1JpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgam9pbjogaW5jbHVkZS5yZXF1aXJlZCA/ICdJTk5FUiBKT0lOJyA6IGluY2x1ZGUucmlnaHQgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snUklHSFQgSk9JTiddID8gJ1JJR0hUIE9VVEVSIEpPSU4nIDogJ0xFRlQgT1VURVIgSk9JTicsXG4gICAgICBib2R5OiB0aGlzLnF1b3RlVGFibGUodGFibGVSaWdodCwgYXNSaWdodCksXG4gICAgICBjb25kaXRpb246IGpvaW5PbixcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgbWFpbjogW10sXG4gICAgICAgIHN1YlF1ZXJ5OiBzdWJxdWVyeUF0dHJpYnV0ZXNcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFNRTCBmcmFnbWVudHMgdG8gaGFuZGxlIHJldHVybmluZyB0aGUgYXR0cmlidXRlcyBmcm9tIGFuIGluc2VydC91cGRhdGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gbW9kZWxBdHRyaWJ1dGVzIEFuIG9iamVjdCB3aXRoIHRoZSBtb2RlbCBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmV0dXJuRmllbGRzID0gW107XG4gICAgY29uc3QgcmV0dXJuVHlwZXMgPSBbXTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSAnJztcbiAgICBsZXQgcmV0dXJuaW5nRnJhZ21lbnQgPSAnJztcbiAgICBsZXQgdG1wVGFibGUgPSAnJztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmV0dXJuaW5nKSkge1xuICAgICAgcmV0dXJuRmllbGRzLnB1c2goLi4ub3B0aW9ucy5yZXR1cm5pbmcubWFwKGZpZWxkID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxBdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2gobW9kZWxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGUgPT4ge1xuICAgICAgICBpZiAoIShhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5WSVJUVUFMKSkge1xuICAgICAgICAgIHJldHVybkZpZWxkcy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5maWVsZCkpO1xuICAgICAgICAgIHJldHVyblR5cGVzLnB1c2goYXR0cmlidXRlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc0VtcHR5KHJldHVybkZpZWxkcykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKCcqJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLnJldHVybmluZykge1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSBgIFJFVFVSTklORyAke3JldHVybkZpZWxkcy5qb2luKCcsJyl9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLm91dHB1dCkge1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSBgIE9VVFBVVCAke3JldHVybkZpZWxkcy5tYXAoZmllbGQgPT4gYElOU0VSVEVELiR7ZmllbGR9YCkuam9pbignLCcpfWA7XG5cbiAgICAgIC8vVG8gY2FwdHVyZSBvdXRwdXQgcm93cyB3aGVuIHRoZXJlIGlzIGEgdHJpZ2dlciBvbiBNU1NRTCBEQlxuICAgICAgaWYgKG9wdGlvbnMuaGFzVHJpZ2dlciAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnRtcFRhYmxlVHJpZ2dlcikge1xuICAgICAgICBjb25zdCB0bXBDb2x1bW5zID0gcmV0dXJuRmllbGRzLm1hcCgoZmllbGQsIGkpID0+IGAke2ZpZWxkfSAke3JldHVyblR5cGVzW2ldLnRvU3FsKCl9YCk7XG5cbiAgICAgICAgdG1wVGFibGUgPSBgREVDTEFSRSBAdG1wIFRBQkxFICgke3RtcENvbHVtbnMuam9pbignLCcpfSk7IGA7XG4gICAgICAgIG91dHB1dEZyYWdtZW50ICs9ICcgSU5UTyBAdG1wJztcbiAgICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSAnOyBTRUxFQ1QgKiBGUk9NIEB0bXAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG91dHB1dEZyYWdtZW50LCByZXR1cm5GaWVsZHMsIHJldHVybmluZ0ZyYWdtZW50LCB0bXBUYWJsZSB9O1xuICB9XG5cbiAgZ2VuZXJhdGVUaHJvdWdoSm9pbihpbmNsdWRlLCBpbmNsdWRlQXMsIHBhcmVudFRhYmxlTmFtZSwgdG9wTGV2ZWxJbmZvKSB7XG4gICAgY29uc3QgdGhyb3VnaCA9IGluY2x1ZGUudGhyb3VnaDtcbiAgICBjb25zdCB0aHJvdWdoVGFibGUgPSB0aHJvdWdoLm1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgIGNvbnN0IHRocm91Z2hBcyA9IGAke2luY2x1ZGVBcy5pbnRlcm5hbEFzfS0+JHt0aHJvdWdoLmFzfWA7XG4gICAgY29uc3QgZXh0ZXJuYWxUaHJvdWdoQXMgPSBgJHtpbmNsdWRlQXMuZXh0ZXJuYWxBc30uJHt0aHJvdWdoLmFzfWA7XG4gICAgY29uc3QgdGhyb3VnaEF0dHJpYnV0ZXMgPSB0aHJvdWdoLmF0dHJpYnV0ZXMubWFwKGF0dHIgPT4ge1xuICAgICAgbGV0IGFsaWFzID0gYCR7ZXh0ZXJuYWxUaHJvdWdoQXN9LiR7QXJyYXkuaXNBcnJheShhdHRyKSA/IGF0dHJbMV0gOiBhdHRyfWA7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIHRocm91Z2hBcywgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoQXJyYXkuaXNBcnJheShhdHRyKSA/IGF0dHJbMF0gOiBhdHRyKX1gLFxuICAgICAgICAnQVMnLFxuICAgICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcylcbiAgICAgIF0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICBjb25zdCBwYXJlbnRJc1RvcCA9ICFpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbC5uYW1lID09PSB0b3BMZXZlbEluZm8ub3B0aW9ucy5tb2RlbC5uYW1lO1xuICAgIGNvbnN0IHRhYmxlU291cmNlID0gcGFyZW50VGFibGVOYW1lO1xuICAgIGNvbnN0IGlkZW50U291cmNlID0gYXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkO1xuICAgIGNvbnN0IHRhYmxlVGFyZ2V0ID0gaW5jbHVkZUFzLmludGVybmFsQXM7XG4gICAgY29uc3QgaWRlbnRUYXJnZXQgPSBhc3NvY2lhdGlvbi5mb3JlaWduSWRlbnRpZmllckZpZWxkO1xuICAgIGNvbnN0IGF0dHJUYXJnZXQgPSBhc3NvY2lhdGlvbi50YXJnZXRLZXlGaWVsZDtcblxuICAgIGNvbnN0IGpvaW5UeXBlID0gaW5jbHVkZS5yZXF1aXJlZCA/ICdJTk5FUiBKT0lOJyA6IGluY2x1ZGUucmlnaHQgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0c1snUklHSFQgSk9JTiddID8gJ1JJR0hUIE9VVEVSIEpPSU4nIDogJ0xFRlQgT1VURVIgSk9JTic7XG4gICAgbGV0IGpvaW5Cb2R5O1xuICAgIGxldCBqb2luQ29uZGl0aW9uO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBtYWluOiBbXSxcbiAgICAgIHN1YlF1ZXJ5OiBbXVxuICAgIH07XG4gICAgbGV0IGF0dHJTb3VyY2UgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXk7XG4gICAgbGV0IHNvdXJjZUpvaW5PbjtcbiAgICBsZXQgdGFyZ2V0Sm9pbk9uO1xuICAgIGxldCB0aHJvdWdoV2hlcmU7XG4gICAgbGV0IHRhcmdldFdoZXJlO1xuXG4gICAgaWYgKHRvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzICE9PSBmYWxzZSkge1xuICAgICAgLy8gVGhyb3VnaCBpbmNsdWRlcyBhcmUgYWx3YXlzIGhhc01hbnksIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBtYWluQXR0cmlidXRlcyBubyBtYXR0ZXIgd2hhdCAoUmVhbCBqb2luIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQgaW4gc3VicXVlcnkpXG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgdGhyb3VnaEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCBpZiB3ZSBuZWVkIHRvIHVzZSBmaWVsZCBvciBhdHRyaWJ1dGVcbiAgICBpZiAoIXRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbCAhPT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubWFpbk1vZGVsKSB7XG4gICAgICBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQ7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIHN0YXRlbWVudCBmb3IgbGVmdCBzaWRlIG9mIHRocm91Z2hcbiAgICAvLyBVc2VkIGJ5IGJvdGggam9pbiBhbmQgc3VicXVlcnkgd2hlcmVcbiAgICAvLyBJZiBwYXJlbnQgaW5jbHVkZSB3YXMgaW4gYSBzdWJxdWVyeSBuZWVkIHRvIGpvaW4gb24gdGhlIGFsaWFzZWQgYXR0cmlidXRlXG4gICAgaWYgKHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiAhcGFyZW50SXNUb3ApIHtcbiAgICAgIC8vIElmIHdlIGFyZSBtaW5pZnlpbmcgYWxpYXNlcyBhbmQgb3VyIEpPSU4gdGFyZ2V0IGhhcyBiZWVuIG1pbmlmaWVkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgYWxpYXMgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY29sdW1uIG5hbWVcbiAgICAgIGNvbnN0IGpvaW5Tb3VyY2UgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlU291cmNlLCBgJHt0YWJsZVNvdXJjZX0uJHthdHRyU291cmNlfWAsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBgJHt0YWJsZVNvdXJjZX0uJHthdHRyU291cmNlfWA7XG5cbiAgICAgIHNvdXJjZUpvaW5PbiA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGpvaW5Tb3VyY2UpfSA9IGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGFyZSBtaW5pZnlpbmcgYWxpYXNlcyBhbmQgb3VyIEpPSU4gdGFyZ2V0IGhhcyBiZWVuIG1pbmlmaWVkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgYWxpYXMgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY29sdW1uIG5hbWVcbiAgICAgIGNvbnN0IGFsaWFzZWRTb3VyY2UgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlU291cmNlLCBhdHRyU291cmNlLCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgYXR0clNvdXJjZTtcblxuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlU291cmNlKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhc2VkU291cmNlKX0gPSBgO1xuICAgIH1cbiAgICBzb3VyY2VKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFNvdXJjZSl9YDtcblxuICAgIC8vIEZpbHRlciBzdGF0ZW1lbnQgZm9yIHJpZ2h0IHNpZGUgb2YgdGhyb3VnaFxuICAgIC8vIFVzZWQgYnkgYm90aCBqb2luIGFuZCBzdWJxdWVyeSB3aGVyZVxuICAgIHRhcmdldEpvaW5PbiA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlVGFyZ2V0KX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyVGFyZ2V0KX0gPSBgO1xuICAgIHRhcmdldEpvaW5PbiArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50VGFyZ2V0KX1gO1xuXG4gICAgaWYgKHRocm91Z2gud2hlcmUpIHtcbiAgICAgIHRocm91Z2hXaGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHRocm91Z2gud2hlcmUsIHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKSksIHRocm91Z2gubW9kZWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmpvaW5UYWJsZURlcGVuZGVudCkge1xuICAgICAgLy8gR2VuZXJhdGUgYSB3cmFwcGVkIGpvaW4gc28gdGhhdCB0aGUgdGhyb3VnaCB0YWJsZSBqb2luIGNhbiBiZSBkZXBlbmRlbnQgb24gdGhlIHRhcmdldCBqb2luXG4gICAgICBqb2luQm9keSA9IGAoICR7dGhpcy5xdW90ZVRhYmxlKHRocm91Z2hUYWJsZSwgdGhyb3VnaEFzKX0gSU5ORVIgSk9JTiAke3RoaXMucXVvdGVUYWJsZShpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCBpbmNsdWRlQXMuaW50ZXJuYWxBcyl9IE9OICR7dGFyZ2V0Sm9pbk9ufWA7XG4gICAgICBpZiAodGhyb3VnaFdoZXJlKSB7XG4gICAgICAgIGpvaW5Cb2R5ICs9IGAgQU5EICR7dGhyb3VnaFdoZXJlfWA7XG4gICAgICB9XG4gICAgICBqb2luQm9keSArPSAnKSc7XG4gICAgICBqb2luQ29uZGl0aW9uID0gc291cmNlSm9pbk9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZW5lcmF0ZSBqb2luIFNRTCBmb3IgbGVmdCBzaWRlIG9mIHRocm91Z2hcbiAgICAgIGpvaW5Cb2R5ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHRocm91Z2hUYWJsZSwgdGhyb3VnaEFzKX0gT04gJHtzb3VyY2VKb2luT259ICR7am9pblR5cGV9ICR7dGhpcy5xdW90ZVRhYmxlKGluY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCksIGluY2x1ZGVBcy5pbnRlcm5hbEFzKX1gO1xuICAgICAgam9pbkNvbmRpdGlvbiA9IHRhcmdldEpvaW5PbjtcbiAgICAgIGlmICh0aHJvdWdoV2hlcmUpIHtcbiAgICAgICAgam9pbkNvbmRpdGlvbiArPSBgIEFORCAke3Rocm91Z2hXaGVyZX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLndoZXJlIHx8IGluY2x1ZGUudGhyb3VnaC53aGVyZSkge1xuICAgICAgaWYgKGluY2x1ZGUud2hlcmUpIHtcbiAgICAgICAgdGFyZ2V0V2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhpbmNsdWRlLndoZXJlLCB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKSksIGluY2x1ZGUubW9kZWwsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRhcmdldFdoZXJlKSB7XG4gICAgICAgICAgam9pbkNvbmRpdGlvbiArPSBgIEFORCAke3RhcmdldFdoZXJlfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKTtcblxuICAgIHJldHVybiB7XG4gICAgICBqb2luOiBqb2luVHlwZSxcbiAgICAgIGJvZHk6IGpvaW5Cb2R5LFxuICAgICAgY29uZGl0aW9uOiBqb2luQ29uZGl0aW9uLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBHZW5lcmF0ZXMgc3ViUXVlcnlGaWx0ZXIgLSBhIHNlbGVjdCBuZXN0ZWQgaW4gdGhlIHdoZXJlIGNsYXVzZSBvZiB0aGUgc3ViUXVlcnkuXG4gICAqIEZvciBhIGdpdmVuIGluY2x1ZGUgYSBxdWVyeSBpcyBnZW5lcmF0ZWQgdGhhdCBjb250YWlucyBhbGwgdGhlIHdheSBmcm9tIHRoZSBzdWJRdWVyeVxuICAgKiB0YWJsZSB0byB0aGUgaW5jbHVkZSB0YWJsZSBwbHVzIGV2ZXJ5dGhpbmcgdGhhdCdzIGluIHJlcXVpcmVkIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiB0aGVcbiAgICogZ2l2ZW4gaW5jbHVkZS5cbiAgICovXG4gIF9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKSB7XG4gICAgaWYgKCF0b3BMZXZlbEluZm8uc3ViUXVlcnkgfHwgIWluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRvcExldmVsSW5mby5vcHRpb25zLndoZXJlKSB7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZSA9IHt9O1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gaW5jbHVkZTtcbiAgICBsZXQgY2hpbGQgPSBpbmNsdWRlO1xuICAgIGxldCBuZXN0ZWRJbmNsdWRlcyA9IHRoaXMuX2dldFJlcXVpcmVkQ2xvc3VyZShpbmNsdWRlKS5pbmNsdWRlO1xuICAgIGxldCBxdWVyeTtcblxuICAgIHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKHBhcmVudC5wYXJlbnQgJiYgIXBhcmVudC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47IC8vIG9ubHkgZ2VuZXJhdGUgc3ViUXVlcnlGaWx0ZXIgaWYgYWxsIHRoZSBwYXJlbnRzIG9mIHRoaXMgaW5jbHVkZSBhcmUgcmVxdWlyZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5zdWJRdWVyeUZpbHRlcikge1xuICAgICAgICAvLyB0aGUgaW5jbHVkZSBpcyBhbHJlYWR5IGhhbmRsZWQgYXMgdGhpcyBwYXJlbnQgaGFzIHRoZSBpbmNsdWRlIG9uIGl0cyByZXF1aXJlZCBjbG9zdXJlXG4gICAgICAgIC8vIHNraXAgdG8gcHJldmVudCBkdXBsaWNhdGUgc3ViUXVlcnlGaWx0ZXJcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuZXN0ZWRJbmNsdWRlcyA9IFt7IC4uLmNoaWxkLCBpbmNsdWRlOiBuZXN0ZWRJbmNsdWRlcywgYXR0cmlidXRlczogW10gfV07XG4gICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICB9XG5cbiAgICBjb25zdCB0b3BJbmNsdWRlID0gbmVzdGVkSW5jbHVkZXNbMF07XG4gICAgY29uc3QgdG9wUGFyZW50ID0gdG9wSW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgdG9wQXNzb2NpYXRpb24gPSB0b3BJbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIHRvcEluY2x1ZGUuYXNzb2NpYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodG9wSW5jbHVkZS50aHJvdWdoICYmIE9iamVjdCh0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwpID09PSB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5zZWxlY3RRdWVyeSh0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwuZ2V0VGFibGVOYW1lKCksIHtcbiAgICAgICAgYXR0cmlidXRlczogW3RvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5wcmltYXJ5S2V5RmllbGRdLFxuICAgICAgICBpbmNsdWRlOiBNb2RlbC5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKHtcbiAgICAgICAgICBtb2RlbDogdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLFxuICAgICAgICAgIGluY2x1ZGU6IFt7XG4gICAgICAgICAgICBhc3NvY2lhdGlvbjogdG9wQXNzb2NpYXRpb24udG9UYXJnZXQsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIHdoZXJlOiB0b3BJbmNsdWRlLndoZXJlLFxuICAgICAgICAgICAgaW5jbHVkZTogdG9wSW5jbHVkZS5pbmNsdWRlXG4gICAgICAgICAgfV1cbiAgICAgICAgfSkuaW5jbHVkZSxcbiAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBbT3AuYW5kXTogW1xuICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChbXG4gICAgICAgICAgICAgIGAke3RoaXMucXVvdGVUYWJsZSh0b3BQYXJlbnQubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wUGFyZW50Lm1vZGVsLnByaW1hcnlLZXlGaWVsZCl9YCxcbiAgICAgICAgICAgICAgYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCl9YFxuICAgICAgICAgICAgXS5qb2luKCcgPSAnKSksXG4gICAgICAgICAgICB0b3BJbmNsdWRlLnRocm91Z2gud2hlcmVcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICBpbmNsdWRlSWdub3JlQXR0cmlidXRlczogZmFsc2VcbiAgICAgIH0sIHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzQmVsb25nc1RvID0gdG9wQXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlID09PSAnQmVsb25nc1RvJztcbiAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gaXNCZWxvbmdzVG8gPyB0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQgOiB0b3BBc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZCB8fCB0b3BQYXJlbnQubW9kZWwucHJpbWFyeUtleUZpZWxkO1xuICAgICAgY29uc3QgdGFyZ2V0RmllbGQgPSBpc0JlbG9uZ3NUbyA/IHRvcEFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkIHx8IHRvcEluY2x1ZGUubW9kZWwucHJpbWFyeUtleUZpZWxkIDogdG9wQXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkO1xuXG4gICAgICBjb25zdCBqb2luID0gW1xuICAgICAgICBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BJbmNsdWRlLmFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YXJnZXRGaWVsZCl9YCxcbiAgICAgICAgYCR7dGhpcy5xdW90ZVRhYmxlKHRvcFBhcmVudC5hcyB8fCB0b3BQYXJlbnQubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc291cmNlRmllbGQpfWBcbiAgICAgIF0uam9pbignID0gJyk7XG5cbiAgICAgIHF1ZXJ5ID0gdGhpcy5zZWxlY3RRdWVyeSh0b3BJbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0YXJnZXRGaWVsZF0sXG4gICAgICAgIGluY2x1ZGU6IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHModG9wSW5jbHVkZSkuaW5jbHVkZSxcbiAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRvcEluY2x1ZGUud2hlcmUsXG4gICAgICAgICAgICB7IFtPcC5qb2luXTogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChqb2luKSB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgdGFibGVBczogdG9wSW5jbHVkZS5hcyxcbiAgICAgICAgaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICB9LCB0b3BJbmNsdWRlLm1vZGVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW09wLmFuZF0pIHtcbiAgICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW09wLmFuZF0gPSBbXTtcbiAgICB9XG5cbiAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtgX18ke2luY2x1ZGVBcy5pbnRlcm5hbEFzfWBdID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChbXG4gICAgICAnKCcsXG4gICAgICBxdWVyeS5yZXBsYWNlKC87JC8sICcnKSxcbiAgICAgICcpJyxcbiAgICAgICdJUyBOT1QgTlVMTCdcbiAgICBdLmpvaW4oJyAnKSk7XG4gIH1cblxuICAvKlxuICAgKiBGb3IgYSBnaXZlbiBpbmNsdWRlIGhpZXJhcmNoeSBjcmVhdGVzIGEgY29weSBvZiBpdCB3aGVyZSBvbmx5IHRoZSByZXF1aXJlZCBpbmNsdWRlc1xuICAgKiBhcmUgcHJlc2VydmVkLlxuICAgKi9cbiAgX2dldFJlcXVpcmVkQ2xvc3VyZShpbmNsdWRlKSB7XG4gICAgY29uc3QgY29weSA9IHsgLi4uaW5jbHVkZSwgYXR0cmlidXRlczogW10sIGluY2x1ZGU6IFtdIH07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNsdWRlLmluY2x1ZGUpKSB7XG4gICAgICBjb3B5LmluY2x1ZGUgPSBpbmNsdWRlLmluY2x1ZGVcbiAgICAgICAgLmZpbHRlcihpID0+IGkucmVxdWlyZWQpXG4gICAgICAgIC5tYXAoaW5jID0+IHRoaXMuX2dldFJlcXVpcmVkQ2xvc3VyZShpbmMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIGdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBzdWJRdWVyeSkge1xuICAgIGNvbnN0IG1haW5RdWVyeU9yZGVyID0gW107XG4gICAgY29uc3Qgc3ViUXVlcnlPcmRlciA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vcmRlcikpIHtcbiAgICAgIGZvciAobGV0IG9yZGVyIG9mIG9wdGlvbnMub3JkZXIpIHtcblxuICAgICAgICAvLyB3cmFwIGlmIG5vdCBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgICAgb3JkZXIgPSBbb3JkZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN1YlF1ZXJ5XG4gICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShvcmRlcilcbiAgICAgICAgICAmJiBvcmRlclswXVxuICAgICAgICAgICYmICEob3JkZXJbMF0gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbilcbiAgICAgICAgICAmJiAhKHR5cGVvZiBvcmRlclswXSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcmRlclswXS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbClcbiAgICAgICAgICAmJiAhKHR5cGVvZiBvcmRlclswXS5tb2RlbCA9PT0gJ2Z1bmN0aW9uJyAmJiBvcmRlclswXS5tb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbClcbiAgICAgICAgICAmJiAhKHR5cGVvZiBvcmRlclswXSA9PT0gJ3N0cmluZycgJiYgbW9kZWwgJiYgbW9kZWwuYXNzb2NpYXRpb25zICE9PSB1bmRlZmluZWQgJiYgbW9kZWwuYXNzb2NpYXRpb25zW29yZGVyWzBdXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3ViUXVlcnlPcmRlci5wdXNoKHRoaXMucXVvdGUob3JkZXIsIG1vZGVsLCAnLT4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBzdWItcXVlcnkgcmVuYW1lcyBhdHRyaWJ1dGUgd2Ugd2FudCB0byBvcmRlciBieSxcbiAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvaXNzdWVzLzg3MzlcbiAgICAgICAgICBjb25zdCBzdWJRdWVyeUF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlcy5maW5kKGEgPT4gQXJyYXkuaXNBcnJheShhKSAmJiBhWzBdID09PSBvcmRlclswXSAmJiBhWzFdKTtcbiAgICAgICAgICBpZiAoc3ViUXVlcnlBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLm5hbWUpO1xuXG4gICAgICAgICAgICBvcmRlclswXSA9IG5ldyBVdGlscy5Db2wodGhpcy5fZ2V0QWxpYXNGb3JGaWVsZChtb2RlbE5hbWUsIHN1YlF1ZXJ5QXR0cmlidXRlWzFdLCBvcHRpb25zKSB8fCBzdWJRdWVyeUF0dHJpYnV0ZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFpblF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlKG9yZGVyLCBtb2RlbCwgJy0+JykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmRlciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgY29uc3Qgc3FsID0gdGhpcy5xdW90ZShvcHRpb25zLm9yZGVyLCBtb2RlbCwgJy0+Jyk7XG4gICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgc3ViUXVlcnlPcmRlci5wdXNoKHNxbCk7XG4gICAgICB9XG4gICAgICBtYWluUXVlcnlPcmRlci5wdXNoKHNxbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3JkZXIgbXVzdCBiZSB0eXBlIG9mIGFycmF5IG9yIGluc3RhbmNlIG9mIGEgdmFsaWQgc2VxdWVsaXplIG1ldGhvZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtYWluUXVlcnlPcmRlciwgc3ViUXVlcnlPcmRlciB9O1xuICB9XG5cbiAgX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZXh0cmFJbmZvID0ge30pIHtcbiAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKSByZXR1cm47XG4gICAgY29uc3QgYXNQYXJ0ID0gZXh0cmFJbmZvLmFzICYmIGBhcyAke2V4dHJhSW5mby5hc31gIHx8ICcnO1xuICAgIGNvbnN0IG5hbWVQYXJ0ID0gZXh0cmFJbmZvLm1vZGVsTmFtZSAmJiBgZm9yIG1vZGVsICcke2V4dHJhSW5mby5tb2RlbE5hbWV9J2AgfHwgJyc7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBBdHRlbXB0ZWQgYSBTRUxFQ1QgcXVlcnkgJHtuYW1lUGFydH0gJHthc1BhcnR9IHdpdGhvdXQgc2VsZWN0aW5nIGFueSBjb2x1bW5zYDtcbiAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3IuUXVlcnlFcnJvcihtZXNzYWdlLnJlcGxhY2UoLyArL2csICcgJykpO1xuICB9XG5cbiAgc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbW9kZWwsIGF0dHJpYnV0ZXMsIHRhYmxlcywgbWFpblRhYmxlQXMpIHtcbiAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIHsgbW9kZWxOYW1lOiBtb2RlbCAmJiBtb2RlbC5uYW1lLCBhczogbWFpblRhYmxlQXMgfSk7XG5cbiAgICBsZXQgZnJhZ21lbnQgPSBgU0VMRUNUICR7YXR0cmlidXRlcy5qb2luKCcsICcpfSBGUk9NICR7dGFibGVzfWA7XG5cbiAgICBpZiAobWFpblRhYmxlQXMpIHtcbiAgICAgIGZyYWdtZW50ICs9IGAgQVMgJHttYWluVGFibGVBc31gO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGV4SGludHMgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleEhpbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhpbnQgb2Ygb3B0aW9ucy5pbmRleEhpbnRzKSB7XG4gICAgICAgIGlmIChJbmRleEhpbnRzW2hpbnQudHlwZV0pIHtcbiAgICAgICAgICBmcmFnbWVudCArPSBgICR7SW5kZXhIaW50c1toaW50LnR5cGVdfSBJTkRFWCAoJHtoaW50LnZhbHVlcy5tYXAoaW5kZXhOYW1lID0+IHRoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpKS5qb2luKCcsJyl9KWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBTUUwgZnJhZ21lbnQgZm9yIGFkZGluZyByZXN1bHQgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBzZWxlY3RRdWVyeSBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9ICcnO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCAmJiBvcHRpb25zLmxpbWl0ID09IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9ICcgTElNSVQgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KSArICcsICcgKyAxMDAwMDAwMDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gJyBMSU1JVCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpICsgJywgJyArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gJyBMSU1JVCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLk9wZXJhdG9yTWFwLCBzbXRoLmNvbXBhcmF0b3IpKSB7XG4gICAgICBzbXRoLmNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW3NtdGguY29tcGFyYXRvcl07XG4gICAgfVxuXG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5XaGVyZSkge1xuICAgICAgbGV0IHZhbHVlID0gc210aC5sb2dpYztcbiAgICAgIGxldCBrZXk7XG5cbiAgICAgIGlmIChzbXRoLmF0dHJpYnV0ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICBrZXkgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhzbXRoLmF0dHJpYnV0ZSwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGAke3RoaXMucXVvdGVUYWJsZShzbXRoLmF0dHJpYnV0ZS5Nb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzbXRoLmF0dHJpYnV0ZS5maWVsZCB8fCBzbXRoLmF0dHJpYnV0ZS5maWVsZE5hbWUpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHZhbHVlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ05VTEwnKSB7XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSAnSVMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSAnIT0nKSB7XG4gICAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSAnSVMgTk9UJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke3NtdGguY29tcGFyYXRvcn0gYCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShzbXRoLmF0dHJpYnV0ZSwgdmFsdWUsIHtcbiAgICAgICAgICBtb2RlbDogZmFjdG9yeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChbdGhpcy5PcGVyYXRvck1hcFtPcC5iZXR3ZWVuXSwgdGhpcy5PcGVyYXRvck1hcFtPcC5ub3RCZXR3ZWVuXV0uaW5jbHVkZXMoc210aC5jb21wYXJhdG9yKSkge1xuICAgICAgICB2YWx1ZSA9IGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdKX0gQU5EICR7dGhpcy5lc2NhcGUodmFsdWVbMV0pfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5ib29sZWFuVmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gJ05VTEwnKSB7XG4gICAgICAgIGlmIChzbXRoLmNvbXBhcmF0b3IgPT09ICc9Jykge1xuICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9ICdJUyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gJyE9Jykge1xuICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9ICdJUyBOT1QnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7c210aC5jb21wYXJhdG9yfSBgKTtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICByZXR1cm4gc210aC52YWw7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKHNtdGgudmFsIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgudmFsLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfSBlbHNlIGlmIChfLmlzUGxhaW5PYmplY3Qoc210aC52YWwpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgudmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZXNjYXBlKHNtdGgudmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBDQVNUKCR7cmVzdWx0fSBBUyAke3NtdGgudHlwZS50b1VwcGVyQ2FzZSgpfSlgO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkZuKSB7XG4gICAgICByZXR1cm4gYCR7c210aC5mbn0oJHtcbiAgICAgICAgc210aC5hcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhcmcsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZy5yZXBsYWNlKCckJywgJyQkJCcpIDogYXJnKTtcbiAgICAgICAgfSkuam9pbignLCAnKVxuICAgICAgfSlgO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNvbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc210aC5jb2wpICYmICFmYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgU2VxdWVsaXplLmNvbCgpIHdpdGggYXJyYXkgb3V0c2lkZSBvZiBvcmRlciAvIGdyb3VwIGNsYXVzZScpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGguY29sLnN0YXJ0c1dpdGgoJyonKSkge1xuICAgICAgICByZXR1cm4gJyonO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucXVvdGUoc210aC5jb2wsIGZhY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gc210aC50b1N0cmluZyh0aGlzLCBmYWN0b3J5KTtcbiAgfVxuXG4gIHdoZXJlUXVlcnkod2hlcmUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHdoZXJlLCBvcHRpb25zKTtcbiAgICBpZiAocXVlcnkgJiYgcXVlcnkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYFdIRVJFICR7cXVlcnl9YDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgd2hlcmVJdGVtc1F1ZXJ5KHdoZXJlLCBvcHRpb25zLCBiaW5kaW5nKSB7XG4gICAgaWYgKFxuICAgICAgd2hlcmUgPT09IG51bGwgfHxcbiAgICAgIHdoZXJlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIFV0aWxzLmdldENvbXBsZXhTaXplKHdoZXJlKSA9PT0gMFxuICAgICkge1xuICAgICAgLy8gTk8gT1BcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdoZXJlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciBge3doZXJlOiBcXCdyYXcgcXVlcnlcXCd9YCBoYXMgYmVlbiByZW1vdmVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBiaW5kaW5nID0gYmluZGluZyB8fCAnQU5EJztcbiAgICBpZiAoYmluZGluZ1swXSAhPT0gJyAnKSBiaW5kaW5nID0gYCAke2JpbmRpbmd9IGA7XG5cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHdoZXJlKSkge1xuICAgICAgVXRpbHMuZ2V0Q29tcGxleEtleXMod2hlcmUpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB3aGVyZVtwcm9wXTtcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHByb3AsIGl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodW5kZWZpbmVkLCB3aGVyZSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggJiYgaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCkuam9pbihiaW5kaW5nKSB8fCAnJztcbiAgfVxuXG4gIHdoZXJlSXRlbVF1ZXJ5KGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdIRVJFIHBhcmFtZXRlciBcIiR7a2V5fVwiIGhhcyBpbnZhbGlkIFwidW5kZWZpbmVkXCIgdmFsdWVgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmluY2x1ZGVzKCcuJykgJiYgb3B0aW9ucy5tb2RlbCkge1xuICAgICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgIGlmIChvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5UGFydHNbMF1dICYmIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHt9O1xuICAgICAgICBjb25zdCBmaWVsZCA9IG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV07XG4gICAgICAgIF8uc2V0KHRtcCwga2V5UGFydHMuc2xpY2UoMSksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkoZmllbGQuZmllbGQgfHwga2V5UGFydHNbMF0sIHRtcCwgeyBmaWVsZCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuX2ZpbmRGaWVsZChrZXksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGZpZWxkVHlwZSA9IGZpZWxkICYmIGZpZWxkLnR5cGUgfHwgb3B0aW9ucy50eXBlO1xuXG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgY29uc3QgaXNBcnJheSA9ICFpc1BsYWluT2JqZWN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGtleSA9IHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgJiYgdGhpcy5PcGVyYXRvcnNBbGlhc01hcFtrZXldIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlS2V5cyA9IGlzUGxhaW5PYmplY3QgJiYgVXRpbHMuZ2V0Q29tcGxleEtleXModmFsdWUpO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIHZhbHVlS2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkodmFsdWVLZXlzWzBdLCB2YWx1ZVt2YWx1ZUtleXNbMF1dLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/ICdOVUxMJyA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5pc10sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBjb25zdCBvcFZhbHVlID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgJiYgIShrZXkgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkZuKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHdoZXJlOiBbXSB0byBPcC5hbmQgaWYgcG9zc2libGUsIGVsc2UgdHJlYXQgYXMgbGl0ZXJhbC9yZXBsYWNlbWVudHNcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgJiYgaXNBcnJheSkge1xuICAgICAgaWYgKFV0aWxzLmNhblRyZWF0QXJyYXlBc0FuZCh2YWx1ZSkpIHtcbiAgICAgICAga2V5ID0gT3AuYW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciBsaXRlcmFsIHJlcGxhY2VtZW50cyBpbiB0aGUgYHdoZXJlYCBvYmplY3QgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSBPcC5vciB8fCBrZXkgPT09IE9wLmFuZCB8fCBrZXkgPT09IE9wLm5vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlR3JvdXBCaW5kKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuXG4gICAgaWYgKHZhbHVlW09wLm9yXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlQmluZCh0aGlzLk9wZXJhdG9yTWFwW09wLm9yXSwga2V5LCB2YWx1ZVtPcC5vcl0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZVtPcC5hbmRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVCaW5kKHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSwga2V5LCB2YWx1ZVtPcC5hbmRdLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSAmJiBmaWVsZFR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIGZpZWxkVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIElmIG11bHRpcGxlIGtleXMgd2UgY29tYmluZSB0aGUgZGlmZmVyZW50IGxvZ2ljIGNvbmRpdGlvbnNcbiAgICBpZiAoaXNQbGFpbk9iamVjdCAmJiB2YWx1ZUtleXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlQmluZCh0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0sIGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIE9wLmluLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5PcGVyYXRvck1hcFt2YWx1ZUtleXNbMF1dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdmFsdWVLZXlzWzBdLCB2YWx1ZVt2YWx1ZUtleXNbMF1dLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSBPcC5wbGFjZWhvbGRlcikge1xuICAgICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZSh0aGlzLk9wZXJhdG9yTWFwW2tleV0sIG9wVmFsdWUsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG5cbiAgX2ZpbmRGaWVsZChrZXksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5maWVsZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZmllbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzICYmIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXldKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXAgJiYgb3B0aW9ucy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXBba2V5XSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV07XG4gICAgfVxuICB9XG5cbiAgLy8gT1IvQU5EL05PVCBncm91cGluZyBsb2dpY1xuICBfd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBrZXkgPT09IE9wLm9yID8gdGhpcy5PcGVyYXRvck1hcFtPcC5vcl0gOiB0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF07XG4gICAgY29uc3Qgb3V0ZXJCaW5kaW5nID0ga2V5ID09PSBPcC5ub3QgPyAnTk9UICcgOiAnJztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoaXRlbSA9PiB7XG4gICAgICAgIGxldCBpdGVtUXVlcnkgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShpdGVtLCBvcHRpb25zLCB0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0pO1xuICAgICAgICBpZiAoaXRlbVF1ZXJ5ICYmIGl0ZW1RdWVyeS5sZW5ndGggJiYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSAmJiBVdGlscy5nZXRDb21wbGV4U2l6ZShpdGVtKSA+IDEpIHtcbiAgICAgICAgICBpdGVtUXVlcnkgPSBgKCR7aXRlbVF1ZXJ5fSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUXVlcnk7XG4gICAgICB9KS5maWx0ZXIoaXRlbSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKTtcblxuICAgICAgdmFsdWUgPSB2YWx1ZS5sZW5ndGggJiYgdmFsdWUuam9pbihiaW5kaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeSh2YWx1ZSwgb3B0aW9ucywgYmluZGluZyk7XG4gICAgfVxuICAgIC8vIE9wLm9yOiBbXSBzaG91bGQgcmV0dXJuIG5vIGRhdGEuXG4gICAgLy8gT3Aubm90IG9mIG5vIHJlc3RyaWN0aW9uIHNob3VsZCBhbHNvIHJldHVybiBubyBkYXRhXG4gICAgaWYgKChrZXkgPT09IE9wLm9yIHx8IGtleSA9PT0gT3Aubm90KSAmJiAhdmFsdWUpIHtcbiAgICAgIHJldHVybiAnMCA9IDEnO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA/IGAke291dGVyQmluZGluZ30oJHt2YWx1ZX0pYCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF93aGVyZUJpbmQoYmluZGluZywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IFV0aWxzLmdldENvbXBsZXhLZXlzKHZhbHVlKS5tYXAocHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtwcm9wXTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkoa2V5LCB7IFtwcm9wXTogaXRlbSB9LCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChpdGVtID0+IHRoaXMud2hlcmVJdGVtUXVlcnkoa2V5LCBpdGVtLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSB2YWx1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKTtcblxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyBgKCR7dmFsdWUuam9pbihiaW5kaW5nKX0pYCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGJhc2VLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgIGlmIChvcHRpb25zLnByZWZpeCkge1xuICAgICAgaWYgKG9wdGlvbnMucHJlZml4IGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICBiYXNlS2V5ID0gYCR7dGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VLZXkgPSBgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBVdGlscy5nZXRPcGVyYXRvcnModmFsdWUpLmZvckVhY2gob3AgPT4ge1xuICAgICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICAgIFtvcF06IHZhbHVlW29wXVxuICAgICAgfTtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHdoZXJlLCB7IC4uLm9wdGlvbnMsIGpzb246IGZhbHNlIH0pKTtcbiAgICB9KTtcblxuICAgIF8uZm9yT3duKHZhbHVlLCAoaXRlbSwgcHJvcCkgPT4ge1xuICAgICAgdGhpcy5fdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBwcm9wLCBpdGVtLCBbcHJvcF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gaXRlbXMuam9pbih0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0pO1xuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPiAxID8gYCgke3Jlc3VsdH0pYCA6IHJlc3VsdDtcbiAgfVxuXG4gIF90cmF2ZXJzZUpTT04oaXRlbXMsIGJhc2VLZXksIHByb3AsIGl0ZW0sIHBhdGgpIHtcbiAgICBsZXQgY2FzdDtcblxuICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0uaW5jbHVkZXMoJzo6JykpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXS5zcGxpdCgnOjonKTtcbiAgICAgIGNhc3QgPSB0bXBbMV07XG4gICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPSB0bXBbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aEtleSA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoYmFzZUtleSwgcGF0aCk7XG5cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICBVdGlscy5nZXRPcGVyYXRvcnMoaXRlbSkuZm9yRWFjaChvcCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdG9KU09OVmFsdWUoaXRlbVtvcF0pO1xuICAgICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodGhpcy5fY2FzdEtleShwYXRoS2V5LCB2YWx1ZSwgY2FzdCksIHsgW29wXTogdmFsdWUgfSkpO1xuICAgICAgfSk7XG4gICAgICBfLmZvck93bihpdGVtLCAodmFsdWUsIGl0ZW1Qcm9wKSA9PiB7XG4gICAgICAgIHRoaXMuX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgaXRlbVByb3AsIHZhbHVlLCBwYXRoLmNvbmNhdChbaXRlbVByb3BdKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGl0ZW0gPSB0aGlzLl90b0pTT05WYWx1ZShpdGVtKTtcbiAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodGhpcy5fY2FzdEtleShwYXRoS2V5LCBpdGVtLCBjYXN0KSwgeyBbT3AuZXFdOiBpdGVtIH0pKTtcbiAgfVxuXG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIF9jYXN0S2V5KGtleSwgdmFsdWUsIGNhc3QsIGpzb24pIHtcbiAgICBjYXN0ID0gY2FzdCB8fCB0aGlzLl9nZXRKc29uQ2FzdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWUpO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICByZXR1cm4gbmV3IFV0aWxzLkxpdGVyYWwodGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QobmV3IFV0aWxzLkNhc3QobmV3IFV0aWxzLkxpdGVyYWwoa2V5KSwgY2FzdCwganNvbikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFV0aWxzLkxpdGVyYWwoa2V5KTtcbiAgfVxuXG4gIF9nZXRKc29uQ2FzdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ2RvdWJsZSBwcmVjaXNpb24nO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ3RpbWVzdGFtcHR6JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBfam9pbktleVZhbHVlKGtleSwgdmFsdWUsIGNvbXBhcmF0b3IsIHByZWZpeCkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGFuZCAke3ZhbHVlfSBoYXMgbm8gY29tcGFyYXRvcmApO1xuICAgIH1cbiAgICBrZXkgPSB0aGlzLl9nZXRTYWZlS2V5KGtleSwgcHJlZml4KTtcbiAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke2NvbXBhcmF0b3J9IGApO1xuICB9XG5cbiAgX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICBrZXkgPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeEtleSh0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpLCBwcmVmaXgpO1xuICAgIH1cblxuICAgIGlmIChVdGlscy5pc0NvbFN0cmluZyhrZXkpKSB7XG4gICAgICBrZXkgPSBrZXkuc3Vic3RyKDEsIGtleS5sZW5ndGggLSAyKS5zcGxpdCgnLicpO1xuXG4gICAgICBpZiAoa2V5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAga2V5ID0gW1xuICAgICAgICAgIC8vIGpvaW4gdGhlIHRhYmxlcyBieSAtPiB0byBtYXRjaCBvdXQgaW50ZXJuYWwgbmFtaW5nc1xuICAgICAgICAgIGtleS5zbGljZSgwLCAtMSkuam9pbignLT4nKSxcbiAgICAgICAgICBrZXlba2V5Lmxlbmd0aCAtIDFdXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXkubWFwKGlkZW50aWZpZXIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpLmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJlZml4S2V5KHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksIHByZWZpeCk7XG4gIH1cblxuICBfcHJlZml4S2V5KGtleSwgcHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChwcmVmaXgpLCBrZXldLmpvaW4oJy4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt0aGlzLnF1b3RlVGFibGUocHJlZml4KSwga2V5XS5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIF93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgcHJvcCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvcCA9PT0gT3Aubm90KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcHJvcCA9IE9wLm5vdEluO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcHJvcCA9IE9wLm5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtwcm9wXSB8fCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSBPcC5pbjpcbiAgICAgIGNhc2UgT3Aubm90SW46XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdmFsdWUudmFsLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt2YWx1ZS5tYXAoaXRlbSA9PiB0aGlzLmVzY2FwZShpdGVtLCBmaWVsZCkpLmpvaW4oJywgJyl9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLmluXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCAnKE5VTEwpJywgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgY2FzZSBPcC5hbnk6XG4gICAgICBjYXNlIE9wLmFsbDpcbiAgICAgICAgY29tcGFyYXRvciA9IGAke3RoaXMuT3BlcmF0b3JNYXBbT3AuZXFdfSAke2NvbXBhcmF0b3J9YDtcbiAgICAgICAgaWYgKHZhbHVlW09wLnZhbHVlc10pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYChWQUxVRVMgJHt2YWx1ZVtPcC52YWx1ZXNdLm1hcChpdGVtID0+IGAoJHt0aGlzLmVzY2FwZShpdGVtKX0pYCkuam9pbignLCAnKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpfSlgLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICBjYXNlIE9wLmJldHdlZW46XG4gICAgICBjYXNlIE9wLm5vdEJldHdlZW46XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgJHt0aGlzLmVzY2FwZSh2YWx1ZVswXSwgZmllbGQpfSBBTkQgJHt0aGlzLmVzY2FwZSh2YWx1ZVsxXSwgZmllbGQpfWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNhc2UgT3AucmF3OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgJHJhd2Agd2hlcmUgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gIFVzZSBgc2VxdWVsaXplLmxpdGVyYWxgIGluc3RlYWQuJyk7XG4gICAgICBjYXNlIE9wLmNvbDpcbiAgICAgICAgY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YWx1ZSA9IFtcbiAgICAgICAgICAgIC8vIGpvaW4gdGhlIHRhYmxlcyBieSAtPiB0byBtYXRjaCBvdXQgaW50ZXJuYWwgbmFtaW5nc1xuICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgLTEpLmpvaW4oJy0+JyksXG4gICAgICAgICAgICB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXVxuICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdmFsdWUubWFwKGlkZW50aWZpZXIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpLmpvaW4oJy4nKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5zdGFydHNXaXRoOlxuICAgICAgY2FzZSBPcC5lbmRzV2l0aDpcbiAgICAgIGNhc2UgT3Auc3Vic3RyaW5nOlxuICAgICAgICBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtPcC5saWtlXTtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0dGVybiA9IGAke3ZhbHVlfSVgO1xuXG4gICAgICAgIGlmIChwcm9wID09PSBPcC5lbmRzV2l0aCkgcGF0dGVybiA9IGAlJHt2YWx1ZX1gO1xuICAgICAgICBpZiAocHJvcCA9PT0gT3Auc3Vic3RyaW5nKSBwYXR0ZXJuID0gYCUke3ZhbHVlfSVgO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLmVzY2FwZShwYXR0ZXJuKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZU9wdGlvbnMgPSB7XG4gICAgICBhY2NlcHRTdHJpbmdzOiBjb21wYXJhdG9yLmluY2x1ZGVzKHRoaXMuT3BlcmF0b3JNYXBbT3AubGlrZV0pXG4gICAgfTtcblxuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWVbT3AuY29sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy53aGVyZUl0ZW1RdWVyeShudWxsLCB2YWx1ZSksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZVtPcC5hbnldKSB7XG4gICAgICAgIGVzY2FwZU9wdGlvbnMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt0aGlzLmVzY2FwZSh2YWx1ZVtPcC5hbnldLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyl9KWAsIGAke2NvbXBhcmF0b3J9ICR7dGhpcy5PcGVyYXRvck1hcFtPcC5hbnldfWAsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZVtPcC5hbGxdKSB7XG4gICAgICAgIGVzY2FwZU9wdGlvbnMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt0aGlzLmVzY2FwZSh2YWx1ZVtPcC5hbGxdLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyl9KWAsIGAke2NvbXBhcmF0b3J9ICR7dGhpcy5PcGVyYXRvck1hcFtPcC5hbGxdfWAsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgY29tcGFyYXRvciA9PT0gdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpLCB0aGlzLk9wZXJhdG9yTWFwW09wLmlzXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgY29tcGFyYXRvciA9PT0gdGhpcy5PcGVyYXRvck1hcFtPcC5uZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpLCB0aGlzLk9wZXJhdG9yTWFwW09wLm5vdF0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG5cbiAgLypcbiAgICBUYWtlcyBzb21ldGhpbmcgYW5kIHRyYW5zZm9ybXMgaXQgaW50byB2YWx1ZXMgb2YgYSB3aGVyZSBjb25kaXRpb24uXG4gICBAcHJpdmF0ZVxuICAqL1xuICBnZXRXaGVyZUNvbmRpdGlvbnMoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZVswXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHByZXBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJlcGVuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNtdGggJiYgc210aCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgeyAvLyBDaGVja2luZyBhIHByb3BlcnR5IGlzIGNoZWFwZXIgdGhhbiBhIGxvdCBvZiBpbnN0YW5jZW9mIGNhbGxzXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICB9XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChzbXRoKSkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWUsXG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxldCBwcmltYXJ5S2V5cyA9IGZhY3RvcnkgPyBPYmplY3Qua2V5cyhmYWN0b3J5LnByaW1hcnlLZXlzKSA6IFtdO1xuXG4gICAgICBpZiAocHJpbWFyeUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBTaW5jZSB3ZSdyZSBqdXN0IGEgbnVtYmVyLCBhc3N1bWUgb25seSB0aGUgZmlyc3Qga2V5XG4gICAgICAgIHByaW1hcnlLZXlzID0gcHJpbWFyeUtleXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmltYXJ5S2V5cyA9ICdpZCc7XG4gICAgICB9XG5cbiAgICAgIHdoZXJlW3ByaW1hcnlLZXlzXSA9IHNtdGg7XG5cbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeSh3aGVyZSwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzbXRoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHNtdGgpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbXRoKSkge1xuICAgICAgaWYgKHNtdGgubGVuZ3RoID09PSAwIHx8IHNtdGgubGVuZ3RoID4gMCAmJiBzbXRoWzBdLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcxPTEnO1xuICAgICAgaWYgKFV0aWxzLmNhblRyZWF0QXJyYXlBc0FuZChzbXRoKSkge1xuICAgICAgICBjb25zdCBfc210aCA9IHsgW09wLmFuZF06IHNtdGggfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKF9zbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciBsaXRlcmFsIHJlcGxhY2VtZW50cyBpbiB0aGUgYHdoZXJlYCBvYmplY3QgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICB9XG4gICAgaWYgKHNtdGggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gJzE9MSc7XG4gIH1cblxuICAvLyBBIHJlY3Vyc2l2ZSBwYXJzZXIgZm9yIG5lc3RlZCB3aGVyZSBjb25kaXRpb25zXG4gIHBhcnNlQ29uZGl0aW9uT2JqZWN0KGNvbmRpdGlvbnMsIHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aCB8fCBbXTtcbiAgICByZXR1cm4gXy5yZWR1Y2UoY29uZGl0aW9ucywgKHJlc3VsdCwgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRoaXMucGFyc2VDb25kaXRpb25PYmplY3QodmFsdWUsIHBhdGguY29uY2F0KGtleSkpKTsgLy8gUmVjdXJzaXZlbHkgcGFyc2Ugb2JqZWN0c1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goeyBwYXRoOiBwYXRoLmNvbmNhdChrZXkpLCB2YWx1ZSB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnMnKSk7XG5PYmplY3QuYXNzaWduKFF1ZXJ5R2VuZXJhdG9yLnByb3RvdHlwZSwgcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24nKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnlHZW5lcmF0b3I7XG4iLCIvKipcbiAqIFF1b3RlIGhlbHBlcnMgaW1wbGVtZW50IHF1b3RlIGFiaWxpdHkgZm9yIGFsbCBkaWFsZWN0cy5cbiAqIFRoZXNlIGFyZSBiYXNpYyBibG9jayBvZiBxdWVyeSBidWlsZGluZ1xuICpcbiAqIEl0cyBiZXR0ZXIgdG8gaW1wbGVtZW50IGFsbCBkaWFsZWN0IGltcGxlbWVudGF0aW9uIHRvZ2V0aGVyIGhlcmUuIFdoaWNoIHdpbGwgYWxsb3dcbiAqIGV2ZW4gYWJzdHJhY3QgZ2VuZXJhdG9yIHRvIHVzZSB0aGVtIGJ5IGp1c3Qgc3BlY2lmeWluZyBkaWFsZWN0IHR5cGUuXG4gKlxuICogRGVmaW5pbmcgdGhlc2UgaGVscGVycyBpbiBlYWNoIHF1ZXJ5IGRpYWxlY3Qgd2lsbCBsZWF2ZVxuICogY29kZSBpbiBkdWFsIGRlcGVuZGVuY3kgb2YgYWJzdHJhY3QgPC0+IHNwZWNpZmljIGRpYWxlY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBsaXN0IG9mIHJlc2VydmVkIHdvcmRzIGluIFBvc3RncmVTUUwgMTBcbiAqIHNvdXJjZTogaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy8xMC9zdGF0aWMvc3FsLWtleXdvcmRzLWFwcGVuZGl4Lmh0bWxcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwb3N0Z3Jlc1Jlc2VydmVkV29yZHMgPSAnYWxsLGFuYWx5c2UsYW5hbHl6ZSxhbmQsYW55LGFycmF5LGFzLGFzYyxhc3ltbWV0cmljLGF1dGhvcml6YXRpb24sYmluYXJ5LGJvdGgsY2FzZSxjYXN0LGNoZWNrLGNvbGxhdGUsY29sbGF0aW9uLGNvbHVtbixjb25jdXJyZW50bHksY29uc3RyYWludCxjcmVhdGUsY3Jvc3MsY3VycmVudF9jYXRhbG9nLGN1cnJlbnRfZGF0ZSxjdXJyZW50X3JvbGUsY3VycmVudF9zY2hlbWEsY3VycmVudF90aW1lLGN1cnJlbnRfdGltZXN0YW1wLGN1cnJlbnRfdXNlcixkZWZhdWx0LGRlZmVycmFibGUsZGVzYyxkaXN0aW5jdCxkbyxlbHNlLGVuZCxleGNlcHQsZmFsc2UsZmV0Y2gsZm9yLGZvcmVpZ24sZnJlZXplLGZyb20sZnVsbCxncmFudCxncm91cCxoYXZpbmcsaWxpa2UsaW4saW5pdGlhbGx5LGlubmVyLGludGVyc2VjdCxpbnRvLGlzLGlzbnVsbCxqb2luLGxhdGVyYWwsbGVhZGluZyxsZWZ0LGxpa2UsbGltaXQsbG9jYWx0aW1lLGxvY2FsdGltZXN0YW1wLG5hdHVyYWwsbm90LG5vdG51bGwsbnVsbCxvZmZzZXQsb24sb25seSxvcixvcmRlcixvdXRlcixvdmVybGFwcyxwbGFjaW5nLHByaW1hcnkscmVmZXJlbmNlcyxyZXR1cm5pbmcscmlnaHQsc2VsZWN0LHNlc3Npb25fdXNlcixzaW1pbGFyLHNvbWUsc3ltbWV0cmljLHRhYmxlLHRhYmxlc2FtcGxlLHRoZW4sdG8sdHJhaWxpbmcsdHJ1ZSx1bmlvbix1bmlxdWUsdXNlcix1c2luZyx2YXJpYWRpYyx2ZXJib3NlLHdoZW4sd2hlcmUsd2luZG93LHdpdGgnLnNwbGl0KCcsJyk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgZGlhbGVjdCAgICAgICAgIERpYWxlY3QgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9ICBpZGVudGlmaWVyICAgICAgSWRlbnRpZmllciB0byBxdW90ZVxuICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2U9ZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnF1b3RlSWRlbnRpZmllcnM9dHJ1ZV1cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcXVvdGVJZGVudGlmaWVyKGRpYWxlY3QsIGlkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgaWYgKGlkZW50aWZpZXIgPT09ICcqJykgcmV0dXJuIGlkZW50aWZpZXI7XG5cbiAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICBmb3JjZTogZmFsc2UsXG4gICAgcXVvdGVJZGVudGlmaWVyczogdHJ1ZVxuICB9KTtcblxuICBzd2l0Y2ggKGRpYWxlY3QpIHtcbiAgICBjYXNlICdzcWxpdGUnOlxuICAgIGNhc2UgJ21hcmlhZGInOlxuICAgIGNhc2UgJ215c3FsJzpcbiAgICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnYCcpLCAnYCcpO1xuXG4gICAgY2FzZSAncG9zdGdyZXMnOlxuICAgICAgY29uc3QgcmF3SWRlbnRpZmllciA9IFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdcIicpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuZm9yY2UgIT09IHRydWUgJiZcbiAgICAgICAgb3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSAmJlxuICAgICAgICAhaWRlbnRpZmllci5pbmNsdWRlcygnLicpICYmXG4gICAgICAgICFpZGVudGlmaWVyLmluY2x1ZGVzKCctPicpICYmXG4gICAgICAgICFwb3N0Z3Jlc1Jlc2VydmVkV29yZHMuaW5jbHVkZXMocmF3SWRlbnRpZmllci50b0xvd2VyQ2FzZSgpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEluIFBvc3RncmVzLCBpZiB0YWJsZXMgb3IgYXR0cmlidXRlcyBhcmUgY3JlYXRlZCBkb3VibGUtcXVvdGVkLFxuICAgICAgICAvLyB0aGV5IGFyZSBhbHNvIGNhc2Ugc2Vuc2l0aXZlLiBJZiB0aGV5IGNvbnRhaW4gYW55IHVwcGVyY2FzZVxuICAgICAgICAvLyBjaGFyYWN0ZXJzLCB0aGV5IG11c3QgYWx3YXlzIGJlIGRvdWJsZS1xdW90ZWQuIFRoaXMgbWFrZXMgaXRcbiAgICAgICAgLy8gaW1wb3NzaWJsZSB0byB3cml0ZSBxdWVyaWVzIGluIHBvcnRhYmxlIFNRTCBpZiB0YWJsZXMgYXJlIGNyZWF0ZWQgaW5cbiAgICAgICAgLy8gdGhpcyB3YXkuIEhlbmNlLCB3ZSBzdHJpcCBxdW90ZXMgaWYgd2UgZG9uJ3Qgd2FudCBjYXNlIHNlbnNpdGl2aXR5LlxuICAgICAgICByZXR1cm4gcmF3SWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhyYXdJZGVudGlmaWVyLCAnXCInKTtcbiAgICBjYXNlICdtc3NxbCc6XG4gICAgICByZXR1cm4gYFske2lkZW50aWZpZXIucmVwbGFjZSgvW1tcXF0nXSsvZywgJycpfV1gO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGlhbGVjdCBcIiR7ZGlhbGVjdH1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLnF1b3RlSWRlbnRpZmllciA9IHF1b3RlSWRlbnRpZmllcjtcblxuLyoqXG4gKiBUZXN0IGlmIGEgZ2l2ZSBzdHJpbmcgaXMgYWxyZWFkeSBxdW90ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyUXVvdGVkKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIC9eXFxzKig/OihbYFwiJ10pKD86KD8hXFwxKS58XFwxezJ9KSpcXDFcXC4/KStcXHMqJC9pLnRlc3QoaWRlbnRpZmllcik7XG59XG5tb2R1bGUuZXhwb3J0cy5pc0lkZW50aWZpZXJRdW90ZWQgPSBpc0lkZW50aWZpZXJRdW90ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0b3JzJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IE9wZXJhdG9ySGVscGVycyA9IHtcbiAgT3BlcmF0b3JNYXA6IHtcbiAgICBbT3AuZXFdOiAnPScsXG4gICAgW09wLm5lXTogJyE9JyxcbiAgICBbT3AuZ3RlXTogJz49JyxcbiAgICBbT3AuZ3RdOiAnPicsXG4gICAgW09wLmx0ZV06ICc8PScsXG4gICAgW09wLmx0XTogJzwnLFxuICAgIFtPcC5ub3RdOiAnSVMgTk9UJyxcbiAgICBbT3AuaXNdOiAnSVMnLFxuICAgIFtPcC5pbl06ICdJTicsXG4gICAgW09wLm5vdEluXTogJ05PVCBJTicsXG4gICAgW09wLmxpa2VdOiAnTElLRScsXG4gICAgW09wLm5vdExpa2VdOiAnTk9UIExJS0UnLFxuICAgIFtPcC5pTGlrZV06ICdJTElLRScsXG4gICAgW09wLm5vdElMaWtlXTogJ05PVCBJTElLRScsXG4gICAgW09wLnN0YXJ0c1dpdGhdOiAnTElLRScsXG4gICAgW09wLmVuZHNXaXRoXTogJ0xJS0UnLFxuICAgIFtPcC5zdWJzdHJpbmddOiAnTElLRScsXG4gICAgW09wLnJlZ2V4cF06ICd+JyxcbiAgICBbT3Aubm90UmVnZXhwXTogJyF+JyxcbiAgICBbT3AuaVJlZ2V4cF06ICd+KicsXG4gICAgW09wLm5vdElSZWdleHBdOiAnIX4qJyxcbiAgICBbT3AuYmV0d2Vlbl06ICdCRVRXRUVOJyxcbiAgICBbT3Aubm90QmV0d2Vlbl06ICdOT1QgQkVUV0VFTicsXG4gICAgW09wLm92ZXJsYXBdOiAnJiYnLFxuICAgIFtPcC5jb250YWluc106ICdAPicsXG4gICAgW09wLmNvbnRhaW5lZF06ICc8QCcsXG4gICAgW09wLmFkamFjZW50XTogJy18LScsXG4gICAgW09wLnN0cmljdExlZnRdOiAnPDwnLFxuICAgIFtPcC5zdHJpY3RSaWdodF06ICc+PicsXG4gICAgW09wLm5vRXh0ZW5kUmlnaHRdOiAnJjwnLFxuICAgIFtPcC5ub0V4dGVuZExlZnRdOiAnJj4nLFxuICAgIFtPcC5hbnldOiAnQU5ZJyxcbiAgICBbT3AuYWxsXTogJ0FMTCcsXG4gICAgW09wLmFuZF06ICcgQU5EICcsXG4gICAgW09wLm9yXTogJyBPUiAnLFxuICAgIFtPcC5jb2xdOiAnQ09MJyxcbiAgICBbT3AucGxhY2Vob2xkZXJdOiAnJCRQTEFDRUhPTERFUiQkJyxcbiAgICBbT3AubWF0Y2hdOiAnQEAnXG4gIH0sXG5cbiAgT3BlcmF0b3JzQWxpYXNNYXA6IHt9LFxuXG4gIHNldE9wZXJhdG9yc0FsaWFzZXMoYWxpYXNlcykge1xuICAgIGlmICghYWxpYXNlcyB8fCBfLmlzRW1wdHkoYWxpYXNlcykpIHtcbiAgICAgIHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5PcGVyYXRvcnNBbGlhc01hcCA9IHsgLi4uYWxpYXNlcyB9O1xuICAgIH1cbiAgfSxcblxuICBfcmVwbGFjZUFsaWFzZXMob3JpZykge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGlmICghdGhpcy5PcGVyYXRvcnNBbGlhc01hcCkge1xuICAgICAgcmV0dXJuIG9yaWc7XG4gICAgfVxuXG4gICAgVXRpbHMuZ2V0T3BlcmF0b3JzKG9yaWcpLmZvckVhY2gob3AgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IG9yaWdbb3BdO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgICBvYmpbb3BdID0gdGhpcy5fcmVwbGFjZUFsaWFzZXMoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbb3BdID0gaXRlbTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF8uZm9yT3duKG9yaWcsIChpdGVtLCBwcm9wKSA9PiB7XG4gICAgICBwcm9wID0gdGhpcy5PcGVyYXRvcnNBbGlhc01hcFtwcm9wXSB8fCBwcm9wO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5fcmVwbGFjZUFsaWFzZXMoaXRlbSk7XG4gICAgICB9XG4gICAgICBvYmpbcHJvcF0gPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JIZWxwZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUXVlcmllcyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWVyeSB0aGF0IHNldHMgdGhlIHRyYW5zYWN0aW9uIGlzb2xhdGlvbiBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSAgIFRoZSBpc29sYXRpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBgU0VUIFRSQU5TQUNUSU9OIElTT0xBVElPTiBMRVZFTCAke3ZhbHVlfTtgO1xuICB9LFxuXG4gIGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gdXVpZHY0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWVyeSB0aGF0IHN0YXJ0cyBhIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIC8vIGZvcmNlIHF1b3Rpbmcgb2Ygc2F2ZXBvaW50IGlkZW50aWZpZXJzIGZvciBwb3N0Z3Jlc1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lLCB0cnVlKX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1NUQVJUIFRSQU5TQUNUSU9OOyc7XG4gIH0sXG5cbiAgZGVmZXJDb25zdHJhaW50c1F1ZXJ5KCkge30sXG5cbiAgc2V0Q29uc3RyYWludFF1ZXJ5KCkge30sXG4gIHNldERlZmVycmVkUXVlcnkoKSB7fSxcbiAgc2V0SW1tZWRpYXRlUXVlcnkoKSB7fSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHF1ZXJ5IHRoYXQgY29tbWl0cyBhIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuICdDT01NSVQ7JztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHF1ZXJ5IHRoYXQgcm9sbGJhY2tzIGEgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgIFRoZSBnZW5lcmF0ZWQgc3FsIHF1ZXJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgLy8gZm9yY2UgcXVvdGluZyBvZiBzYXZlcG9pbnQgaWRlbnRpZmllcnMgZm9yIHBvc3RncmVzXG4gICAgICByZXR1cm4gYFJPTExCQUNLIFRPIFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUsIHRydWUpfTtgO1xuICAgIH1cblxuICAgIHJldHVybiAnUk9MTEJBQ0s7JztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvblF1ZXJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90cmFuc2FjdGlvbicpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSB0aGF0IFNlcXVlbGl6ZSB1c2VzIHRvIHRhbGsgdG8gYWxsIGRhdGFiYXNlc1xuICovXG5jbGFzcyBRdWVyeUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSwgcXVlcnlHZW5lcmF0b3IpIHtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gcXVlcnlHZW5lcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0YWJhc2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlICBEYXRhYmFzZSBuYW1lIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNoYXJzZXRdIERhdGFiYXNlIGRlZmF1bHQgY2hhcmFjdGVyIHNldCwgTVlTUUwgb25seVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29sbGF0ZV0gRGF0YWJhc2UgZGVmYXVsdCBjb2xsYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nXSBEYXRhYmFzZSBkZWZhdWx0IGNoYXJhY3RlciBzZXQsIFBvc3RncmVTUUwgb25seVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY3R5cGVdIERhdGFiYXNlIGNoYXJhY3RlciBjbGFzc2lmaWNhdGlvbiwgUG9zdGdyZVNRTCBvbmx5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZW1wbGF0ZV0gVGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGZyb20gd2hpY2ggdG8gY3JlYXRlIHRoZSBuZXcgZGF0YWJhc2UsIFBvc3RncmVTUUwgb25seVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZURhdGFiYXNlKGRhdGFiYXNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGEgZGF0YWJhc2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlICBEYXRhYmFzZSBuYW1lIHRvIGRyb3BcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcERhdGFiYXNlKGRhdGFiYXNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2NoZW1hXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWEgICAgU2NoZW1hIG5hbWUgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVNjaGVtYShzY2hlbWEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYSBzY2hlbWFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYSAgICBTY2hlbWEgbmFtZSB0byBkcm9wXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wU2NoZW1hKHNjaGVtYSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgc2NoZW1hc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wQWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIXRoaXMucXVlcnlHZW5lcmF0b3IuX2RpYWxlY3Quc3VwcG9ydHMuc2NoZW1hcykge1xuICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYXMgPSBhd2FpdCB0aGlzLnNob3dBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChzY2hlbWFzLm1hcChzY2hlbWFOYW1lID0+IHRoaXMuZHJvcFNjaGVtYShzY2hlbWFOYW1lLCBvcHRpb25zKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYWxsIHNjaGVtYXNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICovXG4gIGFzeW5jIHNob3dBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHR5cGU6IHRoaXMuc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0VMRUNUXG4gICAgfTtcblxuICAgIGNvbnN0IHNob3dTY2hlbWFzU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93U2NoZW1hc1F1ZXJ5KG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc2NoZW1hTmFtZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzaG93U2NoZW1hc1NxbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gXy5mbGF0dGVuKHNjaGVtYU5hbWVzLm1hcCh2YWx1ZSA9PiB2YWx1ZS5zY2hlbWFfbmFtZSA/IHZhbHVlLnNjaGVtYV9uYW1lIDogdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZGF0YWJhc2UgdmVyc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgW29wdGlvbnNdICAgICAgUXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1F1ZXJ5VHlwZX0gW29wdGlvbnMudHlwZV0gUXVlcnkgdHlwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGRhdGFiYXNlVmVyc2lvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci52ZXJzaW9uUXVlcnkoKSxcbiAgICAgIHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5WRVJTSU9OIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRhYmxlIHdpdGggZ2l2ZW4gc2V0IG9mIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogYGBganNcbiAgICogcXVlcnlJbnRlcmZhY2UuY3JlYXRlVGFibGUoXG4gICAqICAgJ25hbWVPZlRoZU5ld1RhYmxlJyxcbiAgICogICB7XG4gICAqICAgICBpZDoge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuSU5URUdFUixcbiAgICogICAgICAgcHJpbWFyeUtleTogdHJ1ZSxcbiAgICogICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgKiAgICAgfSxcbiAgICogICAgIGNyZWF0ZWRBdDoge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuREFURVxuICAgKiAgICAgfSxcbiAgICogICAgIHVwZGF0ZWRBdDoge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuREFURVxuICAgKiAgICAgfSxcbiAgICogICAgIGF0dHIxOiBTZXF1ZWxpemUuU1RSSU5HLFxuICAgKiAgICAgYXR0cjI6IFNlcXVlbGl6ZS5JTlRFR0VSLFxuICAgKiAgICAgYXR0cjM6IHtcbiAgICogICAgICAgdHlwZTogU2VxdWVsaXplLkJPT0xFQU4sXG4gICAqICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAqICAgICAgIGFsbG93TnVsbDogZmFsc2VcbiAgICogICAgIH0sXG4gICAqICAgICAvL2ZvcmVpZ24ga2V5IHVzYWdlXG4gICAqICAgICBhdHRyNDoge1xuICAgKiAgICAgICB0eXBlOiBTZXF1ZWxpemUuSU5URUdFUixcbiAgICogICAgICAgcmVmZXJlbmNlczoge1xuICAgKiAgICAgICAgIG1vZGVsOiAnYW5vdGhlcl90YWJsZV9uYW1lJyxcbiAgICogICAgICAgICBrZXk6ICdpZCdcbiAgICogICAgICAgfSxcbiAgICogICAgICAgb25VcGRhdGU6ICdjYXNjYWRlJyxcbiAgICogICAgICAgb25EZWxldGU6ICdjYXNjYWRlJ1xuICAgKiAgICAgfVxuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgZW5naW5lOiAnTVlJU0FNJywgICAgLy8gZGVmYXVsdDogJ0lubm9EQidcbiAgICogICAgIGNoYXJzZXQ6ICdsYXRpbjEnLCAgIC8vIGRlZmF1bHQ6IG51bGxcbiAgICogICAgIHNjaGVtYTogJ3B1YmxpYycsICAgIC8vIGRlZmF1bHQ6IHB1YmxpYywgUG9zdGdyZVNRTCBvbmx5LlxuICAgKiAgICAgY29tbWVudDogJ215IHRhYmxlJywgLy8gY29tbWVudCBmb3IgdGFibGVcbiAgICogICAgIGNvbGxhdGU6ICdsYXRpbjFfZGFuaXNoX2NpJyAvLyBjb2xsYXRpb24sIE1ZU1FMIG9ubHlcbiAgICogICB9XG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgIE5hbWUgb2YgdGFibGUgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIE9iamVjdCByZXByZXNlbnRpbmcgYSBsaXN0IG9mIHRhYmxlIGF0dHJpYnV0ZXMgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gY3JlYXRlIHRhYmxlIGFuZCBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TW9kZWx9ICBbbW9kZWxdIG1vZGVsIGNsYXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGFibGUodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIGxldCBzcWwgPSAnJztcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5mb3JPd24ob3B0aW9ucy51bmlxdWVLZXlzLCB1bmlxdWVLZXkgPT4ge1xuICAgICAgICBpZiAodW5pcXVlS2V5LmN1c3RvbUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1bmlxdWVLZXkuY3VzdG9tSW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG9wdGlvbnMudW5pcXVlS2V5cyA9IG9wdGlvbnMudW5pcXVlS2V5cyB8fCBtb2RlbC51bmlxdWVLZXlzO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMgPSBfLm1hcFZhbHVlcyhcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGUgPT4gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSlcbiAgICApO1xuXG4gICAgLy8gUG9zdGdyZXMgcmVxdWlyZXMgc3BlY2lhbCBTUUwgY29tbWFuZHMgZm9yIEVOVU0vRU5VTVtdXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKTtcblxuICAgIGlmIChcbiAgICAgICF0YWJsZU5hbWUuc2NoZW1hICYmXG4gICAgICAob3B0aW9ucy5zY2hlbWEgfHwgISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hKVxuICAgICkge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRTY2hlbWEoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIF9zY2hlbWE6ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSB8fCBvcHRpb25zLnNjaGVtYVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIHsgdGFibGU6IHRhYmxlTmFtZSwgY29udGV4dDogJ2NyZWF0ZVRhYmxlJyB9KTtcbiAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYSB0YWJsZSBmcm9tIGRhdGFiYXNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgVGFibGUgbmFtZSB0byBkcm9wXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiB3ZSdyZSBmb3JjaW5nIHdlIHNob3VsZCBiZSBjYXNjYWRpbmcgdW5sZXNzIGV4cGxpY2l0bHkgc3RhdGVkIG90aGVyd2lzZVxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLmNhc2NhZGUgPSBvcHRpb25zLmNhc2NhZGUgfHwgb3B0aW9ucy5mb3JjZSB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcblxuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBfZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVOYW1lcykge1xuICAgICAgLy8gaWYgdGFibGVOYW1lIGlzIG5vdCBpbiB0aGUgQXJyYXkgb2YgdGFibGVzIG5hbWVzIHRoZW4gZG9uJ3QgZHJvcCBpdFxuICAgICAgaWYgKCFza2lwLmluY2x1ZGVzKHRhYmxlTmFtZS50YWJsZU5hbWUgfHwgdGFibGVOYW1lKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmRyb3BUYWJsZSh0YWJsZU5hbWUsIHsgLi4ub3B0aW9ucywgY2FzY2FkZTogdHJ1ZSB9ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgYWxsIHRhYmxlcyBmcm9tIGRhdGFiYXNlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc2tpcF0gTGlzdCBvZiB0YWJsZSB0byBza2lwXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcEFsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcblxuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNob3dBbGxUYWJsZXMob3B0aW9ucyk7XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSBhd2FpdCB0aGlzLmdldEZvcmVpZ25LZXlzRm9yVGFibGVzKHRhYmxlTmFtZXMsIG9wdGlvbnMpO1xuXG4gICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVOYW1lcykge1xuICAgICAgbGV0IG5vcm1hbGl6ZWRUYWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5IG9mIGZvcmVpZ25LZXlzW25vcm1hbGl6ZWRUYWJsZU5hbWVdKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlICAgIEN1cnJlbnQgbmFtZSBvZiB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWZ0ZXIgICAgIE5ldyBuYW1lIGZyb20gdGFibGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVuYW1lVGFibGUoYmVmb3JlLCBhZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRhYmxlcyBpbiBjdXJyZW50IGRhdGFiYXNlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgW29wdGlvbnMucmF3PXRydWVdIFJ1biBxdWVyeSBpbiByYXcgbW9kZVxuICAgKiBAcGFyYW0ge1F1ZXJ5VHlwZX0gW29wdGlvbnMudHlwZT1RdWVyeVR5cGUuU0hPV1RBQkxFXSBxdWVyeSB0eXBlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIHNob3dBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmF3OiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TSE9XVEFCTEVTXG4gICAgfTtcblxuICAgIGNvbnN0IHNob3dUYWJsZXNTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dUYWJsZXNRdWVyeSh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpO1xuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzaG93VGFibGVzU3FsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHRhYmxlTmFtZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlIGEgdGFibGUgc3RydWN0dXJlXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2YgaGFzaGVzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHRhYmxlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB7XG4gICAqICAgIG5hbWU6IHtcbiAgICogICAgICB0eXBlOiAgICAgICAgICdWQVJDSEFSKDI1NSknLCAvLyB0aGlzIHdpbGwgYmUgJ0NIQVJBQ1RFUiBWQVJZSU5HJyBmb3IgcGchXG4gICAqICAgICAgYWxsb3dOdWxsOiAgICB0cnVlLFxuICAgKiAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICAgKiAgICB9LFxuICAgKiAgICBpc0JldGFNZW1iZXI6IHtcbiAgICogICAgICB0eXBlOiAgICAgICAgICdUSU5ZSU5UKDEpJywgLy8gdGhpcyB3aWxsIGJlICdCT09MRUFOJyBmb3IgcGchXG4gICAqICAgICAgYWxsb3dOdWxsOiAgICBmYWxzZSxcbiAgICogICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gICAqICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSB0YWJsZSBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fVxuICAgKi9cbiAgYXN5bmMgZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hRGVsaW1pdGVyID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWEgfHwgbnVsbDtcbiAgICAgIHNjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyIHx8IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdvYmplY3QnICYmIHRhYmxlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYTtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZS50YWJsZU5hbWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcik7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZTogUXVlcnlUeXBlcy5ERVNDUklCRSB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgICAgLypcbiAgICAgICAqIElmIG5vIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgcXVlcnksIHRoZW4gdGhlIHRhYmxlIG5hbWUgbWF5IGJlIHdyb25nLlxuICAgICAgICogUXVlcnkgZ2VuZXJhdG9ycyB0aGF0IHVzZSBpbmZvcm1hdGlvbl9zY2hlbWEgZm9yIHJldHJpZXZpbmcgdGFibGUgaW5mbyB3aWxsIGp1c3QgcmV0dXJuIGFuIGVtcHR5IHJlc3VsdCBzZXQsXG4gICAgICAgKiBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBsaWtlIGJ1aWx0LWlucyBkbyAoZS5nLiBERVNDUklCRSBvbiBNeVNxbCkuXG4gICAgICAgKi9cbiAgICAgIGlmIChfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsICYmIGUub3JpZ2luYWwuY29kZSA9PT0gJ0VSX05PX1NVQ0hfVEFCTEUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgY29sdW1uIHRvIGEgdGFibGVcbiAgICpcbiAgICogYGBganNcbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29sdW1uKCd0YWJsZUEnLCAnY29sdW1uQycsIFNlcXVlbGl6ZS5TVFJJTkcsIHtcbiAgICogICAgYWZ0ZXI6ICdjb2x1bW5CJyAvLyBhZnRlciBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgYnkgTXlTUUxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGUgICAgIFRhYmxlIHRvIGFkZCBjb2x1bW4gdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAgICAgICBDb2x1bW4gbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlIEF0dHJpYnV0ZSBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZENvbHVtbih0YWJsZSwga2V5LCBhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRhYmxlIHx8ICFrZXkgfHwgIWF0dHJpYnV0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRDb2x1bW4gdGFrZXMgYXQgbGVhc3QgMyBhcmd1bWVudHMgKHRhYmxlLCBhdHRyaWJ1dGUgbmFtZSwgYXR0cmlidXRlIGRlZmluaXRpb24pJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgYXR0cmlidXRlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgYXR0cmlidXRlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29sdW1uIGZyb20gYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgVGFibGUgdG8gcmVtb3ZlIGNvbHVtbiBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lICBDb2x1bW4gbmFtZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucykge1xuICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRGF0YVR5cGVzKS5pbmNsdWRlcyhkYXRhVHlwZU9yT3B0aW9ucykpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHsgdHlwZTogZGF0YVR5cGVPck9wdGlvbnMsIGFsbG93TnVsbDogdHJ1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGUgPSBkYXRhVHlwZU9yT3B0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIGEgY29sdW1uIGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICAgICBUYWJsZSBuYW1lIHRvIGNoYW5nZSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lICAgICAgQ29sdW1uIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFUeXBlT3JPcHRpb25zICBBdHRyaWJ1dGUgZGVmaW5pdGlvbiBmb3IgbmV3IGNvbHVtblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdICAgICAgICAgIFF1ZXJ5IG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGRhdGFUeXBlT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKHtcbiAgICAgIFthdHRyaWJ1dGVOYW1lXTogdGhpcy5ub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpXG4gICAgfSwge1xuICAgICAgY29udGV4dDogJ2NoYW5nZUNvbHVtbicsXG4gICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIHF1ZXJ5KTtcblxuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlamVjdHMgaWYgdGhlIHRhYmxlIGRvZXNuJ3QgaGF2ZSB0aGUgc3BlY2lmaWVkIGNvbHVtbiwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIGNvbHVtbiBkZXNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoZGVzY3JpcHRpb25bY29sdW1uTmFtZV0pIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAke3RhYmxlTmFtZX0gZG9lc24ndCBoYXZlIHRoZSBjb2x1bW4gJHtjb2x1bW5OYW1lfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgICBUYWJsZSBuYW1lIHdob3NlIGNvbHVtbiB0byByZW5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJOYW1lQmVmb3JlICAgQ3VycmVudCBjb2x1bW4gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVBZnRlciAgICBOZXcgY29sdW1uIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgICAgUXVlcnkgb3B0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVuYW1lQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBkYXRhID0gKGF3YWl0IHRoaXMuYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgb3B0aW9ucykpW2F0dHJOYW1lQmVmb3JlXTtcblxuICAgIGNvbnN0IF9vcHRpb25zID0ge307XG5cbiAgICBfb3B0aW9uc1thdHRyTmFtZUFmdGVyXSA9IHtcbiAgICAgIGF0dHJpYnV0ZTogYXR0ck5hbWVBZnRlcixcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGFsbG93TnVsbDogZGF0YS5hbGxvd051bGwsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRhdGEuZGVmYXVsdFZhbHVlXG4gICAgfTtcblxuICAgIC8vIGZpeDogYSBub3QtbnVsbCBjb2x1bW4gY2Fubm90IGhhdmUgbnVsbCBhcyBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKGRhdGEuZGVmYXVsdFZhbHVlID09PSBudWxsICYmICFkYXRhLmFsbG93TnVsbCkge1xuICAgICAgZGVsZXRlIF9vcHRpb25zW2F0dHJOYW1lQWZ0ZXJdLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUNvbHVtblF1ZXJ5KFxuICAgICAgdGFibGVOYW1lLFxuICAgICAgYXR0ck5hbWVCZWZvcmUsXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTChfb3B0aW9ucylcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpbmRleCB0byBhIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICB0YWJsZU5hbWUgVGFibGUgbmFtZSB0byBhZGQgaW5kZXggb24sIGNhbiBiZSBhIG9iamVjdCB3aXRoIHNjaGVtYVxuICAgKiBAcGFyYW0ge0FycmF5fSAgIFthdHRyaWJ1dGVzXSAgICAgVXNlIG9wdGlvbnMuZmllbGRzIGluc3RlYWQsIExpc3Qgb2YgYXR0cmlidXRlcyB0byBhZGQgaW5kZXggb25cbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICAgICAgICAgIGluZGV4ZXMgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSAgIG9wdGlvbnMuZmllbGRzICAgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGFkZCBpbmRleCBvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbmN1cnJlbnRseV0gUGFzcyBDT05DVVJSRU5UIHNvIG90aGVyIG9wZXJhdGlvbnMgcnVuIHdoaWxlIHRoZSBpbmRleCBpcyBjcmVhdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudW5pcXVlXSBDcmVhdGUgYSB1bmlxdWUgaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBbb3B0aW9ucy51c2luZ10gIFVzZWZ1bCBmb3IgR0lOIGluZGV4ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBbb3B0aW9ucy5vcGVyYXRvcl0gSW5kZXggb3BlcmF0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBbb3B0aW9ucy50eXBlXSAgIFR5cGUgb2YgaW5kZXgsIGF2YWlsYWJsZSBvcHRpb25zIGFyZSBVTklRVUV8RlVMTFRFWFR8U1BBVElBTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtvcHRpb25zLm5hbWVdICAgTmFtZSBvZiB0aGUgaW5kZXguIERlZmF1bHQgaXMgPHRhYmxlPl88YXR0cjE+XzxhdHRyMj5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9ucy53aGVyZV0gIFdoZXJlIGNvbmRpdGlvbiBvbiBpbmRleCwgZm9yIHBhcnRpYWwgaW5kZXhlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtyYXdUYWJsZW5hbWVdICAgdGFibGUgbmFtZSwgdGhpcyBpcyBqdXN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlpdHlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhZGRJbmRleCh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSkge1xuICAgIC8vIFN1cHBvcnQgZm9yIHBhc3NpbmcgdGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zIG9yIHRhYmxlTmFtZSwgb3B0aW9ucyAod2l0aCBhIGZpZWxkcyBwYXJhbSB3aGljaCBpcyB0aGUgYXR0cmlidXRlcylcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICAgIHJhd1RhYmxlbmFtZSA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gYXR0cmlidXRlcztcbiAgICAgIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB9XG5cbiAgICBpZiAoIXJhd1RhYmxlbmFtZSkge1xuICAgICAgLy8gTWFwIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgICByYXdUYWJsZW5hbWUgPSB0YWJsZU5hbWU7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmZpZWxkcyA9IGF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgcmF3VGFibGVuYW1lKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsIHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBpbmRleGVzIG9uIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSB0YWJsZSBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIHNob3dJbmRleCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV0lOREVYRVMgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBmb3JlaWduIGtleSBjb25zdHJhaW50cyBvZiByZXF1ZXN0ZWQgdGFibGVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHRhYmxlTmFtZXMgdGFibGUgbmFtZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleXNGb3JUYWJsZXModGFibGVOYW1lcywgb3B0aW9ucykge1xuICAgIGlmICh0YWJsZU5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVMgfTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0YWJsZU5hbWVzLm1hcCh0YWJsZU5hbWUgPT5cbiAgICAgIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSksIG9wdGlvbnMpKSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIHRhYmxlTmFtZXMuZm9yRWFjaCgodGFibGVOYW1lLCBpKSA9PiB7XG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIHRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdGFibGVOYW1lXSA9IEFycmF5LmlzQXJyYXkocmVzdWx0c1tpXSlcbiAgICAgICAgPyByZXN1bHRzW2ldLm1hcChyID0+IHIuY29uc3RyYWludF9uYW1lKVxuICAgICAgICA6IFtyZXN1bHRzW2ldICYmIHJlc3VsdHNbaV0uY29uc3RyYWludF9uYW1lXTtcblxuICAgICAgcmVzdWx0W3RhYmxlTmFtZV0gPSByZXN1bHRbdGFibGVOYW1lXS5maWx0ZXIoXy5pZGVudGl0eSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmb3JlaWduIGtleSByZWZlcmVuY2VzIGRldGFpbHMgZm9yIHRoZSB0YWJsZVxuICAgKlxuICAgKiBUaG9zZSBkZXRhaWxzIGNvbnRhaW5zIGNvbnN0cmFpbnRTY2hlbWEsIGNvbnN0cmFpbnROYW1lLCBjb25zdHJhaW50Q2F0YWxvZ1xuICAgKiB0YWJsZUNhdGFsb2csIHRhYmxlU2NoZW1hLCB0YWJsZU5hbWUsIGNvbHVtbk5hbWUsXG4gICAqIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2csIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2csIHJlZmVyZW5jZWRUYWJsZVNjaGVtYSwgcmVmZXJlbmNlZFRhYmxlTmFtZSwgcmVmZXJlbmNlZENvbHVtbk5hbWUuXG4gICAqIFJlbWluZDogY29uc3RyYWludCBpbmZvcm1hdGlvbnMgd29uJ3QgcmV0dXJuIGlmIGl0J3Mgc3FsaXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lIHRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgUXVlcnkgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZU1xuICAgIH07XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgcXVlcnlPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYWxyZWFkeSBleGlzdGluZyBpbmRleCBmcm9tIGEgdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgICAgICAgICAgICAgICAgVGFibGUgbmFtZSB0byBkcm9wIGluZGV4IGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGluZGV4TmFtZU9yQXR0cmlidXRlcyAgSW5kZXggbmFtZSBvciBsaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBpbiB0aGUgaW5kZXhcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbW92ZUluZGV4KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIGEgdGFibGVcbiAgICpcbiAgICogQXZhaWxhYmxlIGNvbnN0cmFpbnRzOlxuICAgKiAtIFVOSVFVRVxuICAgKiAtIERFRkFVTFQgKE1TU1FMIG9ubHkpXG4gICAqIC0gQ0hFQ0sgKE15U1FMIC0gSWdub3JlZCBieSB0aGUgZGF0YWJhc2UgZW5naW5lIClcbiAgICogLSBGT1JFSUdOIEtFWVxuICAgKiAtIFBSSU1BUlkgS0VZXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlVOSVFVRTwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnVXNlcnMnLCB7XG4gICAqICAgZmllbGRzOiBbJ2VtYWlsJ10sXG4gICAqICAgdHlwZTogJ3VuaXF1ZScsXG4gICAqICAgbmFtZTogJ2N1c3RvbV91bmlxdWVfY29uc3RyYWludF9uYW1lJ1xuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Q0hFQ0s8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1VzZXJzJywge1xuICAgKiAgIGZpZWxkczogWydyb2xlcyddLFxuICAgKiAgIHR5cGU6ICdjaGVjaycsXG4gICAqICAgd2hlcmU6IHtcbiAgICogICAgICByb2xlczogWyd1c2VyJywgJ2FkbWluJywgJ21vZGVyYXRvcicsICdndWVzdCddXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RGVmYXVsdCAtIE1TU1FMIG9ubHk8L2NhcHRpb24+XG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmFkZENvbnN0cmFpbnQoJ1VzZXJzJywge1xuICAgKiAgICBmaWVsZHM6IFsncm9sZXMnXSxcbiAgICogICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgKiAgICBkZWZhdWx0VmFsdWU6ICdndWVzdCdcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlByaW1hcnkgS2V5PC9jYXB0aW9uPlxuICAgKiBxdWVyeUludGVyZmFjZS5hZGRDb25zdHJhaW50KCdVc2VycycsIHtcbiAgICogICAgZmllbGRzOiBbJ3VzZXJuYW1lJ10sXG4gICAqICAgIHR5cGU6ICdwcmltYXJ5IGtleScsXG4gICAqICAgIG5hbWU6ICdjdXN0b21fcHJpbWFyeV9jb25zdHJhaW50X25hbWUnXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3JlaWduIEtleTwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnUG9zdHMnLCB7XG4gICAqICAgZmllbGRzOiBbJ3VzZXJuYW1lJ10sXG4gICAqICAgdHlwZTogJ2ZvcmVpZ24ga2V5JyxcbiAgICogICBuYW1lOiAnY3VzdG9tX2ZrZXlfY29uc3RyYWludF9uYW1lJyxcbiAgICogICByZWZlcmVuY2VzOiB7IC8vUmVxdWlyZWQgZmllbGRcbiAgICogICAgIHRhYmxlOiAndGFyZ2V0X3RhYmxlX25hbWUnLFxuICAgKiAgICAgZmllbGQ6ICd0YXJnZXRfY29sdW1uX25hbWUnXG4gICAqICAgfSxcbiAgICogICBvbkRlbGV0ZTogJ2Nhc2NhZGUnLFxuICAgKiAgIG9uVXBkYXRlOiAnY2FzY2FkZSdcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbXBvc2l0ZSBGb3JlaWduIEtleTwvY2FwdGlvbj5cbiAgICogcXVlcnlJbnRlcmZhY2UuYWRkQ29uc3RyYWludCgnVGFibGVOYW1lJywge1xuICAgKiAgIGZpZWxkczogWydzb3VyY2VfY29sdW1uX25hbWUnLCAnb3RoZXJfc291cmNlX2NvbHVtbl9uYW1lJ10sXG4gICAqICAgdHlwZTogJ2ZvcmVpZ24ga2V5JyxcbiAgICogICBuYW1lOiAnY3VzdG9tX2ZrZXlfY29uc3RyYWludF9uYW1lJyxcbiAgICogICByZWZlcmVuY2VzOiB7IC8vUmVxdWlyZWQgZmllbGRcbiAgICogICAgIHRhYmxlOiAndGFyZ2V0X3RhYmxlX25hbWUnLFxuICAgKiAgICAgZmllbGRzOiBbJ3RhcmdldF9jb2x1bW5fbmFtZScsICdvdGhlcl90YXJnZXRfY29sdW1uX25hbWUnXVxuICAgKiAgIH0sXG4gICAqICAgb25EZWxldGU6ICdjYXNjYWRlJyxcbiAgICogICBvblVwZGF0ZTogJ2Nhc2NhZGUnXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgICAgICAgICAgICAgIFRhYmxlIG5hbWUgd2hlcmUgeW91IHdhbnQgdG8gYWRkIGEgY29uc3RyYWludFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB0byBkZWZpbmUgdGhlIGNvbnN0cmFpbnQgbmFtZSwgdHlwZSBldGNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSAgICAgICAgICAgICAgICBUeXBlIG9mIGNvbnN0cmFpbnQuIE9uZSBvZiB0aGUgdmFsdWVzIGluIGF2YWlsYWJsZSBjb25zdHJhaW50cyhjYXNlIGluc2Vuc2l0aXZlKVxuICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0aW9ucy5maWVsZHMgICAgICAgICAgICAgIEFycmF5IG9mIGNvbHVtbiBuYW1lcyB0byBhcHBseSB0aGUgY29uc3RyYWludCBvdmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAgICAgICAgICAgICAgTmFtZSBvZiB0aGUgY29uc3RyYWludC4gSWYgbm90IHNwZWNpZmllZCwgc2VxdWVsaXplIGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBhIG5hbWVkIGNvbnN0cmFpbnQgYmFzZWQgb24gY29uc3RyYWludCB0eXBlLCB0YWJsZSAmIGNvbHVtbiBuYW1lc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXSAgICAgIFRoZSB2YWx1ZSBmb3IgdGhlIGRlZmF1bHQgY29uc3RyYWludFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMud2hlcmVdICAgICAgICAgICAgIFdoZXJlIGNsYXVzZS9leHByZXNzaW9uIGZvciB0aGUgQ0hFQ0sgY29uc3RyYWludFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucmVmZXJlbmNlc10gICAgICAgIE9iamVjdCBzcGVjaWZ5aW5nIHRhcmdldCB0YWJsZSwgY29sdW1uIG5hbWUgdG8gY3JlYXRlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZXMudGFibGVdICBUYXJnZXQgdGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVmZXJlbmNlcy5maWVsZF0gIFRhcmdldCBjb2x1bW4gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVmZXJlbmNlcy5maWVsZHNdIFRhcmdldCBjb2x1bW4gbmFtZXMgZm9yIGEgY29tcG9zaXRlIHByaW1hcnkga2V5LiBNdXN0IG1hdGNoIHRoZSBvcmRlciBvZiBmaWVsZHMgaW4gb3B0aW9ucy5maWVsZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZlcnJhYmxlXSAgICAgICAgU2V0cyB0aGUgY29uc3RyYWludCB0byBiZSBkZWZlcnJlZCBvciBpbW1lZGlhdGVseSBjaGVja2VkLiBTZWUgU2VxdWVsaXplLkRlZmVycmFibGUuIFBvc3RncmVTUUwgT25seVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZENvbnN0cmFpbnQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZHMgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLmZpZWxkcycpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cmFpbnQgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMudHlwZScpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgc2hvd0NvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UUyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb25zdHJhaW50IGZyb20gYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lICAgICAgIFRhYmxlIG5hbWUgdG8gZHJvcCBjb25zdHJhaW50IGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnN0cmFpbnROYW1lICBDb25zdHJhaW50IG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICBRdWVyeSBvcHRpb25zXG4gICAqL1xuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgaW5zZXJ0KGluc3RhbmNlLCB0YWJsZU5hbWUsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy5oYXNUcmlnZ2VyO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuaW5zZXJ0UXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5JTlNFUlQ7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlKSByZXN1bHRzWzBdLmlzTmV3UmVjb3JkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcHNlcnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICB0YWJsZSB0byB1cHNlcnQgb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGluc2VydFZhbHVlcyB2YWx1ZXMgdG8gYmUgaW5zZXJ0ZWQsIG1hcHBlZCB0byBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVWYWx1ZXMgdmFsdWVzIHRvIGJlIHVwZGF0ZWQsIG1hcHBlZCB0byBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3aGVyZSAgICAgICAgd2hlcmUgY29uZGl0aW9ucywgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIFVQREFURSBwYXJ0IHdoZW4gSU5TRVJUIGZhaWxzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgcXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuLD9udW1iZXI+fSBSZXNvbHZlcyBhbiBhcnJheSB3aXRoIDxjcmVhdGVkLCBwcmltYXJ5S2V5PlxuICAgKi9cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKGl0ZW0gPT4gaXRlbS5maWVsZCk7XG4gICAgY29uc3QgdW5pcXVlS2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykuZmlsdGVyKGMgPT4gYy5maWVsZHMubGVuZ3RoID49IDEpLm1hcChjID0+IGMuZmllbGRzKTtcbiAgICBjb25zdCBpbmRleEtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLl9pbmRleGVzKS5maWx0ZXIoYyA9PiBjLnVuaXF1ZSAmJiBjLmZpZWxkcy5sZW5ndGggPj0gMSkubWFwKGMgPT4gYy5maWVsZHMpO1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gW107XG5cbiAgICAvLyBGb3IgZmllbGRzIGluIHVwZGF0ZVZhbHVlcywgdHJ5IHRvIGZpbmQgYSBjb25zdHJhaW50IG9yIHVuaXF1ZSBpbmRleFxuICAgIC8vIHRoYXQgaW5jbHVkZXMgZ2l2ZW4gZmllbGQuIE9ubHkgZmlyc3QgbWF0Y2hpbmcgdXBzZXJ0IGtleSBpcyB1c2VkLlxuICAgIGZvciAoY29uc3QgZmllbGQgb2Ygb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdW5pcXVlS2V5cy5maW5kKGZpZWxkcyA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gdW5pcXVlS2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXhLZXkgPSBpbmRleEtleXMuZmluZChmaWVsZHMgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICBpZiAoaW5kZXhLZXkpIHtcbiAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gaW5kZXhLZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsd2F5cyB1c2UgUEssIGlmIG5vIGNvbnN0cmFpbnQgYXZhaWxhYmxlIE9SIHVwZGF0ZSBkYXRhIGNvbnRhaW5zIFBLXG4gICAgaWYgKFxuICAgICAgb3B0aW9ucy51cHNlcnRLZXlzLmxlbmd0aCA9PT0gMFxuICAgICAgfHwgXy5pbnRlcnNlY3Rpb24ob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSwgcHJpbWFyeUtleXMpLmxlbmd0aFxuICAgICkge1xuICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gcHJpbWFyeUtleXM7XG4gICAgfVxuXG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gXy51bmlxKG9wdGlvbnMudXBzZXJ0S2V5cyk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCBtb2RlbC5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgbXVsdGlwbGUgcmVjb3JkcyBpbnRvIGEgdGFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcXVlcnlJbnRlcmZhY2UuYnVsa0luc2VydCgncm9sZXMnLCBbe1xuICAgKiAgICBsYWJlbDogJ3VzZXInLFxuICAgKiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAqICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgKiAgfSwge1xuICAgKiAgICBsYWJlbDogJ2FkbWluJyxcbiAgICogICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgKiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICogIH1dKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgIFRhYmxlIG5hbWUgdG8gaW5zZXJ0IHJlY29yZCB0b1xuICAgKiBAcGFyYW0ge0FycmF5fSAgcmVjb3JkcyAgICAgTGlzdCBvZiByZWNvcmRzIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgVmFyaW91cyBvcHRpb25zLCBwbGVhc2Ugc2VlIE1vZGVsLmJ1bGtDcmVhdGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAgVmFyaW91cyBhdHRyaWJ1dGVzIG1hcHBlZCBieSBmaWVsZCBuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYnVsa0luc2VydCh0YWJsZU5hbWUsIHJlY29yZHMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5JTlNFUlQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIHJlY29yZHMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZShpbnN0YW5jZSwgdGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy5oYXNUcmlnZ2VyO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllciwgb3B0aW9ucywgaW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcblxuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbXVsdGlwbGUgcmVjb3JkcyBvZiBhIHRhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUoJ3JvbGVzJywge1xuICAgKiAgICAgbGFiZWw6ICdhZG1pbicsXG4gICAqICAgfSwge1xuICAgKiAgICAgdXNlclR5cGU6IDMsXG4gICAqICAgfSxcbiAgICogKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgICAgVGFibGUgbmFtZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAgICAgICAgVmFsdWVzIHRvIGJlIGluc2VydGVkLCBtYXBwZWQgdG8gZmllbGQgbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gaWRlbnRpZmllciAgICBBIGhhc2ggd2l0aCBjb25kaXRpb25zIE9SIGFuIElEIGFzIGludGVnZXIgT1IgYSBzdHJpbmcgd2l0aCBjb25kaXRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgIFZhcmlvdXMgb3B0aW9ucywgcGxlYXNlIHNlZSBNb2RlbC5idWxrQ3JlYXRlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAgQXR0cmlidXRlcyBvbiByZXR1cm4gb2JqZWN0cyBpZiBzdXBwb3J0ZWQgYnkgU1FMIGRpYWxlY3RcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBidWxrVXBkYXRlKHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdvYmplY3QnKSBpZGVudGlmaWVyID0gVXRpbHMuY2xvbmVEZWVwKGlkZW50aWZpZXIpO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllciwgb3B0aW9ucywgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdGFibGUgPSBfLmlzT2JqZWN0KHRhYmxlTmFtZSkgPyB0YWJsZU5hbWUgOiB7IHRhYmxlTmFtZSB9O1xuICAgIGNvbnN0IG1vZGVsID0gXy5maW5kKHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5tb2RlbHMsIHsgdGFibGVOYW1lOiB0YWJsZS50YWJsZU5hbWUgfSk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlKGluc3RhbmNlLCB0YWJsZU5hbWUsIGlkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXNjYWRlcyA9IFtdO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVsZXRlUXVlcnkodGFibGVOYW1lLCBpZGVudGlmaWVyLCB7fSwgaW5zdGFuY2UuY29uc3RydWN0b3IpO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gQ2hlY2sgZm9yIGEgcmVzdHJpY3QgZmllbGRcbiAgICBpZiAoISFpbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiAhIWluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIGxldCBhc3NvY2lhdGlvbjtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NvY2lhdGlvbiA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9uc1trZXlzW2ldXTtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9uLm9wdGlvbnMgJiYgYXNzb2NpYXRpb24ub3B0aW9ucy5vbkRlbGV0ZSAmJlxuICAgICAgICAgIGFzc29jaWF0aW9uLm9wdGlvbnMub25EZWxldGUudG9Mb3dlckNhc2UoKSA9PT0gJ2Nhc2NhZGUnICYmXG4gICAgICAgICAgYXNzb2NpYXRpb24ub3B0aW9ucy51c2VIb29rcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNhc2NhZGVzLnB1c2goYXNzb2NpYXRpb24uYWNjZXNzb3JzLmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGNhc2NhZGUgb2YgY2FzY2FkZXMpIHtcbiAgICAgIGxldCBpbnN0YW5jZXMgPSBhd2FpdCBpbnN0YW5jZVtjYXNjYWRlXShvcHRpb25zKTtcbiAgICAgIC8vIENoZWNrIGZvciBoYXNPbmUgcmVsYXRpb25zaGlwIHdpdGggbm9uLWV4aXN0aW5nIGFzc29jaWF0ZSAoXCJoYXMgemVyb1wiKVxuICAgICAgaWYgKCFpbnN0YW5jZXMpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSBhd2FpdCBfaW5zdGFuY2UuZGVzdHJveShvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBtdWx0aXBsZSByZWNvcmRzIGZyb20gYSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHRhYmxlTmFtZSAgICAgICAgICAgIHRhYmxlIG5hbWUgZnJvbSB3aGVyZSB0byBkZWxldGUgcmVjb3Jkc1xuICAgKiBAcGFyYW0ge29iamVjdH0gIHdoZXJlICAgICAgICAgICAgICAgIHdoZXJlIGNvbmRpdGlvbnMgdG8gZmluZCByZWNvcmRzIHRvIGRlbGV0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXSAgICAgICAgICAgIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cnVuY2F0ZV0gICBVc2UgdHJ1bmNhdGUgdGFibGUgY29tbWFuZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhc2NhZGU9ZmFsc2VdICAgICAgICAgT25seSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggVFJVTkNBVEUuIFRydW5jYXRlcyAgYWxsIHRhYmxlcyB0aGF0IGhhdmUgZm9yZWlnbi1rZXkgcmVmZXJlbmNlcyB0byB0aGUgbmFtZWQgdGFibGUsIG9yIHRvIGFueSB0YWJsZXMgYWRkZWQgdG8gdGhlIGdyb3VwIGR1ZSB0byBDQVNDQURFLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3RhcnRJZGVudGl0eT1mYWxzZV0gT25seSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggVFJVTkNBVEUuIEF1dG9tYXRpY2FsbHkgcmVzdGFydCBzZXF1ZW5jZXMgb3duZWQgYnkgY29sdW1ucyBvZiB0aGUgdHJ1bmNhdGVkIHRhYmxlLlxuICAgKiBAcGFyYW0ge01vZGVsfSAgIFttb2RlbF0gICAgICAgICAgICAgIE1vZGVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYnVsa0RlbGV0ZSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywgeyBsaW1pdDogbnVsbCB9KTtcblxuICAgIGlmIChvcHRpb25zLnRydW5jYXRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IudHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnb2JqZWN0Jykgd2hlcmUgPSBVdGlscy5jbG9uZURlZXAod2hlcmUpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5kZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zLCBtb2RlbCksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdChtb2RlbCwgdGFibGVOYW1lLCBvcHRpb25zQXJnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4ub3B0aW9uc0FyZywgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QsIG1vZGVsIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgbW9kZWwpLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBhc3luYyBpbmNyZW1lbnQobW9kZWwsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFyaXRobWV0aWNRdWVyeSgnKycsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIGRlY3JlbWVudChtb2RlbCwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXJpdGhtZXRpY1F1ZXJ5KCctJywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgcmF3U2VsZWN0KHRhYmxlTmFtZSwgb3B0aW9ucywgYXR0cmlidXRlU2VsZWN0b3IsIE1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICBwbGFpbjogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUXG4gICAgfSk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgTW9kZWwpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZVNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgYW4gYXR0cmlidXRlIHNlbGVjdG9yIScpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5wbGFpbikge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YSA/IGRhdGFbYXR0cmlidXRlU2VsZWN0b3JdIDogbnVsbDtcblxuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5kYXRhVHlwZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhVHlwZSA9IG9wdGlvbnMuZGF0YVR5cGU7XG5cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREVDSU1BTCB8fCBkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5GTE9BVCkge1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSU5URUdFUiB8fCBkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CSUdJTlQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHQsIDEwKTtcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEUpIHtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgIShyZXN1bHQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVRyaWdnZXIoXG4gICAgdGFibGVOYW1lLFxuICAgIHRyaWdnZXJOYW1lLFxuICAgIHRpbWluZ1R5cGUsXG4gICAgZmlyZU9uQXJyYXksXG4gICAgZnVuY3Rpb25OYW1lLFxuICAgIGZ1bmN0aW9uUGFyYW1zLFxuICAgIG9wdGlvbnNBcnJheSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCB0aW1pbmdUeXBlLCBmaXJlT25BcnJheSwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgb3B0aW9uc0FycmF5KTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBTUUwgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcXVlcnlJbnRlcmZhY2UuY3JlYXRlRnVuY3Rpb24oXG4gICAqICAgJ3NvbWVGdW5jdGlvbicsXG4gICAqICAgW1xuICAgKiAgICAge3R5cGU6ICdpbnRlZ2VyJywgbmFtZTogJ3BhcmFtJywgZGlyZWN0aW9uOiAnSU4nfVxuICAgKiAgIF0sXG4gICAqICAgJ2ludGVnZXInLFxuICAgKiAgICdwbHBnc3FsJyxcbiAgICogICAnUkVUVVJOIHBhcmFtICsgMTsnLFxuICAgKiAgIFtcbiAgICogICAgICdJTU1VVEFCTEUnLFxuICAgKiAgICAgJ0xFQUtQUk9PRidcbiAgICogICBdLFxuICAgKiAgIHtcbiAgICogICAgdmFyaWFibGVzOlxuICAgKiAgICAgIFtcbiAgICogICAgICAgIHt0eXBlOiAnaW50ZWdlcicsIG5hbWU6ICdteVZhcicsIGRlZmF1bHQ6IDEwMH1cbiAgICogICAgICBdLFxuICAgKiAgICAgIGZvcmNlOiB0cnVlXG4gICAqICAgfTtcbiAgICogKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBmdW5jdGlvbk5hbWUgIE5hbWUgb2YgU1FMIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhcmFtcyAgICAgICAgTGlzdCBvZiBwYXJhbWV0ZXJzIGRlY2xhcmVkIGZvciBTUUwgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9ICByZXR1cm5UeXBlICAgIFNRTCB0eXBlIG9mIGZ1bmN0aW9uIHJldHVybmVkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgbGFuZ3VhZ2UgICAgICBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGUgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgaW5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICBib2R5ICAgICAgICAgIFNvdXJjZSBjb2RlIG9mIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgb3B0aW9uc0FycmF5ICBFeHRyYS1vcHRpb25zIGZvciBjcmVhdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXSAgICAgcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZm9yY2UgSWYgZm9yY2UgaXMgdHJ1ZSwgYW55IGV4aXN0aW5nIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgd2lsbCBiZSByZXBsYWNlZC4gRm9yIHBvc3RncmVzLCB0aGlzIG1lYW5zIHVzaW5nIGBDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTmAgaW5zdGVhZCBvZiBgQ1JFQVRFIEZVTkNUSU9OYC4gRGVmYXVsdCBpcyBmYWxzZVxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59ICAgb3B0aW9ucy52YXJpYWJsZXMgTGlzdCBvZiBkZWNsYXJlZCB2YXJpYWJsZXMuIEVhY2ggdmFyaWFibGUgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIHN0cmluZyBmaWVsZHMgYHR5cGVgIGFuZCBgbmFtZWAsIGFuZCBvcHRpb25hbGx5IGhhdmluZyBhIGBkZWZhdWx0YCBmaWVsZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbiBTUUwgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcXVlcnlJbnRlcmZhY2UuZHJvcEZ1bmN0aW9uKFxuICAgKiAgICdzb21lRnVuY3Rpb24nLFxuICAgKiAgIFtcbiAgICogICAgIHt0eXBlOiAndmFyY2hhcicsIG5hbWU6ICdwYXJhbTEnLCBkaXJlY3Rpb246ICdJTid9LFxuICAgKiAgICAge3R5cGU6ICdpbnRlZ2VyJywgbmFtZTogJ3BhcmFtMicsIGRpcmVjdGlvbjogJ0lOT1VUJ31cbiAgICogICBdXG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbk5hbWUgTmFtZSBvZiBTUUwgZnVuY3Rpb24gdG8gZHJvcFxuICAgKiBAcGFyYW0ge0FycmF5fSAgcGFyYW1zICAgICAgIExpc3Qgb2YgcGFyYW1ldGVycyBkZWNsYXJlZCBmb3IgU1FMIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gICAgcXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgYW4gU1FMIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHF1ZXJ5SW50ZXJmYWNlLnJlbmFtZUZ1bmN0aW9uKFxuICAgKiAgICdmb29GdW5jdGlvbicsXG4gICAqICAgW1xuICAgKiAgICAge3R5cGU6ICd2YXJjaGFyJywgbmFtZTogJ3BhcmFtMScsIGRpcmVjdGlvbjogJ0lOJ30sXG4gICAqICAgICB7dHlwZTogJ2ludGVnZXInLCBuYW1lOiAncGFyYW0yJywgZGlyZWN0aW9uOiAnSU5PVVQnfVxuICAgKiAgIF0sXG4gICAqICAgJ2JhckZ1bmN0aW9uJ1xuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkRnVuY3Rpb25OYW1lICBDdXJyZW50IG5hbWUgb2YgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gIHBhcmFtcyAgICAgICAgICAgTGlzdCBvZiBwYXJhbWV0ZXJzIGRlY2xhcmVkIGZvciBTUUwgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0Z1bmN0aW9uTmFtZSAgTmV3IG5hbWUgb2YgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICAgICAgcXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHMgdXNlZnVsIGZvciBxdWVyeWluZ1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5zdXJlRW51bXMoKSB7XG4gICAgLy8gbm9vcCBieSBkZWZhdWx0XG4gIH1cblxuICBhc3luYyBzZXRJc29sYXRpb25MZXZlbCh0cmFuc2FjdGlvbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBpc29sYXRpb24gbGV2ZWwgZm9yIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhJyk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCB8fCAhdmFsdWUpIHtcbiAgICAgIC8vIE5vdCBwb3NzaWJsZSB0byBzZXQgYSBzZXBhcmF0ZSBpc29sYXRpb24gbGV2ZWwgZm9yIHNhdmVwb2ludHNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH07XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIHtcbiAgICAgIHBhcmVudDogdHJhbnNhY3Rpb24ucGFyZW50XG4gICAgfSk7XG5cbiAgICBpZiAoIXNxbCkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBzdGFydFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzdGFydCBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IScpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfTtcbiAgICBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUgPSB0cmFuc2FjdGlvbi5wYXJlbnQgPyB0cmFuc2FjdGlvbi5uYW1lIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgZGVmZXJDb25zdHJhaW50cyh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpO1xuXG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY29tbWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbW1pdCBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IScpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICAvLyBTYXZlcG9pbnRzIGNhbm5vdCBiZSBjb21taXR0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24sXG4gICAgICBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlLFxuICAgICAgY29tcGxldGVzVHJhbnNhY3Rpb246IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcblxuICAgIHRyYW5zYWN0aW9uLmZpbmlzaGVkID0gJ2NvbW1pdCc7XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxuXG4gIGFzeW5jIHJvbGxiYWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJvbGxiYWNrIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uLFxuICAgICAgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlc1RyYW5zYWN0aW9uOiB0cnVlXG4gICAgfTtcbiAgICBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUgPSB0cmFuc2FjdGlvbi5wYXJlbnQgPyB0cmFuc2FjdGlvbi5uYW1lIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iucm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcblxuICAgIHRyYW5zYWN0aW9uLmZpbmlzaGVkID0gJ3JvbGxiYWNrJztcblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG59XG5cbmV4cG9ydHMuUXVlcnlJbnRlcmZhY2UgPSBRdWVyeUludGVyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vc3FsLXN0cmluZycpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBEb3QgPSByZXF1aXJlKCdkb3R0aWUnKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2RlcHJlY2F0aW9ucycpO1xuY29uc3QgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKS52NDtcblxuY2xhc3MgQWJzdHJhY3RRdWVyeSB7XG5cbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy51dWlkID0gdXVpZCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5pbnN0YW5jZSA9IG9wdGlvbnMuaW5zdGFuY2U7XG4gICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgcGxhaW46IGZhbHNlLFxuICAgICAgcmF3OiBmYWxzZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBsb2dnaW5nOiBjb25zb2xlLmxvZyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuY2hlY2tMb2dnaW5nT3B0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogcmV3cml0ZSBxdWVyeSB3aXRoIHBhcmFtZXRlcnNcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgcXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoJ3NlbGVjdCAkMSBhcyBmb28nLCBbJ2Zvb3ZhbCddKTtcbiAgICpcbiAgICogICBxdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycygnc2VsZWN0ICRmb28gYXMgZm9vJywgeyBmb286ICdmb292YWwnIH0pO1xuICAgKlxuICAgKiBPcHRpb25zXG4gICAqICAgc2tpcFVuZXNjYXBlOiBib29sLCBza2lwIHVuZXNjYXBpbmcgJCRcbiAgICogICBza2lwVmFsdWVSZXBsYWNlOiBib29sLCBkbyBub3QgcmVwbGFjZSAoYnV0IGRvIHVuZXNjYXBlICQkKS4gQ2hlY2sgY29ycmVjdCBzeW50YXggYW5kIGlmIGFsbCB2YWx1ZXMgYXJlIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSB2YWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWxlY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlcGxhY2VtZW50RnVuY11cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgcmV0dXJuIFtzcWwsIFtdXTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50RnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucyA9IHJlcGxhY2VtZW50RnVuYyB8fCB7fTtcbiAgICAgIHJlcGxhY2VtZW50RnVuYyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIXJlcGxhY2VtZW50RnVuYykge1xuICAgICAgaWYgKG9wdGlvbnMuc2tpcFZhbHVlUmVwbGFjZSkge1xuICAgICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTcWxTdHJpbmcuZXNjYXBlKHZhbHVlc1trZXldLCB0aW1lWm9uZSwgZGlhbGVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNraXBWYWx1ZVJlcGxhY2UpIHtcbiAgICAgIGNvbnN0IG9yaWdSZXBsYWNlbWVudEZ1bmMgPSByZXBsYWNlbWVudEZ1bmM7XG4gICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAob3JpZ1JlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpO1xuICAgIHNxbCA9IHNxbC5yZXBsYWNlKC9cXEJcXCQoXFwkfFxcdyspL2csIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICBpZiAoJyQnID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2tpcFVuZXNjYXBlID8gbWF0Y2ggOiBrZXk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXBsVmFsO1xuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgaWYgKGtleS5tYXRjaCgvXlsxLTldXFxkKiQvKSkge1xuICAgICAgICAgIGtleSA9IGtleSAtIDE7XG4gICAgICAgICAgcmVwbFZhbCA9IHJlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgha2V5Lm1hdGNoKC9eXFxkKiQvKSkge1xuICAgICAgICByZXBsVmFsID0gcmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVkIGJpbmQgcGFyYW1ldGVyIFwiJHttYXRjaH1cIiBoYXMgbm8gdmFsdWUgaW4gdGhlIGdpdmVuIG9iamVjdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBsVmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3FsLCBbXV07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgcGFzc2VkIHNxbCBxdWVyeS5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBxdWVyeS5ydW4oJ1NFTEVDVCAxJylcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ1bigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBydW4gbWV0aG9kIHdhc25cXCd0IG92ZXJ3cml0dGVuIScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBsb2dnaW5nIG9wdGlvbiBvZiB0aGUgaW5zdGFuY2UgYW5kIHByaW50IGRlcHJlY2F0aW9uIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tMb2dnaW5nT3B0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLm9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gaW5zZXJ0IHF1ZXJ5LCB3aGljaCBjb250YWlucyB0aGUganVzdCBpbnNlcnRlZCBpZC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZpZWxkIG5hbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiAnaW5zZXJ0SWQnO1xuICB9XG5cbiAgZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCkge1xuICAgIGxldCBtZXNzYWdlID0gZmllbGQgPyBgJHtmaWVsZH0gbXVzdCBiZSB1bmlxdWVgIDogJ011c3QgYmUgdW5pcXVlJztcblxuICAgIGlmIChmaWVsZCAmJiB0aGlzLm1vZGVsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5maWVsZHMuaW5jbHVkZXMoZmllbGQucmVwbGFjZSgvXCIvZywgJycpKSkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5tc2cpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5tc2c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgaXNSYXdRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuUkFXO1xuICB9XG5cbiAgaXNWZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlZFUlNJT047XG4gIH1cblxuICBpc1Vwc2VydFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gIH1cblxuICBpc0luc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuSU5TRVJUKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpcyBpbnNlcnQgcXVlcnkgaWYgc3FsIGNvbnRhaW5zIGluc2VydCBpbnRvXG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnaW5zZXJ0IGludG8nKTtcblxuICAgIC8vIGlzIGluc2VydCBxdWVyeSBpZiBubyByZXN1bHRzIGFyZSBwYXNzZWQgb3IgaWYgdGhlIHJlc3VsdCBoYXMgdGhlIGluc2VydGVkIGlkXG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmICghcmVzdWx0cyB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywgdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCkpKTtcblxuICAgIC8vIGlzIGluc2VydCBxdWVyeSBpZiBubyBtZXRhZGF0YSBhcmUgcGFzc2VkIG9yIGlmIHRoZSBtZXRhZGF0YSBoYXMgdGhlIGluc2VydGVkIGlkXG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmICghbWV0YURhdGEgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFEYXRhLCB0aGlzLmdldEluc2VydElkRmllbGQoKSkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIC8vIGFkZCB0aGUgaW5zZXJ0ZWQgcm93IGlkIHRvIHRoZSBpbnN0YW5jZVxuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBpZCA9IG51bGw7XG5cbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuXG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdID0gaWQ7XG4gICAgfVxuICB9XG5cbiAgaXNTaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dUQUJMRVM7XG4gIH1cblxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiBfLmZsYXR0ZW4ocmVzdWx0cy5tYXAocmVzdWx0U2V0ID0+IE9iamVjdC52YWx1ZXMocmVzdWx0U2V0KSkpO1xuICB9XG5cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XSU5ERVhFUztcbiAgfVxuXG4gIGlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UUztcbiAgfVxuXG4gIGlzRGVzY3JpYmVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuREVTQ1JJQkU7XG4gIH1cblxuICBpc1NlbGVjdFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TRUxFQ1Q7XG4gIH1cblxuICBpc0J1bGtVcGRhdGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgfVxuXG4gIGlzQnVsa0RlbGV0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLREVMRVRFO1xuICB9XG5cbiAgaXNGb3JlaWduS2V5c1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5GT1JFSUdOS0VZUztcbiAgfVxuXG4gIGlzVXBkYXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlVQREFURTtcbiAgfVxuXG4gIGhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgIC8vIE1hcCByYXcgZmllbGRzIHRvIG5hbWVzIGlmIGEgbWFwcGluZyBpcyBwcm92aWRlZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmllbGRNYXApIHtcbiAgICAgIGNvbnN0IGZpZWxkTWFwID0gdGhpcy5vcHRpb25zLmZpZWxkTWFwO1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKHJlc3VsdCA9PiBfLnJlZHVjZShmaWVsZE1hcCwgKHJlc3VsdCwgbmFtZSwgZmllbGQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdFtmaWVsZF0gIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSBmaWVsZCkge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHJlc3VsdFtmaWVsZF07XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIFJhdyBxdWVyaWVzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYXcpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHMubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIGxldCBvID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmVzdCkge1xuICAgICAgICAgIG8gPSBEb3QudHJhbnNmb3JtKG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9KTtcbiAgICAvLyBRdWVyaWVzIHdpdGggaW5jbHVkZVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhhc0pvaW4gPT09IHRydWUpIHtcbiAgICAgIHJlc3VsdHMgPSBBYnN0cmFjdFF1ZXJ5Ll9ncm91cEpvaW5EYXRhKHJlc3VsdHMsIHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGluY2x1ZGVNYXA6IHRoaXMub3B0aW9ucy5pbmNsdWRlTWFwLFxuICAgICAgICBpbmNsdWRlTmFtZXM6IHRoaXMub3B0aW9ucy5pbmNsdWRlTmFtZXNcbiAgICAgIH0sIHtcbiAgICAgICAgY2hlY2tFeGlzdGluZzogdGhpcy5vcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSB0aGlzLm1vZGVsLmJ1bGtCdWlsZChyZXN1bHRzLCB7XG4gICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZTogdGhpcy5vcHRpb25zLmluY2x1ZGUsXG4gICAgICAgIGluY2x1ZGVOYW1lczogdGhpcy5vcHRpb25zLmluY2x1ZGVOYW1lcyxcbiAgICAgICAgaW5jbHVkZU1hcDogdGhpcy5vcHRpb25zLmluY2x1ZGVNYXAsXG4gICAgICAgIGluY2x1ZGVWYWxpZGF0ZWQ6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgfHwgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgIHJhdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgLy8gUmVndWxhciBxdWVyaWVzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwuYnVsa0J1aWxkKHJlc3VsdHMsIHtcbiAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlLFxuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgfHwgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgZmlyc3QgcmVhbCBtb2RlbCBpbnN0YW5jZSBpZiBvcHRpb25zLnBsYWluIGlzIHNldCAoZS5nLiBNb2RlbC5maW5kKVxuICAgIGlmICh0aGlzLm9wdGlvbnMucGxhaW4pIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzdWx0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Nob3cnKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdkZXNjcmliZScpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlzQ2FsbFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NhbGwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRlYnVnQ29udGV4dFxuICAgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gcGFyYW1ldGVyc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHRoZSBxdWVyeSB3YXMgY29tcGxldGVkLlxuICAgKi9cbiAgX2xvZ1F1ZXJ5KHNxbCwgZGVidWdDb250ZXh0LCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJlbmNobWFyayA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuYmVuY2htYXJrIHx8IG9wdGlvbnMuYmVuY2htYXJrO1xuICAgIGNvbnN0IGxvZ1F1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubG9nUXVlcnlQYXJhbWV0ZXJzIHx8IG9wdGlvbnMubG9nUXVlcnlQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGxvZ1BhcmFtZXRlciA9ICcnO1xuXG4gICAgaWYgKGxvZ1F1ZXJ5UGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBzcWwuZW5kc1dpdGgoJzsnKSA/ICcnIDogJzsnO1xuICAgICAgbGV0IHBhcmFtU3RyO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgcGFyYW1TdHIgPSBwYXJhbWV0ZXJzLm1hcChwPT5KU09OLnN0cmluZ2lmeShwKSkuam9pbignLCAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtU3RyID0gSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgICBsb2dQYXJhbWV0ZXIgPSBgJHtkZWxpbWl0ZXJ9ICR7cGFyYW1TdHJ9YDtcbiAgICB9XG4gICAgY29uc3QgZm10ID0gYCgke2Nvbm5lY3Rpb24udXVpZCB8fCAnZGVmYXVsdCd9KTogJHtzcWx9JHtsb2dQYXJhbWV0ZXJ9YDtcbiAgICBjb25zdCBtc2cgPSBgRXhlY3V0aW5nICR7Zm10fWA7XG4gICAgZGVidWdDb250ZXh0KG1zZyk7XG4gICAgaWYgKCFiZW5jaG1hcmspIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgRXhlY3V0aW5nICR7Zm10fWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJNc2cgPSBgRXhlY3V0ZWQgJHtmbXR9YDtcbiAgICAgIGRlYnVnQ29udGV4dChhZnRlck1zZyk7XG4gICAgICBpZiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhhZnRlck1zZywgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGFrZXMgdGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgZXhlY3V0aW9uIGFuZCBncm91cHNcbiAgICogdGhlIGFzc29jaWF0ZWQgZGF0YSBieSB0aGUgY2FsbGVlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgIGdyb3VwSm9pbkRhdGEoW1xuICAgKiAgICAge1xuICAgKiAgICAgICBzb21lOiAnZGF0YScsXG4gICAqICAgICAgIGlkOiAxLFxuICAgKiAgICAgICBhc3NvY2lhdGlvbjogeyBmb286ICdiYXInLCBpZDogMSB9XG4gICAqICAgICB9LCB7XG4gICAqICAgICAgIHNvbWU6ICdkYXRhJyxcbiAgICogICAgICAgaWQ6IDEsXG4gICAqICAgICAgIGFzc29jaWF0aW9uOiB7IGZvbzogJ2JhcicsIGlkOiAyIH1cbiAgICogICAgIH0sIHtcbiAgICogICAgICAgc29tZTogJ2RhdGEnLFxuICAgKiAgICAgICBpZDogMSxcbiAgICogICAgICAgYXNzb2NpYXRpb246IHsgZm9vOiAnYmFyJywgaWQ6IDMgfVxuICAgKiAgICAgfVxuICAgKiAgIF0pXG4gICAqXG4gICAqIFJlc3VsdDpcbiAgICogICBTb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgKlxuICAgKiAgIFtcbiAgICogICAgIHtcbiAgICogICAgICAgc29tZTogJ2RhdGEnLFxuICAgKiAgICAgICBpZDogMSxcbiAgICogICAgICAgYXNzb2NpYXRpb246IFtcbiAgICogICAgICAgICB7IGZvbzogJ2JhcicsIGlkOiAxIH0sXG4gICAqICAgICAgICAgeyBmb286ICdiYXInLCBpZDogMiB9LFxuICAgKiAgICAgICAgIHsgZm9vOiAnYmFyJywgaWQ6IDMgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9XG4gICAqICAgXVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByb3dzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNsdWRlT3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9ncm91cEpvaW5EYXRhKHJvd3MsIGluY2x1ZGVPcHRpb25zLCBvcHRpb25zKSB7XG5cbiAgICAvKlxuICAgICAqIEFzc3VtcHRpb25zXG4gICAgICogSUQgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBmaXJzdCBmaWVsZFxuICAgICAqIEFsbCBmaWVsZHMgZm9yIGEgbGV2ZWwgaXMgZ3JvdXBlZCBpbiB0aGUgc2FtZSBzZXQgKGkuZS4gUGFuZWwuaWQsIFRhc2suaWQsIFBhbmVsLnRpdGxlIGlzIG5vdCBwb3NzaWJsZSlcbiAgICAgKiBQYXJlbnQga2V5cyB3aWxsIGJlIHNlZW4gYmVmb3JlIGFueSBpbmNsdWRlL2NoaWxkIGtleXNcbiAgICAgKiBQcmV2aW91cyBzZXQgd29uJ3QgbmVjZXNzYXJpbHkgYmUgcGFyZW50IHNldCAob25lIHBhcmVudCBjb3VsZCBoYXZlIHR3byBjaGlsZHJlbiwgb25lIGNoaWxkIHdvdWxkIHRoZW4gYmUgcHJldmlvdXMgc2V0IGZvciB0aGUgb3RoZXIpXG4gICAgICovXG5cbiAgICAvKlxuICAgICAqIEF1dGhvciAoTUgpIGNvbW1lbnQ6IFRoaXMgY29kZSBpcyBhbiB1bnJlYWRhYmxlIG1lc3MsIGJ1dCBpdCdzIHBlcmZvcm1hbnQuXG4gICAgICogZ3JvdXBKb2luRGF0YSBpcyBhIHBlcmZvcm1hbmNlIGNyaXRpY2FsIGZ1bmN0aW9uIHNvIHdlIHByaW9yaXRpemUgcGVyZiBvdmVyIHJlYWRhYmlsaXR5LlxuICAgICAqL1xuICAgIGlmICghcm93cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmljIGxvb3BpbmdcbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuZ3RoO1xuICAgIGxldCAkaTtcbiAgICBsZXQgJGxlbmd0aDtcbiAgICAvLyBSb3cgc3BlY2lmaWMgbG9vcGluZ1xuICAgIGxldCByb3dzSTtcbiAgICBsZXQgcm93O1xuICAgIGNvbnN0IHJvd3NMZW5ndGggPSByb3dzLmxlbmd0aDtcbiAgICAvLyBLZXkgc3BlY2lmaWMgbG9vcGluZ1xuICAgIGxldCBrZXlzO1xuICAgIGxldCBrZXk7XG4gICAgbGV0IGtleUk7XG4gICAgbGV0IGtleUxlbmd0aDtcbiAgICBsZXQgcHJldktleTtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCB0b3BWYWx1ZXM7XG4gICAgbGV0IHRvcEV4aXN0cztcbiAgICBjb25zdCBjaGVja0V4aXN0aW5nID0gb3B0aW9ucy5jaGVja0V4aXN0aW5nO1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgdG8gZGVkdXBsaWNhdGUgd2UgY2FuIHByZS1hbGxvY2F0ZSB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgbGV0IGl0ZW1IYXNoO1xuICAgIGxldCBwYXJlbnRIYXNoO1xuICAgIGxldCB0b3BIYXNoO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBjaGVja0V4aXN0aW5nID8gW10gOiBuZXcgQXJyYXkocm93c0xlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgaW5jbHVkZU1hcCA9IHt9O1xuICAgIC8vIFJlc3VsdCB2YXJpYWJsZXMgZm9yIHRoZSByZXNwZWN0aXZlIGZ1bmN0aW9uc1xuICAgIGxldCAka2V5UHJlZml4O1xuICAgIGxldCAka2V5UHJlZml4U3RyaW5nO1xuICAgIGxldCAkcHJldktleVByZWZpeFN0cmluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGxldCAkcHJldktleVByZWZpeDtcbiAgICBsZXQgJGxhc3RLZXlQcmVmaXg7XG4gICAgbGV0ICRjdXJyZW50O1xuICAgIGxldCAkcGFyZW50O1xuICAgIC8vIE1hcCBlYWNoIGtleSB0byBhbiBpbmNsdWRlIG9wdGlvblxuICAgIGxldCBwcmV2aW91c1BpZWNlO1xuICAgIGNvbnN0IGJ1aWxkSW5jbHVkZU1hcCA9IHBpZWNlID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJGN1cnJlbnQuaW5jbHVkZU1hcCwgcGllY2UpKSB7XG4gICAgICAgIGluY2x1ZGVNYXBba2V5XSA9ICRjdXJyZW50ID0gJGN1cnJlbnQuaW5jbHVkZU1hcFtwaWVjZV07XG4gICAgICAgIGlmIChwcmV2aW91c1BpZWNlKSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZSA9IGAke3ByZXZpb3VzUGllY2V9LiR7cGllY2V9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c1BpZWNlID0gcGllY2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVkZU1hcFtwcmV2aW91c1BpZWNlXSA9ICRjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdHJpbmcgcHJlZml4IG9mIGEga2V5ICgnVXNlci5SZXN1bHRzJyBmb3IgJ1VzZXIuUmVzdWx0cy5pZCcpXG4gICAgY29uc3Qga2V5UHJlZml4U3RyaW5nTWVtbyA9IHt9O1xuICAgIGNvbnN0IGtleVByZWZpeFN0cmluZyA9IChrZXksIG1lbW8pID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW8sIGtleSkpIHtcbiAgICAgICAgbWVtb1trZXldID0ga2V5LnN1YnN0cigwLCBrZXkubGFzdEluZGV4T2YoJy4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtb1trZXldO1xuICAgIH07XG4gICAgLy8gUmVtb3ZlcyB0aGUgcHJlZml4IGZyb20gYSBrZXkgKCdpZCcgZm9yICdVc2VyLlJlc3VsdHMuaWQnKVxuICAgIGNvbnN0IHJlbW92ZUtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCByZW1vdmVLZXlQcmVmaXggPSBrZXkgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVtb3ZlS2V5UHJlZml4TWVtbywga2V5KSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGtleS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICByZW1vdmVLZXlQcmVmaXhNZW1vW2tleV0gPSBrZXkuc3Vic3RyKGluZGV4ID09PSAtMSA/IDAgOiBpbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZUtleVByZWZpeE1lbW9ba2V5XTtcbiAgICB9O1xuICAgIC8vIENhbGN1bGF0ZXMgdGhlIGFycmF5IHByZWZpeCBvZiBhIGtleSAoWydVc2VyJywgJ1Jlc3VsdHMnXSBmb3IgJ1VzZXIuUmVzdWx0cy5pZCcpXG4gICAgY29uc3Qga2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IGtleVByZWZpeCA9IGtleSA9PiB7XG4gICAgICAvLyBXZSB1c2UgYSBkb3VibGUgbWVtbyBhbmQga2V5UHJlZml4U3RyaW5nIHNvIHRoYXQgZGlmZmVyZW50IGtleXMgd2l0aCB0aGUgc2FtZSBwcmVmaXggd2lsbCByZWNlaXZlIHRoZSBzYW1lIGFycmF5IGluc3RlYWQgb2YgZGlmZmVybmV0IGFycmF5cyB3aXRoIGVxdWFsIHZhbHVlc1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa2V5UHJlZml4TWVtbywga2V5KSkge1xuICAgICAgICBjb25zdCBwcmVmaXhTdHJpbmcgPSBrZXlQcmVmaXhTdHJpbmcoa2V5LCBrZXlQcmVmaXhTdHJpbmdNZW1vKTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa2V5UHJlZml4TWVtbywgcHJlZml4U3RyaW5nKSkge1xuICAgICAgICAgIGtleVByZWZpeE1lbW9bcHJlZml4U3RyaW5nXSA9IHByZWZpeFN0cmluZyA/IHByZWZpeFN0cmluZy5zcGxpdCgnLicpIDogW107XG4gICAgICAgIH1cbiAgICAgICAga2V5UHJlZml4TWVtb1trZXldID0ga2V5UHJlZml4TWVtb1twcmVmaXhTdHJpbmddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleVByZWZpeE1lbW9ba2V5XTtcbiAgICB9O1xuICAgIC8vIENhbGN1YXRlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGFycmF5IHByZWZpeCAoJ1Jlc3VsdHMnIGZvciAnVXNlci5SZXN1bHRzLmlkJylcbiAgICBjb25zdCBsYXN0S2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IGxhc3RLZXlQcmVmaXggPSBrZXkgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdEtleVByZWZpeE1lbW8sIGtleSkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0ga2V5UHJlZml4KGtleSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHByZWZpeC5sZW5ndGg7XG5cbiAgICAgICAgbGFzdEtleVByZWZpeE1lbW9ba2V5XSA9ICFsZW5ndGggPyAnJyA6IHByZWZpeFtsZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0S2V5UHJlZml4TWVtb1trZXldO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyA9IG1vZGVsID0+IHtcbiAgICAgIGxldCB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gXy5jaGFpbihtb2RlbC51bmlxdWVLZXlzKTtcbiAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSB1bmlxdWVLZXlBdHRyaWJ1dGVzXG4gICAgICAgIC5yZXN1bHQoYCR7dW5pcXVlS2V5QXR0cmlidXRlcy5maW5kS2V5KCl9LmZpZWxkc2ApXG4gICAgICAgIC5tYXAoZmllbGQgPT4gXy5maW5kS2V5KG1vZGVsLmF0dHJpYnV0ZXMsIGNociA9PiBjaHIuZmllbGQgPT09IGZpZWxkKSlcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICAgIHJldHVybiB1bmlxdWVLZXlBdHRyaWJ1dGVzO1xuICAgIH07XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gb2JqID0+IG9iaiBpbnN0YW5jZW9mIEJ1ZmZlciA/IG9iai50b1N0cmluZygnaGV4JykgOiBvYmo7XG4gICAgbGV0IHByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgIGxldCB1bmlxdWVLZXlBdHRyaWJ1dGVzO1xuICAgIGxldCBwcmVmaXg7XG5cbiAgICBmb3IgKHJvd3NJID0gMDsgcm93c0kgPCByb3dzTGVuZ3RoOyByb3dzSSsrKSB7XG4gICAgICByb3cgPSByb3dzW3Jvd3NJXTtcblxuICAgICAgLy8gS2V5cyBhcmUgdGhlIHNhbWUgZm9yIGFsbCByb3dzLCBzbyBvbmx5IG5lZWQgdG8gY29tcHV0ZSB0aGVtIG9uIHRoZSBmaXJzdCByb3dcbiAgICAgIGlmIChyb3dzSSA9PT0gMCkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMocm93KTtcbiAgICAgICAga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgIHRvcEV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdG9wIGxldmVsIGhhc2gga2V5ICh0aGlzIGlzIHVzdWFsbHkganVzdCB0aGUgcHJpbWFyeSBrZXkgdmFsdWVzKVxuICAgICAgICAkbGVuZ3RoID0gaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICB0b3BIYXNoID0gJyc7XG4gICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdG9wSGFzaCA9IHN0cmluZ2lmeShyb3dbaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXNbMF1dKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgIHRvcEhhc2ggKz0gc3RyaW5naWZ5KHJvd1tpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlc1skaV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlT3B0aW9ucy5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVPcHRpb25zLm1vZGVsKTtcbiAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgdG9wSGFzaCArPSByb3dbdW5pcXVlS2V5QXR0cmlidXRlc1skaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b3BWYWx1ZXMgPSB2YWx1ZXMgPSB7fTtcbiAgICAgICRwcmV2S2V5UHJlZml4ID0gdW5kZWZpbmVkO1xuICAgICAgZm9yIChrZXlJID0gMDsga2V5SSA8IGtleUxlbmd0aDsga2V5SSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNba2V5SV07XG5cbiAgICAgICAgLy8gVGhlIHN0cmluZyBwcmVmaXggaXNuJ3QgYWN0dWFseSBuZWVkZWRcbiAgICAgICAgLy8gV2UgdXNlIGl0IHNvIGtleVByZWZpeCBmb3IgZGlmZmVyZW50IGtleXMgd2lsbCByZXNvbHZlIHRvIHRoZSBzYW1lIGFycmF5IGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBwcmVmaXhcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXk/XG4gICAgICAgICRrZXlQcmVmaXhTdHJpbmcgPSBrZXlQcmVmaXhTdHJpbmcoa2V5LCBrZXlQcmVmaXhTdHJpbmdNZW1vKTtcbiAgICAgICAgJGtleVByZWZpeCA9IGtleVByZWZpeChrZXkpO1xuXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCByb3cgd2UgY29tcHV0ZSB0aGUgaW5jbHVkZU1hcFxuICAgICAgICBpZiAocm93c0kgPT09IDAgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNsdWRlTWFwLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCEka2V5UHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaW5jbHVkZU1hcFtrZXldID0gaW5jbHVkZU1hcFsnJ10gPSBpbmNsdWRlT3B0aW9ucztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGN1cnJlbnQgPSBpbmNsdWRlT3B0aW9ucztcbiAgICAgICAgICAgIHByZXZpb3VzUGllY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAka2V5UHJlZml4LmZvckVhY2goYnVpbGRJbmNsdWRlTWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIG9mIGtleSBzZXRcbiAgICAgICAgaWYgKCRwcmV2S2V5UHJlZml4ICE9PSB1bmRlZmluZWQgJiYgJHByZXZLZXlQcmVmaXggIT09ICRrZXlQcmVmaXgpIHtcbiAgICAgICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBoYXNoIGtleSBmb3IgdGhpcyBzZXQgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIFRPRE86IE9wdGltaXplXG4gICAgICAgICAgICBsZW5ndGggPSAkcHJldktleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICAgICAkcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHBhcmVudEhhc2ggPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICRwYXJlbnQgPyBgJHskcGFyZW50fS4keyRwcmV2S2V5UHJlZml4W2ldfWAgOiAkcHJldktleVByZWZpeFtpXTtcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5QXR0cmlidXRlcyA9IGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAkbGVuZ3RoID0gcHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1swXX1gXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCRsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXX1gXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gcm93W2Ake3ByZWZpeH0uJHt1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXX1gXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRIYXNoKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtSGFzaCA9IHBhcmVudEhhc2ggKyBpdGVtSGFzaDtcbiAgICAgICAgICAgICAgICAkcGFyZW50ID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IGl0ZW1IYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbUhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbUhhc2ggPT09IHRvcEhhc2gpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICAgICRwYXJlbnQgPSByZXN1bHRNYXBbcGFyZW50SGFzaF07XG4gICAgICAgICAgICAgICRsYXN0S2V5UHJlZml4ID0gbGFzdEtleVByZWZpeChwcmV2S2V5KTtcblxuICAgICAgICAgICAgICBpZiAoaW5jbHVkZU1hcFtwcmV2S2V5XS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkcGFyZW50WyRsYXN0S2V5UHJlZml4XSkge1xuICAgICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0ucHVzaChyZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCB2YWx1ZXNcbiAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGVja0V4aXN0aW5nIGlzIGZhbHNlIGl0J3MgYmVjYXVzZSB0aGVyZSdzIG9ubHkgMToxIGFzc29jaWF0aW9ucyBpbiB0aGlzIHF1ZXJ5XG4gICAgICAgICAgICAvLyBIb3dldmVyIHdlIHN0aWxsIG5lZWQgdG8gbWFwIG9udG8gdGhlIGFwcHJvcHJpYXRlIHBhcmVudFxuICAgICAgICAgICAgLy8gRm9yIDE6MSB3ZSBtYXAgZm9yd2FyZCwgaW5pdGlhbGl6aW5nIHRoZSB2YWx1ZSBvYmplY3Qgb24gdGhlIHBhcmVudCB0byBiZSBmaWxsZWQgaW4gdGhlIG5leHQgaXRlcmF0aW9ucyBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgJGN1cnJlbnQgPSB0b3BWYWx1ZXM7XG4gICAgICAgICAgICBsZW5ndGggPSAka2V5UHJlZml4Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlcyA9ICRjdXJyZW50WyRrZXlQcmVmaXhbaV1dID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRjdXJyZW50ID0gJGN1cnJlbnRbJGtleVByZWZpeFtpXV0gfHwge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgb2YgaXRlcmF0aW9uLCBzZXQgdmFsdWUgYW5kIHNldCBwcmV2IHZhbHVlcyAoZm9yIG5leHQgaXRlcmF0aW9uKVxuICAgICAgICB2YWx1ZXNbcmVtb3ZlS2V5UHJlZml4KGtleSldID0gcm93W2tleV07XG4gICAgICAgIHByZXZLZXkgPSBrZXk7XG4gICAgICAgICRwcmV2S2V5UHJlZml4ID0gJGtleVByZWZpeDtcbiAgICAgICAgJHByZXZLZXlQcmVmaXhTdHJpbmcgPSAka2V5UHJlZml4U3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICBsZW5ndGggPSAkcHJldktleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICRwYXJlbnQgPSBudWxsO1xuICAgICAgICBwYXJlbnRIYXNoID0gbnVsbDtcblxuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAkcGFyZW50ID8gYCR7JHBhcmVudH0uJHskcHJldktleVByZWZpeFtpXX1gIDogJHByZXZLZXlQcmVmaXhbaV07XG4gICAgICAgICAgICBwcmltYXJ5S2V5QXR0cmlidXRlcyA9IGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICAgICAgICAgICRsZW5ndGggPSBwcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBpdGVtSGFzaCA9IHByZWZpeDtcbiAgICAgICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdfWBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCRsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1skaV19YF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwpO1xuICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHJvd1tgJHtwcmVmaXh9LiR7dW5pcXVlS2V5QXR0cmlidXRlc1skaV19YF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyZW50SGFzaCkge1xuICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbUhhc2ggPSBwYXJlbnRIYXNoICsgaXRlbUhhc2g7XG4gICAgICAgICAgICAkcGFyZW50ID0gcHJlZml4O1xuICAgICAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHBhcmVudEhhc2ggPSBpdGVtSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbUhhc2ggPSB0b3BIYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1IYXNoID09PSB0b3BIYXNoKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICRwYXJlbnQgPSByZXN1bHRNYXBbcGFyZW50SGFzaF07XG4gICAgICAgICAgJGxhc3RLZXlQcmVmaXggPSBsYXN0S2V5UHJlZml4KHByZXZLZXkpO1xuXG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXBbcHJldktleV0uYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICAgICAgaWYgKCRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdKSB7XG4gICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XS5wdXNoKHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcEV4aXN0cykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0b3BWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzW3Jvd3NJXSA9IHRvcFZhbHVlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0UXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5BYnN0cmFjdFF1ZXJ5ID0gQWJzdHJhY3RRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFF1ZXJ5O1xuIiwiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3Qgc3luYyByZWN1cnNpdmVcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDsiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubWFyaWFkYjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246bWFyaWFkYicpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdtYXJpYWRiJyk7XG5cbi8qKlxuICogTWFyaWFEQiBDb25uZWN0aW9uIE1hbmFnZXJcbiAqXG4gKiBHZXQgY29ubmVjdGlvbnMsIHZhbGlkYXRlIGFuZCBkaXNjb25uZWN0IHRoZW0uXG4gKiBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHBvb2xpbmcgdXNlIGl0IHRvIGhhbmRsZSBNYXJpYURCIHNwZWNpZmljIGNvbm5lY3Rpb25zXG4gKiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL01hcmlhREIvbWFyaWFkYi1jb25uZWN0b3Itbm9kZWpzIHRvIGNvbm5lY3Qgd2l0aCBNYXJpYURCIHNlcnZlclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZSgnbWFyaWFkYicpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuXG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG5cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3Qgd2l0aCBNYXJpYURCIGRhdGFiYXNlIGJhc2VkIG9uIGNvbmZpZywgSGFuZGxlIGFueSBlcnJvcnMgaW4gY29ubmVjdGlvblxuICAgKiBTZXQgdGhlIHBvb2wgaGFuZGxlcnMgb24gY29ubmVjdGlvbi5lcnJvclxuICAgKiBBbHNvIHNldCBwcm9wZXIgdGltZXpvbmUgb25jZSBjb25uZWN0aW9uIGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgLy8gTmFtZWQgdGltZXpvbmUgaXMgbm90IHN1cHBvcnRlZCBpbiBtYXJpYWRiLCBjb252ZXJ0IHRvIG9mZnNldFxuICAgIGxldCB0ek9mZnNldCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmU7XG4gICAgdHpPZmZzZXQgPSAvXFwvLy50ZXN0KHR6T2Zmc2V0KSA/IG1vbWVudFR6LnR6KHR6T2Zmc2V0KS5mb3JtYXQoJ1onKVxuICAgICAgOiB0ek9mZnNldDtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICB0aW1lem9uZTogdHpPZmZzZXQsXG4gICAgICB0eXBlQ2FzdDogQ29ubmVjdGlvbk1hbmFnZXIuX3R5cGVjYXN0LmJpbmQodGhpcyksXG4gICAgICBiaWdOdW1iZXJTdHJpbmdzOiBmYWxzZSxcbiAgICAgIHN1cHBvcnRCaWdOdW1iZXJzOiB0cnVlLFxuICAgICAgZm91bmRSb3dzOiBmYWxzZSxcbiAgICAgIC4uLmNvbmZpZy5kaWFsZWN0T3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICAvLyBzZXQgdGltZXpvbmUgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoXG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsKSkge1xuICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCA9IFtjb25uZWN0aW9uQ29uZmlnLmluaXRTcWxdO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbC5wdXNoKGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsID0gYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMubGliLmNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoY29ubmVjdGlvbi5zZXJ2ZXJWZXJzaW9uKCkpLnZlcnNpb247XG5cbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGFjcXVpcmVkJyk7XG4gICAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSAnRVNPQ0tFVCc6XG4gICAgICAgICAgY2FzZSAnRUNPTk5SRVNFVCc6XG4gICAgICAgICAgY2FzZSAnRVBJUEUnOlxuICAgICAgICAgIGNhc2UgJ1BST1RPQ09MX0NPTk5FQ1RJT05fTE9TVCc6XG4gICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSAnRUNPTk5SRUZVU0VEJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRVJfQUNDRVNTX0RFTklFRF9FUlJPUic6XG4gICAgICAgIGNhc2UgJ0VSX0FDQ0VTU19ERU5JRURfTk9fUEFTU1dPUkRfRVJST1InOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRU5PVEZPVU5EJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VIT1NUVU5SRUFDSCc6XG4gICAgICAgIGNhc2UgJ0VORVRVTlJFQUNIJzpcbiAgICAgICAgY2FzZSAnRUFERFJOT1RBVkFJTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRUlOVkFMJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIC8vIERvbid0IGRpc2Nvbm5lY3QgY29ubmVjdGlvbnMgd2l0aCBDTE9TRUQgc3RhdGVcbiAgICBpZiAoIWNvbm5lY3Rpb24uaXNWYWxpZCgpKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24uZW5kKCk7XG4gIH1cblxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5pc1ZhbGlkKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHdreCA9IHJlcXVpcmUoJ3dreCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVR5cGVzID0+IHtcbiAgQmFzZVR5cGVzLkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSAnaHR0cHM6Ly9tYXJpYWRiLmNvbS9rYi9lbi9saWJyYXJ5L3Jlc3VsdHNldC8jZmllbGQtdHlwZXMnO1xuXG4gIC8qKlxuICAgKiB0eXBlczogW2J1ZmZlcl90eXBlLCAuLi5dXG4gICAqXG4gICAqIEBzZWUgZG9jdW1lbnRhdGlvbiA6IGh0dHBzOi8vbWFyaWFkYi5jb20va2IvZW4vbGlicmFyeS9yZXN1bHRzZXQvI2ZpZWxkLXR5cGVzXG4gICAqIEBzZWUgY29ubmVjdG9yIGltcGxlbWVudGF0aW9uIDogaHR0cHM6Ly9naXRodWIuY29tL01hcmlhREIvbWFyaWFkYi1jb25uZWN0b3Itbm9kZWpzL2Jsb2IvbWFzdGVyL2xpYi9jb25zdC9maWVsZC10eXBlLmpzXG4gICAqL1xuXG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm1hcmlhZGIgPSBbJ0RBVEVUSU1FJ107XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubWFyaWFkYiA9IFsnVkFSX1NUUklORyddO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5tYXJpYWRiID0gWydTVFJJTkcnXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMubWFyaWFkYiA9IFsnQkxPQiddO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5tYXJpYWRiID0gWydUSU5ZJ107XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5tYXJpYWRiID0gWydTSE9SVCddO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLm1hcmlhZGIgPSBbJ0lOVDI0J107XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm1hcmlhZGIgPSBbJ0xPTkcnXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5tYXJpYWRiID0gWydMT05HTE9ORyddO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMubWFyaWFkYiA9IFsnRkxPQVQnXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubWFyaWFkYiA9IFsnVElNRSddO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubWFyaWFkYiA9IFsnREFURSddO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5tYXJpYWRiID0gWydUSU5ZJ107XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm1hcmlhZGIgPSBbJ1RJTllCTE9CJywgJ0JMT0InLCAnTE9OR0JMT0InXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubWFyaWFkYiA9IFsnTkVXREVDSU1BTCddO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5tYXJpYWRiID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm1hcmlhZGIgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubWFyaWFkYiA9IFsnRE9VQkxFJ107XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubWFyaWFkYiA9IFsnRE9VQkxFJ107XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5tYXJpYWRiID0gWydHRU9NRVRSWSddO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5tYXJpYWRiID0gWydKU09OJ107XG5cbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gc3VwZXIudG9TcWwoKTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICBkZWZpbml0aW9uICs9ICcgVU5TSUdORUQnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gJyBaRVJPRklMTCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aCA/IGBEQVRFVElNRSgke3RoaXMuX2xlbmd0aH0pYCA6ICdEQVRFVElNRSc7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW06c3MuU1NTJyk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9tZW50LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnQudHoodmFsdWUsIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYCR7dmFsdWV9ICR7b3B0aW9ucy50aW1lem9uZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnQ0hBUigzNikgQklOQVJZJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc3JpZCkge1xuICAgICAgc3VwZXIodHlwZSwgc3JpZCk7XG4gICAgICBpZiAoXy5pc0VtcHR5KHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy5rZXk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy50eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyKCk7XG4gICAgICAvLyBFbXB0eSBidWZmZXIsIE15U1FMIGRvZXNuJ3Qgc3VwcG9ydCBQT0lOVCBFTVBUWVxuICAgICAgLy8gY2hlY2ssIGh0dHBzOi8vZGV2Lm15c3FsLmNvbS93b3JrbG9nL3Rhc2svP2lkPTIzODFcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBkaXNjYXJkIHRoZSBmaXJzdCA0IGJ5dGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDQpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZSh2YWx1ZSkudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3FsVHlwZTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgRU5VTSgke3RoaXMudmFsdWVzLm1hcCh2YWx1ZSA9PiBvcHRpb25zLmVzY2FwZSh2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSAnd2hlcmUnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZVxuICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIEVOVU0sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBVVUlELFxuICAgIEdFT01FVFJZLFxuICAgIERFQ0lNQUwsXG4gICAgSlNPTjogSlNPTlRZUEVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0Jyk7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IHsgTXlTUUxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi4vbXlzcWwvcXVlcnktaW50ZXJmYWNlJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubWFyaWFkYjtcblxuY2xhc3MgTWFyaWFkYkRpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNeVNRTFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblxuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShcbiAgXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgICAnVkFMVUVTICgpJzogdHJ1ZSxcbiAgICAnTElNSVQgT04gVVBEQVRFJzogdHJ1ZSxcbiAgICBsb2NrOiB0cnVlLFxuICAgIGZvclNoYXJlOiAnTE9DSyBJTiBTSEFSRSBNT0RFJyxcbiAgICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogZmFsc2UsXG4gICAgc2NoZW1hczogdHJ1ZSxcbiAgICBpbnNlcnRzOiB7XG4gICAgICBpZ25vcmVEdXBsaWNhdGVzOiAnIElHTk9SRScsXG4gICAgICB1cGRhdGVPbkR1cGxpY2F0ZTogJyBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSdcbiAgICB9LFxuICAgIGluZGV4OiB7XG4gICAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICAgIGxlbmd0aDogdHJ1ZSxcbiAgICAgIHBhcnNlcjogdHJ1ZSxcbiAgICAgIHR5cGU6IHRydWUsXG4gICAgICB1c2luZzogMVxuICAgIH0sXG4gICAgY29uc3RyYWludHM6IHtcbiAgICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZSxcbiAgICAgIGNoZWNrOiBmYWxzZVxuICAgIH0sXG4gICAgaW5kZXhWaWFBbHRlcjogdHJ1ZSxcbiAgICBpbmRleEhpbnRzOiB0cnVlLFxuICAgIE5VTUVSSUM6IHRydWUsXG4gICAgR0VPTUVUUlk6IHRydWUsXG4gICAgSlNPTjogdHJ1ZSxcbiAgICBSRUdFWFA6IHRydWVcbiAgfSk7XG5cbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9ICcxMC4xLjQ0Jztcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlF1ZXJ5R2VuZXJhdG9yID0gUXVlcnlHZW5lcmF0b3I7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLm5hbWUgPSAnbWFyaWFkYic7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ2AnO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBNYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlhZGJEaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNeVNRTFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vbXlzcWwvcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vLi4vLi4vdXRpbHMnKTtcblxuY2xhc3MgTWFyaWFEQlF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgTXlTUUxRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdDUkVBVEUgU0NIRU1BIElGIE5PVCBFWElTVFMnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSQUNURVIgU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jaGFyc2V0KX1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBERUZBVUxUIENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGBEUk9QIFNDSEVNQSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpfTtgO1xuICB9XG5cbiAgc2hvd1NjaGVtYXNRdWVyeShvcHRpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hc1RvU2tpcCA9IFtcbiAgICAgICdcXCdNWVNRTFxcJycsXG4gICAgICAnXFwnSU5GT1JNQVRJT05fU0NIRU1BXFwnJyxcbiAgICAgICdcXCdQRVJGT1JNQU5DRV9TQ0hFTUFcXCcnXG4gICAgXTtcbiAgICBpZiAob3B0aW9ucy5za2lwICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5za2lwKSAmJiBvcHRpb25zLnNraXAubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIG9wdGlvbnMuc2tpcCkge1xuICAgICAgICBzY2hlbWFzVG9Ta2lwLnB1c2godGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUIFNDSEVNQV9OQU1FIGFzIHNjaGVtYV9uYW1lJyxcbiAgICAgICdGUk9NIElORk9STUFUSU9OX1NDSEVNQS5TQ0hFTUFUQScsXG4gICAgICBgV0hFUkUgU0NIRU1BX05BTUUgTk9UIElOICgke3NjaGVtYXNUb1NraXAuam9pbignLCAnKX0pYCxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgc2hvd1RhYmxlc1F1ZXJ5KGRhdGFiYXNlKSB7XG4gICAgbGV0IHF1ZXJ5ID0gJ1NFTEVDVCBUQUJMRV9OQU1FLCBUQUJMRV9TQ0hFTUEgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSBcXCdCQVNFIFRBQkxFXFwnJztcbiAgICBpZiAoZGF0YWJhc2UpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoZGF0YWJhc2UpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ICs9ICcgQU5EIFRBQkxFX1NDSEVNQSBOT1QgSU4gKFxcJ01ZU1FMXFwnLCBcXCdJTkZPUk1BVElPTl9TQ0hFTUFcXCcsIFxcJ1BFUkZPUk1BTkNFX1NDSEVNQVxcJyknO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJpYURCUXVlcnlHZW5lcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeScpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IEVSX0RVUF9FTlRSWSA9IDEwNjI7XG5jb25zdCBFUl9ERUFETE9DSyA9IDEyMTM7XG5jb25zdCBFUl9ST1dfSVNfUkVGRVJFTkNFRCA9IDE0NTE7XG5jb25zdCBFUl9OT19SRUZFUkVOQ0VEX1JPVyA9IDE0NTI7XG5cbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnc3FsOm1hcmlhZGInKTtcblxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbiwgc2VxdWVsaXplLCB7IHNob3dXYXJuaW5nczogZmFsc2UsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBbXTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzXykgPT4ge1xuICAgICAgaWYgKHZhbHVlc19ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJpbmRQYXJhbS5wdXNoKHZhbHVlc19ba2V5XSk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtLmxlbmd0aCA+IDAgPyBiaW5kUGFyYW0gOiB1bmRlZmluZWRdO1xuICB9XG5cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcblxuICAgIGNvbnN0IHNob3dXYXJuaW5ncyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc2hvd1dhcm5pbmdzIHx8IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcblxuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBkZWJ1ZygncGFyYW1ldGVycyglaiknLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cztcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHRzID0gYXdhaXQgY29ubmVjdGlvbi5xdWVyeSh0aGlzLnNxbCwgcGFyYW1ldGVycyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIGVycm9yLmVycm5vID09PSBFUl9ERUFETE9DSykge1xuICAgICAgICAvLyBNYXJpYURCIGF1dG9tYXRpY2FsbHkgcm9sbHMtYmFjayB0cmFuc2FjdGlvbnMgaW4gdGhlIGV2ZW50IG9mIGEgZGVhZGxvY2suXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIHN0aWxsIGluaXRpYXRlIGEgbWFudWFsIHJvbGxiYWNrIHRvIGVuc3VyZSB0aGUgY29ubmVjdGlvbiBnZXRzIHJlbGVhc2VkIC0gc2VlICMxMzEwMi5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvcHRpb25zLnRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgLSBzaW5jZSBNYXJpYURCIGF1dG9tYXRpY2FsbHkgcm9sbGVkIGJhY2ssIHdlJ3JlXG4gICAgICAgICAgLy8gbm90IHRoYXQgd29ycmllZCBhYm91dCB0aGlzIHJlZHVuZGFudCByb2xsYmFjayBmYWlsaW5nLlxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCA9ICdyb2xsYmFjayc7XG4gICAgICB9XG5cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3dXYXJuaW5ncyAmJiByZXN1bHRzICYmIHJlc3VsdHMud2FybmluZ1N0YXR1cyA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nV2FybmluZ3MocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeSBleGVjdXRpb24uXG4gICAqXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICBxdWVyeS5mb3JtYXRSZXN1bHRzKFtcbiAgICogICAge1xuICAgKiAgICAgIGlkOiAxLCAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgYXR0cjI6ICdzbmFmdScsICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBUYXNrcy5pZDogMSwgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICAgIFRhc2tzLnRpdGxlOiAndGFzaycgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgIH1cbiAgICogIF0pXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgcmVzdWx0IG9mIHRoZSBxdWVyeSBleGVjdXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcblxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YS5hZmZlY3RlZFJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzID09PSAxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcblxuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBidWxrQ3JlYXRlIEFJIHByaW1hcnkga2V5XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1vZGVsXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBPTkxZIFRSVUUgSUYgQGF1dG9faW5jcmVtZW50X2luY3JlbWVudCBpcyBzZXQgdG8gMSAhIVxuICAgICAgICAgIC8vIERvZXNuJ3Qgd29yayB3aXRoIEdBTEVSQSA9PiBlYWNoIG5vZGUgd2lsbCByZXNlcnZlIGluY3JlbWVudCAoeCBmb3IgZmlyc3Qgc2VydmVyLCB4KzEgZm9yIG5leHQgbm9kZS4uLilcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGRhdGEuYWZmZWN0ZWRSb3dzKTtcbiAgICAgICAgICBjb25zdCBwa0ZpZWxkID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmFmZmVjdGVkUm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB7IFtwa0ZpZWxkXTogc3RhcnRJZCArIGkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV0sIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSnNvblNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgY29uc3QgbWV0YSA9IGRhdGEubWV0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLm1ldGE7XG4gICAgICByZXR1cm4gW2RhdGEsIG1ldGFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkgfHwgdGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgcmVzdWx0W19yZXN1bHQuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2VudW0nKSA/IF9yZXN1bHQuVHlwZS5yZXBsYWNlKC9eZW51bS9pLFxuICAgICAgICAgICAgJ0VOVU0nKSA6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OdWxsID09PSAnWUVTJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleSA9PT0gJ1BSSScsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsICdFeHRyYScpXG4gICAgICAgICAgICAmJiBfcmVzdWx0LkV4dHJhLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRvX2luY3JlbWVudCcsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50ID8gX3Jlc3VsdC5Db21tZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaGFuZGxlSnNvblNlbGVjdFF1ZXJ5KHJvd3MpIHtcbiAgICBpZiAoIXRoaXMubW9kZWwgfHwgIXRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgX2ZpZWxkIG9mIE9iamVjdC5rZXlzKHRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwKSkge1xuICAgICAgY29uc3QgbW9kZWxGaWVsZCA9IHRoaXMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW19maWVsZF07XG4gICAgICBpZiAobW9kZWxGaWVsZC50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgLy8gVmFsdWUgaXMgcmV0dXJuZWQgYXMgU3RyaW5nLCBub3QgSlNPTlxuICAgICAgICByb3dzID0gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdID0gcm93W21vZGVsRmllbGQuZmllbGROYW1lXSA/IEpTT04ucGFyc2UoXG4gICAgICAgICAgICByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdKSA6IG51bGw7XG4gICAgICAgICAgaWYgKERhdGFUeXBlcy5KU09OLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVR5cGVzLkpTT04ucGFyc2UobW9kZWxGaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucyxcbiAgICAgICAgICAgICAgcm93W21vZGVsRmllbGQuZmllbGROYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxvZ1dhcm5pbmdzKHJlc3VsdHMpIHtcbiAgICBjb25zdCB3YXJuaW5nUmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuKCdTSE9XIFdBUk5JTkdTJyk7XG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgTWFyaWFEQiBXYXJuaW5ncyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCAnZGVmYXVsdCd9KTogYDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgX3dhcm5pbmdSb3cgb2Ygd2FybmluZ1Jlc3VsdHMpIHtcbiAgICAgIGlmIChfd2FybmluZ1JvdyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBfd2FybmluZ1Jvd1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfd2FybmluZ1Jlc3VsdCBvZiBfd2FybmluZ1Jvdykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93YXJuaW5nUmVzdWx0LCAnTWVzc2FnZScpKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChfd2FybmluZ1Jlc3VsdC5NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IF9vYmplY3RLZXkgb2YgX3dhcm5pbmdSZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFtfb2JqZWN0S2V5LCBfd2FybmluZ1Jlc3VsdFtfb2JqZWN0S2V5XV0uam9pbignOiAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXF1ZWxpemUubG9nKHdhcm5pbmdNZXNzYWdlICsgbWVzc2FnZXMuam9pbignOyAnKSwgdGhpcy5vcHRpb25zKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgc3dpdGNoIChlcnIuZXJybm8pIHtcbiAgICAgIGNhc2UgRVJfRFVQX0VOVFJZOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goXG4gICAgICAgICAgL0R1cGxpY2F0ZSBlbnRyeSAnKFtcXHNcXFNdKiknIGZvciBrZXkgJz8oKC58XFxzKSo/KSc/XFxzLiokLyk7XG5cbiAgICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGVycm9yJztcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdCgnLScpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmaWVsZEtleSA9IG1hdGNoID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsID0gbWF0Y2ggPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbZmllbGRLZXldO1xuXG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBpZiAodW5pcXVlS2V5Lm1zZykgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbZmllbGRLZXldID0gZmllbGRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKFxuICAgICAgICAgICAgdGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSxcbiAgICAgICAgICAgICd1bmlxdWUgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5EQixcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICAgJ25vdF91bmlxdWUnXG4gICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcyB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSBFUl9ST1dfSVNfUkVGRVJFTkNFRDpcbiAgICAgIGNhc2UgRVJfTk9fUkVGRVJFTkNFRF9ST1c6IHtcbiAgICAgICAgLy8gZS5nLiBDT05TVFJBSU5UIGBleGFtcGxlX2NvbnN0cmFpbnRfbmFtZWAgRk9SRUlHTiBLRVkgKGBleGFtcGxlX2lkYCkgUkVGRVJFTkNFUyBgZXhhbXBsZXNgIChgaWRgKVxuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKFxuICAgICAgICAgIC9DT05TVFJBSU5UIChbYFwiXSkoLiopXFwxIEZPUkVJR04gS0VZIFxcKFxcMSguKilcXDFcXCkgUkVGRVJFTkNFUyBcXDEoLiopXFwxIFxcKFxcMSguKilcXDFcXCkvXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHF1b3RlQ2hhciA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnYCc7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG1hdGNoID8gbWF0Y2hbM10uc3BsaXQobmV3IFJlZ0V4cChgJHtxdW90ZUNoYXJ9LCAqJHtxdW90ZUNoYXJ9YCkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIHJlbHR5cGU6IGVyci5lcnJubyA9PT0gRVJfUk9XX0lTX1JFRkVSRU5DRUQgPyAncGFyZW50JyA6ICdjaGlsZCcsXG4gICAgICAgICAgdGFibGU6IG1hdGNoID8gbWF0Y2hbNF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCAmJiB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRzWzBdXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgaW5kZXg6IG1hdGNoID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcChyZXN1bHRTZXQgPT4gKHtcbiAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICB9KSk7XG4gIH1cblxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcblxuICAgIGxldCBjdXJySXRlbTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGRhdGEuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICghY3Vyckl0ZW0gfHwgY3Vyckl0ZW0ubmFtZSAhPT0gaXRlbS5LZXlfbmFtZSkge1xuICAgICAgICBjdXJySXRlbSA9IHtcbiAgICAgICAgICBwcmltYXJ5OiBpdGVtLktleV9uYW1lID09PSAnUFJJTUFSWScsXG4gICAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgICBuYW1lOiBpdGVtLktleV9uYW1lLFxuICAgICAgICAgIHRhYmxlTmFtZTogaXRlbS5UYWJsZSxcbiAgICAgICAgICB1bmlxdWU6IGl0ZW0uTm9uX3VuaXF1ZSAhPT0gMSxcbiAgICAgICAgICB0eXBlOiBpdGVtLkluZGV4X3R5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LnB1c2goY3Vyckl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBjdXJySXRlbS5maWVsZHNbaXRlbS5TZXFfaW5faW5kZXggLSAxXSA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBpdGVtLkNvbHVtbl9uYW1lLFxuICAgICAgICBsZW5ndGg6IGl0ZW0uU3ViX3BhcnQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBvcmRlcjogaXRlbS5Db2xsYXRpb24gPT09ICdBJyA/ICdBU0MnIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMvYmFzZS1lcnJvcicpO1xuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBpcyBjbG9zZWQgd2hpbGUgYW4gb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzXG4gKi9cbmNsYXNzIEFzeW5jUXVldWVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQXN5bmNRdWV1ZUVycm9yJztcbiAgfVxufVxuXG5leHBvcnRzLkFzeW5jUXVldWVFcnJvciA9IEFzeW5jUXVldWVFcnJvcjtcblxuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVqZWN0Q3VycmVudCA9ICgpID0+IHt9O1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLnJlamVjdEN1cnJlbnQobmV3IENvbm5lY3Rpb25FcnJvcihuZXcgQXN5bmNRdWV1ZUVycm9yKCd0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGlzIHF1ZXJ5IGNvdWxkIGZpbmlzaCBleGVjdXRpbmcnKSkpO1xuICB9XG4gIGVucXVldWUoYXN5bmNGdW5jdGlvbikge1xuICAgIC8vIFRoaXMgb3V0ZXIgcHJvbWlzZSBtaWdodCBzZWVtcyBzdXBlcmZsb3VzIHNpbmNlIGRvd24gYmVsb3cgd2UgcmV0dXJuIGFzeW5jRnVuY3Rpb24oKS50aGVuKHJlc29sdmUsIHJlamVjdCkuXG4gICAgLy8gSG93ZXZlciwgdGhpcyBlbnN1cmVzIHRoYXQgdGhpcy5wcmV2aW91cyB3aWxsIG5ldmVyIGJlIGEgcmVqZWN0ZWQgcHJvbWlzZSBzbyB0aGUgcXVldWUgd2lsbFxuICAgIC8vIGFsd2F5cyBrZWVwIGdvaW5nLCB3aGlsZSBzdGlsbCBjb21tdW5pY2F0aW5nIHJlamVjdGlvbiBmcm9tIGFzeW5jRnVuY3Rpb24gdG8gdGhlIHVzZXIuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlamVjdEN1cnJlbnQgPSByZWplY3Q7XG4gICAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IobmV3IEFzeW5jUXVldWVFcnJvcigndGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgdGhpcyBxdWVyeSBjb3VsZCBiZSBleGVjdXRlZCcpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhc3luY0Z1bmN0aW9uKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFzeW5jUXVldWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IEFzeW5jUXVldWUgPSByZXF1aXJlKCcuL2FzeW5jLXF1ZXVlJykuZGVmYXVsdDtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm1zc3FsO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdtc3NxbCcpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOm1zc3FsJyk7XG5jb25zdCBkZWJ1Z1RlZGlvdXMgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOm1zc3FsOnRlZGlvdXMnKTtcblxuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDE0MzM7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKCd0ZWRpb3VzJyk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG5cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cblxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cblxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICBzZXJ2ZXI6IGNvbmZpZy5ob3N0LFxuICAgICAgYXV0aGVudGljYXRpb246IHtcbiAgICAgICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgdXNlck5hbWU6IGNvbmZpZy51c2VybmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCB8fCB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQoY29uZmlnLnBvcnQsIDEwKSxcbiAgICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgICAgdHJ1c3RTZXJ2ZXJDZXJ0aWZpY2F0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICAvLyBvbmx5IHNldCBwb3J0IGlmIG5vIGluc3RhbmNlIG5hbWUgd2FzIHByb3ZpZGVkXG4gICAgICBpZiAoXG4gICAgICAgIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zICYmXG4gICAgICAgIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zLmluc3RhbmNlTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSBjb25uZWN0aW9uQ29uZmlnLm9wdGlvbnMucG9ydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5hdXRoZW50aWNhdGlvbikge1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbm5lY3Rpb25Db25maWcuYXV0aGVudGljYXRpb24sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5hdXRoZW50aWNhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbkNvbmZpZy5vcHRpb25zLCBjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgdGhpcy5saWIuQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc3RhdGUgPT09IGNvbm5lY3Rpb24uU1RBVEUuSU5JVElBTElaRUQpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uLnF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICAgICAgY29ubmVjdGlvbi5saWIgPSB0aGlzLmxpYjtcblxuICAgICAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IGVycm9yID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuXG4gICAgICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gYWNxdWlyZWQnKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVuZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ5IHJlbW90ZSBzZXJ2ZXInKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kSGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdjb25uZWN0JywgY29ubmVjdEhhbmRsZXIpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFBlcm1hbmVudGx5IGF0dGFjaCB0aGlzIGV2ZW50IGJlZm9yZSBjb25uZWN0aW9uIGlzIGV2ZW4gYWNxdWlyZWRcbiAgICAgICAgICogdGVkaW91cyBzb21ldGltZSBlbWl0cyBlcnJvciBldmVuIGFmdGVyIGNvbm5lY3Qod2l0aCBlcnJvcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHdlIGRvbnQgYXR0YWNoIHRoaXMgZXZlbiB0aGF0IHVuZXhwZWN0ZWQgZXJyb3IgZXZlbnQgd2lsbCBjcmFzaCBub2RlIHByb2Nlc3NcbiAgICAgICAgICpcbiAgICAgICAgICogRS5nLiBjb25uZWN0VGltZW91dCBpcyBzZXQgaGlnaGVyIHRoYW4gcmVxdWVzdFRpbWVvdXRcbiAgICAgICAgICovXG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnRVNPQ0tFVCc6XG4gICAgICAgICAgICBjYXNlICdFQ09OTlJFU0VUJzpcbiAgICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgIGNvbm5lY3Rpb24ub24oJ2RlYnVnJywgZGVidWdUZWRpb3VzLmxvZy5iaW5kKGRlYnVnVGVkaW91cykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFlcnJvci5jb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ0VTT0NLRVQnOlxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdjb25uZWN0IEVIT1NUVU5SRUFDSCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdjb25uZWN0IEVORVRVTlJFQUNIJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3QgRUFERFJOT1RBVkFJTCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdnZXRhZGRyaW5mbyBFTk9URk9VTkQnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdjb25uZWN0IEVDT05OUkVGVVNFRCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICAgIGNhc2UgJ0VSX0FDQ0VTU19ERU5JRURfRVJST1InOlxuICAgICAgICBjYXNlICdFTE9HSU4nOlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyb3IpO1xuICAgICAgICBjYXNlICdFSU5WQUwnOlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIC8vIERvbid0IGRpc2Nvbm5lY3QgYSBjb25uZWN0aW9uIHRoYXQgaXMgYWxyZWFkeSBkaXNjb25uZWN0ZWRcbiAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLnF1ZXVlLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25uZWN0aW9uLm9uKCdlbmQnLCByZXNvbHZlKTtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24ubG9nZ2VkSW47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUeXBlcyA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHVuZGVmaW5lZCwgJ2h0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxODc3NTIlMjh2PXNxbC4xMTAlMjkuYXNweCcpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHVuc3VwcG9ydGVkIE1TU1FMIG9wdGlvbnMsIGkuZS4sIExFTkdUSCwgVU5TSUdORUQgYW5kIFpFUk9GSUxMLCBmb3IgdGhlIGludGVnZXIgZGF0YSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFUeXBlIFRoZSBiYXNlIGludGVnZXIgZGF0YSB0eXBlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5fbGVuZ3RoIHx8IGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoIHx8IGRhdGFUeXBlLl91bnNpZ25lZCB8fCBkYXRhVHlwZS5femVyb2ZpbGwpIHtcbiAgICAgIHdhcm4oYE1TU1FMIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBvcHRpb25zLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogdHlwZXM6IFtoZXgsIC4uLl1cbiAgICpcbiAgICogQHNlZSBoZXggaGVyZSBodHRwczovL2dpdGh1Yi5jb20vdGVkaW91c2pzL3RlZGlvdXMvYmxvYi9tYXN0ZXIvc3JjL2RhdGEtdHlwZS50c1xuICAgKi9cblxuICBCYXNlVHlwZXMuREFURS50eXBlcy5tc3NxbCA9IFs0M107XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubXNzcWwgPSBbMjMxLCAxNzNdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5tc3NxbCA9IFsxNzVdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3NzQ1KHY9c3FsLjExMCkuYXNweFxuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5tc3NxbCA9IFszMF07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5tc3NxbCA9IFszNF07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubXNzcWwgPSBbMzhdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5tc3NxbCA9IFsxMDldO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5tc3NxbCA9IFs0MV07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5tc3NxbCA9IFs0MF07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm1zc3FsID0gWzEwNF07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm1zc3FsID0gWzE2NV07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm1zc3FsID0gWzEwNl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgLy8gQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm1zc3FsID0gWzI0MF07IC8vIG5vdCB5ZXQgc3VwcG9ydGVkXG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5tc3NxbCA9IGZhbHNlO1xuXG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gJ3RpbnknKSB7IC8vIHRpbnkgPSAyXjhcbiAgICAgICAgICB3YXJuKCdNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0Igd2l0aCB0aGUgYGxlbmd0aGAgPSBgdGlueWAgb3B0aW9uLiBgVkFSQklOQVJZKDI1NilgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICAgIHJldHVybiAnVkFSQklOQVJZKDI1NiknO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgQkxPQiB3aXRoIHRoZSBgbGVuZ3RoYCBvcHRpb24uIGBWQVJCSU5BUlkoTUFYKWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1ZBUkJJTkFSWShNQVgpJztcbiAgICB9XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIHJldHVybiBgMHgke2hleH1gO1xuICAgIH1cbiAgfVxuXG5cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAoIXRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYE5WQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIEJMT0IucHJvdG90eXBlLl9zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX2JpbmFyeSA/IEJ1ZmZlci5mcm9tKHZhbHVlKSA6IHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBTVFJJTkcucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICAvLyBURVhUIGlzIGRlcHJlY2F0ZWQgaW4gbXNzcWwgYW5kIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHNhdmVkIGFzIGEgbm9uLXVuaWNvZGUgc3RyaW5nLlxuICAgICAgLy8gVXNpbmcgdW5pY29kZSBpcyBqdXN0IGZ1dHVyZSBwcm9vZlxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09ICd0aW55JykgeyAvLyB0aW55ID0gMl44XG4gICAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggdGhlIGBsZW5ndGhgID0gYHRpbnlgIG9wdGlvbi4gYE5WQVJDSEFSKDI1NilgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICAgIHJldHVybiAnTlZBUkNIQVIoMjU2KSc7XG4gICAgICAgIH1cbiAgICAgICAgd2FybignTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggdGhlIGBsZW5ndGhgIG9wdGlvbi4gYE5WQVJDSEFSKE1BWClgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdOVkFSQ0hBUihNQVgpJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdCSVQnO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ0NIQVIoMzYpJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBOT1cgZXh0ZW5kcyBCYXNlVHlwZXMuTk9XIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiAnR0VUREFURSgpJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdEQVRFVElNRU9GRlNFVCc7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgLy8gTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBhbnkgb3B0aW9ucyBmb3IgcmVhbFxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgUkVBTCB3aXRoIG9wdGlvbnMuIFBsYWluIGBSRUFMYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIC8vIE1TU1FMIGRvZXMgb25seSBzdXBwb3J0IGxlbmd0aHMgYXMgb3B0aW9uLlxuICAgICAgLy8gVmFsdWVzIGJldHdlZW4gMS0yNCByZXN1bHQgaW4gNyBkaWdpdHMgcHJlY2lzaW9uICg0IGJ5dGVzIHN0b3JhZ2Ugc2l6ZSlcbiAgICAgIC8vIFZhbHVlcyBiZXR3ZWVuIDI1LTUzIHJlc3VsdCBpbiAxNSBkaWdpdHMgcHJlY2lzaW9uICg4IGJ5dGVzIHN0b3JhZ2Ugc2l6ZSlcbiAgICAgIC8vIElmIGRlY2ltYWxzIGFyZSBwcm92aWRlZCByZW1vdmUgdGhlc2UgYW5kIHByaW50IGEgd2FybmluZ1xuICAgICAgaWYgKHRoaXMuX2RlY2ltYWxzKSB7XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgd2l0aCBkZWNpbWFscy4gUGxhaW4gYEZMT0FUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgdW5zaWduZWQuIGBVTlNJR05FRGAgd2FzIHJlbW92ZWQuJyk7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oJ01TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgemVyb2ZpbGwuIGBaRVJPRklMTGAgd2FzIHJlbW92ZWQuJyk7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdWQVJDSEFSKDI1NSknO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgQkxPQixcbiAgICBCT09MRUFOLFxuICAgIEVOVU0sXG4gICAgU1RSSU5HLFxuICAgIFVVSUQsXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBOT1csXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBSRUFMLFxuICAgIEZMT0FULFxuICAgIFRFWFRcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0Jyk7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKS5tc3NxbDtcbmNvbnN0IHsgTVNTcWxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi9xdWVyeS1pbnRlcmZhY2UnKTtcblxuY2xhc3MgTXNzcWxEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTVNTcWxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5cbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gICdERUZBVUxUJzogdHJ1ZSxcbiAgJ0RFRkFVTFQgVkFMVUVTJzogdHJ1ZSxcbiAgJ0xJTUlUIE9OIFVQREFURSc6IHRydWUsXG4gICdPUkRFUiBOVUxMUyc6IGZhbHNlLFxuICBsb2NrOiBmYWxzZSxcbiAgdHJhbnNhY3Rpb25zOiB0cnVlLFxuICBtaWdyYXRpb25zOiBmYWxzZSxcbiAgcmV0dXJuVmFsdWVzOiB7XG4gICAgb3V0cHV0OiB0cnVlXG4gIH0sXG4gIHNjaGVtYXM6IHRydWUsXG4gIGF1dG9JbmNyZW1lbnQ6IHtcbiAgICBpZGVudGl0eUluc2VydDogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIHVwZGF0ZTogZmFsc2VcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogZmFsc2UsXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiBmYWxzZSxcbiAgICB3aGVyZTogdHJ1ZVxuICB9LFxuICBOVU1FUklDOiB0cnVlLFxuICB0bXBUYWJsZVRyaWdnZXI6IHRydWVcbn0pO1xuXG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gJzEyLjAuMjAwMCc7IC8vIFNRTCBTZXJ2ZXIgMjAxNCBFeHByZXNzXG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLm5hbWUgPSAnbXNzcWwnO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9ICdbJztcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gJ10nO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gTXNzcWxEaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBUYWJsZUhpbnRzID0gcmVxdWlyZSgnLi4vLi4vdGFibGUtaGludHMnKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IE9wID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3JzJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB0aHJvd01ldGhvZFVuZGVmaW5lZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiIGlzIG5vdCBkZWZpbmVkISBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgc3FsIGRpYWxlY3QuYCk7XG59O1xuXG5jbGFzcyBNU1NRTFF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgY29sbGF0ZTogbnVsbCwgLi4ub3B0aW9ucyB9O1xuXG4gICAgY29uc3QgY29sbGF0aW9uID0gb3B0aW9ucy5jb2xsYXRlID8gYENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAgOiAnJztcblxuICAgIHJldHVybiBbXG4gICAgICAnSUYgTk9UIEVYSVNUUyAoU0VMRUNUICogRlJPTSBzeXMuZGF0YWJhc2VzIFdIRVJFIG5hbWUgPScsIHdyYXBTaW5nbGVRdW90ZShkYXRhYmFzZU5hbWUpLCAnKScsXG4gICAgICAnQkVHSU4nLFxuICAgICAgJ0NSRUFURSBEQVRBQkFTRScsIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBgJHtjb2xsYXRpb259O2AsXG4gICAgICAnRU5EOydcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBbXG4gICAgICAnSUYgRVhJU1RTIChTRUxFQ1QgKiBGUk9NIHN5cy5kYXRhYmFzZXMgV0hFUkUgbmFtZSA9Jywgd3JhcFNpbmdsZVF1b3RlKGRhdGFiYXNlTmFtZSksICcpJyxcbiAgICAgICdCRUdJTicsXG4gICAgICAnRFJPUCBEQVRBQkFTRScsIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksICc7JyxcbiAgICAgICdFTkQ7J1xuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBbXG4gICAgICAnSUYgTk9UIEVYSVNUUyAoU0VMRUNUIHNjaGVtYV9uYW1lJyxcbiAgICAgICdGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YScsXG4gICAgICAnV0hFUkUgc2NoZW1hX25hbWUgPScsIHdyYXBTaW5nbGVRdW90ZShzY2hlbWEpLCAnKScsXG4gICAgICAnQkVHSU4nLFxuICAgICAgXCJFWEVDIHNwX2V4ZWN1dGVzcWwgTidDUkVBVEUgU0NIRU1BXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgXCI7J1wiLFxuICAgICAgJ0VORDsnXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIC8vIE1pbWljcyBQb3N0Z3JlcyBDQVNDQURFLCB3aWxsIGRyb3Agb2JqZWN0cyBiZWxvbmdpbmcgdG8gdGhlIHNjaGVtYVxuICAgIGNvbnN0IHF1b3RlZFNjaGVtYSA9IHdyYXBTaW5nbGVRdW90ZShzY2hlbWEpO1xuICAgIHJldHVybiBbXG4gICAgICAnSUYgRVhJU1RTIChTRUxFQ1Qgc2NoZW1hX25hbWUnLFxuICAgICAgJ0ZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhJyxcbiAgICAgICdXSEVSRSBzY2hlbWFfbmFtZSA9JywgcXVvdGVkU2NoZW1hLCAnKScsXG4gICAgICAnQkVHSU4nLFxuICAgICAgJ0RFQ0xBUkUgQGlkIElOVCwgQG1zX3NxbCBOVkFSQ0hBUigyMDAwKTsnLFxuICAgICAgJ0RFQ0xBUkUgQGNhc2NhZGUgVEFCTEUgKCcsXG4gICAgICAnaWQgSU5UIE5PVCBOVUxMIElERU5USVRZIFBSSU1BUlkgS0VZLCcsXG4gICAgICAnbXNfc3FsIE5WQVJDSEFSKDIwMDApIE5PVCBOVUxMICk7JyxcbiAgICAgICdJTlNFUlQgSU5UTyBAY2FzY2FkZSAoIG1zX3NxbCApJyxcbiAgICAgIFwiU0VMRUNUIENBU0UgV0hFTiBvLnR5cGUgSU4gKCdGJywnUEsnKVwiLFxuICAgICAgXCJUSEVOIE4nQUxURVIgVEFCTEUgWycrIHMubmFtZSArIE4nXS5bJyArIHAubmFtZSArIE4nXSBEUk9QIENPTlNUUkFJTlQgWycgKyBvLm5hbWUgKyBOJ10nXCIsXG4gICAgICBcIkVMU0UgTidEUk9QIFRBQkxFIFsnKyBzLm5hbWUgKyBOJ10uWycgKyBvLm5hbWUgKyBOJ10nIEVORFwiLFxuICAgICAgJ0ZST00gc3lzLm9iamVjdHMgbycsXG4gICAgICAnSk9JTiBzeXMuc2NoZW1hcyBzIG9uIG8uc2NoZW1hX2lkID0gcy5zY2hlbWFfaWQnLFxuICAgICAgJ0xFRlQgT1VURVIgSk9JTiBzeXMub2JqZWN0cyBwIG9uIG8ucGFyZW50X29iamVjdF9pZCA9IHAub2JqZWN0X2lkJyxcbiAgICAgIFwiV0hFUkUgby50eXBlIElOICgnRicsICdQSycsICdVJykgQU5EIHMubmFtZSA9IFwiLCBxdW90ZWRTY2hlbWEsXG4gICAgICAnT1JERVIgQlkgby50eXBlIEFTQzsnLFxuICAgICAgJ1NFTEVDVCBUT1AgMSBAaWQgPSBpZCwgQG1zX3NxbCA9IG1zX3NxbCBGUk9NIEBjYXNjYWRlIE9SREVSIEJZIGlkOycsXG4gICAgICAnV0hJTEUgQGlkIElTIE5PVCBOVUxMJyxcbiAgICAgICdCRUdJTicsXG4gICAgICAnQkVHSU4gVFJZIEVYRUMgc3BfZXhlY3V0ZXNxbCBAbXNfc3FsOyBFTkQgVFJZJyxcbiAgICAgICdCRUdJTiBDQVRDSCBCUkVBSzsgVEhST1c7IEVORCBDQVRDSDsnLFxuICAgICAgJ0RFTEVURSBGUk9NIEBjYXNjYWRlIFdIRVJFIGlkID0gQGlkOycsXG4gICAgICAnU0VMRUNUIEBpZCA9IE5VTEwsIEBtc19zcWwgPSBOVUxMOycsXG4gICAgICAnU0VMRUNUIFRPUCAxIEBpZCA9IGlkLCBAbXNfc3FsID0gbXNfc3FsIEZST00gQGNhc2NhZGUgT1JERVIgQlkgaWQ7JyxcbiAgICAgICdFTkQnLFxuICAgICAgXCJFWEVDIHNwX2V4ZWN1dGVzcWwgTidEUk9QIFNDSEVNQVwiLCB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLCBcIjsnXCIsXG4gICAgICAnRU5EOydcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdTRUxFQ1QgXCJuYW1lXCIgYXMgXCJzY2hlbWFfbmFtZVwiIEZST00gc3lzLnNjaGVtYXMgYXMgcycsXG4gICAgICAnV0hFUkUgXCJzXCIuXCJuYW1lXCIgTk9UIElOICgnLFxuICAgICAgXCInSU5GT1JNQVRJT05fU0NIRU1BJywgJ2RibycsICdndWVzdCcsICdzeXMnLCAnYXJjaGl2ZSdcIixcbiAgICAgICcpJywgJ0FORCcsICdcInNcIi5cIm5hbWVcIiBOT1QgTElLRScsIFwiJ2RiXyUnXCJcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICAvLyBVc2VzIHN0cmluZyBtYW5pcHVsYXRpb24gdG8gY29udmVydCB0aGUgTVMgTWFqLk1pbi5QYXRjaC5CdWlsZCB0byBzZW12ZXIgTWFqLk1pbi5QYXRjaFxuICAgIHJldHVybiBbXG4gICAgICAnREVDTEFSRSBAbXNfdmVyIE5WQVJDSEFSKDIwKTsnLFxuICAgICAgXCJTRVQgQG1zX3ZlciA9IFJFVkVSU0UoQ09OVkVSVChOVkFSQ0hBUigyMCksIFNFUlZFUlBST1BFUlRZKCdQcm9kdWN0VmVyc2lvbicpKSk7XCIsXG4gICAgICBcIlNFTEVDVCBSRVZFUlNFKFNVQlNUUklORyhAbXNfdmVyLCBDSEFSSU5ERVgoJy4nLCBAbXNfdmVyKSsxLCAyMCkpIEFTICd2ZXJzaW9uJ1wiXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cblxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW10sXG4gICAgICBmb3JlaWduS2V5cyA9IHt9LFxuICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzID0gW107XG5cbiAgICBsZXQgY29tbWVudFN0ciA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbGV0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnQ09NTUVOVCAnKSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoQ09NTUVOVC4qKSQvKTtcbiAgICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IGNvbW1lbnRNYXRjaFsyXS5yZXBsYWNlKCdDT01NRU5UJywgJycpLnRyaW0oKTtcbiAgICAgICAgICBjb21tZW50U3RyICs9IHRoaXMuY29tbWVudFRlbXBsYXRlKGNvbW1lbnRUZXh0LCB0YWJsZU5hbWUsIGF0dHIpO1xuICAgICAgICAgIC8vIHJlbW92ZSBjb21tZW50IHJlbGF0ZWQgc3Vic3RyaW5nIGZyb20gZGF0YVR5cGVcbiAgICAgICAgICBkYXRhVHlwZSA9IGNvbW1lbnRNYXRjaFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkge1xuICAgICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG5cbiAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICAgICAgLy8gTVNTUUwgZG9lc24ndCBzdXBwb3J0IGlubGluZSBSRUZFUkVOQ0VTIGRlY2xhcmF0aW9uczogbW92ZSB0byB0aGUgZW5kXG4gICAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJycpfWApO1xuICAgICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnJyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgICAvLyBNU1NRTCBkb2Vzbid0IHN1cHBvcnQgaW5saW5lIFJFRkVSRU5DRVMgZGVjbGFyYXRpb25zOiBtb3ZlIHRvIHRoZSBlbmRcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAocGsgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKCcsICcpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbignXycpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBDT05TVFJBSU5UICR7XG4gICAgICAgICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpXG4gICAgICAgICAgfSBVTklRVUUgKCR7XG4gICAgICAgICAgICBjb2x1bW5zLmZpZWxkcy5tYXAoZmllbGQgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKCcsICcpXG4gICAgICAgICAgfSlgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuXG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYElGIE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZU5hbWV9JywgJ1UnKSBJUyBOVUxMYCxcbiAgICAgIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9ICgke2F0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5qb2luKCcsICcpfSlgLFxuICAgICAgJzsnLFxuICAgICAgY29tbWVudFN0clxuICAgIF0pO1xuICB9XG5cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgbGV0IHNxbCA9IFtcbiAgICAgICdTRUxFQ1QnLFxuICAgICAgXCJjLkNPTFVNTl9OQU1FIEFTICdOYW1lJyxcIixcbiAgICAgIFwiYy5EQVRBX1RZUEUgQVMgJ1R5cGUnLFwiLFxuICAgICAgXCJjLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSCBBUyAnTGVuZ3RoJyxcIixcbiAgICAgIFwiYy5JU19OVUxMQUJMRSBhcyAnSXNOdWxsJyxcIixcbiAgICAgIFwiQ09MVU1OX0RFRkFVTFQgQVMgJ0RlZmF1bHQnLFwiLFxuICAgICAgXCJway5DT05TVFJBSU5UX1RZUEUgQVMgJ0NvbnN0cmFpbnQnLFwiLFxuICAgICAgXCJDT0xVTU5QUk9QRVJUWShPQkpFQ1RfSUQoYy5UQUJMRV9TQ0hFTUErJy4nK2MuVEFCTEVfTkFNRSksIGMuQ09MVU1OX05BTUUsICdJc0lkZW50aXR5JykgYXMgJ0lzSWRlbnRpdHknLFwiLFxuICAgICAgXCJDQVNUKHByb3AudmFsdWUgQVMgTlZBUkNIQVIpIEFTICdDb21tZW50J1wiLFxuICAgICAgJ0ZST00nLFxuICAgICAgJ0lORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgdCcsXG4gICAgICAnSU5ORVIgSk9JTicsXG4gICAgICAnSU5GT1JNQVRJT05fU0NIRU1BLkNPTFVNTlMgYyBPTiB0LlRBQkxFX05BTUUgPSBjLlRBQkxFX05BTUUgQU5EIHQuVEFCTEVfU0NIRU1BID0gYy5UQUJMRV9TQ0hFTUEnLFxuICAgICAgJ0xFRlQgSk9JTiAoU0VMRUNUIHRjLnRhYmxlX3NjaGVtYSwgdGMudGFibGVfbmFtZSwgJyxcbiAgICAgICdjdS5jb2x1bW5fbmFtZSwgdGMuQ09OU1RSQUlOVF9UWVBFICcsXG4gICAgICAnRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFMgdGMgJyxcbiAgICAgICdKT0lOIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFICBjdSAnLFxuICAgICAgJ09OIHRjLnRhYmxlX3NjaGVtYT1jdS50YWJsZV9zY2hlbWEgYW5kIHRjLnRhYmxlX25hbWU9Y3UudGFibGVfbmFtZSAnLFxuICAgICAgJ2FuZCB0Yy5jb25zdHJhaW50X25hbWU9Y3UuY29uc3RyYWludF9uYW1lICcsXG4gICAgICAnYW5kIHRjLkNPTlNUUkFJTlRfVFlQRT1cXCdQUklNQVJZIEtFWVxcJykgcGsgJyxcbiAgICAgICdPTiBway50YWJsZV9zY2hlbWE9Yy50YWJsZV9zY2hlbWEgJyxcbiAgICAgICdBTkQgcGsudGFibGVfbmFtZT1jLnRhYmxlX25hbWUgJyxcbiAgICAgICdBTkQgcGsuY29sdW1uX25hbWU9Yy5jb2x1bW5fbmFtZSAnLFxuICAgICAgJ0lOTkVSIEpPSU4gc3lzLmNvbHVtbnMgQVMgc2MnLFxuICAgICAgXCJPTiBzYy5vYmplY3RfaWQgPSBvYmplY3RfaWQodC50YWJsZV9zY2hlbWEgKyAnLicgKyB0LnRhYmxlX25hbWUpIEFORCBzYy5uYW1lID0gYy5jb2x1bW5fbmFtZVwiLFxuICAgICAgJ0xFRlQgSk9JTiBzeXMuZXh0ZW5kZWRfcHJvcGVydGllcyBwcm9wIE9OIHByb3AubWFqb3JfaWQgPSBzYy5vYmplY3RfaWQnLFxuICAgICAgJ0FORCBwcm9wLm1pbm9yX2lkID0gc2MuY29sdW1uX2lkJyxcbiAgICAgIFwiQU5EIHByb3AubmFtZSA9ICdNU19EZXNjcmlwdGlvbidcIixcbiAgICAgICdXSEVSRSB0LlRBQkxFX05BTUUgPScsIHdyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpXG4gICAgXS5qb2luKCcgJyk7XG5cbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICBzcWwgKz0gYEFORCB0LlRBQkxFX1NDSEVNQSA9JHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBzcWw7XG4gIH1cblxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gYEVYRUMgc3BfcmVuYW1lICR7dGhpcy5xdW90ZVRhYmxlKGJlZm9yZSl9LCAke3RoaXMucXVvdGVUYWJsZShhZnRlcil9O2A7XG4gIH1cblxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIFRBQkxFX05BTUUsIFRBQkxFX1NDSEVNQSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJztcIjtcbiAgfVxuXG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlVGJsID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYElGIE9CSkVDVF9JRCgnJHtxdW90ZVRibH0nLCAnVScpIElTIE5PVCBOVUxMYCxcbiAgICAgICdEUk9QIFRBQkxFJyxcbiAgICAgIHF1b3RlVGJsLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIC8vIEZJWE1FOiBhdHRyaWJ1dGVUb1NRTCBTSE9VTEQgYmUgdXNpbmcgYXR0cmlidXRlcyBpbiBhZGRDb2x1bW5RdWVyeVxuICAgIC8vICAgICAgICBidXQgaW5zdGVhZCB3ZSBuZWVkIHRvIHBhc3MgdGhlIGtleSBhbG9uZyBhcyB0aGUgZmllbGQgaGVyZVxuICAgIGRhdGFUeXBlLmZpZWxkID0ga2V5O1xuICAgIGxldCBjb21tZW50U3RyID0gJyc7XG5cbiAgICBpZiAoZGF0YVR5cGUuY29tbWVudCAmJiBfLmlzU3RyaW5nKGRhdGFUeXBlLmNvbW1lbnQpKSB7XG4gICAgICBjb21tZW50U3RyID0gdGhpcy5jb21tZW50VGVtcGxhdGUoZGF0YVR5cGUuY29tbWVudCwgdGFibGUsIGtleSk7XG4gICAgICAvLyBhdHRyaWJ1dGVUb1NRTCB3aWxsIHRyeSB0byBpbmNsdWRlIGBDT01NRU5UICdDb21tZW50IFRleHQnYCB3aGVuIGl0IHJldHVybnMgaWYgdGhlIGNvbW1lbnQga2V5XG4gICAgICAvLyBpcyBwcmVzZW50LiBUaGlzIGlzIG5lZWRlZCBmb3IgY3JlYXRlVGFibGUgc3RhdGVtZW50IHdoZXJlIHRoYXQgcGFydCBpcyBleHRyYWN0ZWQgd2l0aCByZWdleC5cbiAgICAgIC8vIEhlcmUgd2UgY2FuIGludGVyY2VwdCB0aGUgb2JqZWN0IGFuZCByZW1vdmUgY29tbWVudCBwcm9wZXJ0eSBzaW5jZSB3ZSBoYXZlIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICBkZWxldGUgZGF0YVR5cGVbJ2NvbW1lbnQnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgICdBREQnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHsgY29udGV4dDogJ2FkZENvbHVtbicgfSksXG4gICAgICAnOycsXG4gICAgICBjb21tZW50U3RyXG4gICAgXSk7XG4gIH1cblxuICBjb21tZW50VGVtcGxhdGUoY29tbWVudCwgdGFibGUsIGNvbHVtbikge1xuICAgIHJldHVybiAnIEVYRUMgc3BfYWRkZXh0ZW5kZWRwcm9wZXJ0eSAnICtcbiAgICAgICAgYEBuYW1lID0gTidNU19EZXNjcmlwdGlvbicsIEB2YWx1ZSA9ICR7dGhpcy5lc2NhcGUoY29tbWVudCl9LCBgICtcbiAgICAgICAgJ0BsZXZlbDB0eXBlID0gTlxcJ1NjaGVtYVxcJywgQGxldmVsMG5hbWUgPSBcXCdkYm9cXCcsICcgK1xuICAgICAgICBgQGxldmVsMXR5cGUgPSBOJ1RhYmxlJywgQGxldmVsMW5hbWUgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlKX0sIGAgK1xuICAgICAgICBgQGxldmVsMnR5cGUgPSBOJ0NvbHVtbicsIEBsZXZlbDJuYW1lID0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihjb2x1bW4pfTtgO1xuICB9XG5cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0RST1AgQ09MVU1OJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW10sXG4gICAgICBjb25zdHJhaW50U3RyaW5nID0gW107XG4gICAgbGV0IGNvbW1lbnRTdHJpbmcgPSAnJztcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBxdW90ZWRBdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ0NPTU1FTlQgJykpIHtcbiAgICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gZGVmaW5pdGlvbi5tYXRjaCgvXiguKykgKENPTU1FTlQuKikkLyk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gY29tbWVudE1hdGNoWzJdLnJlcGxhY2UoJ0NPTU1FTlQnLCAnJykudHJpbSgpO1xuICAgICAgICBjb21tZW50U3RyaW5nICs9IHRoaXMuY29tbWVudFRlbXBsYXRlKGNvbW1lbnRUZXh0LCB0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAvLyByZW1vdmUgY29tbWVudCByZWxhdGVkIHN1YnN0cmluZyBmcm9tIGRhdGFUeXBlXG4gICAgICAgIGRlZmluaXRpb24gPSBjb21tZW50TWF0Y2hbMV07XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIGNvbnN0cmFpbnRTdHJpbmcucHVzaChgRk9SRUlHTiBLRVkgKCR7cXVvdGVkQXR0ck5hbWV9KSAke2RlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCAnJyl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyaW5nLnB1c2goYCR7cXVvdGVkQXR0ck5hbWV9ICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyU3RyaW5nLmxlbmd0aCAmJiBgQUxURVIgQ09MVU1OICR7YXR0clN0cmluZy5qb2luKCcsICcpfWAsXG4gICAgICBjb25zdHJhaW50U3RyaW5nLmxlbmd0aCAmJiBgQUREICR7Y29uc3RyYWludFN0cmluZy5qb2luKCcsICcpfWAsXG4gICAgICAnOycsXG4gICAgICBjb21tZW50U3RyaW5nXG4gICAgXSk7XG4gIH1cblxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBuZXdOYW1lID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylbMF07XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0VYRUMgc3BfcmVuYW1lJyxcbiAgICAgIGAnJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0uJHthdHRyQmVmb3JlfScsYCxcbiAgICAgIGAnJHtuZXdOYW1lfScsYCxcbiAgICAgIFwiJ0NPTFVNTidcIixcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaGVzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBjb25zdCBhbGxRdWVyaWVzID0gW107XG5cbiAgICBsZXQgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IGZhbHNlLFxuICAgICAgb3V0cHV0RnJhZ21lbnQgPSAnJztcblxuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhhdHRyaWJ1dGVzLCBvcHRpb25zKTtcblxuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZW1wdHlRdWVyeSA9IGBJTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlfSR7b3V0cHV0RnJhZ21lbnR9IERFRkFVTFQgVkFMVUVTYDtcblxuICAgIGF0dHJWYWx1ZUhhc2hlcy5mb3JFYWNoKGF0dHJWYWx1ZUhhc2ggPT4ge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBlbXB0eSBvYmplY3RzIHdpdGggcHJpbWFyeSBrZXlzXG4gICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhhdHRyVmFsdWVIYXNoKTtcbiAgICAgIGNvbnN0IGZpcnN0QXR0ciA9IGF0dHJpYnV0ZXNbZmllbGRzWzBdXTtcbiAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxICYmIGZpcnN0QXR0ciAmJiBmaXJzdEF0dHIuYXV0b0luY3JlbWVudCAmJiBhdHRyVmFsdWVIYXNoW2ZpZWxkc1swXV0gPT09IG51bGwpIHtcbiAgICAgICAgYWxsUXVlcmllcy5wdXNoKGVtcHR5UXVlcnkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbCBjYXNlXG4gICAgICBfLmZvck93bihhdHRyVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgYXR0cmlidXRlc1trZXldICYmIGF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFsbEF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gJiYgYXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoYWxsQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyVmFsdWVIYXNoZXMuZm9yRWFjaChhdHRyVmFsdWVIYXNoID0+IHtcbiAgICAgICAgdHVwbGVzLnB1c2goYCgke1xuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMubWFwKGtleSA9PlxuICAgICAgICAgICAgdGhpcy5lc2NhcGUoYXR0clZhbHVlSGFzaFtrZXldKSkuam9pbignLCcpXG4gICAgICAgIH0pYCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcXVvdGVkQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oJywnKTtcbiAgICAgIGFsbFF1ZXJpZXMucHVzaCh0dXBsZVN0ciA9PiBgSU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZX0gKCR7cXVvdGVkQXR0cmlidXRlc30pJHtvdXRwdXRGcmFnbWVudH0gVkFMVUVTICR7dHVwbGVTdHJ9O2ApO1xuICAgIH1cbiAgICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJhdGNoID0gTWF0aC5mbG9vcigyNTAgLyAoYWxsQXR0cmlidXRlcy5sZW5ndGggKyAxKSkgKyAxO1xuICAgIHdoaWxlIChvZmZzZXQgPCBNYXRoLm1heCh0dXBsZXMubGVuZ3RoLCAxKSkge1xuICAgICAgY29uc3QgdHVwbGVTdHIgPSB0dXBsZXMuc2xpY2Uob2Zmc2V0LCBNYXRoLm1pbih0dXBsZXMubGVuZ3RoLCBvZmZzZXQgKyBiYXRjaCkpO1xuICAgICAgbGV0IGdlbmVyYXRlZFF1ZXJ5ID0gYWxsUXVlcmllcy5tYXAodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2IDogdih0dXBsZVN0cikpLmpvaW4oJzsnKTtcbiAgICAgIGlmIChuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyKSB7XG4gICAgICAgIGdlbmVyYXRlZFF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT047ICR7Z2VuZXJhdGVkUXVlcnl9OyBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9GRjtgO1xuICAgICAgfVxuICAgICAgY29tbWFuZHMucHVzaChnZW5lcmF0ZWRRdWVyeSk7XG4gICAgICBvZmZzZXQgKz0gYmF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5qb2luKCc7Jyk7XG4gIH1cblxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qgc3FsID0gc3VwZXIudXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcyk7XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUFyZ3MgPSBgVVBEQVRFIFRPUCgke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgICAgc3FsLnF1ZXJ5ID0gc3FsLnF1ZXJ5LnJlcGxhY2UoJ1VQREFURScsIHVwZGF0ZUFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgdXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsKSB7XG4gICAgY29uc3QgdGFyZ2V0VGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3RhcmdldGApO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV9zb3VyY2VgKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5c0F0dHJzID0gW107XG4gICAgY29uc3QgaWRlbnRpdHlBdHRycyA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZUF0dHJzID0gW107XG4gICAgY29uc3QgdGFibGVOYW1lUXVvdGVkID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSBmYWxzZTtcblxuICAgIC8vT2J0YWluIHByaW1hcnlLZXlzLCB1bmlxdWVrZXlzIGFuZCBpZGVudGl0eSBhdHRycyBmcm9tIHJhd0F0dHJpYnV0ZXMgYXMgbW9kZWwgaXMgbm90IHBhc3NlZFxuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0ucHJpbWFyeUtleSkge1xuICAgICAgICBwcmltYXJ5S2V5c0F0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnVuaXF1ZSkge1xuICAgICAgICB1bmlxdWVBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGlkZW50aXR5QXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0FkZCB1bmlxdWUgaW5kZXhlcyBkZWZpbmVkIGJ5IGluZGV4ZXMgb3B0aW9uIHRvIHVuaXF1ZUF0dHJzXG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBtb2RlbC5faW5kZXhlcykge1xuICAgICAgaWYgKGluZGV4LnVuaXF1ZSAmJiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnID8gZmllbGQgOiBmaWVsZC5uYW1lIHx8IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAoIXVuaXF1ZUF0dHJzLmluY2x1ZGVzKGZpZWxkTmFtZSkgJiYgbW9kZWwucmF3QXR0cmlidXRlc1tmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICB1bmlxdWVBdHRycy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlS2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5cyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5c1F1b3RlZCA9IGluc2VydEtleXMubWFwKGtleSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGluc2VydFZhbHVlc0VzY2FwZWQgPSBpbnNlcnRLZXlzLm1hcChrZXkgPT4gdGhpcy5lc2NhcGUoaW5zZXJ0VmFsdWVzW2tleV0pKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlUXVlcnkgPSBgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDsgLy9WaXJ0dWFsIFRhYmxlXG4gICAgbGV0IGpvaW5Db25kaXRpb247XG5cbiAgICAvL0lERU5USVRZX0lOU0VSVCBDb25kaXRpb25cbiAgICBpZGVudGl0eUF0dHJzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICh1cGRhdGVWYWx1ZXNba2V5XSAmJiB1cGRhdGVWYWx1ZXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgLypcbiAgICAgICAgICogSURFTlRJVFlfSU5TRVJUIENvbHVtbiBDYW5ub3QgYmUgdXBkYXRlZCwgb25seSBpbnNlcnRlZFxuICAgICAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMDE3NjI1NC8yMjU0MzYwXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9GaWx0ZXIgTlVMTCBDbGF1c2VzXG4gICAgY29uc3QgY2xhdXNlcyA9IHdoZXJlW09wLm9yXS5maWx0ZXIoY2xhdXNlID0+IHtcbiAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAvKlxuICAgICAgICogRXhjbHVkZSBOVUxMIENvbXBvc2l0ZSBQSy9VSy4gUGFydGlhbCBDb21wb3NpdGUgY2xhdXNlcyBzaG91bGQgYWxzbyBiZSBleGNsdWRlZCBhcyBpdCBkb2Vzbid0IGd1YXJhbnRlZSBhIHNpbmdsZSByb3dcbiAgICAgICAqL1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhdXNlW2tleV0gPT09ICd1bmRlZmluZWQnIHx8IGNsYXVzZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIEdlbmVyYXRlIE9OIGNvbmRpdGlvbiB1c2luZyBQSyhzKS5cbiAgICAgKiBJZiBub3QsIGdlbmVyYXRlIHVzaW5nIFVLKHMpLiBFbHNlIHRocm93IGVycm9yXG4gICAgICovXG4gICAgY29uc3QgZ2V0Sm9pblNuaXBwZXQgPSBhcnJheSA9PiB7XG4gICAgICByZXR1cm4gYXJyYXkubWFwKGtleSA9PiB7XG4gICAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3NvdXJjZVRhYmxlQWxpYXN9LiR7a2V5fWA7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGNsYXVzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1hcnkgS2V5IG9yIFVuaXF1ZSBrZXkgc2hvdWxkIGJlIHBhc3NlZCB0byB1cHNlcnQgcXVlcnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VhcmNoIGZvciBwcmltYXJ5IGtleSBhdHRyaWJ1dGUgaW4gY2xhdXNlcyAtLSBNb2RlbCBjYW4gaGF2ZSB0d28gc2VwYXJhdGUgdW5pcXVlIGtleXNcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNsYXVzZXNba2V5XSk7XG4gICAgICAgIGlmIChwcmltYXJ5S2V5c0F0dHJzLmluY2x1ZGVzKGtleXNbMF0pKSB7XG4gICAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHByaW1hcnlLZXlzQXR0cnMpLmpvaW4oJyBBTkQgJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgham9pbkNvbmRpdGlvbikge1xuICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQodW5pcXVlQXR0cnMpLmpvaW4oJyBBTkQgJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBJREVOVElUWV9JTlNFUlQgQ29sdW1uIGZyb20gdXBkYXRlXG4gICAgY29uc3QgdXBkYXRlU25pcHBldCA9IHVwZGF0ZUtleXMuZmlsdGVyKGtleSA9PiAhaWRlbnRpdHlBdHRycy5pbmNsdWRlcyhrZXkpKVxuICAgICAgLm1hcChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXNjYXBlKHVwZGF0ZVZhbHVlc1trZXldKTtcbiAgICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7dmFsdWV9YDtcbiAgICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBjb25zdCBpbnNlcnRTbmlwcGV0ID0gYCgke2luc2VydEtleXNRdW90ZWR9KSBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgO1xuICAgIGxldCBxdWVyeSA9IGBNRVJHRSBJTlRPICR7dGFibGVOYW1lUXVvdGVkfSBXSVRIKEhPTERMT0NLKSBBUyAke3RhcmdldFRhYmxlQWxpYXN9IFVTSU5HICgke3NvdXJjZVRhYmxlUXVlcnl9KSBBUyAke3NvdXJjZVRhYmxlQWxpYXN9KCR7aW5zZXJ0S2V5c1F1b3RlZH0pIE9OICR7am9pbkNvbmRpdGlvbn1gO1xuICAgIHF1ZXJ5ICs9IGAgV0hFTiBNQVRDSEVEIFRIRU4gVVBEQVRFIFNFVCAke3VwZGF0ZVNuaXBwZXR9IFdIRU4gTk9UIE1BVENIRUQgVEhFTiBJTlNFUlQgJHtpbnNlcnRTbmlwcGV0fSBPVVRQVVQgJGFjdGlvbiwgSU5TRVJURUQuKjtgO1xuICAgIGlmIChuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyKSB7XG4gICAgICBxdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7dGFibGVOYW1lUXVvdGVkfSBPTjsgJHtxdWVyeX0gU0VUIElERU5USVRZX0lOU0VSVCAke3RhYmxlTmFtZVF1b3RlZH0gT0ZGO2A7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdERUxFVEUnLFxuICAgICAgb3B0aW9ucy5saW1pdCAmJiBgVE9QKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWAsXG4gICAgICAnRlJPTScsXG4gICAgICB0YWJsZSxcbiAgICAgIHdoZXJlQ2xhdXNlICYmIGBXSEVSRSAke3doZXJlQ2xhdXNlfWAsXG4gICAgICAnOycsXG4gICAgICAnU0VMRUNUIEBAUk9XQ09VTlQgQVMgQUZGRUNURURST1dTJyxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYEVYRUMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZSA9IE4nJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0nO2A7XG4gIH1cblxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYEVYRUMgc3BfaGVscGNvbnN0cmFpbnQgQG9iam5hbWUgPSAke3RoaXMuZXNjYXBlKHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpKX07YDtcbiAgfVxuXG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbignXycpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBgRFJPUCBJTkRFWCAke3RoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpfSBPTiAke3RoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpfWA7XG4gIH1cblxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgc2VsZiByZWZlcmVudGlhbCBjb25zdHJhaW50c1xuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuXG4gICAgICBpZiAoYXR0cmlidXRlLk1vZGVsICYmIGF0dHJpYnV0ZS5Nb2RlbC50YWJsZU5hbWUgPT09IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZygnTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBzZWxmIHJlZmVyZW5jaWFsIGNvbnN0cmFpbnRzLCAnXG4gICAgICAgICAgKyAnd2Ugd2lsbCByZW1vdmUgaXQgYnV0IHdlIHJlY29tbWVuZCByZXN0cnVjdHVyaW5nIHlvdXIgcXVlcnknKTtcbiAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gJyc7XG4gICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZTtcblxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUudmFsdWVzICYmICFhdHRyaWJ1dGUudmFsdWVzKSBhdHRyaWJ1dGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUudmFsdWVzO1xuXG4gICAgICAvLyBlbnVtcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwoKTtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ0hFQ0sgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKX0gSU4oJHthdHRyaWJ1dGUudmFsdWVzLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KS5qb2luKCcsICcpIH0pKWA7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoKTtcblxuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBOT1QgTlVMTCc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlLnByaW1hcnlLZXkgJiYgIVV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBOVUxMJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgSURFTlRJVFkoMSwxKSc7XG4gICAgfVxuXG4gICAgLy8gQmxvYnMvdGV4dHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0VmFsdWVcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgIT09ICdURVhUJyAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlICYmXG4gICAgICAgIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBVTklRVUUnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBQUklNQVJZIEtFWSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcignaWQnKX0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCAmJiB0eXBlb2YgYXR0cmlidXRlLmNvbW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHthdHRyaWJ1dGUuY29tbWVudH1gO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge30sXG4gICAgICBleGlzdGluZ0NvbnN0cmFpbnRzID0gW107XG4gICAgbGV0IGtleSxcbiAgICAgIGF0dHJpYnV0ZTtcblxuICAgIGZvciAoa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmIChleGlzdGluZ0NvbnN0cmFpbnRzLmluY2x1ZGVzKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgLy8gbm8gY2FzY2FkaW5nIGNvbnN0cmFpbnRzIHRvIGEgdGFibGUgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSAnJztcbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZ0NvbnN0cmFpbnRzLnB1c2goYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAvLyBOT1RFOiB0aGlzIHJlYWxseSBqdXN0IGRpc2FibGVzIGNhc2NhZGluZyB1cGRhdGVzIGZvciBhbGxcbiAgICAgICAgICAvLyAgICAgICBkZWZpbml0aW9ucy4gQ2FuIGJlIG1hZGUgbW9yZSByb2J1c3QgdG8gc3VwcG9ydCB0aGVcbiAgICAgICAgICAvLyAgICAgICBmZXcgY2FzZXMgd2hlcmUgTVNTUUwgYWN0dWFsbHkgc3VwcG9ydHMgdGhlbVxuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSAmJiAhYXR0cmlidXRlLmZpZWxkKSBhdHRyaWJ1dGUuZmllbGQgPSBrZXk7XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNyZWF0ZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ2NyZWF0ZVRyaWdnZXInKTtcbiAgfVxuXG4gIGRyb3BUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKCdkcm9wVHJpZ2dlcicpO1xuICB9XG5cbiAgcmVuYW1lVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZCgncmVuYW1lVHJpZ2dlcicpO1xuICB9XG5cbiAgY3JlYXRlRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ2NyZWF0ZUZ1bmN0aW9uJyk7XG4gIH1cblxuICBkcm9wRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ2Ryb3BGdW5jdGlvbicpO1xuICB9XG5cbiAgcmVuYW1lRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoJ3JlbmFtZUZ1bmN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgY29tbW9uIFNRTCBwcmVmaXggZm9yIEZvcmVpZ25LZXlzUXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRhbG9nTmFtZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoY2F0YWxvZ05hbWUpIHtcbiAgICByZXR1cm4gYCR7J1NFTEVDVCAnICtcbiAgICAgICAgJ2NvbnN0cmFpbnRfbmFtZSA9IE9CSi5OQU1FLCAnICtcbiAgICAgICAgJ2NvbnN0cmFpbnROYW1lID0gT0JKLk5BTUUsICd9JHtcbiAgICAgIGNhdGFsb2dOYW1lID8gYGNvbnN0cmFpbnRDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6ICcnXG4gICAgfWNvbnN0cmFpbnRTY2hlbWEgPSBTQ0hFTUFfTkFNRShPQkouU0NIRU1BX0lEKSwgYCArXG4gICAgICAgICd0YWJsZU5hbWUgPSBUQi5OQU1FLCAnICtcbiAgICAgICAgYHRhYmxlU2NoZW1hID0gU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSwgJHtcbiAgICAgICAgICBjYXRhbG9nTmFtZSA/IGB0YWJsZUNhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogJydcbiAgICAgICAgfWNvbHVtbk5hbWUgPSBDT0wuTkFNRSwgYCArXG4gICAgICAgIGByZWZlcmVuY2VkVGFibGVTY2hlbWEgPSBTQ0hFTUFfTkFNRShSVEIuU0NIRU1BX0lEKSwgJHtcbiAgICAgICAgICBjYXRhbG9nTmFtZSA/IGByZWZlcmVuY2VkQ2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiAnJ1xuICAgICAgICB9cmVmZXJlbmNlZFRhYmxlTmFtZSA9IFJUQi5OQU1FLCBgICtcbiAgICAgICAgJ3JlZmVyZW5jZWRDb2x1bW5OYW1lID0gUkNPTC5OQU1FICcgK1xuICAgICAgJ0ZST00gc3lzLmZvcmVpZ25fa2V5X2NvbHVtbnMgRktDICcgK1xuICAgICAgICAnSU5ORVIgSk9JTiBzeXMub2JqZWN0cyBPQkogT04gT0JKLk9CSkVDVF9JRCA9IEZLQy5DT05TVFJBSU5UX09CSkVDVF9JRCAnICtcbiAgICAgICAgJ0lOTkVSIEpPSU4gc3lzLnRhYmxlcyBUQiBPTiBUQi5PQkpFQ1RfSUQgPSBGS0MuUEFSRU5UX09CSkVDVF9JRCAnICtcbiAgICAgICAgJ0lOTkVSIEpPSU4gc3lzLmNvbHVtbnMgQ09MIE9OIENPTC5DT0xVTU5fSUQgPSBQQVJFTlRfQ09MVU1OX0lEIEFORCBDT0wuT0JKRUNUX0lEID0gVEIuT0JKRUNUX0lEICcgK1xuICAgICAgICAnSU5ORVIgSk9JTiBzeXMudGFibGVzIFJUQiBPTiBSVEIuT0JKRUNUX0lEID0gRktDLlJFRkVSRU5DRURfT0JKRUNUX0lEICcgK1xuICAgICAgICAnSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBSQ09MIE9OIFJDT0wuQ09MVU1OX0lEID0gUkVGRVJFTkNFRF9DT0xVTU5fSUQgQU5EIFJDT0wuT0JKRUNUX0lEID0gUlRCLk9CSkVDVF9JRCc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgYWxsIGZvcmVpZ24ga2V5cyBkZXRhaWxzIG9mIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGFsb2dOYW1lIGRhdGFiYXNlIG5hbWVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIGNhdGFsb2dOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGxldCBzcWwgPSBgJHt0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KGNhdGFsb2dOYW1lKVxuICAgIH0gV0hFUkUgVEIuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gO1xuXG4gICAgaWYgKHRhYmxlLnNjaGVtYSkge1xuICAgICAgc3FsICs9IGAgQU5EIFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCkgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICB0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KCksXG4gICAgICAnV0hFUkUnLFxuICAgICAgYFRCLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YCxcbiAgICAgICdBTkQnLFxuICAgICAgYENPTC5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZShhdHRyaWJ1dGVOYW1lKX1gLFxuICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKX1gXG4gICAgXSk7XG4gIH1cblxuICBnZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCBLLlRBQkxFX05BTUUgQVMgdGFibGVOYW1lLCcsXG4gICAgICAnSy5DT0xVTU5fTkFNRSBBUyBjb2x1bW5OYW1lLCcsXG4gICAgICAnSy5DT05TVFJBSU5UX05BTUUgQVMgY29uc3RyYWludE5hbWUnLFxuICAgICAgJ0ZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTIEFTIEMnLFxuICAgICAgJ0pPSU4gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0UgQVMgSycsXG4gICAgICAnT04gQy5UQUJMRV9OQU1FID0gSy5UQUJMRV9OQU1FJyxcbiAgICAgICdBTkQgQy5DT05TVFJBSU5UX0NBVEFMT0cgPSBLLkNPTlNUUkFJTlRfQ0FUQUxPRycsXG4gICAgICAnQU5EIEMuQ09OU1RSQUlOVF9TQ0hFTUEgPSBLLkNPTlNUUkFJTlRfU0NIRU1BJyxcbiAgICAgICdBTkQgQy5DT05TVFJBSU5UX05BTUUgPSBLLkNPTlNUUkFJTlRfTkFNRScsXG4gICAgICAnV0hFUkUgQy5DT05TVFJBSU5UX1RZUEUgPSBcXCdQUklNQVJZIEtFWVxcJycsXG4gICAgICBgQU5EIEsuQ09MVU1OX05BTUUgPSAke3dyYXBTaW5nbGVRdW90ZShhdHRyaWJ1dGVOYW1lKX1gLFxuICAgICAgYEFORCBLLlRBQkxFX05BTUUgPSAke3RhYmxlTmFtZX1gLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdEUk9QJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpXG4gICAgXSk7XG4gIH1cblxuICBnZXREZWZhdWx0Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ1NFTEVDVCBuYW1lIEZST00gc3lzLmRlZmF1bHRfY29uc3RyYWludHMnLFxuICAgICAgYFdIRVJFIFBBUkVOVF9PQkpFQ1RfSUQgPSBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGV9JywgJ1UnKWAsXG4gICAgICBgQU5EIFBBUkVOVF9DT0xVTU5fSUQgPSAoU0VMRUNUIGNvbHVtbl9pZCBGUk9NIHN5cy5jb2x1bW5zIFdIRVJFIE5BTUUgPSAoJyR7YXR0cmlidXRlTmFtZX0nKWAsXG4gICAgICBgQU5EIG9iamVjdF9pZCA9IE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZX0nLCAnVScpKWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgICdEUk9QIENPTlNUUkFJTlQnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoY29uc3RyYWludE5hbWUpLFxuICAgICAgJzsnXG4gICAgXSk7XG4gIH1cblxuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KCkge1xuXG4gIH1cblxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKDEwKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkUgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0JFR0lOIFRSQU5TQUNUSU9OOyc7XG4gIH1cblxuICBjb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiAnQ09NTUlUIFRSQU5TQUNUSU9OOyc7XG4gIH1cblxuICByb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFJPTExCQUNLIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuXG4gICAgcmV0dXJuICdST0xMQkFDSyBUUkFOU0FDVElPTjsnO1xuICB9XG5cbiAgc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbW9kZWwsIGF0dHJpYnV0ZXMsIHRhYmxlcywgbWFpblRhYmxlQXMsIHdoZXJlKSB7XG4gICAgdGhpcy5fdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZUFzIH0pO1xuXG4gICAgY29uc3QgZGJWZXJzaW9uID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb247XG4gICAgY29uc3QgaXNTUUxTZXJ2ZXIyMDA4ID0gc2VtdmVyLnZhbGlkKGRiVmVyc2lvbikgJiYgc2VtdmVyLmx0KGRiVmVyc2lvbiwgJzExLjAuMCcpO1xuXG4gICAgaWYgKGlzU1FMU2VydmVyMjAwOCAmJiBvcHRpb25zLm9mZnNldCkge1xuICAgICAgLy8gRm9yIGVhcmxpZXIgdmVyc2lvbnMgb2YgU1FMIHNlcnZlciwgd2UgbmVlZCB0byBuZXN0IHNldmVyYWwgcXVlcmllc1xuICAgICAgLy8gaW4gb3JkZXIgdG8gZW11bGF0ZSB0aGUgT0ZGU0VUIGJlaGF2aW9yLlxuICAgICAgLy9cbiAgICAgIC8vIDEuIFRoZSBvdXRlcm1vc3QgcXVlcnkgc2VsZWN0cyBhbGwgaXRlbXMgZnJvbSB0aGUgaW5uZXIgcXVlcnkgYmxvY2suXG4gICAgICAvLyAgICBUaGlzIGlzIGR1ZSB0byBhIGxpbWl0YXRpb24gaW4gU1FMIHNlcnZlciB3aXRoIHRoZSB1c2Ugb2YgY29tcHV0ZWRcbiAgICAgIC8vICAgIGNvbHVtbnMgKGUuZy4gU0VMRUNUIFJPV19OVU1CRVIoKS4uLkFTIHgpIGluIFdIRVJFIGNsYXVzZXMuXG4gICAgICAvLyAyLiBUaGUgbmV4dCBxdWVyeSBoYW5kbGVzIHRoZSBMSU1JVCBhbmQgT0ZGU0VUIGJlaGF2aW9yIGJ5IGdldHRpbmdcbiAgICAgIC8vICAgIHRoZSBUT1AgTiByb3dzIG9mIHRoZSBxdWVyeSB3aGVyZSB0aGUgcm93IG51bWJlciBpcyA+IE9GRlNFVFxuICAgICAgLy8gMy4gVGhlIGlubmVybW9zdCBxdWVyeSBpcyB0aGUgYWN0dWFsIHNldCB3ZSB3YW50IGluZm9ybWF0aW9uIGZyb21cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IGlzU3ViUXVlcnkgPSBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb247XG4gICAgICBsZXQgb3JkZXJzID0geyBtYWluUXVlcnlPcmRlcjogW10gfTtcbiAgICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JkZXJzLm1haW5RdWVyeU9yZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcmRlcnMubWFpblF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5wcmltYXJ5S2V5RmllbGQpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG1wVGFibGUgPSBtYWluVGFibGVBcyB8fCAnT2Zmc2V0VGFibGUnO1xuXG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgICdTRUxFQ1QgVE9QIDEwMCBQRVJDRU5UJyxcbiAgICAgICAgYXR0cmlidXRlcy5qb2luKCcsICcpLFxuICAgICAgICAnRlJPTSAoJyxcbiAgICAgICAgW1xuICAgICAgICAgICdTRUxFQ1QnLFxuICAgICAgICAgIG9wdGlvbnMubGltaXQgJiYgYFRPUCAke29wdGlvbnMubGltaXR9YCxcbiAgICAgICAgICAnKiBGUk9NICgnLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdTRUxFQ1QgUk9XX05VTUJFUigpIE9WRVIgKCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdPUkRFUiBCWScsXG4gICAgICAgICAgICAgIG9yZGVycy5tYWluUXVlcnlPcmRlci5qb2luKCcsICcpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYCkgYXMgcm93X251bSwgKiBGUk9NICR7dGFibGVzfSBBUyAke3RtcFRhYmxlfWAsXG4gICAgICAgICAgICB3aGVyZSAmJiBgV0hFUkUgJHt3aGVyZX1gXG4gICAgICAgICAgXSxcbiAgICAgICAgICBgKSBBUyAke3RtcFRhYmxlfSBXSEVSRSByb3dfbnVtID4gJHtvZmZzZXR9YFxuICAgICAgICBdLFxuICAgICAgICBgKSBBUyAke3RtcFRhYmxlfWBcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QnLFxuICAgICAgaXNTUUxTZXJ2ZXIyMDA4ICYmIG9wdGlvbnMubGltaXQgJiYgYFRPUCAke29wdGlvbnMubGltaXR9YCxcbiAgICAgIGF0dHJpYnV0ZXMuam9pbignLCAnKSxcbiAgICAgIGBGUk9NICR7dGFibGVzfWAsXG4gICAgICBtYWluVGFibGVBcyAmJiBgQVMgJHttYWluVGFibGVBc31gLFxuICAgICAgb3B0aW9ucy50YWJsZUhpbnQgJiYgVGFibGVIaW50c1tvcHRpb25zLnRhYmxlSGludF0gJiYgYFdJVEggKCR7VGFibGVIaW50c1tvcHRpb25zLnRhYmxlSGludF19KWBcbiAgICBdKTtcbiAgfVxuXG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgLy8gU2tpcCBoYW5kbGluZyBvZiBsaW1pdCBhbmQgb2Zmc2V0IGFzIHBvc3RmaXhlcyBmb3Igb2xkZXIgU1FMIFNlcnZlciB2ZXJzaW9uc1xuICAgIGlmIChzZW12ZXIudmFsaWQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24pICYmIHNlbXZlci5sdCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgJzExLjAuMCcpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcbiAgICBjb25zdCBpc1N1YlF1ZXJ5ID0gb3B0aW9ucy5zdWJRdWVyeSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvblxuICAgICAgOiBvcHRpb25zLnN1YlF1ZXJ5O1xuXG4gICAgbGV0IGZyYWdtZW50ID0gJyc7XG4gICAgbGV0IG9yZGVycyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxpbWl0IHx8IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMub3JkZXIgfHwgIW9wdGlvbnMub3JkZXIubGVuZ3RoIHx8IG9wdGlvbnMuaW5jbHVkZSAmJiAhb3JkZXJzLnN1YlF1ZXJ5T3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUGtGcmFnbWVudCA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlQXMgfHwgbW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwucHJpbWFyeUtleUZpZWxkKX1gO1xuICAgICAgICBpZiAoIW9wdGlvbnMub3JkZXIgfHwgIW9wdGlvbnMub3JkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgZnJhZ21lbnQgKz0gYCBPUkRFUiBCWSAke3RhYmxlUGtGcmFnbWVudH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9yZGVyRmllbGROYW1lcyA9IF8ubWFwKG9wdGlvbnMub3JkZXIsIG9yZGVyID0+IG9yZGVyWzBdKTtcbiAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5RmllbGRBbHJlYWR5UHJlc2VudCA9IF8uaW5jbHVkZXMob3JkZXJGaWVsZE5hbWVzLCBtb2RlbC5wcmltYXJ5S2V5RmllbGQpO1xuXG4gICAgICAgICAgaWYgKCFwcmltYXJ5S2V5RmllbGRBbHJlYWR5UHJlc2VudCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgKz0gb3B0aW9ucy5vcmRlciAmJiAhaXNTdWJRdWVyeSA/ICcsICcgOiAnIE9SREVSIEJZICc7XG4gICAgICAgICAgICBmcmFnbWVudCArPSB0YWJsZVBrRnJhZ21lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgT0ZGU0VUICR7dGhpcy5lc2NhcGUob2Zmc2V0KX0gUk9XU2A7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgRkVUQ0ggTkVYVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBST1dTIE9OTFlgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICB9XG59XG5cbi8vIHByaXZhdGUgbWV0aG9kc1xuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsIFwiJ1wiKSwgXCInXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1TU1FMUXVlcnlHZW5lcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9ycycpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlJyk7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSB0aGF0IFNlcXVlbGl6ZSB1c2VzIHRvIHRhbGsgd2l0aCBNU1NRTCBkYXRhYmFzZVxuICovXG5jbGFzcyBNU1NxbFF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICAvKipcbiAgKiBBIHdyYXBwZXIgdGhhdCBmaXhlcyBNU1NRTCdzIGluYWJpbGl0eSB0byBjbGVhbmx5IHJlbW92ZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzIGlmIHRoZXkgaGF2ZSBhIGRlZmF1bHQgY29uc3RyYWludC5cbiAgKlxuICAqIEBvdmVycmlkZVxuICAqL1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIHx8IHt9IH07XG5cbiAgICBjb25zdCBmaW5kQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0RGVmYXVsdENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIGNvbnN0IFtyZXN1bHRzMF0gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShmaW5kQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdHMwLmxlbmd0aCkge1xuICAgICAgLy8gTm8gZGVmYXVsdCBjb25zdHJhaW50IGZvdW5kIC0tIHdlIGNhbiBjbGVhbmx5IHJlbW92ZSB0aGUgY29sdW1uXG4gICAgICBjb25zdCBkcm9wQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdHMwWzBdLm5hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmaW5kRm9yZWlnbktleVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZmluZEZvcmVpZ25LZXlTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgLy8gTm8gZm9yZWlnbiBrZXkgY29uc3RyYWludHMgZm91bmQsIHNvIHdlIGNhbiByZW1vdmUgdGhlIGNvbHVtblxuICAgICAgY29uc3QgZHJvcEZvcmVpZ25LZXlTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCByZXN1bHRzWzBdLmNvbnN0cmFpbnRfbmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wRm9yZWlnbktleVNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY29sdW1uIGlzIGEgcHJpbWFyeUtleVxuICAgIGNvbnN0IHByaW1hcnlLZXlDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdF0gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShwcmltYXJ5S2V5Q29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRyb3BDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0WzBdLmNvbnN0cmFpbnROYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShyZW1vdmVTcWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHdoZXJlcyA9IFtdO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKCFVdGlscy5pc1doZXJlRW1wdHkod2hlcmUpKSB7XG4gICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgfVxuXG4gICAgLy8gTGV0cyBjb21iaW5lIHVuaXF1ZSBrZXlzIGFuZCBpbmRleGVzIGludG8gb25lXG4gICAgbGV0IGluZGV4ZXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLm1hcChpdGVtID0+IGl0ZW0uZmllbGRzKTtcbiAgICBpbmRleGVzID0gaW5kZXhlcy5jb25jYXQoT2JqZWN0LnZhbHVlcyhtb2RlbC5faW5kZXhlcykuZmlsdGVyKGl0ZW0gPT4gaXRlbS51bmlxdWUpLm1hcChpdGVtID0+IGl0ZW0uZmllbGRzKSk7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGlmIChfLmludGVyc2VjdGlvbihhdHRyaWJ1dGVzLCBpbmRleCkubGVuZ3RoID09PSBpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgd2hlcmUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleCkge1xuICAgICAgICAgIHdoZXJlW2ZpZWxkXSA9IGluc2VydFZhbHVlc1tmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoZXJlID0geyBbT3Aub3JdOiB3aGVyZXMgfTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnRzLk1TU3FsUXVlcnlJbnRlcmZhY2UgPSBNU1NxbFF1ZXJ5SW50ZXJmYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnknKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdtc3NxbCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuXG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3NxbDptc3NxbCcpO1xuXG5mdW5jdGlvbiBnZXRTY2FsZShhTnVtKSB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFOdW0pKSByZXR1cm4gMDtcbiAgbGV0IGUgPSAxO1xuICB3aGlsZSAoTWF0aC5yb3VuZChhTnVtICogZSkgLyBlICE9PSBhTnVtKSBlICo9IDEwO1xuICByZXR1cm4gTWF0aC5sb2cxMChlKTtcbn1cblxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gJ2lkJztcbiAgfVxuXG4gIGdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlLCBUWVBFUykge1xuICAgIGNvbnN0IHBhcmFtVHlwZSA9IHsgdHlwZTogVFlQRVMuVmFyQ2hhciwgdHlwZU9wdGlvbnM6IHt9IH07XG4gICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5OVmFyQ2hhcjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5JbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5CaWdJbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuTnVtZXJpYztcbiAgICAgICAgLy9EZWZhdWx0IHRvIGEgcmVhc29uYWJsZSBudW1lcmljIHByZWNpc2lvbi9zY2FsZSBwZW5kaW5nIG1vcmUgc29waGlzdGljYXRlZCBsb2dpY1xuICAgICAgICBwYXJhbVR5cGUudHlwZU9wdGlvbnMgPSB7IHByZWNpc2lvbjogMzAsIHNjYWxlOiBnZXRTY2FsZSh2YWx1ZSkgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkJpdDtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuVmFyQmluYXJ5O1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1UeXBlO1xuICB9XG5cbiAgYXN5bmMgX3J1bihjb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuXG4gICAgY29uc3QgcXVlcnkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBUUkFOU0FDVElPTiBTVVBQT1JUXG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoJ0JFR0lOIFRSQU5TQUNUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uYmVnaW5UcmFuc2FjdGlvbihlcnJvciA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lLCBjb25uZWN0aW9uLmxpYi5JU09MQVRJT05fTEVWRUxbb3B0aW9ucy5pc29sYXRpb25MZXZlbF0pO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKCdDT01NSVQgVFJBTlNBQ1RJT04nKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jb21taXRUcmFuc2FjdGlvbihlcnJvciA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoJ1JPTExCQUNLIFRSQU5TQUNUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucm9sbGJhY2tUcmFuc2FjdGlvbihlcnJvciA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aCgnU0FWRSBUUkFOU0FDVElPTicpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNhdmVUcmFuc2FjdGlvbihlcnJvciA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBjb25uZWN0aW9uLmxpYi5SZXF1ZXN0KHNxbCwgKGVyciwgcm93Q291bnQpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShbcm93cywgcm93Q291bnRdKSk7XG5cbiAgICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIF8uZm9yT3duKHBhcmFtZXRlcnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1UeXBlID0gdGhpcy5nZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSwgY29ubmVjdGlvbi5saWIuVFlQRVMpO1xuICAgICAgICAgIHJlcXVlc3QuYWRkUGFyYW1ldGVyKGtleSwgcGFyYW1UeXBlLnR5cGUsIHZhbHVlLCBwYXJhbVR5cGUudHlwZU9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbigncm93JywgY29sdW1ucyA9PiB7XG4gICAgICAgIHJvd3MucHVzaChjb2x1bW5zKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25uZWN0aW9uLmV4ZWNTcWwocmVxdWVzdCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcm93cywgcm93Q291bnQ7XG5cbiAgICB0cnkge1xuICAgICAgW3Jvd3MsIHJvd0NvdW50XSA9IGF3YWl0IHF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyLnNxbCA9IHNxbDtcbiAgICAgIGVyci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcblxuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnIpO1xuICAgIH1cblxuICAgIGNvbXBsZXRlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzKSkge1xuICAgICAgcm93cyA9IHJvd3MubWFwKGNvbHVtbnMgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgICAgIGNvbnN0IHR5cGVpZCA9IGNvbHVtbi5tZXRhZGF0YS50eXBlLmlkO1xuICAgICAgICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KHR5cGVpZCk7XG4gICAgICAgICAgbGV0IHZhbHVlID0gY29sdW1uLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYgISFwYXJzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvd1tjb2x1bW4ubWV0YWRhdGEuY29sTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyb3dzLCByb3dDb3VudCk7XG4gIH1cblxuICBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5xdWV1ZS5lbnF1ZXVlKCgpID0+IHRoaXMuX3J1bih0aGlzLmNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycykpO1xuICB9XG5cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0ge307XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlcykgPT4ge1xuICAgICAgaWYgKHZhbHVlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmluZFBhcmFtW2tleV0gPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgcmV0dXJuIGBAJHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuXG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cblxuICAvKipcbiAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeSBleGVjdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgcmVzdWx0IG9mIHRoZSBxdWVyeSBleGVjdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3dDb3VudFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZXhhbXBsZVxuICAgKiBFeGFtcGxlOlxuICAgKiAgcXVlcnkuZm9ybWF0UmVzdWx0cyhbXG4gICAqICAgIHtcbiAgICogICAgICBpZDogMSwgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIGF0dHIyOiAnc25hZnUnLCAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBtYWluIHRhYmxlXG4gICAqICAgICAgVGFza3MuaWQ6IDEsICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgICBUYXNrcy50aXRsZTogJ3Rhc2snIC8vIHRoaXMgaXMgZnJvbSB0aGUgYXNzb2NpYXRlZCB0YWJsZVxuICAgKiAgICB9XG4gICAqICBdKVxuICAgKi9cbiAgZm9ybWF0UmVzdWx0cyhkYXRhLCByb3dDb3VudCkge1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChfcmVzdWx0LkRlZmF1bHQpIHtcbiAgICAgICAgICBfcmVzdWx0LkRlZmF1bHQgPSBfcmVzdWx0LkRlZmF1bHQucmVwbGFjZShcIignXCIsICcnKS5yZXBsYWNlKFwiJylcIiwgJycpLnJlcGxhY2UoLycvZywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0LklzTnVsbCA9PT0gJ1lFUycgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5Db25zdHJhaW50ID09PSAnUFJJTUFSWSBLRVknLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IF9yZXN1bHQuSXNJZGVudGl0eSA9PT0gMSxcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZS5pbmNsdWRlcygnQ0hBUicpXG4gICAgICAgICAgJiYgX3Jlc3VsdC5MZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKF9yZXN1bHQuTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZSArPSAnKE1BWCknO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlICs9IGAoJHtfcmVzdWx0Lkxlbmd0aH0pYDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3dDb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0gPyBkYXRhWzBdLkFGRkVDVEVEUk9XUyA6IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIGRhdGFbMF0uJGFjdGlvbiA9PT0gJ0lOU0VSVCddO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAocmVzdWx0U2V0ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpIHtcbiAgICAvL0NvbnZlcnQgc25ha2VfY2FzZSBrZXlzIHRvIGNhbWVsQ2FzZSBhcyBpdCdzIGdlbmVyYXRlZCBieSBzdG9yZWQgcHJvY2VkdXJlXG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMSkubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgY29uc3RyYWludFtfLmNhbWVsQ2FzZShrZXkpXSA9IHJlc3VsdFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgfSk7XG4gIH1cblxuICBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBsZXQgbWF0Y2g7XG5cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9WaW9sYXRpb24gb2YgKD86VU5JUVVFfFBSSU1BUlkpIEtFWSBjb25zdHJhaW50ICcoW14nXSopJy4gQ2Fubm90IGluc2VydCBkdXBsaWNhdGUga2V5IGluIG9iamVjdCAnLionLig6PyBUaGUgZHVwbGljYXRlIGtleSB2YWx1ZSBpcyBcXCgoLiopXFwpLik/Lyk7XG4gICAgbWF0Y2ggPSBtYXRjaCB8fCBlcnIubWVzc2FnZS5tYXRjaCgvQ2Fubm90IGluc2VydCBkdXBsaWNhdGUga2V5IHJvdyBpbiBvYmplY3QgLiogd2l0aCB1bmlxdWUgaW5kZXggJyguKiknLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW21hdGNoWzFdXTtcbiAgICAgIGxldCBtZXNzYWdlID0gJ1ZhbGlkYXRpb24gZXJyb3InO1xuXG4gICAgICBpZiAodW5pcXVlS2V5ICYmICEhdW5pcXVlS2V5Lm1zZykge1xuICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaFszXS5zcGxpdCgnLCcpLm1hcChwYXJ0ID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW21hdGNoWzFdXSA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICB0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLFxuICAgICAgICAgICd1bmlxdWUgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5EQixcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICdub3RfdW5pcXVlJ1xuICAgICAgICApKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRmFpbGVkIG9uIHN0ZXAgJyguKiknLkNvdWxkIG5vdCBjcmVhdGUgY29uc3RyYWludC4gU2VlIHByZXZpb3VzIGVycm9ycy4vKSB8fFxuICAgICAgZXJyLm1lc3NhZ2UubWF0Y2goL1RoZSBERUxFVEUgc3RhdGVtZW50IGNvbmZsaWN0ZWQgd2l0aCB0aGUgUkVGRVJFTkNFIGNvbnN0cmFpbnQgXCIoLiopXCIuIFRoZSBjb25mbGljdCBvY2N1cnJlZCBpbiBkYXRhYmFzZSBcIiguKilcIiwgdGFibGUgXCIoLiopXCIsIGNvbHVtbiAnKC4qKScuLykgfHxcbiAgICAgIGVyci5tZXNzYWdlLm1hdGNoKC9UaGUgKD86SU5TRVJUfE1FUkdFfFVQREFURSkgc3RhdGVtZW50IGNvbmZsaWN0ZWQgd2l0aCB0aGUgRk9SRUlHTiBLRVkgY29uc3RyYWludCBcIiguKilcIi4gVGhlIGNvbmZsaWN0IG9jY3VycmVkIGluIGRhdGFiYXNlIFwiKC4qKVwiLCB0YWJsZSBcIiguKilcIiwgY29sdW1uICcoLiopJy4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIGZpZWxkczogbnVsbCxcbiAgICAgICAgaW5kZXg6IG1hdGNoWzFdLFxuICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvQ291bGQgbm90IGRyb3AgY29uc3RyYWludC4gU2VlIHByZXZpb3VzIGVycm9ycy4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnQgPSBlcnIuc3FsLm1hdGNoKC8oPzpjb25zdHJhaW50fGluZGV4KSBcXFsoLis/KVxcXS9pKTtcbiAgICAgIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50ID8gY29uc3RyYWludFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIGxldCB0YWJsZSA9IGVyci5zcWwubWF0Y2goL3RhYmxlIFxcWyguKz8pXFxdL2kpO1xuICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogbWF0Y2hbMV0sXG4gICAgICAgIGNvbnN0cmFpbnQsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIpO1xuICB9XG5cbiAgaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzZWxlY3QgYy5jb2x1bW5fbmFtZSBhcyAnbmFtZScsIGMuZGF0YV90eXBlIGFzICd0eXBlJywgYy5pc19udWxsYWJsZSBhcyAnaXNudWxsJ1wiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdzZWxlY3QgdGFibGVuYW1lID0gdC5uYW1lLCBuYW1lID0gaW5kLm5hbWUsJyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2V4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZScpO1xuICB9XG5cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgLy8gR3JvdXAgYnkgaW5kZXggbmFtZSwgYW5kIGNvbGxlY3QgYWxsIGZpZWxkc1xuICAgIGRhdGEgPSBkYXRhLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoIShpdGVtLmluZGV4X25hbWUgaW4gYWNjKSkge1xuICAgICAgICBhY2NbaXRlbS5pbmRleF9uYW1lXSA9IGl0ZW07XG4gICAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uaW5kZXhfa2V5cy5zcGxpdCgnLCcpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgbGV0IGNvbHVtbk5hbWUgPSBjb2x1bW4udHJpbSgpO1xuICAgICAgICBpZiAoY29sdW1uTmFtZS5pbmNsdWRlcygnKC0pJykpIHtcbiAgICAgICAgICBjb2x1bW5OYW1lID0gY29sdW1uTmFtZS5yZXBsYWNlKCcoLSknLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBhY2NbaXRlbS5pbmRleF9uYW1lXS5maWVsZHMucHVzaCh7XG4gICAgICAgICAgYXR0cmlidXRlOiBjb2x1bW5OYW1lLFxuICAgICAgICAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAgICAgIG9yZGVyOiBjb2x1bW4uaW5jbHVkZXMoJygtKScpID8gJ0RFU0MnIDogJ0FTQycsXG4gICAgICAgICAgY29sbGF0ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgaXRlbS5pbmRleF9rZXlzO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gXy5tYXAoZGF0YSwgaXRlbSA9PiAoe1xuICAgICAgcHJpbWFyeTogaXRlbS5pbmRleF9uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgncGsnKSxcbiAgICAgIGZpZWxkczogaXRlbS5maWVsZHMsXG4gICAgICBuYW1lOiBpdGVtLmluZGV4X25hbWUsXG4gICAgICB0YWJsZU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgIHVuaXF1ZTogaXRlbS5pbmRleF9kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd1bmlxdWUnKSxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgfVxuXG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIC8vIGFkZCB0aGUgaW5zZXJ0ZWQgcm93IGlkIHRvIHRoZSBpbnN0YW5jZVxuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICBsZXQgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gbnVsbDtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUpICYmXG4gICAgICAgIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQ7XG5cbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZV07XG4gICAgICBpZCA9IGlkIHx8IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyAmJiByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzXTtcblxuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50QXR0cmlidXRlXSA9IGlkO1xuXG4gICAgICBpZiAodGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHNbMF0pIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHNbMF0sIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlc3VsdHNbMF1ba2V5XTtcbiAgXG4gICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5maWVsZE5hbWUgPT09IGtleSB8fCBhdHRyaWJ1dGUuZmllbGQgPT09IGtleSk7XG4gIFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykubXlzcWw7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOm15c3FsJyk7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ215c3FsJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIE15U1FMIENvbm5lY3Rpb24gTWFuYWdlclxuICpcbiAqIEdldCBjb25uZWN0aW9ucywgdmFsaWRhdGUgYW5kIGRpc2Nvbm5lY3QgdGhlbS5cbiAqIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgcG9vbGluZyB1c2UgaXQgdG8gaGFuZGxlIE15U1FMIHNwZWNpZmljIGNvbm5lY3Rpb25zXG4gKiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL3NpZG9yYXJlcy9ub2RlLW15c3FsMiB0byBjb25uZWN0IHdpdGggTXlTUUwgc2VydmVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKCdteXNxbDInKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cblxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuXG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHdpdGggTXlTUUwgZGF0YWJhc2UgYmFzZWQgb24gY29uZmlnLCBIYW5kbGUgYW55IGVycm9ycyBpbiBjb25uZWN0aW9uXG4gICAqIFNldCB0aGUgcG9vbCBoYW5kbGVycyBvbiBjb25uZWN0aW9uLmVycm9yXG4gICAqIEFsc28gc2V0IHByb3BlciB0aW1lem9uZSBvbmNlIGNvbm5lY3Rpb24gaXMgY29ubmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0ge1xuICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIGZsYWdzOiAnLUZPVU5EX1JPV1MnLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICB0aW1lem9uZTogdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSxcbiAgICAgIHR5cGVDYXN0OiBDb25uZWN0aW9uTWFuYWdlci5fdHlwZWNhc3QuYmluZCh0aGlzKSxcbiAgICAgIGJpZ051bWJlclN0cmluZ3M6IGZhbHNlLFxuICAgICAgc3VwcG9ydEJpZ051bWJlcnM6IHRydWUsXG4gICAgICAuLi5jb25maWcuZGlhbGVjdE9wdGlvbnNcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmxpYi5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuXG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAgIC8vIGNsZWFuIHVwIGNvbm5lY3QgJiBlcnJvciBldmVudCBpZiB0aGVyZSBpcyBlcnJvclxuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIC8vIGNsZWFuIHVwIGVycm9yIGV2ZW50IGlmIGNvbm5lY3RlZFxuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25uZWN0aW9uLm9uY2UgZm9yIGVycm9yIGV2ZW50IGhhbmRsaW5nIGhlcmVcbiAgICAgICAgLy8gbXlzcWwyIGVtaXQgZXJyb3IgdHdvIHRpbWVzIGluIGNhc2UgaGFuZHNoYWtlIHdhcyBmYWlsZWRcbiAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgcHJvdG9jb2xfbG9zdCBhbmQgc2Vjb25kIGlzIHRpbWVvdXRcbiAgICAgICAgLy8gaWYgd2Ugd2lsbCB1c2UgYG9uY2UuZXJyb3JgIG5vZGUgcHJvY2VzcyB3aWxsIGNyYXNoIG9uIDJuZCBlcnJvciBlbWl0XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdjb25uZWN0JywgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGFjcXVpcmVkJyk7XG4gICAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSAnRVNPQ0tFVCc6XG4gICAgICAgICAgY2FzZSAnRUNPTk5SRVNFVCc6XG4gICAgICAgICAgY2FzZSAnRVBJUEUnOlxuICAgICAgICAgIGNhc2UgJ1BST1RPQ09MX0NPTk5FQ1RJT05fTE9TVCc6XG4gICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgICAgLy8gc2V0IHRpbWV6b25lIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gYnV0IG5hbWVkIHRpbWV6b25lIGFyZSBub3QgZGlyZWN0bHkgc3VwcG9ydGVkIGluIG15c3FsLCBzbyBnZXQgaXRzIG9mZnNldCBmaXJzdFxuICAgICAgICBsZXQgdHpPZmZzZXQgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lO1xuICAgICAgICB0ek9mZnNldCA9IC9cXC8vLnRlc3QodHpPZmZzZXQpID8gbW9tZW50VHoudHoodHpPZmZzZXQpLmZvcm1hdCgnWicpIDogdHpPZmZzZXQ7XG4gICAgICAgIGF3YWl0IHByb21pc2lmeShjYiA9PiBjb25uZWN0aW9uLnF1ZXJ5KGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2AsIGNiKSkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ0VDT05OUkVGVVNFRCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VSX0FDQ0VTU19ERU5JRURfRVJST1InOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRU5PVEZPVU5EJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgJ0VIT1NUVU5SRUFDSCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSAnRUlOVkFMJzpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIC8vIERvbid0IGRpc2Nvbm5lY3QgY29ubmVjdGlvbnMgd2l0aCBDTE9TRUQgc3RhdGVcbiAgICBpZiAoY29ubmVjdGlvbi5fY2xvc2luZykge1xuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeShjYWxsYmFjayA9PiBjb25uZWN0aW9uLmVuZChjYWxsYmFjaykpKCk7XG4gIH1cblxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25cbiAgICAgICYmICFjb25uZWN0aW9uLl9mYXRhbEVycm9yXG4gICAgICAmJiAhY29ubmVjdGlvbi5fcHJvdG9jb2xFcnJvclxuICAgICAgJiYgIWNvbm5lY3Rpb24uX2Nsb3NpbmdcbiAgICAgICYmICFjb25uZWN0aW9uLnN0cmVhbS5kZXN0cm95ZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHdreCA9IHJlcXVpcmUoJ3dreCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUeXBlcyA9PiB7XG4gIEJhc2VUeXBlcy5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gJ2h0dHBzOi8vZGV2Lm15c3FsLmNvbS9kb2MvcmVmbWFuLzUuNy9lbi9kYXRhLXR5cGVzLmh0bWwnO1xuXG4gIC8qKlxuICAgKiB0eXBlczogW2J1ZmZlcl90eXBlLCAuLi5dXG4gICAqXG4gICAqIEBzZWUgYnVmZmVyX3R5cGUgaGVyZSBodHRwczovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjcvZW4vYy1hcGktcHJlcGFyZWQtc3RhdGVtZW50LXR5cGUtY29kZXMuaHRtbFxuICAgKiBAc2VlIGhleCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWRvcmFyZXMvbm9kZS1teXNxbDIvYmxvYi9tYXN0ZXIvbGliL2NvbnN0YW50cy90eXBlcy5qc1xuICAgKi9cblxuICBCYXNlVHlwZXMuREFURS50eXBlcy5teXNxbCA9IFsnREFURVRJTUUnXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5teXNxbCA9IFsnVkFSX1NUUklORyddO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5teXNxbCA9IFsnU1RSSU5HJ107XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm15c3FsID0gWydCTE9CJ107XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm15c3FsID0gWydUSU5ZJ107XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5teXNxbCA9IFsnU0hPUlQnXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5teXNxbCA9IFsnSU5UMjQnXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubXlzcWwgPSBbJ0xPTkcnXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5teXNxbCA9IFsnTE9OR0xPTkcnXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm15c3FsID0gWydGTE9BVCddO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5teXNxbCA9IFsnVElNRSddO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubXlzcWwgPSBbJ0RBVEUnXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubXlzcWwgPSBbJ1RJTlknXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubXlzcWwgPSBbJ1RJTllCTE9CJywgJ0JMT0InLCAnTE9OR0JMT0InXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubXlzcWwgPSBbJ05FV0RFQ0lNQUwnXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubXlzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubXlzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubXlzcWwgPSBbJ0RPVUJMRSddO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm15c3FsID0gWydET1VCTEUnXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm15c3FsID0gWydHRU9NRVRSWSddO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5teXNxbCA9IFsnSlNPTiddO1xuXG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHN1cGVyLnRvU3FsKCk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSAnIFVOU0lHTkVEJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICBkZWZpbml0aW9uICs9ICcgWkVST0ZJTEwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPyBgREFURVRJTUUoJHt0aGlzLl9sZW5ndGh9KWAgOiAnREFURVRJTUUnO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgLy8gRnJhY3Rpb25hbCBEQVRFVElNRXMgb25seSBzdXBwb3J0ZWQgb24gTXlTUUwgNS42LjQrXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcy5TU1MnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbTpzcycpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vbWVudC50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50LnR6KHZhbHVlLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGAke3ZhbHVlfSAke29wdGlvbnMudGltZXpvbmV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZygpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdDSEFSKDM2KSBCSU5BUlknO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IFNVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUyA9IFsnUE9JTlQnLCAnTElORVNUUklORycsICdQT0xZR09OJ107XG5cbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICAgIHN1cGVyKHR5cGUsIHNyaWQpO1xuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMua2V5O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoU1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTLmluY2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy50eXBlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlcyBhcmU6ICR7U1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXIoKTtcbiAgICAgIC8vIEVtcHR5IGJ1ZmZlciwgTXlTUUwgZG9lc24ndCBzdXBwb3J0IFBPSU5UIEVNUFRZXG4gICAgICAvLyBjaGVjaywgaHR0cHM6Ly9kZXYubXlzcWwuY29tL3dvcmtsb2cvdGFzay8/aWQ9MjM4MVxuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBGb3Igc29tZSByZWFzb24sIGRpc2NhcmQgdGhlIGZpcnN0IDQgYnl0ZXNcbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoNCk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKHZhbHVlKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcWxUeXBlO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBFTlVNKCR7dGhpcy52YWx1ZXMubWFwKHZhbHVlID0+IG9wdGlvbnMuZXNjYXBlKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09ICd3aGVyZScgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgRU5VTSxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFVVSUQsXG4gICAgR0VPTUVUUlksXG4gICAgREVDSU1BTCxcbiAgICBKU09OOiBKU09OVFlQRVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QnKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLm15c3FsO1xuY29uc3QgeyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuL3F1ZXJ5LWludGVyZmFjZScpO1xuXG5jbGFzcyBNeXNxbERpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNeVNRTFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblxuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgJ1ZBTFVFUyAoKSc6IHRydWUsXG4gICdMSU1JVCBPTiBVUERBVEUnOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBmb3JTaGFyZTogJ0xPQ0sgSU4gU0hBUkUgTU9ERScsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiBmYWxzZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6ICcgSUdOT1JFJyxcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogJyBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSdcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcGFyc2VyOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IDFcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2UsXG4gICAgY2hlY2s6IGZhbHNlXG4gIH0sXG4gIGluZGV4VmlhQWx0ZXI6IHRydWUsXG4gIGluZGV4SGludHM6IHRydWUsXG4gIE5VTUVSSUM6IHRydWUsXG4gIEdFT01FVFJZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBSRUdFWFA6IHRydWVcbn0pO1xuXG5NeXNxbERpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gJzUuNy4wJztcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnlHZW5lcmF0b3IgPSBRdWVyeUdlbmVyYXRvcjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gJ215c3FsJztcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ2AnO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IE15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBNeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblxubW9kdWxlLmV4cG9ydHMgPSBNeXNxbERpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9ycycpO1xuXG5cbmNvbnN0IEpTT05fRlVOQ1RJT05fUkVHRVggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbmNvbnN0IEpTT05fT1BFUkFUT1JfUkVHRVggPSAvXlxccyooLT4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG5jb25zdCBUT0tFTl9DQVBUVVJFX1JFR0VYID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5jb25zdCBGT1JFSUdOX0tFWV9GSUVMRFMgPSBbXG4gICdDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludF9uYW1lJyxcbiAgJ0NPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50TmFtZScsXG4gICdDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50U2NoZW1hJyxcbiAgJ0NPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRDYXRhbG9nJyxcbiAgJ1RBQkxFX05BTUUgYXMgdGFibGVOYW1lJyxcbiAgJ1RBQkxFX1NDSEVNQSBhcyB0YWJsZVNjaGVtYScsXG4gICdUQUJMRV9TQ0hFTUEgYXMgdGFibGVDYXRhbG9nJyxcbiAgJ0NPTFVNTl9OQU1FIGFzIGNvbHVtbk5hbWUnLFxuICAnUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlU2NoZW1hJyxcbiAgJ1JFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2cnLFxuICAnUkVGRVJFTkNFRF9UQUJMRV9OQU1FIGFzIHJlZmVyZW5jZWRUYWJsZU5hbWUnLFxuICAnUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSBhcyByZWZlcmVuY2VkQ29sdW1uTmFtZSdcbl0uam9pbignLCcpO1xuXG5jb25zdCB0eXBlV2l0aG91dERlZmF1bHQgPSBuZXcgU2V0KFsnQkxPQicsICdURVhUJywgJ0dFT01FVFJZJywgJ0pTT04nXSk7XG5cbmNsYXNzIE15U1FMUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5PcGVyYXRvck1hcCA9IHtcbiAgICAgIC4uLnRoaXMuT3BlcmF0b3JNYXAsXG4gICAgICBbT3AucmVnZXhwXTogJ1JFR0VYUCcsXG4gICAgICBbT3Aubm90UmVnZXhwXTogJ05PVCBSRUdFWFAnXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQ1JFQVRFIERBVEFCQVNFIElGIE5PVCBFWElTVFMnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSQUNURVIgU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jaGFyc2V0KX1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBERUZBVUxUIENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpfTtgO1xuICB9XG5cbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHJldHVybiAnU0hPVyBUQUJMRVMnO1xuICB9XG5cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gJ1NIT1cgVEFCTEVTJztcbiAgfVxuXG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gJ1NFTEVDVCBWRVJTSU9OKCkgYXMgYHZlcnNpb25gJztcbiAgfVxuXG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGVuZ2luZTogJ0lubm9EQicsXG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgcm93Rm9ybWF0OiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdO1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0ge307XG4gICAgY29uc3QgYXR0clN0ciA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgIGxldCBtYXRjaDtcblxuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKSB7XG4gICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgICAvLyBNeVNRTCBkb2Vzbid0IHN1cHBvcnQgaW5saW5lIFJFRkVSRU5DRVMgZGVjbGFyYXRpb25zOiBtb3ZlIHRvIHRoZSBlbmRcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnJyl9YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnJyl9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICAvLyBNeVNRTCBkb2Vzbid0IHN1cHBvcnQgaW5saW5lIFJFRkVSRU5DRVMgZGVjbGFyYXRpb25zOiBtb3ZlIHRvIHRoZSBlbmRcbiAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBhdHRyaWJ1dGVzQ2xhdXNlID0gYXR0clN0ci5qb2luKCcsICcpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKHBrID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbignLCAnKTtcblxuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oJ18nKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFVOSVFVRSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9ICgke2NvbHVtbnMuZmllbGRzLm1hcChmaWVsZCA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMnLFxuICAgICAgdGFibGUsXG4gICAgICBgKCR7YXR0cmlidXRlc0NsYXVzZX0pYCxcbiAgICAgIGBFTkdJTkU9JHtvcHRpb25zLmVuZ2luZX1gLFxuICAgICAgb3B0aW9ucy5jb21tZW50ICYmIHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdzdHJpbmcnICYmIGBDT01NRU5UICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb21tZW50KX1gLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJTRVQ9JHtvcHRpb25zLmNoYXJzZXR9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgQ09MTEFURSAke29wdGlvbnMuY29sbGF0ZX1gLFxuICAgICAgb3B0aW9ucy5pbml0aWFsQXV0b0luY3JlbWVudCAmJiBgQVVUT19JTkNSRU1FTlQ9JHtvcHRpb25zLmluaXRpYWxBdXRvSW5jcmVtZW50fWAsXG4gICAgICBvcHRpb25zLnJvd0Zvcm1hdCAmJiBgUk9XX0ZPUk1BVD0ke29wdGlvbnMucm93Rm9ybWF0fWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUoXG4gICAgICB0aGlzLmFkZFNjaGVtYSh7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXJcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiBgU0hPVyBGVUxMIENPTFVNTlMgRlJPTSAke3RhYmxlfTtgO1xuICB9XG5cbiAgc2hvd1RhYmxlc1F1ZXJ5KGRhdGFiYXNlKSB7XG4gICAgbGV0IHF1ZXJ5ID0gJ1NFTEVDVCBUQUJMRV9OQU1FIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gXFwnQkFTRSBUQUJMRVxcJyc7XG4gICAgaWYgKGRhdGFiYXNlKSB7XG4gICAgICBxdWVyeSArPSBgIEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKGRhdGFiYXNlKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSArPSAnIEFORCBUQUJMRV9TQ0hFTUEgTk9UIElOIChcXCdNWVNRTFxcJywgXFwnSU5GT1JNQVRJT05fU0NIRU1BXFwnLCBcXCdQRVJGT1JNQU5DRV9TQ0hFTUFcXCcsIFxcJ1NZU1xcJyknO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cblxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdBTFRFUiBUQUJMRScsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgJ0FERCcsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwge1xuICAgICAgICBjb250ZXh0OiAnYWRkQ29sdW1uJyxcbiAgICAgICAgdGFibGVOYW1lOiB0YWJsZSxcbiAgICAgICAgZm9yZWlnbktleToga2V5XG4gICAgICB9KSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0RST1AnLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcbiAgICBjb25zdCBjb25zdHJhaW50U3RyaW5nID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sICcnKTtcbiAgICAgICAgY29uc3RyYWludFN0cmluZy5wdXNoKGBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHJpbmcucHVzaChgXFxgJHthdHRyaWJ1dGVOYW1lfVxcYCBcXGAke2F0dHJpYnV0ZU5hbWV9XFxgICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyU3RyaW5nLmxlbmd0aCAmJiBgQ0hBTkdFICR7YXR0clN0cmluZy5qb2luKCcsICcpfWAsXG4gICAgICBjb25zdHJhaW50U3RyaW5nLmxlbmd0aCAmJiBgQUREICR7Y29uc3RyYWludFN0cmluZy5qb2luKCcsICcpfWAsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgYXR0clN0cmluZy5wdXNoKGBcXGAke2F0dHJCZWZvcmV9XFxgIFxcYCR7YXR0ck5hbWV9XFxgICR7ZGVmaW5pdGlvbn1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnQUxURVIgVEFCTEUnLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICAnQ0hBTkdFJyxcbiAgICAgIGF0dHJTdHJpbmcuam9pbignLCAnKSxcbiAgICAgICc7J1xuICAgIF0pO1xuICB9XG5cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgLy8gUGFyc2UgbmVzdGVkIG9iamVjdFxuICAgICAgaWYgKHNtdGguY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChzbXRoLmNvbmRpdGlvbnMpLm1hcChjb25kaXRpb24gPT5cbiAgICAgICAgICBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKCcgQU5EICcpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBsZXQgc3RyO1xuXG4gICAgICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgY29uZGl0aW9ucyB1c2luZyB0aGUgc3FsaXRlIGpzb24gZnVuY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzbXRoLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gc210aC5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsc28gc3VwcG9ydCBqc29uIHByb3BlcnR5IGFjY2Vzc29yc1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoc210aC5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc210aC52YWx1ZSkge1xuICAgICAgICAgIHN0ciArPSB1dGlsLmZvcm1hdCgnID0gJXMnLCB0aGlzLmVzY2FwZShzbXRoLnZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmICgvdGltZXN0YW1wL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9ICdkYXRldGltZSc7XG4gICAgICB9IGVsc2UgaWYgKHNtdGguanNvbiAmJiAvYm9vbGVhbi9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICAvLyB0cnVlIG9yIGZhbHNlIGNhbm5vdCBiZSBjYXN0ZWQgYXMgYm9vbGVhbnMgd2l0aGluIGEgSlNPTiBzdHJ1Y3R1cmVcbiAgICAgICAgc210aC50eXBlID0gJ2NoYXInO1xuICAgICAgfSBlbHNlIGlmICgvZG91YmxlIHByZWNpc2lvbi9pLnRlc3Qoc210aC50eXBlKSB8fCAvYm9vbGVhbi9pLnRlc3Qoc210aC50eXBlKSB8fCAvaW50ZWdlci9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSAnZGVjaW1hbCc7XG4gICAgICB9IGVsc2UgaWYgKC90ZXh0L2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9ICdjaGFyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cblxuICBfdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgICAvLyB0cnVlL2ZhbHNlIGFyZSBzdG9yZWQgYXMgc3RyaW5ncyBpbiBteXNxbFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIG51bGwgaXMgc3RvcmVkIGFzIGEgc3RyaW5nIGluIG15c3FsXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cblxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgbGV0IGxpbWl0ID0gJyc7XG4gICAgbGV0IHF1ZXJ5ID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBsaW1pdCA9IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX1gO1xuICAgIH1cblxuICAgIHdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcblxuICAgIGlmICh3aGVyZSkge1xuICAgICAgcXVlcnkgKz0gYCBXSEVSRSAke3doZXJlfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5ICsgbGltaXQ7XG4gIH1cblxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBTSE9XIElOREVYIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmRhdGFiYXNlICYmIGBGUk9NIFxcYCR7b3B0aW9ucy5kYXRhYmFzZX1cXGBgXG4gICAgXSk7XG4gIH1cblxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYTtcblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QgQ09OU1RSQUlOVF9DQVRBTE9HIEFTIGNvbnN0cmFpbnRDYXRhbG9nLCcsXG4gICAgICAnQ09OU1RSQUlOVF9OQU1FIEFTIGNvbnN0cmFpbnROYW1lLCcsXG4gICAgICAnQ09OU1RSQUlOVF9TQ0hFTUEgQVMgY29uc3RyYWludFNjaGVtYSwnLFxuICAgICAgJ0NPTlNUUkFJTlRfVFlQRSBBUyBjb25zdHJhaW50VHlwZSwnLFxuICAgICAgJ1RBQkxFX05BTUUgQVMgdGFibGVOYW1lLCcsXG4gICAgICAnVEFCTEVfU0NIRU1BIEFTIHRhYmxlU2NoZW1hJyxcbiAgICAgICdmcm9tIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UUycsXG4gICAgICBgV0hFUkUgdGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9J2AsXG4gICAgICBjb25zdHJhaW50TmFtZSAmJiBgQU5EIGNvbnN0cmFpbnRfbmFtZSA9ICcke2NvbnN0cmFpbnROYW1lfSdgLFxuICAgICAgc2NoZW1hTmFtZSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICcke3NjaGVtYU5hbWV9J2AsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbignXycpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdEUk9QIElOREVYJyxcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSksXG4gICAgICAnT04nLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICBdKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZyA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKHsgZXNjYXBlOiB0aGlzLmVzY2FwZS5iaW5kKHRoaXMpIH0pO1xuICAgIGxldCB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZVN0cmluZztcblxuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gJyBOT1QgTlVMTCc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIGF1dG9faW5jcmVtZW50JztcbiAgICB9XG5cbiAgICAvLyBCTE9CL1RFWFQvR0VPTUVUUlkvSlNPTiBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAoIXR5cGVXaXRob3V0RGVmYXVsdC5oYXMoYXR0cmlidXRlU3RyaW5nKVxuICAgICAgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZVxuICAgICAgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIFVOSVFVRSc7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSAnIFBSSU1BUlkgS0VZJztcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5jb21tZW50KX1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuZmlyc3QpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcgRklSU1QnO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmFmdGVyKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIEFGVEVSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmFmdGVyKX1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSAnYWRkQ29sdW1uJyAmJiBvcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICBjb25zdCBma05hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihgJHtvcHRpb25zLnRhYmxlTmFtZX1fJHthdHRyTmFtZX1fZm9yZWlnbl9pZHhgKTtcblxuICAgICAgICB0ZW1wbGF0ZSArPSBgLCBBREQgQ09OU1RSQUlOVCAke2ZrTmFtZX0gRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KWA7XG4gICAgICB9XG5cbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKCdpZCcpfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHN0YXRtZW1lbnQgaXMganNvbiBmdW5jdGlvbiBvciBzaW1wbGUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgc3RtdCAgVGhlIHN0YXRlbWVudCB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RhdGVtZW50IGlzIGpzb24gZnVuY3Rpb25cbiAgICogQHRocm93cyAge0Vycm9yfSAgICAgICAgIHRocm93IGlmIHRoZSBzdGF0ZW1lbnQgbG9va3MgbGlrZSBqc29uIGZ1bmN0aW9uIGJ1dCBoYXMgaW52YWxpZCB0b2tlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcblxuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IEpTT05fRlVOQ1RJT05fUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoJygnKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2hlcyA9IEpTT05fT1BFUkFUT1JfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG9wZXJhdG9yTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gb3BlcmF0b3JNYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IFRPS0VOX0NBUFRVUkVfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJygnKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJyknKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJzsnKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGludmFsaWQganNvbiBzdGF0ZW1lbnRcbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIChoYXNJbnZhbGlkVG9rZW4gfHwgb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhdGVtZW50IGhhcyB2YWxpZCBqc29uIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyBhbGwgZm9yZWlnbiBrZXlzIG9mIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gdGFibGUgIFRoZSB0YWJsZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBzY2hlbWFOYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBzY2hlbWFOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICdTRUxFQ1QnLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgYEZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0Ugd2hlcmUgVEFCTEVfTkFNRSA9ICcke3RhYmxlTmFtZX0nYCxcbiAgICAgIGBBTkQgQ09OU1RSQUlOVF9OQU1FIT0nUFJJTUFSWScgQU5EIENPTlNUUkFJTlRfU0NIRU1BPScke3NjaGVtYU5hbWV9J2AsXG4gICAgICAnQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTCcsXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyB0aGUgZm9yZWlnbiBrZXkgY29uc3RyYWludCBvZiBhIGdpdmVuIGNvbHVtbi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YWJsZSAgVGhlIHRhYmxlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbHVtbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgPyB3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKSA6ICcnO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIGNvbnN0IHF1b3RlZENvbHVtbk5hbWUgPSB3cmFwU2luZ2xlUXVvdGUoY29sdW1uTmFtZSk7XG5cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAnU0VMRUNUJyxcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgICdGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFJyxcbiAgICAgICdXSEVSRSAoJyxcbiAgICAgIFtcbiAgICAgICAgYFJFRkVSRU5DRURfVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFJFRkVSRU5DRURfVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gXG4gICAgICBdLFxuICAgICAgJykgT1IgKCcsXG4gICAgICBbXG4gICAgICAgIGBUQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YCxcbiAgICAgICAgJ0FORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTEwnXG4gICAgICBdLFxuICAgICAgJyknXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJlbW92ZXMgYSBmb3JlaWduIGtleSBmcm9tIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFibGVOYW1lICBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZm9yZWlnbktleSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgY29uc3RyYWludC5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgJ0FMVEVSIFRBQkxFJyxcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgJ0RST1AgRk9SRUlHTiBLRVknLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSksXG4gICAgICAnOydcbiAgICBdKTtcbiAgfVxufVxuXG4vLyBwcml2YXRlIG1ldGhvZHNcbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIHJldHVybiBVdGlscy5hZGRUaWNrcyhpZGVudGlmaWVyLCAnXFwnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXlTUUxRdWVyeUdlbmVyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgdGhhdCBTZXF1ZWxpemUgdXNlcyB0byB0YWxrIHdpdGggTXlTUUwvTWFyaWFEQiBkYXRhYmFzZVxuICovXG5jbGFzcyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICAvKipcbiAgICogQSB3cmFwcGVyIHRoYXQgZml4ZXMgTXlTUUwncyBpbmFiaWxpdHkgdG8gY2xlYW5seSByZW1vdmUgY29sdW1ucyBmcm9tIGV4aXN0aW5nIHRhYmxlcyBpZiB0aGV5IGhhdmUgYSBmb3JlaWduIGtleSBjb25zdHJhaW50LlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgICAgfSwgY29sdW1uTmFtZSksXG4gICAgICB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9XG4gICAgKTtcblxuICAgIC8vRXhjbHVkZSBwcmltYXJ5IGtleSBjb25zdHJhaW50XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoICYmIHJlc3VsdHNbMF0uY29uc3RyYWludF9uYW1lICE9PSAnUFJJTUFSWScpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKGNvbnN0cmFpbnQgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkoXG4gICAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludF9uYW1lKSxcbiAgICAgICAgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfVxuICAgICAgKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBjb2x1bW5OYW1lKSxcbiAgICAgIHsgcmF3OiB0cnVlLCAuLi5vcHRpb25zIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG5cbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgbW9kZWwucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dDb25zdHJhaW50c1F1ZXJ5KFxuICAgICAgdGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgICAgfSwgY29uc3RyYWludE5hbWUpO1xuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucyxcbiAgICAgIHR5cGU6IHRoaXMuc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTIH0pO1xuXG4gICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzWzBdO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAoIWNvbnN0cmFpbnQgfHwgIWNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcihcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludE5hbWUsXG4gICAgICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50VHlwZSA9PT0gJ0ZPUkVJR04gS0VZJykge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVJbmRleFF1ZXJ5KGNvbnN0cmFpbnQudGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydHMuTXlTUUxRdWVyeUludGVyZmFjZSA9IE15U1FMUXVlcnlJbnRlcmZhY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC9xdWVyeScpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IEVSX0RVUF9FTlRSWSA9IDEwNjI7XG5jb25zdCBFUl9ERUFETE9DSyA9IDEyMTM7XG5jb25zdCBFUl9ST1dfSVNfUkVGRVJFTkNFRCA9IDE0NTE7XG5jb25zdCBFUl9OT19SRUZFUkVOQ0VEX1JPVyA9IDE0NTI7XG5cbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnc3FsOm15c3FsJyk7XG5cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgeyBzaG93V2FybmluZ3M6IGZhbHNlLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0gW107XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlc18pID0+IHtcbiAgICAgIGlmICh2YWx1ZXNfW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaW5kUGFyYW0ucHVzaCh2YWx1ZXNfW2tleV0pO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbS5sZW5ndGggPiAwID8gYmluZFBhcmFtIDogdW5kZWZpbmVkXTtcbiAgfVxuXG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnNob3dXYXJuaW5ncyB8fCBvcHRpb25zLnNob3dXYXJuaW5ncztcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG5cbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgZGVidWcoJ3BhcmFtZXRlcnMoJWopJywgcGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdHM7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICAuZXhlY3V0ZShzcWwsIHBhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpXG4gICAgICAgICAgICAuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICAucXVlcnkoeyBzcWwgfSwgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSlcbiAgICAgICAgICAgIC5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIGVycm9yLmVycm5vID09PSBFUl9ERUFETE9DSykge1xuICAgICAgICAvLyBNeVNRTCBhdXRvbWF0aWNhbGx5IHJvbGxzLWJhY2sgdHJhbnNhY3Rpb25zIGluIHRoZSBldmVudCBvZiBhIGRlYWRsb2NrLlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSBzdGlsbCBpbml0aWF0ZSBhIG1hbnVhbCByb2xsYmFjayB0byBlbnN1cmUgdGhlIGNvbm5lY3Rpb24gZ2V0cyByZWxlYXNlZCAtIHNlZSAjMTMxMDIuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgb3B0aW9ucy50cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIC0gc2luY2UgTXlTUUwgYXV0b21hdGljYWxseSByb2xsZWQgYmFjaywgd2UncmVcbiAgICAgICAgICAvLyBub3QgdGhhdCB3b3JyaWVkIGFib3V0IHRoaXMgcmVkdW5kYW50IHJvbGxiYWNrIGZhaWxpbmcuXG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkID0gJ3JvbGxiYWNrJztcbiAgICAgIH1cblxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvd1dhcm5pbmdzICYmIHJlc3VsdHMgJiYgcmVzdWx0cy53YXJuaW5nU3RhdHVzID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dXYXJuaW5ncyhyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICpcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogIHF1ZXJ5LmZvcm1hdFJlc3VsdHMoW1xuICAgKiAgICB7XG4gICAqICAgICAgaWQ6IDEsICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZyb20gdGhlIG1haW4gdGFibGVcbiAgICogICAgICBhdHRyMjogJ3NuYWZ1JywgICAgIC8vIHRoaXMgaXMgZnJvbSB0aGUgbWFpbiB0YWJsZVxuICAgKiAgICAgIFRhc2tzLmlkOiAxLCAgICAgICAgLy8gdGhpcyBpcyBmcm9tIHRoZSBhc3NvY2lhdGVkIHRhYmxlXG4gICAqICAgICAgVGFza3MudGl0bGU6ICd0YXNrJyAvLyB0aGlzIGlzIGZyb20gdGhlIGFzc29jaWF0ZWQgdGFibGVcbiAgICogICAgfVxuICAgKiAgXSlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIFRoZSByZXN1bHQgb2YgdGhlIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuXG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcblxuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBidWxrQ3JlYXRlIEFJIHByaW1hcnkga2V5XG4gICAgICAgIGlmIChcbiAgICAgICAgICBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdSZXN1bHRTZXRIZWFkZXInXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbFxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgICAgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkOyBpIDwgc3RhcnRJZCArIGRhdGEuYWZmZWN0ZWRSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgW3RoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkXTogaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZW51bVJlZ2V4ID0gL15lbnVtL2k7XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiBlbnVtUmVnZXgudGVzdChfcmVzdWx0LlR5cGUpID8gX3Jlc3VsdC5UeXBlLnJlcGxhY2UoZW51bVJlZ2V4LCAnRU5VTScpIDogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk51bGwgPT09ICdZRVMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5ID09PSAnUFJJJyxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwgJ0V4dHJhJylcbiAgICAgICAgICAgICYmIF9yZXN1bHQuRXh0cmEudG9Mb3dlckNhc2UoKSA9PT0gJ2F1dG9faW5jcmVtZW50JyxcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnQgPyBfcmVzdWx0LkNvbW1lbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YS5hZmZlY3RlZFJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3MgPT09IDFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgLy8gTXlTUUwgcmV0dXJucyByb3cgZGF0YSBhbmQgbWV0YWRhdGEgKGFmZmVjdGVkIHJvd3MgZXRjKSBpbiBhIHNpbmdsZSBvYmplY3QgLSBsZXQncyBzdGFuZGFyaXplIGl0LCBzb3J0YVxuICAgICAgcmV0dXJuIFtkYXRhLCBkYXRhXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgbG9nV2FybmluZ3MocmVzdWx0cykge1xuICAgIGNvbnN0IHdhcm5pbmdSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW4oJ1NIT1cgV0FSTklOR1MnKTtcbiAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBNeVNRTCBXYXJuaW5ncyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCAnZGVmYXVsdCd9KTogYDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgX3dhcm5pbmdSb3cgb2Ygd2FybmluZ1Jlc3VsdHMpIHtcbiAgICAgIGlmIChfd2FybmluZ1JvdyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBfd2FybmluZ1Jvd1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfd2FybmluZ1Jlc3VsdCBvZiBfd2FybmluZ1Jvdykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93YXJuaW5nUmVzdWx0LCAnTWVzc2FnZScpKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChfd2FybmluZ1Jlc3VsdC5NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IF9vYmplY3RLZXkgb2YgX3dhcm5pbmdSZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFtfb2JqZWN0S2V5LCBfd2FybmluZ1Jlc3VsdFtfb2JqZWN0S2V5XV0uam9pbignOiAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXF1ZWxpemUubG9nKHdhcm5pbmdNZXNzYWdlICsgbWVzc2FnZXMuam9pbignOyAnKSwgdGhpcy5vcHRpb25zKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgY29uc3QgZXJyQ29kZSA9IGVyci5lcnJubyB8fCBlcnIuY29kZTtcblxuICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgY2FzZSBFUl9EVVBfRU5UUlk6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRHVwbGljYXRlIGVudHJ5ICcoW1xcc1xcU10qKScgZm9yIGtleSAnPygoLnxcXHMpKj8pJz8kLyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBlcnJvcic7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoJy0nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmllbGRLZXkgPSBtYXRjaCA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmaWVsZFZhbCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW2ZpZWxkS2V5XTtcblxuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgaWYgKHVuaXF1ZUtleS5tc2cpIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkS2V5XSA9IGZpZWxkVmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICAgIHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksXG4gICAgICAgICAgICAndW5pcXVlIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuREIsXG4gICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAgICdub3RfdW5pcXVlJ1xuICAgICAgICAgICkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgRVJfUk9XX0lTX1JFRkVSRU5DRUQ6XG4gICAgICBjYXNlIEVSX05PX1JFRkVSRU5DRURfUk9XOiB7XG4gICAgICAgIC8vIGUuZy4gQ09OU1RSQUlOVCBgZXhhbXBsZV9jb25zdHJhaW50X25hbWVgIEZPUkVJR04gS0VZIChgZXhhbXBsZV9pZGApIFJFRkVSRU5DRVMgYGV4YW1wbGVzYCAoYGlkYClcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaChcbiAgICAgICAgICAvQ09OU1RSQUlOVCAoW2BcIl0pKC4qKVxcMSBGT1JFSUdOIEtFWSBcXChcXDEoLiopXFwxXFwpIFJFRkVSRU5DRVMgXFwxKC4qKVxcMSBcXChcXDEoLiopXFwxXFwpL1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ2AnO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBtYXRjaCA/IG1hdGNoWzNdLnNwbGl0KG5ldyBSZWdFeHAoYCR7cXVvdGVDaGFyfSwgKiR7cXVvdGVDaGFyfWApKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICByZWx0eXBlOiBTdHJpbmcoZXJyQ29kZSkgPT09IFN0cmluZyhFUl9ST1dfSVNfUkVGRVJFTkNFRCkgPyAncGFyZW50JyA6ICdjaGlsZCcsXG4gICAgICAgICAgdGFibGU6IG1hdGNoID8gbWF0Y2hbNF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCAmJiB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRzWzBdXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgaW5kZXg6IG1hdGNoID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICAvLyBHcm91cCBieSBpbmRleCBuYW1lLCBhbmQgY29sbGVjdCBhbGwgZmllbGRzXG4gICAgZGF0YSA9IGRhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmICghKGl0ZW0uS2V5X25hbWUgaW4gYWNjKSkge1xuICAgICAgICBhY2NbaXRlbS5LZXlfbmFtZV0gPSBpdGVtO1xuICAgICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBhY2NbaXRlbS5LZXlfbmFtZV0uZmllbGRzW2l0ZW0uU2VxX2luX2luZGV4IC0gMV0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogaXRlbS5Db2x1bW5fbmFtZSxcbiAgICAgICAgbGVuZ3RoOiBpdGVtLlN1Yl9wYXJ0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgb3JkZXI6IGl0ZW0uQ29sbGF0aW9uID09PSAnQScgPyAnQVNDJyA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBpdGVtLmNvbHVtbl9uYW1lO1xuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBfLm1hcChkYXRhLCBpdGVtID0+ICh7XG4gICAgICBwcmltYXJ5OiBpdGVtLktleV9uYW1lID09PSAnUFJJTUFSWScsXG4gICAgICBmaWVsZHM6IGl0ZW0uZmllbGRzLFxuICAgICAgbmFtZTogaXRlbS5LZXlfbmFtZSxcbiAgICAgIHRhYmxlTmFtZTogaXRlbS5UYWJsZSxcbiAgICAgIHVuaXF1ZTogaXRlbS5Ob25fdW5pcXVlICE9PSAxLFxuICAgICAgdHlwZTogaXRlbS5JbmRleF90eXBlXG4gICAgfSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdG9yZXMgPSBuZXcgTWFwKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlhbGVjdCA9PiB7XG4gIGlmICghc3RvcmVzLmhhcyhkaWFsZWN0KSkge1xuICAgIHN0b3Jlcy5zZXQoZGlhbGVjdCwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBzdG9yZXMuZ2V0KGRpYWxlY3QpLmNsZWFyKCk7XG4gICAgfSxcbiAgICByZWZyZXNoKGRhdGFUeXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGF0YVR5cGUudHlwZXNbZGlhbGVjdF0pIHtcbiAgICAgICAgc3RvcmVzLmdldChkaWFsZWN0KS5zZXQodHlwZSwgZGF0YVR5cGUucGFyc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0KHR5cGUpIHtcbiAgICAgIHJldHVybiBzdG9yZXMuZ2V0KGRpYWxlY3QpLmdldCh0eXBlKTtcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ2Nvbm5lY3Rpb246cGcnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCA1NDMyO1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG5cbiAgICBjb25zdCBwZ0xpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKCdwZycpO1xuICAgIHRoaXMubGliID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSA/IHBnTGliLm5hdGl2ZSA6IHBnTGliO1xuXG4gICAgdGhpcy5fY2xlYXJEeW5hbWljT0lEcygpO1xuICAgIHRoaXMuX2NsZWFyVHlwZVBhcnNlcigpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzLnBvc3RncmVzKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGlzIGFzIGEgbWV0aG9kIHNvIHRoYXQgdGhlIHBhcnNpbmcgbWF5IGJlIHVwZGF0ZWQgd2hlbiB0aGUgdXNlciBoYXMgYWRkZWQgYWRkaXRpb25hbCwgY3VzdG9tIHR5cGVzXG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIGNvbnN0IGFycmF5UGFyc2VyQnVpbGRlciA9IHBhcnNlciA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgPT4gdGhpcy5saWIudHlwZXMuYXJyYXlQYXJzZXIuY3JlYXRlKHZhbHVlLCBwYXJzZXIpLnBhcnNlKCk7XG4gICAgfTtcbiAgICBjb25zdCByYW5nZVBhcnNlckJ1aWxkZXIgPSBwYXJzZXIgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlID0+IGRhdGFUeXBlLnBhcnNlKHZhbHVlLCB7IHBhcnNlciB9KTtcbiAgICB9O1xuXG4gICAgLy8gU2V0IHJhbmdlIHBhcnNlcnNcbiAgICBpZiAoZGF0YVR5cGUua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdyYW5nZScpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm5hbWVPaWRNYXApIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLm5hbWVPaWRNYXBbbmFtZV07XG4gICAgICAgIGlmICghIGVudHJ5LnJhbmdlT2lkKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCByYW5nZVBhcnNlciA9IHJhbmdlUGFyc2VyQnVpbGRlcih0aGlzLmdldFR5cGVQYXJzZXIoZW50cnkub2lkKSk7XG4gICAgICAgIGNvbnN0IGFycmF5UmFuZ2VQYXJzZXIgPSBhcnJheVBhcnNlckJ1aWxkZXIocmFuZ2VQYXJzZXIpO1xuXG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChlbnRyeS5yYW5nZU9pZCwgcmFuZ2VQYXJzZXIpO1xuICAgICAgICBpZiAoISBlbnRyeS5hcnJheVJhbmdlT2lkKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGVudHJ5LmFycmF5UmFuZ2VPaWQsIGFycmF5UmFuZ2VQYXJzZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBwYXJzZXJzIGZvciBub3JtYWwgb3IgZW51bSBkYXRhIHR5cGVzXG4gICAgY29uc3QgcGFyc2VyID0gdmFsdWUgPT4gZGF0YVR5cGUucGFyc2UodmFsdWUpO1xuICAgIGNvbnN0IGFycmF5UGFyc2VyID0gYXJyYXlQYXJzZXJCdWlsZGVyKHBhcnNlcik7XG5cbiAgICAvLyBTZXQgZW51bSBwYXJzZXJzXG4gICAgaWYgKGRhdGFUeXBlLmtleS50b0xvd2VyQ2FzZSgpID09PSAnZW51bScpIHtcbiAgICAgIHRoaXMuZW51bU9pZHMub2lkcy5mb3JFYWNoKG9pZCA9PiB7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChvaWQsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW51bU9pZHMuYXJyYXlPaWRzLmZvckVhY2goYXJyYXlPaWQgPT4ge1xuICAgICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQoYXJyYXlPaWQsIGFycmF5UGFyc2VyKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCBwYXJzZXJzIGZvciBub3JtYWwgZGF0YSB0eXBlc1xuICAgIGRhdGFUeXBlLnR5cGVzLnBvc3RncmVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBpZiAoISB0aGlzLm5hbWVPaWRNYXBbbmFtZV0pIHJldHVybjtcbiAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldCh0aGlzLm5hbWVPaWRNYXBbbmFtZV0ub2lkLCBwYXJzZXIpO1xuXG4gICAgICBpZiAoISB0aGlzLm5hbWVPaWRNYXBbbmFtZV0uYXJyYXlPaWQpIHJldHVybjtcbiAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldCh0aGlzLm5hbWVPaWRNYXBbbmFtZV0uYXJyYXlPaWQsIGFycmF5UGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgdGhpcy5vaWRQYXJzZXJNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXRUeXBlUGFyc2VyKG9pZCwgLi4uYXJncykge1xuICAgIGlmICh0aGlzLm9pZFBhcnNlck1hcC5nZXQob2lkKSkgcmV0dXJuIHRoaXMub2lkUGFyc2VyTWFwLmdldChvaWQpO1xuXG4gICAgcmV0dXJuIHRoaXMubGliLnR5cGVzLmdldFR5cGVQYXJzZXIob2lkLCAuLi5hcmdzKTtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uZmlnLnVzZXIgPSBjb25maWcudXNlcm5hbWU7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF8ucGljayhjb25maWcsIFtcbiAgICAgICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAnZGF0YWJhc2UnLCAncG9ydCdcbiAgICBdKTtcblxuICAgIGNvbm5lY3Rpb25Db25maWcudHlwZXMgPSB7XG4gICAgICBnZXRUeXBlUGFyc2VyOiBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHlwZVBhcnNlci5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgIF8ubWVyZ2UoY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgXy5waWNrKGNvbmZpZy5kaWFsZWN0T3B0aW9ucywgW1xuICAgICAgICAvLyBzZWUgW2h0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjMvc3RhdGljL3J1bnRpbWUtY29uZmlnLWxvZ2dpbmcuaHRtbCNHVUMtQVBQTElDQVRJT04tTkFNRV1cbiAgICAgICAgICAnYXBwbGljYXRpb25fbmFtZScsXG4gICAgICAgICAgLy8gY2hvb3NlIHRoZSBTU0wgbW9kZSB3aXRoIHRoZSBQR1NTTE1PREUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgICAvLyBvYmplY3QgZm9ybWF0OiBbaHR0cHM6Ly9naXRodWIuY29tL2JyaWFuYy9ub2RlLXBvc3RncmVzL2Jsb2IvZWUxOWU3NGZmYTYzMDljOWM1ZThlMDE3NDYyNjFhOGY2NTE2NjFmOC9saWIvY29ubmVjdGlvbi5qcyNMNzldXG4gICAgICAgICAgLy8gc2VlIGFsc28gW2h0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjMvc3RhdGljL2xpYnBxLXNzbC5odG1sXVxuICAgICAgICAgICdzc2wnLFxuICAgICAgICAgIC8vIEluIGFkZGl0aW9uIHRvIHRoZSB2YWx1ZXMgYWNjZXB0ZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyLFxuICAgICAgICAgIC8vIHlvdSBjYW4gdXNlIFwiYXV0b1wiIHRvIGRldGVybWluZSB0aGUgcmlnaHQgZW5jb2RpbmcgZnJvbSB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGxvY2FsZSBpbiB0aGUgY2xpZW50IChMQ19DVFlQRSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvbiBVbml4IHN5c3RlbXMpXG4gICAgICAgICAgJ2NsaWVudF9lbmNvZGluZycsXG4gICAgICAgICAgLy8gISEgRE8gTk9UIFNFVCBUSElTIFRPIFRSVUUgISFcbiAgICAgICAgICAvLyAodW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nKVxuICAgICAgICAgIC8vIHNlZSBbaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9tZXNzYWdlLWlkL2ZsYXQvYmM5NTQ5YTUwNzA2MDQwODUydTI3NjMzZjQxaWIxZTZiMDlmODMzOWQ4NDVAbWFpbC5nbWFpbC5jb20jYmM5NTQ5YTUwNzA2MDQwODUydTI3NjMzZjQxaWIxZTZiMDlmODMzOWQ4NDVAbWFpbC5nbWFpbC5jb21dXG4gICAgICAgICAgJ2JpbmFyeScsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgaGVscCB3aXRoIGJhY2tlbmRzIGluY29ycmVjdGx5IGNvbnNpZGVyaW5nIGlkbGUgY2xpZW50cyB0byBiZSBkZWFkIGFuZCBwcmVtYXR1cmVseSBkaXNjb25uZWN0aW5nIHRoZW0uXG4gICAgICAgICAgLy8gdGhpcyBmZWF0dXJlIGhhcyBiZWVuIGFkZGVkIGluIHBnIG1vZHVsZSB2Ni4wLjAsIGNoZWNrIHBnL0NIQU5HRUxPRy5tZFxuICAgICAgICAgICdrZWVwQWxpdmUnLFxuICAgICAgICAgIC8vIFRpbWVzIG91dCBxdWVyaWVzIGFmdGVyIGEgc2V0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLiBBZGRlZCBpbiBwZyB2Ny4zXG4gICAgICAgICAgJ3N0YXRlbWVudF90aW1lb3V0JyxcbiAgICAgICAgICAvLyBUZXJtaW5hdGUgYW55IHNlc3Npb24gd2l0aCBhbiBvcGVuIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGJlZW4gaWRsZSBmb3IgbG9uZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuIEFkZGVkIGluIHBnIHY3LjE3LjAgb25seSBzdXBwb3J0ZWQgaW4gcG9zdGdyZXMgPj0gMTBcbiAgICAgICAgICAnaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXQnXG4gICAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbmRlZCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IHRoaXMubGliLkNsaWVudChjb25uZWN0aW9uQ29uZmlnKTtcblxuICAgICAgY29uc3QgcGFyYW1ldGVySGFuZGxlciA9IG1lc3NhZ2UgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucGFyYW1ldGVyTmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3NlcnZlcl92ZXJzaW9uJzpcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLmNvZXJjZShtZXNzYWdlLnBhcmFtZXRlclZhbHVlKS52ZXJzaW9uO1xuICAgICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci52YWxpZCh2ZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gdmVyc2lvblxuICAgICAgICAgICAgICAgIDogdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzJzpcbiAgICAgICAgICAgIGNvbm5lY3Rpb25bJ3N0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5ncyddID0gbWVzc2FnZS5wYXJhbWV0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnY29ubmVjdGlvbiB0aW1lb3V0Jyk7XG4gICAgICAgIGlmICghcmVzcG9uZGVkKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IobmV3IEVycm9yKCdDb25uZWN0aW9uIHRpbWVkIG91dCcpKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHdlIGRpZG4ndCBldmVyIGhlYXIgZnJvbSB0aGUgY2xpZW50LmNvbm5lY3QoKSBjYWxsYmFjayB0aGUgY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgICAvLyBub2RlLXBvc3RncmVzIGRvZXMgbm90IHRyZWF0IHRoaXMgYXMgYW4gZXJyb3Igc2luY2Ugbm8gYWN0aXZlIHF1ZXJ5IHdhcyBldmVyIGVtaXR0ZWRcbiAgICAgIGNvbm5lY3Rpb24ub25jZSgnZW5kJywgZW5kSGFuZGxlcik7XG5cbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSkge1xuICAgICAgICAvLyBSZWNlaXZlIHZhcmlvdXMgc2VydmVyIHBhcmFtZXRlcnMgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvblxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb24ub24oJ3BhcmFtZXRlclN0YXR1cycsIHBhcmFtZXRlckhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0aW9uLmNvbm5lY3QoZXJyID0+IHtcbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUpIHtcbiAgICAgICAgICAvLyByZW1vdmUgcGFyYW1ldGVyIGhhbmRsZXJcbiAgICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ3BhcmFtZXRlclN0YXR1cycsIHBhcmFtZXRlckhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICBjYXNlICdFQ09OTlJFRlVTRUQnOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ0VOT1RGT1VORCc6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ0VIT1NUVU5SRUFDSCc6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdFSU5WQUwnOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdjb25uZWN0aW9uIGFjcXVpcmVkJyk7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kSGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBsZXQgcXVlcnkgPSAnJztcblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3MgIT09IGZhbHNlICYmIGNvbm5lY3Rpb25bJ3N0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5ncyddICE9PSAnb24nKSB7XG4gICAgICAvLyBEaXNhYmxlIGVzY2FwZSBjaGFyYWN0ZXJzIGluIHN0cmluZ3NcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9pc3N1ZXMvMzU0NSAoc2VjdXJpdHkgaXNzdWUpXG4gICAgICAvLyBzZWUgaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L3N0YXRpYy9ydW50aW1lLWNvbmZpZy1jb21wYXRpYmxlLmh0bWwjR1VDLVNUQU5EQVJELUNPTkZPUk1JTkctU1RSSU5HU1xuICAgICAgcXVlcnkgKz0gJ1NFVCBzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3M9b247JztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIHF1ZXJ5ICs9IGBTRVQgY2xpZW50X21pbl9tZXNzYWdlcyBUTyAke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXN9O2A7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgY29uc3QgaXNab25lID0gISFtb21lbnQudHouem9uZSh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIGlmIChpc1pvbmUpIHtcbiAgICAgICAgcXVlcnkgKz0gYFNFVCBUSU1FIFpPTkUgJyR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZX0nO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSBgU0VUIFRJTUUgWk9ORSBJTlRFUlZBTCAnJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lfScgSE9VUiBUTyBNSU5VVEU7YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24ucXVlcnkocXVlcnkpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5uYW1lT2lkTWFwKS5sZW5ndGggPT09IDAgJiZcbiAgICAgIHRoaXMuZW51bU9pZHMub2lkcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHRoaXMuZW51bU9pZHMuYXJyYXlPaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaER5bmFtaWNPSURzKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgICAvLyBEb24ndCBsZXQgYSBQb3N0Z3JlcyByZXN0YXJ0IChvciBlcnJvcikgdG8gdGFrZSBkb3duIHRoZSB3aG9sZSBhcHBcbiAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgIGNvbm5lY3Rpb24uX2ludmFsaWQgPSB0cnVlO1xuICAgICAgZGVidWcoYGNvbm5lY3Rpb24gZXJyb3IgJHtlcnJvci5jb2RlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uX2VuZGluZykge1xuICAgICAgZGVidWcoJ2Nvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgRU5ESU5HIHN0YXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeShjYWxsYmFjayA9PiBjb25uZWN0aW9uLmVuZChjYWxsYmFjaykpKCk7XG4gIH1cblxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuICFjb25uZWN0aW9uLl9pbnZhbGlkICYmICFjb25uZWN0aW9uLl9lbmRpbmc7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaER5bmFtaWNPSURzKGNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbjtcbiAgICBjb25zdCBzdXBwb3J0ZWRWZXJzaW9uID0gJzguMy4wJztcblxuICAgIC8vIENoZWNrIGZvciBzdXBwb3J0ZWQgdmVyc2lvblxuICAgIGlmICggKGRhdGFiYXNlVmVyc2lvbiAmJiBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgc3VwcG9ydGVkVmVyc2lvbikpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCAoY29ubmVjdGlvbiB8fCB0aGlzLnNlcXVlbGl6ZSkucXVlcnkoXG4gICAgICAnV0lUSCByYW5nZXMgQVMgKCcgK1xuICAgICAgJyAgU0VMRUNUIHBnX3JhbmdlLnJuZ3R5cGlkLCBwZ190eXBlLnR5cG5hbWUgQVMgcm5ndHlwbmFtZSwnICtcbiAgICAgICcgICAgICAgICBwZ190eXBlLnR5cGFycmF5IEFTIHJuZ3R5cGFycmF5LCBwZ19yYW5nZS5ybmdzdWJ0eXBlJyArXG4gICAgICAnICAgIEZST00gcGdfcmFuZ2UgTEVGVCBPVVRFUiBKT0lOIHBnX3R5cGUgT04gcGdfdHlwZS5vaWQgPSBwZ19yYW5nZS5ybmd0eXBpZCcgK1xuICAgICAgJyknICtcbiAgICAgICdTRUxFQ1QgcGdfdHlwZS50eXBuYW1lLCBwZ190eXBlLnR5cHR5cGUsIHBnX3R5cGUub2lkLCBwZ190eXBlLnR5cGFycmF5LCcgK1xuICAgICAgJyAgICAgICByYW5nZXMucm5ndHlwbmFtZSwgcmFuZ2VzLnJuZ3R5cGlkLCByYW5nZXMucm5ndHlwYXJyYXknICtcbiAgICAgICcgIEZST00gcGdfdHlwZSBMRUZUIE9VVEVSIEpPSU4gcmFuZ2VzIE9OIHBnX3R5cGUub2lkID0gcmFuZ2VzLnJuZ3N1YnR5cGUnICtcbiAgICAgICcgV0hFUkUgKHBnX3R5cGUudHlwdHlwZSBJTihcXCdiXFwnLCBcXCdlXFwnKSk7J1xuICAgICk7XG5cbiAgICBsZXQgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShyZXN1bHRzKSA/IHJlc3VsdHMucG9wKCkgOiByZXN1bHRzO1xuXG4gICAgLy8gV2hlbiBzZWFyY2hQYXRoIGlzIHByZXBlbmRlZCB0aGVuIHR3byBzdGF0ZW1lbnRzIGFyZSBleGVjdXRlZCBhbmQgdGhlIHJlc3VsdCBpc1xuICAgIC8vIGFuIGFycmF5IG9mIHRob3NlIHR3byBzdGF0ZW1lbnRzLiBGaXJzdCBvbmUgaXMgdGhlIFNFVCBzZWFyY2hfcGF0aCBhbmQgc2Vjb25kIGlzXG4gICAgLy8gdGhlIFNFTEVDVCBxdWVyeSByZXN1bHQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgaWYgKHJlc3VsdFswXS5jb21tYW5kID09PSAnU0VUJykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV3TmFtZU9pZE1hcCA9IHt9O1xuICAgIGNvbnN0IG5ld0VudW1PaWRzID0geyBvaWRzOiBbXSwgYXJyYXlPaWRzOiBbXSB9O1xuXG4gICAgZm9yIChjb25zdCByb3cgb2YgcmVzdWx0LnJvd3MpIHtcbiAgICAgIC8vIE1hcHBpbmcgZW51bXMsIGhhbmRsZWQgc2VwYXJhdGVkbHlcbiAgICAgIGlmIChyb3cudHlwdHlwZSA9PT0gJ2UnKSB7XG4gICAgICAgIG5ld0VudW1PaWRzLm9pZHMucHVzaChyb3cub2lkKTtcbiAgICAgICAgaWYgKHJvdy50eXBhcnJheSkgbmV3RW51bU9pZHMuYXJyYXlPaWRzLnB1c2gocm93LnR5cGFycmF5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcHBpbmcgYmFzZSB0eXBlcyBhbmQgdGhlaXIgYXJyYXlzXG4gICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXSA9IHsgb2lkOiByb3cub2lkIH07XG4gICAgICBpZiAocm93LnR5cGFycmF5KSBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5hcnJheU9pZCA9IHJvdy50eXBhcnJheTtcblxuICAgICAgLy8gTWFwcGluZyByYW5nZXMob2YgYmFzZSB0eXBlcykgYW5kIHRoZWlyIGFycmF5c1xuICAgICAgaWYgKHJvdy5ybmd0eXBpZCkge1xuICAgICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5yYW5nZU9pZCA9IHJvdy5ybmd0eXBpZDtcbiAgICAgICAgaWYgKHJvdy5ybmd0eXBhcnJheSkgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0uYXJyYXlSYW5nZU9pZCA9IHJvdy5ybmd0eXBhcnJheTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXBsYWNlIGFsbCBPSUQgbWFwcGluZ3MuIEF2b2lkcyB0ZW1wb3JhcnkgZW1wdHkgT0lEIG1hcHBpbmdzLlxuICAgIHRoaXMubmFtZU9pZE1hcCA9IG5ld05hbWVPaWRNYXA7XG4gICAgdGhpcy5lbnVtT2lkcyA9IG5ld0VudW1PaWRzO1xuXG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMucG9zdGdyZXMpO1xuICB9XG5cbiAgX2NsZWFyRHluYW1pY09JRHMoKSB7XG4gICAgdGhpcy5uYW1lT2lkTWFwID0ge307XG4gICAgdGhpcy5lbnVtT2lkcyA9IHsgb2lkczogW10sIGFycmF5T2lkczogW10gfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3Qgd2t4ID0gcmVxdWlyZSgnd2t4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVR5cGVzID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodW5kZWZpbmVkLCAnaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuNC9zdGF0aWMvZGF0YXR5cGUuaHRtbCcpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHVuc3VwcG9ydGVkIFBvc3RncmVzIG9wdGlvbnMsIGkuZS4sIExFTkdUSCwgVU5TSUdORUQgYW5kIFpFUk9GSUxMLCBmb3IgdGhlIGludGVnZXIgZGF0YSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFUeXBlIFRoZSBiYXNlIGludGVnZXIgZGF0YSB0eXBlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5fbGVuZ3RoIHx8IGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoIHx8IGRhdGFUeXBlLl91bnNpZ25lZCB8fCBkYXRhVHlwZS5femVyb2ZpbGwpIHtcbiAgICAgIHdhcm4oYFBvc3RncmVzU1FMIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBMRU5HVEgsIFVOU0lHTkVEIG9yIFpFUk9GSUxMLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogdHlwZXM6XG4gICAqIHtcbiAgICogICBvaWRzOiBbb2lkXSxcbiAgICogICBhcnJheV9vaWRzOiBbb2lkXVxuICAgKiB9XG4gICAqXG4gICAqIEBzZWUgb2lkIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2xpYi9wcS9ibG9iL21hc3Rlci9vaWQvdHlwZXMuZ29cbiAgICovXG5cbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMucG9zdGdyZXMgPSBbJ3V1aWQnXTtcbiAgQmFzZVR5cGVzLkNJRFIudHlwZXMucG9zdGdyZXMgPSBbJ2NpZHInXTtcbiAgQmFzZVR5cGVzLklORVQudHlwZXMucG9zdGdyZXMgPSBbJ2luZXQnXTtcbiAgQmFzZVR5cGVzLk1BQ0FERFIudHlwZXMucG9zdGdyZXMgPSBbJ21hY2FkZHInXTtcbiAgQmFzZVR5cGVzLlRTVkVDVE9SLnR5cGVzLnBvc3RncmVzID0gWyd0c3ZlY3RvciddO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5wb3N0Z3JlcyA9IFsnanNvbiddO1xuICBCYXNlVHlwZXMuSlNPTkIudHlwZXMucG9zdGdyZXMgPSBbJ2pzb25iJ107XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLnBvc3RncmVzID0gWyd0aW1lJ107XG5cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJy1JbmZpbml0eSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgdmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGxvd2VyID09PSAnaW5maW5pdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gJy1pbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fc2FuaXRpemUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ2luZmluaXR5Jykge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09ICctaW5maW5pdHknKSB7XG4gICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLnBvc3RncmVzID0gWydkYXRlJ107XG5cbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBudW1lcmljXG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLnBvc3RncmVzID0gWydudW1lcmljJ107XG5cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiAnQllURUEnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5wb3N0Z3JlcyA9IFsndmFyY2hhciddO1xuXG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggb3B0aW9ucy4gUGxhaW4gYFRFWFRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1RFWFQnO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLnBvc3RncmVzID0gWyd0ZXh0J107XG5cbiAgY2xhc3MgQ0lURVhUIGV4dGVuZHMgQmFzZVR5cGVzLkNJVEVYVCB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkNJVEVYVC50eXBlcy5wb3N0Z3JlcyA9IFsnY2l0ZXh0J107XG5cbiAgY2xhc3MgQ0hBUiBleHRlbmRzIEJhc2VUeXBlcy5DSEFSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuICdCWVRFQSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5wb3N0Z3JlcyA9IFsnY2hhcicsICdicGNoYXInXTtcblxuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdCT09MRUFOJztcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBCaXQgZmllbGRzIGFyZSByZXR1cm5lZCBhcyBidWZmZXJzXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIE9ubHkgdGFrZSBhY3Rpb24gb24gdmFsaWQgYm9vbGVhbiBzdHJpbmdzLlxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAndCcgPyB0cnVlIDogdmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICdmJyA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBPbmx5IHRha2UgYWN0aW9uIG9uIHZhbGlkIGJvb2xlYW4gaW50ZWdlcnMuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxID8gdHJ1ZSA6IHZhbHVlID09PSAwID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEJPT0xFQU4ucGFyc2UgPSBCT09MRUFOLnByb3RvdHlwZS5fc2FuaXRpemU7XG5cbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMucG9zdGdyZXMgPSBbJ2Jvb2wnXTtcblxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUnO1xuICAgIH1cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISF2YWx1ZSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGxvd2VyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobG93ZXIgPT09ICdpbmZpbml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID09PSAnLWluZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuREFURS50eXBlcy5wb3N0Z3JlcyA9IFsndGltZXN0YW1wdHonXTtcblxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGludDJcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMucG9zdGdyZXMgPSBbJ2ludDInXTtcblxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gaW50MlxuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMucG9zdGdyZXMgPSBbJ2ludDInXTtcblxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIElOVEVHRVIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9O1xuXG4gIC8vIGludDRcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMucG9zdGdyZXMgPSBbJ2ludDQnXTtcblxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBpbnQ4XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMucG9zdGdyZXMgPSBbJ2ludDgnXTtcblxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZsb2F0NFxuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5wb3N0Z3JlcyA9IFsnZmxvYXQ0J107XG5cbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZmxvYXQ4XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMucG9zdGdyZXMgPSBbJ2Zsb2F0OCddO1xuXG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIC8vIFBPU1RHUkVTIGRvZXMgb25seSBzdXBwb3J0IGxlbmd0aHMgYXMgcGFyYW1ldGVyLlxuICAgICAgLy8gVmFsdWVzIGJldHdlZW4gMS0yNCByZXN1bHQgaW4gUkVBTFxuICAgICAgLy8gVmFsdWVzIGJldHdlZW4gMjUtNTMgcmVzdWx0IGluIERPVUJMRSBQUkVDSVNJT05cbiAgICAgIC8vIElmIGRlY2ltYWxzIGFyZSBwcm92aWRlZCByZW1vdmUgdGhlc2UgYW5kIHByaW50IGEgd2FybmluZ1xuICAgICAgaWYgKHRoaXMuX2RlY2ltYWxzKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB3aXRoIGRlY2ltYWxzLiBQbGFpbiBgRkxPQVRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2RlY2ltYWxzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB1bnNpZ25lZC4gYFVOU0lHTkVEYCB3YXMgcmVtb3ZlZC4nKTtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybignUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHplcm9maWxsLiBgWkVST0ZJTExgIHdhcyByZW1vdmVkLicpO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIEZMT0FULnBhcnNlOyAvLyBGbG9hdCBoYXMgbm8gc2VwYXJhdGUgdHlwZSBpbiBQR1xuXG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIChCWVRFQSkgd2l0aCBvcHRpb25zLiBQbGFpbiBgQllURUFgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0JZVEVBJztcbiAgICB9XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIC8vIGJ5dGVhIGhleCBmb3JtYXQgaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvc3RhdGljL2RhdGF0eXBlLWJpbmFyeS5odG1sXG4gICAgICByZXR1cm4gYEUnXFxcXFxcXFx4JHtoZXh9J2A7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMucG9zdGdyZXMgPSBbJ2J5dGVhJ107XG5cbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMudHlwZX1gO1xuICAgICAgICBpZiAodGhpcy5zcmlkKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLnNyaWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBjb25zdCBiID0gQnVmZmVyLmZyb20odmFsdWUsICdoZXgnKTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UoYikudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5lc2NhcGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKX0pYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9KWA7XG4gICAgfVxuICB9XG5cbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLnBvc3RncmVzID0gWydnZW9tZXRyeSddO1xuXG5cbiAgY2xhc3MgR0VPR1JBUEhZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT0dSQVBIWSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gJ0dFT0dSQVBIWSc7XG4gICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy50eXBlfWA7XG4gICAgICAgIGlmICh0aGlzLnNyaWQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuc3JpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZShiKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmVzY2FwZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpfSlgO1xuICAgIH1cbiAgICBiaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfSlgO1xuICAgIH1cbiAgfVxuXG4gIEJhc2VUeXBlcy5HRU9HUkFQSFkudHlwZXMucG9zdGdyZXMgPSBbJ2dlb2dyYXBoeSddO1xuXG4gIGxldCBoc3RvcmU7XG5cbiAgY2xhc3MgSFNUT1JFIGV4dGVuZHMgQmFzZVR5cGVzLkhTVE9SRSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgLy8gQWxsIGRhdGF0eXBlIGZpbGVzIGFyZSBsb2FkZWQgYXQgaW1wb3J0IC0gbWFrZSBzdXJlIHdlIGRvbid0IGxvYWQgdGhlIGhzdG9yZSBwYXJzZXIgYmVmb3JlIGEgaHN0b3JlIGlzIGluc3RhbnRpYXRlZFxuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKCcuL2hzdG9yZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIC8vIEFsbCBkYXRhdHlwZSBmaWxlcyBhcmUgbG9hZGVkIGF0IGltcG9ydCAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb2FkIHRoZSBoc3RvcmUgcGFyc2VyIGJlZm9yZSBhIGhzdG9yZSBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZSgnLi9oc3RvcmUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoc3RvcmUuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGAnJHt0aGlzLl92YWx1ZSh2YWx1ZSl9J2A7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIC8vIEFsbCBkYXRhdHlwZSBmaWxlcyBhcmUgbG9hZGVkIGF0IGltcG9ydCAtIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb2FkIHRoZSBoc3RvcmUgcGFyc2VyIGJlZm9yZSBhIGhzdG9yZSBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZSgnLi9oc3RvcmUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoc3RvcmUucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEhTVE9SRS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5cbiAgQmFzZVR5cGVzLkhTVE9SRS50eXBlcy5wb3N0Z3JlcyA9IFsnaHN0b3JlJ107XG5cbiAgY2xhc3MgUkFOR0UgZXh0ZW5kcyBCYXNlVHlwZXMuUkFOR0Uge1xuICAgIF92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlSW5jbHVzaXZpdHkgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5naWZpZWQgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5jbHVzaXZlJykpIHtcbiAgICAgICAgICAgIHZhbHVlSW5jbHVzaXZpdHlbaW5kZXhdID0gdmFsdWUuaW5jbHVzaXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCBcInVuYm91bmRlZFwiIGJvdW5kcyB1bmNoYW5nZWRcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEFycmF5Lm1hcCBkb2VzIG5vdCBwcmVzZXJ2ZSBleHRyYSBhcnJheSBwcm9wZXJ0aWVzXG4gICAgICB2YWx1ZXNTdHJpbmdpZmllZC5pbmNsdXNpdmUgPSB2YWx1ZUluY2x1c2l2aXR5O1xuICAgICAgcmV0dXJuIHJhbmdlLnN0cmluZ2lmeSh2YWx1ZXNTdHJpbmdpZmllZCk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSc6OiR7dGhpcy50b0Nhc3RUeXBlKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gYCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfTo6JHt0aGlzLnRvQ2FzdFR5cGUoKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzLnN1YnR5cGVzW3RoaXMuX3N1YnR5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHRvQ2FzdFR5cGUoKSB7XG4gICAgICByZXR1cm4gQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzLmNhc3RUeXBlc1t0aGlzLl9zdWJ0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMgPSB7IHBhcnNlcjogdmFsID0+IHZhbCB9KSB7XG4gICAgICByZXR1cm4gcmFuZ2UucGFyc2UodmFsdWUsIG9wdGlvbnMucGFyc2VyKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJyk7XG5cbiAgUkFOR0UucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuXG4gIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3JlcyA9IHtcbiAgICBzdWJ0eXBlczoge1xuICAgICAgaW50ZWdlcjogJ2ludDRyYW5nZScsXG4gICAgICBkZWNpbWFsOiAnbnVtcmFuZ2UnLFxuICAgICAgZGF0ZTogJ3RzdHpyYW5nZScsXG4gICAgICBkYXRlb25seTogJ2RhdGVyYW5nZScsXG4gICAgICBiaWdpbnQ6ICdpbnQ4cmFuZ2UnXG4gICAgfSxcbiAgICBjYXN0VHlwZXM6IHtcbiAgICAgIGludGVnZXI6ICdpbnQ0JyxcbiAgICAgIGRlY2ltYWw6ICdudW1lcmljJyxcbiAgICAgIGRhdGU6ICd0aW1lc3RhbXB0eicsXG4gICAgICBkYXRlb25seTogJ2RhdGUnLFxuICAgICAgYmlnaW50OiAnaW50OCdcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETzogV2h5IGFyZSBiYXNlIHR5cGVzIGJlaW5nIG1hbmlwdWxhdGVkPz9cbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbiBfdmFsdWUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iaW5kUGFyYW0gJiYgdGhpcy50eXBlICYmIHRoaXMudHlwZS5fdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5fdmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUuc3RyaW5naWZ5KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy50eXBlLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZS5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl9zdHJpbmdpZnkgPSBmdW5jdGlvbiBfc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucykge1xuICAgIGxldCBzdHIgPSBgQVJSQVlbJHt0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpLmpvaW4oJywnKX1dYDtcblxuICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgIGNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbiAgICAgIGxldCBjYXN0S2V5ID0gdGhpcy50b1NxbCgpO1xuXG4gICAgICBpZiAodGhpcy50eXBlIGluc3RhbmNlb2YgQmFzZVR5cGVzLkVOVU0pIHtcbiAgICAgICAgY2FzdEtleSA9IGAke1V0aWxzLmFkZFRpY2tzKFxuICAgICAgICAgIFV0aWxzLmdlbmVyYXRlRW51bU5hbWUob3B0aW9ucy5maWVsZC5Nb2RlbC5nZXRUYWJsZU5hbWUoKSwgb3B0aW9ucy5maWVsZC5maWVsZE5hbWUpLFxuICAgICAgICAgICdcIidcbiAgICAgICAgKSB9W11gO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gYDo6JHtjYXN0S2V5fWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fYmluZFBhcmFtID0gZnVuY3Rpb24gX2JpbmRQYXJhbSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKSk7XG4gIH07XG5cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5wb3N0Z3JlcyA9IFtudWxsXTtcblxuICByZXR1cm4ge1xuICAgIERFQ0lNQUwsXG4gICAgQkxPQixcbiAgICBTVFJJTkcsXG4gICAgQ0hBUixcbiAgICBURVhULFxuICAgIENJVEVYVCxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIEJPT0xFQU4sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBSRUFMLFxuICAgICdET1VCTEUgUFJFQ0lTSU9OJzogRE9VQkxFLFxuICAgIEZMT0FULFxuICAgIEdFT01FVFJZLFxuICAgIEdFT0dSQVBIWSxcbiAgICBIU1RPUkUsXG4gICAgUkFOR0UsXG4gICAgRU5VTVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHN0b3JlID0gcmVxdWlyZSgncGctaHN0b3JlJykoeyBzYW5pdGl6ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gaHN0b3JlLnN0cmluZ2lmeShkYXRhKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5mdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gaHN0b3JlLnBhcnNlKHZhbHVlKTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QnKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLW1hbmFnZXInKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3F1ZXJ5LWdlbmVyYXRvcicpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLnBvc3RncmVzO1xuY29uc3QgeyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKCcuL3F1ZXJ5LWludGVyZmFjZScpO1xuXG5jbGFzcyBQb3N0Z3Jlc0RpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblxuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgJ0RFRkFVTFQgVkFMVUVTJzogdHJ1ZSxcbiAgJ0VYQ0VQVElPTic6IHRydWUsXG4gICdPTiBEVVBMSUNBVEUgS0VZJzogZmFsc2UsXG4gICdPUkRFUiBOVUxMUyc6IHRydWUsXG4gIHJldHVyblZhbHVlczoge1xuICAgIHJldHVybmluZzogdHJ1ZVxuICB9LFxuICBidWxrRGVmYXVsdDogdHJ1ZSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgbG9ja09mOiB0cnVlLFxuICBsb2NrS2V5OiB0cnVlLFxuICBsb2NrT3V0ZXJKb2luRmFpbHVyZTogdHJ1ZSxcbiAgc2tpcExvY2tlZDogdHJ1ZSxcbiAgZm9yU2hhcmU6ICdGT1IgU0hBUkUnLFxuICBpbmRleDoge1xuICAgIGNvbmN1cnJlbnRseTogdHJ1ZSxcbiAgICB1c2luZzogMixcbiAgICB3aGVyZTogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiB0cnVlLFxuICAgIG9wZXJhdG9yOiB0cnVlXG4gIH0sXG4gIGluc2VydHM6IHtcbiAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiAnIE9OIENPTkZMSUNUIERPIE5PVEhJTkcnLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiAnIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVQnXG4gIH0sXG4gIE5VTUVSSUM6IHRydWUsXG4gIEFSUkFZOiB0cnVlLFxuICBSQU5HRTogdHJ1ZSxcbiAgR0VPTUVUUlk6IHRydWUsXG4gIFJFR0VYUDogdHJ1ZSxcbiAgR0VPR1JBUEhZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBKU09OQjogdHJ1ZSxcbiAgSFNUT1JFOiB0cnVlLFxuICBUU1ZFQ1RPUjogdHJ1ZSxcbiAgZGVmZXJyYWJsZUNvbnN0cmFpbnRzOiB0cnVlLFxuICBzZWFyY2hQYXRoOiB0cnVlXG59KTtcblxuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9ICc5LjUuMCc7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9ICdwb3N0Z3Jlcyc7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc3RncmVzRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5Qb3N0Z3Jlc0RpYWxlY3QgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY2xhc3MgUG9zdGdyZXNRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBzZXRTZWFyY2hQYXRoKHNlYXJjaFBhdGgpIHtcbiAgICByZXR1cm4gYFNFVCBzZWFyY2hfcGF0aCB0byAke3NlYXJjaFBhdGh9O2A7XG4gIH1cblxuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIGRhdGFiYXNlOiB0aGlzLnF1b3RlVGFibGUoZGF0YWJhc2VOYW1lKSxcbiAgICAgIGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nID8gYCBFTkNPRElORyA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5lbmNvZGluZyl9YCA6ICcnLFxuICAgICAgY29sbGF0aW9uOiBvcHRpb25zLmNvbGxhdGUgPyBgIExDX0NPTExBVEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCA6ICcnLFxuICAgICAgY3R5cGU6IG9wdGlvbnMuY3R5cGUgPyBgIExDX0NUWVBFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmN0eXBlKX1gIDogJycsXG4gICAgICB0ZW1wbGF0ZTogb3B0aW9ucy50ZW1wbGF0ZSA/IGAgVEVNUExBVEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMudGVtcGxhdGUpfWAgOiAnJ1xuICAgIH07XG5cbiAgICByZXR1cm4gYENSRUFURSBEQVRBQkFTRSAke3ZhbHVlcy5kYXRhYmFzZX0ke3ZhbHVlcy5lbmNvZGluZ30ke3ZhbHVlcy5jb2xsYXRpb259JHt2YWx1ZXMuY3R5cGV9JHt2YWx1ZXMudGVtcGxhdGV9O2A7XG4gIH1cblxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgREFUQUJBU0UgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKGRhdGFiYXNlTmFtZSl9O2A7XG4gIH1cblxuICBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gXy5nZXQodGhpcywgJ3NlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbicsIDApO1xuXG4gICAgaWYgKGRhdGFiYXNlVmVyc2lvbiAmJiBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgJzkuMi4wJykpIHtcbiAgICAgIHJldHVybiBgQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTICR7c2NoZW1hfTtgO1xuICAgIH1cblxuICAgIHJldHVybiBgQ1JFQVRFIFNDSEVNQSAke3NjaGVtYX07YDtcbiAgfVxuXG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGBEUk9QIFNDSEVNQSBJRiBFWElTVFMgJHtzY2hlbWF9IENBU0NBREU7YDtcbiAgfVxuXG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIHNjaGVtYV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhIFdIRVJFIHNjaGVtYV9uYW1lIDw+ICdpbmZvcm1hdGlvbl9zY2hlbWEnIEFORCBzY2hlbWFfbmFtZSAhPSAncHVibGljJyBBTkQgc2NoZW1hX25hbWUgIX4gRSdecGdfJztcIjtcbiAgfVxuXG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gJ1NIT1cgU0VSVkVSX1ZFUlNJT04nO1xuICB9XG5cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG5cbiAgICAvL1Bvc3RncmVzIDkuMCBkb2VzIG5vdCBzdXBwb3J0IENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTLCA5LjEgYW5kIGFib3ZlIGRvXG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gXy5nZXQodGhpcywgJ3NlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbicsIDApO1xuICAgIGNvbnN0IGF0dHJTdHIgPSBbXTtcbiAgICBsZXQgY29tbWVudHMgPSAnJztcbiAgICBsZXQgY29sdW1uQ29tbWVudHMgPSAnJztcblxuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG5cbiAgICBpZiAob3B0aW9ucy5jb21tZW50ICYmIHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21tZW50cyArPSBgOyBDT01NRU5UIE9OIFRBQkxFICR7cXVvdGVkVGFibGV9IElTICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb21tZW50KX1gO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBxdW90ZWRBdHRyID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cik7XG4gICAgICBjb25zdCBpID0gYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKCdDT01NRU5UICcpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIC8vIE1vdmUgY29tbWVudCB0byBhIHNlcGFyYXRlIHF1ZXJ5XG4gICAgICAgIGNvbnN0IGVzY2FwZWRDb21tZW50VGV4dCA9IHRoaXMuZXNjYXBlKGF0dHJpYnV0ZXNbYXR0cl0uc3Vic3RyaW5nKGkgKyA4KSk7XG4gICAgICAgIGNvbHVtbkNvbW1lbnRzICs9IGA7IENPTU1FTlQgT04gQ09MVU1OICR7cXVvdGVkVGFibGV9LiR7cXVvdGVkQXR0cn0gSVMgJHtlc2NhcGVkQ29tbWVudFRleHR9YDtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGF0dHJpYnV0ZXNbYXR0cl0uc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyU3RyLnB1c2goYCR7cXVvdGVkQXR0cn0gJHtkYXRhVHlwZX1gKTtcbiAgICB9XG5cblxuICAgIGxldCBhdHRyaWJ1dGVzQ2xhdXNlID0gYXR0clN0ci5qb2luKCcsICcpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgY29sdW1ucyA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKGZpZWxkID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGtzID0gXy5yZWR1Y2UoYXR0cmlidXRlcywgKGFjYywgYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgIGlmIChhdHRyaWJ1dGUuaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKS5qb2luKCcsJyk7XG5cbiAgICBpZiAocGtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtzfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBgQ1JFQVRFIFRBQkxFICR7ZGF0YWJhc2VWZXJzaW9uID09PSAwIHx8IHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCAnOS4xLjAnKSA/ICdJRiBOT1QgRVhJU1RTICcgOiAnJ30ke3F1b3RlZFRhYmxlfSAoJHthdHRyaWJ1dGVzQ2xhdXNlfSkke2NvbW1lbnRzfSR7Y29sdW1uQ29tbWVudHN9O2A7XG4gIH1cblxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JHtvcHRpb25zLmNhc2NhZGUgPyAnIENBU0NBREUnIDogJyd9O2A7XG4gIH1cblxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIHRhYmxlX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICdwdWJsaWMnIEFORCB0YWJsZV90eXBlIExJS0UgJyVUQUJMRScgQU5EIHRhYmxlX25hbWUgIT0gJ3NwYXRpYWxfcmVmX3N5cyc7XCI7XG4gIH1cblxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEpIHtcbiAgICBpZiAoIXNjaGVtYSkgc2NoZW1hID0gJ3B1YmxpYyc7XG5cbiAgICByZXR1cm4gJ1NFTEVDVCAnICtcbiAgICAgICdway5jb25zdHJhaW50X3R5cGUgYXMgXCJDb25zdHJhaW50XCIsJyArXG4gICAgICAnYy5jb2x1bW5fbmFtZSBhcyBcIkZpZWxkXCIsICcgK1xuICAgICAgJ2MuY29sdW1uX2RlZmF1bHQgYXMgXCJEZWZhdWx0XCIsJyArXG4gICAgICAnYy5pc19udWxsYWJsZSBhcyBcIk51bGxcIiwgJyArXG4gICAgICAnKENBU0UgV0hFTiBjLnVkdF9uYW1lID0gXFwnaHN0b3JlXFwnIFRIRU4gYy51ZHRfbmFtZSBFTFNFIGMuZGF0YV90eXBlIEVORCkgfHwgKENBU0UgV0hFTiBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCBJUyBOT1QgTlVMTCBUSEVOIFxcJyhcXCcgfHwgYy5jaGFyYWN0ZXJfbWF4aW11bV9sZW5ndGggfHwgXFwnKVxcJyBFTFNFIFxcJ1xcJyBFTkQpIGFzIFwiVHlwZVwiLCAnICtcbiAgICAgICcoU0VMRUNUIGFycmF5X2FnZyhlLmVudW1sYWJlbCkgRlJPTSBwZ19jYXRhbG9nLnBnX3R5cGUgdCBKT0lOIHBnX2NhdGFsb2cucGdfZW51bSBlIE9OIHQub2lkPWUuZW51bXR5cGlkIFdIRVJFIHQudHlwbmFtZT1jLnVkdF9uYW1lKSBBUyBcInNwZWNpYWxcIiwgJyArXG4gICAgICAnKFNFTEVDVCBwZ2QuZGVzY3JpcHRpb24gRlJPTSBwZ19jYXRhbG9nLnBnX3N0YXRpb19hbGxfdGFibGVzIEFTIHN0IElOTkVSIEpPSU4gcGdfY2F0YWxvZy5wZ19kZXNjcmlwdGlvbiBwZ2Qgb24gKHBnZC5vYmpvaWQ9c3QucmVsaWQpIFdIRVJFIGMub3JkaW5hbF9wb3NpdGlvbj1wZ2Qub2Jqc3ViaWQgQU5EIGMudGFibGVfbmFtZT1zdC5yZWxuYW1lKSBBUyBcIkNvbW1lbnRcIiAnICtcbiAgICAgICdGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIGMgJyArXG4gICAgICAnTEVGVCBKT0lOIChTRUxFQ1QgdGMudGFibGVfc2NoZW1hLCB0Yy50YWJsZV9uYW1lLCAnICtcbiAgICAgICdjdS5jb2x1bW5fbmFtZSwgdGMuY29uc3RyYWludF90eXBlICcgK1xuICAgICAgJ0ZST00gaW5mb3JtYXRpb25fc2NoZW1hLlRBQkxFX0NPTlNUUkFJTlRTIHRjICcgK1xuICAgICAgJ0pPSU4gaW5mb3JtYXRpb25fc2NoZW1hLktFWV9DT0xVTU5fVVNBR0UgIGN1ICcgK1xuICAgICAgJ09OIHRjLnRhYmxlX3NjaGVtYT1jdS50YWJsZV9zY2hlbWEgYW5kIHRjLnRhYmxlX25hbWU9Y3UudGFibGVfbmFtZSAnICtcbiAgICAgICdhbmQgdGMuY29uc3RyYWludF9uYW1lPWN1LmNvbnN0cmFpbnRfbmFtZSAnICtcbiAgICAgICdhbmQgdGMuY29uc3RyYWludF90eXBlPVxcJ1BSSU1BUlkgS0VZXFwnKSBwayAnICtcbiAgICAgICdPTiBway50YWJsZV9zY2hlbWE9Yy50YWJsZV9zY2hlbWEgJyArXG4gICAgICAnQU5EIHBrLnRhYmxlX25hbWU9Yy50YWJsZV9uYW1lICcgK1xuICAgICAgJ0FORCBway5jb2x1bW5fbmFtZT1jLmNvbHVtbl9uYW1lICcgK1xuICAgICAgYFdIRVJFIGMudGFibGVfbmFtZSA9ICR7dGhpcy5lc2NhcGUodGFibGVOYW1lKX0gQU5EIGMudGFibGVfc2NoZW1hID0gJHt0aGlzLmVzY2FwZShzY2hlbWEpfSBgO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHN0YXRtZW1lbnQgaXMganNvbiBmdW5jdGlvbiBvciBzaW1wbGUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgc3RtdCAgVGhlIHN0YXRlbWVudCB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RhdGVtZW50IGlzIGpzb24gZnVuY3Rpb25cbiAgICogQHRocm93cyAge0Vycm9yfSAgICAgICAgIHRocm93IGlmIHRoZSBzdGF0ZW1lbnQgbG9va3MgbGlrZSBqc29uIGZ1bmN0aW9uIGJ1dCBoYXMgaW52YWxpZCB0b2tlblxuICAgKi9cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L3N0YXRpYy9mdW5jdGlvbnMtanNvbi5odG1sXG4gICAgY29uc3QganNvbkZ1bmN0aW9uUmVnZXggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbiAgICBjb25zdCBqc29uT3BlcmF0b3JSZWdleCA9IC9eXFxzKigtPj4/fCM+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuICAgIGNvbnN0IHRva2VuQ2FwdHVyZVJlZ2V4ID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0ganNvbkZ1bmN0aW9uUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoJygnKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2hlcyA9IGpzb25PcGVyYXRvclJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSB0b2tlbkNhcHR1cmVSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSAnKCcpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnKScpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSAnOycpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW52YWxpZCBqc29uIHN0YXRlbWVudFxuICAgIGhhc0ludmFsaWRUb2tlbiB8PSBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cztcbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIGhhc0ludmFsaWRUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlIHN0YXRlbWVudCBoYXMgdmFsaWQganNvbiBmdW5jdGlvblxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cblxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICAvLyBQYXJzZSBuZXN0ZWQgb2JqZWN0XG4gICAgICBpZiAoc210aC5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHNtdGguY29uZGl0aW9ucykubWFwKGNvbmRpdGlvbiA9PlxuICAgICAgICAgIGAke3RoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29uZGl0aW9uLnBhdGhbMF0sIF8udGFpbChjb25kaXRpb24ucGF0aCkpfSA9ICcke2NvbmRpdGlvbi52YWx1ZX0nYFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb25zLmpvaW4oJyBBTkQgJyk7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5wYXRoKSB7XG4gICAgICAgIGxldCBzdHI7XG5cbiAgICAgICAgLy8gQWxsb3cgc3BlY2lmeWluZyBjb25kaXRpb25zIHVzaW5nIHRoZSBwb3N0Z3JlcyBqc29uIHN5bnRheFxuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbHNvIHN1cHBvcnQganNvbiBwcm9wZXJ0eSBhY2Nlc3NvcnNcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNtdGgudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoJyA9ICVzJywgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZC5jYWxsKHRoaXMsIHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cblxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBkYkRhdGFUeXBlID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIHsgY29udGV4dDogJ2FkZENvbHVtbicsIHRhYmxlLCBrZXkgfSk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGUudHlwZSB8fCBhdHRyaWJ1dGU7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlLCBrZXksIGRiRGF0YVR5cGUpO1xuICAgIGNvbnN0IHF1b3RlZEtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlKSk7XG5cbiAgICBsZXQgcXVlcnkgPSBgQUxURVIgVEFCTEUgJHtxdW90ZWRUYWJsZX0gQUREIENPTFVNTiAke3F1b3RlZEtleX0gJHtkZWZpbml0aW9ufTtgO1xuXG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5wZ0VudW0odGFibGUsIGtleSwgZGF0YVR5cGUpICsgcXVlcnk7XG4gICAgfSBlbHNlIGlmIChkYXRhVHlwZS50eXBlICYmIGRhdGFUeXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgcXVlcnkgPSB0aGlzLnBnRW51bSh0YWJsZSwga2V5LCBkYXRhVHlwZS50eXBlKSArIHF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmV4dHJhY3RUYWJsZURldGFpbHModGFibGVOYW1lKSk7XG4gICAgY29uc3QgcXVvdGVkQXR0cmlidXRlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9IERST1AgQ09MVU1OICR7cXVvdGVkQXR0cmlidXRlTmFtZX07YDtcbiAgfVxuXG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3ViUXVlcnkgPT4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IEFMVEVSIENPTFVNTiAke3N1YlF1ZXJ5fTtgO1xuICAgIGNvbnN0IHNxbCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICBsZXQgYXR0clNxbCA9ICcnO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnTk9UIE5VTEwnKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBTRVQgTk9UIE5VTExgKTtcblxuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKCdOT1QgTlVMTCcsICcnKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKCdSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gRFJPUCBOT1QgTlVMTGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcygnREVGQVVMVCcpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFNFVCBERUZBVUxUICR7ZGVmaW5pdGlvbi5tYXRjaCgvREVGQVVMVCAoW147XSspLylbMV19YCk7XG5cbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvKERFRkFVTFRbXjtdKykvLCAnJykudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IERST1AgREVGQVVMVGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5zdGFydHNXaXRoKCdFTlVNKCcpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gdGhpcy5wZ0VudW0odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvXkVOVU1cXCguK1xcKS8sIHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIHsgc2NoZW1hOiBmYWxzZSB9KSk7XG4gICAgICAgIGRlZmluaXRpb24gKz0gYCBVU0lORyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX06OiR7dGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSl9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9VTklRVUU7KiQvKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC9VTklRVUU7KiQvLCAnJyk7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYEFERCBVTklRVUUgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9KWApLnJlcGxhY2UoJ0FMVEVSIENPTFVNTicsICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoJ1JFRkVSRU5DRVMnKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sICcnKTtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgQUREIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSkgJHtkZWZpbml0aW9ufWApLnJlcGxhY2UoJ0FMVEVSIENPTFVNTicsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IFRZUEUgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBzcWwucHVzaChhdHRyU3FsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3FsLmpvaW4oJycpO1xuICB9XG5cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG5cbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgYXR0clN0cmluZy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJCZWZvcmUpfSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIENPTFVNTiAke2F0dHJTdHJpbmcuam9pbignLCAnKX07YDtcbiAgfVxuXG4gIGZuKGZuTmFtZSwgdGFibGVOYW1lLCBwYXJhbWV0ZXJzLCBib2R5LCByZXR1cm5zLCBsYW5ndWFnZSkge1xuICAgIGZuTmFtZSA9IGZuTmFtZSB8fCAndGVzdGZ1bmMnO1xuICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UgfHwgJ3BscGdzcWwnO1xuICAgIHJldHVybnMgPSByZXR1cm5zID8gYFJFVFVSTlMgJHtyZXR1cm5zfWAgOiAnJztcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCAnJztcblxuICAgIHJldHVybiBgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gcGdfdGVtcC4ke2ZuTmFtZX0oJHtwYXJhbWV0ZXJzfSkgJHtyZXR1cm5zfSBBUyAkZnVuYyQgQkVHSU4gJHtib2R5fSBFTkQ7ICRmdW5jJCBMQU5HVUFHRSAke2xhbmd1YWdlfTsgU0VMRUNUICogRlJPTSBwZ190ZW1wLiR7Zm5OYW1lfSgpO2A7XG4gIH1cblxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgYFRSVU5DQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMucmVzdGFydElkZW50aXR5ID8gJyBSRVNUQVJUIElERU5USVRZJyA6ICcnLFxuICAgICAgb3B0aW9ucy5jYXNjYWRlID8gJyBDQVNDQURFJyA6ICcnXG4gICAgXS5qb2luKCcnKTtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0ID8gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfWAgOiAnJztcbiAgICBsZXQgcHJpbWFyeUtleXMgPSAnJztcbiAgICBsZXQgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSAnJztcblxuICAgIGlmICh3aGVyZUNsYXVzZSkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgIFdIRVJFICR7d2hlcmVDbGF1c2V9YDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBMSU1JVCBkZWxldGUgd2l0aG91dCBhIG1vZGVsLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwa3MgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAocGsgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGsuZmllbGQpKS5qb2luKCcsJyk7XG5cbiAgICAgIHByaW1hcnlLZXlzID0gbW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoID4gMSA/IGAoJHtwa3N9KWAgOiBwa3M7XG4gICAgICBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9IHBrcztcblxuICAgICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RhYmxlfSBXSEVSRSAke3ByaW1hcnlLZXlzfSBJTiAoU0VMRUNUICR7cHJpbWFyeUtleXNTZWxlY3Rpb259IEZST00gJHt0YWJsZX0ke3doZXJlQ2xhdXNlfSR7bGltaXR9KWA7XG4gICAgfVxuICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0YWJsZX0ke3doZXJlQ2xhdXNlfWA7XG4gIH1cblxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGxldCBzY2hlbWFKb2luID0gJyc7XG4gICAgbGV0IHNjaGVtYVdoZXJlID0gJyc7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWFKb2luID0gJywgcGdfbmFtZXNwYWNlIHMnO1xuICAgICAgc2NoZW1hV2hlcmUgPSBgIEFORCBzLm9pZCA9IHQucmVsbmFtZXNwYWNlIEFORCBzLm5zcG5hbWUgPSAnJHt0YWJsZU5hbWUuc2NoZW1hfSdgO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIEFSQ0FORSFcbiAgICByZXR1cm4gJ1NFTEVDVCBpLnJlbG5hbWUgQVMgbmFtZSwgaXguaW5kaXNwcmltYXJ5IEFTIHByaW1hcnksIGl4LmluZGlzdW5pcXVlIEFTIHVuaXF1ZSwgaXguaW5ka2V5IEFTIGluZGtleSwgJyArXG4gICAgICAnYXJyYXlfYWdnKGEuYXR0bnVtKSBhcyBjb2x1bW5faW5kZXhlcywgYXJyYXlfYWdnKGEuYXR0bmFtZSkgQVMgY29sdW1uX25hbWVzLCBwZ19nZXRfaW5kZXhkZWYoaXguaW5kZXhyZWxpZCkgJyArXG4gICAgICBgQVMgZGVmaW5pdGlvbiBGUk9NIHBnX2NsYXNzIHQsIHBnX2NsYXNzIGksIHBnX2luZGV4IGl4LCBwZ19hdHRyaWJ1dGUgYSR7c2NoZW1hSm9pbn0gYCArXG4gICAgICAnV0hFUkUgdC5vaWQgPSBpeC5pbmRyZWxpZCBBTkQgaS5vaWQgPSBpeC5pbmRleHJlbGlkIEFORCBhLmF0dHJlbGlkID0gdC5vaWQgQU5EICcgK1xuICAgICAgYHQucmVsa2luZCA9ICdyJyBhbmQgdC5yZWxuYW1lID0gJyR7dGFibGVOYW1lfScke3NjaGVtYVdoZXJlfSBgICtcbiAgICAgICdHUk9VUCBCWSBpLnJlbG5hbWUsIGl4LmluZGV4cmVsaWQsIGl4LmluZGlzcHJpbWFyeSwgaXguaW5kaXN1bmlxdWUsIGl4LmluZGtleSBPUkRFUiBCWSBpLnJlbG5hbWU7JztcbiAgfVxuXG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIC8vUG9zdGdyZXMgY29udmVydHMgY2FtZWxDYXNlZCBhbGlhcyB0byBsb3dlcmNhc2UgdW5sZXNzIHF1b3RlZFxuICAgIHJldHVybiBbXG4gICAgICAnU0VMRUNUIGNvbnN0cmFpbnRfY2F0YWxvZyBBUyBcImNvbnN0cmFpbnRDYXRhbG9nXCIsJyxcbiAgICAgICdjb25zdHJhaW50X3NjaGVtYSBBUyBcImNvbnN0cmFpbnRTY2hlbWFcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfbmFtZSBBUyBcImNvbnN0cmFpbnROYW1lXCIsJyxcbiAgICAgICd0YWJsZV9jYXRhbG9nIEFTIFwidGFibGVDYXRhbG9nXCIsJyxcbiAgICAgICd0YWJsZV9zY2hlbWEgQVMgXCJ0YWJsZVNjaGVtYVwiLCcsXG4gICAgICAndGFibGVfbmFtZSBBUyBcInRhYmxlTmFtZVwiLCcsXG4gICAgICAnY29uc3RyYWludF90eXBlIEFTIFwiY29uc3RyYWludFR5cGVcIiwnLFxuICAgICAgJ2lzX2RlZmVycmFibGUgQVMgXCJpc0RlZmVycmFibGVcIiwnLFxuICAgICAgJ2luaXRpYWxseV9kZWZlcnJlZCBBUyBcImluaXRpYWxseURlZmVycmVkXCInLFxuICAgICAgJ2Zyb20gSU5GT1JNQVRJT05fU0NIRU1BLnRhYmxlX2NvbnN0cmFpbnRzJyxcbiAgICAgIGBXSEVSRSB0YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nO2BcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbignXycpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBgRFJPUCBJTkRFWCBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKX1gO1xuICB9XG5cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9ICcnO1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgaWYgKG9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgICAgZnJhZ21lbnQgKz0gJyBMSU1JVCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSAnIE9GRlNFVCAnICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgdHlwZTtcbiAgICBpZiAoXG4gICAgICBhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8XG4gICAgICBhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiBhdHRyaWJ1dGUudHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU1cbiAgICApIHtcbiAgICAgIGNvbnN0IGVudW1UeXBlID0gYXR0cmlidXRlLnR5cGUudHlwZSB8fCBhdHRyaWJ1dGUudHlwZTtcbiAgICAgIGxldCB2YWx1ZXMgPSBhdHRyaWJ1dGUudmFsdWVzO1xuXG4gICAgICBpZiAoZW51bVR5cGUudmFsdWVzICYmICFhdHRyaWJ1dGUudmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGVudW1UeXBlLnZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0eXBlID0gYEVOVU0oJHt2YWx1ZXMubWFwKHZhbHVlID0+IHRoaXMuZXNjYXBlKHZhbHVlKSkuam9pbignLCAnKX0pYDtcblxuICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgICAgICB0eXBlICs9ICdbXSc7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWVzIGZvciBFTlVNIGhhdmVuJ3QgYmVlbiBkZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcbiAgICB9XG5cbiAgICBsZXQgc3FsID0gdHlwZS50b1N0cmluZygpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsICdhbGxvd051bGwnKSAmJiAhYXR0cmlidXRlLmFsbG93TnVsbCkge1xuICAgICAgc3FsICs9ICcgTk9UIE5VTEwnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50SWRlbnRpdHkpIHtcbiAgICAgICAgc3FsICs9ICcgR0VORVJBVEVEIEJZIERFRkFVTFQgQVMgSURFTlRJVFknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsICs9ICcgU0VSSUFMJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICBzcWwgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSwgYXR0cmlidXRlKX1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICBzcWwgKz0gJyBVTklRVUUnO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgc3FsICs9ICcgUFJJTUFSWSBLRVknO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgbGV0IHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCk7XG4gICAgICBsZXQgc2NoZW1hO1xuXG4gICAgICBpZiAob3B0aW9ucy5zY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoIWF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsIHx8IHR5cGVvZiBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCA9PSAnc3RyaW5nJylcbiAgICAgICAgJiYgb3B0aW9ucy50YWJsZVxuICAgICAgICAmJiBvcHRpb25zLnRhYmxlLnNjaGVtYVxuICAgICAgKSB7XG4gICAgICAgIHNjaGVtYSA9IG9wdGlvbnMudGFibGUuc2NoZW1hO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh7XG4gICAgICAgICAgdGFibGVOYW1lOiByZWZlcmVuY2VzVGFibGUsXG4gICAgICAgICAgX3NjaGVtYTogc2NoZW1hXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlZmVyZW5jZXNLZXk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyhhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKCdpZCcpO1xuICAgICAgfVxuXG4gICAgICBzcWwgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1RhYmxlfSAoJHtyZWZlcmVuY2VzS2V5fSlgO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHNxbCArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgc3FsICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmRlZmVycmFibGUpIHtcbiAgICAgICAgc3FsICs9IGAgJHthdHRyaWJ1dGUucmVmZXJlbmNlcy5kZWZlcnJhYmxlLnRvU3RyaW5nKHRoaXMpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50ICYmIHR5cGVvZiBhdHRyaWJ1dGUuY29tbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLmNvbnRleHQgPT09ICdhZGRDb2x1bW4nIHx8IG9wdGlvbnMuY29udGV4dCA9PT0gJ2NoYW5nZUNvbHVtbicpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlZEF0dHIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmtleSk7XG4gICAgICAgIGNvbnN0IGVzY2FwZWRDb21tZW50VGV4dCA9IHRoaXMuZXNjYXBlKGF0dHJpYnV0ZS5jb21tZW50KTtcbiAgICAgICAgc3FsICs9IGA7IENPTU1FTlQgT04gQ09MVU1OICR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMudGFibGUpfS4ke3F1b3RlZEF0dHJ9IElTICR7ZXNjYXBlZENvbW1lbnRUZXh0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgY3JlYXRlVGFibGUgZXZlbnQgd2hpY2ggZG9lcyBpdCdzIG93biBwYXJzaW5nXG4gICAgICAgIC8vIFRPRE86IGNlbnRyYWxpemUgY3JlYXRpb24gb2YgY29tbWVudCBzdGF0ZW1lbnRzIGhlcmVcbiAgICAgICAgc3FsICs9IGAgQ09NTUVOVCAke2F0dHJpYnV0ZS5jb21tZW50fWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIGRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGVmZXJyYWJsZS50b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIHNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCB0eXBlKSB7XG4gICAgbGV0IGNvbHVtbkZyYWdtZW50ID0gJ0FMTCc7XG5cbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgY29sdW1uRnJhZ21lbnQgPSBjb2x1bW5zLm1hcChjb2x1bW4gPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKSkuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFNFVCBDT05TVFJBSU5UUyAke2NvbHVtbkZyYWdtZW50fSAke3R5cGV9YDtcbiAgfVxuXG4gIHNldERlZmVycmVkUXVlcnkoY29sdW1ucykge1xuICAgIHJldHVybiB0aGlzLnNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCAnREVGRVJSRUQnKTtcbiAgfVxuXG4gIHNldEltbWVkaWF0ZVF1ZXJ5KGNvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgJ0lNTUVESUFURScpO1xuICB9XG5cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCB7IGtleSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY3JlYXRlVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCBldmVudFR5cGUsIGZpcmVPblNwZWMsIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIG9wdGlvbnNBcnJheSkge1xuICAgIGNvbnN0IGRlY29kZWRFdmVudFR5cGUgPSB0aGlzLmRlY29kZVRyaWdnZXJFdmVudFR5cGUoZXZlbnRUeXBlKTtcbiAgICBjb25zdCBldmVudFNwZWMgPSB0aGlzLmV4cGFuZFRyaWdnZXJFdmVudFNwZWMoZmlyZU9uU3BlYyk7XG4gICAgY29uc3QgZXhwYW5kZWRPcHRpb25zID0gdGhpcy5leHBhbmRPcHRpb25zKG9wdGlvbnNBcnJheSk7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QoZnVuY3Rpb25QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGBDUkVBVEUgJHt0aGlzLnRyaWdnZXJFdmVudFR5cGVJc0NvbnN0cmFpbnQoZXZlbnRUeXBlKX1UUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJpZ2dlck5hbWUpfSAke2RlY29kZWRFdmVudFR5cGV9ICR7XG4gICAgICBldmVudFNwZWN9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JHtleHBhbmRlZE9wdGlvbnMgPyBgICR7ZXhwYW5kZWRPcHRpb25zfWAgOiAnJ30gRVhFQ1VURSBQUk9DRURVUkUgJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSk7YDtcbiAgfVxuXG4gIGRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgVFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyaWdnZXJOYW1lKX0gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVTVFJJQ1Q7YDtcbiAgfVxuXG4gIHJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvbGRUcmlnZ2VyTmFtZSl9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFTkFNRSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKG5ld1RyaWdnZXJOYW1lKX07YDtcbiAgfVxuXG4gIGNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKSB7XG4gICAgaWYgKCFmdW5jdGlvbk5hbWUgfHwgIXJldHVyblR5cGUgfHwgIWxhbmd1YWdlIHx8ICFib2R5KSB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUZ1bmN0aW9uIG1pc3Npbmcgc29tZSBwYXJhbWV0ZXJzLiBEaWQgeW91IHBhc3MgZnVuY3Rpb25OYW1lLCByZXR1cm5UeXBlLCBsYW5ndWFnZSBhbmQgYm9keT8nKTtcblxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnZhcmlhYmxlcyA/IHRoaXMuX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0KG9wdGlvbnMudmFyaWFibGVzKSA6ICcnO1xuICAgIGNvbnN0IGV4cGFuZGVkT3B0aW9uc0FycmF5ID0gdGhpcy5leHBhbmRPcHRpb25zKG9wdGlvbnNBcnJheSk7XG5cbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBvcHRpb25zICYmIG9wdGlvbnMuZm9yY2UgPyAnQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04nIDogJ0NSRUFURSBGVU5DVElPTic7XG5cbiAgICByZXR1cm4gYCR7c3RhdGVtZW50fSAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRVRVUk5TICR7cmV0dXJuVHlwZX0gQVMgJGZ1bmMkICR7dmFyaWFibGVMaXN0fSBCRUdJTiAke2JvZHl9IEVORDsgJGZ1bmMkIGxhbmd1YWdlICcke2xhbmd1YWdlfScke2V4cGFuZGVkT3B0aW9uc0FycmF5fTtgO1xuICB9XG5cbiAgZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zKSB7XG4gICAgaWYgKCFmdW5jdGlvbk5hbWUpIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgZnVuY3Rpb25OYW1lJyk7XG4gICAgLy8gUkVTVFJJQ1QgaXMgKGN1cnJlbnRseSwgYXMgb2YgOS4yKSBkZWZhdWx0IGJ1dCB3ZSdsbCBiZSBleHBsaWNpdFxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgcmV0dXJuIGBEUk9QIEZVTkNUSU9OICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFU1RSSUNUO2A7XG4gIH1cblxuICByZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICByZXR1cm4gYEFMVEVSIEZVTkNUSU9OICR7b2xkRnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFTkFNRSBUTyAke25ld0Z1bmN0aW9uTmFtZX07YDtcbiAgfVxuXG4gIHBnRXNjYXBlQW5kUXVvdGUodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKFV0aWxzLnJlbW92ZVRpY2tzKHRoaXMuZXNjYXBlKHZhbCksIFwiJ1wiKSk7XG4gIH1cblxuICBfZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0OiBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFycmF5IHJlcXVpcmVkLCBpbmNsdWRpbmcgYW4gZW1wdHkgb25lIGZvciBubyBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbUxpc3QgPSBbXTtcbiAgICBwYXJhbXMuZm9yRWFjaChjdXJQYXJhbSA9PiB7XG4gICAgICBjb25zdCBwYXJhbURlZiA9IFtdO1xuICAgICAgaWYgKGN1clBhcmFtLnR5cGUpIHtcbiAgICAgICAgaWYgKGN1clBhcmFtLmRpcmVjdGlvbikgeyBwYXJhbURlZi5wdXNoKGN1clBhcmFtLmRpcmVjdGlvbik7IH1cbiAgICAgICAgaWYgKGN1clBhcmFtLm5hbWUpIHsgcGFyYW1EZWYucHVzaChjdXJQYXJhbS5uYW1lKTsgfVxuICAgICAgICBwYXJhbURlZi5wdXNoKGN1clBhcmFtLnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBvciB0cmlnZ2VyIHVzZWQgd2l0aCBhIHBhcmFtZXRlciB3aXRob3V0IGFueSB0eXBlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGpvaW5lZCA9IHBhcmFtRGVmLmpvaW4oJyAnKTtcbiAgICAgIGlmIChqb2luZWQpIHBhcmFtTGlzdC5wdXNoKGpvaW5lZCk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbUxpc3Quam9pbignLCAnKTtcbiAgfVxuXG4gIF9leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdCh2YXJpYWJsZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFyaWFibGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3Q6IGZ1bmN0aW9uIHZhcmlhYmxlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhYmxlRGVmaW5pdGlvbnMgPSBbXTtcbiAgICB2YXJpYWJsZXMuZm9yRWFjaCh2YXJpYWJsZSA9PiB7XG4gICAgICBpZiAoIXZhcmlhYmxlLm5hbWUgfHwgIXZhcmlhYmxlLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiB2YXJpYWJsZSBtdXN0IGhhdmUgYSBuYW1lIGFuZCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBsZXQgdmFyaWFibGVEZWZpbml0aW9uID0gYERFQ0xBUkUgJHt2YXJpYWJsZS5uYW1lfSAke3ZhcmlhYmxlLnR5cGV9YDtcbiAgICAgIGlmICh2YXJpYWJsZS5kZWZhdWx0KSB7XG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbiArPSBgIDo9ICR7dmFyaWFibGUuZGVmYXVsdH1gO1xuICAgICAgfVxuICAgICAgdmFyaWFibGVEZWZpbml0aW9uICs9ICc7JztcbiAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnMucHVzaCh2YXJpYWJsZURlZmluaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB2YXJpYWJsZURlZmluaXRpb25zLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGV4cGFuZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgXy5pc0VtcHR5KG9wdGlvbnMpID9cbiAgICAgICcnIDogb3B0aW9ucy5qb2luKCcgJyk7XG4gIH1cblxuICBkZWNvZGVUcmlnZ2VyRXZlbnRUeXBlKGV2ZW50U3BlY2lmaWVyKSB7XG4gICAgY29uc3QgRVZFTlRfREVDT0RFUiA9IHtcbiAgICAgICdhZnRlcic6ICdBRlRFUicsXG4gICAgICAnYmVmb3JlJzogJ0JFRk9SRScsXG4gICAgICAnaW5zdGVhZF9vZic6ICdJTlNURUFEIE9GJyxcbiAgICAgICdhZnRlcl9jb25zdHJhaW50JzogJ0FGVEVSJ1xuICAgIH07XG5cbiAgICBpZiAoIUVWRU5UX0RFQ09ERVJbZXZlbnRTcGVjaWZpZXJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZ2dlciBldmVudCBzcGVjaWZpZWQ6ICR7ZXZlbnRTcGVjaWZpZXJ9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEVWRU5UX0RFQ09ERVJbZXZlbnRTcGVjaWZpZXJdO1xuICB9XG5cbiAgdHJpZ2dlckV2ZW50VHlwZUlzQ29uc3RyYWludChldmVudFNwZWNpZmllcikge1xuICAgIHJldHVybiBldmVudFNwZWNpZmllciA9PT0gJ2FmdGVyX2NvbnN0cmFpbnQnID8gJ0NPTlNUUkFJTlQgJyA6ICcnO1xuICB9XG5cbiAgZXhwYW5kVHJpZ2dlckV2ZW50U3BlYyhmaXJlT25TcGVjKSB7XG4gICAgaWYgKF8uaXNFbXB0eShmaXJlT25TcGVjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB0YWJsZSBjaGFuZ2UgZXZlbnRzIHNwZWNpZmllZCB0byB0cmlnZ2VyIG9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8ubWFwKGZpcmVPblNwZWMsIChmaXJlVmFsdWUsIGZpcmVLZXkpID0+IHtcbiAgICAgIGNvbnN0IEVWRU5UX01BUCA9IHtcbiAgICAgICAgJ2luc2VydCc6ICdJTlNFUlQnLFxuICAgICAgICAndXBkYXRlJzogJ1VQREFURScsXG4gICAgICAgICdkZWxldGUnOiAnREVMRVRFJyxcbiAgICAgICAgJ3RydW5jYXRlJzogJ1RSVU5DQVRFJ1xuICAgICAgfTtcblxuICAgICAgaWYgKCFFVkVOVF9NQVBbZmlyZVZhbHVlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlVHJpZ2dlckV2ZW50U3BlYzogdW5kZWZpbmVkIHRyaWdnZXIgZXZlbnQgJHtmaXJlS2V5fWApO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXZlbnRTcGVjID0gRVZFTlRfTUFQW2ZpcmVWYWx1ZV07XG4gICAgICBpZiAoZXZlbnRTcGVjID09PSAnVVBEQVRFJykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJlVmFsdWUpICYmIGZpcmVWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRTcGVjICs9IGAgT0YgJHtmaXJlVmFsdWUuam9pbignLCAnKX1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudFNwZWM7XG4gICAgfSkuam9pbignIE9SICcpO1xuICB9XG5cbiAgcGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHRhYmxlRGV0YWlscyA9IHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGxldCBlbnVtTmFtZSA9IFV0aWxzLmFkZFRpY2tzKFV0aWxzLmdlbmVyYXRlRW51bU5hbWUodGFibGVEZXRhaWxzLnRhYmxlTmFtZSwgYXR0ciksICdcIicpO1xuXG4gICAgLy8gcGdMaXN0RW51bXMgcmVxdWlyZXMgdGhlIGVudW0gbmFtZSBvbmx5LCB3aXRob3V0IHRoZSBzY2hlbWFcbiAgICBpZiAob3B0aW9ucy5zY2hlbWEgIT09IGZhbHNlICYmIHRhYmxlRGV0YWlscy5zY2hlbWEpIHtcbiAgICAgIGVudW1OYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVEZXRhaWxzLnNjaGVtYSkgKyB0YWJsZURldGFpbHMuZGVsaW1pdGVyICsgZW51bU5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudW1OYW1lO1xuICB9XG5cbiAgcGdMaXN0RW51bXModGFibGVOYW1lLCBhdHRyTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBlbnVtTmFtZSA9ICcnO1xuICAgIGNvbnN0IHRhYmxlRGV0YWlscyA9IHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRhYmxlRGV0YWlscy50YWJsZU5hbWUgJiYgYXR0ck5hbWUpIHtcbiAgICAgIGVudW1OYW1lID0gYCBBTkQgdC50eXBuYW1lPSR7dGhpcy5wZ0VudW1OYW1lKHRhYmxlRGV0YWlscy50YWJsZU5hbWUsIGF0dHJOYW1lLCB7IHNjaGVtYTogZmFsc2UgfSkucmVwbGFjZSgvXCIvZywgXCInXCIpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuICdTRUxFQ1QgdC50eXBuYW1lIGVudW1fbmFtZSwgYXJyYXlfYWdnKGUuZW51bWxhYmVsIE9SREVSIEJZIGVudW1zb3J0b3JkZXIpIGVudW1fdmFsdWUgRlJPTSBwZ190eXBlIHQgJyArXG4gICAgICAnSk9JTiBwZ19lbnVtIGUgT04gdC5vaWQgPSBlLmVudW10eXBpZCAnICtcbiAgICAgICdKT0lOIHBnX2NhdGFsb2cucGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSB0LnR5cG5hbWVzcGFjZSAnICtcbiAgICAgIGBXSEVSRSBuLm5zcG5hbWUgPSAnJHt0YWJsZURldGFpbHMuc2NoZW1hfScke2VudW1OYW1lfSBHUk9VUCBCWSAxYDtcbiAgfVxuXG4gIHBnRW51bSh0YWJsZU5hbWUsIGF0dHIsIGRhdGFUeXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyLCBvcHRpb25zKTtcbiAgICBsZXQgdmFsdWVzO1xuXG4gICAgaWYgKGRhdGFUeXBlLnZhbHVlcykge1xuICAgICAgdmFsdWVzID0gYEVOVU0oJHtkYXRhVHlwZS52YWx1ZXMubWFwKHZhbHVlID0+IHRoaXMuZXNjYXBlKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gZGF0YVR5cGUudG9TdHJpbmcoKS5tYXRjaCgvXkVOVU1cXCguK1xcKS8pWzBdO1xuICAgIH1cblxuICAgIGxldCBzcWwgPSBgQ1JFQVRFIFRZUEUgJHtlbnVtTmFtZX0gQVMgJHt2YWx1ZXN9O2A7XG4gICAgaWYgKCEhb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlID09PSB0cnVlKSB7XG4gICAgICBzcWwgPSB0aGlzLnBnRW51bURyb3AodGFibGVOYW1lLCBhdHRyKSArIHNxbDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuXG4gIHBnRW51bUFkZCh0YWJsZU5hbWUsIGF0dHIsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKTtcbiAgICBsZXQgc3FsID0gYEFMVEVSIFRZUEUgJHtlbnVtTmFtZX0gQUREIFZBTFVFIGA7XG5cbiAgICBpZiAoc2VtdmVyLmd0ZSh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgJzkuMy4wJykpIHtcbiAgICAgIHNxbCArPSAnSUYgTk9UIEVYSVNUUyAnO1xuICAgIH1cbiAgICBzcWwgKz0gdGhpcy5lc2NhcGUodmFsdWUpO1xuXG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICBzcWwgKz0gYCBCRUZPUkUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmJlZm9yZSl9YDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWZ0ZXIpIHtcbiAgICAgIHNxbCArPSBgIEFGVEVSICR7dGhpcy5lc2NhcGUob3B0aW9ucy5hZnRlcil9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgcGdFbnVtRHJvcCh0YWJsZU5hbWUsIGF0dHIsIGVudW1OYW1lKSB7XG4gICAgZW51bU5hbWUgPSBlbnVtTmFtZSB8fCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKTtcbiAgICByZXR1cm4gYERST1AgVFlQRSBJRiBFWElTVFMgJHtlbnVtTmFtZX07IGA7XG4gIH1cblxuICBmcm9tQXJyYXkodGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL157LywgJycpLnJlcGxhY2UoL30kLywgJycpO1xuICAgIGxldCBtYXRjaGVzID0gdGV4dC5tYXRjaCgvKFwiKD86XFxcXC58W15cIlxcXFxcXFxcXSkqXCJ8W14sXSopKD86XFxzKixcXHMqfFxccyokKS9pZyk7XG5cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMubWFwKG0gPT4gbS5yZXBsYWNlKC9cIiwkLywgJycpLnJlcGxhY2UoLywkLywgJycpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCAnJykpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgLTEpO1xuICB9XG5cbiAgZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0ciwgZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ1BSSU1BUlkgS0VZJykpIHtcbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnUFJJTUFSWSBLRVknLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdTRVJJQUwnKSkge1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdCSUdJTlQnKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ1NFUklBTCcsICdCSUdTRVJJQUwnKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKCdCSUdJTlQnLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdTTUFMTElOVCcpKSB7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnU0VSSUFMJywgJ1NNQUxMU0VSSUFMJyk7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgnU01BTExJTlQnLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ0lOVEVHRVInLCAnJyk7XG4gICAgICB9XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoJ05PVCBOVUxMJywgJycpO1xuICAgIH1cblxuICAgIGlmIChkYXRhVHlwZS5zdGFydHNXaXRoKCdFTlVNKCcpKSB7XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoL15FTlVNXFwoLitcXCkvLCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBTUUwgcXVlcnkgdGhhdCByZXR1cm5zIGFsbCBmb3JlaWduIGtleXMgb2YgYSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWJsZU5hbWUgIFRoZSBuYW1lIG9mIHRoZSB0YWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuICdTRUxFQ1QgY29ubmFtZSBhcyBjb25zdHJhaW50X25hbWUsIHBnX2NhdGFsb2cucGdfZ2V0X2NvbnN0cmFpbnRkZWYoci5vaWQsIHRydWUpIGFzIGNvbmRlZiBGUk9NIHBnX2NhdGFsb2cucGdfY29uc3RyYWludCByICcgK1xuICAgICAgYFdIRVJFIHIuY29ucmVsaWQgPSAoU0VMRUNUIG9pZCBGUk9NIHBnX2NsYXNzIFdIRVJFIHJlbG5hbWUgPSAnJHt0YWJsZU5hbWV9JyBMSU1JVCAxKSBBTkQgci5jb250eXBlID0gJ2YnIE9SREVSIEJZIDE7YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBjb21tb24gU1FMIHByZWZpeCBmb3IgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIF9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KCkge1xuICAgIHJldHVybiAnU0VMRUNUICcgK1xuICAgICAgJ0RJU1RJTkNUIHRjLmNvbnN0cmFpbnRfbmFtZSBhcyBjb25zdHJhaW50X25hbWUsICcgK1xuICAgICAgJ3RjLmNvbnN0cmFpbnRfc2NoZW1hIGFzIGNvbnN0cmFpbnRfc2NoZW1hLCAnICtcbiAgICAgICd0Yy5jb25zdHJhaW50X2NhdGFsb2cgYXMgY29uc3RyYWludF9jYXRhbG9nLCAnICtcbiAgICAgICd0Yy50YWJsZV9uYW1lIGFzIHRhYmxlX25hbWUsJyArXG4gICAgICAndGMudGFibGVfc2NoZW1hIGFzIHRhYmxlX3NjaGVtYSwnICtcbiAgICAgICd0Yy50YWJsZV9jYXRhbG9nIGFzIHRhYmxlX2NhdGFsb2csJyArXG4gICAgICAna2N1LmNvbHVtbl9uYW1lIGFzIGNvbHVtbl9uYW1lLCcgK1xuICAgICAgJ2NjdS50YWJsZV9zY2hlbWEgIEFTIHJlZmVyZW5jZWRfdGFibGVfc2NoZW1hLCcgK1xuICAgICAgJ2NjdS50YWJsZV9jYXRhbG9nICBBUyByZWZlcmVuY2VkX3RhYmxlX2NhdGFsb2csJyArXG4gICAgICAnY2N1LnRhYmxlX25hbWUgIEFTIHJlZmVyZW5jZWRfdGFibGVfbmFtZSwnICtcbiAgICAgICdjY3UuY29sdW1uX25hbWUgQVMgcmVmZXJlbmNlZF9jb2x1bW5fbmFtZSAnICtcbiAgICAgICdGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZV9jb25zdHJhaW50cyBBUyB0YyAnICtcbiAgICAgICdKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5rZXlfY29sdW1uX3VzYWdlIEFTIGtjdSAnICtcbiAgICAgICdPTiB0Yy5jb25zdHJhaW50X25hbWUgPSBrY3UuY29uc3RyYWludF9uYW1lICcgK1xuICAgICAgJ0pPSU4gaW5mb3JtYXRpb25fc2NoZW1hLmNvbnN0cmFpbnRfY29sdW1uX3VzYWdlIEFTIGNjdSAnICtcbiAgICAgICdPTiBjY3UuY29uc3RyYWludF9uYW1lID0gdGMuY29uc3RyYWludF9uYW1lICc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJldHVybnMgYWxsIGZvcmVpZ24ga2V5cyBkZXRhaWxzIG9mIGEgdGFibGUuXG4gICAqXG4gICAqIEFzIGZvciBnZXRGb3JlaWduS2V5c1F1ZXJ5IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeSwgc28gYWRkIGEgbmV3IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRhbG9nTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hTmFtZVxuICAgKi9cbiAgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeSh0YWJsZU5hbWUsIGNhdGFsb2dOYW1lLCBzY2hlbWFOYW1lKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKVxuICAgIH1XSEVSRSBjb25zdHJhaW50X3R5cGUgPSAnRk9SRUlHTiBLRVknIEFORCB0Yy50YWJsZV9uYW1lID0gJyR7dGFibGVOYW1lfScke1xuICAgICAgY2F0YWxvZ05hbWUgPyBgIEFORCB0Yy50YWJsZV9jYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9J2AgOiAnJ1xuICAgIH0ke3NjaGVtYU5hbWUgPyBgIEFORCB0Yy50YWJsZV9zY2hlbWEgPSAnJHtzY2hlbWFOYW1lfSdgIDogJyd9YDtcbiAgfVxuXG4gIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG4gICAgcmV0dXJuIGAke3RoaXMuX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKVxuICAgIH1XSEVSRSBjb25zdHJhaW50X3R5cGUgPSAnRk9SRUlHTiBLRVknIEFORCB0Yy50YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nIEFORCAga2N1LmNvbHVtbl9uYW1lID0gJyR7Y29sdW1uTmFtZX0nJHtcbiAgICAgIHNjaGVtYSA/IGAgQU5EIHRjLnRhYmxlX3NjaGVtYSA9ICcke3NjaGVtYX0nYCA6ICcnfWA7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIFNRTCBxdWVyeSB0aGF0IHJlbW92ZXMgYSBmb3JlaWduIGtleSBmcm9tIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFibGVOYW1lICBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZm9yZWlnbktleSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgY29uc3RyYWludC5cbiAgICogQHJldHVybnMge3N0cmluZ30gICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNxbCBxdWVyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBEUk9QIENPTlNUUkFJTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KX07YDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc3RncmVzUXVlcnlHZW5lcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEtdHlwZXMnKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSB0aGF0IFNlcXVlbGl6ZSB1c2VzIHRvIHRhbGsgd2l0aCBQb3N0Z3JlcyBkYXRhYmFzZVxuICovXG5jbGFzcyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICAvKipcbiAgICogRW5zdXJlIGVudW0gYW5kIHRoZWlyIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAgTmFtZSBvZiB0YWJsZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgT2JqZWN0IHJlcHJlc2VudGluZyBhIGxpc3Qgb2Ygbm9ybWFsaXplZCB0YWJsZSBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtNb2RlbH0gIFttb2RlbF1cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBrZXlMZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGxldCBzcWwgPSAnJztcbiAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5c1tpXV07XG4gICAgICBjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8XG4gICAgICAgIHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgdHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gLy9BUlJBWSBzdWIgdHlwZSBpcyBFTlVNXG4gICAgICApIHtcbiAgICAgICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZS5maWVsZCB8fCBrZXlzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgICAgICBzcWwsXG4gICAgICAgICAgeyAuLi5vcHRpb25zLCBwbGFpbjogdHJ1ZSwgcmF3OiB0cnVlLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCB9XG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgZW51bUlkeCA9IDA7XG5cbiAgICAvLyBUaGlzIGxpdHRsZSBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gcmUtdXNlIHRoZSBzYW1lIGNvZGUgdGhhdCBwcmVwZW5kcyBvciBhcHBlbmRzIG5ldyB2YWx1ZSB0byBlbnVtIGFycmF5XG4gICAgY29uc3QgYWRkRW51bVZhbHVlID0gKGZpZWxkLCB2YWx1ZSwgcmVsYXRpdmVWYWx1ZSwgcG9zaXRpb24gPSAnYmVmb3JlJywgc3BsaWNlU3RhcnQgPSBwcm9taXNlcy5sZW5ndGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgdmFsdWVPcHRpb25zLmJlZm9yZSA9IG51bGw7XG4gICAgICB2YWx1ZU9wdGlvbnMuYWZ0ZXIgPSBudWxsO1xuXG4gICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICB2YWx1ZU9wdGlvbnMuYWZ0ZXIgPSByZWxhdGl2ZVZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlT3B0aW9ucy5iZWZvcmUgPSByZWxhdGl2ZVZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlcy5zcGxpY2Uoc3BsaWNlU3RhcnQsIDAsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtQWRkKFxuICAgICAgICAgIHRhYmxlTmFtZSwgZmllbGQsIHZhbHVlLCB2YWx1ZU9wdGlvbnNcbiAgICAgICAgKSwgdmFsdWVPcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5c1tpXV07XG4gICAgICBjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgICBjb25zdCBlbnVtVHlwZSA9IHR5cGUudHlwZSB8fCB0eXBlO1xuICAgICAgY29uc3QgZmllbGQgPSBhdHRyaWJ1dGUuZmllbGQgfHwga2V5c1tpXTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHxcbiAgICAgICAgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiBlbnVtVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIC8vQVJSQVkgc3ViIHR5cGUgaXMgRU5VTVxuICAgICAgKSB7XG4gICAgICAgIC8vIElmIHRoZSBlbnVtIHR5cGUgZG9lc24ndCBleGlzdCB0aGVuIGNyZWF0ZSBpdFxuICAgICAgICBpZiAoIXJlc3VsdHNbZW51bUlkeF0pIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bSh0YWJsZU5hbWUsIGZpZWxkLCBlbnVtVHlwZSwgb3B0aW9ucyksIHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCEhcmVzdWx0c1tlbnVtSWR4XSAmJiAhIW1vZGVsKSB7XG4gICAgICAgICAgY29uc3QgZW51bVZhbHMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyZXN1bHRzW2VudW1JZHhdLmVudW1fdmFsdWUpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBlbnVtVHlwZS52YWx1ZXM7XG5cbiAgICAgICAgICAvLyBHb2luZyB0aHJvdWdoIGFscmVhZHkgZXhpc3RpbmcgdmFsdWVzIGFsbG93cyB1cyB0byBtYWtlIHF1ZXJpZXMgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzXG4gICAgICAgICAgLy8gV2Ugd2lsbCBwcmVwZW5kIGFsbCBuZXcgdmFsdWVzIGJldHdlZW4gdGhlIG9sZCBvbmVzLCBidXQga2VlcCBpbiBtaW5kIC0gd2UgY2FuJ3QgY2hhbmdlIG9yZGVyIG9mIGFscmVhZHkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgICAgLy8gVGhlbiB3ZSBhcHBlbmQgdGhlIHJlc3Qgb2YgbmV3IHZhbHVlcyBBRlRFUiB0aGUgbGF0ZXN0IGFscmVhZHkgZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAvLyBFLmcuOiBbMSwyXSAtPiBbMCwyLDFdID09PiBbMSwwLDJdXG4gICAgICAgICAgLy8gRS5nLjogWzEsMiwzXSAtPiBbMiwxLDMsNF0gPT0+IFsxLDIsMyw0XVxuICAgICAgICAgIC8vIEUuZy46IFsxXSAtPiBbMCwyLDNdID09PiBbMSwwLDIsM11cbiAgICAgICAgICBsZXQgbGFzdE9sZEVudW1WYWx1ZTtcbiAgICAgICAgICBsZXQgcmlnaHRlc3RQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgIGZvciAobGV0IG9sZEluZGV4ID0gMDsgb2xkSW5kZXggPCBlbnVtVmFscy5sZW5ndGg7IG9sZEluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVudW1WYWwgPSBlbnVtVmFsc1tvbGRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBuZXdJZHggPSB2YWxzLmluZGV4T2YoZW51bVZhbCk7XG4gICAgICAgICAgICBsYXN0T2xkRW51bVZhbHVlID0gZW51bVZhbDtcblxuICAgICAgICAgICAgaWYgKG5ld0lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlc0JlZm9yZSA9IHZhbHMuc2xpY2UoMCwgbmV3SWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzTGVuZ3RoID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gd2UgZ28gaW4gcmV2ZXJzZSBvcmRlciBzbyB3ZSBjb3VsZCBzdG9wIHdoZW4gd2UgbWVldCBvbGQgdmFsdWVcbiAgICAgICAgICAgIGZvciAobGV0IHJldmVyc2VJZHggPSBuZXdWYWx1ZXNCZWZvcmUubGVuZ3RoIC0gMTsgcmV2ZXJzZUlkeCA+PSAwOyByZXZlcnNlSWR4LS0pIHtcbiAgICAgICAgICAgICAgaWYgKH5lbnVtVmFscy5pbmRleE9mKG5ld1ZhbHVlc0JlZm9yZVtyZXZlcnNlSWR4XSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFkZEVudW1WYWx1ZShmaWVsZCwgbmV3VmFsdWVzQmVmb3JlW3JldmVyc2VJZHhdLCBsYXN0T2xkRW51bVZhbHVlLCAnYmVmb3JlJywgcHJvbWlzZXNMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBkZXRlY3QgdGhlIG1vc3QgJ3JpZ2h0JyBwb3NpdGlvbiBvZiBvbGQgdmFsdWUgaW4gbmV3IGVudW0gYXJyYXkgc28gd2UgY2FuIGFwcGVuZCBuZXcgdmFsdWVzIHRvIGl0XG4gICAgICAgICAgICBpZiAobmV3SWR4ID4gcmlnaHRlc3RQb3NpdGlvbikge1xuICAgICAgICAgICAgICByaWdodGVzdFBvc2l0aW9uID0gbmV3SWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0T2xkRW51bVZhbHVlICYmIHJpZ2h0ZXN0UG9zaXRpb24gPCB2YWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0VudW1WYWx1ZXMgPSB2YWxzLnNsaWNlKHJpZ2h0ZXN0UG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJldmVyc2VJZHggPSByZW1haW5pbmdFbnVtVmFsdWVzLmxlbmd0aCAtIDE7IHJldmVyc2VJZHggPj0gMDsgcmV2ZXJzZUlkeC0tKSB7XG4gICAgICAgICAgICAgIGFkZEVudW1WYWx1ZShmaWVsZCwgcmVtYWluaW5nRW51bVZhbHVlc1tyZXZlcnNlSWR4XSwgbGFzdE9sZEVudW1WYWx1ZSwgJ2FmdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW51bUlkeCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZXNcbiAgICAgIC5yZWR1Y2UoYXN5bmMgKHByb21pc2UsIGFzeW5jRnVuY3Rpb24pID0+IGF3YWl0IGFzeW5jRnVuY3Rpb24oYXdhaXQgcHJvbWlzZSksIFByb21pc2UucmVzb2x2ZSgpKTtcblxuICAgIC8vIElmIEVOVU0gcHJvY2Vzc2VkLCB0aGVuIHJlZnJlc2ggT0lEc1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuX3JlZnJlc2hEeW5hbWljT0lEcygpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZU1xuICAgIH07XG5cbiAgICAvLyBwb3N0Z3JlcyBuZWVkcyBzb21lIHNwZWNpYWwgdHJlYXRtZW50IGFzIHRob3NlIGZpZWxkIG5hbWVzIHJldHVybmVkIGFyZSBhbGwgbG93ZXJjYXNlXG4gICAgLy8gaW4gb3JkZXIgdG8ga2VlcCBzYW1lIHJlc3VsdCB3aXRoIG90aGVyIGRpYWxlY3RzLlxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgcXVlcnlPcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcChVdGlscy5jYW1lbGl6ZU9iamVjdEtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3Agc3BlY2lmaWVkIGVudW0gZnJvbSBkYXRhYmFzZSAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbnVtTmFtZV0gIEVudW0gbmFtZSB0byBkcm9wXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wRW51bShlbnVtTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KFxuICAgICAgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKG51bGwsIG51bGwsIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFc2NhcGVBbmRRdW90ZShlbnVtTmFtZSkpLFxuICAgICAgeyAuLi5vcHRpb25zLCByYXc6IHRydWUgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgZW51bXMgZnJvbSBkYXRhYmFzZSAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUXVlcnkgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3BBbGxFbnVtcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBlbnVtcyA9IGF3YWl0IHRoaXMucGdMaXN0RW51bXMobnVsbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoZW51bXMubWFwKHJlc3VsdCA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcbiAgICAgIHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChudWxsLCBudWxsLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRXNjYXBlQW5kUXVvdGUocmVzdWx0LmVudW1fbmFtZSkpLFxuICAgICAgeyAuLi5vcHRpb25zLCByYXc6IHRydWUgfVxuICAgICkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGFsbCBlbnVtcyAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWJsZU5hbWVdICBUYWJsZSB3aG9zZSBlbnVtIHRvIGxpc3RcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgICBRdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcGdMaXN0RW51bXModGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0xpc3RFbnVtcyh0YWJsZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIHsgLi4ub3B0aW9ucywgcGxhaW46IGZhbHNlLCByYXc6IHRydWUsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbmNlIHBvc3RncmVzIGhhcyBhIHNwZWNpYWwgY2FzZSBmb3IgZW51bXMsIHdlIHNob3VsZCBkcm9wIHRoZSByZWxhdGVkXG4gICAqIGVudW0gdHlwZSB3aXRoaW4gdGhlIHRhYmxlIGFuZCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBkcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgc3VwZXIuZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCBpbnN0YW5jZVRhYmxlID0gdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmdldE1vZGVsKHRhYmxlTmFtZSwgeyBhdHRyaWJ1dGU6ICd0YWJsZU5hbWUnIH0pO1xuXG4gICAgaWYgKCFpbnN0YW5jZVRhYmxlKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIHdoZW4gbW9kZWwgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFRhYmxlTmFtZSA9ICghb3B0aW9ucyB8fCAhb3B0aW9ucy5zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWEgPT09ICdwdWJsaWMnID8gJycgOiBgJHtvcHRpb25zLnNjaGVtYX1fYCkgKyB0YWJsZU5hbWU7XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2VUYWJsZS5yYXdBdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBrZXlMZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGlmIChpbnN0YW5jZVRhYmxlLnJhd0F0dHJpYnV0ZXNba2V5c1tpXV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChnZXRUYWJsZU5hbWUsIGtleXNbaV0pO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRzU2VhcmNoUGF0aCA9IGZhbHNlO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgeyAuLi5vcHRpb25zLCByYXc6IHRydWUgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxufVxuXG5leHBvcnRzLlBvc3RncmVzUXVlcnlJbnRlcmZhY2UgPSBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnknKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbG9nZ2VyJyk7XG5cbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dCgnc3FsOnBnJyk7XG5cblxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgLyoqXG4gICAqIFJld3JpdGUgcXVlcnkgd2l0aCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsXG4gICAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSB2YWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWxlY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IHN0cmluZ1JlcGxhY2VGdW5jID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKSA6IHZhbHVlO1xuXG4gICAgbGV0IGJpbmRQYXJhbTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBiaW5kUGFyYW0gPSB2YWx1ZXMubWFwKHN0cmluZ1JlcGxhY2VGdW5jKTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmluZFBhcmFtID0gW107XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCBzZWVuID0ge307XG4gICAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzKSA9PiB7XG4gICAgICAgIGlmIChzZWVuW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzZWVuW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpID0gaSArIDE7XG4gICAgICAgICAgYmluZFBhcmFtLnB1c2goc3RyaW5nUmVwbGFjZUZ1bmModmFsdWVzW2tleV0pKTtcbiAgICAgICAgICBzZWVuW2tleV0gPSBgJCR7aX1gO1xuICAgICAgICAgIHJldHVybiBgJCR7aX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cblxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFfLmlzRW1wdHkodGhpcy5vcHRpb25zLnNlYXJjaFBhdGgpKSB7XG4gICAgICBzcWwgPSB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLnNldFNlYXJjaFBhdGgodGhpcy5vcHRpb25zLnNlYXJjaFBhdGgpICsgc3FsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgdGhpcy5vcHRpb25zLmluY2x1ZGVBbGlhc2VzKSB7XG4gICAgICBfLnRvUGFpcnModGhpcy5vcHRpb25zLmluY2x1ZGVBbGlhc2VzKVxuICAgICAgICAvLyBTb3J0aW5nIHRvIHJlcGxhY2UgdGhlIGxvbmdlc3QgYWxpYXNlcyBmaXJzdCB0byBwcmV2ZW50IGFsaWFzIGNvbGxpc2lvblxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXS5sZW5ndGggLSBhWzFdLmxlbmd0aClcbiAgICAgICAgLmZvckVhY2goKFthbGlhcywgb3JpZ2luYWxdKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChfLmVzY2FwZVJlZ0V4cChvcmlnaW5hbCksICdnJyk7XG5cbiAgICAgICAgICBzcWwgPSBzcWwucmVwbGFjZShyZWcsIGFsaWFzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zcWwgPSBzcWw7XG5cbiAgICBjb25zdCBxdWVyeSA9IHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycy5sZW5ndGhcbiAgICAgID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubmVjdGlvbi5xdWVyeShzcWwsIHBhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpKVxuICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uZWN0aW9uLnF1ZXJ5KHNxbCwgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkpO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcblxuICAgIGxldCBxdWVyeVJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICBxdWVyeVJlc3VsdCA9IGF3YWl0IHF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gc2V0IHRoZSBjbGllbnQgc28gdGhhdCBpdCB3aWxsIGJlIHJlYXBlZCBpZiB0aGUgY29ubmVjdGlvbiByZXNldHMgd2hpbGUgZXhlY3V0aW5nXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJykge1xuICAgICAgICBjb25uZWN0aW9uLl9pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZXJyLnNxbCA9IHNxbDtcbiAgICAgIGVyci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBjb21wbGV0ZSgpO1xuXG4gICAgbGV0IHJvd3MgPSBBcnJheS5pc0FycmF5KHF1ZXJ5UmVzdWx0KVxuICAgICAgPyBxdWVyeVJlc3VsdC5yZWR1Y2UoKGFsbFJvd3MsIHIpID0+IGFsbFJvd3MuY29uY2F0KHIucm93cyB8fCBbXSksIFtdKVxuICAgICAgOiBxdWVyeVJlc3VsdC5yb3dzO1xuICAgIGNvbnN0IHJvd0NvdW50ID0gQXJyYXkuaXNBcnJheShxdWVyeVJlc3VsdClcbiAgICAgID8gcXVlcnlSZXN1bHQucmVkdWNlKFxuICAgICAgICAoY291bnQsIHIpID0+IE51bWJlci5pc0Zpbml0ZShyLnJvd0NvdW50KSA/IGNvdW50ICsgci5yb3dDb3VudCA6IGNvdW50LFxuICAgICAgICAwXG4gICAgICApXG4gICAgICA6IHF1ZXJ5UmVzdWx0LnJvd0NvdW50IHx8IDA7XG5cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZykge1xuICAgICAgcm93cyA9IHJvd3NcbiAgICAgICAgLm1hcChyb3cgPT4gXy50b1BhaXJzKHJvdylcbiAgICAgICAgICAucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGFjY1ttYXBwaW5nIHx8IGtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfSwge30pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNUYWJsZU5hbWVRdWVyeSA9IHNxbC5zdGFydHNXaXRoKCdTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMnKTtcbiAgICBjb25zdCBpc1JlbE5hbWVRdWVyeSA9IHNxbC5zdGFydHNXaXRoKCdTRUxFQ1QgcmVsbmFtZSBGUk9NIHBnX2NsYXNzIFdIRVJFIG9pZCBJTicpO1xuXG4gICAgaWYgKGlzUmVsTmFtZVF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+ICh7XG4gICAgICAgIG5hbWU6IHJvdy5yZWxuYW1lLFxuICAgICAgICB0YWJsZU5hbWU6IHJvdy5yZWxuYW1lLnNwbGl0KCdfJylbMF1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGlzVGFibGVOYW1lUXVlcnkpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4gT2JqZWN0LnZhbHVlcyhyb3cpKTtcbiAgICB9XG5cbiAgICBpZiAocm93c1swXSAmJiByb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3Ioe1xuICAgICAgICAgIHNxbCxcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIGNvZGU6ICcyMzUwNScsXG4gICAgICAgICAgZGV0YWlsOiByb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBkZWxldGUgcm93LnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAvT04gLio/ICg/OlVTSU5HIC4qP1xccyk/XFwoKFteXSopXFwpL2dpLmV4ZWMocm93LmRlZmluaXRpb24pWzFdLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgLy8gTWFwIGNvbHVtbiBpbmRleCBpbiB0YWJsZSB0byBjb2x1bW4gbmFtZVxuICAgICAgICBjb25zdCBjb2x1bW5zID0gXy56aXBPYmplY3QoXG4gICAgICAgICAgcm93LmNvbHVtbl9pbmRleGVzLFxuICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJvdy5jb2x1bW5fbmFtZXMpXG4gICAgICAgICk7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1uX2luZGV4ZXM7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1uX25hbWVzO1xuXG4gICAgICAgIGxldCBmaWVsZDtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZTtcblxuICAgICAgICAvLyBJbmRrZXkgaXMgdGhlIG9yZGVyIG9mIGF0dHJpYnV0ZXMgaW4gdGhlIGluZGV4LCBzcGVjaWZpZWQgYnkgYSBzdHJpbmcgb2YgYXR0cmlidXRlIGluZGV4ZXNcbiAgICAgICAgcm93LmZpZWxkcyA9IHJvdy5pbmRrZXkuc3BsaXQoJyAnKS5tYXAoKGluZEtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBmaWVsZCA9IGNvbHVtbnNbaW5kS2V5XTtcbiAgICAgICAgICAvLyBmb3IgZnVuY3Rpb25hbCBpbmRpY2VzIGluZEtleSA9IDBcbiAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogZmllbGQsXG4gICAgICAgICAgICBjb2xsYXRlOiBhdHRyaWJ1dGUubWF0Y2goL0NPTExBVEUgXCIoLio/KVwiLykgPyAvQ09MTEFURSBcIiguKj8pXCIvLmV4ZWMoYXR0cmlidXRlKVsxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9yZGVyOiBhdHRyaWJ1dGUuaW5jbHVkZXMoJ0RFU0MnKSA/ICdERVNDJyA6IGF0dHJpYnV0ZS5pbmNsdWRlcygnQVNDJykgPyAnQVNDJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxlbmd0aDogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKG4gPT4gbiAhPT0gbnVsbCk7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGxldCBkZWZQYXJ0cztcbiAgICAgICAgaWYgKHJvdy5jb25kZWYgIT09IHVuZGVmaW5lZCAmJiAoZGVmUGFydHMgPSByb3cuY29uZGVmLm1hdGNoKC9GT1JFSUdOIEtFWSBcXCgoLispXFwpIFJFRkVSRU5DRVMgKC4rKVxcKCguKylcXCkoIE9OIChVUERBVEV8REVMRVRFKSAoQ0FTQ0FERXxSRVNUUklDVCkpPyggT04gKFVQREFURXxERUxFVEUpIChDQVNDQURFfFJFU1RSSUNUKSk/LykpKSB7XG4gICAgICAgICAgcm93LmlkID0gcm93LmNvbnN0cmFpbnRfbmFtZTtcbiAgICAgICAgICByb3cudGFibGUgPSBkZWZQYXJ0c1syXTtcbiAgICAgICAgICByb3cuZnJvbSA9IGRlZlBhcnRzWzFdO1xuICAgICAgICAgIHJvdy50byA9IGRlZlBhcnRzWzNdO1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDU7IGkgPD0gODsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAoLyhVUERBVEV8REVMRVRFKS8udGVzdChkZWZQYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgcm93W2Bvbl8ke2RlZlBhcnRzW2ldLnRvTG93ZXJDYXNlKCl9YF0gPSBkZWZQYXJ0c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGxldCByZXN1bHQgPSByb3dzO1xuICAgICAgLy8gUG9zdGdyZXMgd2lsbCB0cmVhdCB0YWJsZXMgYXMgY2FzZS1pbnNlbnNpdGl2ZSwgc28gZml4IHRoZSBjYXNlXG4gICAgICAvLyBvZiB0aGUgcmV0dXJuZWQgdmFsdWVzIHRvIG1hdGNoIGF0dHJpYnV0ZXNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmF3ID09PSBmYWxzZSAmJiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzTWFwID0gXy5yZWR1Y2UodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAobSwgdiwgaykgPT4ge1xuICAgICAgICAgIG1bay50b0xvd2VyQ2FzZSgpXSA9IGs7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmVzdWx0ID0gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByZXR1cm4gXy5tYXBLZXlzKHJvdywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEF0dHIgPSBhdHRyc01hcFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRBdHRyID09PSAnc3RyaW5nJyAmJiB0YXJnZXRBdHRyICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkRFU0NSSUJFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogcm93LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IHJvdy5OdWxsID09PSAnWUVTJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHJvdy5EZWZhdWx0LFxuICAgICAgICAgIGNvbW1lbnQ6IHJvdy5Db21tZW50LFxuICAgICAgICAgIHNwZWNpYWw6IHJvdy5zcGVjaWFsID8gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocm93LnNwZWNpYWwpIDogW10sXG4gICAgICAgICAgcHJpbWFyeUtleTogcm93LkNvbnN0cmFpbnQgPT09ICdQUklNQVJZIEtFWSdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0udHlwZSA9PT0gJ0JPT0xFQU4nKSB7XG4gICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0geyAnZmFsc2UnOiBmYWxzZSwgJ3RydWUnOiB0cnVlIH1bcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlXTtcblxuICAgICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUucmVwbGFjZSgvJy9nLCAnJyk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLmluY2x1ZGVzKCc6OicpKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdCA9IHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5zcGxpdCgnOjonKTtcbiAgICAgICAgICAgIGlmIChzcGxpdFsxXS50b0xvd2VyQ2FzZSgpICE9PSAncmVnY2xhc3MpJykge1xuICAgICAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSBzcGxpdFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJvd3NbMF0uc2VydmVyX3ZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd09yRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuQlVMS1VQREFURSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocm93Q291bnQsIDEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJvd3MpO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5CVUxLREVMRVRFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHJvd0NvdW50LCAxMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJvd3NbMF0pIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJvd3NbMF0sIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJvd3NbMF1ba2V5XTtcblxuICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSB8fCByb3dzICYmICh0aGlzLm9wdGlvbnMucGxhaW4gJiYgcm93c1swXSB8fCByb3dzKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHJvd0NvdW50XG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcm93cywgcXVlcnlSZXN1bHRdO1xuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdGFibGU7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBmaWVsZHM7XG4gICAgbGV0IGVycm9ycztcbiAgICBsZXQgbWVzc2FnZTtcblxuICAgIGNvbnN0IGNvZGUgPSBlcnIuY29kZSB8fCBlcnIuc3FsU3RhdGU7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IGVyci5tZXNzYWdlUHJpbWFyeTtcbiAgICBjb25zdCBlcnJEZXRhaWwgPSBlcnIuZGV0YWlsIHx8IGVyci5tZXNzYWdlRGV0YWlsO1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlICcyMzUwMyc6XG4gICAgICAgIGluZGV4ID0gZXJyTWVzc2FnZS5tYXRjaCgvdmlvbGF0ZXMgZm9yZWlnbiBrZXkgY29uc3RyYWludCBcIiguKz8pXCIvKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA/IGluZGV4WzFdIDogdW5kZWZpbmVkO1xuICAgICAgICB0YWJsZSA9IGVyck1lc3NhZ2UubWF0Y2goL29uIHRhYmxlIFwiKC4rPylcIi8pO1xuICAgICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2U6IGVyck1lc3NhZ2UsIGZpZWxkczogbnVsbCwgaW5kZXgsIHRhYmxlLCBwYXJlbnQ6IGVyciB9KTtcbiAgICAgIGNhc2UgJzIzNTA1JzpcbiAgICAgICAgLy8gdGhlcmUgYXJlIG11bHRpcGxlIGRpZmZlcmVudCBmb3JtYXRzIG9mIGVycm9yIG1lc3NhZ2VzIGZvciB0aGlzIGVycm9yIGNvZGVcbiAgICAgICAgLy8gdGhpcyByZWdleCBzaG91bGQgY2hlY2sgYXQgbGVhc3QgdHdvXG4gICAgICAgIGlmIChlcnJEZXRhaWwgJiYgKG1hdGNoID0gZXJyRGV0YWlsLnJlcGxhY2UoL1wiL2csICcnKS5tYXRjaCgvS2V5IFxcKCguKj8pXFwpPVxcKCguKj8pXFwpLykpKSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QobWF0Y2hbMV0uc3BsaXQoJywgJyksIG1hdGNoWzJdLnNwbGl0KCcsICcpKTtcbiAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgICBtZXNzYWdlID0gJ1ZhbGlkYXRpb24gZXJyb3InO1xuXG4gICAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICAgICAgICAgIHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksXG4gICAgICAgICAgICAgICd1bmlxdWUgdmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2lucy5EQixcbiAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICAgICAnbm90X3VuaXF1ZSdcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzKSB7XG4gICAgICAgICAgICBfLmZvck93bih0aGlzLm1vZGVsLnVuaXF1ZUtleXMsIGNvbnN0cmFpbnQgPT4ge1xuICAgICAgICAgICAgICBpZiAoXy5pc0VxdWFsKGNvbnN0cmFpbnQuZmllbGRzLCBPYmplY3Qua2V5cyhmaWVsZHMpKSAmJiAhIWNvbnN0cmFpbnQubXNnKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGNvbnN0cmFpbnQubXNnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJNZXNzYWdlLFxuICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICcyM1AwMSc6XG4gICAgICAgIG1hdGNoID0gZXJyRGV0YWlsLm1hdGNoKC9LZXkgXFwoKC4qPylcXCk9XFwoKC4qPylcXCkvKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdChtYXRjaFsxXS5zcGxpdCgnLCAnKSwgbWF0Y2hbMl0uc3BsaXQoJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgPSAnRXhjbHVzaW9uIGNvbnN0cmFpbnQgZXJyb3InO1xuXG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBjb25zdHJhaW50OiBlcnIuY29uc3RyYWludCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdGFibGU6IGVyci50YWJsZSxcbiAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnNDI3MDQnOlxuICAgICAgICBpZiAoZXJyLnNxbCAmJiAvKENPTlNUUkFJTlR8SU5ERVgpL2dpLnRlc3QoZXJyLnNxbCkpIHtcbiAgICAgICAgICBtZXNzYWdlID0gJ1Vua25vd24gY29uc3RyYWludCBlcnJvcic7XG4gICAgICAgICAgaW5kZXggPSBlcnJNZXNzYWdlLm1hdGNoKC8oPzpjb25zdHJhaW50fGluZGV4KSBcIiguKz8pXCIvaSk7XG4gICAgICAgICAgaW5kZXggPSBpbmRleCA/IGluZGV4WzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHRhYmxlID0gZXJyTWVzc2FnZS5tYXRjaCgvcmVsYXRpb24gXCIoLis/KVwiL2kpO1xuICAgICAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgY29uc3RyYWludDogaW5kZXgsXG4gICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgIHBhcmVudDogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBpc0ZvcmVpZ25LZXlzUXVlcnkoKSB7XG4gICAgcmV0dXJuIC9TRUxFQ1QgY29ubmFtZSBhcyBjb25zdHJhaW50X25hbWUsIHBnX2NhdGFsb2dcXC5wZ19nZXRfY29uc3RyYWludGRlZlxcKHJcXC5vaWQsIHRydWVcXCkgYXMgY29uZGVmIEZST00gcGdfY2F0YWxvZ1xcLnBnX2NvbnN0cmFpbnQgciBXSEVSRSByXFwuY29ucmVsaWQgPSBcXChTRUxFQ1Qgb2lkIEZST00gcGdfY2xhc3MgV0hFUkUgcmVsbmFtZSA9ICcuKicgTElNSVQgMVxcKSBBTkQgclxcLmNvbnR5cGUgPSAnZicgT1JERVIgQlkgMTsvLnRlc3QodGhpcy5zcWwpO1xuICB9XG5cbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gJ2lkJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlSYW5nZUJvdW5kKGJvdW5kKSB7XG4gIGlmIChib3VuZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJyA7XG4gIH1cbiAgaWYgKGJvdW5kID09PSBJbmZpbml0eSB8fCBib3VuZCA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuIGJvdW5kLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm91bmQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlQm91bmQoYm91bmQsIHBhcnNlVHlwZSkge1xuICBpZiAoIWJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGJvdW5kID09PSAnaW5maW5pdHknKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmIChib3VuZCA9PT0gJy1pbmZpbml0eScpIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG4gIHJldHVybiBwYXJzZVR5cGUoYm91bmQpO1xuXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHRocm93IG5ldyBFcnJvcigncmFuZ2UgbXVzdCBiZSBhbiBhcnJheScpO1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gJ2VtcHR5JztcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgRXJyb3IoJ3JhbmdlIGFycmF5IGxlbmd0aCBtdXN0IGJlIDAgKGVtcHR5KSBvciAyIChsb3dlciBhbmQgdXBwZXIgYm91bmRzKScpO1xuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgJ2luY2x1c2l2ZScpKSB7XG4gICAgaWYgKGRhdGEuaW5jbHVzaXZlID09PSBmYWxzZSkgZGF0YS5pbmNsdXNpdmUgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBlbHNlIGlmICghZGF0YS5pbmNsdXNpdmUpIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIGZhbHNlXTtcbiAgICBlbHNlIGlmIChkYXRhLmluY2x1c2l2ZSA9PT0gdHJ1ZSkgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgdHJ1ZV07XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5pbmNsdXNpdmUgPSBbdHJ1ZSwgZmFsc2VdO1xuICB9XG5cbiAgXy5lYWNoKGRhdGEsICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmNsdXNpdmUnKSkgZGF0YS5pbmNsdXNpdmVbaW5kZXhdID0gISF2YWx1ZS5pbmNsdXNpdmU7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAndmFsdWUnKSkgZGF0YVtpbmRleF0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGxvd2VyQm91bmQgPSBzdHJpbmdpZnlSYW5nZUJvdW5kKGRhdGFbMF0pO1xuICBjb25zdCB1cHBlckJvdW5kID0gc3RyaW5naWZ5UmFuZ2VCb3VuZChkYXRhWzFdKTtcblxuICByZXR1cm4gYCR7KGRhdGEuaW5jbHVzaXZlWzBdID8gJ1snIDogJygnKSArIGxvd2VyQm91bmR9LCR7dXBwZXJCb3VuZH0ke2RhdGEuaW5jbHVzaXZlWzFdID8gJ10nIDogJyknfWA7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuZnVuY3Rpb24gcGFyc2UodmFsdWUsIHBhcnNlcikge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICBpZiAodmFsdWUgPT09ICdlbXB0eScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gdmFsdWVcbiAgICAuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpXG4gICAgLnNwbGl0KCcsJywgMik7XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIpIHJldHVybiB2YWx1ZTtcblxuICByZXN1bHQgPSByZXN1bHQubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcGFyc2VSYW5nZUJvdW5kKGl0ZW0sIHBhcnNlciksXG4gICAgICBpbmNsdXNpdmU6IGluZGV4ID09PSAwID8gdmFsdWVbMF0gPT09ICdbJyA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXSdcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdjb25uZWN0aW9uOnNxbGl0ZScpO1xuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vZGF0YS10eXBlcycpLnNxbGl0ZTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKCcuLi9wYXJzZXJTdG9yZScpKCdzcWxpdGUnKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG5cbiAgICAvLyBXZSBhdHRlbXB0IHRvIHBhcnNlIGZpbGUgbG9jYXRpb24gZnJvbSBhIGNvbm5lY3Rpb24gdXJpXG4gICAgLy8gYnV0IHdlIHNob3VsZG4ndCBtYXRjaCBzZXF1ZWxpemUgZGVmYXVsdCBob3N0LlxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3QgPT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICBkZWxldGUgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0O1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKCdzcWxpdGUzJyk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMpO1xuICB9XG5cbiAgYXN5bmMgX29uUHJvY2Vzc0V4aXQoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmNvbm5lY3Rpb25zKVxuICAgICAgICAubWFwKGNvbm5lY3Rpb24gPT4gcHJvbWlzaWZ5KGNhbGxiYWNrID0+IHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbl0uY2xvc2UoY2FsbGJhY2spKSgpKVxuICAgICk7XG4gICAgcmV0dXJuIHN1cGVyLl9vblByb2Nlc3NFeGl0LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhpcyBhcyBhIG1ldGhvZCBzbyB0aGF0IHRoZSBwYXJzaW5nIG1heSBiZSB1cGRhdGVkIHdoZW4gdGhlIHVzZXIgaGFzIGFkZGVkIGFkZGl0aW9uYWwsIGN1c3RvbSB0eXBlc1xuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuXG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXVpZCA9IG9wdGlvbnMudXVpZCB8fCAnZGVmYXVsdCc7XG4gICAgb3B0aW9ucy5zdG9yYWdlID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdG9yYWdlIHx8IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdCB8fCAnOm1lbW9yeTonO1xuICAgIG9wdGlvbnMuaW5NZW1vcnkgPSBvcHRpb25zLnN0b3JhZ2UgPT09ICc6bWVtb3J5OicgPyAxIDogMDtcblxuICAgIGNvbnN0IGRpYWxlY3RPcHRpb25zID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0T3B0aW9ucztcbiAgICBjb25zdCBkZWZhdWx0UmVhZFdyaXRlTW9kZSA9IHRoaXMubGliLk9QRU5fUkVBRFdSSVRFIHwgdGhpcy5saWIuT1BFTl9DUkVBVEU7XG5cbiAgICBvcHRpb25zLnJlYWRXcml0ZU1vZGUgPSBkaWFsZWN0T3B0aW9ucyAmJiBkaWFsZWN0T3B0aW9ucy5tb2RlIHx8IGRlZmF1bHRSZWFkV3JpdGVNb2RlO1xuXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF07XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmluTWVtb3J5ICYmIChvcHRpb25zLnJlYWRXcml0ZU1vZGUgJiB0aGlzLmxpYi5PUEVOX0NSRUFURSkgIT09IDApIHtcbiAgICAgIC8vIGF1dG9tYXRpYyBwYXRoIHByb3Zpc2lvbiBmb3IgYG9wdGlvbnMuc3RvcmFnZWBcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUob3B0aW9ucy5zdG9yYWdlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdID0gbmV3IHRoaXMubGliLkRhdGFiYXNlKFxuICAgICAgICBvcHRpb25zLnN0b3JhZ2UsXG4gICAgICAgIG9wdGlvbnMucmVhZFdyaXRlTW9kZSxcbiAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgIGRlYnVnKGBjb25uZWN0aW9uIGFjcXVpcmVkICR7b3B0aW9ucy51dWlkfWApO1xuICAgICAgICAgIHJlc29sdmUodGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wYXNzd29yZCkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBkZWZpbmUgYW5kIHVzZSBwYXNzd29yZCBmb3Igc3FsaXRlIGVuY3J5cHRpb24gcGx1Z2luIGxpa2Ugc3FsY2lwaGVyXG4gICAgICBjb25uZWN0aW9uLnJ1bihgUFJBR01BIEtFWT0ke3RoaXMuc2VxdWVsaXplLmVzY2FwZSh0aGlzLnNlcXVlbGl6ZS5jb25maWcucGFzc3dvcmQpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5mb3JlaWduS2V5cyAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gZGVmaW5lIGFuZCB1c2UgZm9yZWlnbiBrZXkgY29uc3RyYWludHMgdW5sZXNzXG4gICAgICAvLyBleHBsaWNpdGx5IGRpc2FsbG93ZWQuIEl0J3Mgc3RpbGwgb3B0LWluIHBlciByZWxhdGlvblxuICAgICAgY29ubmVjdGlvbi5ydW4oJ1BSQUdNQSBGT1JFSUdOX0tFWVM9T04nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuXG4gIHJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGZvcmNlKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uZmlsZW5hbWUgPT09ICc6bWVtb3J5OicgJiYgZm9yY2UgIT09IHRydWUpIHJldHVybjtcblxuICAgIGlmIChjb25uZWN0aW9uLnV1aWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIGRlYnVnKGBjb25uZWN0aW9uIHJlbGVhc2VkICR7Y29ubmVjdGlvbi51dWlkfWApO1xuICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi51dWlkXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVR5cGVzID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodW5kZWZpbmVkLCAnaHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9kYXRhdHlwZTMuaHRtbCcpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHVuc3VwcG9ydGVkIFNRTGl0ZSBvcHRpb25zLCBpLmUuLCBVTlNJR05FRCBhbmQgWkVST0ZJTEwsIGZvciB0aGUgaW50ZWdlciBkYXRhIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVR5cGUgVGhlIGJhc2UgaW50ZWdlciBkYXRhIHR5cGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl96ZXJvZmlsbCB8fCBkYXRhVHlwZS5fdW5zaWduZWQpIHtcbiAgICAgIHdhcm4oYFNRTGl0ZSBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggVU5TSUdORUQgb3IgWkVST0ZJTEwuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdW5kZWZpbmVkO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vc3FsaXRlLm9yZy9kYXRhdHlwZTMuaHRtbFxuICAgKi9cblxuICBCYXNlVHlwZXMuREFURS50eXBlcy5zcWxpdGUgPSBbJ0RBVEVUSU1FJ107XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMuc3FsaXRlID0gWydWQVJDSEFSJywgJ1ZBUkNIQVIgQklOQVJZJ107XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLnNxbGl0ZSA9IFsnQ0hBUicsICdDSEFSIEJJTkFSWSddO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5zcWxpdGUgPSBbJ1RFWFQnXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMuc3FsaXRlID0gWydUSU5ZSU5UJ107XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5zcWxpdGUgPSBbJ1NNQUxMSU5UJ107XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMuc3FsaXRlID0gWydNRURJVU1JTlQnXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMuc3FsaXRlID0gWydJTlRFR0VSJ107XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMuc3FsaXRlID0gWydCSUdJTlQnXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLnNxbGl0ZSA9IFsnRkxPQVQnXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMuc3FsaXRlID0gWydUSU1FJ107XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5zcWxpdGUgPSBbJ0RBVEUnXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMuc3FsaXRlID0gWydUSU5ZSU5UJ107XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLnNxbGl0ZSA9IFsnVElOWUJMT0InLCAnQkxPQicsICdMT05HQkxPQiddO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5zcWxpdGUgPSBbJ0RFQ0lNQUwnXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMuc3FsaXRlID0gWydVVUlEJ107XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLnNxbGl0ZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5zcWxpdGUgPSBbJ1JFQUwnXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5zcWxpdGUgPSBbJ0RPVUJMRSBQUkVDSVNJT04nXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLnNxbGl0ZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5zcWxpdGUgPSBbJ0pTT04nLCAnSlNPTkInXTtcblxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFkYXRlLmluY2x1ZGVzKCcrJykpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQuIERhdGVzIGluc2VydGVkIGJ5IHNlcXVlbGl6ZSA8IDIuMGRldjEyIHdpbGwgbm90IGhhdmUgYSB0aW1lc3RhbXAgc2V0XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlICsgb3B0aW9ucy50aW1lem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7IC8vIFdlIGFscmVhZHkgaGF2ZSBhIHRpbWV6b25lIHN0b3JlZCBpbiB0aGUgc3RyaW5nXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZShkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBWQVJDSEFSIEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKCdTUUxpdGUgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggb3B0aW9ucy4gUGxhaW4gYFRFWFRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1RFWFQnO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIENJVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5DSVRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuICdURVhUIENPTExBVEUgTk9DQVNFJztcbiAgICB9XG4gIH1cblxuICBjbGFzcyBDSEFSIGV4dGVuZHMgQmFzZVR5cGVzLkNIQVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYENIQVIgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTlVNQkVSIGV4dGVuZHMgQmFzZVR5cGVzLk5VTUJFUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgVU5TSUdORUQnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHJlc3VsdCArPSAnIFpFUk9GSUxMJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9sZW5ndGh9YDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWNpbWFscyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuX2RlY2ltYWxzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIE1FRElVTUlOVCBleHRlbmRzIEJhc2VUeXBlcy5NRURJVU1JTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICB9XG5cbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gIH1cblxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwgeyB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ05hTicpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICctSW5maW5pdHknKSB7XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGZsb2F0aW5nIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMXSkge1xuICAgIGZsb2F0aW5nLnBhcnNlID0gcGFyc2VGbG9hdGluZztcbiAgfVxuXG5cbiAgZm9yIChjb25zdCBudW0gb2YgW0ZMT0FULCBET1VCTEUsIFJFQUwsIFRJTllJTlQsIFNNQUxMSU5ULCBNRURJVU1JTlQsIElOVEVHRVIsIEJJR0lOVF0pIHtcbiAgICBudW0ucHJvdG90eXBlLnRvU3FsID0gTlVNQkVSLnByb3RvdHlwZS50b1NxbDtcbiAgfVxuXG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gJ1RFWFQnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBTVFJJTkcsXG4gICAgQ0hBUixcbiAgICBOVU1CRVIsXG4gICAgRkxPQVQsXG4gICAgUkVBTCxcbiAgICAnRE9VQkxFIFBSRUNJU0lPTic6IERPVUJMRSxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIE1FRElVTUlOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBURVhULFxuICAgIEVOVU0sXG4gICAgSlNPTjogSlNPTlRZUEUsXG4gICAgQ0lURVhUXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKCcuLi9hYnN0cmFjdCcpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tbWFuYWdlcicpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoJy4vcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9kYXRhLXR5cGVzJykuc3FsaXRlO1xuY29uc3QgeyBTUUxpdGVRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZSgnLi9xdWVyeS1pbnRlcmZhY2UnKTtcblxuY2xhc3MgU3FsaXRlRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcblxuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgU1FMaXRlUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuXG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgJ0RFRkFVTFQnOiBmYWxzZSxcbiAgJ0RFRkFVTFQgVkFMVUVTJzogdHJ1ZSxcbiAgJ1VOSU9OIEFMTCc6IGZhbHNlLFxuICAnUklHSFQgSk9JTic6IGZhbHNlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogJyBPUiBJR05PUkUnLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiAnIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVQnXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgdXNpbmc6IGZhbHNlLFxuICAgIHdoZXJlOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IHRydWVcbiAgfSxcbiAgdHJhbnNhY3Rpb25PcHRpb25zOiB7XG4gICAgdHlwZTogdHJ1ZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGFkZENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZVxuICB9LFxuICBqb2luVGFibGVEZXBlbmRlbnQ6IGZhbHNlLFxuICBncm91cGVkTGltaXQ6IGZhbHNlLFxuICBKU09OOiB0cnVlXG59KTtcblxuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSAnMy44LjAnO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLm5hbWUgPSAnc3FsaXRlJztcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdgJztcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNxbGl0ZURpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5TcWxpdGVEaWFsZWN0ID0gU3FsaXRlRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBTcWxpdGVEaWFsZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zYWN0aW9uJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBNeVNxbFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vbXlzcWwvcXVlcnktZ2VuZXJhdG9yJyk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yJyk7XG5cbmNsYXNzIFNRTGl0ZVF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgTXlTcWxRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPSd0YWJsZScgYW5kIG5hbWUhPSdzcWxpdGVfc2VxdWVuY2UnO1wiO1xuICB9XG5cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPSd0YWJsZScgYW5kIG5hbWUhPSdzcWxpdGVfc2VxdWVuY2UnO1wiO1xuICB9XG5cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiAnU0VMRUNUIHNxbGl0ZV92ZXJzaW9uKCkgYXMgYHZlcnNpb25gJztcbiAgfVxuXG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdO1xuICAgIGNvbnN0IG5lZWRzTXVsdGlwbGVQcmltYXJ5S2V5cyA9IE9iamVjdC52YWx1ZXMoYXR0cmlidXRlcykuZmlsdGVyKGRlZmluaXRpb24gPT4gZGVmaW5pdGlvbi5pbmNsdWRlcygnUFJJTUFSWSBLRVknKSkubGVuZ3RoID4gMTtcbiAgICBjb25zdCBhdHRyQXJyYXkgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBdXRvSW5jcmVtZW50ID0gZGF0YVR5cGUuaW5jbHVkZXMoJ0FVVE9JTkNSRU1FTlQnKTtcblxuICAgICAgICBsZXQgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdQUklNQVJZIEtFWScpKSB7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKCdJTlQnKSkge1xuICAgICAgICAgICAgLy8gT25seSBJTlRFR0VSIGlzIGFsbG93ZWQgZm9yIHByaW1hcnkga2V5LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvaXNzdWVzLzk2OSAobm8gbGVuZ2h0LCB1bnNpZ25lZCBldGMpXG4gICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGNvbnRhaW5zQXV0b0luY3JlbWVudCA/ICdJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlQnIDogJ0lOVEVHRVIgUFJJTUFSWSBLRVknO1xuXG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJyBSRUZFUkVOQ0VTJykpIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgKz0gZGF0YVR5cGUuc3Vic3RyKGRhdGFUeXBlLmluZGV4T2YoJyBSRUZFUkVOQ0VTJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWVkc011bHRpcGxlUHJpbWFyeUtleXMpIHtcbiAgICAgICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoJ05PVCBOVUxMJykpIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZS5yZXBsYWNlKCcgUFJJTUFSWSBLRVknLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlLnJlcGxhY2UoJ1BSSU1BUlkgS0VZJywgJ05PVCBOVUxMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJBcnJheS5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlU3RyaW5nfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IGF0dHJTdHIgPSBhdHRyQXJyYXkuam9pbignLCAnKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcChwayA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oJywgJyk7XG5cbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCBjb2x1bW5zID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBhdHRyU3RyICs9IGAsIFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoZmllbGQgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0clN0ciArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG5cbiAgICBjb25zdCBzcWwgPSBgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHt0YWJsZX0gKCR7YXR0clN0cn0pO2A7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpO1xuICB9XG5cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgc3RhdG1lbWVudCBpcyBqc29uIGZ1bmN0aW9uIG9yIHNpbXBsZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICBzdG10ICBUaGUgc3RhdGVtZW50IHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgICB0cnVlIGlmIHRoZSBnaXZlbiBzdGF0ZW1lbnQgaXMganNvbiBmdW5jdGlvblxuICAgKiBAdGhyb3dzICB7RXJyb3J9ICAgICAgICAgdGhyb3cgaWYgdGhlIHN0YXRlbWVudCBsb29rcyBsaWtlIGpzb24gZnVuY3Rpb24gYnV0IGhhcyBpbnZhbGlkIHRva2VuXG4gICAqL1xuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3NxbGl0ZS5vcmcvanNvbjEuaHRtbFxuICAgIGNvbnN0IGpzb25GdW5jdGlvblJlZ2V4ID0gL15cXHMqKGpzb24oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG4gICAgY29uc3QgdG9rZW5DYXB0dXJlUmVnZXggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcblxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBqc29uRnVuY3Rpb25SZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZignKCcpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gdG9rZW5DYXB0dXJlUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJygnKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJyknKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gJzsnKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGludmFsaWQganNvbiBzdGF0ZW1lbnRcbiAgICBoYXNJbnZhbGlkVG9rZW4gfD0gb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHM7XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiBoYXNJbnZhbGlkVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0cnVlIGlmIHRoZSBzdGF0ZW1lbnQgaGFzIHZhbGlkIGpzb24gZnVuY3Rpb25cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG5cbiAgLy9zcWxpdGUgY2FuJ3QgY2FzdCB0byBkYXRldGltZSBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgZGF0ZSB2YWx1ZXMgdG8gdGhlaXIgSVNPIHN0cmluZ3NcbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZVswXSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsID0+IHZhbC50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cblxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoL3RpbWVzdGFtcC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSAnZGF0ZXRpbWUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yLnByb3RvdHlwZS5oYW5kbGVTZXF1ZWxpemVNZXRob2QuY2FsbCh0aGlzLCBzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG5cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgYXR0cmlidXRlc1trZXldID0gZGF0YVR5cGU7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgeyBjb250ZXh0OiAnYWRkQ29sdW1uJyB9KTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfSAke2ZpZWxkc1trZXldfWA7XG5cbiAgICBjb25zdCBzcWwgPSBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGUpfSBBREQgJHthdHRyaWJ1dGV9O2A7XG5cbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCk7XG4gIH1cblxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuICdTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPVxcJ3RhYmxlXFwnIGFuZCBuYW1lIT1cXCdzcWxpdGVfc2VxdWVuY2VcXCc7JztcbiAgfVxuXG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBhdHRyVmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMub21pdE51bGwsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gfHwgdGhpcy5iaW5kUGFyYW0oYmluZCk7XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0clZhbHVlSGFzaCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWVIYXNoW2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB1bmRlZmluZWQsIHsgY29udGV4dDogJ1VQREFURScgfSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHVuZGVmaW5lZCwgeyBjb250ZXh0OiAnVVBEQVRFJyB9LCBiaW5kUGFyYW0pfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBxdWVyeTtcbiAgICBjb25zdCB3aGVyZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGJpbmRQYXJhbSB9O1xuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gYFVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbignLCcpfSBXSEVSRSByb3dpZCBJTiAoU0VMRUNUIHJvd2lkIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9IExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gYFVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbignLCcpfSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX1gO1xuICAgIH1cblxuICAgIHJldHVybiB7IHF1ZXJ5LCBiaW5kIH07XG4gIH1cblxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMucmVzdGFydElkZW50aXR5ID8gYDsgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUoJ3NxbGl0ZV9zZXF1ZW5jZScpfSBXSEVSRSAke3RoaXMucXVvdGVJZGVudGlmaWVyKCduYW1lJyl9ID0gJHtVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyh0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSwgJ2AnKSwgXCInXCIpfTtgIDogJydcbiAgICBdLmpvaW4oJycpO1xuICB9XG5cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcblxuICAgIGxldCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG5cbiAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYFdIRVJFICR7d2hlcmVDbGF1c2V9YDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7d2hlcmVDbGF1c2V9IExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3doZXJlQ2xhdXNlfWA7XG4gIH1cblxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBkYXRhVHlwZS5maWVsZCB8fCBuYW1lO1xuXG4gICAgICBpZiAoXy5pc09iamVjdChkYXRhVHlwZSkpIHtcbiAgICAgICAgbGV0IHNxbCA9IGRhdGFUeXBlLnR5cGUudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCAnYWxsb3dOdWxsJykgJiYgIWRhdGFUeXBlLmFsbG93TnVsbCkge1xuICAgICAgICAgIHNxbCArPSAnIE5PVCBOVUxMJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoZGF0YVR5cGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIC8vIFRPRE8gdGhvcm91Z2hseSBjaGVjayB0aGF0IERhdGFUeXBlcy5OT1cgd2lsbCBwcm9wZXJseVxuICAgICAgICAgIC8vIGdldCBwb3B1bGF0ZWQgb24gYWxsIGRhdGFiYXNlcyBhcyBERUZBVUxUIHZhbHVlXG4gICAgICAgICAgLy8gaS5lLiBteXNxbCByZXF1aXJlczogREVGQVVMVCBDVVJSRU5UX1RJTUVTVEFNUFxuICAgICAgICAgIHNxbCArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShkYXRhVHlwZS5kZWZhdWx0VmFsdWUsIGRhdGFUeXBlKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFUeXBlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNxbCArPSAnIFVOSVFVRSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVR5cGUucHJpbWFyeUtleSkge1xuICAgICAgICAgIHNxbCArPSAnIFBSSU1BUlkgS0VZJztcblxuICAgICAgICAgIGlmIChkYXRhVHlwZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgICBzcWwgKz0gJyBBVVRPSU5DUkVNRU5UJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVR5cGUucmVmZXJlbmNlcykge1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZShkYXRhVHlwZS5yZWZlcmVuY2VzLm1vZGVsKTtcblxuICAgICAgICAgIGxldCByZWZlcmVuY2VzS2V5O1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFUeXBlLnJlZmVyZW5jZXMua2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKCdpZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNxbCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzVGFibGV9ICgke3JlZmVyZW5jZXNLZXl9KWA7XG5cbiAgICAgICAgICBpZiAoZGF0YVR5cGUub25EZWxldGUpIHtcbiAgICAgICAgICAgIHNxbCArPSBgIE9OIERFTEVURSAke2RhdGFUeXBlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF0YVR5cGUub25VcGRhdGUpIHtcbiAgICAgICAgICAgIHNxbCArPSBgIE9OIFVQREFURSAke2RhdGFUeXBlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gc3FsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBkYXRhVHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFBSQUdNQSBJTkRFWF9MSVNUKCR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9KWA7XG4gIH1cblxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgbGV0IHNxbCA9IGBTRUxFQ1Qgc3FsIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0nJHt0YWJsZU5hbWV9J2A7XG5cbiAgICBpZiAoY29uc3RyYWludE5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBzcWwgTElLRSAnJSR7Y29uc3RyYWludE5hbWV9JSdgO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtzcWx9O2A7XG4gIH1cblxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcblxuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oJ18nKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYERST1AgSU5ERVggSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX1gO1xuICB9XG5cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHtcbiAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlcixcbiAgICAgIHRhYmxlTmFtZVxuICAgIH07XG4gICAgcmV0dXJuIGBQUkFHTUEgVEFCTEVfSU5GTygke3RoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh0YWJsZSkpfSk7YDtcbiAgfVxuXG4gIGRlc2NyaWJlQ3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lPScke3RhYmxlTmFtZX0nO2A7XG4gIH1cblxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcblxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcblxuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuXG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoYXR0ciA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbignLCAnKTtcblxuICAgIC8vIFRlbXBvcmFyeSB0YWJsZSBjYW5ub3Qgd29yayBmb3IgZm9yZWlnbiBrZXlzLlxuICAgIHJldHVybiBgJHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkoYmFja3VwVGFibGVOYW1lLCBhdHRyaWJ1dGVzKVxuICAgIH1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O2BcbiAgICAgICsgYERST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9OyR7XG4gICAgICAgIHRoaXMuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICB9SU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgXG4gICAgICArIGBEUk9QIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgO1xuICB9XG5cbiAgX2FsdGVyQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgY3JlYXRlVGFibGVTcWwpIHtcbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuXG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oJywgJyk7XG5cbiAgICByZXR1cm4gYCR7Y3JlYXRlVGFibGVTcWxcbiAgICAgIC5yZXBsYWNlKGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9YCwgYENSRUFURSBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX1gKVxuICAgICAgLnJlcGxhY2UoYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZS5yZXBsYWNlKC9gL2csICdcIicpfWAsIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9YClcbiAgICB9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtgXG4gICAgICArIGBEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTtgXG4gICAgICArIGBBTFRFUiBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gUkVOQU1FIFRPICR7cXVvdGVkVGFibGVOYW1lfTtgO1xuICB9XG5cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgYXR0cmlidXRlcykge1xuXG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcblxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcblxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cblxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzSW1wb3J0ID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKGF0dHIgPT5cbiAgICAgIGF0dHJOYW1lQWZ0ZXIgPT09IGF0dHIgPyBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyTmFtZUJlZm9yZSl9IEFTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpXG4gICAgKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzRXhwb3J0ID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKGF0dHIgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oJywgJyk7XG5cbiAgICAvLyBUZW1wb3JhcnkgdGFibGVzIGRvbid0IHN1cHBvcnQgZm9yZWlnbiBrZXlzLCBzbyBjcmVhdGluZyBhIHRlbXBvcmFyeSB0YWJsZSB3aWxsIG5vdCBhbGxvdyBmb3JlaWduIGtleXMgdG8gYmUgcHJlc2VydmVkXG4gICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlVGFibGVRdWVyeShiYWNrdXBUYWJsZU5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc0ltcG9ydH0gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07YFxuICAgICAgKyBgRFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07JHtcbiAgICAgICAgdGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH1JTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXNFeHBvcnR9IEZST00gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2BcbiAgICAgICsgYERST1AgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2A7XG4gIH1cblxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cblxuICAgIHJldHVybiBgQkVHSU4gJHt0cmFuc2FjdGlvbi5vcHRpb25zLnR5cGV9IFRSQU5TQUNUSU9OO2A7XG4gIH1cblxuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFUEVBVEFCTEVfUkVBRDpcbiAgICAgICAgcmV0dXJuICctLSBTUUxpdGUgaXMgbm90IGFibGUgdG8gY2hvb3NlIHRoZSBpc29sYXRpb24gbGV2ZWwgUkVQRUFUQUJMRSBSRUFELic7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9VTkNPTU1JVFRFRDpcbiAgICAgICAgcmV0dXJuICdQUkFHTUEgcmVhZF91bmNvbW1pdHRlZCA9IE9OOyc7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiAnUFJBR01BIHJlYWRfdW5jb21taXR0ZWQgPSBPRkY7JztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5TRVJJQUxJWkFCTEU6XG4gICAgICAgIHJldHVybiAnLS0gU1FMaXRlXFwncyBkZWZhdWx0IGlzb2xhdGlvbiBsZXZlbCBpcyBTRVJJQUxJWkFCTEUuIE5vdGhpbmcgdG8gZG8uJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBpc29sYXRpb24gbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG5cbiAgcmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpIHtcbiAgICByZXR1cm4gc3FsLnJlcGxhY2UoL0RFRkFVTFQgJz9mYWxzZSc/L2csICdERUZBVUxUIDAnKS5yZXBsYWNlKC9ERUZBVUxUICc/dHJ1ZSc/L2csICdERUZBVUxUIDEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gU1FMIHF1ZXJ5IHRoYXQgcmV0dXJucyBhbGwgZm9yZWlnbiBrZXlzIG9mIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFibGVOYW1lICBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgICAgVGhlIGdlbmVyYXRlZCBzcWwgcXVlcnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgUFJBR01BIGZvcmVpZ25fa2V5X2xpc3QoJHt0YWJsZU5hbWV9KWA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTUUxpdGVRdWVyeUdlbmVyYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZScpO1xuY29uc3QgeyBjbG9uZURlZXAgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSB0aGF0IFNlcXVlbGl6ZSB1c2VzIHRvIHRhbGsgd2l0aCBTUUxpdGUgZGF0YWJhc2VcbiAqL1xuY2xhc3MgU1FMaXRlUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgdGhhdCBmaXhlcyBTUUxpdGUncyBpbmFiaWxpdHkgdG8gcmVtb3ZlIGNvbHVtbnMgZnJvbSBleGlzdGluZyB0YWJsZXMuXG4gICAqIEl0IHdpbGwgY3JlYXRlIGEgYmFja3VwIG9mIHRoZSB0YWJsZSwgZHJvcCB0aGUgdGFibGUgYWZ0ZXJ3YXJkcyBhbmQgY3JlYXRlIGFcbiAgICogbmV3IHRhYmxlIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgd2l0aG91dCB0aGUgb2Jzb2xldGUgY29sdW1uLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBmaWVsZHNbYXR0cmlidXRlTmFtZV07XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIGNoYW5nZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICAgKiBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gICAqIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGggYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSByZXNwZWN0aXZlIGNvbHVtbi5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBjaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBkYXRhVHlwZU9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgT2JqZWN0LmFzc2lnbihmaWVsZHNbYXR0cmlidXRlTmFtZV0sIHRoaXMubm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKSk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KCc7JykuZmlsdGVyKHEgPT4gcSAhPT0gJycpO1xuXG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgeyByYXc6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSB3cmFwcGVyIHRoYXQgZml4ZXMgU1FMaXRlJ3MgaW5hYmlsaXR5IHRvIHJlbmFtZSBjb2x1bW5zIGZyb20gZXhpc3RpbmcgdGFibGVzLlxuICAgKiBJdCB3aWxsIGNyZWF0ZSBhIGJhY2t1cCBvZiB0aGUgdGFibGUsIGRyb3AgdGhlIHRhYmxlIGFmdGVyd2FyZHMgYW5kIGNyZWF0ZSBhXG4gICAqIG5ldyB0YWJsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IHdpdGggYSByZW5hbWVkIHZlcnNpb24gb2YgdGhlIHJlc3BlY3RpdmUgY29sdW1uLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHJlbmFtZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5hc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBvcHRpb25zKTtcblxuICAgIGZpZWxkc1thdHRyTmFtZUFmdGVyXSA9IHsgLi4uZmllbGRzW2F0dHJOYW1lQmVmb3JlXSB9O1xuICAgIGRlbGV0ZSBmaWVsZHNbYXR0ck5hbWVCZWZvcmVdO1xuXG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjcmVhdGVUYWJsZVNxbDtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zaG93Q29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICAvLyBzcWxpdGUgY2FuJ3Qgc2hvdyBvbmx5IG9uZSBjb25zdHJhaW50LCBzbyB3ZSBmaW5kIGhlcmUgdGhlIG9uZSB0byByZW1vdmVcbiAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludHMuZmluZChjb25zdGFpbnQgPT4gY29uc3RhaW50LmNvbnN0cmFpbnROYW1lID09PSBjb25zdHJhaW50TmFtZSk7XG5cbiAgICBpZiAoIWNvbnN0cmFpbnQpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9IG9uIHRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnROYW1lLFxuICAgICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVGFibGVTcWwgPSBjb25zdHJhaW50LnNxbDtcbiAgICBjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoY29uc3RyYWludC5jb25zdHJhaW50TmFtZSk7XG4gICAgbGV0IGNvbnN0cmFpbnRTbmlwcGV0ID0gYCwgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnQuY29uc3RyYWludE5hbWV9ICR7Y29uc3RyYWludC5jb25zdHJhaW50VHlwZX0gJHtjb25zdHJhaW50LmNvbnN0cmFpbnRDb25kaXRpb259YDtcblxuICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSAnRk9SRUlHTiBLRVknKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VUYWJsZU5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlVGFibGUoY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZU5hbWUpO1xuICAgICAgY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMgPSBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cy5tYXAoY29sdW1uTmFtZSA9PiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcihjb2x1bW5OYW1lKSk7XG4gICAgICBjb25zdCByZWZlcmVuY2VUYWJsZUtleXMgPSBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cy5qb2luKCcsICcpO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlVGFibGVOYW1lfSAoJHtyZWZlcmVuY2VUYWJsZUtleXN9KWA7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIFVQREFURSAke2NvbnN0cmFpbnQudXBkYXRlQWN0aW9ufWA7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIERFTEVURSAke2NvbnN0cmFpbnQuZGVsZXRlQWN0aW9ufWA7XG4gICAgfVxuXG4gICAgY3JlYXRlVGFibGVTcWwgPSBjcmVhdGVUYWJsZVNxbC5yZXBsYWNlKGNvbnN0cmFpbnRTbmlwcGV0LCAnJyk7XG4gICAgY3JlYXRlVGFibGVTcWwgKz0gJzsnO1xuXG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkcywgY3JlYXRlVGFibGVTcWwpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGFkZENvbnN0cmFpbnQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZHMgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLmZpZWxkcycpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cmFpbnQgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMudHlwZScpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBjbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBkZXNjcmliZUNyZWF0ZVRhYmxlU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lKTtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZGVzY3JpYmVDcmVhdGVUYWJsZVNxbCwgeyAuLi5vcHRpb25zLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCwgcmF3OiB0cnVlIH0pO1xuICAgIGxldCBzcWwgPSBjb25zdHJhaW50c1swXS5zcWw7XG4gICAgY29uc3QgaW5kZXggPSBzcWwubGVuZ3RoIC0gMTtcbiAgICAvL1JlcGxhY2UgZW5kaW5nICcpJyB3aXRoIGNvbnN0cmFpbnQgc25pcHBldCAtIFNpbXVsYXRlcyBTdHJpbmcucmVwbGFjZUF0XG4gICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MzEwOTRcbiAgICBjb25zdCBjcmVhdGVUYWJsZVNxbCA9IGAke3NxbC5zdWJzdHIoMCwgaW5kZXgpfSwgJHtjb25zdHJhaW50U25pcHBldH0pJHtzcWwuc3Vic3RyKGluZGV4ICsgMSl9O2A7XG5cbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkcywgY3JlYXRlVGFibGVTcWwpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoJzsnKS5maWx0ZXIocSA9PiBxICE9PSAnJyk7XG5cbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCB7IHJhdzogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YWJhc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2U7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCBkYXRhYmFzZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQubWFwKHJvdyA9PiAoe1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgY29sdW1uTmFtZTogcm93LmZyb20sXG4gICAgICByZWZlcmVuY2VkVGFibGVOYW1lOiByb3cudGFibGUsXG4gICAgICByZWZlcmVuY2VkQ29sdW1uTmFtZTogcm93LnRvLFxuICAgICAgdGFibGVDYXRhbG9nOiBkYXRhYmFzZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2c6IGRhdGFiYXNlXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZHJvcEFsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcblxuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNob3dBbGxUYWJsZXMob3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoJ1BSQUdNQSBmb3JlaWduX2tleXMgPSBPRkYnLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLl9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KCdQUkFHTUEgZm9yZWlnbl9rZXlzID0gT04nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IG51bGw7XG4gICAgbGV0IHNjaGVtYURlbGltaXRlciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hIHx8IG51bGw7XG4gICAgICBzY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlciB8fCBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSAnb2JqZWN0JyAmJiB0YWJsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWE7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cblxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpO1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHR5cGU6IFF1ZXJ5VHlwZXMuREVTQ1JJQkUgfTtcbiAgICBjb25zdCBzcWxJbmRleGVzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgICAvKlxuICAgICAgICogSWYgbm8gZGF0YSBpcyByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeSwgdGhlbiB0aGUgdGFibGUgbmFtZSBtYXkgYmUgd3JvbmcuXG4gICAgICAgKiBRdWVyeSBnZW5lcmF0b3JzIHRoYXQgdXNlIGluZm9ybWF0aW9uX3NjaGVtYSBmb3IgcmV0cmlldmluZyB0YWJsZSBpbmZvIHdpbGwganVzdCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0IHNldCxcbiAgICAgICAqIGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIGxpa2UgYnVpbHQtaW5zIGRvIChlLmcuIERFU0NSSUJFIG9uIE15U3FsKS5cbiAgICAgICAqL1xuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXhlcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbEluZGV4ZXMsIG9wdGlvbnMpO1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtwcm9wXS51bmlxdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgIGlmIChpbmRleC51bmlxdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YVtmaWVsZC5hdHRyaWJ1dGVdLnVuaXF1ZSA9IGluZGV4LnVuaXF1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yZWlnbktleXMgPSBhd2FpdCB0aGlzLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleSBvZiBmb3JlaWduS2V5cykge1xuICAgICAgICBkYXRhW2ZvcmVpZ25LZXkuY29sdW1uTmFtZV0ucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgICBtb2RlbDogZm9yZWlnbktleS5yZWZlcmVuY2VkVGFibGVOYW1lLFxuICAgICAgICAgIGtleTogZm9yZWlnbktleS5yZWZlcmVuY2VkQ29sdW1uTmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbCAmJiBlLm9yaWdpbmFsLmNvZGUgPT09ICdFUl9OT19TVUNIX1RBQkxFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5TUUxpdGVRdWVyeUludGVyZmFjZSA9IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZSgnLi4vYWJzdHJhY3QvcXVlcnknKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeS10eXBlcycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3BhcnNlclN0b3JlJykoJ3NxbGl0ZScpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xvZ2dlcicpO1xuXG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoJ3NxbDpzcWxpdGUnKTtcblxuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiAnbGFzdElEJztcbiAgfVxuXG4gIC8qKlxuICAgKiByZXdyaXRlIHF1ZXJ5IHdpdGggcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gdmFsdWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFsZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBsZXQgYmluZFBhcmFtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGJpbmRQYXJhbSA9IHt9O1xuICAgICAgdmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgYmluZFBhcmFtW2AkJHtpICsgMX1gXSA9IHY7XG4gICAgICB9KTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmluZFBhcmFtID0ge307XG4gICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHZhbHVlcykpIHtcbiAgICAgICAgICBiaW5kUGFyYW1bYCQke2t9YF0gPSB2YWx1ZXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cblxuICBfY29sbGVjdE1vZGVscyhpbmNsdWRlLCBwcmVmaXgpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcblxuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IF9pbmNsdWRlIG9mIGluY2x1ZGUpIHtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgICBrZXkgPSBfaW5jbHVkZS5hcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBgJHtwcmVmaXh9LiR7X2luY2x1ZGUuYXN9YDtcbiAgICAgICAgfVxuICAgICAgICByZXRba2V5XSA9IF9pbmNsdWRlLm1vZGVsO1xuXG4gICAgICAgIGlmIChfaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgICAgXy5tZXJnZShyZXQsIHRoaXMuX2NvbGxlY3RNb2RlbHMoX2luY2x1ZGUuaW5jbHVkZSwga2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgX2hhbmRsZVF1ZXJ5UmVzcG9uc2UobWV0YURhdGEsIGNvbHVtblR5cGVzLCBlcnIsIHJlc3VsdHMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnIuc3FsID0gdGhpcy5zcWw7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuXG4gICAgLy8gYWRkIHRoZSBpbnNlcnRlZCByb3cgaWQgdG8gdGhlIGluc3RhbmNlXG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBidWxrQ3JlYXRlIEFJIHByaW1hcnkga2V5XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtZXRhRGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnU3RhdGVtZW50J1xuICAgICAgICAgICYmIHRoaXMubW9kZWxcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVcbiAgICAgICAgICAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgICAgICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV0gLSBtZXRhRGF0YS5jaGFuZ2VzICsgMTtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBtZXRhRGF0YS5jaGFuZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgW3RoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkXTogaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHMubWFwKHJvdyA9PiByb3cubmFtZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0cztcbiAgICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5zcWwpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNvbnN0cmFpbnRzRnJvbVNxbChyZXN1bHRzWzBdLnNxbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmF3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBhIG1hcCBvZiBwcmVmaXggc3RyaW5ncyB0byBtb2RlbHMsIGUuZy4gdXNlci5wcm9qZWN0cyAtPiBQcm9qZWN0IG1vZGVsXG4gICAgICBjb25zdCBwcmVmaXhlcyA9IHRoaXMuX2NvbGxlY3RNb2RlbHModGhpcy5vcHRpb25zLmluY2x1ZGUpO1xuXG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAocmVzdWx0ID0+IHtcbiAgICAgICAgcmV0dXJuIF8ubWFwVmFsdWVzKHJlc3VsdCwgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgbGV0IG1vZGVsO1xuICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RpbmQgPSBuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgICAgIG1vZGVsID0gcHJlZml4ZXNbbmFtZS5zdWJzdHIoMCwgbGFzdGluZCldO1xuXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIobGFzdGluZCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbCA9IHRoaXMub3B0aW9ucy5tb2RlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtb2RlbC5nZXRUYWJsZU5hbWUoKS50b1N0cmluZygpLnJlcGxhY2UoL2AvZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRhYmxlVHlwZXMgPSBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdIHx8IHt9O1xuXG4gICAgICAgICAgaWYgKHRhYmxlVHlwZXMgJiYgIShuYW1lIGluIHRhYmxlVHlwZXMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29sdW1uIGlzIGFsaWFzZWRcbiAgICAgICAgICAgIF8uZm9yT3duKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0ga2V5ICYmIGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGUuZmllbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhYmxlVHlwZXMsIG5hbWUpXG4gICAgICAgICAgICA/IHRoaXMuYXBwbHlQYXJzZXJzKHRhYmxlVHlwZXNbbmFtZV0sIHZhbHVlKVxuICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd09yRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgSU5ERVhfTElTVCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KHJlc3VsdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBJTkRFWF9JTkZPJykpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoJ1BSQUdNQSBUQUJMRV9JTkZPJykpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHNxbGl0ZSB3YXkgb2YgZ2V0dGluZyB0aGUgbWV0YWRhdGEgb2YgYSB0YWJsZVxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGxldCBkZWZhdWx0VmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAoX3Jlc3VsdC5kZmx0X3ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29sdW1uIHNjaGVtYSBvbWl0cyBhbnkgXCJERUZBVUxUIC4uLlwiXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKF9yZXN1bHQuZGZsdF92YWx1ZSA9PT0gJ05VTEwnKSB7XG4gICAgICAgICAgLy8gQ29sdW1uIHNjaGVtYSBpcyBhIFwiREVGQVVMVCBOVUxMXCJcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZXN1bHQuZGZsdF92YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQudHlwZSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQubm90bnVsbCA9PT0gMCxcbiAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5wayAhPT0gMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHRbX3Jlc3VsdC5uYW1lXS50eXBlID09PSAnVElOWUlOVCgxKScpIHtcbiAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPSB7ICcwJzogZmFsc2UsICcxJzogdHJ1ZSB9W3Jlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPSByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUucmVwbGFjZSgvJy9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIGZvcmVpZ25fa2V5czsnKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcygnUFJBR01BIGZvcmVpZ25fa2V5cycpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKCdQUkFHTUEgZm9yZWlnbl9rZXlfbGlzdCcpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKFtRdWVyeVR5cGVzLkJVTEtVUERBVEUsIFF1ZXJ5VHlwZXMuQlVMS0RFTEVURV0uaW5jbHVkZXModGhpcy5vcHRpb25zLnR5cGUpKSB7XG4gICAgICByZXR1cm4gbWV0YURhdGEuY2hhbmdlcztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlZFUlNJT04pIHtcbiAgICAgIHJldHVybiByZXN1bHRzWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5SQVcpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0cywgbWV0YURhdGFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBudWxsXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNJbnNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgbWV0YURhdGEuY2hhbmdlc107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLmdldERhdGFiYXNlTWV0aG9kKCk7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uLnNlcmlhbGl6ZShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5UeXBlcyA9IHt9O1xuICAgICAgY29uc3QgZXhlY3V0ZVNxbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKCctLSAnKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzO1xuICAgICAgICAvLyBjYW5ub3QgdXNlIGFycm93IGZ1bmN0aW9uIGhlcmUgYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgYm91bmQgdG8gdGhlIHN0YXRlbWVudFxuICAgICAgICBmdW5jdGlvbiBhZnRlckV4ZWN1dGUoZXhlY3V0aW9uRXJyb3IsIHJlc3VsdHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIC8vIGB0aGlzYCBpcyBwYXNzZWQgZnJvbSBzcWxpdGUsIHdlIGhhdmUgbm8gY29udHJvbCBvdmVyIHRoaXMuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgICAgICAgICByZXNvbHZlKHF1ZXJ5Ll9oYW5kbGVRdWVyeVJlc3BvbnNlKHRoaXMsIGNvbHVtblR5cGVzLCBleGVjdXRpb25FcnJvciwgcmVzdWx0cykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1ldGVycykgcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBjb25uW21ldGhvZF0oc3FsLCBwYXJhbWV0ZXJzLCBhZnRlckV4ZWN1dGUpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZ2V0RGF0YWJhc2VNZXRob2QoKSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgbGV0IHRhYmxlTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudGFibGVOYW1lcykge1xuICAgICAgICAgIHRhYmxlTmFtZXMgPSB0aGlzLm9wdGlvbnMudGFibGVOYW1lcztcbiAgICAgICAgfSBlbHNlIGlmICgvRlJPTSBgKC4qPylgL2kuZXhlYyh0aGlzLnNxbCkpIHtcbiAgICAgICAgICB0YWJsZU5hbWVzLnB1c2goL0ZST00gYCguKj8pYC9pLmV4ZWModGhpcy5zcWwpWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgbWV0YWRhdGEgZm9yIHRoZSB0YWJsZSwgdGhlcmUncyBubyBuZWVkIHRvIGFzayBmb3IgaXQgYWdhaW5cbiAgICAgICAgdGFibGVOYW1lcyA9IHRhYmxlTmFtZXMuZmlsdGVyKHRhYmxlTmFtZSA9PiAhKHRhYmxlTmFtZSBpbiBjb2x1bW5UeXBlcykgJiYgdGFibGVOYW1lICE9PSAnc3FsaXRlX21hc3RlcicpO1xuXG4gICAgICAgIGlmICghdGFibGVOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVNxbCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhYmxlTmFtZXMubWFwKHRhYmxlTmFtZSA9PlxuICAgICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnJlcGxhY2UoL2AvZywgJycpO1xuICAgICAgICAgICAgY29sdW1uVHlwZXNbdGFibGVOYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICBjb25uLmFsbChgUFJBR01BIHRhYmxlX2luZm8oXFxgJHt0YWJsZU5hbWV9XFxgKWAsIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdW3Jlc3VsdC5uYW1lXSA9IHJlc3VsdC50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVTcWwoKTtcbiAgICB9KSk7XG4gIH1cblxuICBwYXJzZUNvbnN0cmFpbnRzRnJvbVNxbChzcWwpIHtcbiAgICBsZXQgY29uc3RyYWludHMgPSBzcWwuc3BsaXQoJ0NPTlNUUkFJTlQgJyk7XG4gICAgbGV0IHJlZmVyZW5jZVRhYmxlTmFtZSwgcmVmZXJlbmNlVGFibGVLZXlzLCB1cGRhdGVBY3Rpb24sIGRlbGV0ZUFjdGlvbjtcbiAgICBjb25zdHJhaW50cy5zcGxpY2UoMCwgMSk7XG4gICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5tYXAoY29uc3RyYWludFNxbCA9PiB7XG4gICAgICAvL1BhcnNlIGZvcmVpZ24ga2V5IHNuaXBwZXRzXG4gICAgICBpZiAoY29uc3RyYWludFNxbC5pbmNsdWRlcygnUkVGRVJFTkNFUycpKSB7XG4gICAgICAgIC8vUGFyc2Ugb3V0IHRoZSBjb25zdHJhaW50IGNvbmRpdGlvbiBmb3JtIHNxbCBzdHJpbmdcbiAgICAgICAgdXBkYXRlQWN0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvT04gVVBEQVRFIChDQVNDQURFfFNFVCBOVUxMfFJFU1RSSUNUfE5PIEFDVElPTnxTRVQgREVGQVVMVCl7MX0vKTtcbiAgICAgICAgZGVsZXRlQWN0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvT04gREVMRVRFIChDQVNDQURFfFNFVCBOVUxMfFJFU1RSSUNUfE5PIEFDVElPTnxTRVQgREVGQVVMVCl7MX0vKTtcblxuICAgICAgICBpZiAodXBkYXRlQWN0aW9uKSB7XG4gICAgICAgICAgdXBkYXRlQWN0aW9uID0gdXBkYXRlQWN0aW9uWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGV0ZUFjdGlvbikge1xuICAgICAgICAgIGRlbGV0ZUFjdGlvbiA9IGRlbGV0ZUFjdGlvblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXNSZWdleCA9IC9SRUZFUkVOQ0VTLitcXCgoPzpbXikoXSt8XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSpcXCkvO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VDb25kaXRpb25zID0gY29uc3RyYWludFNxbC5tYXRjaChyZWZlcmVuY2VzUmVnZXgpWzBdLnNwbGl0KCcgJyk7XG4gICAgICAgIHJlZmVyZW5jZVRhYmxlTmFtZSA9IFV0aWxzLnJlbW92ZVRpY2tzKHJlZmVyZW5jZUNvbmRpdGlvbnNbMV0pO1xuICAgICAgICBsZXQgY29sdW1uTmFtZXMgPSByZWZlcmVuY2VDb25kaXRpb25zWzJdO1xuICAgICAgICBjb2x1bW5OYW1lcyA9IGNvbHVtbk5hbWVzLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpLnNwbGl0KCcsICcpO1xuICAgICAgICByZWZlcmVuY2VUYWJsZUtleXMgPSBjb2x1bW5OYW1lcy5tYXAoY29sdW1uID0+IFV0aWxzLnJlbW92ZVRpY2tzKGNvbHVtbikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25zdHJhaW50Q29uZGl0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvXFwoKD86W14pKF0rfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqXFwpLylbMF07XG4gICAgICBjb25zdHJhaW50U3FsID0gY29uc3RyYWludFNxbC5yZXBsYWNlKC9cXCguK1xcKS8sICcnKTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50U3FsLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChjb25zdHJhaW50WzFdID09PSAnUFJJTUFSWScgfHwgY29uc3RyYWludFsxXSA9PT0gJ0ZPUkVJR04nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRbMV0gKz0gJyBLRVknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdHJhaW50TmFtZTogVXRpbHMucmVtb3ZlVGlja3MoY29uc3RyYWludFswXSksXG4gICAgICAgIGNvbnN0cmFpbnRUeXBlOiBjb25zdHJhaW50WzFdLFxuICAgICAgICB1cGRhdGVBY3Rpb24sXG4gICAgICAgIGRlbGV0ZUFjdGlvbixcbiAgICAgICAgc3FsOiBzcWwucmVwbGFjZSgvXCIvZywgJ2AnKSwgLy9TcWxpdGUgcmV0dXJucyBkb3VibGUgcXVvdGVzIGZvciB0YWJsZSBuYW1lXG4gICAgICAgIGNvbnN0cmFpbnRDb25kaXRpb24sXG4gICAgICAgIHJlZmVyZW5jZVRhYmxlTmFtZSxcbiAgICAgICAgcmVmZXJlbmNlVGFibGVLZXlzXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICB9XG5cbiAgYXBwbHlQYXJzZXJzKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUuaW5jbHVkZXMoJygnKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcGFydFxuICAgICAgdHlwZSA9IHR5cGUuc3Vic3RyKDAsIHR5cGUuaW5kZXhPZignKCcpKTtcbiAgICB9XG4gICAgdHlwZSA9IHR5cGUucmVwbGFjZSgnVU5TSUdORUQnLCAnJykucmVwbGFjZSgnWkVST0ZJTEwnLCAnJyk7XG4gICAgdHlwZSA9IHR5cGUudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQodHlwZSk7XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgcGFyc2UpIHtcbiAgICAgIHJldHVybiBwYXJzZSh2YWx1ZSwgeyB0aW1lem9uZTogdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG5cbiAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICBjYXNlICdTUUxJVEVfQ09OU1RSQUlOVCc6IHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdGT1JFSUdOIEtFWSBjb25zdHJhaW50IGZhaWxlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuXG4gICAgICAgIC8vIFNxbGl0ZSBwcmUgMi4yIGJlaGF2aW9yIC0gRXJyb3I6IFNRTElURV9DT05TVFJBSU5UOiBjb2x1bW5zIHgsIHkgYXJlIG5vdCB1bmlxdWVcbiAgICAgICAgbGV0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL2NvbHVtbnMgKC4qPykgYXJlLyk7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGZpZWxkcyA9IG1hdGNoWzFdLnNwbGl0KCcsICcpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gU3FsaXRlIHBvc3QgMi4yIGJlaGF2aW9yIC0gRXJyb3I6IFNRTElURV9DT05TVFJBSU5UOiBVTklRVUUgY29uc3RyYWludCBmYWlsZWQ6IHRhYmxlLngsIHRhYmxlLnlcbiAgICAgICAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9VTklRVUUgY29uc3RyYWludCBmYWlsZWQ6ICguKikvKTtcbiAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGZpZWxkcyA9IG1hdGNoWzFdLnNwbGl0KCcsICcpLm1hcChjb2x1bW5XaXRoVGFibGUgPT4gY29sdW1uV2l0aFRhYmxlLnNwbGl0KCcuJylbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGVycm9yJztcblxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICAgIHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksXG4gICAgICAgICAgICAndW5pcXVlIHZpb2xhdGlvbicsIC8vIHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuREIsXG4gICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZF0sXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICAgJ25vdF91bmlxdWUnXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICAgIF8uZm9yT3duKHRoaXMubW9kZWwudW5pcXVlS2V5cywgY29uc3RyYWludCA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc0VxdWFsKGNvbnN0cmFpbnQuZmllbGRzLCBmaWVsZHMpICYmICEhY29uc3RyYWludC5tc2cpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGNvbnN0cmFpbnQubXNnO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgICB9XG4gICAgICBjYXNlICdTUUxJVEVfQlVTWSc6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlRpbWVvdXRFcnJvcihlcnIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgLy8gU3FsaXRlIHJldHVybnMgaW5kZXhlcyBzbyB0aGUgb25lIHRoYXQgd2FzIGRlZmluZWQgbGFzdCBpcyByZXR1cm5lZCBmaXJzdC4gTGV0cyByZXZlcnNlIHRoYXQhXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGRhdGEucmV2ZXJzZSgpLm1hcChhc3luYyBpdGVtID0+IHtcbiAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICBpdGVtLnByaW1hcnkgPSBmYWxzZTtcbiAgICAgIGl0ZW0udW5pcXVlID0gISFpdGVtLnVuaXF1ZTtcbiAgICAgIGl0ZW0uY29uc3RyYWludE5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICBjb25zdCBjb2x1bW5zID0gYXdhaXQgdGhpcy5ydW4oYFBSQUdNQSBJTkRFWF9JTkZPKFxcYCR7aXRlbS5uYW1lfVxcYClgKTtcbiAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgaXRlbS5maWVsZHNbY29sdW1uLnNlcW5vXSA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IGNvbHVtbi5uYW1lLFxuICAgICAgICAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAgICAgIG9yZGVyOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICB9XG5cbiAgZ2V0RGF0YWJhc2VNZXRob2QoKSB7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpIHx8IHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdDUkVBVEUgVEVNUE9SQVJZIFRBQkxFJy50b0xvd2VyQ2FzZSgpKSB8fCB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLREVMRVRFKSB7XG4gICAgICByZXR1cm4gJ3J1bic7XG4gICAgfVxuICAgIHJldHVybiAnYWxsJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciBtdWx0aXBsZSBFcnJvcnNcbiAqXG4gKiBAcGFyYW0ge0Vycm9yW119IFtlcnJvcnNdIEFycmF5IG9mIGVycm9yc1xuICpcbiAqIEBwcm9wZXJ0eSBlcnJvcnMge0Vycm9yW119XG4gKi9cbmNsYXNzIEFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBBZ2dyZWdhdGVFcnJvciBvZjpcXG4ke1xuICAgICAgdGhpcy5lcnJvcnMubWFwKGVycm9yID0+XG4gICAgICAgIGVycm9yID09PSB0aGlzXG4gICAgICAgICAgPyAnW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXSdcbiAgICAgICAgICA6IGVycm9yIGluc3RhbmNlb2YgQWdncmVnYXRlRXJyb3JcbiAgICAgICAgICAgID8gU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9cXG4kLywgJycpLnJlcGxhY2UoL14vbWcsICcgICcpXG4gICAgICAgICAgICA6IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXi9tZywgJyAgICAnKS5zdWJzdHJpbmcoMilcbiAgICAgICAgXG4gICAgICApLmpvaW4oJ1xcbicpXG4gICAgfVxcbmA7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gYXNzb2NpYXRpb24gaXMgaW1wcm9wZXJseSBjb25zdHJ1Y3RlZCAoc2VlIG1lc3NhZ2UgZm9yIGRldGFpbHMpXG4gKi9cbmNsYXNzIEFzc29jaWF0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUFzc29jaWF0aW9uRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzb2NpYXRpb25FcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZXF1ZWxpemUgcHJvdmlkZXMgYSBob3N0IG9mIGN1c3RvbSBlcnJvciBjbGFzc2VzLCB0byBhbGxvdyB5b3UgdG8gZG8gZWFzaWVyIGRlYnVnZ2luZy4gQWxsIG9mIHRoZXNlIGVycm9ycyBhcmUgZXhwb3NlZCBvbiB0aGUgc2VxdWVsaXplIG9iamVjdCBhbmQgdGhlIHNlcXVlbGl6ZSBjb25zdHJ1Y3Rvci5cbiAqIEFsbCBzZXF1ZWxpemUgZXJyb3JzIGluaGVyaXQgZnJvbSB0aGUgYmFzZSBKUyBlcnJvciBvYmplY3QuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGVycm9ycyBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgYFNlcXVlbGl6ZS5WYWxpZGF0aW9uRXJyb3JgXG4gKiBUaGUgQmFzZSBFcnJvciBhbGwgU2VxdWVsaXplIEVycm9ycyBpbmhlcml0IGZyb20uXG4gKi9cbmNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVCYXNlRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBidWxrIG9wZXJhdGlvbiBmYWlscywgaXQgcmVwcmVzZW50IHBlciByZWNvcmQgbGV2ZWwgZXJyb3IuXG4gKiBVc2VkIHdpdGggQWdncmVnYXRlRXJyb3JcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSAgZXJyb3IgICBFcnJvciBmb3IgYSBnaXZlbiByZWNvcmQvaW5zdGFuY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWNvcmQgIERBTyBpbnN0YW5jZSB0aGF0IGVycm9yIGJlbG9uZ3MgdG9cbiAqL1xuY2xhc3MgQnVsa1JlY29yZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHJlY29yZCkge1xuICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVCdWxrUmVjb3JkRXJyb3InO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3I7XG4gICAgdGhpcy5yZWNvcmQgPSByZWNvcmQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWxrUmVjb3JkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgYWxsIGNvbm5lY3Rpb24gcmVsYXRlZCBlcnJvcnMuXG4gKi9cbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCA/IHBhcmVudC5tZXNzYWdlIDogJycpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVDb25uZWN0aW9uRXJyb3InO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIHNwZWNpZmljIGVycm9yIHdoaWNoIHRyaWdnZXJlZCB0aGlzIG9uZVxuICAgICAqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMub3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGlzIHJlZnVzZWQgZHVlIHRvIGluc3VmZmljaWVudCBwcml2aWxlZ2VzXG4gKi9cbmNsYXNzIEFjY2Vzc0RlbmllZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQWNjZXNzRGVuaWVkRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzRGVuaWVkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGNvbm5lY3Rpb24gaXMgbm90IGFjcXVpcmVkIGR1ZSB0byB0aW1lb3V0XG4gKi9cbmNsYXNzIENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGlzIHJlZnVzZWRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvblJlZnVzZWRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUNvbm5lY3Rpb25SZWZ1c2VkRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblJlZnVzZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi9jb25uZWN0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25uZWN0aW9uIHRvIGEgZGF0YWJhc2UgdGltZXMgb3V0XG4gKi9cbmNsYXNzIENvbm5lY3Rpb25UaW1lZE91dEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplQ29ubmVjdGlvblRpbWVkT3V0RXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblRpbWVkT3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGhhcyBhIGhvc3RuYW1lIHRoYXQgd2FzIG5vdCBmb3VuZFxuICovXG5jbGFzcyBIb3N0Tm90Rm91bmRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUhvc3ROb3RGb3VuZEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvc3ROb3RGb3VuZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLy4uL2Nvbm5lY3Rpb24tZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZSBoYXMgYSBob3N0bmFtZSB0aGF0IHdhcyBub3QgcmVhY2hhYmxlXG4gKi9cbmNsYXNzIEhvc3ROb3RSZWFjaGFibGVFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUhvc3ROb3RSZWFjaGFibGVFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIb3N0Tm90UmVhY2hhYmxlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbm5lY3Rpb25FcnJvciA9IHJlcXVpcmUoJy4vLi4vY29ubmVjdGlvbi1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgY29ubmVjdGlvbiB0byBhIGRhdGFiYXNlIGhhcyBpbnZhbGlkIHZhbHVlcyBmb3IgYW55IG9mIHRoZSBjb25uZWN0aW9uIHBhcmFtZXRlcnNcbiAqL1xuY2xhc3MgSW52YWxpZENvbm5lY3Rpb25FcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUludmFsaWRDb25uZWN0aW9uRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW52YWxpZENvbm5lY3Rpb25FcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBhbGwgZGF0YWJhc2UgcmVsYXRlZCBlcnJvcnMuXG4gKi9cbmNsYXNzIERhdGFiYXNlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQubWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZURhdGFiYXNlRXJyb3InO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFcnJvcn1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbCA9IHBhcmVudDtcbiAgICAvKipcbiAgICAgKiBUaGUgU1FMIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNxbCA9IHBhcmVudC5zcWw7XG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBzcWwgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJlbnQucGFyYW1ldGVycztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFiYXNlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFiYXNlRXJyb3IgPSByZXF1aXJlKCcuLy4uL2RhdGFiYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gZXhjbHVzaW9uIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQgaW4gdGhlIGRhdGFiYXNlXG4gKi9cbmNsYXNzIEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvciBleHRlbmRzIERhdGFiYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogJycgfTtcblxuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplRXhjbHVzaW9uQ29uc3RyYWludEVycm9yJztcblxuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8ICcnO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG9wdGlvbnMuY29uc3RyYWludDtcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXhjbHVzaW9uQ29uc3RyYWludEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEYXRhYmFzZUVycm9yID0gcmVxdWlyZSgnLi8uLi9kYXRhYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgZm9yZWlnbiBrZXkgY29uc3RyYWludCBpcyB2aW9sYXRlZCBpbiB0aGUgZGF0YWJhc2VcbiAqL1xuY2xhc3MgRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvciBleHRlbmRzIERhdGFiYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogJycgfTtcblxuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcic7XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCAnRGF0YWJhc2UgRXJyb3InO1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5yZWx0eXBlID0gb3B0aW9ucy5yZWx0eXBlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YWJhc2VFcnJvciA9IHJlcXVpcmUoJy4vLi4vZGF0YWJhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGRhdGFiYXNlIHF1ZXJ5IHRpbWVzIG91dCBiZWNhdXNlIG9mIGEgZGVhZGxvY2tcbiAqL1xuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRGF0YWJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVRpbWVvdXRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lb3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERhdGFiYXNlRXJyb3IgPSByZXF1aXJlKCcuLy4uL2RhdGFiYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gY29uc3RyYWludCBuYW1lIGlzIG5vdCBmb3VuZCBpbiB0aGUgZGF0YWJhc2VcbiAqL1xuY2xhc3MgVW5rbm93bkNvbnN0cmFpbnRFcnJvciBleHRlbmRzIERhdGFiYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogJycgfTtcblxuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplVW5rbm93bkNvbnN0cmFpbnRFcnJvcic7XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgJ1RoZSBzcGVjaWZpZWQgY29uc3RyYWludCBkb2VzIG5vdCBleGlzdCc7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gb3B0aW9ucy5jb25zdHJhaW50O1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVbmtub3duQ29uc3RyYWludEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBpbmNsdWRlIHN0YXRlbWVudCBpcyBpbXByb3Blcmx5IGNvbnN0cnVjdGVkIChzZWUgbWVzc2FnZSBmb3IgZGV0YWlscylcbiAqL1xuY2xhc3MgRWFnZXJMb2FkaW5nRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUVhZ2VyTG9hZGluZ0Vycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVhZ2VyTG9hZGluZ0Vycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHJlY29yZCB3YXMgbm90IGZvdW5kLCBVc3VhbGx5IHVzZWQgd2l0aCByZWplY3RPbkVtcHR5IG1vZGUgKHNlZSBtZXNzYWdlIGZvciBkZXRhaWxzKVxuICovXG5jbGFzcyBFbXB0eVJlc3VsdEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTZXF1ZWxpemVFbXB0eVJlc3VsdEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVtcHR5UmVzdWx0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbmV4cG9ydHMuQWdncmVnYXRlRXJyb3IgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS1lcnJvcicpO1xuZXhwb3J0cy5Bc3luY1F1ZXVlRXJyb3IgPSByZXF1aXJlKCcuLi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZScpLkFzeW5jUXVldWVFcnJvcjtcbmV4cG9ydHMuQXNzb2NpYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb24tZXJyb3InKTtcbmV4cG9ydHMuQnVsa1JlY29yZEVycm9yID0gcmVxdWlyZSgnLi9idWxrLXJlY29yZC1lcnJvcicpO1xuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24tZXJyb3InKTtcbmV4cG9ydHMuRGF0YWJhc2VFcnJvciA9IHJlcXVpcmUoJy4vZGF0YWJhc2UtZXJyb3InKTtcbmV4cG9ydHMuRWFnZXJMb2FkaW5nRXJyb3IgPSByZXF1aXJlKCcuL2VhZ2VyLWxvYWRpbmctZXJyb3InKTtcbmV4cG9ydHMuRW1wdHlSZXN1bHRFcnJvciA9IHJlcXVpcmUoJy4vZW1wdHktcmVzdWx0LWVycm9yJyk7XG5leHBvcnRzLkluc3RhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2luc3RhbmNlLWVycm9yJyk7XG5leHBvcnRzLk9wdGltaXN0aWNMb2NrRXJyb3IgPSByZXF1aXJlKCcuL29wdGltaXN0aWMtbG9jay1lcnJvcicpO1xuZXhwb3J0cy5RdWVyeUVycm9yID0gcmVxdWlyZSgnLi9xdWVyeS1lcnJvcicpO1xuZXhwb3J0cy5TZXF1ZWxpemVTY29wZUVycm9yID0gcmVxdWlyZSgnLi9zZXF1ZWxpemUtc2NvcGUtZXJyb3InKTtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uLWVycm9yJyk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvckl0ZW0gPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtO1xuXG5leHBvcnRzLkFjY2Vzc0RlbmllZEVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2FjY2Vzcy1kZW5pZWQtZXJyb3InKTtcbmV4cG9ydHMuQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1hY3F1aXJlLXRpbWVvdXQtZXJyb3InKTtcbmV4cG9ydHMuQ29ubmVjdGlvblJlZnVzZWRFcnJvciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3InKTtcbmV4cG9ydHMuQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3InKTtcbmV4cG9ydHMuSG9zdE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vaG9zdC1ub3QtZm91bmQtZXJyb3InKTtcbmV4cG9ydHMuSG9zdE5vdFJlYWNoYWJsZUVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvcicpO1xuZXhwb3J0cy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvcicpO1xuXG5leHBvcnRzLkV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvciA9IHJlcXVpcmUoJy4vZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3InKTtcbmV4cG9ydHMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvciA9IHJlcXVpcmUoJy4vZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvcicpO1xuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSByZXF1aXJlKCcuL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3InKTtcbmV4cG9ydHMuVW5rbm93bkNvbnN0cmFpbnRFcnJvciA9IHJlcXVpcmUoJy4vZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yJyk7XG5cbmV4cG9ydHMuVW5pcXVlQ29uc3RyYWludEVycm9yID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJhc2VFcnJvciA9IHJlcXVpcmUoJy4vYmFzZS1lcnJvcicpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIGEgc29tZSBwcm9ibGVtIG9jY3VycmVkIHdpdGggSW5zdGFuY2UgbWV0aG9kcyAoc2VlIG1lc3NhZ2UgZm9yIGRldGFpbHMpXG4gKi9cbmNsYXNzIEluc3RhbmNlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZUluc3RhbmNlRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zdGFuY2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byB1cGRhdGUgYSBzdGFsZSBtb2RlbCBpbnN0YW5jZVxuICovXG5jbGFzcyBPcHRpbWlzdGljTG9ja0Vycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBgQXR0ZW1wdGluZyB0byB1cGRhdGUgYSBzdGFsZSBtb2RlbCBpbnN0YW5jZTogJHtvcHRpb25zLm1vZGVsTmFtZX1gO1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZU9wdGltaXN0aWNMb2NrRXJyb3InO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBvbiB3aGljaCB0aGUgdXBkYXRlIHdhcyBhdHRlbXB0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbE5hbWUgPSBvcHRpb25zLm1vZGVsTmFtZTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWVzIG9mIHRoZSBhdHRlbXB0ZWQgdXBkYXRlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMud2hlcmUgPSBvcHRpb25zLndoZXJlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3B0aW1pc3RpY0xvY2tFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBxdWVyeSBpcyBwYXNzZWQgaW52YWxpZCBvcHRpb25zIChzZWUgbWVzc2FnZSBmb3IgZGV0YWlscylcbiAqL1xuY2xhc3MgUXVlcnlFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplUXVlcnlFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCYXNlRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2UtZXJyb3InKTtcblxuLyoqXG4gKiBTY29wZSBFcnJvci4gVGhyb3duIHdoZW4gdGhlIHNlcXVlbGl6ZSBjYW5ub3QgcXVlcnkgdGhlIHNwZWNpZmllZCBzY29wZS5cbiAqL1xuY2xhc3MgU2VxdWVsaXplU2NvcGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gJ1NlcXVlbGl6ZVNjb3BlRXJyb3InO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxdWVsaXplU2NvcGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmFzZUVycm9yID0gcmVxdWlyZSgnLi9iYXNlLWVycm9yJyk7XG5cbi8qKlxuICogVmFsaWRhdGlvbiBFcnJvci4gVGhyb3duIHdoZW4gdGhlIHNlcXVlbGl6ZSB2YWxpZGF0aW9uIGhhcyBmYWlsZWQuIFRoZSBlcnJvciBjb250YWlucyBhbiBgZXJyb3JzYCBwcm9wZXJ0eSxcbiAqIHdoaWNoIGlzIGFuIGFycmF5IHdpdGggMSBvciBtb3JlIFZhbGlkYXRpb25FcnJvckl0ZW1zLCBvbmUgZm9yIGVhY2ggdmFsaWRhdGlvbiB0aGF0IGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0FycmF5fSBbZXJyb3JzXSBBcnJheSBvZiBWYWxpZGF0aW9uRXJyb3JJdGVtIG9iamVjdHMgZGVzY3JpYmluZyB0aGUgdmFsaWRhdGlvbiBlcnJvcnNcbiAqXG4gKiBAcHJvcGVydHkgZXJyb3JzIHtWYWxpZGF0aW9uRXJyb3JJdGVtc1tdfVxuICovXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplVmFsaWRhdGlvbkVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVmFsaWRhdGlvbiBFcnJvcic7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VmFsaWRhdGlvbkVycm9ySXRlbVtdfVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuXG4gICAgLy8gVXNlIHByb3ZpZGVkIGVycm9yIG1lc3NhZ2UgaWYgYXZhaWxhYmxlLi4uXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgICAgIC8vIC4uLiBvdGhlcndpc2UgY3JlYXRlIGEgY29uY2F0ZW5hdGVkIG1lc3NhZ2Ugb3V0IG9mIGV4aXN0aW5nIGVycm9ycy5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDAgJiYgdGhpcy5lcnJvcnNbMF0ubWVzc2FnZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubWFwKGVyciA9PiBgJHtlcnIudHlwZSB8fCBlcnIub3JpZ2lufTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsXFxuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHZhbGlkYXRpb24gZXJyb3IgaXRlbXMgZm9yIHRoZSBwYXRoIC8gZmllbGQgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBiZSBjaGVja2VkIGZvciBlcnJvciBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8VmFsaWRhdGlvbkVycm9ySXRlbT59IFZhbGlkYXRpb24gZXJyb3IgaXRlbXMgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aFxuICAgKi9cbiAgZ2V0KHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvcnMucmVkdWNlKChyZWR1Y2VkLCBlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yLnBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgcmVkdWNlZC5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIFtdKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRpb24gRXJyb3IgSXRlbVxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGluY2x1ZGVkIGluIHRoZSBgVmFsaWRhdGlvbkVycm9yLmVycm9yc2AgcHJvcGVydHkuXG4gKi9cbmNsYXNzIFZhbGlkYXRpb25FcnJvckl0ZW0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBWYWxpZGF0aW9uRXJyb3IgaXRlbS4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGluY2x1ZGVkIGluIHRoZSBgVmFsaWRhdGlvbkVycm9yLmVycm9yc2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gQW4gZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFRoZSB0eXBlL29yaWdpbiBvZiB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhdIFRoZSBmaWVsZCB0aGF0IHRyaWdnZXJlZCB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSBUaGUgdmFsdWUgdGhhdCBnZW5lcmF0ZWQgdGhlIGVycm9yXG4gICAqIEBwYXJhbSB7TW9kZWx9IFtpbnN0YW5jZV0gdGhlIERBTyBpbnN0YW5jZSB0aGF0IGNhdXNlZCB0aGUgdmFsaWRhdGlvbiBlcnJvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRvcktleV0gYSB2YWxpZGF0aW9uIFwia2V5XCIsIHVzZWQgZm9yIGlkZW50aWZpY2F0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm5OYW1lXSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBCVUlMVC1JTiB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHZhbGlkYXRpb24gZXJyb3IgKGUuZy4gXCJpblwiIG9yIFwibGVuXCIpLCBpZiBhcHBsaWNhYmxlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtmbkFyZ3NdIHBhcmFtZXRlcnMgdXNlZCB3aXRoIHRoZSBCVUlMVC1JTiB2YWxpZGF0b3IgZnVuY3Rpb24sIGlmIGFwcGxpY2FibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUsIHBhdGgsIHZhbHVlLCBpbnN0YW5jZSwgdmFsaWRhdG9yS2V5LCBmbk5hbWUsIGZuQXJncykge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUvb3JpZ2luIG9mIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIHRoYXQgdHJpZ2dlcmVkIHRoZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgdGhhdCBnZW5lcmF0ZWQgdGhlIGVycm9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogbnVsbDtcblxuICAgIHRoaXMub3JpZ2luID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBEQU8gaW5zdGFuY2UgdGhhdCBjYXVzZWQgdGhlIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtNb2RlbCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHZhbGlkYXRpb24gXCJrZXlcIiwgdXNlZCBmb3IgaWRlbnRpZmljYXRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9yS2V5ID0gdmFsaWRhdG9yS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBCVUlMVC1JTiB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHZhbGlkYXRpb24gZXJyb3IgKGUuZy4gXCJpblwiIG9yIFwibGVuXCIpLCBpZiBhcHBsaWNhYmxlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRvck5hbWUgPSBmbk5hbWUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgdXNlZCB3aXRoIHRoZSBCVUlMVC1JTiB2YWxpZGF0b3IgZnVuY3Rpb24sIGlmIGFwcGxpY2FibGVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRvckFyZ3MgPSBmbkFyZ3MgfHwgW107XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2luc1sgdHlwZSBdKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVR5cGUgPSBgJHt0eXBlfWAudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGNvbnN0IHJlYWxUeXBlID0gVmFsaWRhdGlvbkVycm9ySXRlbS5UeXBlU3RyaW5nTWFwWyBsb3dlcmNhc2VUeXBlIF07XG5cbiAgICAgICAgaWYgKHJlYWxUeXBlICYmIFZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2luc1sgcmVhbFR5cGUgXSkge1xuICAgICAgICAgIHRoaXMub3JpZ2luID0gcmVhbFR5cGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZG9lc24ndCBuZWVkIGNhcHR1cmVTdGFja1RyYWNlIGJlY2F1c2UgaXQncyBub3QgYSBzdWJjbGFzcyBvZiBFcnJvclxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiBhIGxvd2VyY2FzZSwgdHJpbW1lZCBzdHJpbmcgXCJrZXlcIiB0aGF0IGlkZW50aWZpZXMgdGhlIHZhbGlkYXRvci5cbiAgICpcbiAgICogTm90ZTogdGhlIHN0cmluZyB3aWxsIGJlIGVtcHR5IGlmIHRoZSBpbnN0YW5jZSBoYXMgbmVpdGhlciBhIHZhbGlkIGB2YWxpZGF0b3JLZXlgIHByb3BlcnR5IG5vciBhIHZhbGlkIGB2YWxpZGF0b3JOYW1lYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gW3VzZVR5cGVBc05TPXRydWVdICAgICAgY29udHJvbHMgd2hldGhlciB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgXCJuYW1lc3BhY2VcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgaWYgdGhlIHZhbGlkYXRvcidzIGB0eXBlYCBpcyBub3Qgb25lIG9mIFZhbGlkYXRpb25FcnJvckl0ZW0uT3JpZ2luc1xuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgW05TU2VwYXJhdG9yPScuJ10gICAgICAgYSBzZXBhcmF0b3Igc3RyaW5nIGZvciBjb25jYXRlbmF0aW5nIHRoZSBuYW1lc3BhY2UsIG11c3QgYmUgbm90IGJlIGVtcHR5LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gXCIuXCIgKGZ1bGxzdG9wKS4gb25seSB1c2VkIGFuZCB2YWxpZGF0ZWQgaWYgdXNlVHlwZUFzTlMgaXMgVFJVRS5cbiAgICogQHRocm93cyAge0Vycm9yfSAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93biBpZiBOU1NlcGFyYXRvciBpcyBmb3VuZCB0byBiZSBpbnZhbGlkLlxuICAgKiBAcmV0dXJucyAge3N0cmluZ31cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFZhbGlkYXRvcktleSh1c2VUeXBlQXNOUywgTlNTZXBhcmF0b3IpIHtcbiAgICBjb25zdCB1c2VUQU5TID0gdXNlVHlwZUFzTlMgPT09IHVuZGVmaW5lZCB8fCAhIXVzZVR5cGVBc05TO1xuICAgIGNvbnN0IE5TU2VwID0gTlNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcuJyA6IE5TU2VwYXJhdG9yO1xuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMub3JpZ2luO1xuICAgIGNvbnN0IGtleSA9IHRoaXMudmFsaWRhdG9yS2V5IHx8IHRoaXMudmFsaWRhdG9yTmFtZTtcbiAgICBjb25zdCB1c2VOUyA9IHVzZVRBTlMgJiYgdHlwZSAmJiBWYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnNbIHR5cGUgXTtcblxuICAgIGlmICh1c2VOUyAmJiAodHlwZW9mIE5TU2VwICE9PSAnc3RyaW5nJyB8fCAhTlNTZXAubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5hbWVzcGFjZSBzZXBhcmF0b3IgZ2l2ZW4sIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gKHVzZU5TID8gW3R5cGUsIGtleV0uam9pbihOU1NlcCkgOiBrZXkpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB9XG59XG5cbi8qKlxuICogQW4gZW51bSB0aGF0IGRlZmluZXMgdmFsaWQgVmFsaWRhdGlvbkVycm9ySXRlbSBgb3JpZ2luYCB2YWx1ZXNcbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IENPUkUgICAgICAge3N0cmluZ30gIHNwZWNpZmllcyBlcnJvcnMgdGhhdCBvcmlnaW5hdGUgZnJvbSB0aGUgc2VxdWVsaXplIFwiY29yZVwiXG4gKiBAcHJvcGVydHkgREIgICAgICAgICB7c3RyaW5nfSAgc3BlY2lmaWVzIHZhbGlkYXRpb24gZXJyb3JzIHRoYXQgb3JpZ2luYXRlIGZyb20gdGhlIHN0b3JhZ2UgZW5naW5lXG4gKiBAcHJvcGVydHkgRlVOQ1RJT04gICB7c3RyaW5nfSAgc3BlY2lmaWVzIHZhbGlkYXRpb24gZXJyb3JzIHRoYXQgb3JpZ2luYXRlIGZyb20gdmFsaWRhdG9yIGZ1bmN0aW9ucyAoYm90aCBidWlsdC1pbiBhbmQgY3VzdG9tKSBkZWZpbmVkIGZvciBhIGdpdmVuIGF0dHJpYnV0ZVxuICovXG5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMgPSB7XG4gIENPUkU6ICdDT1JFJyxcbiAgREI6ICdEQicsXG4gIEZVTkNUSU9OOiAnRlVOQ1RJT04nXG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgYFZhbGlkYXRpb25FcnJvckl0ZW1gIGNsYXNzXG4gKiB0aGF0IG1hcHMgY3VycmVudCBgdHlwZWAgc3RyaW5ncyAoYXMgZ2l2ZW4gdG8gVmFsaWRhdGlvbkVycm9ySXRlbS5jb25zdHJ1Y3RvcigpKSB0b1xuICogb3VyIG5ldyBgb3JpZ2luYCB2YWx1ZXMuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqL1xuVmFsaWRhdGlvbkVycm9ySXRlbS5UeXBlU3RyaW5nTWFwID0ge1xuICAnbm90bnVsbCB2aW9sYXRpb24nOiAnQ09SRScsXG4gICdzdHJpbmcgdmlvbGF0aW9uJzogJ0NPUkUnLFxuICAndW5pcXVlIHZpb2xhdGlvbic6ICdEQicsXG4gICd2YWxpZGF0aW9uIGVycm9yJzogJ0ZVTkNUSU9OJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3JJdGVtID0gVmFsaWRhdGlvbkVycm9ySXRlbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi8uLi92YWxpZGF0aW9uLWVycm9yJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSB1bmlxdWUgY29uc3RyYWludCBpcyB2aW9sYXRlZCBpbiB0aGUgZGF0YWJhc2VcbiAqL1xuY2xhc3MgVW5pcXVlQ29uc3RyYWludEVycm9yIGV4dGVuZHMgVmFsaWRhdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6ICcnIH07XG4gICAgb3B0aW9ucy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgJ1ZhbGlkYXRpb24gRXJyb3InO1xuICAgIG9wdGlvbnMuZXJyb3JzID0gb3B0aW9ucy5lcnJvcnMgfHwge307XG4gICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlLCBvcHRpb25zLmVycm9ycyk7XG5cbiAgICB0aGlzLm5hbWUgPSAnU2VxdWVsaXplVW5pcXVlQ29uc3RyYWludEVycm9yJztcbiAgICB0aGlzLmVycm9ycyA9IG9wdGlvbnMuZXJyb3JzO1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLm9yaWdpbmFsID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy5zcWwgPSBvcHRpb25zLnBhcmVudC5zcWw7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVbmlxdWVDb25zdHJhaW50RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuL3V0aWxzL2xvZ2dlcicpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KCdob29rcycpO1xuXG5jb25zdCBob29rVHlwZXMgPSB7XG4gIGJlZm9yZVZhbGlkYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclZhbGlkYXRlOiB7IHBhcmFtczogMiB9LFxuICB2YWxpZGF0aW9uRmFpbGVkOiB7IHBhcmFtczogMyB9LFxuICBiZWZvcmVDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVEZXN0cm95OiB7IHBhcmFtczogMiB9LFxuICBhZnRlckRlc3Ryb3k6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVJlc3RvcmU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyUmVzdG9yZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlVXBkYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclVwZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlU2F2ZTogeyBwYXJhbXM6IDIsIHByb3hpZXM6IFsnYmVmb3JlVXBkYXRlJywgJ2JlZm9yZUNyZWF0ZSddIH0sXG4gIGFmdGVyU2F2ZTogeyBwYXJhbXM6IDIsIHByb3hpZXM6IFsnYWZ0ZXJVcGRhdGUnLCAnYWZ0ZXJDcmVhdGUnXSB9LFxuICBiZWZvcmVVcHNlcnQ6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVXBzZXJ0OiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVCdWxrQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlckJ1bGtDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUJ1bGtEZXN0cm95OiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtEZXN0cm95OiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrUmVzdG9yZTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrUmVzdG9yZTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1VwZGF0ZTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrVXBkYXRlOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckZpbmQ6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUNvdW50OiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVEZWZpbmU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyRGVmaW5lOiB7IHBhcmFtczogMSwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVJbml0OiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckluaXQ6IHsgcGFyYW1zOiAxLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZUFzc29jaWF0ZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUgfSxcbiAgYWZ0ZXJBc3NvY2lhdGU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlIH0sXG4gIGJlZm9yZUNvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyQ29ubmVjdDogeyBwYXJhbXM6IDIsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlRGlzY29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJEaXNjb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVTeW5jOiB7IHBhcmFtczogMSB9LFxuICBhZnRlclN5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtTeW5jOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtTeW5jOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVRdWVyeTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJRdWVyeTogeyBwYXJhbXM6IDIgfVxufTtcbmV4cG9ydHMuaG9va3MgPSBob29rVHlwZXM7XG5cblxuLyoqXG4gKiBnZXQgYXJyYXkgb2YgY3VycmVudCBob29rIGFuZCBpdHMgcHJveGllcyBjb21iaW5lZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rVHlwZSBhbnkgaG9vayB0eXBlIEBzZWUge0BsaW5rIGhvb2tUeXBlc31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBnZXRQcm94aWVkSG9va3MgPSBob29rVHlwZSA9PlxuICBob29rVHlwZXNbaG9va1R5cGVdLnByb3hpZXNcbiAgICA/IGhvb2tUeXBlc1tob29rVHlwZV0ucHJveGllcy5jb25jYXQoaG9va1R5cGUpXG4gICAgOiBbaG9va1R5cGVdXG47XG5cbmZ1bmN0aW9uIGdldEhvb2tzKGhvb2tlZCwgaG9va1R5cGUpIHtcbiAgcmV0dXJuIChob29rZWQub3B0aW9ucy5ob29rcyB8fCB7fSlbaG9va1R5cGVdIHx8IFtdO1xufVxuXG5jb25zdCBIb29rcyA9IHtcbiAgLyoqXG4gICAqIFByb2Nlc3MgdXNlciBzdXBwbGllZCBob29rcyBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBob29rcyBob29rcyBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICAgKi9cbiAgX3NldHVwSG9va3MoaG9va3MpIHtcbiAgICB0aGlzLm9wdGlvbnMuaG9va3MgPSB7fTtcbiAgICBfLm1hcChob29rcyB8fCB7fSwgKGhvb2tzQXJyYXksIGhvb2tOYW1lKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9va3NBcnJheSkpIGhvb2tzQXJyYXkgPSBbaG9va3NBcnJheV07XG4gICAgICBob29rc0FycmF5LmZvckVhY2goaG9va0ZuID0+IHRoaXMuYWRkSG9vayhob29rTmFtZSwgaG9va0ZuKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgYXN5bmMgcnVuSG9va3MoaG9va3MsIC4uLmhvb2tBcmdzKSB7XG4gICAgaWYgKCFob29rcykgdGhyb3cgbmV3IEVycm9yKCdydW5Ib29rcyByZXF1aXJlcyBhdCBsZWFzdCAxIGFyZ3VtZW50Jyk7XG5cbiAgICBsZXQgaG9va1R5cGU7XG5cbiAgICBpZiAodHlwZW9mIGhvb2tzID09PSAnc3RyaW5nJykge1xuICAgICAgaG9va1R5cGUgPSBob29rcztcbiAgICAgIGhvb2tzID0gZ2V0SG9va3ModGhpcywgaG9va1R5cGUpO1xuXG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUpIHtcbiAgICAgICAgaG9va3MgPSBob29rcy5jb25jYXQoZ2V0SG9va3ModGhpcy5zZXF1ZWxpemUsIGhvb2tUeXBlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhvb2tzKSkge1xuICAgICAgaG9va3MgPSBbaG9va3NdO1xuICAgIH1cblxuICAgIC8vIHN5bmNocm9ub3VzIGhvb2tzXG4gICAgaWYgKGhvb2tUeXBlc1tob29rVHlwZV0gJiYgaG9va1R5cGVzW2hvb2tUeXBlXS5zeW5jKSB7XG4gICAgICBmb3IgKGxldCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBob29rID0gaG9vay5mbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKGBydW5uaW5nIGhvb2soc3luYykgJHtob29rVHlwZX1gKTtcbiAgICAgICAgaG9vay5hcHBseSh0aGlzLCBob29rQXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXN5bmNocm9ub3VzIGhvb2tzIChkZWZhdWx0KVxuICAgIGZvciAobGV0IGhvb2sgb2YgaG9va3MpIHtcbiAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaG9vayA9IGhvb2suZm47XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKGBydW5uaW5nIGhvb2sgJHtob29rVHlwZX1gKTtcbiAgICAgIGF3YWl0IGhvb2suYXBwbHkodGhpcywgaG9va0FyZ3MpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgaG9vayB0byB0aGUgbW9kZWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIGhvb2tUeXBlIGhvb2sgbmFtZSBAc2VlIHtAbGluayBob29rVHlwZXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBbbmFtZV0gUHJvdmlkZSBhIG5hbWUgZm9yIHRoZSBob29rIGZ1bmN0aW9uLiBJdCBjYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGhvb2sgbGF0ZXIgb3IgdG8gb3JkZXIgaG9va3MgYmFzZWQgb24gc29tZSBzb3J0IG9mIHByaW9yaXR5IHN5c3RlbSBpbiB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgZm4gVGhlIGhvb2sgZnVuY3Rpb25cbiAgICpcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gICAqL1xuICBhZGRIb29rKGhvb2tUeXBlLCBuYW1lLCBmbikge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBuYW1lO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVidWcoYGFkZGluZyBob29rICR7aG9va1R5cGV9YCk7XG4gICAgLy8gY2hlY2sgZm9yIHByb3hpZXMsIGFkZCB0aGVtIHRvb1xuICAgIGhvb2tUeXBlID0gZ2V0UHJveGllZEhvb2tzKGhvb2tUeXBlKTtcblxuICAgIGhvb2tUeXBlLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBob29rcyA9IGdldEhvb2tzKHRoaXMsIHR5cGUpO1xuICAgICAgaG9va3MucHVzaChuYW1lID8geyBuYW1lLCBmbiB9IDogZm4pO1xuICAgICAgdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdID0gaG9va3M7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGhvb2sgZnJvbSB0aGUgbW9kZWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvb2tUeXBlIEBzZWUge0BsaW5rIGhvb2tUeXBlc31cbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IG5hbWUgbmFtZSBvZiBob29rIG9yIGZ1bmN0aW9uIHJlZmVyZW5jZSB3aGljaCB3YXMgYXR0YWNoZWRcbiAgICpcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gICAqL1xuICByZW1vdmVIb29rKGhvb2tUeXBlLCBuYW1lKSB7XG4gICAgY29uc3QgaXNSZWZlcmVuY2UgPSB0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJyA/IHRydWUgOiBmYWxzZTtcblxuICAgIGlmICghdGhpcy5oYXNIb29rKGhvb2tUeXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGVidWcoYHJlbW92aW5nIGhvb2sgJHtob29rVHlwZX1gKTtcblxuICAgIC8vIGNoZWNrIGZvciBwcm94aWVzLCBhZGQgdGhlbSB0b29cbiAgICBob29rVHlwZSA9IGdldFByb3hpZWRIb29rcyhob29rVHlwZSk7XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgaG9va1R5cGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXSA9IHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXS5maWx0ZXIoaG9vayA9PiB7XG4gICAgICAgIGlmIChpc1JlZmVyZW5jZSAmJiB0eXBlb2YgaG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBob29rICE9PSBuYW1lOyAvLyBjaGVjayBpZiBzYW1lIG1ldGhvZFxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWZlcmVuY2UgJiYgdHlwZW9mIGhvb2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2submFtZSAhPT0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBtb2RlIGhhcyBhbnkgaG9va3Mgb2YgdGhpcyB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rVHlwZSBAc2VlIHtAbGluayBob29rVHlwZXN9XG4gICAqXG4gICAqIEBhbGlhcyBoYXNIb29rc1xuICAgKlxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAgICovXG4gIGhhc0hvb2soaG9va1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhvb2tzW2hvb2tUeXBlXSAmJiAhIXRoaXMub3B0aW9ucy5ob29rc1tob29rVHlwZV0ubGVuZ3RoO1xuICB9XG59O1xuSG9va3MuaGFzSG9va3MgPSBIb29rcy5oYXNIb29rO1xuXG5cbmZ1bmN0aW9uIGFwcGx5VG8odGFyZ2V0LCBpc01vZGVsID0gZmFsc2UpIHtcbiAgXy5taXhpbih0YXJnZXQsIEhvb2tzKTtcblxuICBmb3IgKGNvbnN0IGhvb2sgb2YgT2JqZWN0LmtleXMoaG9va1R5cGVzKSkge1xuICAgIGlmIChpc01vZGVsICYmIGhvb2tUeXBlc1tob29rXS5ub01vZGVsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGFyZ2V0W2hvb2tdID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEhvb2soaG9vaywgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuYXBwbHlUbyA9IGFwcGx5VG87XG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZVZhbGlkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgdmFsaWRhdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlclZhbGlkYXRlXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gd2hlbiB2YWxpZGF0aW9uIGZhaWxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2UsIG9wdGlvbnMsIGVycm9yLiBFcnJvciBpcyB0aGVcbiAqIFNlcXVlbGl6ZVZhbGlkYXRpb25FcnJvci4gSWYgdGhlIGNhbGxiYWNrIHRocm93cyBhbiBlcnJvciwgaXQgd2lsbCByZXBsYWNlIHRoZSBvcmlnaW5hbCB2YWxpZGF0aW9uIGVycm9yLlxuICogQG5hbWUgdmFsaWRhdGlvbkZhaWxlZFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBjcmVhdGluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGF0dHJpYnV0ZXMsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUNyZWF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGNyZWF0aW5nIGEgc2luZ2xlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJDcmVhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgY3JlYXRpbmcgb3IgdXBkYXRpbmcgYSBzaW5nbGUgaW5zdGFuY2UsIEl0IHByb3hpZXMgYGJlZm9yZUNyZWF0ZWAgYW5kIGBiZWZvcmVVcGRhdGVgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlU2F2ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSB1cHNlcnRpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVVcHNlcnRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciB1cHNlcnRpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHVwc2VydCgpLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlclVwc2VydFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBjcmVhdGluZyBvciB1cGRhdGluZyBhIHNpbmdsZSBpbnN0YW5jZSwgSXQgcHJveGllcyBgYWZ0ZXJDcmVhdGVgIGFuZCBgYWZ0ZXJVcGRhdGVgXG4gKlxuICAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhdHRyaWJ1dGVzLCBvcHRpb25zXG4gICogQG5hbWUgYWZ0ZXJTYXZlXG4gICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgZGVzdHJveWluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKlxuICogQG5hbWUgYmVmb3JlRGVzdHJveVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGRlc3Ryb3lpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICpcbiAqIEBuYW1lIGFmdGVyRGVzdHJveVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSByZXN0b3JpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICpcbiAqIEBuYW1lIGJlZm9yZVJlc3RvcmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciByZXN0b3JpbmcgYSBzaW5nbGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZSwgb3B0aW9uc1xuICpcbiAqIEBuYW1lIGFmdGVyUmVzdG9yZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSB1cGRhdGluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVVcGRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciB1cGRhdGluZyBhIHNpbmdsZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlclVwZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBjcmVhdGluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGluc3RhbmNlcywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlQnVsa0NyZWF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGNyZWF0aW5nIGluc3RhbmNlcyBpbiBidWxrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggaW5zdGFuY2VzLCBvcHRpb25zXG4gKiBAbmFtZSBhZnRlckJ1bGtDcmVhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgZGVzdHJveWluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAbmFtZSBiZWZvcmVCdWxrRGVzdHJveVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIGRlc3Ryb3lpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKlxuICogQG5hbWUgYWZ0ZXJCdWxrRGVzdHJveVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSByZXN0b3JpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKlxuICogQG5hbWUgYmVmb3JlQnVsa1Jlc3RvcmVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciByZXN0b3JpbmcgaW5zdGFuY2VzIGluIGJ1bGtcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKlxuICogQG5hbWUgYWZ0ZXJCdWxrUmVzdG9yZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSB1cGRhdGluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUJ1bGtVcGRhdGVcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciB1cGRhdGluZyBpbnN0YW5jZXMgaW4gYnVsa1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGFmdGVyQnVsa1VwZGF0ZVxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGZpbmQgKHNlbGVjdCkgcXVlcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVGaW5kXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgZmluZCAoc2VsZWN0KSBxdWVyeSwgYWZ0ZXIgYW55IHsgaW5jbHVkZToge2FsbDogLi4ufSB9IG9wdGlvbnMgYXJlIGV4cGFuZGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGZpbmQgKHNlbGVjdCkgcXVlcnksIGFmdGVyIGFsbCBvcHRpb24gcGFyc2luZyBpcyBjb21wbGV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUZpbmRBZnRlck9wdGlvbnNcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuTW9kZWxcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBhIGZpbmQgKHNlbGVjdCkgcXVlcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBpbnN0YW5jZShzKSwgb3B0aW9uc1xuICogQG5hbWUgYWZ0ZXJGaW5kXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplLk1vZGVsXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgY291bnQgcXVlcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBvcHRpb25zXG4gKiBAbmFtZSBiZWZvcmVDb3VudFxuICogQG1lbWJlcm9mIFNlcXVlbGl6ZS5Nb2RlbFxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGJlZm9yZSBhIGRlZmluZSBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYXR0cmlidXRlcywgb3B0aW9uc1xuICogQG5hbWUgYmVmb3JlRGVmaW5lXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYWZ0ZXIgYSBkZWZpbmUgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGZhY3RvcnlcbiAqIEBuYW1lIGFmdGVyRGVmaW5lXG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIFNlcXVlbGl6ZSgpIGNhbGxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBjb25maWcsIG9wdGlvbnNcbiAqIEBuYW1lIGJlZm9yZUluaXRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBTZXF1ZWxpemUoKSBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggc2VxdWVsaXplXG4gKiBAbmFtZSBhZnRlckluaXRcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgYSBjb25uZWN0aW9uIGlzIGNyZWF0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBjb25maWcgcGFzc2VkIHRvIGNvbm5lY3Rpb25cbiAqIEBuYW1lIGJlZm9yZUNvbm5lY3RcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBhIGNvbm5lY3Rpb24gaXMgY3JlYXRlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uIG9iamVjdCBhbmQgdGhlIGNvbmZpZyBwYXNzZWQgdG8gY29ubmVjdGlvblxuICogQG5hbWUgYWZ0ZXJDb25uZWN0XG4gKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gKi9cblxuLyoqXG4gKiBBIGhvb2sgdGhhdCBpcyBydW4gYmVmb3JlIGEgY29ubmVjdGlvbiBpcyBkaXNjb25uZWN0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCB0aGUgY29ubmVjdGlvbiBvYmplY3RcbiAqIEBuYW1lIGJlZm9yZURpc2Nvbm5lY3RcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBhIGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGNvbm5lY3Rpb24gb2JqZWN0XG4gKiBAbmFtZSBhZnRlckRpc2Nvbm5lY3RcbiAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAqL1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgTW9kZWwuc3luYyBjYWxsXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9ucyBwYXNzZWQgdG8gTW9kZWwuc3luY1xuICogQG5hbWUgYmVmb3JlU3luY1xuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIE1vZGVsLnN5bmMgY2FsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIE1vZGVsLnN5bmNcbiAqIEBuYW1lIGFmdGVyU3luY1xuICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICovXG5cbi8qKlxuICAqIEEgaG9vayB0aGF0IGlzIHJ1biBiZWZvcmUgc2VxdWVsaXplLnN5bmMgY2FsbFxuICpcbiAgKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggb3B0aW9ucyBwYXNzZWQgdG8gc2VxdWVsaXplLnN5bmNcbiAgKiBAbmFtZSBiZWZvcmVCdWxrU3luY1xuICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgKi9cblxuLyoqXG4gICogQSBob29rIHRoYXQgaXMgcnVuIGFmdGVyIHNlcXVlbGl6ZS5zeW5jIGNhbGxcbiAqXG4gICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIHNlcXVlbGl6ZS5zeW5jXG4gICogQG5hbWUgYWZ0ZXJCdWxrU3luY1xuICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlbnVtIG9mIGluZGV4IGhpbnRzIHRvIGJlIHVzZWQgaW4gbXlzcWwgZm9yIHF1ZXJ5aW5nIHdpdGggaW5kZXggaGludHNcbiAqXG4gKiBAcHJvcGVydHkgVVNFXG4gKiBAcHJvcGVydHkgRk9SQ0VcbiAqIEBwcm9wZXJ0eSBJR05PUkVcbiAqL1xuY29uc3QgSW5kZXhIaW50cyA9IG1vZHVsZS5leHBvcnRzID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIFVTRTogJ1VTRScsXG4gIEZPUkNFOiAnRk9SQ0UnLFxuICBJR05PUkU6ICdJR05PUkUnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10bycpO1xuY29uc3QgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0b3ItZXh0cmFzJykudmFsaWRhdG9yO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBJbnN0YW5jZSBWYWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtJbnN0YW5jZX0gbW9kZWxJbnN0YW5jZSBUaGUgbW9kZWwgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEluc3RhbmNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IobW9kZWxJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAvLyBhc3NpZ24gZGVmaW5lZCBhbmQgZGVmYXVsdCBvcHRpb25zXG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuZmllbGRzICYmICFvcHRpb25zLnNraXApIHtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyhtb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5tb2RlbEluc3RhbmNlID0gbW9kZWxJbnN0YW5jZTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgYSByZWZlcmVuY2UgdG8gdmFsaWRhdG9yLmpzLiBUaGlzIGFsbG93cyB5b3UgdG8gYWRkIGN1c3RvbSB2YWxpZGF0aW9ucyB1c2luZyBgdmFsaWRhdG9yLmV4dGVuZGBcbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbGlkYXRvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG5cbiAgICAvKipcbiAgICAgKiAgQWxsIGVycm9ycyB3aWxsIGJlIHN0b3JlZCBoZXJlIGZyb20gdGhlIHZhbGlkYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fSBXaWxsIGNvbnRhaW4ga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYXR0cmlidXRlcyB3aGljaCB3aWxsXG4gICAgICogICBiZSBBcnJheXMgb2YgRXJyb3JzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdmFsaWRhdGlvbnMgYXJlIGluIHByb2dyZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgdGhlIFZhbGlkYXRpb24gbW9kdWxlLCBpbnZva2UgdG8gc3RhcnQgdGhlIGRhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF92YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5pblByb2dyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb25zIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG5cbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5fcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpLFxuICAgICAgdGhpcy5fY3VzdG9tVmFsaWRhdG9ycygpXG4gICAgXSk7XG5cbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9yKG51bGwsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIHRoZSBWYWxpZGF0aW9uIHNlcXVlbmNlIGFuZCBydW4gdmFsaWRhdGlvbiBob29rcyBpZiBkZWZpbmVkXG4gICAqICAgLSBCZWZvcmUgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gVmFsaWRhdGlvblxuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBzdWNjZXNzOiBBZnRlciBWYWxpZGF0aW9uIE1vZGVsIEhvb2tzXG4gICAqICAgLSBPbiB2YWxpZGF0aW9uIGZhaWx1cmU6IFZhbGlkYXRpb24gRmFpbGVkIE1vZGVsIEhvb2tzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIGF3YWl0ICh0aGlzLm9wdGlvbnMuaG9va3MgPyB0aGlzLl92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkgOiB0aGlzLl92YWxpZGF0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIFZhbGlkYXRpb24gc2VxdWVuY2UgYW5kIHJ1biBob29rc1xuICAgKiAgIC0gQmVmb3JlIFZhbGlkYXRpb24gTW9kZWwgSG9va3NcbiAgICogICAtIFZhbGlkYXRpb25cbiAgICogICAtIE9uIHZhbGlkYXRpb24gc3VjY2VzczogQWZ0ZXIgVmFsaWRhdGlvbiBNb2RlbCBIb29rc1xuICAgKiAgIC0gT24gdmFsaWRhdGlvbiBmYWlsdXJlOiBWYWxpZGF0aW9uIEZhaWxlZCBNb2RlbCBIb29rc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkge1xuICAgIGNvbnN0IHJ1bkhvb2tzID0gdGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLnJ1bkhvb2tzLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICBhd2FpdCBydW5Ib29rcygnYmVmb3JlVmFsaWRhdGUnLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbmV3RXJyb3IgPSBhd2FpdCBydW5Ib29rcygndmFsaWRhdGlvbkZhaWxlZCcsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXdFcnJvciB8fCBlcnJvcjtcbiAgICB9XG5cbiAgICBhd2FpdCBydW5Ib29rcygnYWZ0ZXJWYWxpZGF0ZScsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5tb2RlbEluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcnVuIGFsbCB0aGUgdmFsaWRhdG9ycyBkZWZpbmVkIHBlciBhdHRyaWJ1dGUgKGJ1aWx0LWluIHZhbGlkYXRvcnMgYW5kIGN1c3RvbSB2YWxpZGF0b3JzKVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfcGVyQXR0cmlidXRlVmFsaWRhdG9ycygpIHtcbiAgICAvLyBwcm9taXNpZnkgYWxsIGF0dHJpYnV0ZSBpbnZvY2F0aW9uc1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcblxuICAgIF8uZm9ySW4odGhpcy5tb2RlbEluc3RhbmNlLnJhd0F0dHJpYnV0ZXMsIChyYXdBdHRyaWJ1dGUsIGZpZWxkKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXAuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1vZGVsSW5zdGFuY2UuZGF0YVZhbHVlc1tmaWVsZF07XG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghcmF3QXR0cmlidXRlLl9hdXRvR2VuZXJhdGVkICYmICFyYXdBdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgICAvLyBwZXJmb3JtIHZhbGlkYXRpb25zIGJhc2VkIG9uIHNjaGVtYVxuICAgICAgICB0aGlzLl92YWxpZGF0ZVNjaGVtYShyYXdBdHRyaWJ1dGUsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnMsIGZpZWxkKSkge1xuICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy5fc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgcmF3QXR0cmlidXRlLmFsbG93TnVsbCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcnVuIGFsbCB0aGUgY3VzdG9tIHZhbGlkYXRvcnMgZGVmaW5lZCBpbiB0aGUgbW9kZWwncyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfY3VzdG9tVmFsaWRhdG9ycygpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5lYWNoKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLnZhbGlkYXRlLCAodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXAuaW5jbHVkZXModmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxwcm9tID0gdGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSlcbiAgICAgICAgLy8gZXJyb3JzIGFyZSBoYW5kbGVkIGluIHNldHRsaW5nLCBzdHViIHRoaXNcbiAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcblxuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbHByb20pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgc2luZ2xlIGF0dHJpYnV0ZSB3aXRoIGFsbCB0aGUgZGVmaW5lZCBidWlsdC1pbiB2YWxpZGF0b3JzIGFuZCBjdXN0b20gdmFsaWRhdG9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnl0aGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93TnVsbCBXaGV0aGVyIG9yIG5vdCB0aGUgc2NoZW1hIGFsbG93cyBudWxsIHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlLCB3aWxsIGFsd2F5cyByZXNvbHZlLCBhdXRvIHBvcHVsYXRlcyBlcnJvciBvbiB0aGlzLmVycm9yIGxvY2FsIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIF9zaW5nbGVBdHRyVmFsaWRhdGUodmFsdWUsIGZpZWxkLCBhbGxvd051bGwpIHtcbiAgICAvLyBJZiB2YWx1ZSBpcyBudWxsIGFuZCBhbGxvd051bGwgaXMgZmFsc2UsIG5vIHZhbGlkYXRvcnMgc2hvdWxkIHJ1biAoc2VlICM5MTQzKVxuICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgJiYgIWFsbG93TnVsbCkge1xuICAgICAgLy8gVGhlIHNjaGVtYSB2YWxpZGF0b3IgKF92YWxpZGF0ZVNjaGVtYSkgaGFzIGFscmVhZHkgZ2VuZXJhdGVkIHRoZSB2YWxpZGF0aW9uIGVycm9yLiBOb3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvbWlzaWZ5IGVhY2ggdmFsaWRhdG9yXG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgIF8uZm9ySW4odGhpcy5tb2RlbEluc3RhbmNlLnZhbGlkYXRvcnNbZmllbGRdLCAodGVzdCwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuXG4gICAgICBpZiAodmFsaWRhdG9yVHlwZSA9PT0gJ2lzVXJsJyB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNVUkwnIHx8IHZhbGlkYXRvclR5cGUgPT09ICdpc0VtYWlsJykge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBiYWNrd2FyZHMgY29tcGF0LiBWYWxpZGF0b3IuanMgbm93IGV4cGVjdHMgdGhlIHNlY29uZCBwYXJhbSB0byBpc1VSTCBhbmQgaXNFbWFpbCB0byBiZSBhbiBvYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnb2JqZWN0JyAmJiB0ZXN0ICE9PSBudWxsICYmIHRlc3QubXNnKSB7XG4gICAgICAgICAgdGVzdCA9IHtcbiAgICAgICAgICAgIG1zZzogdGVzdC5tc2dcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRlc3QgPT09IHRydWUpIHtcbiAgICAgICAgICB0ZXN0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3VzdG9tIHZhbGlkYXRvcnMgc2hvdWxkIGFsd2F5cyBydW4sIGV4Y2VwdCBpZiB2YWx1ZSBpcyBudWxsIGFuZCBhbGxvd051bGwgaXMgZmFsc2UgKHNlZSAjOTE0MylcbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHRlc3QsIHZhbGlkYXRvclR5cGUsIHRydWUsIHZhbHVlLCBmaWVsZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHZhbHVlIGlzIG51bGwsIGJ1aWx0LWluIHZhbGlkYXRvcnMgc2hvdWxkIG5vdCBydW4gKG9ubHkgY3VzdG9tIHZhbGlkYXRvcnMgaGF2ZSB0byBydW4pIChzZWUgIzkxMzQpLlxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWxpZGF0b3JQcm9taXNlID0gdGhpcy5faW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpO1xuICAgICAgLy8gZXJyb3JzIGFyZSBoYW5kbGVkIGluIHNldHRsaW5nLCBzdHViIHRoaXNcbiAgICAgIHZhbGlkYXRvclByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvclByb21pc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2VcbiAgICAgIC5hbGwodmFsaWRhdG9ycy5tYXAodmFsaWRhdG9yID0+IHZhbGlkYXRvci5jYXRjaChyZWplY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBpc0J1aWx0SW4gPSAhIXJlamVjdGlvbi52YWxpZGF0b3JOYW1lO1xuICAgICAgICB0aGlzLl9wdXNoRXJyb3IoaXNCdWlsdEluLCBmaWVsZCwgcmVqZWN0aW9uLCB2YWx1ZSwgcmVqZWN0aW9uLnZhbGlkYXRvck5hbWUsIHJlamVjdGlvbi52YWxpZGF0b3JBcmdzKTtcbiAgICAgIH0pKSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbmQgaW52b2tlIGEgY3VzdG9tIHZhbGlkYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsaWRhdG9yIFRoZSBjdXN0b20gdmFsaWRhdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yVHlwZSB0aGUgY3VzdG9tIHZhbGlkYXRvciB0eXBlIChuYW1lKS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRBdHRyRGVmaW5lZCBTZXQgdG8gdHJ1ZSBpZiBjdXN0b20gdmFsaWRhdG9yIHdhcyBkZWZpbmVkIGZyb20gdGhlIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0geyp9IG9wdFZhbHVlIHZhbHVlIGZvciBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdEZpZWxkIGZpZWxkIGZvciBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZS5cbiAgICovXG4gIGFzeW5jIF9pbnZva2VDdXN0b21WYWxpZGF0b3IodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlLCBvcHRBdHRyRGVmaW5lZCwgb3B0VmFsdWUsIG9wdEZpZWxkKSB7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcblxuICAgIGNvbnN0IHZhbGlkYXRvckFyaXR5ID0gdmFsaWRhdG9yLmxlbmd0aDtcbiAgICAvLyBjaGVjayBpZiB2YWxpZGF0b3IgaXMgYXN5bmMgYW5kIHJlcXVpcmVzIGEgY2FsbGJhY2tcbiAgICBsZXQgYXN5bmNBcml0eSA9IDE7XG4gICAgbGV0IGVycm9yS2V5ID0gdmFsaWRhdG9yVHlwZTtcbiAgICBsZXQgaW52b2tlQXJncztcbiAgICBpZiAob3B0QXR0ckRlZmluZWQpIHtcbiAgICAgIGFzeW5jQXJpdHkgPSAyO1xuICAgICAgaW52b2tlQXJncyA9IG9wdFZhbHVlO1xuICAgICAgZXJyb3JLZXkgPSBvcHRGaWVsZDtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRvckFyaXR5ID09PSBhc3luY0FyaXR5KSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdEF0dHJEZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSh2YWxpZGF0b3IuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UsIGludm9rZUFyZ3MpKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkodmFsaWRhdG9yLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlKSkoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHZhbGlkYXRvci5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZSwgaW52b2tlQXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbmQgaW52b2tlIGEgYnVpbGQtaW4gdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueXRoaW5nLlxuICAgKiBAcGFyYW0geyp9IHRlc3QgVGhlIHRlc3QgY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclR5cGUgT25lIG9mIGtub3duIHRvIFNlcXVlbGl6ZSB2YWxpZGF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIHRoYXQgaXMgYmVpbmcgdmFsaWRhdGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHNwZWNpZmljIGtleXMgdG8gaW52b2tlIHRoZSB2YWxpZGF0b3IuXG4gICAqL1xuICBhc3luYyBfaW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcbiAgICAvLyBDYXN0IHZhbHVlIGFzIHN0cmluZyB0byBwYXNzIG5ldyBWYWxpZGF0b3IuanMgc3RyaW5nIHJlcXVpcmVtZW50XG4gICAgY29uc3QgdmFsdWVTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuICAgIC8vIGNoZWNrIGlmIFZhbGlkYXRvciBrbm93cyB0aGF0IGtpbmQgb2YgdmFsaWRhdGlvbiB0ZXN0XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3JbdmFsaWRhdG9yVHlwZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb246ICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0b3JBcmdzID0gdGhpcy5fZXh0cmFjdFZhbGlkYXRvckFyZ3ModGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpO1xuXG4gICAgaWYgKCF2YWxpZGF0b3JbdmFsaWRhdG9yVHlwZV0odmFsdWVTdHJpbmcsIC4uLnZhbGlkYXRvckFyZ3MpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0ZXN0Lm1zZyB8fCBgVmFsaWRhdGlvbiAke3ZhbGlkYXRvclR5cGV9IG9uICR7ZmllbGR9IGZhaWxlZGApLCB7IHZhbGlkYXRvck5hbWU6IHZhbGlkYXRvclR5cGUsIHZhbGlkYXRvckFyZ3MgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgZXh0cmFjdCBhcmd1bWVudHMgZm9yIHRoZSB2YWxpZGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdGVzdCBUaGUgdGVzdCBjYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yVHlwZSBPbmUgb2Yga25vd24gdG8gU2VxdWVsaXplIHZhbGlkYXRvcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZXh0cmFjdFZhbGlkYXRvckFyZ3ModGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcbiAgICBsZXQgdmFsaWRhdG9yQXJncyA9IHRlc3QuYXJncyB8fCB0ZXN0O1xuICAgIGNvbnN0IGlzTG9jYWxpemVkVmFsaWRhdG9yID0gdHlwZW9mIHZhbGlkYXRvckFyZ3MgIT09ICdzdHJpbmcnICYmICh2YWxpZGF0b3JUeXBlID09PSAnaXNBbHBoYScgfHwgdmFsaWRhdG9yVHlwZSA9PT0gJ2lzQWxwaGFudW1lcmljJyB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNNb2JpbGVQaG9uZScpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkYXRvckFyZ3MpKSB7XG4gICAgICBpZiAodmFsaWRhdG9yVHlwZSA9PT0gJ2lzSW1tdXRhYmxlJykge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW3ZhbGlkYXRvckFyZ3MsIGZpZWxkLCB0aGlzLm1vZGVsSW5zdGFuY2VdO1xuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsaXplZFZhbGlkYXRvciB8fCB2YWxpZGF0b3JUeXBlID09PSAnaXNJUCcpIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFt2YWxpZGF0b3JBcmdzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdG9yQXJncyA9IHZhbGlkYXRvckFyZ3Muc2xpY2UoMCk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0b3JBcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgdmFsaWRhdGUgYSBzaW5nbGUgZmllbGQgYWdhaW5zdCBpdHMgc2NoZW1hIGRlZmluaXRpb24gKGlzbnVsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByYXdBdHRyaWJ1dGUgQXMgZGVmaW5lZCBpbiB0aGUgU2NoZW1hLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgYW55dGhpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAocmF3QXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICBjb25zdCBhc3NvY2lhdGlvbiA9IE9iamVjdC52YWx1ZXModGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9ucykuZmluZChhc3NvY2lhdGlvbiA9PiBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyAmJiBhc3NvY2lhdGlvbi5mb3JlaWduS2V5ID09PSByYXdBdHRyaWJ1dGUuZmllbGROYW1lKTtcbiAgICAgIGlmICghYXNzb2NpYXRpb24gfHwgIXRoaXMubW9kZWxJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3NvcikpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzW2ZpZWxkXTtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gXy5nZXQodmFsaWRhdG9ycywgJ25vdE51bGwubXNnJywgYCR7dGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9LiR7ZmllbGR9IGNhbm5vdCBiZSBudWxsYCk7XG5cbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICBlcnJNc2csXG4gICAgICAgICAgJ25vdE51bGwgVmlvbGF0aW9uJywgLy8gc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbS5PcmlnaW5zLkNPUkUsXG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy5tb2RlbEluc3RhbmNlLFxuICAgICAgICAgICdpc19udWxsJ1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuU1RSSU5HIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlRFWFQgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQ0lURVhUKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXy5pc09iamVjdCh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgJiYgIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShcbiAgICAgICAgICBgJHtmaWVsZH0gY2Fubm90IGJlIGFuIGFycmF5IG9yIGFuIG9iamVjdGAsXG4gICAgICAgICAgJ3N0cmluZyB2aW9sYXRpb24nLCAvLyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuQ09SRSxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0aGlzLm1vZGVsSW5zdGFuY2UsXG4gICAgICAgICAgJ25vdF9hX3N0cmluZydcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGFsbCBlcnJvcnMgcmV0YWluaW5nIHRoZSBvcmlnaW5hbC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBpc0J1aWx0aW4gICAtIERldGVybWluZXMgaWYgZXJyb3IgaXMgZnJvbSBidWlsdGluIHZhbGlkYXRvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBlcnJvcktleSAgICAtIG5hbWUgb2YgaW52YWxpZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7RXJyb3J8c3RyaW5nfSAgcmF3RXJyb3IgICAgLSBUaGUgb3JpZ2luYWwgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgICAgICAgLSBUaGUgZGF0YSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgZm5OYW1lICAgICAgLSBOYW1lIG9mIHRoZSB2YWxpZGF0b3IsIGlmIGFueVxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIGZuQXJncyAgICAgIC0gQXJndW1lbnRzIGZvciB0aGUgdmFsaWRhdG9yIFtmdW5jdGlvbl0sIGlmIGFueVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3B1c2hFcnJvcihpc0J1aWx0aW4sIGVycm9yS2V5LCByYXdFcnJvciwgdmFsdWUsIGZuTmFtZSwgZm5BcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHJhd0Vycm9yLm1lc3NhZ2UgfHwgcmF3RXJyb3IgfHwgJ1ZhbGlkYXRpb24gZXJyb3InO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oXG4gICAgICBtZXNzYWdlLFxuICAgICAgJ1ZhbGlkYXRpb24gZXJyb3InLCAvLyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLk9yaWdpbnMuRlVOQ1RJT04sXG4gICAgICBlcnJvcktleSxcbiAgICAgIHZhbHVlLFxuICAgICAgdGhpcy5tb2RlbEluc3RhbmNlLFxuICAgICAgZm5OYW1lLFxuICAgICAgaXNCdWlsdGluID8gZm5OYW1lIDogdW5kZWZpbmVkLFxuICAgICAgaXNCdWlsdGluID8gZm5BcmdzIDogdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIGVycm9yW0luc3RhbmNlVmFsaWRhdG9yLlJBV19LRVlfTkFNRV0gPSByYXdFcnJvcjtcblxuICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG4vKipcbiAqIFRoZSBlcnJvciBrZXkgZm9yIGFyZ3VtZW50cyBhcyBwYXNzZWQgYnkgY3VzdG9tIHZhbGlkYXRvcnNcbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FID0gJ29yaWdpbmFsJztcblxubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbm1vZHVsZS5leHBvcnRzLkluc3RhbmNlVmFsaWRhdG9yID0gSW5zdGFuY2VWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSW5zdGFuY2VWYWxpZGF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRvcG9zb3J0ID0gcmVxdWlyZSgndG9wb3NvcnQtY2xhc3MnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY2xhc3MgTW9kZWxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgfVxuXG4gIGFkZE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbHMucHVzaChtb2RlbCk7XG4gICAgdGhpcy5zZXF1ZWxpemUubW9kZWxzW21vZGVsLm5hbWVdID0gbW9kZWw7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICByZW1vdmVNb2RlbChtb2RlbFRvUmVtb3ZlKSB7XG4gICAgdGhpcy5tb2RlbHMgPSB0aGlzLm1vZGVscy5maWx0ZXIobW9kZWwgPT4gbW9kZWwubmFtZSAhPT0gbW9kZWxUb1JlbW92ZS5uYW1lKTtcblxuICAgIGRlbGV0ZSB0aGlzLnNlcXVlbGl6ZS5tb2RlbHNbbW9kZWxUb1JlbW92ZS5uYW1lXTtcbiAgfVxuXG4gIGdldE1vZGVsKGFnYWluc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgICBhdHRyaWJ1dGU6ICduYW1lJ1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbmQobW9kZWwgPT4gbW9kZWxbb3B0aW9ucy5hdHRyaWJ1dGVdID09PSBhZ2FpbnN0KTtcbiAgfVxuXG4gIGdldCBhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBNb2RlbHMgaW4gYW4gb3JkZXIgc3VpdGFibGUgZm9yIGUuZy4gY3JlYXRpbmcgdGFibGVzLlxuICAgKiBXaWxsIHRha2UgZm9yZWlnbiBrZXkgY29uc3RyYWludHMgaW50byBhY2NvdW50IHNvIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSB2aXNpdGVkIGJlZm9yZSBkZXBlbmRlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvciBtZXRob2QgdG8gZXhlY3V0ZSBvbiBlYWNoIG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9yRWFjaE1vZGVsKGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWxzID0ge307XG4gICAgY29uc3Qgc29ydGVyID0gbmV3IFRvcG9zb3J0KCk7XG4gICAgbGV0IHNvcnRlZDtcbiAgICBsZXQgZGVwO1xuXG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVscykge1xuICAgICAgbGV0IGRlcHMgPSBbXTtcbiAgICAgIGxldCB0YWJsZU5hbWUgPSBtb2RlbC5nZXRUYWJsZU5hbWUoKTtcblxuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSBgJHt0YWJsZU5hbWUuc2NoZW1hfS4ke3RhYmxlTmFtZS50YWJsZU5hbWV9YDtcbiAgICAgIH1cblxuICAgICAgbW9kZWxzW3RhYmxlTmFtZV0gPSBtb2RlbDtcblxuICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kZWwucmF3QXR0cmlidXRlcywgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyTmFtZV07XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGRlcCA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsO1xuXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChkZXApKSB7XG4gICAgICAgICAgICAgIGRlcCA9IGAke2RlcC5zY2hlbWF9LiR7ZGVwLnRhYmxlTmFtZX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVwcyA9IGRlcHMuZmlsdGVyKGRlcCA9PiB0YWJsZU5hbWUgIT09IGRlcCk7XG5cbiAgICAgIHNvcnRlci5hZGQodGFibGVOYW1lLCBkZXBzKTtcbiAgICB9XG5cbiAgICBzb3J0ZWQgPSBzb3J0ZXIuc29ydCgpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHNvcnRlZCA9IHNvcnRlZC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWQpIHtcbiAgICAgIGl0ZXJhdG9yKG1vZGVsc1tuYW1lXSwgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWxNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuTW9kZWxNYW5hZ2VyID0gTW9kZWxNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IE1vZGVsTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBEb3R0aWUgPSByZXF1aXJlKCdkb3R0aWUnKTtcblxuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi91dGlscy9sb2dnZXInKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8nKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnknKTtcbmNvbnN0IEluc3RhbmNlVmFsaWRhdG9yID0gcmVxdWlyZSgnLi9pbnN0YW5jZS12YWxpZGF0b3InKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKCcuL3F1ZXJ5LXR5cGVzJyk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9iYXNlJyk7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZSgnLi9hc3NvY2lhdGlvbnMvaGFzLW1hbnknKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuY29uc3QgSG9va3MgPSByZXF1aXJlKCcuL2hvb2tzJyk7XG5jb25zdCBhc3NvY2lhdGlvbnNNaXhpbiA9IHJlcXVpcmUoJy4vYXNzb2NpYXRpb25zL21peGluJyk7XG5jb25zdCBPcCA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzJyk7XG5jb25zdCB7IG5vRG91YmxlTmVzdGVkR3JvdXAgfSA9IHJlcXVpcmUoJy4vdXRpbHMvZGVwcmVjYXRpb25zJyk7XG5cblxuLy8gVGhpcyBsaXN0IHdpbGwgcXVpY2tseSBiZWNvbWUgZGF0ZWQsIGJ1dCBmYWlsaW5nIHRvIG1haW50YWluIHRoaXMgbGlzdCBqdXN0IG1lYW5zXG4vLyB3ZSB3b24ndCB0aHJvdyBhIHdhcm5pbmcgd2hlbiB3ZSBzaG91bGQuIEF0IGxlYXN0IG1vc3QgY29tbW9uIGNhc2VzIHdpbGwgZm9yZXZlciBiZSBjb3ZlcmVkXG4vLyBzbyB3ZSBzdG9wIHRocm93aW5nIGVycm9uZW91cyB3YXJuaW5ncyB3aGVuIHdlIHNob3VsZG4ndC5cbmNvbnN0IHZhbGlkUXVlcnlLZXl3b3JkcyA9IG5ldyBTZXQoWyd3aGVyZScsICdhdHRyaWJ1dGVzJywgJ3BhcmFub2lkJywgJ2luY2x1ZGUnLCAnb3JkZXInLCAnbGltaXQnLCAnb2Zmc2V0JyxcbiAgJ3RyYW5zYWN0aW9uJywgJ2xvY2snLCAncmF3JywgJ2xvZ2dpbmcnLCAnYmVuY2htYXJrJywgJ2hhdmluZycsICdzZWFyY2hQYXRoJywgJ3JlamVjdE9uRW1wdHknLCAncGxhaW4nLFxuICAnc2NvcGUnLCAnZ3JvdXAnLCAndGhyb3VnaCcsICdkZWZhdWx0cycsICdkaXN0aW5jdCcsICdwcmltYXJ5JywgJ2V4Y2VwdGlvbicsICd0eXBlJywgJ2hvb2tzJywgJ2ZvcmNlJyxcbiAgJ25hbWUnXSk7XG5cbi8vIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBub3QgYmUgaW1wbGljaXRseSBwYXNzZWQgaW50byBzdWJxdWVyaWVzL2luY2x1ZGVzLlxuY29uc3Qgbm9uQ2FzY2FkaW5nT3B0aW9ucyA9IFsnaW5jbHVkZScsICdhdHRyaWJ1dGVzJywgJ29yaWdpbmFsQXR0cmlidXRlcycsICdvcmRlcicsICd3aGVyZScsICdsaW1pdCcsICdvZmZzZXQnLCAncGxhaW4nLCAnZ3JvdXAnLCAnaGF2aW5nJ107XG5cbi8qKlxuICogQSBNb2RlbCByZXByZXNlbnRzIGEgdGFibGUgaW4gdGhlIGRhdGFiYXNlLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBkYXRhYmFzZSByb3cuXG4gKlxuICogTW9kZWwgaW5zdGFuY2VzIG9wZXJhdGUgd2l0aCB0aGUgY29uY2VwdCBvZiBhIGBkYXRhVmFsdWVzYCBwcm9wZXJ0eSwgd2hpY2ggc3RvcmVzIHRoZSBhY3R1YWwgdmFsdWVzIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnN0YW5jZS5cbiAqIEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZXMgZnJvbSBkYXRhVmFsdWVzIGNhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gdGhlIEluc3RhbmNlLCB0aGF0IGlzOlxuICogYGBganNcbiAqIGluc3RhbmNlLmZpZWxkXG4gKiAvLyBpcyB0aGUgc2FtZSBhc1xuICogaW5zdGFuY2UuZ2V0KCdmaWVsZCcpXG4gKiAvLyBpcyB0aGUgc2FtZSBhc1xuICogaW5zdGFuY2UuZ2V0RGF0YVZhbHVlKCdmaWVsZCcpXG4gKiBgYGBcbiAqIEhvd2V2ZXIsIGlmIGdldHRlcnMgYW5kL29yIHNldHRlcnMgYXJlIGRlZmluZWQgZm9yIGBmaWVsZGAgdGhleSB3aWxsIGJlIGludm9rZWQsIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZSB2YWx1ZSBmcm9tIGBkYXRhVmFsdWVzYC5cbiAqIEFjY2Vzc2luZyBwcm9wZXJ0aWVzIGRpcmVjdGx5IG9yIHVzaW5nIGBnZXRgIGlzIHByZWZlcnJlZCBmb3IgcmVndWxhciB1c2UsIGBnZXREYXRhVmFsdWVgIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGN1c3RvbSBnZXR0ZXJzLlxuICpcbiAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZSNkZWZpbmV9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGdldHRlcnMgYW5kIHNldHRlcnNcbiAqIEBtaXhlcyBIb29rc1xuICovXG5jbGFzcyBNb2RlbCB7XG4gIHN0YXRpYyBnZXQgcXVlcnlJbnRlcmZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHF1ZXJ5R2VuZXJhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnF1ZXJ5R2VuZXJhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBzZXF1ZWxpemUgaW5zdGFuY2VcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplfVxuICAgKlxuICAgKiBAcHJvcGVydHkgc2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXF1ZWxpemV9XG4gICAqL1xuICBnZXQgc2VxdWVsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNlcXVlbGl6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBuZXcgbW9kZWwgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW3ZhbHVlcz17fV0gYW4gb2JqZWN0IG9mIGtleSB2YWx1ZSBwYWlyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRpb25zXSBpbnN0YW5jZSBjb25zdHJ1Y3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIHZhbHVlcyB3aWxsIGlnbm9yZSBmaWVsZCBhbmQgdmlydHVhbCBzZXR0ZXJzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzTmV3UmVjb3JkPXRydWVdIElzIHRoaXMgYSBuZXcgcmVjb3JkXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMuaW5jbHVkZV0gYW4gYXJyYXkgb2YgaW5jbHVkZSBvcHRpb25zIC0gVXNlZCB0byBidWlsZCBwcmVmZXRjaGVkL2luY2x1ZGVkIG1vZGVsIGluc3RhbmNlcy4gU2VlIGBzZXRgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0cnVlLFxuICAgICAgX3NjaGVtYTogdGhpcy5jb25zdHJ1Y3Rvci5fc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogdGhpcy5jb25zdHJ1Y3Rvci5fc2NoZW1hRGVsaW1pdGVyLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKGF0dHJpYnV0ZSA9PiBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZSkgPyBhdHRyaWJ1dGVbMV0gOiBhdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGFWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaW5zdGFuY2UgaGFzIG5vdCB5ZXQgYmVlbiBwZXJzaXN0ZWQgdG8gdGhlIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNOZXdSZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzTmV3UmVjb3JkID0gb3B0aW9ucy5pc05ld1JlY29yZDtcblxuICAgIHRoaXMuX2luaXRWYWx1ZXModmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIF9pbml0VmFsdWVzKHZhbHVlcywgb3B0aW9ucykge1xuICAgIGxldCBkZWZhdWx0cztcbiAgICBsZXQga2V5O1xuXG4gICAgdmFsdWVzID0geyAuLi52YWx1ZXMgfTtcblxuICAgIGlmIChvcHRpb25zLmlzTmV3UmVjb3JkKSB7XG4gICAgICBkZWZhdWx0cyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBkZWZhdWx0cyA9IF8ubWFwVmFsdWVzKHRoaXMuY29uc3RydWN0b3IuX2RlZmF1bHRWYWx1ZXMsIHZhbHVlRm4gPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVGbigpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCA/IHZhbHVlIDogXy5jbG9uZURlZXAodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGlkIHRvIG51bGwgaWYgbm90IHBhc3NlZCBhcyB2YWx1ZSwgYSBuZXdseSBjcmVhdGVkIGRhbyBoYXMgbm8gaWRcbiAgICAgIC8vIHJlbW92aW5nIHRoaXMgYnJlYWtzIGJ1bGtDcmVhdGVcbiAgICAgIC8vIGRvIGFmdGVyIGRlZmF1bHQgdmFsdWVzIHNpbmNlIGl0IG1pZ2h0IGhhdmUgVVVJRCBhcyBhIGRlZmF1bHQgdmFsdWVcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmZvckVhY2gocHJpbWFyeUtleUF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmYXVsdHMsIHByaW1hcnlLZXlBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBkZWZhdWx0c1twcmltYXJ5S2V5QXR0cmlidXRlXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgJiYgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdKSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICAgIGRlbGV0ZSBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICAgIH1cblxuICAgICAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKHZhbHVlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNldChrZXksIFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW2tleV0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0KHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMgc2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHRoaXMgbWV0aG9kXG4gIHN0YXRpYyBfcGFyYW5vaWRDbGF1c2UobW9kZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIEFwcGx5IG9uIGVhY2ggaW5jbHVkZVxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgYmVmb3JlIGhhbmRsaW5nIHdoZXJlIGNvbmRpdGlvbnMgYmVjYXVzZSBvZiBsb2dpYyB3aXRoIHJldHVybnNcbiAgICAvLyBvdGhlcndpc2UgdGhpcyBjb2RlIHdpbGwgbmV2ZXIgcnVuIG9uIGluY2x1ZGVzIG9mIGEgYWxyZWFkeSBjb25kaXRpb25hYmxlIHdoZXJlXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9wYXJhbm9pZENsYXVzZShpbmNsdWRlLm1vZGVsLCBpbmNsdWRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhcHBseSBwYXJhbm9pZCB3aGVuIGdyb3VwZWRMaW1pdCBpcyB1c2VkXG4gICAgaWYgKF8uZ2V0KG9wdGlvbnMsICdncm91cGVkTGltaXQub24ub3B0aW9ucy5wYXJhbm9pZCcpKSB7XG4gICAgICBjb25zdCB0aHJvdWdoTW9kZWwgPSBfLmdldChvcHRpb25zLCAnZ3JvdXBlZExpbWl0Lm9uLnRocm91Z2gubW9kZWwnKTtcbiAgICAgIGlmICh0aHJvdWdoTW9kZWwpIHtcbiAgICAgICAgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRocm91Z2hNb2RlbCwgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbC5vcHRpb25zLnRpbWVzdGFtcHMgfHwgIW1vZGVsLm9wdGlvbnMucGFyYW5vaWQgfHwgb3B0aW9ucy5wYXJhbm9pZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIFRoaXMgbW9kZWwgaXMgbm90IHBhcmFub2lkLCBub3RoaW5nIHRvIGRvIGhlcmU7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gbW9kZWwucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdE9iamVjdCA9IHt9O1xuXG4gICAgbGV0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuXG4gICAgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlIHx8IHtcbiAgICAgIFtPcC5lcV06IG51bGxcbiAgICB9O1xuXG4gICAgZGVsZXRlZEF0T2JqZWN0W2RlbGV0ZWRBdEF0dHJpYnV0ZS5maWVsZCB8fCBkZWxldGVkQXRDb2xdID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKFV0aWxzLmlzV2hlcmVFbXB0eShvcHRpb25zLndoZXJlKSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IGRlbGV0ZWRBdE9iamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHsgW09wLmFuZF06IFtkZWxldGVkQXRPYmplY3QsIG9wdGlvbnMud2hlcmVdIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBzdGF0aWMgX2FkZERlZmF1bHRBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRhaWwgPSB7fTtcbiAgICBsZXQgaGVhZCA9IHt9O1xuXG4gICAgLy8gQWRkIGlkIGlmIG5vIHByaW1hcnkga2V5IHdhcyBtYW51YWxseSBhZGRlZCB0byBkZWZpbml0aW9uXG4gICAgLy8gQ2FuJ3QgdXNlIHRoaXMucHJpbWFyeUtleXMgaGVyZSwgc2luY2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYmVmb3JlIFBLcyBhcmUgaWRlbnRpZmllZFxuICAgIGlmICghXy5zb21lKHRoaXMucmF3QXR0cmlidXRlcywgJ3ByaW1hcnlLZXknKSkge1xuICAgICAgaWYgKCdpZCcgaW4gdGhpcy5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBpcyBmaXNoeSBoZXJlIVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgY29sdW1uIGNhbGxlZCAnaWQnIHdhcyBhZGRlZCB0byB0aGUgYXR0cmlidXRlcyBvZiAnJHt0aGlzLnRhYmxlTmFtZX0nIGJ1dCBub3QgbWFya2VkIHdpdGggJ3ByaW1hcnlLZXk6IHRydWUnYCk7XG4gICAgICB9XG5cbiAgICAgIGhlYWQgPSB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgdHlwZTogbmV3IERhdGFUeXBlcy5JTlRFR0VSKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiB0cnVlLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgdGFpbFt0aGlzLl92ZXJzaW9uQXR0cmlidXRlXSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLklOVEVHRVIsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMCxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgbmV3UmF3QXR0cmlidXRlcyA9IHtcbiAgICAgIC4uLmhlYWQsXG4gICAgICAuLi50aGlzLnJhd0F0dHJpYnV0ZXNcbiAgICB9O1xuICAgIF8uZWFjaCh0YWlsLCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgIGlmIChuZXdSYXdBdHRyaWJ1dGVzW2F0dHJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3UmF3QXR0cmlidXRlc1thdHRyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yYXdBdHRyaWJ1dGVzID0gbmV3UmF3QXR0cmlidXRlcztcblxuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5wcmltYXJ5S2V5cykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnByaW1hcnlLZXlzLmlkID0gdGhpcy5yYXdBdHRyaWJ1dGVzLmlkO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfZmluZEF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUoKSB7XG4gICAgdGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlID0gbnVsbDtcblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yYXdBdHRyaWJ1dGVzLCBuYW1lKSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdGFuY2UgZGVmaW5pdGlvbi4gT25seSBvbmUgYXV0b2luY3JlbWVudCBmaWVsZCBhbGxvd2VkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgc2VsZikge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlKSByZXR1cm47XG5cbiAgICAvLyBpZiBpbmNsdWRlIGlzIG5vdCBhbiBhcnJheSwgd3JhcCBpbiBhbiBhcnJheVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGUpKSB7XG4gICAgICBvcHRpb25zLmluY2x1ZGUgPSBbb3B0aW9ucy5pbmNsdWRlXTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5pbmNsdWRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYWxsIGluY2x1ZGVkIGVsZW1lbnRzIHRvIHsgbW9kZWw6IE1vZGVsIH0gZm9ybVxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZS5tYXAoaW5jbHVkZSA9PiB0aGlzLl9jb25mb3JtSW5jbHVkZShpbmNsdWRlLCBzZWxmKSk7XG4gIH1cblxuICBzdGF0aWMgX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUsIHNlbGYpIHtcbiAgICBpZiAoc2VsZiAmJiB0eXBlb2YgaW5jbHVkZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuYXNzb2NpYXRpb25zLCBpbmNsdWRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc29jaWF0aW9uIHdpdGggYWxpYXMgXCIke2luY2x1ZGV9XCIgZG9lcyBub3QgZXhpc3Qgb24gJHtzZWxmLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5hc3NvY2lhdGlvbnNbaW5jbHVkZV07XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlO1xuICB9XG5cbiAgc3RhdGljIF9jb25mb3JtSW5jbHVkZShpbmNsdWRlLCBzZWxmKSB7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGxldCBtb2RlbDtcblxuICAgICAgaWYgKGluY2x1ZGUuX3BzZXVkbykgcmV0dXJuIGluY2x1ZGU7XG5cbiAgICAgIGluY2x1ZGUgPSB0aGlzLl90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLCBzZWxmKTtcblxuICAgICAgaWYgKGluY2x1ZGUgaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICBpZiAoc2VsZiAmJiBpbmNsdWRlLnRhcmdldC5uYW1lID09PSBzZWxmLm5hbWUpIHtcbiAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUuc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS50YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBtb2RlbCwgYXNzb2NpYXRpb246IGluY2x1ZGUsIGFzOiBpbmNsdWRlLmFzIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlLnByb3RvdHlwZSAmJiBpbmNsdWRlLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGVsOiBpbmNsdWRlIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaW5jbHVkZSkpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgICBpbmNsdWRlLmFzc29jaWF0aW9uID0gdGhpcy5fdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZS5hc3NvY2lhdGlvbiwgc2VsZik7XG5cbiAgICAgICAgICBpZiAoc2VsZiAmJiBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSBzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlLm1vZGVsKSBpbmNsdWRlLm1vZGVsID0gbW9kZWw7XG4gICAgICAgICAgaWYgKCFpbmNsdWRlLmFzKSBpbmNsdWRlLmFzID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5hcztcblxuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlLCBtb2RlbCk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZS5tb2RlbCkge1xuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNsdWRlLmFsbCkge1xuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW5jbHVkZSB1bmV4cGVjdGVkLiBFbGVtZW50IGhhcyB0byBiZSBlaXRoZXIgYSBNb2RlbCwgYW4gQXNzb2NpYXRpb24gb3IgYW4gb2JqZWN0LicpO1xuICB9XG5cbiAgc3RhdGljIF9leHBhbmRJbmNsdWRlQWxsRWxlbWVudChpbmNsdWRlcywgaW5jbHVkZSkge1xuICAgIC8vIGNoZWNrICdhbGwnIGF0dHJpYnV0ZSBwcm92aWRlZCBpcyB2YWxpZFxuICAgIGxldCBhbGwgPSBpbmNsdWRlLmFsbDtcbiAgICBkZWxldGUgaW5jbHVkZS5hbGw7XG5cbiAgICBpZiAoYWxsICE9PSB0cnVlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsKSkge1xuICAgICAgICBhbGwgPSBbYWxsXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRUeXBlcyA9IHtcbiAgICAgICAgQmVsb25nc1RvOiB0cnVlLFxuICAgICAgICBIYXNPbmU6IHRydWUsXG4gICAgICAgIEhhc01hbnk6IHRydWUsXG4gICAgICAgIE9uZTogWydCZWxvbmdzVG8nLCAnSGFzT25lJ10sXG4gICAgICAgIEhhczogWydIYXNPbmUnLCAnSGFzTWFueSddLFxuICAgICAgICBNYW55OiBbJ0hhc01hbnknXVxuICAgICAgfTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGFsbFtpXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBbGwnKSB7XG4gICAgICAgICAgYWxsID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGVzID0gdmFsaWRUeXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlcykge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYGluY2x1ZGUgYWxsICcke3R5cGV9JyBpcyBub3QgdmFsaWQgLSBtdXN0IGJlIEJlbG9uZ3NUbywgSGFzT25lLCBIYXNNYW55LCBPbmUsIEhhcywgTWFueSBvciBBbGxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHJlcGxhY2UgdHlwZSBwbGFjZWhvbGRlciBlLmcuICdPbmUnIHdpdGggaXRzIGNvbnN0aXR1ZW50IHR5cGVzIGUuZy4gJ0hhc09uZScsICdCZWxvbmdzVG8nXG4gICAgICAgICAgYWxsLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0eXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFhbGwuaW5jbHVkZXModHlwZXNbal0pKSB7XG4gICAgICAgICAgICAgIGFsbC51bnNoaWZ0KHR5cGVzW2pdKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBhbGwgYXNzb2NpYXRpb25zIG9mIHR5cGVzIHNwZWNpZmllZCB0byBpbmNsdWRlc1xuICAgIGNvbnN0IG5lc3RlZCA9IGluY2x1ZGUubmVzdGVkO1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIGRlbGV0ZSBpbmNsdWRlLm5lc3RlZDtcblxuICAgICAgaWYgKCFpbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgaW5jbHVkZS5pbmNsdWRlID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGluY2x1ZGUuaW5jbHVkZSkpIHtcbiAgICAgICAgaW5jbHVkZS5pbmNsdWRlID0gW2luY2x1ZGUuaW5jbHVkZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdXNlZCA9IFtdO1xuICAgIChmdW5jdGlvbiBhZGRBbGxJbmNsdWRlcyhwYXJlbnQsIGluY2x1ZGVzKSB7XG4gICAgICBfLmZvckVhY2gocGFyZW50LmFzc29jaWF0aW9ucywgYXNzb2NpYXRpb24gPT4ge1xuICAgICAgICBpZiAoYWxsICE9PSB0cnVlICYmICFhbGwuaW5jbHVkZXMoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIG1vZGVsIGFscmVhZHkgaW5jbHVkZWQsIGFuZCBza2lwIGlmIHNvXG4gICAgICAgIGNvbnN0IG1vZGVsID0gYXNzb2NpYXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBhcyA9IGFzc29jaWF0aW9uLm9wdGlvbnMuYXM7XG5cbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0geyBtb2RlbCB9O1xuICAgICAgICBpZiAoYXMpIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IGFkZCAnYXMnIHRvIHRoZSBwcmVkaWNhdGUgaWYgaXQgYWN0dWFsbHkgZXhpc3RzXG4gICAgICAgICAgcHJlZGljYXRlLmFzID0gYXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zb21lKGluY2x1ZGVzLCBwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBpZiByZWN1cnNpbmcgb3ZlciBhIG1vZGVsIGFscmVhZHkgbmVzdGVkXG4gICAgICAgIGlmIChuZXN0ZWQgJiYgdXNlZC5pbmNsdWRlcyhtb2RlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXNlZC5wdXNoKHBhcmVudCk7XG5cbiAgICAgICAgLy8gaW5jbHVkZSB0aGlzIG1vZGVsXG4gICAgICAgIGNvbnN0IHRoaXNJbmNsdWRlID0gVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpO1xuICAgICAgICB0aGlzSW5jbHVkZS5tb2RlbCA9IG1vZGVsO1xuICAgICAgICBpZiAoYXMpIHtcbiAgICAgICAgICB0aGlzSW5jbHVkZS5hcyA9IGFzO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVzLnB1c2godGhpc0luY2x1ZGUpO1xuXG4gICAgICAgIC8vIHJ1biByZWN1cnNpdmVseSBpZiBuZXN0ZWRcbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgIGFkZEFsbEluY2x1ZGVzKG1vZGVsLCB0aGlzSW5jbHVkZS5pbmNsdWRlKTtcbiAgICAgICAgICBpZiAodGhpc0luY2x1ZGUuaW5jbHVkZS5sZW5ndGggPT09IDApIGRlbGV0ZSB0aGlzSW5jbHVkZS5pbmNsdWRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVzZWQucG9wKCk7XG4gICAgfSkodGhpcywgaW5jbHVkZXMpO1xuICB9XG5cbiAgc3RhdGljIF92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucywgdGFibGVOYW1lcykge1xuICAgIGlmICghb3B0aW9ucy5tb2RlbCkgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgICB0YWJsZU5hbWVzID0gdGFibGVOYW1lcyB8fCB7fTtcbiAgICBvcHRpb25zLmluY2x1ZGVOYW1lcyA9IFtdO1xuICAgIG9wdGlvbnMuaW5jbHVkZU1hcCA9IHt9O1xuXG4gICAgLyogTGVnYWN5ICovXG4gICAgb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiA9IGZhbHNlO1xuICAgIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvcHRpb25zLnBhcmVudCkge1xuICAgICAgb3B0aW9ucy50b3BNb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgICBvcHRpb25zLnRvcExpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUubWFwKGluY2x1ZGUgPT4ge1xuICAgICAgaW5jbHVkZSA9IHRoaXMuX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUpO1xuICAgICAgaW5jbHVkZS5wYXJlbnQgPSBvcHRpb25zO1xuICAgICAgaW5jbHVkZS50b3BMaW1pdCA9IG9wdGlvbnMudG9wTGltaXQ7XG5cbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50LmNhbGwob3B0aW9ucy5tb2RlbCwgaW5jbHVkZSwgdGFibGVOYW1lcywgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5jbHVkZS5kdXBsaWNhdGluZyA9IGluY2x1ZGUuYXNzb2NpYXRpb24uaXNNdWx0aUFzc29jaWF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nID0gaW5jbHVkZS5oYXNEdXBsaWNhdGluZyB8fCBpbmNsdWRlLmR1cGxpY2F0aW5nO1xuICAgICAgaW5jbHVkZS5oYXNSZXF1aXJlZCA9IGluY2x1ZGUuaGFzUmVxdWlyZWQgfHwgaW5jbHVkZS5yZXF1aXJlZDtcblxuICAgICAgb3B0aW9ucy5oYXNEdXBsaWNhdGluZyA9IG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgfHwgaW5jbHVkZS5oYXNEdXBsaWNhdGluZztcbiAgICAgIG9wdGlvbnMuaGFzUmVxdWlyZWQgPSBvcHRpb25zLmhhc1JlcXVpcmVkIHx8IGluY2x1ZGUucmVxdWlyZWQ7XG5cbiAgICAgIG9wdGlvbnMuaGFzV2hlcmUgPSBvcHRpb25zLmhhc1doZXJlIHx8IGluY2x1ZGUuaGFzV2hlcmUgfHwgISFpbmNsdWRlLndoZXJlO1xuICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBpbmNsdWRlLmhhc1BhcmVudFdoZXJlID0gb3B0aW9ucy5oYXNQYXJlbnRXaGVyZSB8fCAhIW9wdGlvbnMud2hlcmU7XG4gICAgICBpbmNsdWRlLmhhc1BhcmVudFJlcXVpcmVkID0gb3B0aW9ucy5oYXNQYXJlbnRSZXF1aXJlZCB8fCAhIW9wdGlvbnMucmVxdWlyZWQ7XG5cbiAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICE9PSBmYWxzZSAmJiBvcHRpb25zLmhhc0R1cGxpY2F0aW5nICYmIG9wdGlvbnMudG9wTGltaXQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGluY2x1ZGUuaGFzUmVxdWlyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuaGFzUmVxdWlyZWQ7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gaW5jbHVkZS5zdWJRdWVyeTtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5IHx8IGluY2x1ZGUuaGFzUGFyZW50UmVxdWlyZWQgJiYgaW5jbHVkZS5oYXNSZXF1aXJlZCAmJiAhaW5jbHVkZS5zZXBhcmF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmluY2x1ZGVNYXBbaW5jbHVkZS5hc10gPSBpbmNsdWRlO1xuICAgICAgb3B0aW9ucy5pbmNsdWRlTmFtZXMucHVzaChpbmNsdWRlLmFzKTtcblxuICAgICAgLy8gU2V0IHRvcCBsZXZlbCBvcHRpb25zXG4gICAgICBpZiAob3B0aW9ucy50b3BNb2RlbCA9PT0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLnN1YlF1ZXJ5ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50b3BMaW1pdCkge1xuICAgICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSkge1xuICAgICAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUuaGFzRHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBMZWdhY3kgKi9cbiAgICAgIG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlID0gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgaW5jbHVkZS5oYXNJbmNsdWRlV2hlcmUgfHwgISFpbmNsdWRlLndoZXJlO1xuICAgICAgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgPSBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCBpbmNsdWRlLmhhc0luY2x1ZGVSZXF1aXJlZCB8fCAhIWluY2x1ZGUucmVxdWlyZWQ7XG5cbiAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLmlzTXVsdGlBc3NvY2lhdGlvbiB8fCBpbmNsdWRlLmhhc011bHRpQXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24gfHwgaW5jbHVkZS5oYXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50b3BNb2RlbCA9PT0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLnN1YlF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBzdGF0aWMgX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50KGluY2x1ZGUsIHRhYmxlTmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0YWJsZU5hbWVzW2luY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCldID0gdHJ1ZTtcblxuICAgIGlmIChpbmNsdWRlLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMucmF3KSB7XG4gICAgICBpbmNsdWRlLm1vZGVsLl9leHBhbmRBdHRyaWJ1dGVzKGluY2x1ZGUpO1xuXG4gICAgICBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcyA9IGluY2x1ZGUubW9kZWwuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKGluY2x1ZGUuYXR0cmlidXRlcyk7XG5cbiAgICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuXG4gICAgICBpZiAoaW5jbHVkZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBfLmVhY2goaW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5cywgKGF0dHIsIGtleSkgPT4ge1xuICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIHByaW1hcnkga2V5IGlmIGl0J3Mgbm90IGFscmVhZHkgaW5jbHVkZWQgLSB0YWtlIGludG8gYWNjb3VudCB0aGF0IHRoZSBwayBtaWdodCBiZSBhbGlhc2VkIChkdWUgdG8gYSAuZmllbGQgcHJvcClcbiAgICAgICAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcy5zb21lKGluY2x1ZGVBdHRyID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyLmZpZWxkICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5jbHVkZUF0dHIpICYmIGluY2x1ZGVBdHRyWzBdID09PSBhdHRyLmZpZWxkICYmIGluY2x1ZGVBdHRyWzFdID09PSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZUF0dHIgPT09IGtleTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzLnVuc2hpZnQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICB9XG5cbiAgICAvLyBwc2V1ZG8gaW5jbHVkZSBqdXN0IG5lZWRlZCB0aGUgYXR0cmlidXRlIGxvZ2ljLCByZXR1cm5cbiAgICBpZiAoaW5jbHVkZS5fcHNldWRvKSB7XG4gICAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcykge1xuICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbmNsdWRlLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgY3VycmVudCBNb2RlbCBpcyBhY3R1YWxseSBhc3NvY2lhdGVkIHdpdGggdGhlIHBhc3NlZCBNb2RlbCAtIG9yIGl0J3MgYSBwc2V1ZG8gaW5jbHVkZVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbiB8fCB0aGlzLl9nZXRJbmNsdWRlZEFzc29jaWF0aW9uKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUuYXMpO1xuXG4gICAgaW5jbHVkZS5hc3NvY2lhdGlvbiA9IGFzc29jaWF0aW9uO1xuICAgIGluY2x1ZGUuYXMgPSBhc3NvY2lhdGlvbi5hcztcblxuICAgIC8vIElmIHRocm91Z2gsIHdlIGNyZWF0ZSBhIHBzZXVkbyBjaGlsZCBpbmNsdWRlLCB0byBlYXNlIG91ciBwYXJzaW5nIGxhdGVyIG9uXG4gICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaCAmJiBPYmplY3QoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSB7XG4gICAgICBpZiAoIWluY2x1ZGUuaW5jbHVkZSkgaW5jbHVkZS5pbmNsdWRlID0gW107XG4gICAgICBjb25zdCB0aHJvdWdoID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoO1xuXG4gICAgICBpbmNsdWRlLnRocm91Z2ggPSBfLmRlZmF1bHRzKGluY2x1ZGUudGhyb3VnaCB8fCB7fSwge1xuICAgICAgICBtb2RlbDogdGhyb3VnaC5tb2RlbCxcbiAgICAgICAgYXM6IHRocm91Z2gubW9kZWwubmFtZSxcbiAgICAgICAgYXNzb2NpYXRpb246IHtcbiAgICAgICAgICBpc1NpbmdsZUFzc29jaWF0aW9uOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9wc2V1ZG86IHRydWUsXG4gICAgICAgIHBhcmVudDogaW5jbHVkZVxuICAgICAgfSk7XG5cblxuICAgICAgaWYgKHRocm91Z2guc2NvcGUpIHtcbiAgICAgICAgaW5jbHVkZS50aHJvdWdoLndoZXJlID0gaW5jbHVkZS50aHJvdWdoLndoZXJlID8geyBbT3AuYW5kXTogW2luY2x1ZGUudGhyb3VnaC53aGVyZSwgdGhyb3VnaC5zY29wZV0gfSA6IHRocm91Z2guc2NvcGU7XG4gICAgICB9XG5cbiAgICAgIGluY2x1ZGUuaW5jbHVkZS5wdXNoKGluY2x1ZGUudGhyb3VnaCk7XG4gICAgICB0YWJsZU5hbWVzW3Rocm91Z2gudGFibGVOYW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZS5tb2RlbCBtYXkgYmUgdGhlIG1haW4gbW9kZWwsIHdoaWxlIHRoZSBhc3NvY2lhdGlvbiB0YXJnZXQgbWF5IGJlIHNjb3BlZCAtIHRodXMgd2UgbmVlZCB0byBsb29rIGF0IGFzc29jaWF0aW9uLnRhcmdldC9zb3VyY2VcbiAgICBsZXQgbW9kZWw7XG4gICAgaWYgKGluY2x1ZGUubW9kZWwuc2NvcGVkID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiB0aGUgcGFzc2VkIG1vZGVsIGlzIGFscmVhZHkgc2NvcGVkLCBrZWVwIHRoYXRcbiAgICAgIG1vZGVsID0gaW5jbHVkZS5tb2RlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHVzZSB0aGUgbW9kZWwgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgdG8gdGhlIGFzc29jaWF0aW9uXG4gICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IGluY2x1ZGUubW9kZWwubmFtZSA/IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0IDogaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgfVxuXG4gICAgbW9kZWwuX2luamVjdFNjb3BlKGluY2x1ZGUpO1xuXG4gICAgLy8gVGhpcyBjaGVjayBzaG91bGQgaGFwcGVuIGFmdGVyIGluamVjdGluZyB0aGUgc2NvcGUsIHNpbmNlIHRoZSBzY29wZSBtYXkgY29udGFpbiBhIC5hdHRyaWJ1dGVzXG4gICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGluY2x1ZGUuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluY2x1ZGUubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcblxuICAgIGlmIChpbmNsdWRlLnJlcXVpcmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluY2x1ZGUucmVxdWlyZWQgPSAhIWluY2x1ZGUud2hlcmU7XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpIHtcbiAgICAgIGluY2x1ZGUud2hlcmUgPSBpbmNsdWRlLndoZXJlID8geyBbT3AuYW5kXTogW2luY2x1ZGUud2hlcmUsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGVdIH0gOiBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlLmxpbWl0ICYmIGluY2x1ZGUuc2VwYXJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZS5zZXBhcmF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGUuc2VwYXJhdGUgPT09IHRydWUpIHtcbiAgICAgIGlmICghKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBIYXNNYW55KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgSGFzTWFueSBhc3NvY2lhdGlvbnMgc3VwcG9ydCBpbmNsdWRlLnNlcGFyYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGluY2x1ZGUuZHVwbGljYXRpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgICAgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzLmxlbmd0aFxuICAgICAgICAmJiAhXy5mbGF0dGVuRGVwdGgob3B0aW9ucy5hdHRyaWJ1dGVzLCAyKS5pbmNsdWRlcyhhc3NvY2lhdGlvbi5zb3VyY2VLZXkpXG4gICAgICApIHtcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLnB1c2goYXNzb2NpYXRpb24uc291cmNlS2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBpbmNsdWRlLmF0dHJpYnV0ZXNcbiAgICAgICAgJiYgaW5jbHVkZS5hdHRyaWJ1dGVzLmxlbmd0aFxuICAgICAgICAmJiAhXy5mbGF0dGVuRGVwdGgoaW5jbHVkZS5hdHRyaWJ1dGVzLCAyKS5pbmNsdWRlcyhhc3NvY2lhdGlvbi5mb3JlaWduS2V5KVxuICAgICAgKSB7XG4gICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcy5wdXNoKGFzc29jaWF0aW9uLmZvcmVpZ25LZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGNoaWxkIGluY2x1ZGVzXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNsdWRlLCAnaW5jbHVkZScpKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMuY2FsbChpbmNsdWRlLm1vZGVsLCBpbmNsdWRlLCB0YWJsZU5hbWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5jbHVkZTtcbiAgfVxuXG4gIHN0YXRpYyBfZ2V0SW5jbHVkZWRBc3NvY2lhdGlvbih0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXRNb2RlbCk7XG4gICAgbGV0IGFzc29jaWF0aW9uID0gbnVsbDtcbiAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBub3QgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0hYCk7XG4gICAgfVxuICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBhc3NvY2lhdGlvbiA9IHRoaXMuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpO1xuICAgICAgaWYgKGFzc29jaWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRBbGlhcykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0FsaWFzZXMgPSB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXRNb2RlbCkubWFwKGFzc29jaWF0aW9uID0+IGFzc29jaWF0aW9uLmFzKTtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSB1c2luZyBhbiBhbGlhcy4gYCArXG4gICAgICAgICAgYFlvdSd2ZSBpbmNsdWRlZCBhbiBhbGlhcyAoJHt0YXJnZXRBbGlhc30pLCBidXQgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGFsaWFzKGVzKSBkZWZpbmVkIGluIHlvdXIgYXNzb2NpYXRpb24gKCR7ZXhpc3RpbmdBbGlhc2VzLmpvaW4oJywgJyl9KS5gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gdXNpbmcgYW4gYWxpYXMuIGAgK1xuICAgICAgICAnWW91IG11c3QgdXNlIHRoZSBcXCdhc1xcJyBrZXl3b3JkIHRvIHNwZWNpZnkgdGhlIGFsaWFzIHdpdGhpbiB5b3VyIGluY2x1ZGUgc3RhdGVtZW50LicpO1xuICAgIH1cbiAgICBhc3NvY2lhdGlvbiA9IHRoaXMuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpO1xuICAgIGlmICghYXNzb2NpYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gbXVsdGlwbGUgdGltZXMuIGAgK1xuICAgICAgICAnVG8gaWRlbnRpZnkgdGhlIGNvcnJlY3QgYXNzb2NpYXRpb24sIHlvdSBtdXN0IHVzZSB0aGUgXFwnYXNcXCcga2V5d29yZCB0byBzcGVjaWZ5IHRoZSBhbGlhcyBvZiB0aGUgYXNzb2NpYXRpb24geW91IHdhbnQgdG8gaW5jbHVkZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9XG5cblxuICBzdGF0aWMgX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucykge1xuICAgIGNvbnN0IGluY2x1ZGVzID0gb3B0aW9ucy5pbmNsdWRlO1xuICAgIGlmICghaW5jbHVkZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5jbHVkZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpbmNsdWRlID0gaW5jbHVkZXNbaW5kZXhdO1xuXG4gICAgICBpZiAoaW5jbHVkZS5hbGwpIHtcbiAgICAgICAgaW5jbHVkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcblxuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsRWxlbWVudChpbmNsdWRlcywgaW5jbHVkZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5jbHVkZXMuZm9yRWFjaChpbmNsdWRlID0+IHtcbiAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwuY2FsbChpbmNsdWRlLm1vZGVsLCBpbmNsdWRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBfY29uZm9ybUluZGV4KGluZGV4KSB7XG4gICAgaWYgKCFpbmRleC5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcImZpZWxkc1wiIHByb3BlcnR5IGZvciBpbmRleCBkZWZpbml0aW9uJyk7XG4gICAgfVxuXG4gICAgaW5kZXggPSBfLmRlZmF1bHRzKGluZGV4LCB7XG4gICAgICB0eXBlOiAnJyxcbiAgICAgIHBhcnNlcjogbnVsbFxuICAgIH0pO1xuXG4gICAgaWYgKGluZGV4LnR5cGUgJiYgaW5kZXgudHlwZS50b0xvd2VyQ2FzZSgpID09PSAndW5pcXVlJykge1xuICAgICAgaW5kZXgudW5pcXVlID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBpbmRleC50eXBlO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG5cbiAgc3RhdGljIF91bmlxSW5jbHVkZXMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlKSByZXR1cm47XG5cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBfKG9wdGlvbnMuaW5jbHVkZSlcbiAgICAgIC5ncm91cEJ5KGluY2x1ZGUgPT4gYCR7aW5jbHVkZS5tb2RlbCAmJiBpbmNsdWRlLm1vZGVsLm5hbWV9LSR7aW5jbHVkZS5hc31gKVxuICAgICAgLm1hcChpbmNsdWRlcyA9PiB0aGlzLl9hc3NpZ25PcHRpb25zKC4uLmluY2x1ZGVzKSlcbiAgICAgIC52YWx1ZSgpO1xuICB9XG5cbiAgc3RhdGljIF9iYXNlTWVyZ2UoLi4uYXJncykge1xuICAgIF8uYXNzaWduV2l0aCguLi5hcmdzKTtcbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoYXJnc1swXSwgdGhpcyk7XG4gICAgdGhpcy5fdW5pcUluY2x1ZGVzKGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgc3RhdGljIF9tZXJnZUZ1bmN0aW9uKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpICYmIEFycmF5LmlzQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gXy51bmlvbihvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnd2hlcmUnIHx8IGtleSA9PT0gJ2hhdmluZycpIHtcbiAgICAgIGlmIChzcmNWYWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICBzcmNWYWx1ZSA9IHsgW09wLmFuZF06IHNyY1ZhbHVlIH07XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9ialZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdhdHRyaWJ1dGVzJyAmJiBfLmlzUGxhaW5PYmplY3Qob2JqVmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBfLmFzc2lnbldpdGgob2JqVmFsdWUsIHNyY1ZhbHVlLCAob2JqVmFsdWUsIHNyY1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBfLnVuaW9uKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIGEgcG9zc2libGUgb2JqZWN0L2FycmF5IHRvIGNsb25lLCB3ZSB0cnkgaXQuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlIHdoZW4gaXQncyBub3QgdW5kZWZpbmVkLFxuICAgIC8vIG9yIHRoZSByZXN1bHRpbmcgb2JqZWN0IGluIHRoYXQgY2FzZS5cbiAgICBpZiAoc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGlscy5jbG9uZURlZXAoc3JjVmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3JjVmFsdWUgPT09IHVuZGVmaW5lZCA/IG9ialZhbHVlIDogc3JjVmFsdWU7XG4gIH1cblxuICBzdGF0aWMgX2Fzc2lnbk9wdGlvbnMoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9iYXNlTWVyZ2UoLi4uYXJncywgdGhpcy5fbWVyZ2VGdW5jdGlvbik7XG4gIH1cblxuICBzdGF0aWMgX2RlZmF1bHRzT3B0aW9ucyh0YXJnZXQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZU1lcmdlKHRhcmdldCwgb3B0cywgKHNyY1ZhbHVlLCBvYmpWYWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVyZ2VGdW5jdGlvbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG1vZGVsLCByZXByZXNlbnRpbmcgYSB0YWJsZSBpbiB0aGUgREIsIHdpdGggYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogVGhlIHRhYmxlIGNvbHVtbnMgYXJlIGRlZmluZWQgYnkgdGhlIGhhc2ggdGhhdCBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqIEVhY2ggYXR0cmlidXRlIG9mIHRoZSBoYXNoIHJlcHJlc2VudHMgYSBjb2x1bW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFByb2plY3QuaW5pdCh7XG4gICAqICAgY29sdW1uQToge1xuICAgKiAgICAgdHlwZTogU2VxdWVsaXplLkJPT0xFQU4sXG4gICAqICAgICB2YWxpZGF0ZToge1xuICAgKiAgICAgICBpczogWydbYS16XScsJ2knXSwgICAgICAgIC8vIHdpbGwgb25seSBhbGxvdyBsZXR0ZXJzXG4gICAqICAgICAgIG1heDogMjMsICAgICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyB2YWx1ZXMgPD0gMjNcbiAgICogICAgICAgaXNJbjoge1xuICAgKiAgICAgICAgIGFyZ3M6IFtbJ2VuJywgJ3poJ11dLFxuICAgKiAgICAgICAgIG1zZzogXCJNdXN0IGJlIEVuZ2xpc2ggb3IgQ2hpbmVzZVwiXG4gICAqICAgICAgIH1cbiAgICogICAgIH0sXG4gICAqICAgICBmaWVsZDogJ2NvbHVtbl9hJ1xuICAgKiAgICAgLy8gT3RoZXIgYXR0cmlidXRlcyBoZXJlXG4gICAqICAgfSxcbiAgICogICBjb2x1bW5COiBTZXF1ZWxpemUuU1RSSU5HLFxuICAgKiAgIGNvbHVtbkM6ICdNWSBWRVJZIE9XTiBDT0xVTU4gVFlQRSdcbiAgICogfSwge3NlcXVlbGl6ZX0pXG4gICAqXG4gICAqIHNlcXVlbGl6ZS5tb2RlbHMubW9kZWxOYW1lIC8vIFRoZSBtb2RlbCB3aWxsIG5vdyBiZSBhdmFpbGFibGUgaW4gbW9kZWxzIHVuZGVyIHRoZSBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBzZWVcbiAgICogPGEgaHJlZj1cIi9tYXN0ZXIvbWFudWFsL21vZGVsLWJhc2ljcy5odG1sXCI+TW9kZWwgQmFzaWNzPC9hPiBndWlkZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIDxhIGhyZWY9XCIvbWFzdGVyL21hbnVhbC9tb2RlbC1iYXNpY3MuaHRtbFwiPkhvb2tzPC9hPiBndWlkZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIDxhIGhyZWY9XCIvbWFzdGVyL21hbnVhbC92YWxpZGF0aW9ucy1hbmQtY29uc3RyYWludHMuaHRtbFwiLz5WYWxpZGF0aW9ucyAmIENvbnN0cmFpbnRzPC9hPiBndWlkZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzIEFuIG9iamVjdCwgd2hlcmUgZWFjaCBhdHRyaWJ1dGUgaXMgYSBjb2x1bW4gb2YgdGhlIHRhYmxlLiBFYWNoIGNvbHVtbiBjYW4gYmUgZWl0aGVyIGEgRGF0YVR5cGUsIGEgc3RyaW5nIG9yIGEgdHlwZS1kZXNjcmlwdGlvbiBvYmplY3QsIHdpdGggdGhlIHByb3BlcnRpZXMgZGVzY3JpYmVkIGJlbG93OlxuICAgKiBAcGFyYW0ge3N0cmluZ3xEYXRhVHlwZXN8b2JqZWN0fSBhdHRyaWJ1dGVzLmNvbHVtbiBUaGUgZGVzY3JpcHRpb24gb2YgYSBkYXRhYmFzZSBjb2x1bW5cbiAgICogQHBhcmFtIHtzdHJpbmd8RGF0YVR5cGVzfSAgICAgICAgYXR0cmlidXRlcy5jb2x1bW4udHlwZSBBIHN0cmluZyBvciBhIGRhdGEgdHlwZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uYWxsb3dOdWxsPXRydWVdIElmIGZhbHNlLCB0aGUgY29sdW1uIHdpbGwgaGF2ZSBhIE5PVCBOVUxMIGNvbnN0cmFpbnQsIGFuZCBhIG5vdCBudWxsIHZhbGlkYXRpb24gd2lsbCBiZSBydW4gYmVmb3JlIGFuIGluc3RhbmNlIGlzIHNhdmVkLlxuICAgKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uZGVmYXVsdFZhbHVlPW51bGxdIEEgbGl0ZXJhbCBkZWZhdWx0IHZhbHVlLCBhIEphdmFTY3JpcHQgZnVuY3Rpb24sIG9yIGFuIFNRTCBmdW5jdGlvbiAoc2VlIGBzZXF1ZWxpemUuZm5gKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4udW5pcXVlPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29sdW1uIHdpbGwgZ2V0IGEgdW5pcXVlIGNvbnN0cmFpbnQuIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgY29sdW1uIHdpbGwgYmUgcGFydCBvZiBhIGNvbXBvc2l0ZSB1bmlxdWUgaW5kZXguIElmIG11bHRpcGxlIGNvbHVtbnMgaGF2ZSB0aGUgc2FtZSBzdHJpbmcsIHRoZXkgd2lsbCBiZSBwYXJ0IG9mIHRoZSBzYW1lIHVuaXF1ZSBpbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ucHJpbWFyeUtleT1mYWxzZV0gSWYgdHJ1ZSwgdGhpcyBhdHRyaWJ1dGUgd2lsbCBiZSBtYXJrZWQgYXMgcHJpbWFyeSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmZpZWxkPW51bGxdIElmIHNldCwgc2VxdWVsaXplIHdpbGwgbWFwIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBhIGRpZmZlcmVudCBuYW1lIGluIHRoZSBkYXRhYmFzZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uYXV0b0luY3JlbWVudD1mYWxzZV0gSWYgdHJ1ZSwgdGhpcyBjb2x1bW4gd2lsbCBiZSBzZXQgdG8gYXV0byBpbmNyZW1lbnRcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmF1dG9JbmNyZW1lbnRJZGVudGl0eT1mYWxzZV0gSWYgdHJ1ZSwgY29tYmluZWQgd2l0aCBhdXRvSW5jcmVtZW50PXRydWUsIHdpbGwgdXNlIFBvc3RncmVzIGBHRU5FUkFURUQgQlkgREVGQVVMVCBBUyBJREVOVElUWWAgaW5zdGVhZCBvZiBgU0VSSUFMYC4gUG9zdGdyZXMgMTArIG9ubHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5jb21tZW50PW51bGxdIENvbW1lbnQgZm9yIHRoaXMgY29sdW1uXG4gICAqIEBwYXJhbSB7c3RyaW5nfE1vZGVsfSAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5yZWZlcmVuY2VzPW51bGxdIEFuIG9iamVjdCB3aXRoIHJlZmVyZW5jZSBjb25maWd1cmF0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xNb2RlbH0gICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ucmVmZXJlbmNlcy5tb2RlbF0gSWYgdGhpcyBjb2x1bW4gcmVmZXJlbmNlcyBhbm90aGVyIHRhYmxlLCBwcm92aWRlIGl0IGhlcmUgYXMgYSBNb2RlbCwgb3IgYSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLnJlZmVyZW5jZXMua2V5PSdpZCddIFRoZSBjb2x1bW4gb2YgdGhlIGZvcmVpZ24gdGFibGUgdGhhdCB0aGlzIGNvbHVtbiByZWZlcmVuY2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFthdHRyaWJ1dGVzLmNvbHVtbi5vblVwZGF0ZV0gV2hhdCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIHJlZmVyZW5jZWQga2V5IGlzIHVwZGF0ZWQuIE9uZSBvZiBDQVNDQURFLCBSRVNUUklDVCwgU0VUIERFRkFVTFQsIFNFVCBOVUxMIG9yIE5PIEFDVElPTlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4ub25EZWxldGVdIFdoYXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZSByZWZlcmVuY2VkIGtleSBpcyBkZWxldGVkLiBPbmUgb2YgQ0FTQ0FERSwgUkVTVFJJQ1QsIFNFVCBERUZBVUxULCBTRVQgTlVMTCBvciBOTyBBQ1RJT05cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgW2F0dHJpYnV0ZXMuY29sdW1uLmdldF0gUHJvdmlkZSBhIGN1c3RvbSBnZXR0ZXIgZm9yIHRoaXMgY29sdW1uLiBVc2UgYHRoaXMuZ2V0RGF0YVZhbHVlKFN0cmluZylgIHRvIG1hbmlwdWxhdGUgdGhlIHVuZGVybHlpbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4uc2V0XSBQcm92aWRlIGEgY3VzdG9tIHNldHRlciBmb3IgdGhpcyBjb2x1bW4uIFVzZSBgdGhpcy5zZXREYXRhVmFsdWUoU3RyaW5nLCBWYWx1ZSlgIHRvIG1hbmlwdWxhdGUgdGhlIHVuZGVybHlpbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbYXR0cmlidXRlcy5jb2x1bW4udmFsaWRhdGVdIEFuIG9iamVjdCBvZiB2YWxpZGF0aW9ucyB0byBleGVjdXRlIGZvciB0aGlzIGNvbHVtbiBldmVyeSB0aW1lIHRoZSBtb2RlbCBpcyBzYXZlZC4gQ2FuIGJlIGVpdGhlciB0aGUgbmFtZSBvZiBhIHZhbGlkYXRpb24gcHJvdmlkZWQgYnkgdmFsaWRhdG9yLmpzLCBhIHZhbGlkYXRpb24gZnVuY3Rpb24gcHJvdmlkZWQgYnkgZXh0ZW5kaW5nIHZhbGlkYXRvci5qcyAoc2VlIHRoZSBgREFPVmFsaWRhdG9yYCBwcm9wZXJ0eSBmb3IgbW9yZSBkZXRhaWxzKSwgb3IgYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi4gQ3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGFuZCB0aGUgaW5zdGFuY2UgaXRzZWxmIGFzIHRoZSBgdGhpc2AgYmluZGluZywgYW5kIGNhbiBwb3NzaWJseSB0YWtlIGEgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LCB0byBzaWduYWwgdGhhdCB0aGV5IGFyZSBhc3luY2hyb25vdXMuIElmIHRoZSB2YWxpZGF0b3IgaXMgc3luYywgaXQgc2hvdWxkIHRocm93IGluIHRoZSBjYXNlIG9mIGEgZmFpbGVkIHZhbGlkYXRpb247IGlmIGl0IGlzIGFzeW5jLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBlcnJvciB0ZXh0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBvcHRpb25zIFRoZXNlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZSBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBTZXF1ZWxpemUgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXF1ZWxpemUgRGVmaW5lIHRoZSBzZXF1ZWxpemUgaW5zdGFuY2UgdG8gYXR0YWNoIHRvIHRoZSBuZXcgTW9kZWwuIFRocm93IGVycm9yIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLm1vZGVsTmFtZV0gU2V0IG5hbWUgb2YgdGhlIG1vZGVsLiBCeSBkZWZhdWx0IGl0cyBzYW1lIGFzIENsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmRlZmF1bHRTY29wZT17fV0gRGVmaW5lIHRoZSBkZWZhdWx0IHNlYXJjaCBzY29wZSB0byB1c2UgZm9yIHRoaXMgbW9kZWwuIFNjb3BlcyBoYXZlIHRoZSBzYW1lIGZvcm0gYXMgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGZpbmQgLyBmaW5kQWxsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnNjb3Blc10gTW9yZSBzY29wZXMsIGRlZmluZWQgaW4gdGhlIHNhbWUgd2F5IGFzIGRlZmF1bHRTY29wZSBhYm92ZS4gU2VlIGBNb2RlbC5zY29wZWAgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IHNjb3BlcyBhcmUgZGVmaW5lZCwgYW5kIHdoYXQgeW91IGNhbiBkbyB3aXRoIHRoZW1cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMub21pdE51bGxdIERvbid0IHBlcnNpc3QgbnVsbCB2YWx1ZXMuIFRoaXMgbWVhbnMgdGhhdCBhbGwgY29sdW1ucyB3aXRoIG51bGwgdmFsdWVzIHdpbGwgbm90IGJlIHNhdmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLnRpbWVzdGFtcHM9dHJ1ZV0gQWRkcyBjcmVhdGVkQXQgYW5kIHVwZGF0ZWRBdCB0aW1lc3RhbXBzIHRvIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMucGFyYW5vaWQ9ZmFsc2VdIENhbGxpbmcgYGRlc3Ryb3lgIHdpbGwgbm90IGRlbGV0ZSB0aGUgbW9kZWwsIGJ1dCBpbnN0ZWFkIHNldCBhIGBkZWxldGVkQXRgIHRpbWVzdGFtcCBpZiB0aGlzIGlzIHRydWUuIE5lZWRzIGB0aW1lc3RhbXBzPXRydWVgIHRvIHdvcmtcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgW29wdGlvbnMudW5kZXJzY29yZWQ9ZmFsc2VdIEFkZCB1bmRlcnNjb3JlZCBmaWVsZCB0byBhbGwgYXR0cmlidXRlcywgdGhpcyBjb3ZlcnMgdXNlciBkZWZpbmVkIGF0dHJpYnV0ZXMsIHRpbWVzdGFtcHMgYW5kIGZvcmVpZ24ga2V5cy4gV2lsbCBub3QgYWZmZWN0IGF0dHJpYnV0ZXMgd2l0aCBleHBsaWNpdGx5IHNldCBgZmllbGRgIG9wdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5mcmVlemVUYWJsZU5hbWU9ZmFsc2VdIElmIGZyZWV6ZVRhYmxlTmFtZSBpcyB0cnVlLCBzZXF1ZWxpemUgd2lsbCBub3QgdHJ5IHRvIGFsdGVyIHRoZSBtb2RlbCBuYW1lIHRvIGdldCB0aGUgdGFibGUgbmFtZS4gT3RoZXJ3aXNlLCB0aGUgbW9kZWwgbmFtZSB3aWxsIGJlIHBsdXJhbGl6ZWRcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMubmFtZV0gQW4gb2JqZWN0IHdpdGggdHdvIGF0dHJpYnV0ZXMsIGBzaW5ndWxhcmAgYW5kIGBwbHVyYWxgLCB3aGljaCBhcmUgdXNlZCB3aGVuIHRoaXMgbW9kZWwgaXMgYXNzb2NpYXRlZCB0byBvdGhlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLm5hbWUuc2luZ3VsYXI9VXRpbHMuc2luZ3VsYXJpemUobW9kZWxOYW1lKV0gU2luZ3VsYXIgbmFtZSBmb3IgbW9kZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMubmFtZS5wbHVyYWw9VXRpbHMucGx1cmFsaXplKG1vZGVsTmFtZSldIFBsdXJhbCBuYW1lIGZvciBtb2RlbFxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59ICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzXSBpbmRleGVzIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguIERlZmF1bHRzIHRvIG1vZGVsIG5hbWUgKyBfICsgZmllbGRzIGNvbmNhdGVuYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10udHlwZV0gSW5kZXggdHlwZS4gT25seSB1c2VkIGJ5IG15c3FsLiBPbmUgb2YgYFVOSVFVRWAsIGBGVUxMVEVYVGAgYW5kIGBTUEFUSUFMYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10udXNpbmddIFRoZSBtZXRob2QgdG8gY3JlYXRlIHRoZSBpbmRleCBieSAoYFVTSU5HYCBzdGF0ZW1lbnQgaW4gU1FMKS4gQlRSRUUgYW5kIEhBU0ggYXJlIHN1cHBvcnRlZCBieSBteXNxbCBhbmQgcG9zdGdyZXMsIGFuZCBwb3N0Z3JlcyBhZGRpdGlvbmFsbHkgc3VwcG9ydHMgR0lTVCBhbmQgR0lOLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmRleGVzW10ub3BlcmF0b3JdIFNwZWNpZnkgaW5kZXggb3BlcmF0b3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS51bmlxdWU9ZmFsc2VdIFNob3VsZCB0aGUgaW5kZXggYnkgdW5pcXVlPyBDYW4gYWxzbyBiZSB0cmlnZ2VyZWQgYnkgc2V0dGluZyB0eXBlIHRvIGBVTklRVUVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLmluZGV4ZXNbXS5jb25jdXJyZW50bHk9ZmFsc2VdIFBvc3RncmVzU1FMIHdpbGwgYnVpbGQgdGhlIGluZGV4IHdpdGhvdXQgdGFraW5nIGFueSB3cml0ZSBsb2Nrcy4gUG9zdGdyZXMgb25seVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xvYmplY3Q+fSAgICBbb3B0aW9ucy5pbmRleGVzW10uZmllbGRzXSBBbiBhcnJheSBvZiB0aGUgZmllbGRzIHRvIGluZGV4LiBFYWNoIGZpZWxkIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgZmllbGQsIGEgc2VxdWVsaXplIG9iamVjdCAoZS5nIGBzZXF1ZWxpemUuZm5gKSwgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOiBgYXR0cmlidXRlYCAoZmllbGQgbmFtZSksIGBsZW5ndGhgIChjcmVhdGUgYSBwcmVmaXggaW5kZXggb2YgbGVuZ3RoIGNoYXJzKSwgYG9yZGVyYCAodGhlIGRpcmVjdGlvbiB0aGUgY29sdW1uIHNob3VsZCBiZSBzb3J0ZWQgaW4pLCBgY29sbGF0ZWAgKHRoZSBjb2xsYXRpb24gKHNvcnQgb3JkZXIpIGZvciB0aGUgY29sdW1uKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSAgICAgICAgICBbb3B0aW9ucy5jcmVhdGVkQXRdIE92ZXJyaWRlIHRoZSBuYW1lIG9mIHRoZSBjcmVhdGVkQXQgYXR0cmlidXRlIGlmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCBvciBkaXNhYmxlIGl0IGlmIGZhbHNlLiBUaW1lc3RhbXBzIG11c3QgYmUgdHJ1ZS4gVW5kZXJzY29yZWQgZmllbGQgd2lsbCBiZSBzZXQgd2l0aCB1bmRlcnNjb3JlZCBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSAgICAgICAgICBbb3B0aW9ucy51cGRhdGVkQXRdIE92ZXJyaWRlIHRoZSBuYW1lIG9mIHRoZSB1cGRhdGVkQXQgYXR0cmlidXRlIGlmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCBvciBkaXNhYmxlIGl0IGlmIGZhbHNlLiBUaW1lc3RhbXBzIG11c3QgYmUgdHJ1ZS4gVW5kZXJzY29yZWQgZmllbGQgd2lsbCBiZSBzZXQgd2l0aCB1bmRlcnNjb3JlZCBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSAgICAgICAgICBbb3B0aW9ucy5kZWxldGVkQXRdIE92ZXJyaWRlIHRoZSBuYW1lIG9mIHRoZSBkZWxldGVkQXQgYXR0cmlidXRlIGlmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCBvciBkaXNhYmxlIGl0IGlmIGZhbHNlLiBUaW1lc3RhbXBzIG11c3QgYmUgdHJ1ZS4gVW5kZXJzY29yZWQgZmllbGQgd2lsbCBiZSBzZXQgd2l0aCB1bmRlcnNjb3JlZCBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy50YWJsZU5hbWVdIERlZmF1bHRzIHRvIHBsdXJhbGl6ZWQgbW9kZWwgbmFtZSwgdW5sZXNzIGZyZWV6ZVRhYmxlTmFtZSBpcyB0cnVlLCBpbiB3aGljaCBjYXNlIGl0IHVzZXMgbW9kZWwgbmFtZSB2ZXJiYXRpbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5zY2hlbWE9J3B1YmxpYyddIHNjaGVtYVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5lbmdpbmVdIFNwZWNpZnkgZW5naW5lIGZvciBtb2RlbCdzIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmNoYXJzZXRdIFNwZWNpZnkgY2hhcnNldCBmb3IgbW9kZWwncyB0YWJsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5jb21tZW50XSBTcGVjaWZ5IGNvbW1lbnQgZm9yIG1vZGVsJ3MgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuY29sbGF0ZV0gU3BlY2lmeSBjb2xsYXRpb24gZm9yIG1vZGVsJ3MgdGFibGVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5pdGlhbEF1dG9JbmNyZW1lbnRdIFNldCB0aGUgaW5pdGlhbCBBVVRPX0lOQ1JFTUVOVCB2YWx1ZSBmb3IgdGhlIHRhYmxlIGluIE15U1FMLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbb3B0aW9ucy5ob29rc10gQW4gb2JqZWN0IG9mIGhvb2sgZnVuY3Rpb24gdGhhdCBhcmUgY2FsbGVkIGJlZm9yZSBhbmQgYWZ0ZXIgY2VydGFpbiBsaWZlY3ljbGUgZXZlbnRzLiBUaGUgcG9zc2libGUgaG9va3MgYXJlOiBiZWZvcmVWYWxpZGF0ZSwgYWZ0ZXJWYWxpZGF0ZSwgdmFsaWRhdGlvbkZhaWxlZCwgYmVmb3JlQnVsa0NyZWF0ZSwgYmVmb3JlQnVsa0Rlc3Ryb3ksIGJlZm9yZUJ1bGtVcGRhdGUsIGJlZm9yZUNyZWF0ZSwgYmVmb3JlRGVzdHJveSwgYmVmb3JlVXBkYXRlLCBhZnRlckNyZWF0ZSwgYmVmb3JlU2F2ZSwgYWZ0ZXJEZXN0cm95LCBhZnRlclVwZGF0ZSwgYWZ0ZXJCdWxrQ3JlYXRlLCBhZnRlclNhdmUsIGFmdGVyQnVsa0Rlc3Ryb3kgYW5kIGFmdGVyQnVsa1VwZGF0ZS4gU2VlIEhvb2tzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvb2sgZnVuY3Rpb25zIGFuZCB0aGVpciBzaWduYXR1cmVzLiBFYWNoIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2YgZnVuY3Rpb25zLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBbb3B0aW9ucy52YWxpZGF0ZV0gQW4gb2JqZWN0IG9mIG1vZGVsIHdpZGUgdmFsaWRhdGlvbnMuIFZhbGlkYXRpb25zIGhhdmUgYWNjZXNzIHRvIGFsbCBtb2RlbCB2YWx1ZXMgdmlhIGB0aGlzYC4gSWYgdGhlIHZhbGlkYXRvciBmdW5jdGlvbiB0YWtlcyBhbiBhcmd1bWVudCwgaXQgaXMgYXNzdW1lZCB0byBiZSBhc3luYywgYW5kIGlzIGNhbGxlZCB3aXRoIGEgY2FsbGJhY2sgdGhhdCBhY2NlcHRzIGFuIG9wdGlvbmFsIGVycm9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TW9kZWx9XG4gICAqL1xuICBzdGF0aWMgaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnMuc2VxdWVsaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNlcXVlbGl6ZSBpbnN0YW5jZSBwYXNzZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlcXVlbGl6ZSA9IG9wdGlvbnMuc2VxdWVsaXplO1xuXG4gICAgY29uc3QgZ2xvYmFsT3B0aW9ucyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnM7XG5cbiAgICBvcHRpb25zID0gVXRpbHMubWVyZ2UoXy5jbG9uZURlZXAoZ2xvYmFsT3B0aW9ucy5kZWZpbmUpLCBvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucy5tb2RlbE5hbWUpIHtcbiAgICAgIG9wdGlvbnMubW9kZWxOYW1lID0gdGhpcy5uYW1lO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBVdGlscy5tZXJnZSh7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIHBsdXJhbDogVXRpbHMucGx1cmFsaXplKG9wdGlvbnMubW9kZWxOYW1lKSxcbiAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKG9wdGlvbnMubW9kZWxOYW1lKVxuICAgICAgfSxcbiAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgb21pdE51bGw6IGdsb2JhbE9wdGlvbnMub21pdE51bGwsXG4gICAgICBzY2hlbWE6IGdsb2JhbE9wdGlvbnMuc2NoZW1hXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcygnYmVmb3JlRGVmaW5lJywgYXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlbE5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywgeyB2YWx1ZTogb3B0aW9ucy5tb2RlbE5hbWUgfSk7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLm1vZGVsTmFtZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHRpbWVzdGFtcHM6IHRydWUsXG4gICAgICB2YWxpZGF0ZToge30sXG4gICAgICBmcmVlemVUYWJsZU5hbWU6IGZhbHNlLFxuICAgICAgdW5kZXJzY29yZWQ6IGZhbHNlLFxuICAgICAgcGFyYW5vaWQ6IGZhbHNlLFxuICAgICAgcmVqZWN0T25FbXB0eTogZmFsc2UsXG4gICAgICB3aGVyZUNvbGxlY3Rpb246IG51bGwsXG4gICAgICBzY2hlbWE6IG51bGwsXG4gICAgICBzY2hlbWFEZWxpbWl0ZXI6ICcnLFxuICAgICAgZGVmYXVsdFNjb3BlOiB7fSxcbiAgICAgIHNjb3Blczoge30sXG4gICAgICBpbmRleGVzOiBbXSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gaWYgeW91IGNhbGwgXCJkZWZpbmVcIiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgbW9kZWxOYW1lLCBkbyBub3QgY2x1dHRlciB0aGUgZmFjdG9yeVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5pc0RlZmluZWQodGhpcy5uYW1lKSkge1xuICAgICAgdGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLnJlbW92ZU1vZGVsKHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5nZXRNb2RlbCh0aGlzLm5hbWUpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3NldHVwSG9va3Mob3B0aW9ucy5ob29rcyk7XG5cbiAgICB0aGlzLnVuZGVyc2NvcmVkID0gdGhpcy5vcHRpb25zLnVuZGVyc2NvcmVkO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudGFibGVOYW1lKSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZSA9IHRoaXMub3B0aW9ucy5mcmVlemVUYWJsZU5hbWUgPyB0aGlzLm5hbWUgOiBVdGlscy51bmRlcnNjb3JlZElmKFV0aWxzLnBsdXJhbGl6ZSh0aGlzLm5hbWUpLCB0aGlzLnVuZGVyc2NvcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWJsZU5hbWUgPSB0aGlzLm9wdGlvbnMudGFibGVOYW1lO1xuICAgIH1cblxuICAgIHRoaXMuX3NjaGVtYSA9IHRoaXMub3B0aW9ucy5zY2hlbWE7XG4gICAgdGhpcy5fc2NoZW1hRGVsaW1pdGVyID0gdGhpcy5vcHRpb25zLnNjaGVtYURlbGltaXRlcjtcblxuICAgIC8vIGVycm9yIGNoZWNrIG9wdGlvbnNcbiAgICBfLmVhY2gob3B0aW9ucy52YWxpZGF0ZSwgKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCB2YWxpZGF0b3JUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbW9kZWwgdmFsaWRhdG9yIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgdGhlIHNhbWUgbmFtZSBhcyBhIGZpZWxkLiBNb2RlbDogJHt0aGlzLm5hbWV9LCBmaWVsZC92YWxpZGF0aW9uIG5hbWU6ICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZW1iZXJzIG9mIHRoZSB2YWxpZGF0ZSBvcHRpb24gbXVzdCBiZSBmdW5jdGlvbnMuIE1vZGVsOiAke3RoaXMubmFtZX0sIGVycm9yIHdpdGggdmFsaWRhdGUgbWVtYmVyICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmF3QXR0cmlidXRlcyA9IF8ubWFwVmFsdWVzKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIG5hbWUpID0+IHtcbiAgICAgIGF0dHJpYnV0ZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBkYXRhdHlwZSBmb3IgYXR0cmlidXRlIFwiJHt0aGlzLm5hbWV9LiR7bmFtZX1cImApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCAhPT0gZmFsc2UgJiYgXy5nZXQoYXR0cmlidXRlLCAndmFsaWRhdGUubm90TnVsbCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZWZpbml0aW9uIGZvciBcIiR7dGhpcy5uYW1lfS4ke25hbWV9XCIsIFwibm90TnVsbFwiIHZhbGlkYXRvciBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcImFsbG93TnVsbDpmYWxzZVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmdldChhdHRyaWJ1dGUsICdyZWZlcmVuY2VzLm1vZGVsLnByb3RvdHlwZScpIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgPSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKCk7XG4gICAgdGhpcy5faW5kZXhlcyA9IHRoaXMub3B0aW9ucy5pbmRleGVzXG4gICAgICAubWFwKGluZGV4ID0+IFV0aWxzLm5hbWVJbmRleCh0aGlzLl9jb25mb3JtSW5kZXgoaW5kZXgpLCB0YWJsZU5hbWUpKTtcblxuICAgIHRoaXMucHJpbWFyeUtleXMgPSB7fTtcbiAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgLy8gc2V0dXAgbmFtZXMgb2YgdGltZXN0YW1wIGF0dHJpYnV0ZXNcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWVzdGFtcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnY3JlYXRlZEF0JywgJ3VwZGF0ZWRBdCcsICdkZWxldGVkQXQnXSkge1xuICAgICAgICBpZiAoIVsndW5kZWZpbmVkJywgJ3N0cmluZycsICdib29sZWFuJ10uaW5jbHVkZXModHlwZW9mIHRoaXMub3B0aW9uc1trZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIFwiJHtrZXl9XCIgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBib29sZWFuLCBnb3QgJHt0eXBlb2YgdGhpcy5vcHRpb25zW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1trZXldID09PSAnJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIFwiJHtrZXl9XCIgb3B0aW9uIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNyZWF0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQgPVxuICAgICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuY3JlYXRlZEF0ID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgOiAnY3JlYXRlZEF0JztcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgPVxuICAgICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlZEF0ID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy51cGRhdGVkQXQgOiAndXBkYXRlZEF0JztcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFub2lkICYmIHRoaXMub3B0aW9ucy5kZWxldGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ID1cbiAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0IDogJ2RlbGV0ZWRBdCc7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIG5hbWUgZm9yIHZlcnNpb24gYXR0cmlidXRlXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICB0aGlzLl92ZXJzaW9uQXR0cmlidXRlID0gdHlwZW9mIHRoaXMub3B0aW9ucy52ZXJzaW9uID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy52ZXJzaW9uIDogJ3ZlcnNpb24nO1xuICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYXNSZWFkT25seUF0dHJpYnV0ZXMgPSB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuc2l6ZSA+IDA7XG5cbiAgICAvLyBBZGQgaGVhZCBhbmQgdGFpbCBkZWZhdWx0IGF0dHJpYnV0ZXMgKGlkLCB0aW1lc3RhbXBzKVxuICAgIHRoaXMuX2FkZERlZmF1bHRBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuX2ZpbmRBdXRvSW5jcmVtZW50QXR0cmlidXRlKCk7XG5cbiAgICB0aGlzLl9zY29wZSA9IHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGU7XG4gICAgdGhpcy5fc2NvcGVOYW1lcyA9IFsnZGVmYXVsdFNjb3BlJ107XG5cbiAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuYWRkTW9kZWwodGhpcyk7XG4gICAgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoJ2FmdGVyRGVmaW5lJywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyByZWZyZXNoQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5pcHVsYXRpb24gPSB7fTtcblxuICAgIHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzID0ge307XG4gICAgdGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnMgPSB7fTtcblxuICAgIFsnZ2V0JywgJ3NldCddLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBvcHQgPSBgJHt0eXBlfXRlck1ldGhvZHNgO1xuICAgICAgY29uc3QgZnVuY3MgPSB7IC4uLnRoaXMub3B0aW9uc1tvcHRdIH07XG4gICAgICBjb25zdCBfY3VzdG9tID0gdHlwZSA9PT0gJ2dldCcgPyB0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycyA6IHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzO1xuXG4gICAgICBfLmVhY2goZnVuY3MsIChtZXRob2QsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBfY3VzdG9tW2F0dHJpYnV0ZV0gPSBtZXRob2Q7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdnZXQnKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgXy5lYWNoKHRoaXMucmF3QXR0cmlidXRlcywgKG9wdGlvbnMsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIHR5cGUpKSB7XG4gICAgICAgICAgX2N1c3RvbVthdHRyaWJ1dGVdID0gb3B0aW9uc1t0eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnZ2V0Jykge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyaWJ1dGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF8uZWFjaChmdW5jcywgKGZjdCwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXSkge1xuICAgICAgICAgIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdW3R5cGVdID0gZmN0O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kYXRhVHlwZUNoYW5nZXMgPSB7fTtcbiAgICB0aGlzLl9kYXRhVHlwZVNhbml0aXplcnMgPSB7fTtcblxuICAgIHRoaXMuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgdGhpcy5faGFzRGF0ZUF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9qc29uQXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWVzID0ge307XG4gICAgdGhpcy5wcm90b3R5cGUudmFsaWRhdG9ycyA9IHt9O1xuXG4gICAgdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXAgPSB7fTtcblxuICAgIHRoaXMucHJpbWFyeUtleXMgPSB7fTtcbiAgICB0aGlzLnVuaXF1ZUtleXMgPSB7fTtcblxuICAgIF8uZWFjaCh0aGlzLnJhd0F0dHJpYnV0ZXMsIChkZWZpbml0aW9uLCBuYW1lKSA9PiB7XG4gICAgICBkZWZpbml0aW9uLnR5cGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVEYXRhVHlwZShkZWZpbml0aW9uLnR5cGUpO1xuXG4gICAgICBkZWZpbml0aW9uLk1vZGVsID0gdGhpcztcbiAgICAgIGRlZmluaXRpb24uZmllbGROYW1lID0gbmFtZTtcbiAgICAgIGRlZmluaXRpb24uX21vZGVsQXR0cmlidXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlZmluaXRpb24uZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uLmZpZWxkID0gVXRpbHMudW5kZXJzY29yZWRJZihuYW1lLCB0aGlzLnVuZGVyc2NvcmVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24ucHJpbWFyeUtleSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnByaW1hcnlLZXlzW25hbWVdID0gZGVmaW5pdGlvbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXBbZGVmaW5pdGlvbi5maWVsZF0gPSBkZWZpbml0aW9uO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlLl9zYW5pdGl6ZSkge1xuICAgICAgICB0aGlzLl9kYXRhVHlwZVNhbml0aXplcnNbbmFtZV0gPSBkZWZpbml0aW9uLnR5cGUuX3Nhbml0aXplO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlLl9pc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fZGF0YVR5cGVDaGFuZ2VzW25hbWVdID0gZGVmaW5pdGlvbi50eXBlLl9pc0NoYW5nZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQk9PTEVBTikge1xuICAgICAgICB0aGlzLl9oYXNCb29sZWFuQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFIHx8IGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFT05MWSkge1xuICAgICAgICB0aGlzLl9oYXNEYXRlQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgIHRoaXMuX2pzb25BdHRyaWJ1dGVzLmFkZChuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlZJUlRVQUwpIHtcbiAgICAgICAgdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sICdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVzW25hbWVdID0gKCkgPT4gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmaW5pdGlvbi5kZWZhdWx0VmFsdWUsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgJ3VuaXF1ZScpICYmIGRlZmluaXRpb24udW5pcXVlKSB7XG4gICAgICAgIGxldCBpZHhOYW1lO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIGRlZmluaXRpb24udW5pcXVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLnVuaXF1ZSwgJ25hbWUnKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZHhOYW1lID0gZGVmaW5pdGlvbi51bmlxdWUubmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbi51bmlxdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGRlZmluaXRpb24udW5pcXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkeE5hbWUgPSBgJHt0aGlzLnRhYmxlTmFtZX1fJHtuYW1lfV91bmlxdWVgO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy51bmlxdWVLZXlzW2lkeE5hbWVdIHx8IHsgZmllbGRzOiBbXSB9O1xuXG4gICAgICAgIGlkeC5maWVsZHMucHVzaChkZWZpbml0aW9uLmZpZWxkKTtcbiAgICAgICAgaWR4Lm1zZyA9IGlkeC5tc2cgfHwgZGVmaW5pdGlvbi51bmlxdWUubXNnIHx8IG51bGw7XG4gICAgICAgIGlkeC5uYW1lID0gaWR4TmFtZSB8fCBmYWxzZTtcbiAgICAgICAgaWR4LmNvbHVtbiA9IG5hbWU7XG4gICAgICAgIGlkeC5jdXN0b21JbmRleCA9IGRlZmluaXRpb24udW5pcXVlICE9PSB0cnVlO1xuXG4gICAgICAgIHRoaXMudW5pcXVlS2V5c1tpZHhOYW1lXSA9IGlkeDtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCAndmFsaWRhdGUnKSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS52YWxpZGF0b3JzW25hbWVdID0gZGVmaW5pdGlvbi52YWxpZGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24uaW5kZXggPT09IHRydWUgJiYgZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT05CKSB7XG4gICAgICAgIHRoaXMuX2luZGV4ZXMucHVzaChcbiAgICAgICAgICBVdGlscy5uYW1lSW5kZXgoXG4gICAgICAgICAgICB0aGlzLl9jb25mb3JtSW5kZXgoe1xuICAgICAgICAgICAgICBmaWVsZHM6IFtkZWZpbml0aW9uLmZpZWxkIHx8IG5hbWVdLFxuICAgICAgICAgICAgICB1c2luZzogJ2dpbidcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5nZXRUYWJsZU5hbWUoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5pbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBmaWVsZCB0byBhdHRyaWJ1dGUgbmFtZXNcbiAgICB0aGlzLmZpZWxkQXR0cmlidXRlTWFwID0gXy5yZWR1Y2UodGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXAsIChtYXAsIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgIT09IHZhbHVlLmZpZWxkTmFtZSkge1xuICAgICAgICBtYXBba2V5XSA9IHZhbHVlLmZpZWxkTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuXG4gICAgdGhpcy5faGFzSnNvbkF0dHJpYnV0ZXMgPSAhIXRoaXMuX2pzb25BdHRyaWJ1dGVzLnNpemU7XG5cbiAgICB0aGlzLl9oYXNWaXJ0dWFsQXR0cmlidXRlcyA9ICEhdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuc2l6ZTtcblxuICAgIHRoaXMuX2hhc0RlZmF1bHRWYWx1ZXMgPSAhXy5pc0VtcHR5KHRoaXMuX2RlZmF1bHRWYWx1ZXMpO1xuXG4gICAgdGhpcy50YWJsZUF0dHJpYnV0ZXMgPSBfLm9taXRCeSh0aGlzLnJhd0F0dHJpYnV0ZXMsIChfYSwga2V5KSA9PiB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoa2V5KSk7XG5cbiAgICB0aGlzLnByb3RvdHlwZS5faGFzQ3VzdG9tR2V0dGVycyA9IE9iamVjdC5rZXlzKHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzKS5sZW5ndGg7XG4gICAgdGhpcy5wcm90b3R5cGUuX2hhc0N1c3RvbVNldHRlcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycykubGVuZ3RoO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXR0cmlidXRlTWFuaXB1bGF0aW9uKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNb2RlbC5wcm90b3R5cGUsIGtleSkpIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBOb3Qgb3ZlcnJpZGluZyBidWlsdC1pbiBtZXRob2QgZnJvbSBtb2RlbCBhdHRyaWJ1dGU6ICR7a2V5fWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwga2V5LCBhdHRyaWJ1dGVNYW5pcHVsYXRpb25ba2V5XSk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm90b3R5cGUucmF3QXR0cmlidXRlcyA9IHRoaXMucmF3QXR0cmlidXRlcztcbiAgICB0aGlzLnByb3RvdHlwZS5faXNBdHRyaWJ1dGUgPSBrZXkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvdG90eXBlLnJhd0F0dHJpYnV0ZXMsIGtleSk7XG5cbiAgICAvLyBQcmltYXJ5IGtleSBjb252ZW5pZW5jZSBjb25zdGlhYmxlc1xuICAgIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnByaW1hcnlLZXlzKTtcbiAgICB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgPSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdO1xuICAgIGlmICh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUpIHtcbiAgICAgIHRoaXMucHJpbWFyeUtleUZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgfHwgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc1ByaW1hcnlLZXlzID0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGggPiAwO1xuICAgIHRoaXMuX2lzUHJpbWFyeUtleSA9IGtleSA9PiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGF0dHJpYnV0ZSBmcm9tIG1vZGVsIGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBuYW1lIG9mIGF0dHJpYnV0ZSB0byByZW1vdmVcbiAgICovXG4gIHN0YXRpYyByZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jIHRoaXMgTW9kZWwgdG8gdGhlIERCLCB0aGF0IGlzIGNyZWF0ZSB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gc3luYyBvcHRpb25zXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZSNzeW5jfSBmb3Igb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3luYyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuaG9va3M7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy50YWJsZUF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcmF3QXR0cmlidXRlcyA9IHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwO1xuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZVN5bmMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZHJvcChvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKTtcblxuICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuY3JlYXRlVGFibGUodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCB0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLmFsdGVyKSB7XG4gICAgICBjb25zdCB0YWJsZUluZm9zID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSxcbiAgICAgICAgdGhpcy5xdWVyeUludGVyZmFjZS5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucylcbiAgICAgIF0pO1xuICAgICAgY29uc3QgY29sdW1ucyA9IHRhYmxlSW5mb3NbMF07XG4gICAgICAvLyBVc2UgZm9yIGFsdGVyIGZvcmVpZ24ga2V5c1xuICAgICAgY29uc3QgZm9yZWlnbktleVJlZmVyZW5jZXMgPSB0YWJsZUluZm9zWzFdO1xuICAgICAgY29uc3QgcmVtb3ZlZENvbnN0cmFpbnRzID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgY29sdW1uTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGNvbHVtbk5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFjb2x1bW5zW2NvbHVtbk5hbWVdICYmICFjb2x1bW5zW2F0dHJpYnV0ZXNbY29sdW1uTmFtZV0uZmllbGRdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5hZGRDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLmZpZWxkIHx8IGNvbHVtbk5hbWUsIGF0dHJpYnV0ZXNbY29sdW1uTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFsdGVyID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zLmFsdGVyID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLmFsdGVyLmRyb3AgIT09IGZhbHNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uTmFtZSBpbiBjb2x1bW5zKSB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29sdW1ucywgY29sdW1uTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGUgPSByYXdBdHRyaWJ1dGVzW2NvbHVtbk5hbWVdO1xuICAgICAgICAgIGlmICghY3VycmVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yZW1vdmVDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZS5wcmltYXJ5S2V5KSBjb250aW51ZTtcbiAgICAgICAgICAvLyBDaGVjayBmb3JlaWduIGtleXMuIElmIGl0J3MgYSBmb3JlaWduIGtleSwgaXQgc2hvdWxkIHJlbW92ZSBjb25zdHJhaW50IGZpcnN0LlxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBjdXJyZW50QXR0cmlidXRlLnJlZmVyZW5jZXM7XG4gICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YWJhc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2U7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuc2NoZW1hO1xuICAgICAgICAgICAgLy8gRmluZCBleGlzdGVkIGZvcmVpZ24ga2V5c1xuICAgICAgICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5UmVmZXJlbmNlIG9mIGZvcmVpZ25LZXlSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnROYW1lID0gZm9yZWlnbktleVJlZmVyZW5jZS5jb25zdHJhaW50TmFtZTtcbiAgICAgICAgICAgICAgaWYgKCEhY29uc3RyYWludE5hbWVcbiAgICAgICAgICAgICAgICAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnRhYmxlQ2F0YWxvZyA9PT0gZGF0YWJhc2VcbiAgICAgICAgICAgICAgICAmJiAoc2NoZW1hID8gZm9yZWlnbktleVJlZmVyZW5jZS50YWJsZVNjaGVtYSA9PT0gc2NoZW1hIDogdHJ1ZSlcbiAgICAgICAgICAgICAgICAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRUYWJsZU5hbWUgPT09IHJlZmVyZW5jZXMubW9kZWxcbiAgICAgICAgICAgICAgICAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRDb2x1bW5OYW1lID09PSByZWZlcmVuY2VzLmtleVxuICAgICAgICAgICAgICAgICYmIChzY2hlbWEgPyBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRUYWJsZVNjaGVtYSA9PT0gc2NoZW1hIDogdHJ1ZSlcbiAgICAgICAgICAgICAgICAmJiAhcmVtb3ZlZENvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb25zdHJhaW50IG9uIGZvcmVpZ24ga2V5cy5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5jaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBjdXJyZW50QXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaW5kZXhlcyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2Uuc2hvd0luZGV4KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgaW5kZXhlcyA9IHRoaXMuX2luZGV4ZXMuZmlsdGVyKGl0ZW0xID0+XG4gICAgICAhaW5kZXhlcy5zb21lKGl0ZW0yID0+IGl0ZW0xLm5hbWUgPT09IGl0ZW0yLm5hbWUpXG4gICAgKS5zb3J0KChpbmRleDEsIGluZGV4MikgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gJ3Bvc3RncmVzJykge1xuICAgICAgLy8gbW92ZSBjb25jdXJyZW50IGluZGV4ZXMgdG8gdGhlIGJvdHRvbSB0byBhdm9pZCB3ZWlyZCBkZWFkbG9ja3NcbiAgICAgICAgaWYgKGluZGV4MS5jb25jdXJyZW50bHkgPT09IHRydWUpIHJldHVybiAxO1xuICAgICAgICBpZiAoaW5kZXgyLmNvbmN1cnJlbnRseSA9PT0gdHJ1ZSkgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5hZGRJbmRleCh0YWJsZU5hbWUsIHsgLi4ub3B0aW9ucywgLi4uaW5kZXggfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyU3luYycsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3AgdGhlIHRhYmxlIHJlcHJlc2VudGVkIGJ5IHRoaXMgTW9kZWxcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnNdIGRyb3Agb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5jYXNjYWRlPWZhbHNlXSAgIEFsc28gZHJvcCBhbGwgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhpcyB0YWJsZSwgc3VjaCBhcyB2aWV3cy4gT25seSB3b3JrcyBpbiBwb3N0Z3Jlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkcm9wKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kcm9wVGFibGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZHJvcFNjaGVtYShzY2hlbWEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgc2NoZW1hIHRvIHRoaXMgbW9kZWwuIEZvciBwb3N0Z3JlcywgdGhpcyB3aWxsIGFjdHVhbGx5IHBsYWNlIHRoZSBzY2hlbWEgaW4gZnJvbnQgb2YgdGhlIHRhYmxlIG5hbWUgLSBgXCJzY2hlbWFcIi5cInRhYmxlTmFtZVwiYCxcbiAgICogd2hpbGUgdGhlIHNjaGVtYSB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgdGFibGUgbmFtZSBmb3IgbXlzcWwgYW5kIHNxbGl0ZSAtIGAnc2NoZW1hLnRhYmxlbmFtZSdgLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdXNlIGNhc2VzIHdoZXJlIHRoZSBzYW1lIG1vZGVsIGlzIG5lZWRlZCBpbiBtdWx0aXBsZSBzY2hlbWFzLiBJbiBzdWNoIGEgdXNlIGNhc2UgaXQgaXMgaW1wb3J0YW50XG4gICAqIHRvIGNhbGwgYG1vZGVsLnNjaGVtYShzY2hlbWEsIFtvcHRpb25zXSkuc3luYygpYCBmb3IgZWFjaCBtb2RlbCB0byBlbnN1cmUgdGhlIG1vZGVscyBhcmUgY3JlYXRlZCBpbiB0aGUgY29ycmVjdCBzY2hlbWEuXG4gICAqXG4gICAqIElmIGEgc2luZ2xlIGRlZmF1bHQgc2NoZW1hIHBlciBtb2RlbCBpcyBuZWVkZWQsIHNldCB0aGUgYG9wdGlvbnMuc2NoZW1hPSdzY2hlbWEnYCBwYXJhbWV0ZXIgZHVyaW5nIHRoZSBgZGVmaW5lKClgIGNhbGxcbiAgICogZm9yIHRoZSBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgc2NoZW1hIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWFcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnNdIHNjaGVtYSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnNjaGVtYURlbGltaXRlcj0nLiddIFRoZSBjaGFyYWN0ZXIocykgdGhhdCBzZXBhcmF0ZXMgdGhlIHNjaGVtYSBuYW1lIGZyb20gdGhlIHRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIFNlcXVlbGl6ZSNkZWZpbmV9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHNldHRpbmcgYSBkZWZhdWx0IHNjaGVtYS5cbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfVxuICAgKi9cbiAgc3RhdGljIHNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGNsb25lID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB0aGlzLm5hbWUgfSk7XG5cbiAgICBjbG9uZS5fc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2xvbmUuX3NjaGVtYURlbGltaXRlciA9IG9wdGlvbnM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgICAgIGNsb25lLl9zY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0YWJsZSBuYW1lIG9mIHRoZSBtb2RlbCwgdGFraW5nIHNjaGVtYSBpbnRvIGFjY291bnQuIFRoZSBtZXRob2Qgd2lsbCByZXR1cm4gVGhlIG5hbWUgYXMgYSBzdHJpbmcgaWYgdGhlIG1vZGVsIGhhcyBubyBzY2hlbWEsXG4gICAqIG9yIGFuIG9iamVjdCB3aXRoIGB0YWJsZU5hbWVgLCBgc2NoZW1hYCBhbmQgYGRlbGltaXRlcmAgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0VGFibGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZFNjaGVtYSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdW4tc2NvcGVkIG1vZGVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH1cbiAgICovXG4gIHN0YXRpYyB1bnNjb3BlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzY29wZSB0byB0aGUgbW9kZWwuIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGFkZGluZyBzY29wZXMgd2l0aCBpbmNsdWRlcywgd2hlbiB0aGUgbW9kZWwgeW91IHdhbnQgdG8gaW5jbHVkZSBpcyBub3QgYXZhaWxhYmxlIGF0IHRoZSB0aW1lIHRoaXMgbW9kZWwgaXMgZGVmaW5lZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYSBzY29wZSB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0cy4gUGFzcyBgb3ZlcnJpZGU6IHRydWVgIGluIHRoZSBvcHRpb25zIG9iamVjdCB0byBzaWxlbmNlIHRoaXMgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY29wZS4gVXNlIGBkZWZhdWx0U2NvcGVgIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjb3BlXG4gICAqIEBwYXJhbSB7b2JqZWN0fEZ1bmN0aW9ufSBzY29wZSBzY29wZSBvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBbb3B0aW9uc10gc2NvcGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMub3ZlcnJpZGU9ZmFsc2VdIG92ZXJyaWRlIG9sZCBzY29wZSBpZiBhbHJlYWR5IGRlZmluZWRcbiAgICovXG4gIHN0YXRpYyBhZGRTY29wZShuYW1lLCBzY29wZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IG92ZXJyaWRlOiBmYWxzZSwgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKChuYW1lID09PSAnZGVmYXVsdFNjb3BlJyAmJiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlKS5sZW5ndGggPiAwIHx8IG5hbWUgaW4gdGhpcy5vcHRpb25zLnNjb3BlcykgJiYgb3B0aW9ucy5vdmVycmlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNjb3BlICR7bmFtZX0gYWxyZWFkeSBleGlzdHMuIFBhc3MgeyBvdmVycmlkZTogdHJ1ZSB9IGFzIG9wdGlvbnMgdG8gc2lsZW5jZSB0aGlzIGVycm9yYCk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdkZWZhdWx0U2NvcGUnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlID0gdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnNjb3Blc1tuYW1lXSA9IHNjb3BlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNjb3BlIGNyZWF0ZWQgaW4gYGRlZmluZWAgdG8gdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5ob3cgdG8gY3JlYXRlIHNjb3BlczwvY2FwdGlvbj5cbiAgICogY29uc3QgTW9kZWwgPSBzZXF1ZWxpemUuZGVmaW5lKCdtb2RlbCcsIGF0dHJpYnV0ZXMsIHtcbiAgICogICBkZWZhdWx0U2NvcGU6IHtcbiAgICogICAgIHdoZXJlOiB7XG4gICAqICAgICAgIHVzZXJuYW1lOiAnZGFuJ1xuICAgKiAgICAgfSxcbiAgICogICAgIGxpbWl0OiAxMlxuICAgKiAgIH0sXG4gICAqICAgc2NvcGVzOiB7XG4gICAqICAgICBpc0FMaWU6IHtcbiAgICogICAgICAgd2hlcmU6IHtcbiAgICogICAgICAgICBzdHVmZjogJ2Nha2UnXG4gICAqICAgICAgIH1cbiAgICogICAgIH0sXG4gICAqICAgICBjb21wbGV4RnVuY3Rpb246IGZ1bmN0aW9uKGVtYWlsLCBhY2Nlc3NMZXZlbCkge1xuICAgKiAgICAgICByZXR1cm4ge1xuICAgKiAgICAgICAgIHdoZXJlOiB7XG4gICAqICAgICAgICAgICBlbWFpbDoge1xuICAgKiAgICAgICAgICAgICBbT3AubGlrZV06IGVtYWlsXG4gICAqICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgYWNjZXNzX2xldmVsIHtcbiAgICogICAgICAgICAgICAgW09wLmd0ZV06IGFjY2Vzc0xldmVsXG4gICAqICAgICAgICAgICB9XG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiAjIEFzIHlvdSBoYXZlIGRlZmluZWQgYSBkZWZhdWx0IHNjb3BlLCBldmVyeSB0aW1lIHlvdSBkbyBNb2RlbC5maW5kLCB0aGUgZGVmYXVsdCBzY29wZSBpcyBhcHBlbmRlZCB0byB5b3VyIHF1ZXJ5LiBIZXJlJ3MgYSBjb3VwbGUgb2YgZXhhbXBsZXM6XG4gICAqXG4gICAqIE1vZGVsLmZpbmRBbGwoKSAvLyBXSEVSRSB1c2VybmFtZSA9ICdkYW4nXG4gICAqIE1vZGVsLmZpbmRBbGwoeyB3aGVyZTogeyBhZ2U6IHsgW09wLmd0XTogMTIgfSB9IH0pIC8vIFdIRVJFIGFnZSA+IDEyIEFORCB1c2VybmFtZSA9ICdkYW4nXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlRvIGludm9rZSBzY29wZSBmdW5jdGlvbnMgeW91IGNhbiBkbzwvY2FwdGlvbj5cbiAgICogTW9kZWwuc2NvcGUoeyBtZXRob2Q6IFsnY29tcGxleEZ1bmN0aW9uJywgJ2RhbkBzZXF1ZWxpemUuY29tJywgNDJdfSkuZmluZEFsbCgpXG4gICAqIC8vIFdIRVJFIGVtYWlsIGxpa2UgJ2RhbkBzZXF1ZWxpemUuY29tJScgQU5EIGFjY2Vzc19sZXZlbCA+PSA0MlxuICAgKlxuICAgKiBAcGFyYW0gez9BcnJheXxvYmplY3R8c3RyaW5nfSBbb3B0aW9uXSBUaGUgc2NvcGUocykgdG8gYXBwbHkuIFNjb3BlcyBjYW4gZWl0aGVyIGJlIHBhc3NlZCBhcyBjb25zZWN1dGl2ZSBhcmd1bWVudHMsIG9yIGFzIGFuIGFycmF5IG9mIGFyZ3VtZW50cy4gVG8gYXBwbHkgc2ltcGxlIHNjb3BlcyBhbmQgc2NvcGUgZnVuY3Rpb25zIHdpdGggbm8gYXJndW1lbnRzLCBwYXNzIHRoZW0gYXMgc3RyaW5ncy4gRm9yIHNjb3BlIGZ1bmN0aW9uLCBwYXNzIGFuIG9iamVjdCwgd2l0aCBhIGBtZXRob2RgIHByb3BlcnR5LiBUaGUgdmFsdWUgY2FuIGVpdGhlciBiZSBhIHN0cmluZywgaWYgdGhlIG1ldGhvZCBkb2VzIG5vdCB0YWtlIGFueSBhcmd1bWVudHMsIG9yIGFuIGFycmF5LCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kLCBhbmQgY29uc2VjdXRpdmUgZWxlbWVudHMgYXJlIGFyZ3VtZW50cyB0byB0aGF0IG1ldGhvZC4gUGFzcyBudWxsIHRvIHJlbW92ZSBhbGwgc2NvcGVzLCBpbmNsdWRpbmcgdGhlIGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNb2RlbH0gQSByZWZlcmVuY2UgdG8gdGhlIG1vZGVsLCB3aXRoIHRoZSBzY29wZShzKSBhcHBsaWVkLiBDYWxsaW5nIHNjb3BlIGFnYWluIG9uIHRoZSByZXR1cm5lZCBtb2RlbCB3aWxsIGNsZWFyIHRoZSBwcmV2aW91cyBzY29wZS5cbiAgICovXG4gIHN0YXRpYyBzY29wZShvcHRpb24pIHtcbiAgICBjb25zdCBzZWxmID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHt9O1xuICAgIGxldCBzY29wZTtcbiAgICBsZXQgc2NvcGVOYW1lO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICduYW1lJywgeyB2YWx1ZTogdGhpcy5uYW1lIH0pO1xuXG4gICAgc2VsZi5fc2NvcGUgPSB7fTtcbiAgICBzZWxmLl9zY29wZU5hbWVzID0gW107XG4gICAgc2VsZi5zY29wZWQgPSB0cnVlO1xuXG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmZsYXR0ZW4oYXJndW1lbnRzKTtcblxuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIHNjb3BlID0gbnVsbDtcbiAgICAgIHNjb3BlTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgICAgICBpZiAob3B0aW9uLm1ldGhvZCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbi5tZXRob2QpICYmICEhc2VsZi5vcHRpb25zLnNjb3Blc1tvcHRpb24ubWV0aG9kWzBdXSkge1xuICAgICAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uLm1ldGhvZFswXTtcbiAgICAgICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdLmFwcGx5KHNlbGYsIG9wdGlvbi5tZXRob2Quc2xpY2UoMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzZWxmLm9wdGlvbnMuc2NvcGVzW29wdGlvbi5tZXRob2RdKSB7XG4gICAgICAgICAgICBzY29wZU5hbWUgPSBvcHRpb24ubWV0aG9kO1xuICAgICAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV0uYXBwbHkoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlID0gb3B0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gJ2RlZmF1bHRTY29wZScgJiYgXy5pc1BsYWluT2JqZWN0KHNlbGYub3B0aW9ucy5kZWZhdWx0U2NvcGUpKSB7XG4gICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLmRlZmF1bHRTY29wZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbjtcbiAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzY29wZSA9IHNjb3BlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhzY29wZSwgdGhpcyk7XG4gICAgICAgIC8vIGNsb25lIHNjb3BlIHNvIGl0IGRvZXNuJ3QgZ2V0IG1vZGlmaWVkXG4gICAgICAgIHRoaXMuX2Fzc2lnbk9wdGlvbnMoc2VsZi5fc2NvcGUsIFV0aWxzLmNsb25lRGVlcChzY29wZSkpO1xuICAgICAgICBzZWxmLl9zY29wZU5hbWVzLnB1c2goc2NvcGVOYW1lID8gc2NvcGVOYW1lIDogJ2RlZmF1bHRTY29wZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5TZXF1ZWxpemVTY29wZUVycm9yKGBJbnZhbGlkIHNjb3BlICR7c2NvcGVOYW1lfSBjYWxsZWQuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBtdWx0aXBsZSBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlNpbXBsZSBzZWFyY2ggdXNpbmcgQU5EIGFuZCA9PC9jYXB0aW9uPlxuICAgKiBNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZToge1xuICAgKiAgICAgYXR0cjE6IDQyLFxuICAgKiAgICAgYXR0cjI6ICdjYWtlJ1xuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogIyBXSEVSRSBhdHRyMSA9IDQyIEFORCBhdHRyMiA9ICdjYWtlJ1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2luZyBncmVhdGVyIHRoYW4sIGxlc3MgdGhhbiBldGMuPC9jYXB0aW9uPlxuICAgKiBjb25zdCB7Z3QsIGx0ZSwgbmUsIGluOiBvcElufSA9IFNlcXVlbGl6ZS5PcDtcbiAgICpcbiAgICogTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IHtcbiAgICogICAgIGF0dHIxOiB7XG4gICAqICAgICAgIFtndF06IDUwXG4gICAqICAgICB9LFxuICAgKiAgICAgYXR0cjI6IHtcbiAgICogICAgICAgW2x0ZV06IDQ1XG4gICAqICAgICB9LFxuICAgKiAgICAgYXR0cjM6IHtcbiAgICogICAgICAgW29wSW5dOiBbMSwyLDNdXG4gICAqICAgICB9LFxuICAgKiAgICAgYXR0cjQ6IHtcbiAgICogICAgICAgW25lXTogNVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogIyBXSEVSRSBhdHRyMSA+IDUwIEFORCBhdHRyMiA8PSA0NSBBTkQgYXR0cjMgSU4gKDEsMiwzKSBBTkQgYXR0cjQgIT0gNVxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5RdWVyaWVzIHVzaW5nIE9SPC9jYXB0aW9uPlxuICAgKiBjb25zdCB7b3IsIGFuZCwgZ3QsIGx0fSA9IFNlcXVlbGl6ZS5PcDtcbiAgICpcbiAgICogTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IHtcbiAgICogICAgIG5hbWU6ICdhIHByb2plY3QnLFxuICAgKiAgICAgW29yXTogW1xuICAgKiAgICAgICB7aWQ6IFsxLCAyLCAzXX0sXG4gICAqICAgICAgIHtcbiAgICogICAgICAgICBbYW5kXTogW1xuICAgKiAgICAgICAgICAge2lkOiB7W2d0XTogMTB9fSxcbiAgICogICAgICAgICAgIHtpZDoge1tsdF06IDEwMH19XG4gICAqICAgICAgICAgXVxuICAgKiAgICAgICB9XG4gICAqICAgICBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogIyBXSEVSRSBgTW9kZWxgLmBuYW1lYCA9ICdhIHByb2plY3QnIEFORCAoYE1vZGVsYC5gaWRgIElOICgxLCAyLCAzKSBPUiAoYE1vZGVsYC5gaWRgID4gMTAgQU5EIGBNb2RlbGAuYGlkYCA8IDEwMCkpO1xuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBPcGVyYXRvcnN9IGZvciBwb3NzaWJsZSBvcGVyYXRvcnNcbiAgICogX19BbGlhc19fOiBfYWxsX1xuICAgKlxuICAgKiBUaGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIE1vZGVsIGluc3RhbmNlcyBpZiB0aGUgcXVlcnkgc3VjY2VlZHMuX1xuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zXSBBIGhhc2ggb2Ygb3B0aW9ucyB0byBkZXNjcmliZSB0aGUgc2NvcGUgb2YgdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLndoZXJlXSBBIGhhc2ggb2YgYXR0cmlidXRlcyB0byBkZXNjcmliZSB5b3VyIHNlYXJjaC4gU2VlIGFib3ZlIGZvciBleGFtcGxlcy5cbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPnxvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5hdHRyaWJ1dGVzXSBBIGxpc3Qgb2YgdGhlIGF0dHJpYnV0ZXMgdGhhdCB5b3Ugd2FudCB0byBzZWxlY3QsIG9yIGFuIG9iamVjdCB3aXRoIGBpbmNsdWRlYCBhbmQgYGV4Y2x1ZGVgIGtleXMuIFRvIHJlbmFtZSBhbiBhdHRyaWJ1dGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSwgd2l0aCB0d28gZWxlbWVudHMgLSB0aGUgZmlyc3QgaXMgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBpbiB0aGUgREIgKG9yIHNvbWUga2luZCBvZiBleHByZXNzaW9uIHN1Y2ggYXMgYFNlcXVlbGl6ZS5saXRlcmFsYCwgYFNlcXVlbGl6ZS5mbmAgYW5kIHNvIG9uKSwgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIG5hbWUgeW91IHdhbnQgdGhlIGF0dHJpYnV0ZSB0byBoYXZlIGluIHRoZSByZXR1cm5lZCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZV0gU2VsZWN0IGFsbCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwsIHBsdXMgc29tZSBhZGRpdGlvbmFsIG9uZXMuIFVzZWZ1bCBmb3IgYWdncmVnYXRpb25zLCBlLmcuIGB7IGF0dHJpYnV0ZXM6IHsgaW5jbHVkZTogW1tzZXF1ZWxpemUuZm4oJ0NPVU5UJywgc2VxdWVsaXplLmNvbCgnaWQnKSksICd0b3RhbCddXSB9YFxuICAgKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmF0dHJpYnV0ZXMuZXhjbHVkZV0gU2VsZWN0IGFsbCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwsIGV4Y2VwdCBzb21lIGZldy4gVXNlZnVsIGZvciBzZWN1cml0eSBwdXJwb3NlcyBlLmcuIGB7IGF0dHJpYnV0ZXM6IHsgZXhjbHVkZTogWydwYXNzd29yZCddIH0gfWBcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5wYXJhbm9pZD10cnVlXSBJZiB0cnVlLCBvbmx5IG5vbi1kZWxldGVkIHJlY29yZHMgd2lsbCBiZSByZXR1cm5lZC4gSWYgZmFsc2UsIGJvdGggZGVsZXRlZCBhbmQgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHJldHVybmVkLiBPbmx5IGFwcGxpZXMgaWYgYG9wdGlvbnMucGFyYW5vaWRgIGlzIHRydWUgZm9yIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtICB7QXJyYXk8b2JqZWN0fE1vZGVsfHN0cmluZz59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlXSBBIGxpc3Qgb2YgYXNzb2NpYXRpb25zIHRvIGVhZ2VybHkgbG9hZCB1c2luZyBhIGxlZnQgam9pbi4gU3VwcG9ydGVkIGlzIGVpdGhlciBgeyBpbmNsdWRlOiBbIE1vZGVsMSwgTW9kZWwyLCAuLi5dfWAgb3IgYHsgaW5jbHVkZTogW3sgbW9kZWw6IE1vZGVsMSwgYXM6ICdBbGlhcycgfV19YCBvciBgeyBpbmNsdWRlOiBbJ0FsaWFzJ119YC4gSWYgeW91ciBhc3NvY2lhdGlvbiBhcmUgc2V0IHVwIHdpdGggYW4gYGFzYCAoZWcuIGBYLmhhc01hbnkoWSwgeyBhczogJ1ogfWAsIHlvdSBuZWVkIHRvIHNwZWNpZnkgWiBpbiB0aGUgYXMgYXR0cmlidXRlIHdoZW4gZWFnZXIgbG9hZGluZyBZKS5cbiAgICogQHBhcmFtICB7TW9kZWx9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ubW9kZWxdIFRoZSBtb2RlbCB5b3Ugd2FudCB0byBlYWdlcmx5IGxvYWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uYXNdIFRoZSBhbGlhcyBvZiB0aGUgcmVsYXRpb24sIGluIGNhc2UgdGhlIG1vZGVsIHlvdSB3YW50IHRvIGVhZ2VybHkgbG9hZCBpcyBhbGlhc2VkLiBGb3IgYGhhc09uZWAgLyBgYmVsb25nc1RvYCwgdGhpcyBzaG91bGQgYmUgdGhlIHNpbmd1bGFyIG5hbWUsIGFuZCBmb3IgYGhhc01hbnlgLCBpdCBzaG91bGQgYmUgdGhlIHBsdXJhbFxuICAgKiBAcGFyYW0gIHtBc3NvY2lhdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5hc3NvY2lhdGlvbl0gVGhlIGFzc29jaWF0aW9uIHlvdSB3YW50IHRvIGVhZ2VybHkgbG9hZC4gKFRoaXMgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBwcm92aWRpbmcgYSBtb2RlbC9hcyBwYWlyKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS53aGVyZV0gV2hlcmUgY2xhdXNlcyB0byBhcHBseSB0byB0aGUgY2hpbGQgbW9kZWxzLiBOb3RlIHRoYXQgdGhpcyBjb252ZXJ0cyB0aGUgZWFnZXIgbG9hZCB0byBhbiBpbm5lciBqb2luLCB1bmxlc3MgeW91IGV4cGxpY2l0bHkgc2V0IGByZXF1aXJlZDogZmFsc2VgXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLm9yPWZhbHNlXSBXaGV0aGVyIHRvIGJpbmQgdGhlIE9OIGFuZCBXSEVSRSBjbGF1c2UgdG9nZXRoZXIgYnkgT1IgaW5zdGVhZCBvZiBBTkQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLm9uXSBTdXBwbHkgeW91ciBvd24gT04gY29uZGl0aW9uIGZvciB0aGUgam9pbi5cbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uYXR0cmlidXRlc10gQSBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gc2VsZWN0IGZyb20gdGhlIGNoaWxkIG1vZGVsXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnJlcXVpcmVkXSBJZiB0cnVlLCBjb252ZXJ0cyB0byBhbiBpbm5lciBqb2luLCB3aGljaCBtZWFucyB0aGF0IHRoZSBwYXJlbnQgbW9kZWwgd2lsbCBvbmx5IGJlIGxvYWRlZCBpZiBpdCBoYXMgYW55IG1hdGNoaW5nIGNoaWxkcmVuLiBUcnVlIGlmIGBpbmNsdWRlLndoZXJlYCBpcyBzZXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ucmlnaHRdIElmIHRydWUsIGNvbnZlcnRzIHRvIGEgcmlnaHQgam9pbiBpZiBkaWFsZWN0IHN1cHBvcnQgaXQuIElnbm9yZWQgaWYgYGluY2x1ZGUucmVxdWlyZWRgIGlzIHRydWUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnNlcGFyYXRlXSBJZiB0cnVlLCBydW5zIGEgc2VwYXJhdGUgcXVlcnkgdG8gZmV0Y2ggdGhlIGFzc29jaWF0ZWQgaW5zdGFuY2VzLCBvbmx5IHN1cHBvcnRlZCBmb3IgaGFzTWFueSBhc3NvY2lhdGlvbnNcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10ubGltaXRdIExpbWl0IHRoZSBqb2luZWQgcm93cywgb25seSBzdXBwb3J0ZWQgd2l0aCBpbmNsdWRlLnNlcGFyYXRlPXRydWVcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10udGhyb3VnaC5hc10gVGhlIGFsaWFzIGZvciB0aGUgam9pbiBtb2RlbCwgaW4gY2FzZSB5b3Ugd2FudCB0byBnaXZlIGl0IGEgZGlmZmVyZW50IG5hbWUgdGhhbiB0aGUgZGVmYXVsdCBvbmUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5jbHVkZVtdLnRocm91Z2gud2hlcmVdIEZpbHRlciBvbiB0aGUgam9pbiBtb2RlbCBmb3IgYmVsb25nc1RvTWFueSByZWxhdGlvbnNcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10udGhyb3VnaC5hdHRyaWJ1dGVzXSBBIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzZWxlY3QgZnJvbSB0aGUgam9pbiBtb2RlbCBmb3IgYmVsb25nc1RvTWFueSByZWxhdGlvbnNcbiAgICogQHBhcmFtICB7QXJyYXk8b2JqZWN0fE1vZGVsfHN0cmluZz59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pbmNsdWRlW10uaW5jbHVkZV0gTG9hZCBmdXJ0aGVyIG5lc3RlZCByZWxhdGVkIG1vZGVsc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmluY2x1ZGVbXS5kdXBsaWNhdGluZ10gTWFyayB0aGUgaW5jbHVkZSBhcyBkdXBsaWNhdGluZywgd2lsbCBwcmV2ZW50IGEgc3VicXVlcnkgZnJvbSBiZWluZyB1c2VkLlxuICAgKiBAcGFyYW0gIHtBcnJheXxTZXF1ZWxpemUuZm58U2VxdWVsaXplLmNvbHxTZXF1ZWxpemUubGl0ZXJhbH0gICAgICAgIFtvcHRpb25zLm9yZGVyXSBTcGVjaWZpZXMgYW4gb3JkZXJpbmcuIFVzaW5nIGFuIGFycmF5LCB5b3UgY2FuIHByb3ZpZGUgc2V2ZXJhbCBjb2x1bW5zIC8gZnVuY3Rpb25zIHRvIG9yZGVyIGJ5LiBFYWNoIGVsZW1lbnQgY2FuIGJlIGZ1cnRoZXIgd3JhcHBlZCBpbiBhIHR3by1lbGVtZW50IGFycmF5LiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgY29sdW1uIC8gZnVuY3Rpb24gdG8gb3JkZXIgYnksIHRoZSBzZWNvbmQgaXMgdGhlIGRpcmVjdGlvbi4gRm9yIGV4YW1wbGU6IGBvcmRlcjogW1snbmFtZScsICdERVNDJ11dYC4gSW4gdGhpcyB3YXkgdGhlIGNvbHVtbiB3aWxsIGJlIGVzY2FwZWQsIGJ1dCB0aGUgZGlyZWN0aW9uIHdpbGwgbm90LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLmxpbWl0XSBMaW1pdCBmb3IgcmVzdWx0XG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMub2Zmc2V0XSBPZmZzZXQgZm9yIHJlc3VsdFxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfG9iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5sb2NrXSBMb2NrIHRoZSBzZWxlY3RlZCByb3dzLiBQb3NzaWJsZSBvcHRpb25zIGFyZSB0cmFuc2FjdGlvbi5MT0NLLlVQREFURSBhbmQgdHJhbnNhY3Rpb24uTE9DSy5TSEFSRS4gUG9zdGdyZXMgYWxzbyBzdXBwb3J0cyB0cmFuc2FjdGlvbi5MT0NLLktFWV9TSEFSRSwgdHJhbnNhY3Rpb24uTE9DSy5OT19LRVlfVVBEQVRFIGFuZCBzcGVjaWZpYyBtb2RlbCBsb2NrcyB3aXRoIGpvaW5zLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnNraXBMb2NrZWRdIFNraXAgbG9ja2VkIHJvd3MuIE9ubHkgc3VwcG9ydGVkIGluIFBvc3RncmVzLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnJhd10gUmV0dXJuIHJhdyByZXN1bHQuIFNlZSBzZXF1ZWxpemUucXVlcnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5oYXZpbmddIEhhdmluZyBvcHRpb25zXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgc2NoZW1hIHNlYXJjaF9wYXRoIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0gIHtib29sZWFufEVycm9yfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnJlamVjdE9uRW1wdHk9ZmFsc2VdIFRocm93cyBhbiBlcnJvciB3aGVuIG5vIHJlY29yZHMgZm91bmRcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgU2VxdWVsaXplI3F1ZXJ5fVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNb2RlbD4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRBbGwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5RdWVyeUVycm9yKCdUaGUgYXJndW1lbnQgcGFzc2VkIHRvIGZpbmRBbGwgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuUXVlcnlFcnJvcignVGhlIGF0dHJpYnV0ZXMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgb2YgY29sdW1uIG5hbWVzIG9yIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMud2Fybk9uSW52YWxpZE9wdGlvbnMob3B0aW9ucywgT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKSk7XG5cbiAgICBjb25zdCB0YWJsZU5hbWVzID0ge307XG5cbiAgICB0YWJsZU5hbWVzW3RoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpXSA9IHRydWU7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgeyBob29rczogdHJ1ZSB9KTtcblxuICAgIC8vIHNldCByZWplY3RPbkVtcHR5IG9wdGlvbiwgZGVmYXVsdHMgdG8gbW9kZWwgb3B0aW9uc1xuICAgIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAncmVqZWN0T25FbXB0eScpXG4gICAgICA/IG9wdGlvbnMucmVqZWN0T25FbXB0eVxuICAgICAgOiB0aGlzLm9wdGlvbnMucmVqZWN0T25FbXB0eTtcblxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUZpbmQnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIHRoaXMuX2V4cGFuZEF0dHJpYnV0ZXMob3B0aW9ucyk7XG4gICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzID0gdGhpcy5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcblxuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIG9wdGlvbnMuaGFzSm9pbiA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zLCB0YWJsZU5hbWVzKTtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHJhdywgd2UgaGF2ZSB0byBtYWtlIHN1cmUgd2UgaW5jbHVkZSB0aGUgcHJpbWFyeSBrZXkgZm9yIGRlLWR1cGxpY2F0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgICAmJiAhb3B0aW9ucy5yYXdcbiAgICAgICAgJiYgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICAgICYmICFvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZXModGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlKVxuICAgICAgICAmJiAoIW9wdGlvbnMuZ3JvdXAgfHwgIW9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uKVxuICAgICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFt0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmNvbmNhdChvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgb3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgPSB0aGlzLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIC8vIHdoZXJlQ29sbGVjdGlvbiBpcyB1c2VkIGZvciBub24tcHJpbWFyeSBrZXkgdXBkYXRlc1xuICAgIHRoaXMub3B0aW9ucy53aGVyZUNvbGxlY3Rpb24gPSBvcHRpb25zLndoZXJlIHx8IG51bGw7XG5cbiAgICBVdGlscy5tYXBGaW5kZXJPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUZpbmRBZnRlck9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdGFibGVOYW1lczogT2JqZWN0LmtleXModGFibGVOYW1lcykgfTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5zZWxlY3QodGhpcywgdGhpcy5nZXRUYWJsZU5hbWUoc2VsZWN0T3B0aW9ucyksIHNlbGVjdE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlckZpbmQnLCByZXN1bHRzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvL3JlamVjdE9uRW1wdHkgbW9kZVxuICAgIGlmIChfLmlzRW1wdHkocmVzdWx0cykgJiYgb3B0aW9ucy5yZWplY3RPbkVtcHR5KSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgb3B0aW9ucy5yZWplY3RPbkVtcHR5KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgb3B0aW9ucy5yZWplY3RPbkVtcHR5O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FbXB0eVJlc3VsdEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IE1vZGVsLl9maW5kU2VwYXJhdGUocmVzdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgd2Fybk9uSW52YWxpZE9wdGlvbnMob3B0aW9ucywgdmFsaWRDb2x1bW5OYW1lcykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdW5yZWNvZ25pemVkT3B0aW9ucyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcihrID0+ICF2YWxpZFF1ZXJ5S2V5d29yZHMuaGFzKGspKTtcbiAgICBjb25zdCB1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzID0gXy5pbnRlcnNlY3Rpb24odW5yZWNvZ25pemVkT3B0aW9ucywgdmFsaWRDb2x1bW5OYW1lcyk7XG4gICAgaWYgKCFvcHRpb25zLndoZXJlICYmIHVuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE1vZGVsIGF0dHJpYnV0ZXMgKCR7dW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcy5qb2luKCcsICcpfSkgcGFzc2VkIGludG8gZmluZGVyIG1ldGhvZCBvcHRpb25zIG9mIG1vZGVsICR7dGhpcy5uYW1lfSwgYnV0IHRoZSBvcHRpb25zLndoZXJlIG9iamVjdCBpcyBlbXB0eS4gRGlkIHlvdSBmb3JnZXQgdG8gdXNlIG9wdGlvbnMud2hlcmU/YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNWaXJ0dWFsQXR0cmlidXRlcykgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8ICFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSByZXR1cm4gYXR0cmlidXRlcztcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZSlcbiAgICAgICAgJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0udHlwZS5maWVsZHNcbiAgICAgICkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQodGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0udHlwZS5maWVsZHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMgPSBfLnVuaXEoYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBfZmluZFNlcGFyYXRlKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSB8fCBvcHRpb25zLnJhdyB8fCAhcmVzdWx0cykgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHJlc3VsdHM7XG4gICAgaWYgKG9wdGlvbnMucGxhaW4pIHJlc3VsdHMgPSBbcmVzdWx0c107XG5cbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luYWw7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLmluY2x1ZGUubWFwKGFzeW5jIGluY2x1ZGUgPT4ge1xuICAgICAgaWYgKCFpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBNb2RlbC5fZmluZFNlcGFyYXRlKFxuICAgICAgICAgIHJlc3VsdHMucmVkdWNlKChtZW1vLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGxldCBhc3NvY2lhdGlvbnMgPSByZXN1bHQuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uYXMpO1xuXG4gICAgICAgICAgICAvLyBNaWdodCBiZSBhbiBlbXB0eSBiZWxvbmdzVG8gcmVsYXRpb25cbiAgICAgICAgICAgIGlmICghYXNzb2NpYXRpb25zKSByZXR1cm4gbWVtbztcblxuICAgICAgICAgICAgLy8gRm9yY2UgYXJyYXkgc28gd2UgY2FuIGNvbmNhdCBubyBtYXR0ZXIgaWYgaXQncyAxOjEgb3IgOk1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NvY2lhdGlvbnMpKSBhc3NvY2lhdGlvbnMgPSBbYXNzb2NpYXRpb25zXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFzc29jaWF0aW9ucy5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIG1lbW8ucHVzaChhc3NvY2lhdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgW10pLFxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgLi4uXy5vbWl0KG9wdGlvbnMsICdpbmNsdWRlJywgJ2F0dHJpYnV0ZXMnLCAnb3JkZXInLCAnd2hlcmUnLCAnbGltaXQnLCAnb2Zmc2V0JywgJ3BsYWluJywgJ3Njb3BlJyksXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlLmluY2x1ZGUgfHwgW11cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24uZ2V0KHJlc3VsdHMsIHtcblxuICAgICAgICAuLi5fLm9taXQob3B0aW9ucywgbm9uQ2FzY2FkaW5nT3B0aW9ucyksXG4gICAgICAgIC4uLl8ub21pdChpbmNsdWRlLCBbJ3BhcmVudCcsICdhc3NvY2lhdGlvbicsICdhcycsICdvcmlnaW5hbEF0dHJpYnV0ZXMnXSlcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgaW5jbHVkZS5hc3NvY2lhdGlvbi5hcyxcbiAgICAgICAgICBtYXBbcmVzdWx0LmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSldLFxuICAgICAgICAgIHsgcmF3OiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBhIHNpbmdsZSBpbnN0YW5jZSBieSBpdHMgcHJpbWFyeSBrZXkuX1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfEJ1ZmZlcn0gICAgICBwYXJhbSBUaGUgdmFsdWUgb2YgdGhlIGRlc2lyZWQgaW5zdGFuY2UncyBwcmltYXJ5IGtleS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgW29wdGlvbnNdIGZpbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgICAgICAgICAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gICAgICAgICAgIGZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2Ygb3B0aW9ucywgTm90ZSB0aGF0IG9wdGlvbnMud2hlcmUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRCeVBrKHBhcmFtLCBvcHRpb25zKSB7XG4gICAgLy8gcmV0dXJuIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBudWxsIGlmIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgaWYgKFtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHBhcmFtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKHBhcmFtKSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgICAgW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV06IHBhcmFtXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQnlQayBpcyBpbnZhbGlkOiAke3BhcmFtfWApO1xuICAgIH1cblxuICAgIC8vIEJ5cGFzcyBhIHBvc3NpYmxlIG92ZXJsb2FkZWQgZmluZE9uZVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBhIHNpbmdsZSBpbnN0YW5jZS4gUmV0dXJucyB0aGUgZmlyc3QgaW5zdGFuY2UgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBjYW4gYmUgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgW29wdGlvbnNdIEEgaGFzaCBvZiBvcHRpb25zIHRvIGRlc2NyaWJlIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gZm9yIGFuIGV4cGxhbmF0aW9uIG9mIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWx8bnVsbD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZE9uZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZE9uZSBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMubGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdW5pcXVlU2luZ2xlQ29sdW1ucyA9IF8uY2hhaW4odGhpcy51bmlxdWVLZXlzKS52YWx1ZXMoKS5maWx0ZXIoYyA9PiBjLmZpZWxkcy5sZW5ndGggPT09IDEpLm1hcCgnY29sdW1uJykudmFsdWUoKTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIGxpbWl0IGlmIHF1ZXJ5aW5nIGRpcmVjdGx5IG9uIHRoZSBwayBvciBhIHVuaXF1ZSBjb2x1bW5cbiAgICAgIGlmICghb3B0aW9ucy53aGVyZSB8fCAhXy5zb21lKG9wdGlvbnMud2hlcmUsICh2YWx1ZSwga2V5KSA9PlxuICAgICAgICAoa2V5ID09PSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgfHwgdW5pcXVlU2luZ2xlQ29sdW1ucy5pbmNsdWRlcyhrZXkpKSAmJlxuICAgICAgICAgIChVdGlscy5pc1ByaW1pdGl2ZSh2YWx1ZSkgfHwgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSlcbiAgICAgICkpIHtcbiAgICAgICAgb3B0aW9ucy5saW1pdCA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnlwYXNzIGEgcG9zc2libGUgb3ZlcmxvYWRlZCBmaW5kQWxsLlxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRBbGwoXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBwbGFpbjogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYW4gYWdncmVnYXRpb24gbWV0aG9kIG9uIHRoZSBzcGVjaWZpZWQgZmllbGRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIGF0dHJpYnV0ZSBUaGUgYXR0cmlidXRlIHRvIGFnZ3JlZ2F0ZSBvdmVyLiBDYW4gYmUgYSBmaWVsZCBuYW1lIG9yICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0byB1c2UgZm9yIGFnZ3JlZ2F0aW9uLCBlLmcuIHN1bSwgbWF4IGV0Yy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zXSBRdWVyeSBvcHRpb25zLiBTZWUgc2VxdWVsaXplLnF1ZXJ5IGZvciBmdWxsIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zLndoZXJlXSBBIGhhc2ggb2Ygc2VhcmNoIGF0dHJpYnV0ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSB7RGF0YVR5cGVzfHN0cmluZ30gW29wdGlvbnMuZGF0YVR5cGVdIFRoZSB0eXBlIG9mIHRoZSByZXN1bHQuIElmIGBmaWVsZGAgaXMgYSBmaWVsZCBpbiB0aGlzIE1vZGVsLCB0aGUgZGVmYXVsdCB3aWxsIGJlIHRoZSB0eXBlIG9mIHRoYXQgZmllbGQsIG90aGVyd2lzZSBkZWZhdWx0cyB0byBmbG9hdC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmRpc3RpbmN0XSBBcHBsaWVzIERJU1RJTkNUIHRvIHRoZSBmaWVsZCBiZWluZyBhZ2dyZWdhdGVkIG92ZXJcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLnBsYWluXSBXaGVuIGB0cnVlYCwgdGhlIGZpcnN0IHJldHVybmVkIHZhbHVlIG9mIGBhZ2dyZWdhdGVGdW5jdGlvbmAgaXMgY2FzdCB0byBgZGF0YVR5cGVgIGFuZCByZXR1cm5lZC4gSWYgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIGFyZSBzcGVjaWZpZWQsIGFsb25nIHdpdGggYGdyb3VwYCBjbGF1c2VzLCBzZXQgYHBsYWluYCB0byBgZmFsc2VgIHRvIHJldHVybiBhbGwgdmFsdWVzIG9mIGFsbCByZXR1cm5lZCByb3dzLiAgRGVmYXVsdHMgdG8gYHRydWVgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERhdGFUeXBlc3xvYmplY3Q+fSBSZXR1cm5zIHRoZSBhZ2dyZWdhdGUgcmVzdWx0IGNhc3QgdG8gYG9wdGlvbnMuZGF0YVR5cGVgLCB1bmxlc3MgYG9wdGlvbnMucGxhaW5gIGlzIGZhbHNlLCBpbiB3aGljaCBjYXNlIHRoZSBjb21wbGV0ZSBkYXRhIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBhZ2dyZWdhdGUoYXR0cmlidXRlLCBhZ2dyZWdhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIGF0dHJpYnV0ZXMgaGVyZSBhcyB0aGUgYGluamVjdFNjb3BlYCBjYWxsIHdvdWxkIGluamVjdCBub24gYWdncmVnYXRlIGNvbHVtbnMuXG4gICAgY29uc3QgcHJldkF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gcHJldkF0dHJpYnV0ZXM7XG4gICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyT3B0aW9ucyA9IHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIGNvbnN0IGZpZWxkID0gYXR0ck9wdGlvbnMgJiYgYXR0ck9wdGlvbnMuZmllbGQgfHwgYXR0cmlidXRlO1xuICAgIGxldCBhZ2dyZWdhdGVDb2x1bW4gPSB0aGlzLnNlcXVlbGl6ZS5jb2woZmllbGQpO1xuXG4gICAgaWYgKG9wdGlvbnMuZGlzdGluY3QpIHtcbiAgICAgIGFnZ3JlZ2F0ZUNvbHVtbiA9IHRoaXMuc2VxdWVsaXplLmZuKCdESVNUSU5DVCcsIGFnZ3JlZ2F0ZUNvbHVtbik7XG4gICAgfVxuXG4gICAgbGV0IHsgZ3JvdXAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ3JvdXApICYmIEFycmF5LmlzQXJyYXkoZ3JvdXBbMF0pKSB7XG4gICAgICBub0RvdWJsZU5lc3RlZEdyb3VwKCk7XG4gICAgICBncm91cCA9IF8uZmxhdHRlbihncm91cCk7XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IF8udW5pb25CeShcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgIGdyb3VwLFxuICAgICAgW1t0aGlzLnNlcXVlbGl6ZS5mbihhZ2dyZWdhdGVGdW5jdGlvbiwgYWdncmVnYXRlQ29sdW1uKSwgYWdncmVnYXRlRnVuY3Rpb25dXSxcbiAgICAgIGEgPT4gQXJyYXkuaXNBcnJheShhKSA/IGFbMV0gOiBhXG4gICAgKTtcblxuICAgIGlmICghb3B0aW9ucy5kYXRhVHlwZSkge1xuICAgICAgaWYgKGF0dHJPcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBhdHRyT3B0aW9ucy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIEZMT0FUIGFzIGZhbGxiYWNrXG4gICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGVzLkZMT0FUKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVEYXRhVHlwZShvcHRpb25zLmRhdGFUeXBlKTtcbiAgICB9XG5cbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yYXdTZWxlY3QodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMsIGFnZ3JlZ2F0ZUZ1bmN0aW9uLCB0aGlzKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ291bnQgdGhlIG51bWJlciBvZiByZWNvcmRzIG1hdGNoaW5nIHRoZSBwcm92aWRlZCB3aGVyZSBjbGF1c2UuXG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIGFuIGBpbmNsdWRlYCBvcHRpb24sIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgYXNzb2NpYXRpb25zIHdpbGwgYmUgY291bnRlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgIFtvcHRpb25zXSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgW29wdGlvbnMud2hlcmVdIEEgaGFzaCBvZiBzZWFyY2ggYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICBbb3B0aW9ucy5pbmNsdWRlXSBJbmNsdWRlIG9wdGlvbnMuIFNlZSBgZmluZGAgZm9yIGRldGFpbHNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBbb3B0aW9ucy5wYXJhbm9pZD10cnVlXSBTZXQgYHRydWVgIHRvIGNvdW50IG9ubHkgbm9uLWRlbGV0ZWQgcmVjb3Jkcy4gQ2FuIGJlIHVzZWQgb24gbW9kZWxzIHdpdGggYHBhcmFub2lkYCBlbmFibGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgW29wdGlvbnMuZGlzdGluY3RdIEFwcGx5IENPVU5UKERJU1RJTkNUKGNvbCkpIG9uIHByaW1hcnkga2V5IG9yIG9uIG9wdGlvbnMuY29sLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIFtvcHRpb25zLmNvbF0gQ29sdW1uIG9uIHdoaWNoIENPVU5UKCkgc2hvdWxkIGJlIGFwcGxpZWRcbiAgICogQHBhcmFtIHtBcnJheX0gICAgICAgICBbb3B0aW9ucy5hdHRyaWJ1dGVzXSBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGdyb3VwYFxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIFtvcHRpb25zLmdyb3VwXSBGb3IgY3JlYXRpbmcgY29tcGxleCBjb3VudHMuIFdpbGwgcmV0dXJuIG11bHRpcGxlIHJvd3MgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBjb3VudChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7IGhvb2tzOiB0cnVlIH0pO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ291bnQnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IGNvbCA9IG9wdGlvbnMuY29sIHx8ICcqJztcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBjb2wgPSBgJHt0aGlzLm5hbWV9LiR7b3B0aW9ucy5jb2wgfHwgdGhpcy5wcmltYXJ5S2V5RmllbGR9YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGlzdGluY3QgJiYgY29sID09PSAnKicpIHtcbiAgICAgIGNvbCA9IHRoaXMucHJpbWFyeUtleUZpZWxkO1xuICAgIH1cbiAgICBvcHRpb25zLnBsYWluID0gIW9wdGlvbnMuZ3JvdXA7XG4gICAgb3B0aW9ucy5kYXRhVHlwZSA9IG5ldyBEYXRhVHlwZXMuSU5URUdFUigpO1xuICAgIG9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuICAgIC8vIE5vIGxpbWl0LCBvZmZzZXQgb3Igb3JkZXIgZm9yIHRoZSBvcHRpb25zIG1heCBiZSBnaXZlbiB0byBjb3VudCgpXG4gICAgLy8gU2V0IHRoZW0gdG8gbnVsbCB0byBwcmV2ZW50IHNjb3BlcyBzZXR0aW5nIHRob3NlIHZhbHVlc1xuICAgIG9wdGlvbnMubGltaXQgPSBudWxsO1xuICAgIG9wdGlvbnMub2Zmc2V0ID0gbnVsbDtcbiAgICBvcHRpb25zLm9yZGVyID0gbnVsbDtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShjb2wsICdjb3VudCcsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIHRoZSByb3dzIG1hdGNoaW5nIHlvdXIgcXVlcnksIHdpdGhpbiBhIHNwZWNpZmllZCBvZmZzZXQgLyBsaW1pdCwgYW5kIGdldCB0aGUgdG90YWwgbnVtYmVyIG9mIHJvd3MgbWF0Y2hpbmcgeW91ciBxdWVyeS4gVGhpcyBpcyB2ZXJ5IHVzZWZ1bCBmb3IgcGFnaW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IE1vZGVsLmZpbmRBbmRDb3VudEFsbCh7XG4gICAqICAgd2hlcmU6IC4uLixcbiAgICogICBsaW1pdDogMTIsXG4gICAqICAgb2Zmc2V0OiAxMlxuICAgKiB9KTtcbiAgICpcbiAgICogIyBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgYHJlc3VsdC5yb3dzYCB3aWxsIGNvbnRhaW4gcm93cyAxMyB0aHJvdWdoIDI0LCB3aGlsZSBgcmVzdWx0LmNvdW50YCB3aWxsIHJldHVybiB0aGUgdG90YWwgbnVtYmVyIG9mIHJvd3MgdGhhdCBtYXRjaGVkIHlvdXIgcXVlcnkuXG4gICAqXG4gICAqICMgV2hlbiB5b3UgYWRkIGluY2x1ZGVzLCBvbmx5IHRob3NlIHdoaWNoIGFyZSByZXF1aXJlZCAoZWl0aGVyIGJlY2F1c2UgdGhleSBoYXZlIGEgd2hlcmUgY2xhdXNlLCBvciBiZWNhdXNlIGByZXF1aXJlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZSBvbiB0aGUgaW5jbHVkZSkgd2lsbCBiZSBhZGRlZCB0byB0aGUgY291bnQgcGFydC5cbiAgICpcbiAgICogIyBTdXBwb3NlIHlvdSB3YW50IHRvIGZpbmQgYWxsIHVzZXJzIHdobyBoYXZlIGEgcHJvZmlsZSBhdHRhY2hlZDpcbiAgICpcbiAgICogVXNlci5maW5kQW5kQ291bnRBbGwoe1xuICAgKiAgIGluY2x1ZGU6IFtcbiAgICogICAgICB7IG1vZGVsOiBQcm9maWxlLCByZXF1aXJlZDogdHJ1ZX1cbiAgICogICBdLFxuICAgKiAgIGxpbWl0OiAzXG4gICAqIH0pO1xuICAgKlxuICAgKiAjIEJlY2F1c2UgdGhlIGluY2x1ZGUgZm9yIGBQcm9maWxlYCBoYXMgYHJlcXVpcmVkYCBzZXQgaXQgd2lsbCByZXN1bHQgaW4gYW4gaW5uZXIgam9pbiwgYW5kIG9ubHkgdGhlIHVzZXJzIHdobyBoYXZlIGEgcHJvZmlsZSB3aWxsIGJlIGNvdW50ZWQuIElmIHdlIHJlbW92ZSBgcmVxdWlyZWRgIGZyb20gdGhlIGluY2x1ZGUsIGJvdGggdXNlcnMgd2l0aCBhbmQgd2l0aG91dCBwcm9maWxlcyB3aWxsIGJlIGNvdW50ZWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUgZmluZEFsbCBvcHRpb25zXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9IGZvciBhIHNwZWNpZmljYXRpb24gb2YgZmluZCBhbmQgcXVlcnkgb3B0aW9uc1xuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5jb3VudH0gZm9yIGEgc3BlY2lmaWNhdGlvbiBvZiBjb3VudCBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtjb3VudDogbnVtYmVyLCByb3dzOiBNb2RlbFtdfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZEFuZENvdW50QWxsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQW5kQ291bnRBbGwgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3VudE9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICBpZiAoY291bnRPcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvdW50T3B0aW9ucy5hdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IFtjb3VudCwgcm93c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLmNvdW50KGNvdW50T3B0aW9ucyksXG4gICAgICB0aGlzLmZpbmRBbGwob3B0aW9ucylcbiAgICBdKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb3VudCxcbiAgICAgIHJvd3M6IGNvdW50ID09PSAwID8gW10gOiByb3dzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGZpZWxkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBhdHRyaWJ1dGUgLyBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIGFnZ3JlZ2F0ZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5hZ2dyZWdhdGV9IGZvciBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIG1heChmaWVsZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShmaWVsZCwgJ21heCcsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1pbmltdW0gdmFsdWUgb2YgZmllbGRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIGF0dHJpYnV0ZSAvIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUgYWdncmVnYXRlXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmFnZ3JlZ2F0ZX0gZm9yIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbWluKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCAnbWluJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgc3VtIG9mIGZpZWxkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBhdHRyaWJ1dGUgLyBmaWVsZCBuYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIGFnZ3JlZ2F0ZVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5hZ2dyZWdhdGV9IGZvciBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3VtKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCAnc3VtJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgbmV3IG1vZGVsIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gdmFsdWVzIEFuIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnMgb3IgYW4gYXJyYXkgb2Ygc3VjaC4gSWYgYW4gYXJyYXksIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBpbnN0YW5jZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgW29wdGlvbnNdIEluc3RhbmNlIGJ1aWxkIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yYXc9ZmFsc2VdIElmIHNldCB0byB0cnVlLCB2YWx1ZXMgd2lsbCBpZ25vcmUgZmllbGQgYW5kIHZpcnR1YWwgc2V0dGVycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc05ld1JlY29yZD10cnVlXSBJcyB0aGlzIG5ldyByZWNvcmRcbiAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5pbmNsdWRlXSBhbiBhcnJheSBvZiBpbmNsdWRlIG9wdGlvbnMgLSBVc2VkIHRvIGJ1aWxkIHByZWZldGNoZWQvaW5jbHVkZWQgbW9kZWwgaW5zdGFuY2VzLiBTZWUgYHNldGBcbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfEFycmF5PE1vZGVsPn1cbiAgICovXG4gIHN0YXRpYyBidWlsZCh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWxrQnVpbGQodmFsdWVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXModmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBidWxrQnVpbGQodmFsdWVTZXRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgaXNOZXdSZWNvcmQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcblxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKGF0dHJpYnV0ZSA9PiBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZSkgPyBhdHRyaWJ1dGVbMV0gOiBhdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVNldHMubWFwKHZhbHVlcyA9PiB0aGlzLmJ1aWxkKHZhbHVlcywgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG5ldyBtb2RlbCBpbnN0YW5jZSBhbmQgY2FsbHMgc2F2ZSBvbiBpdC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuYnVpbGR9XG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLnNhdmV9XG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICB2YWx1ZXMgICAgICAgICAgICAgICAgICAgICAgIEhhc2ggb2YgZGF0YSB2YWx1ZXMgdG8gY3JlYXRlIG5ldyByZWNvcmQgd2l0aFxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICBCdWlsZCBhbmQgcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMucmF3PWZhbHNlXSAgICAgICAgICBJZiBzZXQgdG8gdHJ1ZSwgdmFsdWVzIHdpbGwgaWdub3JlIGZpZWxkIGFuZCB2aXJ0dWFsIHNldHRlcnMuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5pc05ld1JlY29yZD10cnVlXSAgIElzIHRoaXMgbmV3IHJlY29yZFxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgW29wdGlvbnMuaW5jbHVkZV0gICAgICAgICAgICBBbiBhcnJheSBvZiBpbmNsdWRlIG9wdGlvbnMgLSBVc2VkIHRvIGJ1aWxkIHByZWZldGNoZWQvaW5jbHVkZWQgbW9kZWwgaW5zdGFuY2VzLiBTZWUgYHNldGBcbiAgICogQHBhcmFtICB7c3RyaW5nW119ICAgICAgIFtvcHRpb25zLmZpZWxkc10gICAgICAgICAgICAgQW4gb3B0aW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgcmVwcmVzZW50aW5nIGRhdGFiYXNlIGNvbHVtbnMuIElmIGZpZWxkcyBpcyBwcm92aWRlZCwgb25seSB0aG9zZSBjb2x1bW5zIHdpbGwgYmUgdmFsaWRhdGVkIGFuZCBzYXZlZC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnNpbGVudD1mYWxzZV0gICAgICAgSWYgdHJ1ZSwgdGhlIHVwZGF0ZWRBdCB0aW1lc3RhbXAgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnZhbGlkYXRlPXRydWVdICAgICAgSWYgZmFsc2UsIHZhbGlkYXRpb25zIHdvbid0IGJlIHJ1bi5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgUnVuIGJlZm9yZSBhbmQgYWZ0ZXIgY3JlYXRlIC8gdXBkYXRlICsgdmFsaWRhdGUgaG9va3NcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtICB7Ym9vbGVhbnxBcnJheX0gIFtvcHRpb25zLnJldHVybmluZz10cnVlXSAgICAgQXBwZW5kcyBSRVRVUk5JTkcgPG1vZGVsIGNvbHVtbnM+IHRvIGdldCBiYWNrIGFsbCBkZWZpbmVkIHZhbHVlczsgaWYgYW4gYXJyYXkgb2YgY29sdW1uIG5hbWVzLCBhcHBlbmQgUkVUVVJOSU5HIDxjb2x1bW5zPiB0byBnZXQgYmFjayBzcGVjaWZpYyBjb2x1bW5zIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbD59XG4gICAqXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyB8fCB7fSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5idWlsZCh2YWx1ZXMsIHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5maWVsZHMsXG4gICAgICBpbmNsdWRlOiBvcHRpb25zLmluY2x1ZGUsXG4gICAgICByYXc6IG9wdGlvbnMucmF3LFxuICAgICAgc2lsZW50OiBvcHRpb25zLnNpbGVudFxuICAgIH0pLnNhdmUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHJvdyB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LCBvciBidWlsZCAoYnV0IGRvbid0IHNhdmUpIHRoZSByb3cgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICogVGhlIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIHRoZSBwcm9taXNlIHdpbGwgYmUgKGluc3RhbmNlLCBidWlsdClcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgb3B0aW9ucyBmaW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgb3B0aW9ucy53aGVyZSBBIGhhc2ggb2Ygc2VhcmNoIGF0dHJpYnV0ZXMuIElmIGB3aGVyZWAgaXMgYSBwbGFpbiBvYmplY3QgaXQgd2lsbCBiZSBhcHBlbmRlZCB3aXRoIGRlZmF1bHRzIHRvIGJ1aWxkIGEgbmV3IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5kZWZhdWx0c10gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIGlmIGJ1aWxkaW5nIGEgbmV3IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWwsYm9vbGVhbj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZE9yQnVpbGQob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kT3JCdWlsZC4gJyArXG4gICAgICAgICdQbGVhc2Ugbm90ZSB0aGF0IHRoZSBBUEkgaGFzIGNoYW5nZWQsIGFuZCBpcyBub3cgb3B0aW9ucyBvbmx5IChhbiBvYmplY3Qgd2l0aCB3aGVyZSwgZGVmYXVsdHMga2V5cywgdHJhbnNhY3Rpb24gZXRjLiknXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB2YWx1ZXM7XG5cbiAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSB7IC4uLm9wdGlvbnMuZGVmYXVsdHMgfTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkKHZhbHVlcywgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBbaW5zdGFuY2UsIHRydWVdO1xuICAgIH1cblxuICAgIHJldHVybiBbaW5zdGFuY2UsIGZhbHNlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgcm93IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnksIG9yIGJ1aWxkIGFuZCBzYXZlIHRoZSByb3cgaWYgbm9uZSBpcyBmb3VuZFxuICAgKiBUaGUgc3VjY2Vzc2Z1bCByZXN1bHQgb2YgdGhlIHByb21pc2Ugd2lsbCBiZSAoaW5zdGFuY2UsIGNyZWF0ZWQpXG4gICAqXG4gICAqIElmIG5vIHRyYW5zYWN0aW9uIGlzIHBhc3NlZCBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYSBuZXcgdHJhbnNhY3Rpb24gd2lsbCBiZSBjcmVhdGVkIGludGVybmFsbHksIHRvIHByZXZlbnQgdGhlIHJhY2UgY29uZGl0aW9uIHdoZXJlIGEgbWF0Y2hpbmcgcm93IGlzIGNyZWF0ZWQgYnkgYW5vdGhlciBjb25uZWN0aW9uIGFmdGVyIHRoZSBmaW5kIGJ1dCBiZWZvcmUgdGhlIGluc2VydCBjYWxsLlxuICAgKiBIb3dldmVyLCBpdCBpcyBub3QgYWx3YXlzIHBvc3NpYmxlIHRvIGhhbmRsZSB0aGlzIGNhc2UgaW4gU1FMaXRlLCBzcGVjaWZpY2FsbHkgaWYgb25lIHRyYW5zYWN0aW9uIGluc2VydHMgYW5kIGFub3RoZXIgdHJpZXMgdG8gc2VsZWN0IGJlZm9yZSB0aGUgZmlyc3Qgb25lIGhhcyBjb21taXR0ZWQuIEluIHRoaXMgY2FzZSwgYW4gaW5zdGFuY2Ugb2Ygc2VxdWVsaXplLiBUaW1lb3V0RXJyb3Igd2lsbCBiZSB0aHJvd24gaW5zdGVhZC5cbiAgICogSWYgYSB0cmFuc2FjdGlvbiBpcyBjcmVhdGVkLCBhIHNhdmVwb2ludCB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZCwgYW5kIGFueSB1bmlxdWUgY29uc3RyYWludCB2aW9sYXRpb24gd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHkuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9IGZvciBhIGZ1bGwgc3BlY2lmaWNhdGlvbiBvZiBmaW5kIGFuZCBvcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIG9wdGlvbnMgZmluZCBhbmQgY3JlYXRlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgb3B0aW9ucy53aGVyZSB3aGVyZSBBIGhhc2ggb2Ygc2VhcmNoIGF0dHJpYnV0ZXMuIElmIGB3aGVyZWAgaXMgYSBwbGFpbiBvYmplY3QgaXQgd2lsbCBiZSBhcHBlbmRlZCB3aXRoIGRlZmF1bHRzIHRvIGJ1aWxkIGEgbmV3IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9ucy5kZWZhdWx0c10gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIGlmIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWwsYm9vbGVhbj59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZE9yQ3JlYXRlKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ01pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZE9yQ3JlYXRlLiAnICtcbiAgICAgICAgJ1BsZWFzZSBub3RlIHRoYXQgdGhlIEFQSSBoYXMgY2hhbmdlZCwgYW5kIGlzIG5vdyBvcHRpb25zIG9ubHkgKGFuIG9iamVjdCB3aXRoIHdoZXJlLCBkZWZhdWx0cyBrZXlzLCB0cmFuc2FjdGlvbiBldGMuKSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gT2JqZWN0LmtleXMob3B0aW9ucy5kZWZhdWx0cyk7XG4gICAgICBjb25zdCB1bmtub3duRGVmYXVsdHMgPSBkZWZhdWx0cy5maWx0ZXIobmFtZSA9PiAhdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdKTtcblxuICAgICAgaWYgKHVua25vd25EZWZhdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYFVua25vd24gYXR0cmlidXRlcyAoJHt1bmtub3duRGVmYXVsdHN9KSBwYXNzZWQgdG8gZGVmYXVsdHMgb3B0aW9uIG9mIGZpbmRPckNyZWF0ZWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB1bmRlZmluZWQgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KCd0cmFuc2FjdGlvbicpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJuYWxUcmFuc2FjdGlvbiA9ICFvcHRpb25zLnRyYW5zYWN0aW9uO1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS50cmFuc2FjdGlvbihvcHRpb25zKTtcbiAgICAgIHRyYW5zYWN0aW9uID0gdDtcbiAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuXG4gICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZE9uZShVdGlscy5kZWZhdWx0cyh7IHRyYW5zYWN0aW9uIH0sIG9wdGlvbnMpKTtcbiAgICAgIGlmIChmb3VuZCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2ZvdW5kLCBmYWxzZV07XG4gICAgICB9XG5cbiAgICAgIHZhbHVlcyA9IHsgLi4ub3B0aW9ucy5kZWZhdWx0cyB9O1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbiA9IHRydWU7XG4gICAgICBvcHRpb25zLnJldHVybmluZyA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3JlYXRlZC5nZXQodGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZSBxdWVyeSByZXR1cm5lZCBhbiBlbXB0eSByZXN1bHQgZm9yIHRoZSBwcmltYXJ5IGtleSwgd2Uga25vdyB0aGF0IHRoaXMgd2FzIGFjdHVhbGx5IGEgdW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbY3JlYXRlZCwgdHJ1ZV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcikpIHRocm93IGVycjtcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkV2hlcmUgPSBVdGlscy5mbGF0dGVuT2JqZWN0RGVlcChvcHRpb25zLndoZXJlKTtcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkV2hlcmVLZXlzID0gT2JqZWN0LmtleXMoZmxhdHRlbmVkV2hlcmUpLm1hcChuYW1lID0+IF8ubGFzdChuYW1lLnNwbGl0KCcuJykpKTtcbiAgICAgICAgY29uc3Qgd2hlcmVGaWVsZHMgPSBmbGF0dGVuZWRXaGVyZUtleXMubWFwKG5hbWUgPT4gXy5nZXQodGhpcy5yYXdBdHRyaWJ1dGVzLCBgJHtuYW1lfS5maWVsZGAsIG5hbWUpKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZGVmYXVsdHMgJiYgT2JqZWN0LmtleXMob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdKVxuICAgICAgICAgIC5tYXAobmFtZSA9PiB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0uZmllbGQgfHwgbmFtZSk7XG5cbiAgICAgICAgY29uc3QgZXJyRmllbGRLZXlzID0gT2JqZWN0LmtleXMoZXJyLmZpZWxkcyk7XG4gICAgICAgIGNvbnN0IGVyckZpZWxkc1doZXJlSW50ZXJzZWN0cyA9IFV0aWxzLmludGVyc2VjdHMoZXJyRmllbGRLZXlzLCB3aGVyZUZpZWxkcyk7XG4gICAgICAgIGlmIChkZWZhdWx0RmllbGRzICYmICFlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMgJiYgVXRpbHMuaW50ZXJzZWN0cyhlcnJGaWVsZEtleXMsIGRlZmF1bHRGaWVsZHMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyckZpZWxkc1doZXJlSW50ZXJzZWN0cykge1xuICAgICAgICAgIF8uZWFjaChlcnIuZmllbGRzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV0uZmllbGROYW1lO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkgIT09IG9wdGlvbnMud2hlcmVbbmFtZV0udG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSNmaW5kT3JDcmVhdGU6IHZhbHVlIHVzZWQgZm9yICR7bmFtZX0gd2FzIG5vdCBlcXVhbCBmb3IgYm90aCB0aGUgZmluZCBhbmQgdGhlIGNyZWF0ZSBjYWxscywgJyR7b3B0aW9ucy53aGVyZVtuYW1lXX0nIHZzICcke3ZhbHVlfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWVvbmUgbXVzdCBoYXZlIGNyZWF0ZWQgYSBtYXRjaGluZyBpbnN0YW5jZSBpbnNpZGUgdGhlIHNhbWUgdHJhbnNhY3Rpb24gc2luY2Ugd2UgbGFzdCBkaWQgYSBmaW5kLiBMZXQncyBmaW5kIGl0IVxuICAgICAgICBjb25zdCBvdGhlckNyZWF0ZWQgPSBhd2FpdCB0aGlzLmZpbmRPbmUoVXRpbHMuZGVmYXVsdHMoe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBpbnRlcm5hbFRyYW5zYWN0aW9uID8gbnVsbCA6IHRyYW5zYWN0aW9uXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAvLyBTYW5pdHkgY2hlY2ssIGlkZWFsbHkgd2UgY2F1Z2h0IHRoaXMgYXQgdGhlIGRlZmF1bHRGZWlsZHMvZXJyLmZpZWxkcyBjaGVja1xuICAgICAgICAvLyBCdXQgaWYgd2UgZGlkbid0IGFuZCBpbnN0YW5jZSBpcyBudWxsLCB3ZSB3aWxsIHRocm93XG4gICAgICAgIGlmIChvdGhlckNyZWF0ZWQgPT09IG51bGwpIHRocm93IGVycjtcblxuICAgICAgICByZXR1cm4gW290aGVyQ3JlYXRlZCwgZmFsc2VdO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaW50ZXJuYWxUcmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbikge1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBtb3JlIHBlcmZvcm1hbnQgZmluZE9yQ3JlYXRlIHRoYXQgd2lsbCBub3Qgd29yayB1bmRlciBhIHRyYW5zYWN0aW9uIChhdCBsZWFzdCBub3QgaW4gcG9zdGdyZXMpXG4gICAqIFdpbGwgZXhlY3V0ZSBhIGZpbmQgY2FsbCwgaWYgZW1wdHkgdGhlbiBhdHRlbXB0IHRvIGNyZWF0ZSwgaWYgdW5pcXVlIGNvbnN0cmFpbnQgdGhlbiBhdHRlbXB0IHRvIGZpbmQgYWdhaW5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH0gZm9yIGEgZnVsbCBzcGVjaWZpY2F0aW9uIG9mIGZpbmQgYW5kIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgZmluZCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLndoZXJlIEEgaGFzaCBvZiBzZWFyY2ggYXR0cmlidXRlcy4gSWYgYHdoZXJlYCBpcyBhIHBsYWluIG9iamVjdCBpdCB3aWxsIGJlIGFwcGVuZGVkIHdpdGggZGVmYXVsdHMgdG8gYnVpbGQgYSBuZXcgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5kZWZhdWx0c10gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIGlmIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsLGJvb2xlYW4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRDcmVhdGVGaW5kKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ01pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZENyZWF0ZUZpbmQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVzID0geyAuLi5vcHRpb25zLmRlZmF1bHRzIH07XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmIChmb3VuZCkgcmV0dXJuIFtmb3VuZCwgZmFsc2VdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtjcmVhdGVkLCB0cnVlXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IpKSB0aHJvdyBlcnI7XG4gICAgICBjb25zdCBmb3VuZEFnYWluID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtmb3VuZEFnYWluLCBmYWxzZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBvciB1cGRhdGUgYSBzaW5nbGUgcm93LiBBbiB1cGRhdGUgd2lsbCBiZSBleGVjdXRlZCBpZiBhIHJvdyB3aGljaCBtYXRjaGVzIHRoZSBzdXBwbGllZCB2YWx1ZXMgb24gZWl0aGVyIHRoZSBwcmltYXJ5IGtleSBvciBhIHVuaXF1ZSBrZXkgaXMgZm91bmQuIE5vdGUgdGhhdCB0aGUgdW5pcXVlIGluZGV4IG11c3QgYmUgZGVmaW5lZCBpbiB5b3VyIHNlcXVlbGl6ZSBtb2RlbCBhbmQgbm90IGp1c3QgaW4gdGhlIHRhYmxlLiBPdGhlcndpc2UgeW91IG1heSBleHBlcmllbmNlIGEgdW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uLCBiZWNhdXNlIHNlcXVlbGl6ZSBmYWlscyB0byBpZGVudGlmeSB0aGUgcm93IHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqICoqSW1wbGVtZW50YXRpb24gZGV0YWlsczoqKlxuICAgKlxuICAgKiAqIE15U1FMIC0gSW1wbGVtZW50ZWQgd2l0aCBPTiBEVVBMSUNBVEUgS0VZIFVQREFURWBcbiAgICogKiBQb3N0Z3JlU1FMIC0gSW1wbGVtZW50ZWQgd2l0aCBPTiBDT05GTElDVCBETyBVUERBVEUuIElmIHVwZGF0ZSBkYXRhIGNvbnRhaW5zIFBLIGZpZWxkLCB0aGVuIFBLIGlzIHNlbGVjdGVkIGFzIHRoZSBkZWZhdWx0IGNvbmZsaWN0IGtleS4gT3RoZXJ3aXNlIGZpcnN0IHVuaXF1ZSBjb25zdHJhaW50L2luZGV4IHdpbGwgYmUgc2VsZWN0ZWQsIHdoaWNoIGNhbiBzYXRpc2Z5IGNvbmZsaWN0IGtleSByZXF1aXJlbWVudHMuXG4gICAqICogU1FMaXRlIC0gSW1wbGVtZW50ZWQgd2l0aCBPTiBDT05GTElDVCBETyBVUERBVEVcbiAgICogKiBNU1NRTCAtIEltcGxlbWVudGVkIGFzIGEgc2luZ2xlIHF1ZXJ5IHVzaW5nIGBNRVJHRWAgYW5kIGBXSEVOIChOT1QpIE1BVENIRUQgVEhFTmBcbiAgICpcbiAgICogKipOb3RlKiogdGhhdCBQb3N0Z3Jlcy9TUUxpdGUgcmV0dXJucyBudWxsIGZvciBjcmVhdGVkLCBubyBtYXR0ZXIgaWYgdGhlIHJvdyB3YXMgY3JlYXRlZCBvciB1cGRhdGVkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgdmFsdWVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggb2YgdmFsdWVzIHRvIHVwc2VydFxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHNlcnQgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLnZhbGlkYXRlPXRydWVdICAgICAgICAgICAgICAgICAgICAgICBSdW4gdmFsaWRhdGlvbnMgYmVmb3JlIHRoZSByb3cgaXMgaW5zZXJ0ZWRcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICBbb3B0aW9ucy5maWVsZHM9T2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKV0gVGhlIGZpZWxkcyB0byBpbnNlcnQgLyB1cGRhdGUuIERlZmF1bHRzIHRvIGFsbCBjaGFuZ2VkIGZpZWxkc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmhvb2tzPXRydWVdICAgICAgICAgICAgICAgICAgICAgICAgICBSdW4gYmVmb3JlIC8gYWZ0ZXIgdXBzZXJ0IGhvb2tzP1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLnJldHVybmluZz10cnVlXSAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBmZXRjaGVzIGJhY2sgYXV0byBnZW5lcmF0ZWQgdmFsdWVzXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgICAgICAgICAgICAgICAgICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSAgICAgICAgICAgICAgICAgIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFtNb2RlbCwgYm9vbGVhbiB8IG51bGxdPn0gcmV0dXJucyBhbiBhcnJheSB3aXRoIHR3byBlbGVtZW50cywgdGhlIGZpcnN0IGJlaW5nIHRoZSBuZXcgcmVjb3JkIGFuZCB0aGUgc2Vjb25kIGJlaW5nIGB0cnVlYCBpZiBpdCB3YXMganVzdCBjcmVhdGVkIG9yIGBmYWxzZWAgaWYgaXQgYWxyZWFkeSBleGlzdGVkIChleGNlcHQgb24gUG9zdGdyZXMgYW5kIFNRTGl0ZSwgd2hpY2ggY2FuJ3QgZGV0ZWN0IHRoaXMgYW5kIHdpbGwgYWx3YXlzIHJldHVybiBgbnVsbGAgaW5zdGVhZCBvZiBhIGJvb2xlYW4pLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHVwc2VydCh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICByZXR1cm5pbmc6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgIC4uLlV0aWxzLmNsb25lRGVlcChvcHRpb25zKVxuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgIGNvbnN0IGhhc1ByaW1hcnkgPSB0aGlzLnByaW1hcnlLZXlGaWVsZCBpbiB2YWx1ZXMgfHwgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlIGluIHZhbHVlcztcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuYnVpbGQodmFsdWVzKTtcblxuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuICAgIGNvbnN0IGNoYW5nZWQgPSBBcnJheS5mcm9tKGluc3RhbmNlLl9jaGFuZ2VkKTtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgIGF3YWl0IGluc3RhbmNlLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBNYXAgZmllbGQgbmFtZXNcbiAgICBjb25zdCB1cGRhdGVkRGF0YVZhbHVlcyA9IF8ucGljayhpbnN0YW5jZS5kYXRhVmFsdWVzLCBjaGFuZ2VkKTtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXMoaW5zdGFuY2UuZGF0YVZhbHVlcywgT2JqZWN0LmtleXMoaW5zdGFuY2UucmF3QXR0cmlidXRlcyksIHRoaXMpO1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh1cGRhdGVkRGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMsIHRoaXMpO1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuXG4gICAgLy8gQXR0YWNoIGNyZWF0ZWRBdFxuICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICF1cGRhdGVWYWx1ZXNbY3JlYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW2NyZWF0ZWRBdEF0dHJdLmZpZWxkIHx8IGNyZWF0ZWRBdEF0dHI7XG4gICAgICBpbnNlcnRWYWx1ZXNbZmllbGRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcChjcmVhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFpbnNlcnRWYWx1ZXNbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3VwZGF0ZWRBdEF0dHJdLmZpZWxkIHx8IHVwZGF0ZWRBdEF0dHI7XG4gICAgICBpbnNlcnRWYWx1ZXNbZmllbGRdID0gdXBkYXRlVmFsdWVzW2ZpZWxkXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIGFkZHMgYSBudWxsIHZhbHVlIGZvciB0aGUgcHJpbWFyeSBrZXksIGlmIG5vbmUgd2FzIGdpdmVuIGJ5IHRoZSB1c2VyLlxuICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoYXQgYmVjYXVzZSBvZiBzb21lIFBvc3RncmVzIHRlY2huaWNhbGl0aWVzLlxuICAgIGlmICghaGFzUHJpbWFyeSAmJiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgIXRoaXMucmF3QXR0cmlidXRlc1t0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVsZXRlIGluc2VydFZhbHVlc1t0aGlzLnByaW1hcnlLZXlGaWVsZF07XG4gICAgICBkZWxldGUgdXBkYXRlVmFsdWVzW3RoaXMucHJpbWFyeUtleUZpZWxkXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlVXBzZXJ0JywgdmFsdWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS51cHNlcnQodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCBpbnN0YW5jZS53aGVyZSgpLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IFtyZWNvcmRdID0gcmVzdWx0O1xuICAgIHJlY29yZC5pc05ld1JlY29yZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyVXBzZXJ0JywgcmVzdWx0LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBpbnNlcnQgbXVsdGlwbGUgaW5zdGFuY2VzIGluIGJ1bGsuXG4gICAqXG4gICAqIFRoZSBzdWNjZXNzIGhhbmRsZXIgaXMgcGFzc2VkIGFuIGFycmF5IG9mIGluc3RhbmNlcywgYnV0IHBsZWFzZSBub3RpY2UgdGhhdCB0aGVzZSBtYXkgbm90IGNvbXBsZXRlbHkgcmVwcmVzZW50IHRoZSBzdGF0ZSBvZiB0aGUgcm93cyBpbiB0aGUgREIuIFRoaXMgaXMgYmVjYXVzZSBNeVNRTFxuICAgKiBhbmQgU1FMaXRlIGRvIG5vdCBtYWtlIGl0IGVhc3kgdG8gb2J0YWluIGJhY2sgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgSURzIGFuZCBvdGhlciBkZWZhdWx0IHZhbHVlcyBpbiBhIHdheSB0aGF0IGNhbiBiZSBtYXBwZWQgdG8gbXVsdGlwbGUgcmVjb3Jkcy5cbiAgICogVG8gb2J0YWluIEluc3RhbmNlcyBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgdmFsdWVzLCB5b3Ugd2lsbCBuZWVkIHRvIHF1ZXJ5IGZvciB0aGVtIGFnYWluLlxuICAgKlxuICAgKiBJZiB2YWxpZGF0aW9uIGZhaWxzLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGFycmF5LWxpa2UgQWdncmVnYXRlRXJyb3JcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHJlY29yZHMgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyAoa2V5L3ZhbHVlIHBhaXJzKSB0byBjcmVhdGUgaW5zdGFuY2VzIGZyb21cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgICAgIEJ1bGsgY3JlYXRlIG9wdGlvbnNcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIFtvcHRpb25zLmZpZWxkc10gICAgICAgICAgICAgICAgIEZpZWxkcyB0byBpbnNlcnQgKGRlZmF1bHRzIHRvIGFsbCBmaWVsZHMpXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy52YWxpZGF0ZT1mYWxzZV0gICAgICAgICBTaG91bGQgZWFjaCByb3cgYmUgc3ViamVjdCB0byB2YWxpZGF0aW9uIGJlZm9yZSBpdCBpcyBpbnNlcnRlZC4gVGhlIHdob2xlIGluc2VydCB3aWxsIGZhaWwgaWYgb25lIHJvdyBmYWlscyB2YWxpZGF0aW9uXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgICAgICBSdW4gYmVmb3JlIC8gYWZ0ZXIgYnVsayBjcmVhdGUgaG9va3M/XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5pbmRpdmlkdWFsSG9va3M9ZmFsc2VdICBSdW4gYmVmb3JlIC8gYWZ0ZXIgY3JlYXRlIGhvb2tzIGZvciBlYWNoIGluZGl2aWR1YWwgSW5zdGFuY2U/IEJ1bGtDcmVhdGUgaG9va3Mgd2lsbCBzdGlsbCBiZSBydW4gaWYgb3B0aW9ucy5ob29rcyBpcyB0cnVlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaWdub3JlRHVwbGljYXRlcz1mYWxzZV0gSWdub3JlIGR1cGxpY2F0ZSB2YWx1ZXMgZm9yIHByaW1hcnkga2V5cz8gKG5vdCBzdXBwb3J0ZWQgYnkgTVNTUUwgb3IgUG9zdGdyZXMgPCA5LjUpXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICBbb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZV0gICAgICBGaWVsZHMgdG8gdXBkYXRlIGlmIHJvdyBrZXkgYWxyZWFkeSBleGlzdHMgKG9uIGR1cGxpY2F0ZSBrZXkgdXBkYXRlKT8gKG9ubHkgc3VwcG9ydGVkIGJ5IE15U1FMLCBNYXJpYURCLCBTUUxpdGUgPj0gMy4yNC4wICYgUG9zdGdyZXMgPj0gOS41KS4gQnkgZGVmYXVsdCwgYWxsIGZpZWxkcyBhcmUgdXBkYXRlZC5cbiAgICogQHBhcmFtICB7VHJhbnNhY3Rpb259ICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgICAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbnxBcnJheX0gIFtvcHRpb25zLnJldHVybmluZz1mYWxzZV0gICAgICAgIElmIHRydWUsIGFwcGVuZCBSRVRVUk5JTkcgPG1vZGVsIGNvbHVtbnM+IHRvIGdldCBiYWNrIGFsbCBkZWZpbmVkIHZhbHVlczsgaWYgYW4gYXJyYXkgb2YgY29sdW1uIG5hbWVzLCBhcHBlbmQgUkVUVVJOSU5HIDxjb2x1bW5zPiB0byBnZXQgYmFjayBzcGVjaWZpYyBjb2x1bW5zIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgW29wdGlvbnMuc2VhcmNoUGF0aD1ERUZBVUxUXSAgICAgQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TW9kZWw+Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBidWxrQ3JlYXRlKHJlY29yZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWFsZWN0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0O1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuXG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VzID0gcmVjb3Jkcy5tYXAodmFsdWVzID0+IHRoaXMuYnVpbGQodmFsdWVzLCB7IGlzTmV3UmVjb3JkOiB0cnVlLCBpbmNsdWRlOiBvcHRpb25zLmluY2x1ZGUgfSkpO1xuXG4gICAgY29uc3QgcmVjdXJzaXZlQnVsa0NyZWF0ZSA9IGFzeW5jIChpbnN0YW5jZXMsIG9wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgaG9va3M6IHRydWUsXG4gICAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3NvY2lhdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgJiYgWydtc3NxbCddLmluY2x1ZGVzKGRpYWxlY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkaWFsZWN0fSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBpZ25vcmVEdXBsaWNhdGVzIG9wdGlvbi5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlICYmIChkaWFsZWN0ICE9PSAnbXlzcWwnICYmIGRpYWxlY3QgIT09ICdtYXJpYWRiJyAmJiBkaWFsZWN0ICE9PSAnc3FsaXRlJyAmJiBkaWFsZWN0ICE9PSAncG9zdGdyZXMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGlhbGVjdH0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgdXBkYXRlT25EdXBsaWNhdGUgb3B0aW9uLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG5cbiAgICAgIG9wdGlvbnMuZmllbGRzID0gb3B0aW9ucy5maWVsZHMgfHwgT2JqZWN0LmtleXMobW9kZWwucmF3QXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcblxuICAgICAgaWYgKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSAmJiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLmxlbmd0aCkge1xuICAgICAgICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBfLmludGVyc2VjdGlvbihcbiAgICAgICAgICAgIF8ud2l0aG91dChPYmplY3Qua2V5cyhtb2RlbC50YWJsZUF0dHJpYnV0ZXMpLCBjcmVhdGVkQXRBdHRyKSxcbiAgICAgICAgICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXBkYXRlT25EdXBsaWNhdGUgb3B0aW9uIG9ubHkgc3VwcG9ydHMgbm9uLWVtcHR5IGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwucnVuSG9va3MoJ2JlZm9yZUJ1bGtDcmVhdGUnLCBpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gVmFsaWRhdGVcbiAgICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgdmFsaWRhdGVPcHRpb25zLmhvb2tzID0gb3B0aW9ucy5pbmRpdmlkdWFsSG9va3M7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnZhbGlkYXRlKHZhbGlkYXRlT3B0aW9ucyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLkJ1bGtSZWNvcmRFcnJvcihlcnIsIGluc3RhbmNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuc2tpcDtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIGluc3RhbmNlID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRpdmlkdWFsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBob29rczogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmZpZWxkcztcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzO1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzO1xuXG4gICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmRpdmlkdWFsT3B0aW9ucyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUgJiYgb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMuaW5jbHVkZS5maWx0ZXIoaW5jbHVkZSA9PiBpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvKS5tYXAoYXN5bmMgaW5jbHVkZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gaW5zdGFuY2UuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VzLnB1c2goYXNzb2NpYXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcC5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFzc29jaWF0aW9uSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpXG4gICAgICAgICAgICAgIC5vbWl0KFsnYXNzb2NpYXRpb24nXSlcbiAgICAgICAgICAgICAgLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmdcbiAgICAgICAgICAgICAgfSkudmFsdWUoKTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzID0gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShhc3NvY2lhdGlvbkluc3RhbmNlcywgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXNbaWR4XTtcbiAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwW2lkeF07XG5cbiAgICAgICAgICAgICAgYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi5zZXQoaW5zdGFuY2UsIGFzc29jaWF0aW9uSW5zdGFuY2UsIHsgc2F2ZTogZmFsc2UsIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYWxsIGluIG9uZSBxdWVyeVxuICAgICAgICAvLyBSZWNyZWF0ZSByZWNvcmRzIGZyb20gaW5zdGFuY2VzIHRvIHJlcHJlc2VudCBhbnkgY2hhbmdlcyBtYWRlIGluIGhvb2tzIG9yIHZhbGlkYXRpb25cbiAgICAgICAgcmVjb3JkcyA9IGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGluc3RhbmNlLmRhdGFWYWx1ZXM7XG5cbiAgICAgICAgICAvLyBzZXQgY3JlYXRlZEF0L3VwZGF0ZWRBdCBhdHRyaWJ1dGVzXG4gICAgICAgICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIXZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgICAgICAgdmFsdWVzW2NyZWF0ZWRBdEF0dHJdID0gbm93O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhjcmVhdGVkQXRBdHRyKSkge1xuICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGNyZWF0ZWRBdEF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhdmFsdWVzW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbdXBkYXRlZEF0QXR0cl0gPSBub3c7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb3V0ID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHZhbHVlcywgb3B0aW9ucy5maWVsZHMsIG1vZGVsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBtb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvdXRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFwIGF0dHJpYnV0ZXMgdG8gZmllbGRzIGZvciBzZXJpYWwgaWRlbnRpZmljYXRpb25cbiAgICAgICAgY29uc3QgZmllbGRNYXBwZWRBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBtb2RlbC50YWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCB8fCBhdHRyXSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXAgdXBkYXRlT25EdXBsaWNhdGUgYXR0cmlidXRlcyB0byBmaWVsZHNcbiAgICAgICAgaWYgKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgICAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoYXR0ciA9PiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkIHx8IGF0dHIpO1xuICAgICAgICAgIC8vIEdldCBwcmltYXJ5IGtleXMgZm9yIHBvc3RncmVzIHRvIGVuYWJsZSB1cGRhdGVPbkR1cGxpY2F0ZVxuICAgICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IF8uY2hhaW4obW9kZWwucHJpbWFyeUtleXMpLnZhbHVlcygpLm1hcCgnZmllbGQnKS52YWx1ZSgpO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtb2RlbC51bmlxdWVLZXlzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBfLmNoYWluKG1vZGVsLnVuaXF1ZUtleXMpLnZhbHVlcygpLmZpbHRlcihjID0+IGMuZmllbGRzLmxlbmd0aCA+PSAxKS5tYXAoYyA9PiBjLmZpZWxkcykucmVkdWNlKGMgPT4gY1swXSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXAgcmV0dXJuaW5nIGF0dHJpYnV0ZXMgdG8gZmllbGRzXG4gICAgICAgIGlmIChvcHRpb25zLnJldHVybmluZyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMucmV0dXJuaW5nKSkge1xuICAgICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gb3B0aW9ucy5yZXR1cm5pbmcubWFwKGF0dHIgPT4gXy5nZXQobW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSwgJ2ZpZWxkJywgYXR0cikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1vZGVsLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtJbnNlcnQobW9kZWwuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCByZWNvcmRzLCBvcHRpb25zLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UgfHwga2V5ID09PSBtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0KG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUpICYmXG4gICAgICAgICAgICAgICAgWydteXNxbCcsICdtYXJpYWRiJywgJ3NxbGl0ZSddLmluY2x1ZGVzKGRpYWxlY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHF1ZXJ5LmpzIGZvciB0aGVzZSBEQnMgaXMgYmxpbmQsIGl0IGF1dG9pbmNyZW1lbnRzIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByaW1hcnlrZXkgdmFsdWUsIGV2ZW4gaWYgaXQgd2FzIHNldCBtYW51YWxseS4gQWxzbywgaXQgY2FuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG1vcmUgcmVzdWx0cyB0aGFuIGluc3RhbmNlcywgYnVnPy5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlc3VsdFtrZXldO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZChtb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSAmJiBvcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMuaW5jbHVkZS5maWx0ZXIoaW5jbHVkZSA9PiAhKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gfHxcbiAgICAgICAgICBpbmNsdWRlLnBhcmVudCAmJiBpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKS5tYXAoYXN5bmMgaW5jbHVkZSA9PiB7XG4gICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwID0gW107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGFzc29jaWF0ZWQgPSBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNzb2NpYXRlZCkpIGFzc29jaWF0ZWQgPSBbYXNzb2NpYXRlZF07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSBvZiBhc3NvY2lhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKSB7XG4gICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlLnNldChpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXksIGluc3RhbmNlLmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSB8fCBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGFzc29jaWF0aW9uSW5zdGFuY2UsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlcy5wdXNoKGFzc29jaWF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFzc29jaWF0aW9uSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpXG4gICAgICAgICAgICAub21pdChbJ2Fzc29jaWF0aW9uJ10pXG4gICAgICAgICAgICAuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nXG4gICAgICAgICAgICB9KS52YWx1ZSgpO1xuXG4gICAgICAgICAgY29uc3QgY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzID0gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShhc3NvY2lhdGlvbkluc3RhbmNlcywgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVTZXRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzW2lkeF07XG4gICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcFtpZHhdO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5XTogaW5zdGFuY2UuZ2V0KGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5XTogYXNzb2NpYXRpb25JbnN0YW5jZS5nZXQoYXNzb2NpYXRpb25JbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHZhbHVlcyBkZWZpbmVkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgICAgICAgICAgIC4uLmluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXMoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uX2F1dG9HZW5lcmF0ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cl0gPSBhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWx1ZVNldHMucHVzaCh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0aHJvdWdoT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKVxuICAgICAgICAgICAgICAub21pdChbJ2Fzc29jaWF0aW9uJywgJ2F0dHJpYnV0ZXMnXSlcbiAgICAgICAgICAgICAgLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmdcbiAgICAgICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICAgIHRocm91Z2hPcHRpb25zLm1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWw7XG4gICAgICAgICAgICBjb25zdCB0aHJvdWdoSW5zdGFuY2VzID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWwuYnVsa0J1aWxkKHZhbHVlU2V0cywgdGhyb3VnaE9wdGlvbnMpO1xuXG4gICAgICAgICAgICBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKHRocm91Z2hJbnN0YW5jZXMsIHRocm91Z2hPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFwIGZpZWxkcyBiYWNrIHRvIGF0dHJpYnV0ZXNcbiAgICAgIGluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJlxuICAgICAgICAgICAgICBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0clxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyXSA9IGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgICAgICBkZWxldGUgaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSA9IGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICAgICAgaW5zdGFuY2UuY2hhbmdlZChhdHRyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuaXNOZXdSZWNvcmQgPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwucnVuSG9va3MoJ2FmdGVyQnVsa0NyZWF0ZScsIGluc3RhbmNlcywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1bmNhdGUgYWxsIGluc3RhbmNlcyBvZiB0aGUgbW9kZWwuIFRoaXMgaXMgYSBjb252ZW5pZW50IG1ldGhvZCBmb3IgTW9kZWwuZGVzdHJveSh7IHRydW5jYXRlOiB0cnVlIH0pLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgIFtvcHRpb25zXSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gTW9kZWwuZGVzdHJveSBpbiBhZGRpdGlvbiB0byB0cnVuY2F0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmNhc2NhZGUgPSBmYWxzZV0gVHJ1bmNhdGVzIGFsbCB0YWJsZXMgdGhhdCBoYXZlIGZvcmVpZ24ta2V5IHJlZmVyZW5jZXMgdG8gdGhlIG5hbWVkIHRhYmxlLCBvciB0byBhbnkgdGFibGVzIGFkZGVkIHRvIHRoZSBncm91cCBkdWUgdG8gQ0FTQ0FERS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICBbb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHk9ZmFsc2VdIEF1dG9tYXRpY2FsbHkgcmVzdGFydCBzZXF1ZW5jZXMgb3duZWQgYnkgY29sdW1ucyBvZiB0aGUgdHJ1bmNhdGVkIHRhYmxlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSAgICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uXSBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmRlc3Ryb3l9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdHJ1bmNhdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucykgfHwge307XG4gICAgb3B0aW9ucy50cnVuY2F0ZSA9IHRydWU7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVzdHJveShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgbXVsdGlwbGUgaW5zdGFuY2VzLCBvciBzZXQgdGhlaXIgZGVsZXRlZEF0IHRpbWVzdGFtcCB0byB0aGUgY3VycmVudCB0aW1lIGlmIGBwYXJhbm9pZGAgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3kgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIFtvcHRpb25zLndoZXJlXSAgICAgICAgICAgICAgICAgRmlsdGVyIHRoZSBkZXN0cm95XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuaG9va3M9dHJ1ZV0gICAgICAgICAgICBSdW4gYmVmb3JlIC8gYWZ0ZXIgYnVsayBkZXN0cm95IGhvb2tzP1xuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIFtvcHRpb25zLmluZGl2aWR1YWxIb29rcz1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIGRlc3Ryb3kgd2lsbCBTRUxFQ1QgYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIHdoZXJlIHBhcmFtZXRlciBhbmQgd2lsbCBleGVjdXRlIGJlZm9yZSAvIGFmdGVyIGRlc3Ryb3kgaG9va3Mgb24gZWFjaCByb3dcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICBbb3B0aW9ucy5saW1pdF0gICAgICAgICAgICAgICAgIEhvdyBtYW55IHJvd3MgdG8gZGVsZXRlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuZm9yY2U9ZmFsc2VdICAgICAgICAgICBEZWxldGUgaW5zdGVhZCBvZiBzZXR0aW5nIGRlbGV0ZWRBdCB0byBjdXJyZW50IHRpbWVzdGFtcCAob25seSBhcHBsaWNhYmxlIGlmIGBwYXJhbm9pZGAgaXMgZW5hYmxlZClcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy50cnVuY2F0ZT1mYWxzZV0gICAgICAgIElmIHNldCB0byB0cnVlLCBkaWFsZWN0cyB0aGF0IHN1cHBvcnQgaXQgd2lsbCB1c2UgVFJVTkNBVEUgaW5zdGVhZCBvZiBERUxFVEUgRlJPTS4gSWYgYSB0YWJsZSBpcyB0cnVuY2F0ZWQgdGhlIHdoZXJlIGFuZCBsaW1pdCBvcHRpb25zIGFyZSBpZ25vcmVkXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuY2FzY2FkZT1mYWxzZV0gICAgICAgICBPbmx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBUUlVOQ0FURS4gVHJ1bmNhdGVzICBhbGwgdGFibGVzIHRoYXQgaGF2ZSBmb3JlaWduLWtleSByZWZlcmVuY2VzIHRvIHRoZSBuYW1lZCB0YWJsZSwgb3IgdG8gYW55IHRhYmxlcyBhZGRlZCB0byB0aGUgZ3JvdXAgZHVlIHRvIENBU0NBREUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMucmVzdGFydElkZW50aXR5PWZhbHNlXSBPbmx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBUUlVOQ0FURS4gQXV0b21hdGljYWxseSByZXN0YXJ0IHNlcXVlbmNlcyBvd25lZCBieSBjb2x1bW5zIG9mIHRoZSB0cnVuY2F0ZWQgdGFibGUuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuYmVuY2htYXJrPWZhbHNlXSAgICAgICBQYXNzIHF1ZXJ5IGV4ZWN1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhcyBzZWNvbmQgYXJndW1lbnQgdG8gbG9nZ2luZyBmdW5jdGlvbiAob3B0aW9ucy5sb2dnaW5nKS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gVGhlIG51bWJlciBvZiBkZXN0cm95ZWQgcm93c1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucyB8fCAhKG9wdGlvbnMud2hlcmUgfHwgb3B0aW9ucy50cnVuY2F0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB3aGVyZSBvciB0cnVuY2F0ZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIG1vZGVsLmRlc3Ryb3kuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnRydW5jYXRlICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucy53aGVyZSkgJiYgIShvcHRpb25zLndoZXJlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwbGFpbiBvYmplY3QsIGFycmF5IG9yIHNlcXVlbGl6ZSBtZXRob2QgaW4gdGhlIG9wdGlvbnMud2hlcmUgcGFyYW1ldGVyIG9mIG1vZGVsLmRlc3Ryb3kuJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgY2FzY2FkZTogZmFsc2UsXG4gICAgICByZXN0YXJ0SWRlbnRpdHk6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtERUxFVEU7XG5cbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG5cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlQnVsa0Rlc3Ryb3knLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IGluc3RhbmNlcztcbiAgICAvLyBHZXQgZGFvcyBhbmQgcnVuIGJlZm9yZURlc3Ryb3kgaG9vayBvbiBlYWNoIHJlY29yZCBpbmRpdmlkdWFsbHlcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7IHdoZXJlOiBvcHRpb25zLndoZXJlLCB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbiwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLCBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHRoaXMucnVuSG9va3MoJ2JlZm9yZURlc3Ryb3knLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICAvLyBSdW4gZGVsZXRlIHF1ZXJ5IChvciB1cGRhdGUgaWYgcGFyYW5vaWQpXG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmICFvcHRpb25zLmZvcmNlKSB7XG4gICAgICAvLyBTZXQgcXVlcnkgdHlwZSBhcHByb3ByaWF0ZWx5IHdoZW4gcnVubmluZyBzb2Z0IGRlbGV0ZVxuICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuXG4gICAgICBjb25zdCBhdHRyVmFsdWVIYXNoID0ge307XG4gICAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdLmZpZWxkO1xuICAgICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICAgIFtmaWVsZF06IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsXG4gICAgICB9O1xuXG5cbiAgICAgIGF0dHJWYWx1ZUhhc2hbZmllbGRdID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGF0dHJWYWx1ZUhhc2gsIE9iamVjdC5hc3NpZ24od2hlcmUsIG9wdGlvbnMud2hlcmUpLCBvcHRpb25zLCB0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtEZWxldGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXJEZXN0cm95IGhvb2sgb24gZWFjaCByZWNvcmQgaW5kaXZpZHVhbGx5XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLnJ1bkhvb2tzKCdhZnRlckRlc3Ryb3knLCBpbnN0YW5jZSwgb3B0aW9ucykpXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlckJ1bGtEZXN0cm95Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBtdWx0aXBsZSBpbnN0YW5jZXMgaWYgYHBhcmFub2lkYCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSBvcHRpb25zXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgW29wdGlvbnMud2hlcmVdICAgICAgICAgICAgICAgICBGaWx0ZXIgdGhlIHJlc3RvcmVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgICAgIFJ1biBiZWZvcmUgLyBhZnRlciBidWxrIHJlc3RvcmUgaG9va3M/XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgW29wdGlvbnMuaW5kaXZpZHVhbEhvb2tzPWZhbHNlXSBJZiBzZXQgdG8gdHJ1ZSwgcmVzdG9yZSB3aWxsIGZpbmQgYWxsIHJlY29yZHMgd2l0aGluIHRoZSB3aGVyZSBwYXJhbWV0ZXIgYW5kIHdpbGwgZXhlY3V0ZSBiZWZvcmUgLyBhZnRlciBidWxrUmVzdG9yZSBob29rcyBvbiBlYWNoIHJvd1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgIFtvcHRpb25zLmxpbWl0XSAgICAgICAgICAgICAgICAgSG93IG1hbnkgcm93cyB0byB1bmRlbGV0ZSAob25seSBmb3IgbXlzcWwpXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdICAgICAgIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gIFtvcHRpb25zLnRyYW5zYWN0aW9uXSAgICAgICAgICAgVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHJlc3RvcmUob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHRocm93IG5ldyBFcnJvcignTW9kZWwgaXMgbm90IHBhcmFub2lkJyk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlJBVztcbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlQnVsa1Jlc3RvcmUnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIC8vIEdldCBkYW9zIGFuZCBydW4gYmVmb3JlUmVzdG9yZSBob29rIG9uIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseVxuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHsgd2hlcmU6IG9wdGlvbnMud2hlcmUsIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmssIHBhcmFub2lkOiBmYWxzZSB9KTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVSZXN0b3JlJywgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIC8vIFJ1biB1bmRlbGV0ZSBxdWVyeVxuICAgIGNvbnN0IGF0dHJWYWx1ZUhhc2ggPSB7fTtcbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJykgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcblxuICAgIGF0dHJWYWx1ZUhhc2hbZGVsZXRlZEF0QXR0cmlidXRlLmZpZWxkIHx8IGRlbGV0ZWRBdENvbF0gPSBkZWxldGVkQXREZWZhdWx0VmFsdWU7XG4gICAgb3B0aW9ucy5vbWl0TnVsbCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgYXR0clZhbHVlSGFzaCwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICAvLyBSdW4gYWZ0ZXJEZXN0cm95IGhvb2sgb24gZWFjaCByZWNvcmQgaW5kaXZpZHVhbGx5XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLnJ1bkhvb2tzKCdhZnRlclJlc3RvcmUnLCBpbnN0YW5jZSwgb3B0aW9ucykpXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlckJ1bGtSZXN0b3JlJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG11bHRpcGxlIGluc3RhbmNlcyB0aGF0IG1hdGNoIHRoZSB3aGVyZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgdmFsdWVzICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoIG9mIHZhbHVlcyB0byB1cGRhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlIG9wdGlvbnNcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgIG9wdGlvbnMud2hlcmUgICAgICAgICAgICAgICAgICAgT3B0aW9ucyB0byBkZXNjcmliZSB0aGUgc2NvcGUgb2YgdGhlIHNlYXJjaC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnBhcmFub2lkPXRydWVdICAgICAgICAgSWYgdHJ1ZSwgb25seSBub24tZGVsZXRlZCByZWNvcmRzIHdpbGwgYmUgdXBkYXRlZC4gSWYgZmFsc2UsIGJvdGggZGVsZXRlZCBhbmQgbm9uLWRlbGV0ZWQgcmVjb3JkcyB3aWxsIGJlIHVwZGF0ZWQuIE9ubHkgYXBwbGllcyBpZiBgb3B0aW9ucy5wYXJhbm9pZGAgaXMgdHJ1ZSBmb3IgdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgW29wdGlvbnMuZmllbGRzXSAgICAgICAgICAgICAgICBGaWVsZHMgdG8gdXBkYXRlIChkZWZhdWx0cyB0byBhbGwgZmllbGRzKVxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMudmFsaWRhdGU9dHJ1ZV0gICAgICAgICBTaG91bGQgZWFjaCByb3cgYmUgc3ViamVjdCB0byB2YWxpZGF0aW9uIGJlZm9yZSBpdCBpcyBpbnNlcnRlZC4gVGhlIHdob2xlIGluc2VydCB3aWxsIGZhaWwgaWYgb25lIHJvdyBmYWlscyB2YWxpZGF0aW9uXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSAgICAgICAgICAgIFJ1biBiZWZvcmUgLyBhZnRlciBidWxrIHVwZGF0ZSBob29rcz9cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLnNpZGVFZmZlY3RzPXRydWVdICAgICAgV2hldGhlciBvciBub3QgdG8gdXBkYXRlIHRoZSBzaWRlIGVmZmVjdHMgb2YgYW55IHZpcnR1YWwgc2V0dGVycy5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmluZGl2aWR1YWxIb29rcz1mYWxzZV0gUnVuIGJlZm9yZSAvIGFmdGVyIHVwZGF0ZSBob29rcz8uIElmIHRydWUsIHRoaXMgd2lsbCBleGVjdXRlIGEgU0VMRUNUIGZvbGxvd2VkIGJ5IGluZGl2aWR1YWwgVVBEQVRFcy4gQSBzZWxlY3QgaXMgbmVlZGVkLCBiZWNhdXNlIHRoZSByb3cgZGF0YSBuZWVkcyB0byBiZSBwYXNzZWQgdG8gdGhlIGhvb2tzXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58QXJyYXl9ICBbb3B0aW9ucy5yZXR1cm5pbmc9ZmFsc2VdICAgICAgIElmIHRydWUsIGFwcGVuZCBSRVRVUk5JTkcgPG1vZGVsIGNvbHVtbnM+IHRvIGdldCBiYWNrIGFsbCBkZWZpbmVkIHZhbHVlczsgaWYgYW4gYXJyYXkgb2YgY29sdW1uIG5hbWVzLCBhcHBlbmQgUkVUVVJOSU5HIDxjb2x1bW5zPiB0byBnZXQgYmFjayBzcGVjaWZpYyBjb2x1bW5zIChQb3N0Z3JlcyBvbmx5KVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgW29wdGlvbnMubGltaXRdICAgICAgICAgICAgICAgICBIb3cgbWFueSByb3dzIHRvIHVwZGF0ZSAob25seSBmb3IgbXlzcWwgYW5kIG1hcmlhZGIsIGltcGxlbWVudGVkIGFzIFRPUChuKSBmb3IgTVNTUUw7IGZvciBzcWxpdGUgaXQgaXMgc3VwcG9ydGVkIG9ubHkgd2hlbiByb3dpZCBpcyBwcmVzZW50KVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIFtvcHRpb25zLmJlbmNobWFyaz1mYWxzZV0gICAgICAgUGFzcyBxdWVyeSBleGVjdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGxvZ2dpbmcgZnVuY3Rpb24gKG9wdGlvbnMubG9nZ2luZykuXG4gICAqIEBwYXJhbSAge1RyYW5zYWN0aW9ufSAgICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gICAgICAgICAgIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuc2lsZW50PWZhbHNlXSAgICAgICAgICBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxudW1iZXIsbnVtYmVyPj59ICBUaGUgcHJvbWlzZSByZXR1cm5zIGFuIGFycmF5IHdpdGggb25lIG9yIHR3byBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgYWx3YXlzIHRoZSBudW1iZXJcbiAgICogb2YgYWZmZWN0ZWQgcm93cywgd2hpbGUgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBhY3R1YWwgYWZmZWN0ZWQgcm93cyAob25seSBzdXBwb3J0ZWQgaW4gcG9zdGdyZXMgd2l0aCBgb3B0aW9ucy5yZXR1cm5pbmdgIHRydWUpLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHVwZGF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgdGhpcy5fb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgIHJldHVybmluZzogZmFsc2UsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICBzaWRlRWZmZWN0czogdHJ1ZVxuICAgIH0pKTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcblxuICAgIC8vIENsb25lIHZhbHVlcyBzbyBpdCBkb2Vzbid0IGdldCBtb2RpZmllZCBmb3IgY2FsbGVyIHNjb3BlIGFuZCBpZ25vcmUgdW5kZWZpbmVkIHZhbHVlc1xuICAgIHZhbHVlcyA9IF8ub21pdEJ5KHZhbHVlcywgdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCk7XG5cbiAgICAvLyBSZW1vdmUgdmFsdWVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgb3B0aW9ucy5maWVsZHNcbiAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgb3B0aW9ucy5maWVsZHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWVzKSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbihPYmplY3Qua2V5cyh2YWx1ZXMpLCBPYmplY3Qua2V5cyh0aGlzLnRhYmxlQXR0cmlidXRlcykpO1xuICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdmFsdWVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpIHx8IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cblxuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG4gICAgbGV0IHZhbHVlc1VzZTtcbiAgICAvLyBWYWxpZGF0ZVxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBjb25zdCBidWlsZCA9IHRoaXMuYnVpbGQodmFsdWVzKTtcbiAgICAgIGJ1aWxkLnNldCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCwgdmFsdWVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSwgeyByYXc6IHRydWUgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLnNpZGVFZmZlY3RzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCBfLnBpY2soYnVpbGQuZ2V0KCksIGJ1aWxkLmNoYW5nZWQoKSkpO1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pb24ob3B0aW9ucy5maWVsZHMsIE9iamVjdC5rZXlzKHZhbHVlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSB3YW50IHRvIHNraXAgdmFsaWRhdGlvbnMgZm9yIGFsbCBvdGhlciBmaWVsZHNcbiAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhd2FpdCBidWlsZC52YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuZGF0YVZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBfLnBpY2soYXR0cmlidXRlcy5kYXRhVmFsdWVzLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUnVuIGJlZm9yZSBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHZhbHVlcztcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZUJ1bGtVcGRhdGUnLCBvcHRpb25zKTtcbiAgICAgIHZhbHVlcyA9IG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgdmFsdWVzVXNlID0gdmFsdWVzO1xuXG4gICAgLy8gR2V0IGluc3RhbmNlcyBhbmQgcnVuIGJlZm9yZVVwZGF0ZSBob29rIG9uIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseVxuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgbGV0IHVwZGF0ZURvbmVSb3dCeVJvdyA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHtcbiAgICAgICAgd2hlcmU6IG9wdGlvbnMud2hlcmUsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmssXG4gICAgICAgIHBhcmFub2lkOiBvcHRpb25zLnBhcmFub2lkXG4gICAgICB9KTtcblxuICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUnVuIGJlZm9yZVVwZGF0ZSBob29rcyBvbiBlYWNoIHJlY29yZCBhbmQgY2hlY2sgd2hldGhlciBiZWZvcmVVcGRhdGUgaG9vayBjaGFuZ2VzIHZhbHVlcyB1bmlmb3JtbHlcbiAgICAgICAgLy8gaS5lLiB3aGV0aGVyIHRoZXkgY2hhbmdlIHZhbHVlcyBmb3IgZWFjaCByZWNvcmQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgIGxldCBjaGFuZ2VkVmFsdWVzO1xuICAgICAgICBsZXQgZGlmZmVyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaW5zdGFuY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgLy8gUmVjb3JkIHVwZGF0ZXMgaW4gaW5zdGFuY2VzIGRhdGFWYWx1ZXNcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGFuZ2VkIGZpZWxkcyBvbiB0aGUgaW5zdGFuY2VcbiAgICAgICAgICBfLmZvckluKHZhbHVlc1VzZSwgKG5ld1ZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RGF0YVZhbHVlKGF0dHIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFJ1biBiZWZvcmVVcGRhdGUgaG9va1xuICAgICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2JlZm9yZVVwZGF0ZScsIGluc3RhbmNlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0NoYW5nZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIF8uZm9ySW4oaW5zdGFuY2UuZGF0YVZhbHVlcywgKG5ld1ZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSkge1xuICAgICAgICAgICAgICAgIHRoaXNDaGFuZ2VkVmFsdWVzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZFZhbHVlcyA9IHRoaXNDaGFuZ2VkVmFsdWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlmZmVyZW50ID0gIV8uaXNFcXVhbChjaGFuZ2VkVmFsdWVzLCB0aGlzQ2hhbmdlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlZFZhbHVlcyk7XG4gICAgICAgICAgLy8gSG9va3MgZG8gbm90IGNoYW5nZSB2YWx1ZXMgb3IgY2hhbmdlIHRoZW0gdW5pZm9ybWx5XG4gICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBIb29rcyBjaGFuZ2UgdmFsdWVzIC0gcmVjb3JkIGNoYW5nZXMgaW4gdmFsdWVzVXNlIHNvIHRoZXkgYXJlIGV4ZWN1dGVkXG4gICAgICAgICAgICB2YWx1ZXNVc2UgPSBjaGFuZ2VkVmFsdWVzO1xuICAgICAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaW9uKG9wdGlvbnMuZmllbGRzLCBrZXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRpdmlkdWFsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgaG9va3M6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWxpZGF0ZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2F2ZShpbmRpdmlkdWFsT3B0aW9ucyk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHVwZGF0ZURvbmVSb3dCeVJvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodXBkYXRlRG9uZVJvd0J5Um93KSB7XG4gICAgICByZXN1bHQgPSBbaW5zdGFuY2VzLmxlbmd0aCwgaW5zdGFuY2VzXTtcbiAgICB9IGVsc2UgaWYgKF8uaXNFbXB0eSh2YWx1ZXNVc2UpXG4gICAgICAgfHwgT2JqZWN0LmtleXModmFsdWVzVXNlKS5sZW5ndGggPT09IDEgJiYgdmFsdWVzVXNlW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSkge1xuICAgICAgLy8gb25seSB1cGRhdGVkQXQgaXMgYmVpbmcgcGFzc2VkLCB0aGVuIHNraXAgdXBkYXRlXG4gICAgICByZXN1bHQgPSBbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1VzZSA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh2YWx1ZXNVc2UsIG9wdGlvbnMuZmllbGRzLCB0aGlzKTtcbiAgICAgIG9wdGlvbnMgPSBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmhhc1RyaWdnZXIgOiBmYWxzZTtcblxuICAgICAgY29uc3QgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXNVc2UsIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXN1bHQgPSBbYWZmZWN0ZWRSb3dzLmxlbmd0aCwgYWZmZWN0ZWRSb3dzXTtcbiAgICAgICAgaW5zdGFuY2VzID0gYWZmZWN0ZWRSb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW2FmZmVjdGVkUm93c107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGluc3RhbmNlID0+IHRoaXMucnVuSG9va3MoJ2FmdGVyVXBkYXRlJywgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgICByZXN1bHRbMV0gPSBpbnN0YW5jZXM7XG4gICAgfVxuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHZhbHVlcztcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoJ2FmdGVyQnVsa1VwZGF0ZScsIG9wdGlvbnMpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYSBkZXNjcmliZSBxdWVyeSBvbiB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1hXSBzY2hlbWEgbmFtZSB0byBzZWFyY2ggdGFibGUgaW5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBxdWVyeSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBoYXNoIG9mIGF0dHJpYnV0ZXMgYW5kIHRoZWlyIHR5cGVzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGVzY3JpYmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZGVzY3JpYmVUYWJsZSh0aGlzLnRhYmxlTmFtZSwgeyBzY2hlbWE6IHNjaGVtYSB8fCB0aGlzLl9zY2hlbWEgfHwgdW5kZWZpbmVkLCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgc3RhdGljIF9nZXREZWZhdWx0VGltZXN0YW1wKGF0dHIpIHtcbiAgICBpZiAoISF0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgISF0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gVXRpbHMudG9EZWZhdWx0VmFsdWUodGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdLmRlZmF1bHRWYWx1ZSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfZXhwYW5kQXR0cmlidXRlcyhvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyk7XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmV4Y2x1ZGUpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmZpbHRlcihlbGVtID0+ICFvcHRpb25zLmF0dHJpYnV0ZXMuZXhjbHVkZS5pbmNsdWRlcyhlbGVtKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQob3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvLyBJbmplY3QgX3Njb3BlIGludG8gb3B0aW9ucy5cbiAgc3RhdGljIF9pbmplY3RTY29wZShvcHRpb25zKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBVdGlscy5jbG9uZURlZXAodGhpcy5fc2NvcGUpO1xuICAgIHRoaXMuX2RlZmF1bHRzT3B0aW9ucyhvcHRpb25zLCBzY29wZSk7XG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBzdGF0aWMgaGFzQWxpYXMoYWxpYXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXNzb2NpYXRpb25zLCBhbGlhcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSB2YWx1ZSBvZiBvbmUgb3IgbW9yZSBjb2x1bW5zLiBUaGlzIGlzIGRvbmUgaW4gdGhlIGRhdGFiYXNlLCB3aGljaCBtZWFucyBpdCBkb2VzIG5vdCB1c2UgdGhlIHZhbHVlcyBjdXJyZW50bHkgc3RvcmVkIG9uIHRoZSBJbnN0YW5jZS4gVGhlIGluY3JlbWVudCBpcyBkb25lIHVzaW5nIGFcbiAgICogYGBgIFNFVCBjb2x1bW4gPSBjb2x1bW4gKyBYIFdIRVJFIGZvbyA9ICdiYXInIGBgYCBxdWVyeS4gVG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlIGFmdGVyIGFuIGluY3JlbWVudCBpbnRvIHRoZSBJbnN0YW5jZSB5b3Ugc2hvdWxkIGRvIGEgcmVsb2FkLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5pbmNyZW1lbnQgbnVtYmVyIGJ5IDE8L2NhcHRpb24+XG4gICAqIE1vZGVsLmluY3JlbWVudCgnbnVtYmVyJywgeyB3aGVyZTogeyBmb286ICdiYXInIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5pbmNyZW1lbnQgbnVtYmVyIGFuZCBjb3VudCBieSAyPC9jYXB0aW9uPlxuICAgKiBNb2RlbC5pbmNyZW1lbnQoWydudW1iZXInLCAnY291bnQnXSwgeyBieTogMiwgd2hlcmU6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5pbmNyZW1lbnQgYW5zd2VyIGJ5IDQyLCBhbmQgZGVjcmVtZW50IHRyaWVzIGJ5IDE8L2NhcHRpb24+XG4gICAqIC8vIGBieWAgaXMgaWdub3JlZCwgYXMgZWFjaCBjb2x1bW4gaGFzIGl0cyBvd24gdmFsdWVcbiAgICogTW9kZWwuaW5jcmVtZW50KHsgYW5zd2VyOiA0MiwgdHJpZXM6IC0xfSwgeyBieTogMiwgd2hlcmU6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNyZWxvYWR9XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxvYmplY3R9ICBmaWVsZHMgICAgICAgICAgICAgICAgICAgICAgIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGF0IGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgb2YgYGJ5YCBnaXZlbiBpbiBvcHRpb25zLiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgZWFjaCBjb2x1bW4uIElmIGFuZCBvYmplY3QgaXMgcHJvdmlkZWQsIGVhY2ggY29sdW1uIGlzIGluY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBnaXZlbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50IG9wdGlvbnNcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgIG9wdGlvbnMud2hlcmUgICAgICAgICAgICAgICAgY29uZGl0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICBbb3B0aW9ucy5ieT0xXSAgICAgICAgICAgICAgIFRoZSBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgICAgICAgICBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdICAgICAgIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSAgICAgIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0gIHtUcmFuc2FjdGlvbn0gICAgICAgICAgW29wdGlvbnMudHJhbnNhY3Rpb25dICAgICAgICBUcmFuc2FjdGlvbiB0byBydW4gcXVlcnkgdW5kZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxbXSw/bnVtYmVyPn0gcmV0dXJucyBhbiBhcnJheSBvZiBhZmZlY3RlZCByb3dzIGFuZCBhZmZlY3RlZCBjb3VudCB3aXRoIGBvcHRpb25zLnJldHVybmluZ2AgdHJ1ZSwgd2hlbmV2ZXIgc3VwcG9ydGVkIGJ5IGRpYWxlY3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdzdHJpbmcnKSBmaWVsZHMgPSBbZmllbGRzXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICBmaWVsZHMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgICAgICBpZiAodGhpcy5yYXdBdHRyaWJ1dGVzW2ZdICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgIT09IGYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgdGhpcy5fb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGJ5OiAxLFxuICAgICAgd2hlcmU6IHt9LFxuICAgICAgaW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaXNTdWJ0cmFjdGlvbiA9ICFvcHRpb25zLmluY3JlbWVudDtcblxuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG5cbiAgICBjb25zdCB3aGVyZSA9IHsgLi4ub3B0aW9ucy53aGVyZSB9O1xuXG4gICAgLy8gQSBwbGFpbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIGZpZWxkcyB0byBiZSBpbmNyZW1lbnRlZCBhbmQgd2hvc2UgdmFsdWVzIGFyZVxuICAgIC8vIHRoZSBhbW91bnRzIHRvIGJlIGluY3JlbWVudGVkIGJ5LlxuICAgIGxldCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0ge307XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFtmaWVsZF0gPSBvcHRpb25zLmJ5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgYGZpZWxkc2AgYXJndW1lbnQgaXMgbm90IGFuIGFycmF5LCB0aGVuIHdlIGFzc3VtZSBpdCBhbHJlYWR5IGhhcyB0aGVcbiAgICAgIC8vIGZvcm0gbmVjZXNzYXJ5IHRvIGJlIHBsYWNlZCBkaXJlY3RseSBpbiB0aGUgYGluY3JlbWVudEFtb3VudHNCeUZpZWxkYCB2YXJpYWJsZS5cbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0gZmllbGRzO1xuICAgIH1cblxuICAgIC8vIElmIG9wdGltaXN0aWMgbG9ja2luZyBpcyBlbmFibGVkLCB3ZSBjYW4gdGFrZSBhZHZhbnRhZ2UgdGhhdCB0aGlzIGlzIGFuXG4gICAgLy8gaW5jcmVtZW50L2RlY3JlbWVudCBvcGVyYXRpb24gYW5kIHNlbmQgaXQgaGVyZSBhcyB3ZWxsLiBXZSBwdXQgYC0xYCBmb3JcbiAgICAvLyBkZWNyZW1lbnRpbmcgYmVjYXVzZSBpdCB3aWxsIGJlIHN1YnRyYWN0ZWQsIGdldHRpbmcgYC0oLTEpYCB3aGljaCBpcyBgKzFgXG4gICAgaWYgKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkW3RoaXMuX3ZlcnNpb25BdHRyaWJ1dGVdID0gaXNTdWJ0cmFjdGlvbiA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCA9IHt9O1xuXG4gICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgdXBkYXRlZEF0QXR0ciAmJiAhaW5jcmVtZW50QW1vdW50c0J5RmllbGRbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5yYXdBdHRyaWJ1dGVzW3VwZGF0ZWRBdEF0dHJdLmZpZWxkIHx8IHVwZGF0ZWRBdEF0dHI7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZFthdHRyTmFtZV0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpO1xuICAgIGxldCBhZmZlY3RlZFJvd3M7XG4gICAgaWYgKGlzU3VidHJhY3Rpb24pIHtcbiAgICAgIGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZGVjcmVtZW50KFxuICAgICAgICB0aGlzLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuaW5jcmVtZW50KFxuICAgICAgICB0aGlzLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICByZXR1cm4gW2FmZmVjdGVkUm93cywgYWZmZWN0ZWRSb3dzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFthZmZlY3RlZFJvd3NdO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3JlbWVudCB0aGUgdmFsdWUgb2Ygb25lIG9yIG1vcmUgY29sdW1ucy4gVGhpcyBpcyBkb25lIGluIHRoZSBkYXRhYmFzZSwgd2hpY2ggbWVhbnMgaXQgZG9lcyBub3QgdXNlIHRoZSB2YWx1ZXMgY3VycmVudGx5IHN0b3JlZCBvbiB0aGUgSW5zdGFuY2UuIFRoZSBkZWNyZW1lbnQgaXMgZG9uZSB1c2luZyBhXG4gICAqIGBgYHNxbCBTRVQgY29sdW1uID0gY29sdW1uIC0gWCBXSEVSRSBmb28gPSAnYmFyJ2BgYCBxdWVyeS4gVG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlIGFmdGVyIGEgZGVjcmVtZW50IGludG8gdGhlIEluc3RhbmNlIHlvdSBzaG91bGQgZG8gYSByZWxvYWQuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmRlY3JlbWVudCBudW1iZXIgYnkgMTwvY2FwdGlvbj5cbiAgICogTW9kZWwuZGVjcmVtZW50KCdudW1iZXInLCB7IHdoZXJlOiB7IGZvbzogJ2JhcicgfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmRlY3JlbWVudCBudW1iZXIgYW5kIGNvdW50IGJ5IDI8L2NhcHRpb24+XG4gICAqIE1vZGVsLmRlY3JlbWVudChbJ251bWJlcicsICdjb3VudCddLCB7IGJ5OiAyLCB3aGVyZTogeyBmb286ICdiYXInIH0gfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmRlY3JlbWVudCBhbnN3ZXIgYnkgNDIsIGFuZCBkZWNyZW1lbnQgdHJpZXMgYnkgLTE8L2NhcHRpb24+XG4gICAqIC8vIGBieWAgaXMgaWdub3JlZCwgc2luY2UgZWFjaCBjb2x1bW4gaGFzIGl0cyBvd24gdmFsdWVcbiAgICogTW9kZWwuZGVjcmVtZW50KHsgYW5zd2VyOiA0MiwgdHJpZXM6IC0xfSwgeyBieTogMiwgd2hlcmU6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheXxvYmplY3R9IGZpZWxkcyBJZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgdGhhdCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIG9mIGBieWAgZ2l2ZW4gaW4gb3B0aW9ucy4gSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZSBzYW1lIGlzIHRydWUgZm9yIGVhY2ggY29sdW1uLiBJZiBhbmQgb2JqZWN0IGlzIHByb3ZpZGVkLCBlYWNoIGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgZ2l2ZW4uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGRlY3JlbWVudCBvcHRpb25zLCBzaW1pbGFyIHRvIGluY3JlbWVudFxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5pbmNyZW1lbnR9XG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3JlbG9hZH1cbiAgICogQHNpbmNlIDQuMzYuMFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbFtdLD9udW1iZXI+fSByZXR1cm5zIGFuIGFycmF5IG9mIGFmZmVjdGVkIHJvd3MgYW5kIGFmZmVjdGVkIGNvdW50IHdpdGggYG9wdGlvbnMucmV0dXJuaW5nYCB0cnVlLCB3aGVuZXZlciBzdXBwb3J0ZWQgYnkgZGlhbGVjdFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnQoZmllbGRzLCB7XG4gICAgICBieTogMSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBpbmNyZW1lbnQ6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpIHtcbiAgICBhc3NlcnQob3B0aW9ucyAmJiBvcHRpb25zLndoZXJlLCAnTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyJyk7XG4gICAgYXNzZXJ0KF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMud2hlcmUpIHx8IG9wdGlvbnMud2hlcmUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QsXG4gICAgICAnRXhwZWN0ZWQgcGxhaW4gb2JqZWN0LCBhcnJheSBvciBzZXF1ZWxpemUgbWV0aG9kIGluIHRoZSBvcHRpb25zLndoZXJlIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBxdWVyeSBmb3IgdGhpcyBpbnN0YW5jZSwgdXNlIHdpdGggYG9wdGlvbnMud2hlcmVgXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrVmVyc2lvbj1mYWxzZV0gaW5jbHVkZSB2ZXJzaW9uIGF0dHJpYnV0ZSBpbiB3aGVyZSBoYXNoXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICB3aGVyZShjaGVja1ZlcnNpb24pIHtcbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMucmVkdWNlKChyZXN1bHQsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZV0gPSB0aGlzLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICBpZiAoXy5zaXplKHdoZXJlKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucy53aGVyZUNvbGxlY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25BdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdmVyc2lvbkF0dHJpYnV0ZTtcbiAgICBpZiAoY2hlY2tWZXJzaW9uICYmIHZlcnNpb25BdHRyKSB7XG4gICAgICB3aGVyZVt2ZXJzaW9uQXR0cl0gPSB0aGlzLmdldCh2ZXJzaW9uQXR0ciwgeyByYXc6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5tYXBXaGVyZUZpZWxkTmFtZXMod2hlcmUsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbb2JqZWN0IFNlcXVlbGl6ZUluc3RhbmNlOiR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfV1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHVuZGVybHlpbmcgZGF0YSB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IGtleSB0byBsb29rIGluIGluc3RhbmNlIGRhdGEgc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGdldERhdGFWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB1bmRlcmx5aW5nIGRhdGEgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBrZXkgdG8gc2V0IGluIGluc3RhbmNlIGRhdGEgc3RvcmVcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIG5ldyB2YWx1ZSBmb3IgZ2l2ZW4ga2V5XG4gICAqXG4gICAqL1xuICBzZXREYXRhVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XTtcblxuICAgIGlmICghXy5pc0VxdWFsKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSkge1xuICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBubyBrZXkgaXMgZ2l2ZW4sIHJldHVybnMgYWxsIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UsIGFsc28gaW52b2tpbmcgdmlydHVhbCBnZXR0ZXJzLlxuICAgKlxuICAgKiBJZiBrZXkgaXMgZ2l2ZW4gYW5kIGEgZmllbGQgb3IgdmlydHVhbCBnZXR0ZXIgaXMgcHJlc2VudCBmb3IgdGhlIGtleSBpdCB3aWxsIGNhbGwgdGhhdCBnZXR0ZXIgLSBlbHNlIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBmb3Iga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIFtrZXldIGtleSB0byBnZXQgdmFsdWUgb2ZcbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0aW9uc10gZ2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wbGFpbj1mYWxzZV0gSWYgc2V0IHRvIHRydWUsIGluY2x1ZGVkIGluc3RhbmNlcyB3aWxsIGJlIHJldHVybmVkIGFzIHBsYWluIG9iamVjdHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yYXc9ZmFsc2VdIElmIHNldCB0byB0cnVlLCBmaWVsZCBhbmQgdmlydHVhbCBzZXR0ZXJzIHdpbGwgYmUgaWdub3JlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fGFueX1cbiAgICovXG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ga2V5O1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9jdXN0b21HZXR0ZXJzLCBrZXkpICYmICFvcHRpb25zLnJhdykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tR2V0dGVyc1trZXldLmNhbGwodGhpcywga2V5LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGxhaW4gJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhVmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldLm1hcChpbnN0YW5jZSA9PiBpbnN0YW5jZS5nZXQob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFWYWx1ZXNba2V5XSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldLmdldChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9oYXNDdXN0b21HZXR0ZXJzXG4gICAgICB8fCBvcHRpb25zLnBsYWluICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZVxuICAgICAgfHwgb3B0aW9ucy5jbG9uZVxuICAgICkge1xuICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICBsZXQgX2tleTtcblxuICAgICAgaWYgKHRoaXMuX2hhc0N1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgZm9yIChfa2V5IGluIHRoaXMuX2N1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICYmICF0aGlzLl9vcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZXMoX2tleSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fY3VzdG9tR2V0dGVycywgX2tleSkpIHtcbiAgICAgICAgICAgIHZhbHVlc1tfa2V5XSA9IHRoaXMuZ2V0KF9rZXksIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKF9rZXkgaW4gdGhpcy5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlcywgX2tleSlcbiAgICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5kYXRhVmFsdWVzLCBfa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICB2YWx1ZXNbX2tleV0gPSB0aGlzLmdldChfa2V5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlzIHVzZWQgdG8gdXBkYXRlIHZhbHVlcyBvbiB0aGUgaW5zdGFuY2UgKHRoZSBzZXF1ZWxpemUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlIHRoYXQgaXMsIHJlbWVtYmVyIHRoYXQgbm90aGluZyB3aWxsIGJlIHBlcnNpc3RlZCBiZWZvcmUgeW91IGFjdHVhbGx5IGNhbGwgYHNhdmVgKS5cbiAgICogSW4gaXRzIG1vc3QgYmFzaWMgZm9ybSBgc2V0YCB3aWxsIHVwZGF0ZSBhIHZhbHVlIHN0b3JlZCBpbiB0aGUgdW5kZXJseWluZyBgZGF0YVZhbHVlc2Agb2JqZWN0LiBIb3dldmVyLCBpZiBhIGN1c3RvbSBzZXR0ZXIgZnVuY3Rpb24gaXMgZGVmaW5lZCBmb3IgdGhlIGtleSwgdGhhdCBmdW5jdGlvblxuICAgKiB3aWxsIGJlIGNhbGxlZCBpbnN0ZWFkLiBUbyBieXBhc3MgdGhlIHNldHRlciwgeW91IGNhbiBwYXNzIGByYXc6IHRydWVgIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICpcbiAgICogSWYgc2V0IGlzIGNhbGxlZCB3aXRoIGFuIG9iamVjdCwgaXQgd2lsbCBsb29wIG92ZXIgdGhlIG9iamVjdCwgYW5kIGNhbGwgc2V0IHJlY3Vyc2l2ZWx5IGZvciBlYWNoIGtleSwgdmFsdWUgcGFpci4gSWYgeW91IHNldCByYXcgdG8gdHJ1ZSwgdGhlIHVuZGVybHlpbmcgZGF0YVZhbHVlcyB3aWxsIGVpdGhlciBiZVxuICAgKiBzZXQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBwYXNzZWQsIG9yIHVzZWQgdG8gZXh0ZW5kIGRhdGFWYWx1ZXMsIGlmIGRhdGFWYWx1ZXMgYWxyZWFkeSBjb250YWluIHZhbHVlcy5cbiAgICpcbiAgICogV2hlbiBzZXQgaXMgY2FsbGVkLCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGZpZWxkIGlzIHN0b3JlZCBhbmQgc2V0cyBhIGNoYW5nZWQgZmxhZyhzZWUgYGNoYW5nZWRgKS5cbiAgICpcbiAgICogU2V0IGNhbiBhbHNvIGJlIHVzZWQgdG8gYnVpbGQgaW5zdGFuY2VzIGZvciBhc3NvY2lhdGlvbnMsIGlmIHlvdSBoYXZlIHZhbHVlcyBmb3IgdGhvc2UuXG4gICAqIFdoZW4gdXNpbmcgc2V0IHdpdGggYXNzb2NpYXRpb25zIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkga2V5IG1hdGNoZXMgdGhlIGFsaWFzIG9mIHRoZSBhc3NvY2lhdGlvblxuICAgKiB3aGlsZSBhbHNvIG1ha2luZyBzdXJlIHRoYXQgdGhlIHByb3BlciBpbmNsdWRlIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCAoZnJvbSAuYnVpbGQoKSBvciAuZmluZE9uZSgpKVxuICAgKlxuICAgKiBJZiBjYWxsZWQgd2l0aCBhIGRvdC5zZXBhcmF0ZWQga2V5IG9uIGEgSlNPTi9KU09OQiBhdHRyaWJ1dGUgaXQgd2lsbCBzZXQgdGhlIHZhbHVlIG5lc3RlZCBhbmQgZmxhZyB0aGUgZW50aXJlIG9iamVjdCBhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbmNsdWRlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGtleSBrZXkgdG8gc2V0LCBpdCBjYW4gYmUgc3RyaW5nIG9yIG9iamVjdC4gV2hlbiBzdHJpbmcgaXQgd2lsbCBzZXQgdGhhdCBrZXksIGZvciBvYmplY3QgaXQgd2lsbCBsb29wIG92ZXIgYWxsIG9iamVjdCBwcm9wZXJ0aWVzIG5kIHNldCB0aGVtLlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgdmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yYXc9ZmFsc2VdIElmIHNldCB0byB0cnVlLCBmaWVsZCBhbmQgdmlydHVhbCBzZXR0ZXJzIHdpbGwgYmUgaWdub3JlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc2V0PWZhbHNlXSBDbGVhciBhbGwgcHJldmlvdXNseSBzZXQgZGF0YSB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfVxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCBvcmlnaW5hbFZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0ga2V5O1xuICAgICAgb3B0aW9ucyA9IHZhbHVlIHx8IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNldCkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHJhdywgYW5kIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggaW5jbHVkZXMgb3Igc3BlY2lhbCBhdHRyaWJ1dGVzLCBqdXN0IHNldCBpdCBzdHJhaWdodCBvbiB0aGUgZGF0YVZhbHVlcyBvYmplY3RcbiAgICAgIGlmIChvcHRpb25zLnJhdyAmJiAhKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlKSAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzKSAmJiAhdGhpcy5jb25zdHJ1Y3Rvci5faGFzRGF0ZUF0dHJpYnV0ZXMgJiYgIXRoaXMuY29uc3RydWN0b3IuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmRhdGFWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGF0YVZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiByYXcsIC5jaGFuZ2VkKCkgc2hvdWxkbid0IGJlIHRydWVcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0geyAuLi50aGlzLmRhdGFWYWx1ZXMgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExvb3AgYW5kIGNhbGwgc2V0XG4gICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBjb25zdCBzZXRLZXlzID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgZGF0YSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWVzW2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnNldChrLCB2YWx1ZXNba10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0S2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNWaXJ0dWFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgc2V0S2V5cyh0aGlzLmNvbnN0cnVjdG9yLl92aXJ0dWFsQXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcykge1xuICAgICAgICAgICAgc2V0S2V5cyh0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZXNba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmF3KSB7XG4gICAgICAgICAgLy8gSWYgcmF3LCAuY2hhbmdlZCgpIHNob3VsZG4ndCBiZSB0cnVlXG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0geyAuLi50aGlzLmRhdGFWYWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMucmF3KSB7XG4gICAgICBvcmlnaW5hbFZhbHVlID0gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IHJhdywgYW5kIHRoZXJlJ3MgYSBjdXN0b20gc2V0dGVyXG4gICAgaWYgKCFvcHRpb25zLnJhdyAmJiB0aGlzLl9jdXN0b21TZXR0ZXJzW2tleV0pIHtcbiAgICAgIHRoaXMuX2N1c3RvbVNldHRlcnNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgLy8gY3VzdG9tIHNldHRlciBzaG91bGQgaGF2ZSBjaGFuZ2VkIHZhbHVlLCBnZXQgdGhhdCBjaGFuZ2VkIHZhbHVlXG4gICAgICAvLyBUT0RPOiB2NSBtYWtlIHNldHRlcnMgcmV0dXJuIG5ldyB2YWx1ZSBpbnN0ZWFkIG9mIGNoYW5naW5nIGludGVybmFsIHN0b3JlXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgICAgaWYgKCFfLmlzRXF1YWwobmV3VmFsdWUsIG9yaWdpbmFsVmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgaW5jbHVkZWQgbW9kZWxzLCBhbmQgaWYgdGhpcyBrZXkgbWF0Y2hlcyB0aGUgaW5jbHVkZSBtb2RlbCBuYW1lcy9hbGlhc2VzXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAvLyBQYXNzIGl0IG9uIHRvIHRoZSBpbmNsdWRlIGhhbmRsZXJcbiAgICAgICAgdGhpcy5fc2V0SW5jbHVkZShrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBCdW5jaCBvZiBzdHVmZiB3ZSB3b24ndCBkbyB3aGVuIGl0J3MgcmF3XG4gICAgICBpZiAoIW9wdGlvbnMucmF3KSB7XG4gICAgICAgIC8vIElmIGF0dHJpYnV0ZSBpcyBub3QgaW4gbW9kZWwgZGVmaW5pdGlvbiwgcmV0dXJuXG4gICAgICAgIGlmICghdGhpcy5faXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9qc29uQXR0cmlidXRlcy5oYXMoa2V5LnNwbGl0KCcuJylbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c05lc3RlZFZhbHVlID0gRG90dGllLmdldCh0aGlzLmRhdGFWYWx1ZXMsIGtleSk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2aW91c05lc3RlZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgRG90dGllLnNldCh0aGlzLmRhdGFWYWx1ZXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LnNwbGl0KCcuJylbMF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gc2V0IHByaW1hcnkga2V5IGFuZCBwcmltYXJ5IGtleSBpcyBhbHJlYWR5IGRlZmluZWQsIHJldHVyblxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzUHJpbWFyeUtleXMgJiYgb3JpZ2luYWxWYWx1ZSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9pc1ByaW1hcnlLZXkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBzZXQgcmVhZCBvbmx5IGF0dHJpYnV0ZXMsIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5jb25zdHJ1Y3Rvci5faGFzUmVhZE9ubHlBdHRyaWJ1dGVzICYmIHRoaXMuY29uc3RydWN0b3IuX3JlYWRPbmx5QXR0cmlidXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBkYXRhIHR5cGUgc2FuaXRpemVyXG4gICAgICBpZiAoXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpXG4gICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZVNhbml0aXplcnMsIGtleSlcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlU2FuaXRpemVyc1trZXldLmNhbGwodGhpcywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgYW5kIG5vdCByYXdcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnMucmF3ICYmXG4gICAgICAgIChcbiAgICAgICAgICAvLyBUcnVlIHdoZW4gc2VxdWVsaXplIG1ldGhvZFxuICAgICAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fFxuICAgICAgICAgIC8vIENoZWNrIGZvciBkYXRhIHR5cGUgdHlwZSBjb21wYXJhdG9yc1xuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpICYmIHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldICYmIHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldLmNhbGwodGhpcywgdmFsdWUsIG9yaWdpbmFsVmFsdWUsIG9wdGlvbnMpIHx8IC8vIENoZWNrIGRlZmF1bHRcbiAgICAgICAgICAhdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0gJiYgIV8uaXNFcXVhbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgZGF0YSB2YWx1ZVxuICAgICAgdGhpcy5kYXRhVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBdHRyaWJ1dGVzKHVwZGF0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodXBkYXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogSWYgY2hhbmdlZCBpcyBjYWxsZWQgd2l0aCBhIHN0cmluZyBpdCB3aWxsIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBvZiB0aGF0IGtleSBpbiBgZGF0YVZhbHVlc2AgaXMgZGlmZmVyZW50IGZyb20gdGhlIHZhbHVlIGluIGBfcHJldmlvdXNEYXRhVmFsdWVzYC5cbiAgICpcbiAgICogSWYgY2hhbmdlZCBpcyBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgaXQgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Yga2V5cyB0aGF0IGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogSWYgY2hhbmdlZCBpcyBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCBhbmQgbm8ga2V5cyBoYXZlIGNoYW5nZWQsIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgZmFsc2VgIHdoZW4gYSBwcm9wZXJ0eSBmcm9tIGEgbmVzdGVkIChmb3IgZXhhbXBsZSBKU09OKSBwcm9wZXJ0eVxuICAgKiB3YXMgZWRpdGVkIG1hbnVhbGx5LCB5b3UgbXVzdCBjYWxsIGBjaGFuZ2VkKCdrZXknLCB0cnVlKWAgbWFudWFsbHkgaW4gdGhlc2UgY2FzZXMuXG4gICAqIFdyaXRpbmcgYW4gZW50aXJlbHkgbmV3IG9iamVjdCAoZWcuIGRlZXAgY2xvbmVkKSB3aWxsIGJlIGRldGVjdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgbWRsID0gYXdhaXQgTXlNb2RlbC5maW5kT25lKCk7XG4gICAqIG1kbC5teUpzb25GaWVsZC5hID0gMTtcbiAgICogY29uc29sZS5sb2cobWRsLmNoYW5nZWQoKSkgPT4gZmFsc2VcbiAgICogbWRsLnNhdmUoKTsgLy8gdGhpcyB3aWxsIG5vdCBzYXZlIGFueXRoaW5nXG4gICAqIG1kbC5jaGFuZ2VkKCdteUpzb25GaWVsZCcsIHRydWUpO1xuICAgKiBjb25zb2xlLmxvZyhtZGwuY2hhbmdlZCgpKSA9PiBbJ215SnNvbkZpZWxkJ11cbiAgICogbWRsLnNhdmUoKTsgLy8gd2lsbCBzYXZlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0ga2V5IHRvIGNoZWNrIG9yIGNoYW5nZSBzdGF0dXMgb2ZcbiAgICogQHBhcmFtIHthbnl9IFt2YWx1ZV0gdmFsdWUgdG8gc2V0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufEFycmF5fVxuICAgKi9cbiAgY2hhbmdlZChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fY2hhbmdlZC5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9jaGFuZ2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmFkZChrZXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWQuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgdmFsdWUgZm9yIGtleSBmcm9tIGBfcHJldmlvdXNEYXRhVmFsdWVzYC5cbiAgICpcbiAgICogSWYgY2FsbGVkIHdpdGhvdXQgYSBrZXksIHJldHVybnMgdGhlIHByZXZpb3VzIHZhbHVlcyBmb3IgYWxsIHZhbHVlcyB3aGljaCBoYXZlIGNoYW5nZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIGtleSB0byBnZXQgcHJldmlvdXMgdmFsdWUgb2ZcbiAgICpcbiAgICogQHJldHVybnMge2FueXxBcnJheTxhbnk+fVxuICAgKi9cbiAgcHJldmlvdXMoa2V5KSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfLnBpY2tCeSh0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB0aGlzLmNoYW5nZWQoa2V5KSk7XG4gIH1cblxuICBfc2V0SW5jbHVkZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdO1xuICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChpbnN0YW5jZSA9PiBpbnN0YW5jZS5kYXRhVmFsdWVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmNsdWRlID0gdGhpcy5fb3B0aW9ucy5pbmNsdWRlTWFwW2tleV07XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IGFjY2Vzc29yID0ga2V5O1xuICAgIGNvbnN0IHByaW1hcnlLZXlBdHRyaWJ1dGUgPSBpbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgY2hpbGRPcHRpb25zID0ge1xuICAgICAgaXNOZXdSZWNvcmQ6IHRoaXMuaXNOZXdSZWNvcmQsXG4gICAgICBpbmNsdWRlOiBpbmNsdWRlLmluY2x1ZGUsXG4gICAgICBpbmNsdWRlTmFtZXM6IGluY2x1ZGUuaW5jbHVkZU5hbWVzLFxuICAgICAgaW5jbHVkZU1hcDogaW5jbHVkZS5pbmNsdWRlTWFwLFxuICAgICAgaW5jbHVkZVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgIHJhdzogb3B0aW9ucy5yYXcsXG4gICAgICBhdHRyaWJ1dGVzOiBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlc1xuICAgIH07XG4gICAgbGV0IGlzRW1wdHk7XG5cbiAgICBpZiAoaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCB8fCBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaXNFbXB0eSA9IHZhbHVlICYmIHZhbHVlW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsO1xuICAgICAgICB0aGlzW2FjY2Vzc29yXSA9IHRoaXMuZGF0YVZhbHVlc1thY2Nlc3Nvcl0gPSBpc0VtcHR5ID8gbnVsbCA6IGluY2x1ZGUubW9kZWwuYnVpbGQodmFsdWUsIGNoaWxkT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0VtcHR5ID0gdmFsdWVbMF0gJiYgdmFsdWVbMF1bcHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG51bGw7XG4gICAgICAgIHRoaXNbYWNjZXNzb3JdID0gdGhpcy5kYXRhVmFsdWVzW2FjY2Vzc29yXSA9IGlzRW1wdHkgPyBbXSA6IGluY2x1ZGUubW9kZWwuYnVsa0J1aWxkKHZhbHVlLCBjaGlsZE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhpcyBpbnN0YW5jZSwgYW5kIGlmIHRoZSB2YWxpZGF0aW9uIHBhc3NlcywgcGVyc2lzdHMgaXQgdG8gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzYXZlZCBpbnN0YW5jZSAob3IgcmVqZWN0cyB3aXRoIGEgYFNlcXVlbGl6ZS5WYWxpZGF0aW9uRXJyb3JgLCB3aGljaCB3aWxsIGhhdmUgYSBwcm9wZXJ0eSBmb3IgZWFjaCBvZiB0aGUgZmllbGRzIGZvciB3aGljaCB0aGUgdmFsaWRhdGlvbiBmYWlsZWQsIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UgZm9yIHRoYXQgZmllbGQpLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBvcHRpbWl6ZWQgdG8gcGVyZm9ybSBhbiBVUERBVEUgb25seSBpbnRvIHRoZSBmaWVsZHMgdGhhdCBjaGFuZ2VkLiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBubyBTUUwgcXVlcnkgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhd2FyZSBvZiBlYWdlciBsb2FkZWQgYXNzb2NpYXRpb25zLiBJbiBvdGhlciB3b3JkcywgaWYgc29tZSBvdGhlciBtb2RlbCBpbnN0YW5jZSAoY2hpbGQpIHdhcyBlYWdlciBsb2FkZWQgd2l0aCB0aGlzIGluc3RhbmNlIChwYXJlbnQpLCBhbmQgeW91IGNoYW5nZSBzb21ldGhpbmcgaW4gdGhlIGNoaWxkLCBjYWxsaW5nIGBzYXZlKClgIHdpbGwgc2ltcGx5IGlnbm9yZSB0aGUgY2hhbmdlIHRoYXQgaGFwcGVuZWQgb24gdGhlIGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9uc10gc2F2ZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nW119ICAgIFtvcHRpb25zLmZpZWxkc10gQW4gb3B0aW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgcmVwcmVzZW50aW5nIGRhdGFiYXNlIGNvbHVtbnMuIElmIGZpZWxkcyBpcyBwcm92aWRlZCwgb25seSB0aG9zZSBjb2x1bW5zIHdpbGwgYmUgdmFsaWRhdGVkIGFuZCBzYXZlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMuc2lsZW50PWZhbHNlXSBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy52YWxpZGF0ZT10cnVlXSBJZiBmYWxzZSwgdmFsaWRhdGlvbnMgd29uJ3QgYmUgcnVuLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5ob29rcz10cnVlXSBSdW4gYmVmb3JlIGFuZCBhZnRlciBjcmVhdGUgLyB1cGRhdGUgKyB2YWxpZGF0ZSBob29rc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLnJldHVybmluZ10gQXBwZW5kIFJFVFVSTklORyAqIHRvIGdldCBiYWNrIGF1dG8gZ2VuZXJhdGVkIHZhbHVlcyAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgYXN5bmMgc2F2ZShvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YgdGhlIG9wdGlvbnMgb2JqZWN0LicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbih0aGlzLmNoYW5nZWQoKSwgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJldHVybmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5hc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcmltYXJ5S2V5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBjb25zdCBwcmltYXJ5S2V5QXR0cmlidXRlID0gcHJpbWFyeUtleU5hbWUgJiYgdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3ByaW1hcnlLZXlOYW1lXTtcbiAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQ7XG4gICAgY29uc3QgdmVyc2lvbkF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl92ZXJzaW9uQXR0cmlidXRlO1xuICAgIGNvbnN0IGhvb2sgPSB0aGlzLmlzTmV3UmVjb3JkID8gJ0NyZWF0ZScgOiAnVXBkYXRlJztcbiAgICBjb25zdCB3YXNOZXdSZWNvcmQgPSB0aGlzLmlzTmV3UmVjb3JkO1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIGxldCB1cGRhdGVkQXRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG5cbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiBvcHRpb25zLmZpZWxkcy5sZW5ndGggPj0gMSAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uQXR0ciAmJiBvcHRpb25zLmZpZWxkcy5sZW5ndGggPj0gMSAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModmVyc2lvbkF0dHIpKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHZlcnNpb25BdHRyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaWxlbnQgPT09IHRydWUgJiYgISh0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuZ2V0KHVwZGF0ZWRBdEF0dHIsIHsgcmF3OiB0cnVlIH0pKSkge1xuICAgICAgLy8gVXBkYXRlQXRBdHRyIG1pZ2h0IGhhdmUgYmVlbiBhZGRlZCBhcyBhIHJlc3VsdCBvZiBPYmplY3Qua2V5cyhNb2RlbC5yYXdBdHRyaWJ1dGVzKS4gSW4gdGhhdCBjYXNlIHdlIGhhdmUgdG8gcmVtb3ZlIGl0IGFnYWluXG4gICAgICBfLnJlbW92ZShvcHRpb25zLmZpZWxkcywgdmFsID0+IHZhbCA9PT0gdXBkYXRlZEF0QXR0cik7XG4gICAgICB1cGRhdGVkQXRBdHRyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhjcmVhdGVkQXRBdHRyKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGNyZWF0ZWRBdEF0dHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpbWFyeUtleUF0dHJpYnV0ZSAmJiBwcmltYXJ5S2V5QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMocHJpbWFyeUtleU5hbWUpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnVuc2hpZnQocHJpbWFyeUtleU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkID09PSBmYWxzZSkge1xuICAgICAgaWYgKHByaW1hcnlLZXlOYW1lICYmIHRoaXMuZ2V0KHByaW1hcnlLZXlOYW1lLCB7IHJhdzogdHJ1ZSB9KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGF0dGVtcHRlZCB0byBzYXZlIGFuIGluc3RhbmNlIHdpdGggbm8gcHJpbWFyeSBrZXksIHRoaXMgaXMgbm90IGFsbG93ZWQgc2luY2UgaXQgd291bGQgcmVzdWx0IGluIGEgZ2xvYmFsIHVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFvcHRpb25zLnNpbGVudCAmJiBvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgdGhpcy5kYXRhVmFsdWVzW3VwZGF0ZWRBdEF0dHJdID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgJiYgY3JlYXRlZEF0QXR0ciAmJiAhdGhpcy5kYXRhVmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICB0aGlzLmRhdGFWYWx1ZXNbY3JlYXRlZEF0QXR0cl0gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXREZWZhdWx0VGltZXN0YW1wKGNyZWF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZVxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBSdW4gYmVmb3JlIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgY29uc3QgYmVmb3JlSG9va1ZhbHVlcyA9IF8ucGljayh0aGlzLmRhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzKTtcbiAgICAgIGxldCBpZ25vcmVDaGFuZ2VkID0gXy5kaWZmZXJlbmNlKHRoaXMuY2hhbmdlZCgpLCBvcHRpb25zLmZpZWxkcyk7IC8vIEluIGNhc2Ugb2YgdXBkYXRlIHdoZXJlIGl0J3Mgb25seSBzdXBwb3NlZCB0byB1cGRhdGUgdGhlIHBhc3NlZCB2YWx1ZXMgYW5kIHRoZSBob29rIHZhbHVlc1xuICAgICAgbGV0IGhvb2tDaGFuZ2VkO1xuICAgICAgbGV0IGFmdGVySG9va1ZhbHVlcztcblxuICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgaWdub3JlQ2hhbmdlZCA9IF8ud2l0aG91dChpZ25vcmVDaGFuZ2VkLCB1cGRhdGVkQXRBdHRyKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhgYmVmb3JlJHtob29rfWAsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdEZpZWxkcyAmJiAhdGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBhZnRlckhvb2tWYWx1ZXMgPSBfLnBpY2sodGhpcy5kYXRhVmFsdWVzLCBfLmRpZmZlcmVuY2UodGhpcy5jaGFuZ2VkKCksIGlnbm9yZUNoYW5nZWQpKTtcblxuICAgICAgICBob29rQ2hhbmdlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhZnRlckhvb2tWYWx1ZXMpKSB7XG4gICAgICAgICAgaWYgKGFmdGVySG9va1ZhbHVlc1trZXldICE9PSBiZWZvcmVIb29rVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIGhvb2tDaGFuZ2VkLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pcShvcHRpb25zLmZpZWxkcy5jb25jYXQoaG9va0NoYW5nZWQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvb2tDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICAgICAgLy8gVmFsaWRhdGUgYWdhaW5cblxuICAgICAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpLCBob29rQ2hhbmdlZCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5za2lwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpZWxkcy5sZW5ndGggJiYgdGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fb3B0aW9ucy5pbmNsdWRlLmZpbHRlcihpbmNsdWRlID0+IGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8pLm1hcChhc3luYyBpbmNsdWRlID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpXG4gICAgICAgICAgLm9taXQoWydhc3NvY2lhdGlvbiddKVxuICAgICAgICAgIC5kZWZhdWx0cyh7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgICAgIHBhcmVudFJlY29yZDogdGhpc1xuICAgICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG5cbiAgICAgICAgYXdhaXQgdGhpc1tpbmNsdWRlLmFzc29jaWF0aW9uLmFjY2Vzc29ycy5zZXRdKGluc3RhbmNlLCB7IHNhdmU6IGZhbHNlLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxGaWVsZHMgPSBvcHRpb25zLmZpZWxkcy5maWx0ZXIoZmllbGQgPT4gIXRoaXMuY29uc3RydWN0b3IuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhmaWVsZCkpO1xuICAgIGlmICghcmVhbEZpZWxkcy5sZW5ndGgpIHJldHVybiB0aGlzO1xuICAgIGlmICghdGhpcy5jaGFuZ2VkKCkgJiYgIXRoaXMuaXNOZXdSZWNvcmQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgdmVyc2lvbkZpZWxkTmFtZSA9IF8uZ2V0KHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1t2ZXJzaW9uQXR0cl0sICdmaWVsZCcpIHx8IHZlcnNpb25BdHRyO1xuICAgIGNvbnN0IHZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh0aGlzLmRhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICBsZXQgcXVlcnkgPSBudWxsO1xuICAgIGxldCBhcmdzID0gW107XG4gICAgbGV0IHdoZXJlO1xuXG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgIHF1ZXJ5ID0gJ2luc2VydCc7XG4gICAgICBhcmdzID0gW3RoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXMsIG9wdGlvbnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZSA9IHRoaXMud2hlcmUodHJ1ZSk7XG4gICAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgICAgdmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdID0gcGFyc2VJbnQodmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdLCAxMCkgKyAxO1xuICAgICAgfVxuICAgICAgcXVlcnkgPSAndXBkYXRlJztcbiAgICAgIGFyZ3MgPSBbdGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlcywgd2hlcmUsIG9wdGlvbnNdO1xuICAgIH1cblxuICAgIGNvbnN0IFtyZXN1bHQsIHJvd3NVcGRhdGVkXSA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IucXVlcnlJbnRlcmZhY2VbcXVlcnldKC4uLmFyZ3MpO1xuICAgIGlmICh2ZXJzaW9uQXR0cikge1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIHRoYXQgYSByb3cgd2FzIHVwZGF0ZWQsIG90aGVyd2lzZSBpdCdzIGFuIG9wdGltaXN0aWMgbG9ja2luZyBlcnJvci5cbiAgICAgIGlmIChyb3dzVXBkYXRlZCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5PcHRpbWlzdGljTG9ja0Vycm9yKHtcbiAgICAgICAgICBtb2RlbE5hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgd2hlcmVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGF0YVZhbHVlc1t2ZXJzaW9uQXR0cl0gPSB2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmZXIgZGF0YWJhc2UgZ2VuZXJhdGVkIHZhbHVlcyAoZGVmYXVsdHMsIGF1dG9pbmNyZW1lbnQsIGV0YylcbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJlxuICAgICAgICAgIHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHJcbiAgICAgICkge1xuICAgICAgICB2YWx1ZXNbYXR0cl0gPSB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgZGVsZXRlIHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgcmVzdWx0LmRhdGFWYWx1ZXMpO1xuXG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICBpZiAod2FzTmV3UmVjb3JkICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5pbmNsdWRlLmZpbHRlcihpbmNsdWRlID0+ICEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyB8fFxuICAgICAgICAgIGluY2x1ZGUucGFyZW50ICYmIGluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpLm1hcChhc3luYyBpbmNsdWRlID0+IHtcbiAgICAgICAgICBsZXQgaW5zdGFuY2VzID0gdGhpcy5nZXQoaW5jbHVkZS5hcyk7XG5cbiAgICAgICAgICBpZiAoIWluc3RhbmNlcykgcmV0dXJuO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcblxuICAgICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpXG4gICAgICAgICAgICAub21pdChbJ2Fzc29jaWF0aW9uJ10pXG4gICAgICAgICAgICAuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICAgICAgICBwYXJlbnRSZWNvcmQ6IHRoaXNcbiAgICAgICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgICAvLyBJbnN0YW5jZXMgd2lsbCBiZSB1cGRhdGVkIGluIHBsYWNlIHNvIHdlIGNhbiBzYWZlbHkgdHJlYXQgSGFzT25lIGxpa2UgYSBIYXNNYW55XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlczAgPSB7XG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleV06IHRoaXMuZ2V0KHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXldOiBpbnN0YW5jZS5nZXQoaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgICAgICAgICAgICAuLi5pbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2guc2NvcGVcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLl9hdXRvR2VuZXJhdGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSB8fFxuICAgICAgICAgICAgICAgICAgICBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlczBbYXR0cl0gPSBpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWwuY3JlYXRlKHZhbHVlczAsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldChpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXksIHRoaXMuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uc291cmNlS2V5IHx8IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUnVuIGFmdGVyIGhvb2tcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhgYWZ0ZXIke2hvb2t9YCwgcmVzdWx0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgcmVzdWx0Ll9wcmV2aW91c0RhdGFWYWx1ZXNbZmllbGRdID0gcmVzdWx0LmRhdGFWYWx1ZXNbZmllbGRdO1xuICAgICAgdGhpcy5jaGFuZ2VkKGZpZWxkLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuaXNOZXdSZWNvcmQgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY3VycmVudCBpbnN0YW5jZSBpbi1wbGFjZSwgaS5lLiB1cGRhdGUgdGhlIG9iamVjdCB3aXRoIGN1cnJlbnQgZGF0YSBmcm9tIHRoZSBEQiBhbmQgcmV0dXJuIHRoZSBzYW1lIG9iamVjdC5cbiAgICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBkb2luZyBhIGBmaW5kKEluc3RhbmNlLmlkKWAsIGJlY2F1c2UgdGhhdCB3b3VsZCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZS4gV2l0aCB0aGlzIG1ldGhvZCxcbiAgICogYWxsIHJlZmVyZW5jZXMgdG8gdGhlIEluc3RhbmNlIGFyZSB1cGRhdGVkIHdpdGggdGhlIG5ldyBkYXRhIGFuZCBubyBuZXcgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCBvbiB0byBgTW9kZWwuZmluZGBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICovXG4gIGFzeW5jIHJlbG9hZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKHtcbiAgICAgIHdoZXJlOiB0aGlzLndoZXJlKClcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICBpbmNsdWRlOiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG5cbiAgICBjb25zdCByZWxvYWRlZCA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoIXJlbG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkluc3RhbmNlRXJyb3IoXG4gICAgICAgICdJbnN0YW5jZSBjb3VsZCBub3QgYmUgcmVsb2FkZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBhbnltb3JlIChmaW5kIGNhbGwgcmV0dXJuZWQgbnVsbCknXG4gICAgICApO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIGludGVybmFsIG9wdGlvbnMgb2YgdGhlIGluc3RhbmNlXG4gICAgdGhpcy5fb3B0aW9ucyA9IHJlbG9hZGVkLl9vcHRpb25zO1xuICAgIC8vIHJlLXNldCBpbnN0YW5jZSB2YWx1ZXNcbiAgICB0aGlzLnNldChyZWxvYWRlZC5kYXRhVmFsdWVzLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICByZXNldDogdHJ1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFZhbGlkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHZhbGlkYXRpb24gcnVsZXMgc2V0IGluIHRoZSBtb2RlbCBkZWZpbml0aW9uLlxuICAqXG4gICogVGhlIHByb21pc2UgZnVsZmlsbHMgaWYgYW5kIG9ubHkgaWYgdmFsaWRhdGlvbiBzdWNjZXNzZnVsOyBvdGhlcndpc2UgaXQgcmVqZWN0cyBhbiBFcnJvciBpbnN0YW5jZSBjb250YWluaW5nIHsgZmllbGQgbmFtZSA6IFtlcnJvciBtc2dzXSB9IGVudHJpZXMuXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3JcbiAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5za2lwXSBBbiBhcnJheSBvZiBzdHJpbmdzLiBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBpbiB0aGlzIGFycmF5IHdpbGwgbm90IGJlIHZhbGlkYXRlZFxuICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmZpZWxkc10gQW4gYXJyYXkgb2Ygc3RyaW5ncy4gT25seSB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBpbiB0aGlzIGFycmF5IHdpbGwgYmUgdmFsaWRhdGVkXG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ob29rcz10cnVlXSBSdW4gYmVmb3JlIGFuZCBhZnRlciB2YWxpZGF0ZSBob29rc1xuICAqXG4gICogQHJldHVybnMge1Byb21pc2V9XG4gICovXG4gIGFzeW5jIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEluc3RhbmNlVmFsaWRhdG9yKHRoaXMsIG9wdGlvbnMpLnZhbGlkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIGBzZXRgIGFuZCB0aGVuIGNhbGxpbmcgYHNhdmVgIGJ1dCBpdCBvbmx5IHNhdmVzIHRoZVxuICAgKiBleGFjdCB2YWx1ZXMgcGFzc2VkIHRvIGl0LCBtYWtpbmcgaXQgbW9yZSBhdG9taWMgYW5kIHNhZmVyLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNzZXR9XG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI3NhdmV9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgU2VlIGBzZXRgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFNlZSBgc2F2ZWBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWw+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIC8vIENsb25lIHZhbHVlcyBzbyBpdCBkb2Vzbid0IGdldCBtb2RpZmllZCBmb3IgY2FsbGVyIHNjb3BlIGFuZCBpZ25vcmUgdW5kZWZpbmVkIHZhbHVlc1xuICAgIHZhbHVlcyA9IF8ub21pdEJ5KHZhbHVlcywgdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBjaGFuZ2VkQmVmb3JlID0gdGhpcy5jaGFuZ2VkKCkgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkgb3B0aW9ucyA9IHsgZmllbGRzOiBvcHRpb25zIH07XG5cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNldE9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgc2V0T3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy5zZXQodmFsdWVzLCBzZXRPcHRpb25zKTtcblxuICAgIC8vIE5vdyB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggZmllbGRzIHdlcmUgYWN0dWFsbHkgYWZmZWN0ZWQgYnkgdGhlIHNldHRlci5cbiAgICBjb25zdCBzaWRlRWZmZWN0cyA9IF8ud2l0aG91dCh0aGlzLmNoYW5nZWQoKSwgLi4uY2hhbmdlZEJlZm9yZSk7XG4gICAgY29uc3QgZmllbGRzID0gXy51bmlvbihPYmplY3Qua2V5cyh2YWx1ZXMpLCBzaWRlRWZmZWN0cyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKGZpZWxkcywgdGhpcy5jaGFuZ2VkKCkpO1xuICAgICAgb3B0aW9ucy5kZWZhdWx0RmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2F2ZShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSByb3cgY29ycmVzcG9uZGluZyB0byB0aGlzIGluc3RhbmNlLiBEZXBlbmRpbmcgb24geW91ciBzZXR0aW5nIGZvciBwYXJhbm9pZCwgdGhlIHJvdyB3aWxsIGVpdGhlciBiZSBjb21wbGV0ZWx5IGRlbGV0ZWQsIG9yIGhhdmUgaXRzIGRlbGV0ZWRBdCB0aW1lc3RhbXAgc2V0IHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtvcHRpb25zPXt9XSBkZXN0cm95IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMuZm9yY2U9ZmFsc2VdIElmIHNldCB0byB0cnVlLCBwYXJhbm9pZCBtb2RlbHMgd2lsbCBhY3R1YWxseSBiZSBkZWxldGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIFtvcHRpb25zLnNlYXJjaFBhdGg9REVGQVVMVF0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIHNjaGVtYSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKCdiZWZvcmVEZXN0cm95JywgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHdoZXJlID0gdGhpcy53aGVyZSh0cnVlKTtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmIG9wdGlvbnMuZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCAnZGVmYXVsdFZhbHVlJylcbiAgICAgICAgPyBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0RGF0YVZhbHVlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgY29uc3QgdW5kZWZpbmVkT3JOdWxsID0gY3VycmVudFZhbHVlID09IG51bGwgJiYgZGVmYXVsdFZhbHVlID09IG51bGw7XG4gICAgICBpZiAodW5kZWZpbmVkT3JOdWxsIHx8IF8uaXNFcXVhbChjdXJyZW50VmFsdWUsIGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgdGltZXN0YW1wIGlmIGl0IHdhc24ndCBhbHJlYWR5IHNldFxuICAgICAgICB0aGlzLnNldERhdGFWYWx1ZShhdHRyaWJ1dGVOYW1lLCBuZXcgRGF0ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYXZlKHsgLi4ub3B0aW9ucywgaG9va3M6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnF1ZXJ5SW50ZXJmYWNlLmRlbGV0ZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgd2hlcmUsIHsgdHlwZTogUXVlcnlUeXBlcy5ERUxFVEUsIGxpbWl0OiBudWxsLCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvLyBSdW4gYWZ0ZXIgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKCdhZnRlckRlc3Ryb3knLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGluc3RhbmNlIGlzIFwic29mdCBkZWxldGVkXCIuICBUaGlzIGlzXG4gICAqIHBhcnRpY3VsYXJseSB1c2VmdWwgaWYgdGhlIGltcGxlbWVudGVyIHJlbmFtZWQgdGhlIGBkZWxldGVkQXRgIGF0dHJpYnV0ZVxuICAgKiB0byBzb21ldGhpbmcgZGlmZmVyZW50LiAgVGhpcyBtZXRob2QgcmVxdWlyZXMgYHBhcmFub2lkYCB0byBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU29mdERlbGV0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlbCBpcyBub3QgcGFyYW5vaWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IHRoaXMuZ2V0KHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB8fCBudWxsO1xuICAgIGNvbnN0IGlzU2V0ID0gZGVsZXRlZEF0ICE9PSBkZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gaXNTZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSB0aGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZS4gT25seSBhdmFpbGFibGUgZm9yIHBhcmFub2lkIG1vZGVscy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW29wdGlvbnM9e31dIHJlc3RvcmUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlc3RvcmUob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHRocm93IG5ldyBFcnJvcignTW9kZWwgaXMgbm90IHBhcmFub2lkJyk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIC8vIFJ1biBiZWZvcmUgaG9va1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKCdiZWZvcmVSZXN0b3JlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuXG4gICAgdGhpcy5zZXREYXRhVmFsdWUoZGVsZXRlZEF0Q29sLCBkZWxldGVkQXREZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2F2ZSh7IC4uLm9wdGlvbnMsIGhvb2tzOiBmYWxzZSwgb21pdE51bGw6IGZhbHNlIH0pO1xuICAgIC8vIFJ1biBhZnRlciBob29rXG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoJ2FmdGVyUmVzdG9yZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHZhbHVlIG9mIG9uZSBvciBtb3JlIGNvbHVtbnMuIFRoaXMgaXMgZG9uZSBpbiB0aGUgZGF0YWJhc2UsIHdoaWNoIG1lYW5zIGl0IGRvZXMgbm90IHVzZSB0aGUgdmFsdWVzIGN1cnJlbnRseSBzdG9yZWQgb24gdGhlIEluc3RhbmNlLiBUaGUgaW5jcmVtZW50IGlzIGRvbmUgdXNpbmcgYVxuICAgKiBgYGBzcWxcbiAgICogU0VUIGNvbHVtbiA9IGNvbHVtbiArIFhcbiAgICogYGBgXG4gICAqIHF1ZXJ5LiBUaGUgdXBkYXRlZCBpbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkIGJ5IGRlZmF1bHQgaW4gUG9zdGdyZXMuIEhvd2V2ZXIsIGluIG90aGVyIGRpYWxlY3RzLCB5b3Ugd2lsbCBuZWVkIHRvIGRvIGEgcmVsb2FkIHRvIGdldCB0aGUgbmV3IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW5zdGFuY2UuaW5jcmVtZW50KCdudW1iZXInKSAvLyBpbmNyZW1lbnQgbnVtYmVyIGJ5IDFcbiAgICpcbiAgICogaW5zdGFuY2UuaW5jcmVtZW50KFsnbnVtYmVyJywgJ2NvdW50J10sIHsgYnk6IDIgfSkgLy8gaW5jcmVtZW50IG51bWJlciBhbmQgY291bnQgYnkgMlxuICAgKlxuICAgKiAvLyBpbmNyZW1lbnQgYW5zd2VyIGJ5IDQyLCBhbmQgdHJpZXMgYnkgMS5cbiAgICogLy8gYGJ5YCBpcyBpZ25vcmVkLCBzaW5jZSBlYWNoIGNvbHVtbiBoYXMgaXRzIG93biB2YWx1ZVxuICAgKiBpbnN0YW5jZS5pbmNyZW1lbnQoeyBhbnN3ZXI6IDQyLCB0cmllczogMX0sIHsgYnk6IDIgfSlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwjcmVsb2FkfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheXxvYmplY3R9IGZpZWxkcyBJZiBhIHN0cmluZyBpcyBwcm92aWRlZCwgdGhhdCBjb2x1bW4gaXMgaW5jcmVtZW50ZWQgYnkgdGhlIHZhbHVlIG9mIGBieWAgZ2l2ZW4gaW4gb3B0aW9ucy4gSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZSBzYW1lIGlzIHRydWUgZm9yIGVhY2ggY29sdW1uLiBJZiBhbmQgb2JqZWN0IGlzIHByb3ZpZGVkLCBlYWNoIGNvbHVtbiBpcyBpbmNyZW1lbnRlZCBieSB0aGUgdmFsdWUgZ2l2ZW4uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYnk9MV0gVGhlIG51bWJlciB0byBpbmNyZW1lbnQgYnlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdIElmIHRydWUsIHRoZSB1cGRhdGVkQXQgdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVHJhbnNhY3Rpb24gdG8gcnVuIHF1ZXJ5IHVuZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuaW5nPXRydWVdIEFwcGVuZCBSRVRVUk5JTkcgKiB0byBnZXQgYmFjayBhdXRvIGdlbmVyYXRlZCB2YWx1ZXMgKFBvc3RncmVzIG9ubHkpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVsPn1cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBhc3luYyBpbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMud2hlcmUoKTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy53aGVyZSA9IHsgLi4ub3B0aW9ucy53aGVyZSwgLi4uaWRlbnRpZmllciB9O1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5pbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3JlbWVudCB0aGUgdmFsdWUgb2Ygb25lIG9yIG1vcmUgY29sdW1ucy4gVGhpcyBpcyBkb25lIGluIHRoZSBkYXRhYmFzZSwgd2hpY2ggbWVhbnMgaXQgZG9lcyBub3QgdXNlIHRoZSB2YWx1ZXMgY3VycmVudGx5IHN0b3JlZCBvbiB0aGUgSW5zdGFuY2UuIFRoZSBkZWNyZW1lbnQgaXMgZG9uZSB1c2luZyBhXG4gICAqIGBgYHNxbFxuICAgKiBTRVQgY29sdW1uID0gY29sdW1uIC0gWFxuICAgKiBgYGBcbiAgICogcXVlcnkuIFRoZSB1cGRhdGVkIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgYnkgZGVmYXVsdCBpbiBQb3N0Z3Jlcy4gSG93ZXZlciwgaW4gb3RoZXIgZGlhbGVjdHMsIHlvdSB3aWxsIG5lZWQgdG8gZG8gYSByZWxvYWQgdG8gZ2V0IHRoZSBuZXcgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnN0YW5jZS5kZWNyZW1lbnQoJ251bWJlcicpIC8vIGRlY3JlbWVudCBudW1iZXIgYnkgMVxuICAgKlxuICAgKiBpbnN0YW5jZS5kZWNyZW1lbnQoWydudW1iZXInLCAnY291bnQnXSwgeyBieTogMiB9KSAvLyBkZWNyZW1lbnQgbnVtYmVyIGFuZCBjb3VudCBieSAyXG4gICAqXG4gICAqIC8vIGRlY3JlbWVudCBhbnN3ZXIgYnkgNDIsIGFuZCB0cmllcyBieSAxLlxuICAgKiAvLyBgYnlgIGlzIGlnbm9yZWQsIHNpbmNlIGVhY2ggY29sdW1uIGhhcyBpdHMgb3duIHZhbHVlXG4gICAqIGluc3RhbmNlLmRlY3JlbWVudCh7IGFuc3dlcjogNDIsIHRyaWVzOiAxfSwgeyBieTogMiB9KVxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbCNyZWxvYWR9XG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fG9iamVjdH0gZmllbGRzIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGF0IGNvbHVtbiBpcyBkZWNyZW1lbnRlZCBieSB0aGUgdmFsdWUgb2YgYGJ5YCBnaXZlbiBpbiBvcHRpb25zLiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgZWFjaCBjb2x1bW4uIElmIGFuZCBvYmplY3QgaXMgcHJvdmlkZWQsIGVhY2ggY29sdW1uIGlzIGRlY3JlbWVudGVkIGJ5IHRoZSB2YWx1ZSBnaXZlblxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9uc10gZGVjcmVtZW50IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgW29wdGlvbnMuYnk9MV0gVGhlIG51bWJlciB0byBkZWNyZW1lbnQgYnlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW29wdGlvbnMuc2lsZW50PWZhbHNlXSBJZiB0cnVlLCB0aGUgdXBkYXRlZEF0IHRpbWVzdGFtcCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5sb2dnaW5nPWZhbHNlXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCB3aGlsZSBydW5uaW5nIHRoZSBxdWVyeSB0byBsb2cgdGhlIHNxbC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gW29wdGlvbnMudHJhbnNhY3Rpb25dIFRyYW5zYWN0aW9uIHRvIHJ1biBxdWVyeSB1bmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFtvcHRpb25zLnJldHVybmluZz10cnVlXSBBcHBlbmQgUkVUVVJOSU5HICogdG8gZ2V0IGJhY2sgYXV0byBnZW5lcmF0ZWQgdmFsdWVzIChQb3N0Z3JlcyBvbmx5KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRlY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnQoZmllbGRzLCB7XG4gICAgICBieTogMSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBpbmNyZW1lbnQ6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGFuZCBgb3RoZXJgIEluc3RhbmNlIHJlZmVyIHRvIHRoZSBzYW1lIHJvd1xuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBvdGhlciBPdGhlciBpbnN0YW5jZSB0byBjb21wYXJlIGFnYWluc3RcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIW90aGVyIHx8ICFvdGhlci5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5ldmVyeShhdHRyaWJ1dGUgPT4gdGhpcy5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gb3RoZXIuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgaXMgZXF1YWwgdG8gb25lIG9mIGBvdGhlcnNgIGJ5IGNhbGxpbmcgZXF1YWxzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8TW9kZWw+fSBvdGhlcnMgQW4gYXJyYXkgb2YgaW5zdGFuY2VzIHRvIGNoZWNrIGFnYWluc3RcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHNPbmVPZihvdGhlcnMpIHtcbiAgICByZXR1cm4gb3RoZXJzLnNvbWUob3RoZXIgPT4gdGhpcy5lcXVhbHMob3RoZXIpKTtcbiAgfVxuXG4gIHNldFZhbGlkYXRvcnMoYXR0cmlidXRlLCB2YWxpZGF0b3JzKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzW2F0dHJpYnV0ZV0gPSB2YWxpZGF0b3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGluc3RhbmNlIHRvIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICogUHJveGllcyB0byBjYWxsaW5nIGBnZXRgIHdpdGggbm8ga2V5cy5cbiAgICogVGhpcyBtZWFucyBnZXQgYWxsIHZhbHVlcyBnb3R0ZW4gZnJvbSB0aGUgREIsIGFuZCBhcHBseSBhbGwgY3VzdG9tIGdldHRlcnMuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsI2dldH1cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gXy5jbG9uZURlZXAoXG4gICAgICB0aGlzLmdldCh7XG4gICAgICAgIHBsYWluOiB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIDE6bSBhc3NvY2lhdGlvbiBiZXR3ZWVuIHRoaXMgKHRoZSBzb3VyY2UpIGFuZCB0aGUgcHJvdmlkZWQgdGFyZ2V0LlxuICAgKiBUaGUgZm9yZWlnbiBrZXkgaXMgYWRkZWQgb24gdGhlIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbH0gICAgICAgICAgICAgICB0YXJnZXQgVGFyZ2V0IG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgW29wdGlvbnNdIGhhc01hbnkgYXNzb2NpYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgIFtvcHRpb25zLmhvb2tzPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBydW4gYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3Mgd2hlbiBhbiBhc3NvY2lhdGVkIG1vZGVsIGlzIGRlbGV0ZWQgYmVjYXVzZSBvZiBhIGNhc2NhZGUuIEZvciBleGFtcGxlIGlmIGBVc2VyLmhhc09uZShQcm9maWxlLCB7b25EZWxldGU6ICdjYXNjYWRlJywgaG9va3M6dHJ1ZX0pYCwgdGhlIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIGZvciBwcm9maWxlIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGlzIGRlbGV0ZWQuIE90aGVyd2lzZSB0aGUgcHJvZmlsZSB3aWxsIGJlIGRlbGV0ZWQgd2l0aG91dCBpbnZva2luZyBhbnkgaG9va3NcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICBbb3B0aW9ucy5hc10gVGhlIGFsaWFzIG9mIHRoaXMgbW9kZWwuIElmIHlvdSBwcm92aWRlIGEgc3RyaW5nLCBpdCBzaG91bGQgYmUgcGx1cmFsLCBhbmQgd2lsbCBiZSBzaW5ndWxhcml6ZWQgdXNpbmcgbm9kZS5pbmZsZWN0aW9uLiBJZiB5b3Ugd2FudCB0byBjb250cm9sIHRoZSBzaW5ndWxhciB2ZXJzaW9uIHlvdXJzZWxmLCBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGBwbHVyYWxgIGFuZCBgc2luZ3VsYXJgIGtleXMuIFNlZSBhbHNvIHRoZSBgbmFtZWAgb3B0aW9uIHBhc3NlZCB0byBgc2VxdWVsaXplLmRlZmluZWAuIElmIHlvdSBjcmVhdGUgbXVsdGlwbGUgYXNzb2NpYXRpb25zIGJldHdlZW4gdGhlIHNhbWUgdGFibGVzLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYW4gYWxpYXMgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZW0uIElmIHlvdSBwcm92aWRlIGFuIGFsaWFzIHdoZW4gY3JlYXRpbmcgdGhlIGFzc29jaWF0aW9uLCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIHNhbWUgYWxpYXMgd2hlbiBlYWdlciBsb2FkaW5nIGFuZCB3aGVuIGdldHRpbmcgYXNzb2NpYXRlZCBtb2RlbHMuIERlZmF1bHRzIHRvIHRoZSBwbHVyYWxpemVkIG5hbWUgb2YgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgW29wdGlvbnMuZm9yZWlnbktleV0gVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGluIHRoZSB0YXJnZXQgdGFibGUgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciB0aGUgZm9yZWlnbiBjb2x1bW4gKHNlZSBgU2VxdWVsaXplLmRlZmluZWAgZm9yIHN5bnRheCkuIFdoZW4gdXNpbmcgYW4gb2JqZWN0LCB5b3UgY2FuIGFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbi4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2Ygc291cmNlICsgcHJpbWFyeSBrZXkgb2Ygc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgW29wdGlvbnMuc291cmNlS2V5XSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gdXNlIGFzIHRoZSBrZXkgZm9yIHRoZSBhc3NvY2lhdGlvbiBpbiB0aGUgc291cmNlIHRhYmxlLiBEZWZhdWx0cyB0byB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIHNvdXJjZSB0YWJsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zLnNjb3BlXSBBIGtleS92YWx1ZSBzZXQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGFzc29jaWF0aW9uIGNyZWF0ZSBhbmQgZmluZCBkZWZhdWx0cyBvbiB0aGUgdGFyZ2V0LiAoc3FsaXRlIG5vdCBzdXBwb3J0ZWQgZm9yIE46TSlcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBbb3B0aW9ucy5vbkRlbGV0ZT0nU0VUJm5ic3A7TlVMTHxDQVNDQURFJ10gU0VUIE5VTEwgaWYgZm9yZWlnbktleSBhbGxvd3MgbnVsbHMsIENBU0NBREUgaWYgb3RoZXJ3aXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgW29wdGlvbnMub25VcGRhdGU9J0NBU0NBREUnXSBTZXQgYE9OIFVQREFURWBcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy5jb25zdHJhaW50cz10cnVlXSBTaG91bGQgb24gdXBkYXRlIGFuZCBvbiBkZWxldGUgY29uc3RyYWludHMgYmUgZW5hYmxlZCBvbiB0aGUgZm9yZWlnbiBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtIYXNNYW55fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBVc2VyLmhhc01hbnkoUHJvZmlsZSkgLy8gVGhpcyB3aWxsIGFkZCB1c2VySWQgdG8gdGhlIHByb2ZpbGUgdGFibGVcbiAgICovXG4gIHN0YXRpYyBoYXNNYW55KHRhcmdldCwgb3B0aW9ucykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gTjpNIGFzc29jaWF0aW9uIHdpdGggYSBqb2luIHRhYmxlLiBEZWZpbmluZyBgdGhyb3VnaGAgaXMgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICAgICAgdGFyZ2V0IFRhcmdldCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgIG9wdGlvbnMgYmVsb25nc1RvTWFueSBhc3NvY2lhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMuaG9va3M9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHJ1biBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyB3aGVuIGFuIGFzc29jaWF0ZWQgbW9kZWwgaXMgZGVsZXRlZCBiZWNhdXNlIG9mIGEgY2FzY2FkZS4gRm9yIGV4YW1wbGUgaWYgYFVzZXIuaGFzT25lKFByb2ZpbGUsIHtvbkRlbGV0ZTogJ2Nhc2NhZGUnLCBob29rczp0cnVlfSlgLCB0aGUgYmVmb3JlLS9hZnRlckRlc3Ryb3kgaG9va3MgZm9yIHByb2ZpbGUgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgaXMgZGVsZXRlZC4gT3RoZXJ3aXNlIHRoZSBwcm9maWxlIHdpbGwgYmUgZGVsZXRlZCB3aXRob3V0IGludm9raW5nIGFueSBob29rc1xuICAgKiBAcGFyYW0ge01vZGVsfHN0cmluZ3xvYmplY3R9IG9wdGlvbnMudGhyb3VnaCBUaGUgbmFtZSBvZiB0aGUgdGFibGUgdGhhdCBpcyB1c2VkIHRvIGpvaW4gc291cmNlIGFuZCB0YXJnZXQgaW4gbjptIGFzc29jaWF0aW9ucy4gQ2FuIGFsc28gYmUgYSBzZXF1ZWxpemUgbW9kZWwgaWYgeW91IHdhbnQgdG8gZGVmaW5lIHRoZSBqdW5jdGlvbiB0YWJsZSB5b3Vyc2VsZiBhbmQgYWRkIGV4dHJhIGF0dHJpYnV0ZXMgdG8gaXQuXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICAgICAgW29wdGlvbnMudGhyb3VnaC5tb2RlbF0gVGhlIG1vZGVsIHVzZWQgdG8gam9pbiBib3RoIHNpZGVzIG9mIHRoZSBOOk0gYXNzb2NpYXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgW29wdGlvbnMudGhyb3VnaC5zY29wZV0gQSBrZXkvdmFsdWUgc2V0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhc3NvY2lhdGlvbiBjcmVhdGUgYW5kIGZpbmQgZGVmYXVsdHMgb24gdGhlIHRocm91Z2ggbW9kZWwuIChSZW1lbWJlciB0byBhZGQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIHRocm91Z2ggbW9kZWwpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgW29wdGlvbnMudGhyb3VnaC51bmlxdWU9dHJ1ZV0gSWYgdHJ1ZSBhIHVuaXF1ZSBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9yZWlnbiBrZXlzIHVzZWQgKG1pZ2h0IHdhbnQgdG8gdHVybiB0aGlzIG9mZiBhbmQgY3JlYXRlIHNwZWNpZmljIHVuaXF1ZSBrZXlzIHdoZW4gdXNpbmcgc2NvcGVzKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgIFtvcHRpb25zLmFzXSBUaGUgYWxpYXMgb2YgdGhpcyBhc3NvY2lhdGlvbi4gSWYgeW91IHByb3ZpZGUgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBwbHVyYWwsIGFuZCB3aWxsIGJlIHNpbmd1bGFyaXplZCB1c2luZyBub2RlLmluZmxlY3Rpb24uIElmIHlvdSB3YW50IHRvIGNvbnRyb2wgdGhlIHNpbmd1bGFyIHZlcnNpb24geW91cnNlbGYsIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYHBsdXJhbGAgYW5kIGBzaW5ndWxhcmAga2V5cy4gU2VlIGFsc28gdGhlIGBuYW1lYCBvcHRpb24gcGFzc2VkIHRvIGBzZXF1ZWxpemUuZGVmaW5lYC4gSWYgeW91IGNyZWF0ZSBtdWx0aXBsZSBhc3NvY2lhdGlvbnMgYmV0d2VlbiB0aGUgc2FtZSB0YWJsZXMsIHlvdSBzaG91bGQgcHJvdmlkZSBhbiBhbGlhcyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlbS4gSWYgeW91IHByb3ZpZGUgYW4gYWxpYXMgd2hlbiBjcmVhdGluZyB0aGUgYXNzb2NpYXRpb24sIHlvdSBzaG91bGQgcHJvdmlkZSB0aGUgc2FtZSBhbGlhcyB3aGVuIGVhZ2VyIGxvYWRpbmcgYW5kIHdoZW4gZ2V0dGluZyBhc3NvY2lhdGVkIG1vZGVscy4gRGVmYXVsdHMgdG8gdGhlIHBsdXJhbGl6ZWQgbmFtZSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICBbb3B0aW9ucy5mb3JlaWduS2V5XSBUaGUgbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgaW4gdGhlIGpvaW4gdGFibGUgKHJlcHJlc2VudGluZyB0aGUgc291cmNlIG1vZGVsKSBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBmb3JlaWduIGNvbHVtbiAoc2VlIGBTZXF1ZWxpemUuZGVmaW5lYCBmb3Igc3ludGF4KS4gV2hlbiB1c2luZyBhbiBvYmplY3QsIHlvdSBjYW4gYWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uLiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiBzb3VyY2UgKyBwcmltYXJ5IGtleSBvZiBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICBbb3B0aW9ucy5vdGhlcktleV0gVGhlIG5hbWUgb2YgdGhlIGZvcmVpZ24ga2V5IGluIHRoZSBqb2luIHRhYmxlIChyZXByZXNlbnRpbmcgdGhlIHRhcmdldCBtb2RlbCkgb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciB0aGUgb3RoZXIgY29sdW1uIChzZWUgYFNlcXVlbGl6ZS5kZWZpbmVgIGZvciBzeW50YXgpLiBXaGVuIHVzaW5nIGFuIG9iamVjdCwgeW91IGNhbiBhZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gc2V0IHRoZSBuYW1lIG9mIHRoZSBjb2x1bW4uIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRhcmdldCArIHByaW1hcnkga2V5IG9mIHRhcmdldFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zLnNjb3BlXSBBIGtleS92YWx1ZSBzZXQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGFzc29jaWF0aW9uIGNyZWF0ZSBhbmQgZmluZCBkZWZhdWx0cyBvbiB0aGUgdGFyZ2V0LiAoc3FsaXRlIG5vdCBzdXBwb3J0ZWQgZm9yIE46TSlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy50aW1lc3RhbXBzPXNlcXVlbGl6ZS5vcHRpb25zLnRpbWVzdGFtcHNdIFNob3VsZCB0aGUgam9pbiBtb2RlbCBoYXZlIHRpbWVzdGFtcHNcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBbb3B0aW9ucy5vbkRlbGV0ZT0nU0VUJm5ic3A7TlVMTHxDQVNDQURFJ10gQ2FzY2FkZSBpZiB0aGlzIGlzIGEgbjptLCBhbmQgc2V0IG51bGwgaWYgaXQgaXMgYSAxOm1cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBbb3B0aW9ucy5vblVwZGF0ZT0nQ0FTQ0FERSddIFNldHMgYE9OIFVQREFURWBcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICBbb3B0aW9ucy5jb25zdHJhaW50cz10cnVlXSBTaG91bGQgb24gdXBkYXRlIGFuZCBvbiBkZWxldGUgY29uc3RyYWludHMgYmUgZW5hYmxlZCBvbiB0aGUgZm9yZWlnbiBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCZWxvbmdzVG9NYW55fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBdXRvbWFnaWNhbGx5IGdlbmVyYXRlZCBqb2luIG1vZGVsXG4gICAqIFVzZXIuYmVsb25nc1RvTWFueShQcm9qZWN0LCB7IHRocm91Z2g6ICdVc2VyUHJvamVjdHMnIH0pXG4gICAqIFByb2plY3QuYmVsb25nc1RvTWFueShVc2VyLCB7IHRocm91Z2g6ICdVc2VyUHJvamVjdHMnIH0pXG4gICAqXG4gICAqIC8vIEpvaW4gbW9kZWwgd2l0aCBhZGRpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICogY29uc3QgVXNlclByb2plY3RzID0gc2VxdWVsaXplLmRlZmluZSgnVXNlclByb2plY3RzJywge1xuICAgKiAgIHN0YXJ0ZWQ6IFNlcXVlbGl6ZS5CT09MRUFOXG4gICAqIH0pXG4gICAqIFVzZXIuYmVsb25nc1RvTWFueShQcm9qZWN0LCB7IHRocm91Z2g6IFVzZXJQcm9qZWN0cyB9KVxuICAgKiBQcm9qZWN0LmJlbG9uZ3NUb01hbnkoVXNlciwgeyB0aHJvdWdoOiBVc2VyUHJvamVjdHMgfSlcbiAgICovXG4gIHN0YXRpYyBiZWxvbmdzVG9NYW55KHRhcmdldCwgb3B0aW9ucykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzc29jaWF0aW9uIGJldHdlZW4gdGhpcyAodGhlIHNvdXJjZSkgYW5kIHRoZSBwcm92aWRlZCB0YXJnZXQuIFRoZSBmb3JlaWduIGtleSBpcyBhZGRlZCBvbiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgdGFyZ2V0IFRhcmdldCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnNdIGhhc09uZSBhc3NvY2lhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5ob29rcz1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcnVuIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIHdoZW4gYW4gYXNzb2NpYXRlZCBtb2RlbCBpcyBkZWxldGVkIGJlY2F1c2Ugb2YgYSBjYXNjYWRlLiBGb3IgZXhhbXBsZSBpZiBgVXNlci5oYXNPbmUoUHJvZmlsZSwge29uRGVsZXRlOiAnY2FzY2FkZScsIGhvb2tzOnRydWV9KWAsIHRoZSBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyBmb3IgcHJvZmlsZSB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBpcyBkZWxldGVkLiBPdGhlcndpc2UgdGhlIHByb2ZpbGUgd2lsbCBiZSBkZWxldGVkIHdpdGhvdXQgaW52b2tpbmcgYW55IGhvb2tzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5hc10gVGhlIGFsaWFzIG9mIHRoaXMgbW9kZWwsIGluIHNpbmd1bGFyIGZvcm0uIFNlZSBhbHNvIHRoZSBgbmFtZWAgb3B0aW9uIHBhc3NlZCB0byBgc2VxdWVsaXplLmRlZmluZWAuIElmIHlvdSBjcmVhdGUgbXVsdGlwbGUgYXNzb2NpYXRpb25zIGJldHdlZW4gdGhlIHNhbWUgdGFibGVzLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYW4gYWxpYXMgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZW0uIElmIHlvdSBwcm92aWRlIGFuIGFsaWFzIHdoZW4gY3JlYXRpbmcgdGhlIGFzc29jaWF0aW9uLCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIHNhbWUgYWxpYXMgd2hlbiBlYWdlciBsb2FkaW5nIGFuZCB3aGVuIGdldHRpbmcgYXNzb2NpYXRlZCBtb2RlbHMuIERlZmF1bHRzIHRvIHRoZSBzaW5ndWxhcml6ZWQgbmFtZSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgIFtvcHRpb25zLmZvcmVpZ25LZXldIFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBhdHRyaWJ1dGUgaW4gdGhlIHRhcmdldCBtb2RlbCBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBmb3JlaWduIGNvbHVtbiAoc2VlIGBTZXF1ZWxpemUuZGVmaW5lYCBmb3Igc3ludGF4KS4gV2hlbiB1c2luZyBhbiBvYmplY3QsIHlvdSBjYW4gYWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uLiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiBzb3VyY2UgKyBwcmltYXJ5IGtleSBvZiBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLnNvdXJjZUtleV0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byB1c2UgYXMgdGhlIGtleSBmb3IgdGhlIGFzc29jaWF0aW9uIGluIHRoZSBzb3VyY2UgdGFibGUuIERlZmF1bHRzIHRvIHRoZSBwcmltYXJ5IGtleSBvZiB0aGUgc291cmNlIHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5vbkRlbGV0ZT0nU0VUJm5ic3A7TlVMTHxDQVNDQURFJ10gU0VUIE5VTEwgaWYgZm9yZWlnbktleSBhbGxvd3MgbnVsbHMsIENBU0NBREUgaWYgb3RoZXJ3aXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5vblVwZGF0ZT0nQ0FTQ0FERSddIFNldHMgJ09OIFVQREFURSdcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmNvbnN0cmFpbnRzPXRydWVdIFNob3VsZCBvbiB1cGRhdGUgYW5kIG9uIGRlbGV0ZSBjb25zdHJhaW50cyBiZSBlbmFibGVkIG9uIHRoZSBmb3JlaWduIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLnVuaXF1ZUtleV0gVGhlIGN1c3RvbSBuYW1lIGZvciB1bmlxdWUgY29uc3RyYWludC5cbiAgICpcbiAgICogQHJldHVybnMge0hhc09uZX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogVXNlci5oYXNPbmUoUHJvZmlsZSkgLy8gVGhpcyB3aWxsIGFkZCB1c2VySWQgdG8gdGhlIHByb2ZpbGUgdGFibGVcbiAgICovXG4gIHN0YXRpYyBoYXNPbmUodGFyZ2V0LCBvcHRpb25zKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gYmV0d2VlbiB0aGlzICh0aGUgc291cmNlKSBhbmQgdGhlIHByb3ZpZGVkIHRhcmdldC4gVGhlIGZvcmVpZ24ga2V5IGlzIGFkZGVkIG9uIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZWx9ICAgICAgICAgICB0YXJnZXQgVGhlIHRhcmdldCBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnNdIGJlbG9uZ3NUbyBhc3NvY2lhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5ob29rcz1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcnVuIGJlZm9yZS0vYWZ0ZXJEZXN0cm95IGhvb2tzIHdoZW4gYW4gYXNzb2NpYXRlZCBtb2RlbCBpcyBkZWxldGVkIGJlY2F1c2Ugb2YgYSBjYXNjYWRlLiBGb3IgZXhhbXBsZSBpZiBgVXNlci5oYXNPbmUoUHJvZmlsZSwge29uRGVsZXRlOiAnY2FzY2FkZScsIGhvb2tzOnRydWV9KWAsIHRoZSBiZWZvcmUtL2FmdGVyRGVzdHJveSBob29rcyBmb3IgcHJvZmlsZSB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBpcyBkZWxldGVkLiBPdGhlcndpc2UgdGhlIHByb2ZpbGUgd2lsbCBiZSBkZWxldGVkIHdpdGhvdXQgaW52b2tpbmcgYW55IGhvb2tzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5hc10gVGhlIGFsaWFzIG9mIHRoaXMgbW9kZWwsIGluIHNpbmd1bGFyIGZvcm0uIFNlZSBhbHNvIHRoZSBgbmFtZWAgb3B0aW9uIHBhc3NlZCB0byBgc2VxdWVsaXplLmRlZmluZWAuIElmIHlvdSBjcmVhdGUgbXVsdGlwbGUgYXNzb2NpYXRpb25zIGJldHdlZW4gdGhlIHNhbWUgdGFibGVzLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYW4gYWxpYXMgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZW0uIElmIHlvdSBwcm92aWRlIGFuIGFsaWFzIHdoZW4gY3JlYXRpbmcgdGhlIGFzc29jaWF0aW9uLCB5b3Ugc2hvdWxkIHByb3ZpZGUgdGhlIHNhbWUgYWxpYXMgd2hlbiBlYWdlciBsb2FkaW5nIGFuZCB3aGVuIGdldHRpbmcgYXNzb2NpYXRlZCBtb2RlbHMuIERlZmF1bHRzIHRvIHRoZSBzaW5ndWxhcml6ZWQgbmFtZSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgIFtvcHRpb25zLmZvcmVpZ25LZXldIFRoZSBuYW1lIG9mIHRoZSBmb3JlaWduIGtleSBhdHRyaWJ1dGUgaW4gdGhlIHNvdXJjZSB0YWJsZSBvciBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBmb3JlaWduIGNvbHVtbiAoc2VlIGBTZXF1ZWxpemUuZGVmaW5lYCBmb3Igc3ludGF4KS4gV2hlbiB1c2luZyBhbiBvYmplY3QsIHlvdSBjYW4gYWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uLiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiB0YXJnZXQgKyBwcmltYXJ5IGtleSBvZiB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIFtvcHRpb25zLnRhcmdldEtleV0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byB1c2UgYXMgdGhlIGtleSBmb3IgdGhlIGFzc29jaWF0aW9uIGluIHRoZSB0YXJnZXQgdGFibGUuIERlZmF1bHRzIHRvIHRoZSBwcmltYXJ5IGtleSBvZiB0aGUgdGFyZ2V0IHRhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5vbkRlbGV0ZT0nU0VUJm5ic3A7TlVMTHxOTyZuYnNwO0FDVElPTiddIFNFVCBOVUxMIGlmIGZvcmVpZ25LZXkgYWxsb3dzIG51bGxzLCBOTyBBQ1RJT04gaWYgb3RoZXJ3aXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5vblVwZGF0ZT0nQ0FTQ0FERSddIFNldHMgJ09OIFVQREFURSdcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmNvbnN0cmFpbnRzPXRydWVdIFNob3VsZCBvbiB1cGRhdGUgYW5kIG9uIGRlbGV0ZSBjb25zdHJhaW50cyBiZSBlbmFibGVkIG9uIHRoZSBmb3JlaWduIGtleS5cbiAgICpcbiAgICogQHJldHVybnMge0JlbG9uZ3NUb31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogUHJvZmlsZS5iZWxvbmdzVG8oVXNlcikgLy8gVGhpcyB3aWxsIGFkZCB1c2VySWQgdG8gdGhlIHByb2ZpbGUgdGFibGVcbiAgICovXG4gIHN0YXRpYyBiZWxvbmdzVG8odGFyZ2V0LCBvcHRpb25zKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbk9iamVjdC5hc3NpZ24oTW9kZWwsIGFzc29jaWF0aW9uc01peGluKTtcbkhvb2tzLmFwcGx5VG8oTW9kZWwsIHRydWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwiXG4ndXNlIHN0cmljdCc7XG4vKipcbiAqIE9wZXJhdG9yIHN5bWJvbHMgdG8gYmUgdXNlZCB3aGVuIHF1ZXJ5aW5nIGRhdGFcbiAqXG4gKiBAc2VlIHtAbGluayBNb2RlbCN3aGVyZX1cbiAqXG4gKiBAcHJvcGVydHkgZXFcbiAqIEBwcm9wZXJ0eSBuZVxuICogQHByb3BlcnR5IGd0ZVxuICogQHByb3BlcnR5IGd0XG4gKiBAcHJvcGVydHkgbHRlXG4gKiBAcHJvcGVydHkgbHRcbiAqIEBwcm9wZXJ0eSBub3RcbiAqIEBwcm9wZXJ0eSBpc1xuICogQHByb3BlcnR5IGluXG4gKiBAcHJvcGVydHkgbm90SW5cbiAqIEBwcm9wZXJ0eSBsaWtlXG4gKiBAcHJvcGVydHkgbm90TGlrZVxuICogQHByb3BlcnR5IGlMaWtlXG4gKiBAcHJvcGVydHkgbm90SUxpa2VcbiAqIEBwcm9wZXJ0eSBzdGFydHNXaXRoXG4gKiBAcHJvcGVydHkgZW5kc1dpdGhcbiAqIEBwcm9wZXJ0eSBzdWJzdHJpbmdcbiAqIEBwcm9wZXJ0eSByZWdleHBcbiAqIEBwcm9wZXJ0eSBub3RSZWdleHBcbiAqIEBwcm9wZXJ0eSBpUmVnZXhwXG4gKiBAcHJvcGVydHkgbm90SVJlZ2V4cFxuICogQHByb3BlcnR5IGJldHdlZW5cbiAqIEBwcm9wZXJ0eSBub3RCZXR3ZWVuXG4gKiBAcHJvcGVydHkgb3ZlcmxhcFxuICogQHByb3BlcnR5IGNvbnRhaW5zXG4gKiBAcHJvcGVydHkgY29udGFpbmVkXG4gKiBAcHJvcGVydHkgYWRqYWNlbnRcbiAqIEBwcm9wZXJ0eSBzdHJpY3RMZWZ0XG4gKiBAcHJvcGVydHkgc3RyaWN0UmlnaHRcbiAqIEBwcm9wZXJ0eSBub0V4dGVuZFJpZ2h0XG4gKiBAcHJvcGVydHkgbm9FeHRlbmRMZWZ0XG4gKiBAcHJvcGVydHkgYW5kXG4gKiBAcHJvcGVydHkgb3JcbiAqIEBwcm9wZXJ0eSBhbnlcbiAqIEBwcm9wZXJ0eSBhbGxcbiAqIEBwcm9wZXJ0eSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSBjb2xcbiAqIEBwcm9wZXJ0eSBwbGFjZWhvbGRlclxuICogQHByb3BlcnR5IGpvaW5cbiAqL1xuY29uc3QgT3AgPSB7XG4gIGVxOiBTeW1ib2wuZm9yKCdlcScpLFxuICBuZTogU3ltYm9sLmZvcignbmUnKSxcbiAgZ3RlOiBTeW1ib2wuZm9yKCdndGUnKSxcbiAgZ3Q6IFN5bWJvbC5mb3IoJ2d0JyksXG4gIGx0ZTogU3ltYm9sLmZvcignbHRlJyksXG4gIGx0OiBTeW1ib2wuZm9yKCdsdCcpLFxuICBub3Q6IFN5bWJvbC5mb3IoJ25vdCcpLFxuICBpczogU3ltYm9sLmZvcignaXMnKSxcbiAgaW46IFN5bWJvbC5mb3IoJ2luJyksXG4gIG5vdEluOiBTeW1ib2wuZm9yKCdub3RJbicpLFxuICBsaWtlOiBTeW1ib2wuZm9yKCdsaWtlJyksXG4gIG5vdExpa2U6IFN5bWJvbC5mb3IoJ25vdExpa2UnKSxcbiAgaUxpa2U6IFN5bWJvbC5mb3IoJ2lMaWtlJyksXG4gIG5vdElMaWtlOiBTeW1ib2wuZm9yKCdub3RJTGlrZScpLFxuICBzdGFydHNXaXRoOiBTeW1ib2wuZm9yKCdzdGFydHNXaXRoJyksXG4gIGVuZHNXaXRoOiBTeW1ib2wuZm9yKCdlbmRzV2l0aCcpLFxuICBzdWJzdHJpbmc6IFN5bWJvbC5mb3IoJ3N1YnN0cmluZycpLFxuICByZWdleHA6IFN5bWJvbC5mb3IoJ3JlZ2V4cCcpLFxuICBub3RSZWdleHA6IFN5bWJvbC5mb3IoJ25vdFJlZ2V4cCcpLFxuICBpUmVnZXhwOiBTeW1ib2wuZm9yKCdpUmVnZXhwJyksXG4gIG5vdElSZWdleHA6IFN5bWJvbC5mb3IoJ25vdElSZWdleHAnKSxcbiAgYmV0d2VlbjogU3ltYm9sLmZvcignYmV0d2VlbicpLFxuICBub3RCZXR3ZWVuOiBTeW1ib2wuZm9yKCdub3RCZXR3ZWVuJyksXG4gIG92ZXJsYXA6IFN5bWJvbC5mb3IoJ292ZXJsYXAnKSxcbiAgY29udGFpbnM6IFN5bWJvbC5mb3IoJ2NvbnRhaW5zJyksXG4gIGNvbnRhaW5lZDogU3ltYm9sLmZvcignY29udGFpbmVkJyksXG4gIGFkamFjZW50OiBTeW1ib2wuZm9yKCdhZGphY2VudCcpLFxuICBzdHJpY3RMZWZ0OiBTeW1ib2wuZm9yKCdzdHJpY3RMZWZ0JyksXG4gIHN0cmljdFJpZ2h0OiBTeW1ib2wuZm9yKCdzdHJpY3RSaWdodCcpLFxuICBub0V4dGVuZFJpZ2h0OiBTeW1ib2wuZm9yKCdub0V4dGVuZFJpZ2h0JyksXG4gIG5vRXh0ZW5kTGVmdDogU3ltYm9sLmZvcignbm9FeHRlbmRMZWZ0JyksXG4gIGFuZDogU3ltYm9sLmZvcignYW5kJyksXG4gIG9yOiBTeW1ib2wuZm9yKCdvcicpLFxuICBhbnk6IFN5bWJvbC5mb3IoJ2FueScpLFxuICBhbGw6IFN5bWJvbC5mb3IoJ2FsbCcpLFxuICB2YWx1ZXM6IFN5bWJvbC5mb3IoJ3ZhbHVlcycpLFxuICBjb2w6IFN5bWJvbC5mb3IoJ2NvbCcpLFxuICBwbGFjZWhvbGRlcjogU3ltYm9sLmZvcigncGxhY2Vob2xkZXInKSxcbiAgam9pbjogU3ltYm9sLmZvcignam9pbicpLFxuICBtYXRjaDogU3ltYm9sLmZvcignbWF0Y2gnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlbnVtIG9mIHF1ZXJ5IHR5cGVzIHVzZWQgYnkgYHNlcXVlbGl6ZS5xdWVyeWBcbiAqXG4gKiBAc2VlIHtAbGluayBTZXF1ZWxpemUjcXVlcnl9XG4gKlxuICogQHByb3BlcnR5IFNFTEVDVFxuICogQHByb3BlcnR5IElOU0VSVFxuICogQHByb3BlcnR5IFVQREFURVxuICogQHByb3BlcnR5IEJVTEtVUERBVEVcbiAqIEBwcm9wZXJ0eSBCVUxLREVMRVRFXG4gKiBAcHJvcGVydHkgREVMRVRFXG4gKiBAcHJvcGVydHkgVVBTRVJUXG4gKiBAcHJvcGVydHkgVkVSU0lPTlxuICogQHByb3BlcnR5IFNIT1dUQUJMRVNcbiAqIEBwcm9wZXJ0eSBTSE9XSU5ERVhFU1xuICogQHByb3BlcnR5IERFU0NSSUJFXG4gKiBAcHJvcGVydHkgUkFXXG4gKiBAcHJvcGVydHkgRk9SRUlHTktFWVNcbiAqIEBwcm9wZXJ0eSBTSE9XQ09OU1RSQUlOVFNcbiAqL1xuY29uc3QgUXVlcnlUeXBlcyA9IG1vZHVsZS5leHBvcnRzID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIFNFTEVDVDogJ1NFTEVDVCcsXG4gIElOU0VSVDogJ0lOU0VSVCcsXG4gIFVQREFURTogJ1VQREFURScsXG4gIEJVTEtVUERBVEU6ICdCVUxLVVBEQVRFJyxcbiAgQlVMS0RFTEVURTogJ0JVTEtERUxFVEUnLFxuICBERUxFVEU6ICdERUxFVEUnLFxuICBVUFNFUlQ6ICdVUFNFUlQnLFxuICBWRVJTSU9OOiAnVkVSU0lPTicsXG4gIFNIT1dUQUJMRVM6ICdTSE9XVEFCTEVTJyxcbiAgU0hPV0lOREVYRVM6ICdTSE9XSU5ERVhFUycsXG4gIERFU0NSSUJFOiAnREVTQ1JJQkUnLFxuICBSQVc6ICdSQVcnLFxuICBGT1JFSUdOS0VZUzogJ0ZPUkVJR05LRVlTJyxcbiAgU0hPV0NPTlNUUkFJTlRTOiAnU0hPV0NPTlNUUkFJTlRTJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdyZXRyeS1hcy1wcm9taXNlZCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBEZWZlcnJhYmxlID0gcmVxdWlyZSgnLi9kZWZlcnJhYmxlJyk7XG5jb25zdCBNb2RlbE1hbmFnZXIgPSByZXF1aXJlKCcuL21vZGVsLW1hbmFnZXInKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbicpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoJy4vcXVlcnktdHlwZXMnKTtcbmNvbnN0IFRhYmxlSGludHMgPSByZXF1aXJlKCcuL3RhYmxlLWhpbnRzJyk7XG5jb25zdCBJbmRleEhpbnRzID0gcmVxdWlyZSgnLi9pbmRleC1oaW50cycpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEhvb2tzID0gcmVxdWlyZSgnLi9ob29rcycpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKCcuL2Fzc29jaWF0aW9ucy9pbmRleCcpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi91dGlscy92YWxpZGF0b3ItZXh0cmFzJykudmFsaWRhdG9yO1xuY29uc3QgT3AgPSByZXF1aXJlKCcuL29wZXJhdG9ycycpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZSgnLi91dGlscy9kZXByZWNhdGlvbnMnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGNsYXNzLCB0aGUgZW50cnkgcG9pbnQgdG8gc2VxdWVsaXplLlxuICovXG5jbGFzcyBTZXF1ZWxpemUge1xuICAvKipcbiAgICogSW5zdGFudGlhdGUgc2VxdWVsaXplIHdpdGggbmFtZSBvZiBkYXRhYmFzZSwgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyB3aXRob3V0IHBhc3N3b3JkIC8gd2l0aCBibGFuayBwYXNzd29yZFxuICAgKiBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKCdkYXRhYmFzZScsICd1c2VybmFtZScsIG51bGwsIHtcbiAgICogICBkaWFsZWN0OiAnbXlzcWwnXG4gICAqIH0pXG4gICAqXG4gICAqIC8vIHdpdGggcGFzc3dvcmQgYW5kIG9wdGlvbnNcbiAgICogY29uc3Qgc2VxdWVsaXplID0gbmV3IFNlcXVlbGl6ZSgnbXlfZGF0YWJhc2UnLCAnam9obicsICdkb2UnLCB7XG4gICAqICAgZGlhbGVjdDogJ3Bvc3RncmVzJ1xuICAgKiB9KVxuICAgKlxuICAgKiAvLyB3aXRoIGRhdGFiYXNlLCB1c2VybmFtZSwgYW5kIHBhc3N3b3JkIGluIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBjb25zdCBzZXF1ZWxpemUgPSBuZXcgU2VxdWVsaXplKHsgZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgZGlhbGVjdDogJ21zc3FsJyB9KTtcbiAgICpcbiAgICogLy8gd2l0aCB1cmlcbiAgICogY29uc3Qgc2VxdWVsaXplID0gbmV3IFNlcXVlbGl6ZSgnbXlzcWw6Ly9sb2NhbGhvc3Q6MzMwNi9kYXRhYmFzZScsIHt9KVxuICAgKlxuICAgKiAvLyBvcHRpb24gZXhhbXBsZXNcbiAgICogY29uc3Qgc2VxdWVsaXplID0gbmV3IFNlcXVlbGl6ZSgnZGF0YWJhc2UnLCAndXNlcm5hbWUnLCAncGFzc3dvcmQnLCB7XG4gICAqICAgLy8gdGhlIHNxbCBkaWFsZWN0IG9mIHRoZSBkYXRhYmFzZVxuICAgKiAgIC8vIGN1cnJlbnRseSBzdXBwb3J0ZWQ6ICdteXNxbCcsICdzcWxpdGUnLCAncG9zdGdyZXMnLCAnbXNzcWwnXG4gICAqICAgZGlhbGVjdDogJ215c3FsJyxcbiAgICpcbiAgICogICAvLyBjdXN0b20gaG9zdDsgZGVmYXVsdDogbG9jYWxob3N0XG4gICAqICAgaG9zdDogJ215LnNlcnZlci50bGQnLFxuICAgKiAgIC8vIGZvciBwb3N0Z3JlcywgeW91IGNhbiBhbHNvIHNwZWNpZnkgYW4gYWJzb2x1dGUgcGF0aCB0byBhIGRpcmVjdG9yeVxuICAgKiAgIC8vIGNvbnRhaW5pbmcgYSBVTklYIHNvY2tldCB0byBjb25uZWN0IG92ZXJcbiAgICogICAvLyBob3N0OiAnL3NvY2tldHMvcHNxbF9zb2NrZXRzJy5cbiAgICpcbiAgICogICAvLyBjdXN0b20gcG9ydDsgZGVmYXVsdDogZGlhbGVjdCBkZWZhdWx0XG4gICAqICAgcG9ydDogMTIzNDUsXG4gICAqXG4gICAqICAgLy8gY3VzdG9tIHByb3RvY29sOyBkZWZhdWx0OiAndGNwJ1xuICAgKiAgIC8vIHBvc3RncmVzIG9ubHksIHVzZWZ1bCBmb3IgSGVyb2t1XG4gICAqICAgcHJvdG9jb2w6IG51bGwsXG4gICAqXG4gICAqICAgLy8gZGlzYWJsZSBsb2dnaW5nIG9yIHByb3ZpZGUgYSBjdXN0b20gbG9nZ2luZyBmdW5jdGlvbjsgZGVmYXVsdDogY29uc29sZS5sb2dcbiAgICogICBsb2dnaW5nOiBmYWxzZSxcbiAgICpcbiAgICogICAvLyB5b3UgY2FuIGFsc28gcGFzcyBhbnkgZGlhbGVjdCBvcHRpb25zIHRvIHRoZSB1bmRlcmx5aW5nIGRpYWxlY3QgbGlicmFyeVxuICAgKiAgIC8vIC0gZGVmYXVsdCBpcyBlbXB0eVxuICAgKiAgIC8vIC0gY3VycmVudGx5IHN1cHBvcnRlZDogJ215c3FsJywgJ3Bvc3RncmVzJywgJ21zc3FsJ1xuICAgKiAgIGRpYWxlY3RPcHRpb25zOiB7XG4gICAqICAgICBzb2NrZXRQYXRoOiAnL0FwcGxpY2F0aW9ucy9NQU1QL3RtcC9teXNxbC9teXNxbC5zb2NrJyxcbiAgICogICAgIHN1cHBvcnRCaWdOdW1iZXJzOiB0cnVlLFxuICAgKiAgICAgYmlnTnVtYmVyU3RyaW5nczogdHJ1ZVxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgLy8gdGhlIHN0b3JhZ2UgZW5naW5lIGZvciBzcWxpdGVcbiAgICogICAvLyAtIGRlZmF1bHQgJzptZW1vcnk6J1xuICAgKiAgIHN0b3JhZ2U6ICdwYXRoL3RvL2RhdGFiYXNlLnNxbGl0ZScsXG4gICAqXG4gICAqICAgLy8gZGlzYWJsZSBpbnNlcnRpbmcgdW5kZWZpbmVkIHZhbHVlcyBhcyBOVUxMXG4gICAqICAgLy8gLSBkZWZhdWx0OiBmYWxzZVxuICAgKiAgIG9taXROdWxsOiB0cnVlLFxuICAgKlxuICAgKiAgIC8vIGEgZmxhZyBmb3IgdXNpbmcgYSBuYXRpdmUgbGlicmFyeSBvciBub3QuXG4gICAqICAgLy8gaW4gdGhlIGNhc2Ugb2YgJ3BnJyAtLSBzZXQgdGhpcyB0byB0cnVlIHdpbGwgYWxsb3cgU1NMIHN1cHBvcnRcbiAgICogICAvLyAtIGRlZmF1bHQ6IGZhbHNlXG4gICAqICAgbmF0aXZlOiB0cnVlLFxuICAgKlxuICAgKiAgIC8vIFNwZWNpZnkgb3B0aW9ucywgd2hpY2ggYXJlIHVzZWQgd2hlbiBzZXF1ZWxpemUuZGVmaW5lIGlzIGNhbGxlZC5cbiAgICogICAvLyBUaGUgZm9sbG93aW5nIGV4YW1wbGU6XG4gICAqICAgLy8gICBkZWZpbmU6IHsgdGltZXN0YW1wczogZmFsc2UgfVxuICAgKiAgIC8vIGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhczpcbiAgICogICAvLyAgIE1vZGVsLmluaXQoYXR0cmlidXRlcywgeyB0aW1lc3RhbXBzOiBmYWxzZSB9KTtcbiAgICogICAvLyAgIHNlcXVlbGl6ZS5kZWZpbmUobmFtZSwgYXR0cmlidXRlcywgeyB0aW1lc3RhbXBzOiBmYWxzZSB9KTtcbiAgICogICAvLyBzbyBkZWZpbmluZyB0aGUgdGltZXN0YW1wcyBmb3IgZWFjaCBtb2RlbCB3aWxsIGJlIG5vdCBuZWNlc3NhcnlcbiAgICogICBkZWZpbmU6IHtcbiAgICogICAgIHVuZGVyc2NvcmVkOiBmYWxzZSxcbiAgICogICAgIGZyZWV6ZVRhYmxlTmFtZTogZmFsc2UsXG4gICAqICAgICBjaGFyc2V0OiAndXRmOCcsXG4gICAqICAgICBkaWFsZWN0T3B0aW9uczoge1xuICAgKiAgICAgICBjb2xsYXRlOiAndXRmOF9nZW5lcmFsX2NpJ1xuICAgKiAgICAgfSxcbiAgICogICAgIHRpbWVzdGFtcHM6IHRydWVcbiAgICogICB9LFxuICAgKlxuICAgKiAgIC8vIHNpbWlsYXIgZm9yIHN5bmM6IHlvdSBjYW4gZGVmaW5lIHRoaXMgdG8gYWx3YXlzIGZvcmNlIHN5bmMgZm9yIG1vZGVsc1xuICAgKiAgIHN5bmM6IHsgZm9yY2U6IHRydWUgfSxcbiAgICpcbiAgICogICAvLyBwb29sIGNvbmZpZ3VyYXRpb24gdXNlZCB0byBwb29sIGRhdGFiYXNlIGNvbm5lY3Rpb25zXG4gICAqICAgcG9vbDoge1xuICAgKiAgICAgbWF4OiA1LFxuICAgKiAgICAgaWRsZTogMzAwMDAsXG4gICAqICAgICBhY3F1aXJlOiA2MDAwMCxcbiAgICogICB9LFxuICAgKlxuICAgKiAgIC8vIGlzb2xhdGlvbiBsZXZlbCBvZiBlYWNoIHRyYW5zYWN0aW9uXG4gICAqICAgLy8gZGVmYXVsdHMgdG8gZGlhbGVjdCBkZWZhdWx0XG4gICAqICAgaXNvbGF0aW9uTGV2ZWw6IFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVQRUFUQUJMRV9SRUFEXG4gICAqIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtkYXRhYmFzZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFt1c2VybmFtZT1udWxsXSBUaGUgdXNlcm5hbWUgd2hpY2ggaXMgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCB0aGUgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtwYXNzd29yZD1udWxsXSBUaGUgcGFzc3dvcmQgd2hpY2ggaXMgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCB0aGUgZGF0YWJhc2UuIFN1cHBvcnRzIFNRTENpcGhlciBlbmNyeXB0aW9uIGZvciBTUUxpdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zPXt9XSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5ob3N0PSdsb2NhbGhvc3QnXSBUaGUgaG9zdCBvZiB0aGUgcmVsYXRpb25hbCBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9ydD1dIFRoZSBwb3J0IG9mIHRoZSByZWxhdGlvbmFsIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy51c2VybmFtZT1udWxsXSBUaGUgdXNlcm5hbWUgd2hpY2ggaXMgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCB0aGUgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnBhc3N3b3JkPW51bGxdIFRoZSBwYXNzd29yZCB3aGljaCBpcyB1c2VkIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbnN0IHRoZSBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuZGF0YWJhc2U9bnVsbF0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmRpYWxlY3RdIFRoZSBkaWFsZWN0IG9mIHRoZSBkYXRhYmFzZSB5b3UgYXJlIGNvbm5lY3RpbmcgdG8uIE9uZSBvZiBteXNxbCwgcG9zdGdyZXMsIHNxbGl0ZSBhbmQgbXNzcWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmRpYWxlY3RNb2R1bGU9bnVsbF0gSWYgc3BlY2lmaWVkLCB1c2UgdGhpcyBkaWFsZWN0IGxpYnJhcnkuIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB1c2UgcGcuanMgaW5zdGVhZCBvZiBwZyB3aGVuIGNvbm5lY3RpbmcgdG8gYSBwZyBkYXRhYmFzZSwgeW91IHNob3VsZCBzcGVjaWZ5ICdyZXF1aXJlKFwicGcuanNcIiknIGhlcmVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuZGlhbGVjdE1vZHVsZVBhdGg9bnVsbF0gSWYgc3BlY2lmaWVkLCBsb2FkIHRoZSBkaWFsZWN0IGxpYnJhcnkgZnJvbSB0aGlzIHBhdGguIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB1c2UgcGcuanMgaW5zdGVhZCBvZiBwZyB3aGVuIGNvbm5lY3RpbmcgdG8gYSBwZyBkYXRhYmFzZSwgeW91IHNob3VsZCBzcGVjaWZ5ICcvcGF0aC90by9wZy5qcycgaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5kaWFsZWN0T3B0aW9uc10gQW4gb2JqZWN0IG9mIGFkZGl0aW9uYWwgb3B0aW9ucywgd2hpY2ggYXJlIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgY29ubmVjdGlvbiBsaWJyYXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnN0b3JhZ2VdIE9ubHkgdXNlZCBieSBzcWxpdGUuIERlZmF1bHRzIHRvICc6bWVtb3J5OidcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMucHJvdG9jb2w9J3RjcCddIFRoZSBwcm90b2NvbCBvZiB0aGUgcmVsYXRpb25hbCBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuZGVmaW5lPXt9XSBEZWZhdWx0IG9wdGlvbnMgZm9yIG1vZGVsIGRlZmluaXRpb25zLiBTZWUge0BsaW5rIE1vZGVsLmluaXR9LlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5xdWVyeT17fV0gRGVmYXVsdCBvcHRpb25zIGZvciBzZXF1ZWxpemUucXVlcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuc2NoZW1hPW51bGxdIEEgc2NoZW1hIHRvIHVzZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5zZXQ9e31dIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VxdWVsaXplLnNldFxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5zeW5jPXt9XSBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcXVlbGl6ZS5zeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnRpbWV6b25lPScrMDA6MDAnXSBUaGUgdGltZXpvbmUgdXNlZCB3aGVuIGNvbnZlcnRpbmcgYSBkYXRlIGZyb20gdGhlIGRhdGFiYXNlIGludG8gYSBKYXZhU2NyaXB0IGRhdGUuIFRoZSB0aW1lem9uZSBpcyBhbHNvIHVzZWQgdG8gU0VUIFRJTUVaT05FIHdoZW4gY29ubmVjdGluZyB0byB0aGUgc2VydmVyLCB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIE5PVywgQ1VSUkVOVF9USU1FU1RBTVAgYW5kIG90aGVyIHRpbWUgcmVsYXRlZCBmdW5jdGlvbnMgaGF2ZSBpbiB0aGUgcmlnaHQgdGltZXpvbmUuIEZvciBiZXN0IGNyb3NzIHBsYXRmb3JtIHBlcmZvcm1hbmNlIHVzZSB0aGUgZm9ybWF0ICsvLUhIOk1NLiBXaWxsIGFsc28gYWNjZXB0IHN0cmluZyB2ZXJzaW9ucyBvZiB0aW1lem9uZXMgdXNlZCBieSBtb21lbnQuanMgKGUuZy4gJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnKTsgdGhpcyBpcyB1c2VmdWwgdG8gY2FwdHVyZSBkYXlsaWdodCBzYXZpbmdzIHRpbWUgY2hhbmdlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gW29wdGlvbnMuY2xpZW50TWluTWVzc2FnZXM9J3dhcm5pbmcnXSBUaGUgUG9zdGdyZVNRTCBgY2xpZW50X21pbl9tZXNzYWdlc2Agc2Vzc2lvbiBwYXJhbWV0ZXIuIFNldCB0byBgZmFsc2VgIHRvIG5vdCBvdmVycmlkZSB0aGUgZGF0YWJhc2UncyBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5zdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzPXRydWVdIFRoZSBQb3N0Z3JlU1FMIGBzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3NgIHNlc3Npb24gcGFyYW1ldGVyLiBTZXQgdG8gYGZhbHNlYCB0byBub3Qgc2V0IHRoZSBvcHRpb24uIFdBUk5JTkc6IFNldHRpbmcgdGhpcyB0byBmYWxzZSBtYXkgZXhwb3NlIHZ1bG5lcmFiaWxpdGllcyBhbmQgaXMgbm90IHJlY29tbWVuZGVkIVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nPWNvbnNvbGUubG9nXSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCBldmVyeSB0aW1lIFNlcXVlbGl6ZSB3b3VsZCBsb2cgc29tZXRoaW5nLiBGdW5jdGlvbiBtYXkgcmVjZWl2ZSBtdWx0aXBsZSBwYXJhbWV0ZXJzIGJ1dCBvbmx5IGZpcnN0IG9uZSBpcyBwcmludGVkIGJ5IGBjb25zb2xlLmxvZ2AuIFRvIHByaW50IGFsbCB2YWx1ZXMgdXNlIGAoLi4ubXNnKSA9PiBjb25zb2xlLmxvZyhtc2cpYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5iZW5jaG1hcms9ZmFsc2VdIFBhc3MgcXVlcnkgZXhlY3V0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFzIHNlY29uZCBhcmd1bWVudCB0byBsb2dnaW5nIGZ1bmN0aW9uIChvcHRpb25zLmxvZ2dpbmcpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5vbWl0TnVsbD1mYWxzZV0gQSBmbGFnIHRoYXQgZGVmaW5lcyBpZiBudWxsIHZhbHVlcyBzaG91bGQgYmUgcGFzc2VkIGFzIHZhbHVlcyB0byBDUkVBVEUvVVBEQVRFIFNRTCBxdWVyaWVzIG9yIG5vdC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMubmF0aXZlPWZhbHNlXSBBIGZsYWcgdGhhdCBkZWZpbmVzIGlmIG5hdGl2ZSBsaWJyYXJ5IHNoYWxsIGJlIHVzZWQgb3Igbm90LiBDdXJyZW50bHkgb25seSBoYXMgYW4gZWZmZWN0IGZvciBwb3N0Z3Jlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5yZXBsaWNhdGlvbj1mYWxzZV0gVXNlIHJlYWQgLyB3cml0ZSByZXBsaWNhdGlvbi4gVG8gZW5hYmxlIHJlcGxpY2F0aW9uLCBwYXNzIGFuIG9iamVjdCwgd2l0aCB0d28gcHJvcGVydGllcywgcmVhZCBhbmQgd3JpdGUuIFdyaXRlIHNob3VsZCBiZSBhbiBvYmplY3QgKGEgc2luZ2xlIHNlcnZlciBmb3IgaGFuZGxpbmcgd3JpdGVzKSwgYW5kIHJlYWQgYW4gYXJyYXkgb2Ygb2JqZWN0IChzZXZlcmFsIHNlcnZlcnMgdG8gaGFuZGxlIHJlYWRzKS4gRWFjaCByZWFkL3dyaXRlIHNlcnZlciBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IGBob3N0YCwgYHBvcnRgLCBgdXNlcm5hbWVgLCBgcGFzc3dvcmRgLCBgZGF0YWJhc2VgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnBvb2xdIHNlcXVlbGl6ZSBjb25uZWN0aW9uIHBvb2wgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gICBbb3B0aW9ucy5wb29sLm1heD01XSBNYXhpbXVtIG51bWJlciBvZiBjb25uZWN0aW9uIGluIHBvb2xcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5taW49MF0gTWluaW11bSBudW1iZXIgb2YgY29ubmVjdGlvbiBpbiBwb29sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wuaWRsZT0xMDAwMF0gVGhlIG1heGltdW0gdGltZSwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IGEgY29ubmVjdGlvbiBjYW4gYmUgaWRsZSBiZWZvcmUgYmVpbmcgcmVsZWFzZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wuYWNxdWlyZT02MDAwMF0gVGhlIG1heGltdW0gdGltZSwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IHBvb2wgd2lsbCB0cnkgdG8gZ2V0IGNvbm5lY3Rpb24gYmVmb3JlIHRocm93aW5nIGVycm9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnBvb2wuZXZpY3Q9MTAwMF0gVGhlIHRpbWUgaW50ZXJ2YWwsIGluIG1pbGxpc2Vjb25kcywgYWZ0ZXIgd2hpY2ggc2VxdWVsaXplLXBvb2wgd2lsbCByZW1vdmUgaWRsZSBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucG9vbC52YWxpZGF0ZV0gQSBmdW5jdGlvbiB0aGF0IHZhbGlkYXRlcyBhIGNvbm5lY3Rpb24uIENhbGxlZCB3aXRoIGNsaWVudC4gVGhlIGRlZmF1bHQgZnVuY3Rpb24gY2hlY2tzIHRoYXQgY2xpZW50IGlzIGFuIG9iamVjdCwgYW5kIHRoYXQgaXRzIHN0YXRlIGlzIG5vdCBkaXNjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgW29wdGlvbnMucG9vbC5tYXhVc2VzPUluZmluaXR5XSBUaGUgbnVtYmVyIG9mIHRpbWVzIGEgY29ubmVjdGlvbiBjYW4gYmUgdXNlZCBiZWZvcmUgZGlzY2FyZGluZyBpdCBmb3IgYSByZXBsYWNlbWVudCwgW2B1c2VkIGZvciBldmVudHVhbCBjbHVzdGVyIHJlYmFsYW5jaW5nYF0oaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUtcG9vbCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnF1b3RlSWRlbnRpZmllcnM9dHJ1ZV0gU2V0IHRvIGBmYWxzZWAgdG8gbWFrZSB0YWJsZSBuYW1lcyBhbmQgYXR0cmlidXRlcyBjYXNlLWluc2Vuc2l0aXZlIG9uIFBvc3RncmVzIGFuZCBza2lwIGRvdWJsZSBxdW90aW5nIG9mIHRoZW0uICBXQVJOSU5HOiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgbWF5IGV4cG9zZSB2dWxuZXJhYmlsaXRpZXMgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCFcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMudHJhbnNhY3Rpb25UeXBlPSdERUZFUlJFRCddIFNldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvbiB0eXBlLiBTZWUgYFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5UWVBFU2AgZm9yIHBvc3NpYmxlIG9wdGlvbnMuIFNxbGl0ZSBvbmx5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBbb3B0aW9ucy5pc29sYXRpb25MZXZlbF0gU2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uIGlzb2xhdGlvbiBsZXZlbC4gU2VlIGBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMU2AgZm9yIHBvc3NpYmxlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zLnJldHJ5XSBTZXQgb2YgZmxhZ3MgdGhhdCBjb250cm9sIHdoZW4gYSBxdWVyeSBpcyBhdXRvbWF0aWNhbGx5IHJldHJpZWQuIEFjY2VwdHMgYWxsIG9wdGlvbnMgZm9yIFtgcmV0cnktYXMtcHJvbWlzZWRgXShodHRwczovL2dpdGh1Yi5jb20vbWlja2hhbnNlbi9yZXRyeS1hcy1wcm9taXNlZCkuXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgIFtvcHRpb25zLnJldHJ5Lm1hdGNoXSBPbmx5IHJldHJ5IGEgcXVlcnkgaWYgdGhlIGVycm9yIG1hdGNoZXMgb25lIG9mIHRoZXNlIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgIFtvcHRpb25zLnJldHJ5Lm1heF0gSG93IG1hbnkgdGltZXMgYSBmYWlsaW5nIHF1ZXJ5IGlzIGF1dG9tYXRpY2FsbHkgcmV0cmllZC4gIFNldCB0byAwIHRvIGRpc2FibGUgcmV0cnlpbmcgb24gU1FMX0JVU1kgZXJyb3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLnR5cGVWYWxpZGF0aW9uPWZhbHNlXSBSdW4gYnVpbHQtaW4gdHlwZSB2YWxpZGF0b3JzIG9uIGluc2VydCBhbmQgdXBkYXRlLCBhbmQgc2VsZWN0IHdpdGggd2hlcmUgY2xhdXNlLCBlLmcuIHZhbGlkYXRlIHRoYXQgYXJndW1lbnRzIHBhc3NlZCB0byBpbnRlZ2VyIGZpZWxkcyBhcmUgaW50ZWdlci1saWtlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICBbb3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzXSBTdHJpbmcgYmFzZWQgb3BlcmF0b3IgYWxpYXMuIFBhc3Mgb2JqZWN0IHRvIGxpbWl0IHNldCBvZiBhbGlhc2VkIG9wZXJhdG9ycy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgW29wdGlvbnMuaG9va3NdIEFuIG9iamVjdCBvZiBnbG9iYWwgaG9vayBmdW5jdGlvbnMgdGhhdCBhcmUgY2FsbGVkIGJlZm9yZSBhbmQgYWZ0ZXIgY2VydGFpbiBsaWZlY3ljbGUgZXZlbnRzLiBHbG9iYWwgaG9va3Mgd2lsbCBydW4gYWZ0ZXIgYW55IG1vZGVsLXNwZWNpZmljIGhvb2tzIGRlZmluZWQgZm9yIHRoZSBzYW1lIGV2ZW50IChTZWUgYFNlcXVlbGl6ZS5Nb2RlbC5pbml0KClgIGZvciBhIGxpc3QpLiAgQWRkaXRpb25hbGx5LCBgYmVmb3JlQ29ubmVjdCgpYCwgYGFmdGVyQ29ubmVjdCgpYCwgYGJlZm9yZURpc2Nvbm5lY3QoKWAsIGFuZCBgYWZ0ZXJEaXNjb25uZWN0KClgIGhvb2tzIG1heSBiZSBkZWZpbmVkIGhlcmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIFtvcHRpb25zLm1pbmlmeUFsaWFzZXM9ZmFsc2VdIEEgZmxhZyB0aGF0IGRlZmluZXMgaWYgYWxpYXNlcyBzaG91bGQgYmUgbWluaWZpZWQgKG1vc3RseSB1c2VmdWwgdG8gYXZvaWQgUG9zdGdyZXMgYWxpYXMgY2hhcmFjdGVyIGxpbWl0IG9mIDY0KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5sb2dRdWVyeVBhcmFtZXRlcnM9ZmFsc2VdIEEgZmxhZyB0aGF0IGRlZmluZXMgaWYgc2hvdyBiaW5kIHBhcmFtZXRlcnMgaW4gbG9nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGxldCBjb25maWc7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGF0YWJhc2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBuZXcgU2VxdWVsaXplKHsgLi4uIG9wdGlvbnMgfSlcbiAgICAgIG9wdGlvbnMgPSBkYXRhYmFzZTtcbiAgICAgIGNvbmZpZyA9IF8ucGljayhvcHRpb25zLCAnaG9zdCcsICdwb3J0JywgJ2RhdGFiYXNlJywgJ3VzZXJuYW1lJywgJ3Bhc3N3b3JkJyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkYXRhYmFzZSA9PT0gJ3N0cmluZycgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgdXNlcm5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBuZXcgU2VxdWVsaXplKFVSSSwgeyAuLi4gb3B0aW9ucyB9KVxuXG4gICAgICBjb25maWcgPSB7fTtcbiAgICAgIG9wdGlvbnMgPSB1c2VybmFtZSB8fCB7fTtcblxuICAgICAgY29uc3QgdXJsUGFydHMgPSB1cmwucGFyc2UoYXJndW1lbnRzWzBdLCB0cnVlKTtcblxuICAgICAgb3B0aW9ucy5kaWFsZWN0ID0gdXJsUGFydHMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyk7XG4gICAgICBvcHRpb25zLmhvc3QgPSB1cmxQYXJ0cy5ob3N0bmFtZTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGlhbGVjdCA9PT0gJ3NxbGl0ZScgJiYgdXJsUGFydHMucGF0aG5hbWUgJiYgIXVybFBhcnRzLnBhdGhuYW1lLnN0YXJ0c1dpdGgoJy86bWVtb3J5JykpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5ob3N0LCB1cmxQYXJ0cy5wYXRobmFtZSk7XG4gICAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IHBhdGgucmVzb2x2ZShvcHRpb25zLnN0b3JhZ2UgfHwgc3RvcmFnZVBhdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsUGFydHMucGF0aG5hbWUpIHtcbiAgICAgICAgY29uZmlnLmRhdGFiYXNlID0gdXJsUGFydHMucGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybFBhcnRzLnBvcnQpIHtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gdXJsUGFydHMucG9ydDtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybFBhcnRzLmF1dGgpIHtcbiAgICAgICAgY29uc3QgYXV0aFBhcnRzID0gdXJsUGFydHMuYXV0aC5zcGxpdCgnOicpO1xuXG4gICAgICAgIGNvbmZpZy51c2VybmFtZSA9IGF1dGhQYXJ0c1swXTtcblxuICAgICAgICBpZiAoYXV0aFBhcnRzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgY29uZmlnLnBhc3N3b3JkID0gYXV0aFBhcnRzLnNsaWNlKDEpLmpvaW4oJzonKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5KSB7XG4gICAgICAgIC8vIEFsbG93IGhvc3QgcXVlcnkgYXJndW1lbnQgdG8gb3ZlcnJpZGUgdGhlIHVybCBob3N0LlxuICAgICAgICAvLyBFbmFibGVzIHNwZWNpZnlpbmcgZG9tYWluIHNvY2tldCBob3N0cyB3aGljaCBjYW5ub3QgYmUgc3BlY2lmaWVkIHZpYSB0aGUgdHlwaWNhbFxuICAgICAgICAvLyBob3N0IHBhcnQgb2YgYSB1cmwuXG4gICAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeS5ob3N0KSB7XG4gICAgICAgICAgb3B0aW9ucy5ob3N0ID0gdXJsUGFydHMucXVlcnkuaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmRpYWxlY3RPcHRpb25zLCB1cmxQYXJ0cy5xdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5kaWFsZWN0T3B0aW9ucyA9IHVybFBhcnRzLnF1ZXJ5O1xuICAgICAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeS5vcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvID0gSlNPTi5wYXJzZSh1cmxQYXJ0cy5xdWVyeS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zID0gbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbywgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIEpTT05cbiAgICAgICAgICAgICAgLy8gYW4gdGh1cyBkb2VzIG5vdCBuZWVkIGFueSBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmV3IFNlcXVlbGl6ZShkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkLCB7IC4uLiBvcHRpb25zIH0pXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGNvbmZpZyA9IHsgZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCB9O1xuICAgIH1cblxuICAgIFNlcXVlbGl6ZS5ydW5Ib29rcygnYmVmb3JlSW5pdCcsIGNvbmZpZywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBkaWFsZWN0OiBudWxsLFxuICAgICAgZGlhbGVjdE1vZHVsZTogbnVsbCxcbiAgICAgIGRpYWxlY3RNb2R1bGVQYXRoOiBudWxsLFxuICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgICBwcm90b2NvbDogJ3RjcCcsXG4gICAgICBkZWZpbmU6IHt9LFxuICAgICAgcXVlcnk6IHt9LFxuICAgICAgc3luYzoge30sXG4gICAgICB0aW1lem9uZTogJyswMDowMCcsXG4gICAgICBjbGllbnRNaW5NZXNzYWdlczogJ3dhcm5pbmcnLFxuICAgICAgc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5nczogdHJ1ZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBsb2dnaW5nOiBjb25zb2xlLmxvZyxcbiAgICAgIG9taXROdWxsOiBmYWxzZSxcbiAgICAgIG5hdGl2ZTogZmFsc2UsXG4gICAgICByZXBsaWNhdGlvbjogZmFsc2UsXG4gICAgICBzc2w6IHVuZGVmaW5lZCxcbiAgICAgIHBvb2w6IHt9LFxuICAgICAgcXVvdGVJZGVudGlmaWVyczogdHJ1ZSxcbiAgICAgIGhvb2tzOiB7fSxcbiAgICAgIHJldHJ5OiB7XG4gICAgICAgIG1heDogNSxcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAnU1FMSVRFX0JVU1k6IGRhdGFiYXNlIGlzIGxvY2tlZCdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uVHlwZTogVHJhbnNhY3Rpb24uVFlQRVMuREVGRVJSRUQsXG4gICAgICBpc29sYXRpb25MZXZlbDogbnVsbCxcbiAgICAgIGRhdGFiYXNlVmVyc2lvbjogMCxcbiAgICAgIHR5cGVWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgIGJlbmNobWFyazogZmFsc2UsXG4gICAgICBtaW5pZnlBbGlhc2VzOiBmYWxzZSxcbiAgICAgIGxvZ1F1ZXJ5UGFyYW1ldGVyczogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpYWxlY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlhbGVjdCBuZWVkcyB0byBiZSBleHBsaWNpdGx5IHN1cHBsaWVkIGFzIG9mIHY0LjAuMCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCA9PT0gJ3Bvc3RncmVzcWwnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGlhbGVjdCA9ICdwb3N0Z3Jlcyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ID09PSAnc3FsaXRlJyAmJiB0aGlzLm9wdGlvbnMudGltZXpvbmUgIT09ICcrMDA6MDAnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldHRpbmcgYSBjdXN0b20gdGltZXpvbmUgaXMgbm90IHN1cHBvcnRlZCBieSBTUUxpdGUsIGRhdGVzIGFyZSBhbHdheXMgcmV0dXJuZWQgYXMgVVRDLiBQbGVhc2UgcmVtb3ZlIHRoZSBjdXN0b20gdGltZXpvbmUgcGFyYW1ldGVyLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLm9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHVwSG9va3Mob3B0aW9ucy5ob29rcyk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UgfHwgdGhpcy5vcHRpb25zLmRhdGFiYXNlLFxuICAgICAgdXNlcm5hbWU6IGNvbmZpZy51c2VybmFtZSB8fCB0aGlzLm9wdGlvbnMudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkIHx8IHRoaXMub3B0aW9ucy5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgaG9zdDogY29uZmlnLmhvc3QgfHwgdGhpcy5vcHRpb25zLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCB8fCB0aGlzLm9wdGlvbnMucG9ydCxcbiAgICAgIHBvb2w6IHRoaXMub3B0aW9ucy5wb29sLFxuICAgICAgcHJvdG9jb2w6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAgIG5hdGl2ZTogdGhpcy5vcHRpb25zLm5hdGl2ZSxcbiAgICAgIHNzbDogdGhpcy5vcHRpb25zLnNzbCxcbiAgICAgIHJlcGxpY2F0aW9uOiB0aGlzLm9wdGlvbnMucmVwbGljYXRpb24sXG4gICAgICBkaWFsZWN0TW9kdWxlOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE1vZHVsZSxcbiAgICAgIGRpYWxlY3RNb2R1bGVQYXRoOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE1vZHVsZVBhdGgsXG4gICAgICBrZWVwRGVmYXVsdFRpbWV6b25lOiB0aGlzLm9wdGlvbnMua2VlcERlZmF1bHRUaW1lem9uZSxcbiAgICAgIGRpYWxlY3RPcHRpb25zOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnNcbiAgICB9O1xuXG4gICAgbGV0IERpYWxlY3Q7XG4gICAgLy8gUmVxdWlyaW5nIHRoZSBkaWFsZWN0IGluIGEgc3dpdGNoLWNhc2UgdG8ga2VlcCB0aGVcbiAgICAvLyByZXF1aXJlIGNhbGxzIHN0YXRpYy4gKEJyb3dzZXJpZnkgZml4KVxuICAgIHN3aXRjaCAodGhpcy5nZXREaWFsZWN0KCkpIHtcbiAgICAgIGNhc2UgJ21hcmlhZGInOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9tYXJpYWRiJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbXNzcWwnOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZSgnLi9kaWFsZWN0cy9tc3NxbCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ215c3FsJzpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvbXlzcWwnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3N0Z3Jlcyc6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKCcuL2RpYWxlY3RzL3Bvc3RncmVzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3FsaXRlJzpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoJy4vZGlhbGVjdHMvc3FsaXRlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGlhbGVjdCAke3RoaXMuZ2V0RGlhbGVjdCgpfSBpcyBub3Qgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgZGlhbGVjdHM6IG1zc3FsLCBtYXJpYWRiLCBteXNxbCwgcG9zdGdyZXMsIGFuZCBzcWxpdGUuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5kaWFsZWN0ID0gbmV3IERpYWxlY3QodGhpcyk7XG4gICAgdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLnR5cGVWYWxpZGF0aW9uID0gb3B0aW9ucy50eXBlVmFsaWRhdGlvbjtcblxuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMpKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9TdHJpbmdPcGVyYXRvcnMoKTtcbiAgICAgIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5zZXRPcGVyYXRvcnNBbGlhc2VzKHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9Cb29sT3BlcmF0b3JBbGlhc2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IHRoaXMuZGlhbGVjdC5xdWVyeUludGVyZmFjZTtcblxuICAgIC8qKlxuICAgICAqIE1vZGVscyBhcmUgc3RvcmVkIGhlcmUgdW5kZXIgdGhlIG5hbWUgZ2l2ZW4gdG8gYHNlcXVlbGl6ZS5kZWZpbmVgXG4gICAgICovXG4gICAgdGhpcy5tb2RlbHMgPSB7fTtcbiAgICB0aGlzLm1vZGVsTWFuYWdlciA9IG5ldyBNb2RlbE1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlcjtcblxuICAgIFNlcXVlbGl6ZS5ydW5Ib29rcygnYWZ0ZXJJbml0JywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBkYXRhIHR5cGVzIGFuZCBwYXJzZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVmcmVzaFR5cGVzKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgZGlhbGVjdC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNwZWNpZmllZCBkaWFsZWN0LlxuICAgKi9cbiAgZ2V0RGlhbGVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRpYWxlY3Q7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YWJhc2UgbmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRhdGFiYXNlIG5hbWUuXG4gICAqL1xuICBnZXREYXRhYmFzZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgUXVlcnlJbnRlcmZhY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtRdWVyeUludGVyZmFjZX0gQW4gaW5zdGFuY2UgKHNpbmdsZXRvbikgb2YgUXVlcnlJbnRlcmZhY2UuXG4gICAqL1xuICBnZXRRdWVyeUludGVyZmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUludGVyZmFjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBuZXcgbW9kZWwsIHJlcHJlc2VudGluZyBhIHRhYmxlIGluIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogVGhlIHRhYmxlIGNvbHVtbnMgYXJlIGRlZmluZWQgYnkgdGhlIG9iamVjdCB0aGF0IGlzIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuIEVhY2gga2V5IG9mIHRoZSBvYmplY3QgcmVwcmVzZW50cyBhIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxOYW1lIFRoZSBuYW1lIG9mIHRoZSBtb2RlbC4gVGhlIG1vZGVsIHdpbGwgYmUgc3RvcmVkIGluIGBzZXF1ZWxpemUubW9kZWxzYCB1bmRlciB0aGlzIG5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgQW4gb2JqZWN0LCB3aGVyZSBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNvbHVtbiBvZiB0aGUgdGFibGUuIFNlZSB7QGxpbmsgTW9kZWwuaW5pdH1cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGVzZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgU2VxdWVsaXplIGNvbnN0cnVjdG9yIGFuZCBwYXNzZWQgdG8gTW9kZWwuaW5pdCgpXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmluaXR9IGZvciBhIG1vcmUgY29tcHJlaGVuc2l2ZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBgb3B0aW9uc2AgYW5kIGBhdHRyaWJ1dGVzYCBvYmplY3RzLlxuICAgKiBAc2VlXG4gICAqIDxhIGhyZWY9XCIvbWFzdGVyL21hbnVhbC9tb2RlbC1iYXNpY3MuaHRtbFwiPk1vZGVsIEJhc2ljczwvYT4gZ3VpZGVcbiAgICpcbiAgICogQHJldHVybnMge01vZGVsfSBOZXdseSBkZWZpbmVkIG1vZGVsXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHNlcXVlbGl6ZS5kZWZpbmUoJ21vZGVsTmFtZScsIHtcbiAgICogICBjb2x1bW5BOiB7XG4gICAqICAgICAgIHR5cGU6IFNlcXVlbGl6ZS5CT09MRUFOLFxuICAgKiAgICAgICB2YWxpZGF0ZToge1xuICAgKiAgICAgICAgIGlzOiBbXCJbYS16XVwiLCdpJ10sICAgICAgICAvLyB3aWxsIG9ubHkgYWxsb3cgbGV0dGVyc1xuICAgKiAgICAgICAgIG1heDogMjMsICAgICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyB2YWx1ZXMgPD0gMjNcbiAgICogICAgICAgICBpc0luOiB7XG4gICAqICAgICAgICAgICBhcmdzOiBbWydlbicsICd6aCddXSxcbiAgICogICAgICAgICAgIG1zZzogXCJNdXN0IGJlIEVuZ2xpc2ggb3IgQ2hpbmVzZVwiXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBmaWVsZDogJ2NvbHVtbl9hJ1xuICAgKiAgIH0sXG4gICAqICAgY29sdW1uQjogU2VxdWVsaXplLlNUUklORyxcbiAgICogICBjb2x1bW5DOiAnTVkgVkVSWSBPV04gQ09MVU1OIFRZUEUnXG4gICAqIH0pO1xuICAgKlxuICAgKiBzZXF1ZWxpemUubW9kZWxzLm1vZGVsTmFtZSAvLyBUaGUgbW9kZWwgd2lsbCBub3cgYmUgYXZhaWxhYmxlIGluIG1vZGVscyB1bmRlciB0aGUgbmFtZSBnaXZlbiB0byBkZWZpbmVcbiAgICovXG4gIGRlZmluZShtb2RlbE5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMubW9kZWxOYW1lID0gbW9kZWxOYW1lO1xuICAgIG9wdGlvbnMuc2VxdWVsaXplID0gdGhpcztcblxuICAgIGNvbnN0IG1vZGVsID0gY2xhc3MgZXh0ZW5kcyBNb2RlbCB7fTtcblxuICAgIG1vZGVsLmluaXQoYXR0cmlidXRlcywgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBNb2RlbCB3aGljaCBpcyBhbHJlYWR5IGRlZmluZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZSBUaGUgbmFtZSBvZiBhIG1vZGVsIGRlZmluZWQgd2l0aCBTZXF1ZWxpemUuZGVmaW5lXG4gICAqXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbW9kZWwgaXMgbm90IGRlZmluZWQgKHRoYXQgaXMsIGlmIHNlcXVlbGl6ZSNpc0RlZmluZWQgcmV0dXJucyBmYWxzZSlcbiAgICogQHJldHVybnMge01vZGVsfSBTcGVjaWZpZWQgbW9kZWxcbiAgICovXG4gIG1vZGVsKG1vZGVsTmFtZSkge1xuICAgIGlmICghdGhpcy5pc0RlZmluZWQobW9kZWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21vZGVsTmFtZX0gaGFzIG5vdCBiZWVuIGRlZmluZWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwobW9kZWxOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIG1vZGVsIHdpdGggdGhlIGdpdmVuIG5hbWUgaXMgZGVmaW5lZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxOYW1lIFRoZSBuYW1lIG9mIGEgbW9kZWwgZGVmaW5lZCB3aXRoIFNlcXVlbGl6ZS5kZWZpbmVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBtb2RlbCBpcyBhbHJlYWR5IGRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgKi9cbiAgaXNEZWZpbmVkKG1vZGVsTmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscy5maW5kKG1vZGVsID0+IG1vZGVsLm5hbWUgPT09IG1vZGVsTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHF1ZXJ5IG9uIHRoZSBEQiwgb3B0aW9uYWxseSBieXBhc3NpbmcgYWxsIHRoZSBTZXF1ZWxpemUgZ29vZG5lc3MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gYXJndW1lbnRzOiBhbiBhcnJheSBvZiByZXN1bHRzLCBhbmQgYSBtZXRhZGF0YSBvYmplY3QsIGNvbnRhaW5pbmcgbnVtYmVyIG9mIGFmZmVjdGVkIHJvd3MgZXRjLlxuICAgKlxuICAgKiBJZiB5b3UgYXJlIHJ1bm5pbmcgYSB0eXBlIG9mIHF1ZXJ5IHdoZXJlIHlvdSBkb24ndCBuZWVkIHRoZSBtZXRhZGF0YSwgZm9yIGV4YW1wbGUgYSBgU0VMRUNUYCBxdWVyeSwgeW91IGNhbiBwYXNzIGluIGEgcXVlcnkgdHlwZSB0byBtYWtlIHNlcXVlbGl6ZSBmb3JtYXQgdGhlIHJlc3VsdHM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IFtyZXN1bHRzLCBtZXRhZGF0YV0gPSBhd2FpdCBzZXF1ZWxpemUucXVlcnkoJ1NFTEVDVC4uLicpOyAvLyBSYXcgcXVlcnkgLSB1c2UgYXJyYXkgZGVzdHJ1Y3R1cmluZ1xuICAgKlxuICAgKiBjb25zdCByZXN1bHRzID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KCdTRUxFQ1QuLi4nLCB7IHR5cGU6IHNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNFTEVDVCB9KTsgLy8gU0VMRUNUIHF1ZXJ5IC0gbm8gZGVzdHJ1Y3R1cmluZ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIHNxbFxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnM9e31dIFF1ZXJ5IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5yYXddIElmIHRydWUsIHNlcXVlbGl6ZSB3aWxsIG5vdCB0cnkgdG8gZm9ybWF0IHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSwgb3IgYnVpbGQgYW4gaW5zdGFuY2Ugb2YgYSBtb2RlbCBmcm9tIHRoZSByZXN1bHRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gICAgIFtvcHRpb25zLnRyYW5zYWN0aW9uPW51bGxdIFRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgZXhlY3V0ZWQgdW5kZXJcbiAgICogQHBhcmFtIHtRdWVyeVR5cGVzfSAgICAgIFtvcHRpb25zLnR5cGU9J1JBVyddIFRoZSB0eXBlIG9mIHF1ZXJ5IHlvdSBhcmUgZXhlY3V0aW5nLiBUaGUgcXVlcnkgdHlwZSBhZmZlY3RzIGhvdyByZXN1bHRzIGFyZSBmb3JtYXR0ZWQgYmVmb3JlIHRoZXkgYXJlIHBhc3NlZCBiYWNrLiBUaGUgdHlwZSBpcyBhIHN0cmluZywgYnV0IGBTZXF1ZWxpemUuUXVlcnlUeXBlc2AgaXMgcHJvdmlkZWQgYXMgY29udmVuaWVuY2Ugc2hvcnRjdXRzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMubmVzdD1mYWxzZV0gSWYgdHJ1ZSwgdHJhbnNmb3JtcyBvYmplY3RzIHdpdGggYC5gIHNlcGFyYXRlZCBwcm9wZXJ0eSBuYW1lcyBpbnRvIG5lc3RlZCBvYmplY3RzIHVzaW5nIFtkb3R0aWUuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNraGFuc2VuL2RvdHRpZS5qcykuIEZvciBleGFtcGxlIHsgJ3VzZXIudXNlcm5hbWUnOiAnam9obicgfSBiZWNvbWVzIHsgdXNlcjogeyB1c2VybmFtZTogJ2pvaG4nIH19LiBXaGVuIGBuZXN0YCBpcyB0cnVlLCB0aGUgcXVlcnkgdHlwZSBpcyBhc3N1bWVkIHRvIGJlIGAnU0VMRUNUJ2AsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5wbGFpbj1mYWxzZV0gU2V0cyB0aGUgcXVlcnkgdHlwZSB0byBgU0VMRUNUYCBhbmQgcmV0dXJuIGEgc2luZ2xlIHJvd1xuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gICAgW29wdGlvbnMucmVwbGFjZW1lbnRzXSBFaXRoZXIgYW4gb2JqZWN0IG9mIG5hbWVkIHBhcmFtZXRlciByZXBsYWNlbWVudHMgaW4gdGhlIGZvcm1hdCBgOnBhcmFtYCBvciBhbiBhcnJheSBvZiB1bm5hbWVkIHJlcGxhY2VtZW50cyB0byByZXBsYWNlIGA/YCBpbiB5b3VyIFNRTC5cbiAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl9ICAgIFtvcHRpb25zLmJpbmRdIEVpdGhlciBhbiBvYmplY3Qgb2YgbmFtZWQgYmluZCBwYXJhbWV0ZXIgaW4gdGhlIGZvcm1hdCBgX3BhcmFtYCBvciBhbiBhcnJheSBvZiB1bm5hbWVkIGJpbmQgcGFyYW1ldGVyIHRvIHJlcGxhY2UgYCQxLCAkMiwgLi4uYCBpbiB5b3VyIFNRTC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLnVzZU1hc3Rlcj1mYWxzZV0gRm9yY2UgdGhlIHF1ZXJ5IHRvIHVzZSB0aGUgd3JpdGUgcG9vbCwgcmVnYXJkbGVzcyBvZiB0aGUgcXVlcnkgdHlwZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgIFtvcHRpb25zLmxvZ2dpbmc9ZmFsc2VdIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIHdoaWxlIHJ1bm5pbmcgdGhlIHF1ZXJ5IHRvIGxvZyB0aGUgc3FsLlxuICAgKiBAcGFyYW0ge01vZGVsfSAgICAgICAgICAgW29wdGlvbnMuaW5zdGFuY2VdIEEgc2VxdWVsaXplIG1vZGVsIGluc3RhbmNlIHdob3NlIE1vZGVsIGlzIHRvIGJlIHVzZWQgdG8gYnVpbGQgdGhlIHF1ZXJ5IHJlc3VsdFxuICAgKiBAcGFyYW0ge3R5cGVvZiBNb2RlbH0gICAgW29wdGlvbnMubW9kZWxdIEEgc2VxdWVsaXplIG1vZGVsIHVzZWQgdG8gYnVpbGQgdGhlIHJldHVybmVkIG1vZGVsIGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgW29wdGlvbnMucmV0cnldIFNldCBvZiBmbGFncyB0aGF0IGNvbnRyb2wgd2hlbiBhIHF1ZXJ5IGlzIGF1dG9tYXRpY2FsbHkgcmV0cmllZC4gQWNjZXB0cyBhbGwgb3B0aW9ucyBmb3IgW2ByZXRyeS1hcy1wcm9taXNlZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNraGFuc2VuL3JldHJ5LWFzLXByb21pc2VkKS5cbiAgICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgIFtvcHRpb25zLnJldHJ5Lm1hdGNoXSBPbmx5IHJldHJ5IGEgcXVlcnkgaWYgdGhlIGVycm9yIG1hdGNoZXMgb25lIG9mIHRoZXNlIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gICAgICAgICBbb3B0aW9ucy5yZXRyeS5tYXhdIEhvdyBtYW55IHRpbWVzIGEgZmFpbGluZyBxdWVyeSBpcyBhdXRvbWF0aWNhbGx5IHJldHJpZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5zdXBwb3J0c1NlYXJjaFBhdGhdIElmIGZhbHNlIGRvIG5vdCBwcmVwZW5kIHRoZSBxdWVyeSB3aXRoIHRoZSBzZWFyY2hfcGF0aCAoUG9zdGdyZXMgb25seSlcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLm1hcFRvTW9kZWw9ZmFsc2VdIE1hcCByZXR1cm5lZCBmaWVsZHMgdG8gbW9kZWwncyBmaWVsZHMgaWYgYG9wdGlvbnMubW9kZWxgIG9yIGBvcHRpb25zLmluc3RhbmNlYCBpcyBwcmVzZW50LiBNYXBwaW5nIHdpbGwgb2NjdXIgYmVmb3JlIGJ1aWxkaW5nIHRoZSBtb2RlbCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIFtvcHRpb25zLmZpZWxkTWFwXSBNYXAgcmV0dXJuZWQgZmllbGRzIHRvIGFyYml0cmFyeSBuYW1lcyBmb3IgYFNFTEVDVGAgcXVlcnkgdHlwZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIE1vZGVsLmJ1aWxkfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBpbnN0YW5jZSBvcHRpb24uXG4gICAqL1xuXG4gIGFzeW5jIHF1ZXJ5KHNxbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucy5xdWVyeSwgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKG9wdGlvbnMuaW5zdGFuY2UgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIG9wdGlvbnMubW9kZWwgPSBvcHRpb25zLmluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pbnN0YW5jZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIG1hcCByYXcgZmllbGRzIHRvIG1vZGVsIGF0dHJpYnV0ZXNcbiAgICBpZiAob3B0aW9ucy5tYXBUb01vZGVsKSB7XG4gICAgICBvcHRpb25zLmZpZWxkTWFwID0gXy5nZXQob3B0aW9ucywgJ21vZGVsLmZpZWxkQXR0cmlidXRlTWFwJywge30pO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBsb2dnaW5nOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLCAnbG9nZ2luZycpID8gdGhpcy5vcHRpb25zLmxvZ2dpbmcgOiBjb25zb2xlLmxvZyxcbiAgICAgIHNlYXJjaFBhdGg6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9wdGlvbnMsICdzZWFyY2hQYXRoJykgPyB0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCA6ICdERUZBVUxUJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmIChvcHRpb25zLm1vZGVsIHx8IG9wdGlvbnMubmVzdCB8fCBvcHRpb25zLnBsYWluKSB7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuU0VMRUNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5SQVc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9pZiBkaWFsZWN0IGRvZXNuJ3Qgc3VwcG9ydCBzZWFyY2hfcGF0aCBvciBkaWFsZWN0IG9wdGlvblxuICAgIC8vdG8gcHJlcGVuZCBzZWFyY2hQYXRoIGlzIG5vdCB0cnVlIGRlbGV0ZSB0aGUgc2VhcmNoUGF0aCBvcHRpb25cbiAgICBpZiAoXG4gICAgICAhdGhpcy5kaWFsZWN0LnN1cHBvcnRzLnNlYXJjaFBhdGggfHxcbiAgICAgICF0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnMgfHxcbiAgICAgICF0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnMucHJlcGVuZFNlYXJjaFBhdGggfHxcbiAgICAgIG9wdGlvbnMuc3VwcG9ydHNTZWFyY2hQYXRoID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc2VhcmNoUGF0aDtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIC8vaWYgdXNlciB3YW50cyB0byBhbHdheXMgcHJlcGVuZCBzZWFyY2hQYXRoIChkaWFsZWN0T3B0aW9ucy5wcmVwcmVuZFNlYXJjaFBhdGggPSB0cnVlKVxuICAgICAgLy90aGVuIHNldCB0byBERUZBVUxUIGlmIG5vbmUgaXMgcHJvdmlkZWRcbiAgICAgIG9wdGlvbnMuc2VhcmNoUGF0aCA9ICdERUZBVUxUJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNxbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChzcWwudmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggYHNxbC52YWx1ZXNgIGFuZCBgb3B0aW9ucy5yZXBsYWNlbWVudHNgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucmVwbGFjZW1lbnRzID0gc3FsLnZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHNxbC5iaW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGBzcWwuYmluZGAgYW5kIGBvcHRpb25zLmJpbmRgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuYmluZCA9IHNxbC5iaW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3FsLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3FsID0gc3FsLnF1ZXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNxbCA9IHNxbC50cmltKCk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMgJiYgb3B0aW9ucy5iaW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggYHJlcGxhY2VtZW50c2AgYW5kIGBiaW5kYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVwbGFjZW1lbnRzKSkge1xuICAgICAgICBzcWwgPSBVdGlscy5mb3JtYXQoW3NxbF0uY29uY2F0KG9wdGlvbnMucmVwbGFjZW1lbnRzKSwgdGhpcy5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsID0gVXRpbHMuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgb3B0aW9ucy5yZXBsYWNlbWVudHMsIHRoaXMub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYmluZFBhcmFtZXRlcnM7XG5cbiAgICBpZiAob3B0aW9ucy5iaW5kKSB7XG4gICAgICBbc3FsLCBiaW5kUGFyYW1ldGVyc10gPSB0aGlzLmRpYWxlY3QuUXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCBvcHRpb25zLmJpbmQsIHRoaXMub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCAmJiAhb3B0aW9ucy5jb21wbGV0ZXNUcmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkfSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyB0cmFuc2FjdGlvbigke29wdGlvbnMudHJhbnNhY3Rpb24uaWR9KSwgeW91IGNhbiBubyBsb25nZXIgdXNlIGl0LiAoVGhlIHJlamVjdGVkIHF1ZXJ5IGlzIGF0dGFjaGVkIGFzIHRoZSAnc3FsJyBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yKWApO1xuICAgICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXRyeU9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucy5yZXRyeSwgLi4ub3B0aW9ucy5yZXRyeSB9O1xuXG4gICAgcmV0dXJuIHJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB1bmRlZmluZWQgJiYgU2VxdWVsaXplLl9jbHMpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IFNlcXVlbGl6ZS5fY2xzLmdldCgndHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgY2hlY2tUcmFuc2FjdGlvbigpO1xuXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgKG9wdGlvbnMudHJhbnNhY3Rpb24gPyBvcHRpb25zLnRyYW5zYWN0aW9uLmNvbm5lY3Rpb24gOiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24ob3B0aW9ucykpO1xuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgdGhpcy5kaWFsZWN0LlF1ZXJ5KGNvbm5lY3Rpb24sIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVRdWVyeScsIG9wdGlvbnMsIHF1ZXJ5KTtcbiAgICAgICAgY2hlY2tUcmFuc2FjdGlvbigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcXVlcnkucnVuKHNxbCwgYmluZFBhcmFtZXRlcnMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYWZ0ZXJRdWVyeScsIG9wdGlvbnMsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHJldHJ5T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHF1ZXJ5IHdoaWNoIHdvdWxkIHNldCBhbiBlbnZpcm9ubWVudCBvciB1c2VyIHZhcmlhYmxlLiBUaGUgdmFyaWFibGVzIGFyZSBzZXQgcGVyIGNvbm5lY3Rpb24sIHNvIHRoaXMgZnVuY3Rpb24gbmVlZHMgYSB0cmFuc2FjdGlvbi5cbiAgICogT25seSB3b3JrcyBmb3IgTXlTUUwuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgdmFyaWFibGVzIE9iamVjdCB3aXRoIG11bHRpcGxlIHZhcmlhYmxlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICBbb3B0aW9uc10gcXVlcnkgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gICBbb3B0aW9ucy50cmFuc2FjdGlvbl0gVGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhlIHF1ZXJ5IHNob3VsZCBiZSBleGVjdXRlZCB1bmRlclxuICAgKlxuICAgKiBAbWVtYmVyb2YgU2VxdWVsaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2V0KHZhcmlhYmxlcywgb3B0aW9ucykge1xuXG4gICAgLy8gUHJlcGFyZSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLnNldCwgLi4udHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCAhPT0gJ215c3FsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXF1ZWxpemUuc2V0IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBteXNxbCcpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJhbnNhY3Rpb24gfHwgIShvcHRpb25zLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy50cmFuc2FjdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHNvbWUgb3B0aW9ucywgc2luY2UgdGhpcyBpc24ndCBhIFNFTEVDVFxuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcbiAgICBvcHRpb25zLnR5cGUgPSAnU0VUJztcblxuICAgIC8vIEdlbmVyYXRlIFNRTCBRdWVyeVxuICAgIGNvbnN0IHF1ZXJ5ID1cbiAgICAgIGBTRVQgJHtcbiAgICAgICAgXy5tYXAodmFyaWFibGVzLCAodiwgaykgPT4gYEAke2t9IDo9ICR7dHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYFwiJHt2fVwiYCA6IHZ9YCkuam9pbignLCAnKX1gO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHN0cmluZyB2YWx1ZSB0byBlc2NhcGVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVzY2FwZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuZXNjYXBlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YWJhc2Ugc2NoZW1hLlxuICAgKlxuICAgKiAqKk5vdGU6KiogdGhpcyBpcyBhIHNjaGVtYSBpbiB0aGUgW3Bvc3RncmVzIHNlbnNlIG9mIHRoZSB3b3JkXShodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4xL3N0YXRpYy9kZGwtc2NoZW1hcy5odG1sKSxcbiAgICogbm90IGEgZGF0YWJhc2UgdGFibGUuIEluIG15c3FsIGFuZCBzcWxpdGUsIHRoaXMgY29tbWFuZCB3aWxsIGRvIG5vdGhpbmcuXG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLnNjaGVtYX1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYSBOYW1lIG9mIHRoZSBzY2hlbWFcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhbGwgZGVmaW5lZCBzY2hlbWFzXG4gICAqXG4gICAqICoqTm90ZToqKiB0aGlzIGlzIGEgc2NoZW1hIGluIHRoZSBbcG9zdGdyZXMgc2Vuc2Ugb2YgdGhlIHdvcmRdKGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjEvc3RhdGljL2RkbC1zY2hlbWFzLmh0bWwpLFxuICAgKiBub3QgYSBkYXRhYmFzZSB0YWJsZS4gSW4gbXlzcWwgYW5kIHNxbGl0ZSwgdGhpcyB3aWxsIHNob3cgYWxsIHRhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc2hvd0FsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuc2hvd0FsbFNjaGVtYXMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhIHNpbmdsZSBzY2hlbWFcbiAgICpcbiAgICogKipOb3RlOioqIHRoaXMgaXMgYSBzY2hlbWEgaW4gdGhlIFtwb3N0Z3JlcyBzZW5zZSBvZiB0aGUgd29yZF0oaHR0cDovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuMS9zdGF0aWMvZGRsLXNjaGVtYXMuaHRtbCksXG4gICAqIG5vdCBhIGRhdGFiYXNlIHRhYmxlLiBJbiBteXNxbCBhbmQgc3FsaXRlLCB0aGlzIGRyb3AgYSB0YWJsZSBtYXRjaGluZyB0aGUgc2NoZW1hIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYSBOYW1lIG9mIHRoZSBzY2hlbWFcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZ10gQSBmdW5jdGlvbiB0aGF0IGxvZ3Mgc3FsIHF1ZXJpZXMsIG9yIGZhbHNlIGZvciBubyBsb2dnaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGFsbCBzY2hlbWFzLlxuICAgKlxuICAgKiAqKk5vdGU6KiogdGhpcyBpcyBhIHNjaGVtYSBpbiB0aGUgW3Bvc3RncmVzIHNlbnNlIG9mIHRoZSB3b3JkXShodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS4xL3N0YXRpYy9kZGwtc2NoZW1hcy5odG1sKSxcbiAgICogbm90IGEgZGF0YWJhc2UgdGFibGUuIEluIG15c3FsIGFuZCBzcWxpdGUsIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgZHJvcCBhbGwgdGFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2dnaW5nXSBBIGZ1bmN0aW9uIHRoYXQgbG9ncyBzcWwgcXVlcmllcywgb3IgZmFsc2UgZm9yIG5vIGxvZ2dpbmdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBkcm9wQWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kcm9wQWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jIGFsbCBkZWZpbmVkIG1vZGVscyB0byB0aGUgREIuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gc3luYyBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2U9ZmFsc2VdIElmIGZvcmNlIGlzIHRydWUsIGVhY2ggTW9kZWwgd2lsbCBydW4gYERST1AgVEFCTEUgSUYgRVhJU1RTYCwgYmVmb3JlIGl0IHRyaWVzIHRvIGNyZWF0ZSBpdHMgb3duIHRhYmxlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5tYXRjaF0gTWF0Y2ggYSByZWdleCBhZ2FpbnN0IHRoZSBkYXRhYmFzZSBuYW1lIGJlZm9yZSBzeW5jaW5nLCBhIHNhZmV0eSBjaGVjayBmb3IgY2FzZXMgd2hlcmUgZm9yY2U6IHRydWUgaXMgdXNlZCBpbiB0ZXN0cyBidXQgbm90IGxpdmUgY29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmc9Y29uc29sZS5sb2ddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1hPSdwdWJsaWMnXSBUaGUgc2NoZW1hIHRoYXQgdGhlIHRhYmxlcyBzaG91bGQgYmUgY3JlYXRlZCBpbi4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBmb3IgZWFjaCB0YWJsZSBpbiBzZXF1ZWxpemUuZGVmaW5lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWFyY2hQYXRoPURFRkFVTFRdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBzY2hlbWEgc2VhcmNoX3BhdGggKFBvc3RncmVzIG9ubHkpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaG9va3M9dHJ1ZV0gSWYgaG9va3MgaXMgdHJ1ZSB0aGVuIGJlZm9yZVN5bmMsIGFmdGVyU3luYywgYmVmb3JlQnVsa1N5bmMsIGFmdGVyQnVsa1N5bmMgaG9va3Mgd2lsbCBiZSBjYWxsZWRcbiAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gW29wdGlvbnMuYWx0ZXI9ZmFsc2VdIEFsdGVycyB0YWJsZXMgdG8gZml0IG1vZGVscy4gUHJvdmlkZSBhbiBvYmplY3QgZm9yIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbi4gTm90IHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uIHVzZS4gSWYgbm90IGZ1cnRoZXIgY29uZmlndXJlZCBkZWxldGVzIGRhdGEgaW4gY29sdW1ucyB0aGF0IHdlcmUgcmVtb3ZlZCBvciBoYWQgdGhlaXIgdHlwZSBjaGFuZ2VkIGluIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbHRlci5kcm9wPXRydWVdIFByZXZlbnRzIGFueSBkcm9wIHN0YXRlbWVudHMgd2hpbGUgYWx0ZXJpbmcgYSB0YWJsZSB3aGVuIHNldCB0byBgZmFsc2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgc3luYyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucy5zeW5jLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhvb2tzOiBvcHRpb25zID8gb3B0aW9ucy5ob29rcyAhPT0gZmFsc2UgOiB0cnVlXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLm1hdGNoKSB7XG4gICAgICBpZiAoIW9wdGlvbnMubWF0Y2gudGVzdCh0aGlzLmNvbmZpZy5kYXRhYmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBcIiR7dGhpcy5jb25maWcuZGF0YWJhc2V9XCIgZG9lcyBub3QgbWF0Y2ggc3luYyBtYXRjaCBwYXJhbWV0ZXIgXCIke29wdGlvbnMubWF0Y2h9XCJgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcygnYmVmb3JlQnVsa1N5bmMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZHJvcChvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxzID0gW107XG5cbiAgICAvLyBUb3BvbG9naWNhbGx5IHNvcnQgYnkgZm9yZWlnbiBrZXkgY29uc3RyYWludHMgdG8gZ2l2ZSB1cyBhbiBhcHByb3ByaWF0ZVxuICAgIC8vIGNyZWF0aW9uIG9yZGVyXG4gICAgdGhpcy5tb2RlbE1hbmFnZXIuZm9yRWFjaE1vZGVsKG1vZGVsID0+IHtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbHMucHVzaChtb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEQiBzaG91bGQgdGhyb3cgYW4gU1FMIGVycm9yIGlmIHJlZmVyZW5jaW5nIG5vbi1leGlzdGVudCB0YWJsZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbm8gbW9kZWxzIGRlZmluZWQsIGp1c3QgYXV0aGVudGljYXRlXG4gICAgaWYgKCFtb2RlbHMubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiBtb2RlbHMpIGF3YWl0IG1vZGVsLnN5bmMob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKCdhZnRlckJ1bGtTeW5jJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydW5jYXRlIGFsbCB0YWJsZXMgZGVmaW5lZCB0aHJvdWdoIHRoZSBzZXF1ZWxpemUgbW9kZWxzLlxuICAgKiBUaGlzIGlzIGRvbmUgYnkgY2FsbGluZyBgTW9kZWwudHJ1bmNhdGUoKWAgb24gZWFjaCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gTW9kZWwuZGVzdHJveSBpbiBhZGRpdGlvbiB0byB0cnVuY2F0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwudHJ1bmNhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyB0cnVuY2F0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWxzID0gW107XG5cbiAgICB0aGlzLm1vZGVsTWFuYWdlci5mb3JFYWNoTW9kZWwobW9kZWwgPT4ge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB7IHJldmVyc2U6IGZhbHNlIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYXNjYWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vZGVscykgYXdhaXQgbW9kZWwudHJ1bmNhdGUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZGVscy5tYXAobW9kZWwgPT4gbW9kZWwudHJ1bmNhdGUob3B0aW9ucykpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgdGFibGVzIGRlZmluZWQgdGhyb3VnaCB0aGlzIHNlcXVlbGl6ZSBpbnN0YW5jZS5cbiAgICogVGhpcyBpcyBkb25lIGJ5IGNhbGxpbmcgTW9kZWwuZHJvcCBvbiBlYWNoIG1vZGVsLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5kcm9wfSBmb3Igb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIHBhc3NlZCB0byBlYWNoIGNhbGwgdG8gTW9kZWwuZHJvcFxuICAgKiBAcGFyYW0ge2Jvb2xlYW58RnVuY3Rpb259IFtvcHRpb25zLmxvZ2dpbmddIEEgZnVuY3Rpb24gdGhhdCBsb2dzIHNxbCBxdWVyaWVzLCBvciBmYWxzZSBmb3Igbm8gbG9nZ2luZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGRyb3Aob3B0aW9ucykge1xuICAgIGNvbnN0IG1vZGVscyA9IFtdO1xuXG4gICAgdGhpcy5tb2RlbE1hbmFnZXIuZm9yRWFjaE1vZGVsKG1vZGVsID0+IHtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbHMucHVzaChtb2RlbCk7XG4gICAgICB9XG4gICAgfSwgeyByZXZlcnNlOiBmYWxzZSB9KTtcblxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbW9kZWxzKSBhd2FpdCBtb2RlbC5kcm9wKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgdGhlIGNvbm5lY3Rpb24gYnkgdHJ5aW5nIHRvIGF1dGhlbnRpY2F0ZS4gSXQgcnVucyBgU0VMRUNUIDErMSBBUyByZXN1bHRgIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIHF1ZXJ5IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICBwbGFpbjogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNULFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBhd2FpdCB0aGlzLnF1ZXJ5KCdTRUxFQ1QgMSsxIEFTIHJlc3VsdCcsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmMgZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRhdGFiYXNlVmVyc2lvbihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZuIGZvciByYW5kb20gYmFzZWQgb24gdGhlIGRpYWxlY3RcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5mbn1cbiAgICovXG4gIHJhbmRvbSgpIHtcbiAgICBjb25zdCBkaWEgPSB0aGlzLmdldERpYWxlY3QoKTtcbiAgICBpZiAoZGlhID09PSAncG9zdGdyZXMnIHx8IGRpYSA9PT0gJ3NxbGl0ZScpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCdSQU5ET00nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm4oJ1JBTkQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBkYXRhYmFzZSBmdW5jdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCBpbiBzZWFyY2ggcXVlcmllcywgYm90aCBpbiB3aGVyZSBhbmQgb3JkZXIgcGFydHMsIGFuZCBhcyBkZWZhdWx0IHZhbHVlcyBpbiBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gICAqIElmIHlvdSB3YW50IHRvIHJlZmVyIHRvIGNvbHVtbnMgaW4geW91ciBmdW5jdGlvbiwgeW91IHNob3VsZCB1c2UgYHNlcXVlbGl6ZS5jb2xgLCBzbyB0aGF0IHRoZSBjb2x1bW5zIGFyZSBwcm9wZXJseSBpbnRlcnByZXRlZCBhcyBjb2x1bW5zIGFuZCBub3QgYSBzdHJpbmdzLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUuZGVmaW5lfVxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUuY29sfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm4gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGNhbGxcbiAgICogQHBhcmFtIHthbnl9IGFyZ3MgQWxsIGZ1cnRoZXIgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byB0aGUgZnVuY3Rpb25cbiAgICpcbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5mbn1cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBhIHVzZXIncyB1c2VybmFtZSB0byB1cHBlciBjYXNlPC9jYXB0aW9uPlxuICAgKiBpbnN0YW5jZS51cGRhdGUoe1xuICAgKiAgIHVzZXJuYW1lOiBzZXF1ZWxpemUuZm4oJ3VwcGVyJywgc2VxdWVsaXplLmNvbCgndXNlcm5hbWUnKSlcbiAgICogfSk7XG4gICAqL1xuICBzdGF0aWMgZm4oZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkZuKGZuLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCByZXByZXNlbnRzIGEgY29sdW1uIGluIHRoZSBEQiwgdGhpcyBhbGxvd3MgcmVmZXJlbmNpbmcgYW5vdGhlciBjb2x1bW4gaW4geW91ciBxdWVyeS4gVGhpcyBpcyBvZnRlbiB1c2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aCBgc2VxdWVsaXplLmZuYCwgc2luY2UgcmF3IHN0cmluZyBhcmd1bWVudHMgdG8gZm4gd2lsbCBiZSBlc2NhcGVkLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBTZXF1ZWxpemUjZm59XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2wgVGhlIG5hbWUgb2YgdGhlIGNvbHVtblxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmNvbH1cbiAgICovXG4gIHN0YXRpYyBjb2woY29sKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5Db2woY29sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBjYWxsIHRvIHRoZSBjYXN0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsIFRoZSB2YWx1ZSB0byBjYXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIHRvIGNhc3QgaXQgdG9cbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5jYXN0fVxuICAgKi9cbiAgc3RhdGljIGNhc3QodmFsLCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5DYXN0KHZhbCwgdHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbGl0ZXJhbCwgaS5lLiBzb21ldGhpbmcgdGhhdCB3aWxsIG5vdCBiZSBlc2NhcGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsIGxpdGVyYWwgdmFsdWVcbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5saXRlcmFsfVxuICAgKi9cbiAgc3RhdGljIGxpdGVyYWwodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gQU5EIHF1ZXJ5XG4gICAqXG4gICAqIEBzZWVcbiAgICoge0BsaW5rIE1vZGVsLmZpbmRBbGx9XG4gICAqXG4gICAqIEBwYXJhbSB7Li4uc3RyaW5nfG9iamVjdH0gYXJncyBFYWNoIGFyZ3VtZW50IHdpbGwgYmUgam9pbmVkIGJ5IEFORFxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmFuZH1cbiAgICovXG4gIHN0YXRpYyBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiB7IFtPcC5hbmRdOiBhcmdzIH07XG4gIH1cblxuICAvKipcbiAgICogQW4gT1IgcXVlcnlcbiAgICpcbiAgICogQHNlZVxuICAgKiB7QGxpbmsgTW9kZWwuZmluZEFsbH1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5zdHJpbmd8b2JqZWN0fSBhcmdzIEVhY2ggYXJndW1lbnQgd2lsbCBiZSBqb2luZWQgYnkgT1JcbiAgICogQHNpbmNlIHYyLjAuMC1kZXYzXG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1NlcXVlbGl6ZS5vcn1cbiAgICovXG4gIHN0YXRpYyBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHsgW09wLm9yXTogYXJncyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBuZXN0ZWQgd2hlcmUgY29uZGl0aW9ucyBmb3IgcG9zdGdyZXMvc3FsaXRlL215c3FsIGpzb24gZGF0YS10eXBlLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbmRpdGlvbnNPclBhdGggQSBoYXNoIGNvbnRhaW5pbmcgc3RyaW5ncy9udW1iZXJzIG9yIG90aGVyIG5lc3RlZCBoYXNoLCBhIHN0cmluZyB1c2luZyBkb3Qgbm90YXRpb24gb3IgYSBzdHJpbmcgdXNpbmcgcG9zdGdyZXMvc3FsaXRlL215c3FsIGpzb24gc3ludGF4LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gW3ZhbHVlXSBBbiBvcHRpb25hbCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuIFByb2R1Y2VzIGEgc3RyaW5nIG9mIHRoZSBmb3JtIFwiPGpzb24gcGF0aD4gPSAnPHZhbHVlPidcIi5cbiAgICogQG1lbWJlcm9mIFNlcXVlbGl6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VxdWVsaXplLmpzb259XG4gICAqL1xuICBzdGF0aWMganNvbihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuSnNvbihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQSB3YXkgb2Ygc3BlY2lmeWluZyBhdHRyID0gY29uZGl0aW9uLlxuICAgKlxuICAgKiBUaGUgYXR0ciBjYW4gZWl0aGVyIGJlIGFuIG9iamVjdCB0YWtlbiBmcm9tIGBNb2RlbC5yYXdBdHRyaWJ1dGVzYCAoZm9yIGV4YW1wbGUgYE1vZGVsLnJhd0F0dHJpYnV0ZXMuaWRgIG9yIGBNb2RlbC5yYXdBdHRyaWJ1dGVzLm5hbWVgKS4gVGhlXG4gICAqIGF0dHJpYnV0ZSBzaG91bGQgYmUgZGVmaW5lZCBpbiB5b3VyIG1vZGVsIGRlZmluaXRpb24uIFRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgYW4gb2JqZWN0IGZyb20gb25lIG9mIHRoZSBzZXF1ZWxpemUgdXRpbGl0eSBmdW5jdGlvbnMgKGBzZXF1ZWxpemUuZm5gLCBgc2VxdWVsaXplLmNvbGAgZXRjLilcbiAgICpcbiAgICogRm9yIHN0cmluZyBhdHRyaWJ1dGVzLCB1c2UgdGhlIHJlZ3VsYXIgYHsgd2hlcmU6IHsgYXR0cjogc29tZXRoaW5nIH19YCBzeW50YXguIElmIHlvdSBkb24ndCB3YW50IHlvdXIgc3RyaW5nIHRvIGJlIGVzY2FwZWQsIHVzZSBgc2VxdWVsaXplLmxpdGVyYWxgLlxuICAgKlxuICAgKiBAc2VlXG4gICAqIHtAbGluayBNb2RlbC5maW5kQWxsfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXR0ciBUaGUgYXR0cmlidXRlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvYmplY3QgZnJvbSBgTW9kZWwucmF3QXR0cmlidXRlc2Agb3IgYSBzZXF1ZWxpemUgb2JqZWN0LCBmb3IgZXhhbXBsZSBhbiBpbnN0YW5jZSBvZiBgc2VxdWVsaXplLmZuYC4gRm9yIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlcywgdXNlIHRoZSBQT0pPIHN5bnRheFxuICAgKiBAcGFyYW0ge3N5bWJvbH0gW2NvbXBhcmF0b3I9J09wLmVxJ10gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBsb2dpYyBUaGUgY29uZGl0aW9uLiBDYW4gYmUgYm90aCBhIHNpbXBseSB0eXBlLCBvciBhIGZ1cnRoZXIgY29uZGl0aW9uIChgb3JgLCBgYW5kYCwgYC5saXRlcmFsYCBldGMuKVxuICAgKiBAc2luY2UgdjIuMC4wLWRldjNcbiAgICovXG4gIHN0YXRpYyB3aGVyZShhdHRyLCBjb21wYXJhdG9yLCBsb2dpYykge1xuICAgIHJldHVybiBuZXcgVXRpbHMuV2hlcmUoYXR0ciwgY29tcGFyYXRvciwgbG9naWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgdHJhbnNhY3Rpb24uIFdoZW4gdXNpbmcgdHJhbnNhY3Rpb25zLCB5b3Ugc2hvdWxkIHBhc3MgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IGluIG9yZGVyIGZvciB0aGUgcXVlcnkgdG8gaGFwcGVuIHVuZGVyIHRoYXQgdHJhbnNhY3Rpb24gQHNlZSB7QGxpbmsgVHJhbnNhY3Rpb259XG4gICAqXG4gICAqIElmIHlvdSBoYXZlIFtDTFNdKGh0dHBzOi8vZ2l0aHViLmNvbS9KZWZmLUxld2lzL2Nscy1ob29rZWQpIGVuYWJsZWQsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcGFzc2VkIHRvIGFueSBxdWVyeSB0aGF0IHJ1bnMgd2l0aGluIHRoZSBjYWxsYmFja1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB0cnkge1xuICAgKiAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgc2VxdWVsaXplLnRyYW5zYWN0aW9uKCk7XG4gICAqICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSguLi4sIHsgdHJhbnNhY3Rpb24gfSk7XG4gICAqICAgYXdhaXQgdXNlci51cGRhdGUoLi4uLCB7IHRyYW5zYWN0aW9uIH0pO1xuICAgKiAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuICAgKiB9IGNhdGNoIHtcbiAgICogICBhd2FpdCB0cmFuc2FjdGlvbi5yb2xsYmFjaygpXG4gICAqIH1cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+QSBzeW50YXggZm9yIGF1dG9tYXRpY2FsbHkgY29tbWl0dGluZyBvciByb2xsaW5nIGJhY2sgYmFzZWQgb24gdGhlIHByb21pc2UgY2hhaW4gcmVzb2x1dGlvbiBpcyBhbHNvIHN1cHBvcnRlZDwvY2FwdGlvbj5cbiAgICpcbiAgICogdHJ5IHtcbiAgICogICBhd2FpdCBzZXF1ZWxpemUudHJhbnNhY3Rpb24odHJhbnNhY3Rpb24gPT4geyAvLyBOb3RlIHRoYXQgd2UgcGFzcyBhIGNhbGxiYWNrIHJhdGhlciB0aGFuIGF3YWl0aW5nIHRoZSBjYWxsIHdpdGggbm8gYXJndW1lbnRzXG4gICAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kT25lKC4uLiwge3RyYW5zYWN0aW9ufSk7XG4gICAqICAgICBhd2FpdCB1c2VyLnVwZGF0ZSguLi4sIHt0cmFuc2FjdGlvbn0pO1xuICAgKiAgIH0pO1xuICAgKiAgIC8vIENvbW1pdHRlZFxuICAgKiB9IGNhdGNoKGVycikge1xuICAgKiAgIC8vIFJvbGxlZCBiYWNrXG4gICAqICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgKiB9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlRvIGVuYWJsZSBDTFMsIGFkZCBpdCBkbyB5b3VyIHByb2plY3QsIGNyZWF0ZSBhIG5hbWVzcGFjZSBhbmQgc2V0IGl0IG9uIHRoZSBzZXF1ZWxpemUgY29uc3RydWN0b3I6PC9jYXB0aW9uPlxuICAgKlxuICAgKiBjb25zdCBjbHMgPSByZXF1aXJlKCdjbHMtaG9va2VkJyk7XG4gICAqIGNvbnN0IG5hbWVzcGFjZSA9IGNscy5jcmVhdGVOYW1lc3BhY2UoJy4uLi4nKTtcbiAgICogY29uc3QgU2VxdWVsaXplID0gcmVxdWlyZSgnc2VxdWVsaXplJyk7XG4gICAqIFNlcXVlbGl6ZS51c2VDTFMobmFtZXNwYWNlKTtcbiAgICpcbiAgICogLy8gTm90ZSwgdGhhdCBDTFMgaXMgZW5hYmxlZCBmb3IgYWxsIHNlcXVlbGl6ZSBpbnN0YW5jZXMsIGFuZCBhbGwgaW5zdGFuY2VzIHdpbGwgc2hhcmUgdGhlIHNhbWUgbmFtZXNwYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgIFtvcHRpb25zXSBUcmFuc2FjdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLnR5cGU9J0RFRkVSUkVEJ10gU2VlIGBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uVFlQRVNgIGZvciBwb3NzaWJsZSBvcHRpb25zLiBTcWxpdGUgb25seS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgW29wdGlvbnMuaXNvbGF0aW9uTGV2ZWxdIFNlZSBgU2VxdWVsaXplLlRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFNgIGZvciBwb3NzaWJsZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtvcHRpb25zLmRlZmVycmFibGVdIFNldHMgdGhlIGNvbnN0cmFpbnRzIHRvIGJlIGRlZmVycmVkIG9yIGltbWVkaWF0ZWx5IGNoZWNrZWQuIFNlZSBgU2VxdWVsaXplLkRlZmVycmFibGVgLiBQb3N0Z3JlU1FMIE9ubHlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nZ2luZz1mYWxzZV0gQSBmdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgd2hpbGUgcnVubmluZyB0aGUgcXVlcnkgdG8gbG9nIHRoZSBzcWwuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFthdXRvQ2FsbGJhY2tdIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0LCBhbmQgc2hvdWxkIHJldHVybiBhIHByb21pc2UuIElmIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLCB0aGUgdHJhbnNhY3Rpb24gY29tbWl0czsgaWYgdGhlIHByb21pc2UgcmVqZWN0cywgdGhlIHRyYW5zYWN0aW9uIHJvbGxzIGJhY2tcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyB0cmFuc2FjdGlvbihvcHRpb25zLCBhdXRvQ2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGF1dG9DYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFhdXRvQ2FsbGJhY2spIHtcbiAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnByZXBhcmVFbnZpcm9ubWVudChmYWxzZSk7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuXG4gICAgLy8gYXV0b0NhbGxiYWNrIHByb3ZpZGVkXG4gICAgcmV0dXJuIFNlcXVlbGl6ZS5fY2xzUnVuKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnByZXBhcmVFbnZpcm9ubWVudCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRvQ2FsbGJhY2sodHJhbnNhY3Rpb24pO1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uZmluaXNoZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb24sIGV2ZW4gaWYgd2UgZG9uJ3QgbmVlZCB0byByb2xsYmFja1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY2xlYW51cCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyMCkge1xuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgQ0xTIChDb250aW51YXRpb24gTG9jYWwgU3RvcmFnZSkgd2l0aCBTZXF1ZWxpemUuIFdpdGggQ29udGludWF0aW9uXG4gICAqIExvY2FsIFN0b3JhZ2UsIGFsbCBxdWVyaWVzIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY2FsbGJhY2sgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IHJlY2VpdmUgdGhlIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQ0xTIG5hbWVzcGFjZSBwcm92aWRlZCBpcyBzdG9yZWQgYXMgYFNlcXVlbGl6ZS5fY2xzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbnMgQ0xTIG5hbWVzcGFjZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBTZXF1ZWxpemUgY29uc3RydWN0b3JcbiAgICovXG4gIHN0YXRpYyB1c2VDTFMobnMpIHtcbiAgICAvLyBjaGVjayBgbnNgIGlzIHZhbGlkIENMUyBuYW1lc3BhY2VcbiAgICBpZiAoIW5zIHx8IHR5cGVvZiBucyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG5zLmJpbmQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG5zLnJ1biAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgQ0xTIG5hbWVzcGFjZScpO1xuXG4gICAgLy8gc2F2ZSBuYW1lc3BhY2UgYXMgYFNlcXVlbGl6ZS5fY2xzYFxuICAgIHRoaXMuX2NscyA9IG5zO1xuXG4gICAgLy8gcmV0dXJuIFNlcXVlbGl6ZSBmb3IgY2hhaW5pbmdcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gZnVuY3Rpb24gaW4gQ0xTIGNvbnRleHQuXG4gICAqIElmIG5vIENMUyBjb250ZXh0IGluIHVzZSwganVzdCBydW5zIHRoZSBmdW5jdGlvbiBub3JtYWxseVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBydW5cbiAgICogQHJldHVybnMgeyp9IFJldHVybiB2YWx1ZSBvZiBmdW5jdGlvblxuICAgKi9cbiAgc3RhdGljIF9jbHNSdW4oZm4pIHtcbiAgICBjb25zdCBucyA9IFNlcXVlbGl6ZS5fY2xzO1xuICAgIGlmICghbnMpIHJldHVybiBmbigpO1xuXG4gICAgbGV0IHJlcztcbiAgICBucy5ydW4oY29udGV4dCA9PiByZXMgPSBmbihjb250ZXh0KSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGxvZyguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnM7XG5cbiAgICBjb25zdCBsYXN0ID0gXy5sYXN0KGFyZ3MpO1xuXG4gICAgaWYgKGxhc3QgJiYgXy5pc1BsYWluT2JqZWN0KGxhc3QpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXN0LCAnbG9nZ2luZycpKSB7XG4gICAgICBvcHRpb25zID0gbGFzdDtcblxuICAgICAgLy8gcmVtb3ZlIG9wdGlvbnMgZnJvbSBzZXQgb2YgbG9nZ2VkIGFyZ3VtZW50cyBpZiBvcHRpb25zLmxvZ2dpbmcgaXMgZXF1YWwgdG8gY29uc29sZS5sb2dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAob3B0aW9ucy5sb2dnaW5nID09PSBjb25zb2xlLmxvZykge1xuICAgICAgICBhcmdzLnNwbGljZShhcmdzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvZ2dpbmcpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgb3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlY29uZCBhcmd1bWVudCBpcyBzcWwtdGltaW5ncywgd2hlbiBiZW5jaG1hcmtpbmcgb3B0aW9uIGVuYWJsZWRcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAoKHRoaXMub3B0aW9ucy5iZW5jaG1hcmsgfHwgb3B0aW9ucy5iZW5jaG1hcmspICYmIG9wdGlvbnMubG9nZ2luZyA9PT0gY29uc29sZS5sb2cpIHtcbiAgICAgICAgYXJncyA9IFtgJHthcmdzWzBdfSBFbGFwc2VkIHRpbWU6ICR7YXJnc1sxXX1tc2BdO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmxvZ2dpbmcoLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIGFsbCBjb25uZWN0aW9ucyB1c2VkIGJ5IHRoaXMgc2VxdWVsaXplIGluc3RhbmNlLCBhbmQgZnJlZSBhbGwgcmVmZXJlbmNlcyBzbyB0aGUgaW5zdGFuY2UgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKlxuICAgKiBOb3JtYWxseSB0aGlzIGlzIGRvbmUgb24gcHJvY2VzcyBleGl0LCBzbyB5b3Ugb25seSBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgaWYgeW91IGFyZSBjcmVhdGluZyBtdWx0aXBsZSBpbnN0YW5jZXMsIGFuZCB3YW50XG4gICAqIHRvIGdhcmJhZ2UgY29sbGVjdCBzb21lIG9mIHRoZW0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY2xvc2UoKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZURhdGFUeXBlKFR5cGUpIHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBUeXBlID09PSAnZnVuY3Rpb24nID8gbmV3IFR5cGUoKSA6IFR5cGU7XG4gICAgY29uc3QgZGlhbGVjdFR5cGVzID0gdGhpcy5kaWFsZWN0LkRhdGFUeXBlcyB8fCB7fTtcblxuICAgIGlmIChkaWFsZWN0VHlwZXNbdHlwZS5rZXldKSB7XG4gICAgICB0eXBlID0gZGlhbGVjdFR5cGVzW3R5cGUua2V5XS5leHRlbmQodHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgIGlmICghdHlwZS50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQVJSQVkgaXMgbWlzc2luZyB0eXBlIGRlZmluaXRpb24gZm9yIGl0cyB2YWx1ZXMuJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGlhbGVjdFR5cGVzW3R5cGUudHlwZS5rZXldKSB7XG4gICAgICAgIHR5cGUudHlwZSA9IGRpYWxlY3RUeXBlc1t0eXBlLnR5cGUua2V5XS5leHRlbmQodHlwZS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7IHR5cGU6IGF0dHJpYnV0ZSB9O1xuICAgIH1cblxuICAgIGlmICghYXR0cmlidXRlLnR5cGUpIHJldHVybiBhdHRyaWJ1dGU7XG5cbiAgICBhdHRyaWJ1dGUudHlwZSA9IHRoaXMubm9ybWFsaXplRGF0YVR5cGUoYXR0cmlidXRlLnR5cGUpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsICdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nICYmIChcbiAgICAgICAgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9PT0gRGF0YVR5cGVzLk5PVyB8fFxuICAgICAgICAgIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPT09IERhdGFUeXBlcy5VVUlEVjEgfHxcbiAgICAgICAgICBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID09PSBEYXRhVHlwZXMuVVVJRFY0XG4gICAgICApKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPSBuZXcgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICAvLyBUaGUgRU5VTSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgdHlwZSBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzXG4gICAgICBpZiAoYXR0cmlidXRlLnZhbHVlcykge1xuICAgICAgICBhdHRyaWJ1dGUudHlwZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS5vcHRpb25zLnZhbHVlcyA9IGF0dHJpYnV0ZS52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUudmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dHJpYnV0ZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWVzIGZvciBFTlVNIGhhdmUgbm90IGJlZW4gZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlO1xuICB9XG59XG5cbi8vIEFsaWFzZXNcblNlcXVlbGl6ZS5wcm90b3R5cGUuZm4gPSBTZXF1ZWxpemUuZm47XG5TZXF1ZWxpemUucHJvdG90eXBlLmNvbCA9IFNlcXVlbGl6ZS5jb2w7XG5TZXF1ZWxpemUucHJvdG90eXBlLmNhc3QgPSBTZXF1ZWxpemUuY2FzdDtcblNlcXVlbGl6ZS5wcm90b3R5cGUubGl0ZXJhbCA9IFNlcXVlbGl6ZS5saXRlcmFsO1xuU2VxdWVsaXplLnByb3RvdHlwZS5hbmQgPSBTZXF1ZWxpemUuYW5kO1xuU2VxdWVsaXplLnByb3RvdHlwZS5vciA9IFNlcXVlbGl6ZS5vcjtcblNlcXVlbGl6ZS5wcm90b3R5cGUuanNvbiA9IFNlcXVlbGl6ZS5qc29uO1xuU2VxdWVsaXplLnByb3RvdHlwZS53aGVyZSA9IFNlcXVlbGl6ZS53aGVyZTtcblNlcXVlbGl6ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBTZXF1ZWxpemUucHJvdG90eXBlLmF1dGhlbnRpY2F0ZTtcblxuLyoqXG4gKiBTZXF1ZWxpemUgdmVyc2lvbiBudW1iZXIuXG4gKi9cblNlcXVlbGl6ZS52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuU2VxdWVsaXplLm9wdGlvbnMgPSB7IGhvb2tzOiB7fSB9O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblNlcXVlbGl6ZS5VdGlscyA9IFV0aWxzO1xuXG4vKipcbiAqIE9wZXJhdG9ycyBzeW1ib2xzIHRvIGJlIHVzZWQgZm9yIHF1ZXJ5aW5nIGRhdGFcbiAqXG4gKiBAc2VlICB7QGxpbmsgT3BlcmF0b3JzfVxuICovXG5TZXF1ZWxpemUuT3AgPSBPcDtcblxuLyoqXG4gKiBBdmFpbGFibGUgdGFibGUgaGludHMgdG8gYmUgdXNlZCBmb3IgcXVlcnlpbmcgZGF0YSBpbiBtc3NxbCBmb3IgdGFibGUgaGludHNcbiAqXG4gKiBAc2VlIHtAbGluayBUYWJsZUhpbnRzfVxuICovXG5TZXF1ZWxpemUuVGFibGVIaW50cyA9IFRhYmxlSGludHM7XG5cbi8qKlxuICogQXZhaWxhYmxlIGluZGV4IGhpbnRzIHRvIGJlIHVzZWQgZm9yIHF1ZXJ5aW5nIGRhdGEgaW4gbXlzcWwgZm9yIGluZGV4IGhpbnRzXG4gKlxuICogQHNlZSB7QGxpbmsgSW5kZXhIaW50c31cbiAqL1xuU2VxdWVsaXplLkluZGV4SGludHMgPSBJbmRleEhpbnRzO1xuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIHRoZSBzZXF1ZWxpemUgdHJhbnNhY3Rpb24gY2xhc3MuIFVzZSB0aGlzIHRvIGFjY2VzcyBpc29sYXRpb25MZXZlbHMgYW5kIHR5cGVzIHdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvblxuICpcbiAqIEBzZWUge0BsaW5rIFRyYW5zYWN0aW9ufVxuICogQHNlZSB7QGxpbmsgU2VxdWVsaXplLnRyYW5zYWN0aW9ufVxuICovXG5TZXF1ZWxpemUuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBTZXF1ZWxpemUgY29uc3RydWN0b3IgZnJvbSBzZXF1ZWxpemUuIFVzZWZ1bCBmb3IgYWNjZXNzaW5nIERhdGFUeXBlcywgRXJyb3JzIGV0Yy5cbiAqXG4gKiBAc2VlIHtAbGluayBTZXF1ZWxpemV9XG4gKi9cblNlcXVlbGl6ZS5wcm90b3R5cGUuU2VxdWVsaXplID0gU2VxdWVsaXplO1xuXG4vKipcbiAqIEF2YWlsYWJsZSBxdWVyeSB0eXBlcyBmb3IgdXNlIHdpdGggYHNlcXVlbGl6ZS5xdWVyeWBcbiAqXG4gKiBAc2VlIHtAbGluayBRdWVyeVR5cGVzfVxuICovXG5TZXF1ZWxpemUucHJvdG90eXBlLlF1ZXJ5VHlwZXMgPSBTZXF1ZWxpemUuUXVlcnlUeXBlcyA9IFF1ZXJ5VHlwZXM7XG5cbi8qKlxuICogRXhwb3NlcyB0aGUgdmFsaWRhdG9yLmpzIG9iamVjdCwgc28geW91IGNhbiBleHRlbmQgaXQgd2l0aCBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIFRoZSB2YWxpZGF0b3IgaXMgZXhwb3NlZCBib3RoIG9uIHRoZSBpbnN0YW5jZSwgYW5kIG9uIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzXG4gKi9cblNlcXVlbGl6ZS5wcm90b3R5cGUuVmFsaWRhdG9yID0gU2VxdWVsaXplLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcblxuU2VxdWVsaXplLk1vZGVsID0gTW9kZWw7XG5cblNlcXVlbGl6ZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5mb3IgKGNvbnN0IGRhdGFUeXBlIGluIERhdGFUeXBlcykge1xuICBTZXF1ZWxpemVbZGF0YVR5cGVdID0gRGF0YVR5cGVzW2RhdGFUeXBlXTtcbn1cblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byB0aGUgZGVmZXJyYWJsZSBjb2xsZWN0aW9uLiBVc2UgdGhpcyB0byBhY2Nlc3MgdGhlIGRpZmZlcmVudCBkZWZlcnJhYmxlIG9wdGlvbnMuXG4gKlxuICogQHNlZSB7QGxpbmsgVHJhbnNhY3Rpb24uRGVmZXJyYWJsZX1cbiAqIEBzZWUge0BsaW5rIFNlcXVlbGl6ZSN0cmFuc2FjdGlvbn1cbiAqL1xuU2VxdWVsaXplLkRlZmVycmFibGUgPSBEZWZlcnJhYmxlO1xuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIHRoZSBzZXF1ZWxpemUgYXNzb2NpYXRpb24gY2xhc3MuXG4gKlxuICogQHNlZSB7QGxpbmsgQXNzb2NpYXRpb259XG4gKi9cblNlcXVlbGl6ZS5wcm90b3R5cGUuQXNzb2NpYXRpb24gPSBTZXF1ZWxpemUuQXNzb2NpYXRpb24gPSBBc3NvY2lhdGlvbjtcblxuLyoqXG4gKiBQcm92aWRlIGFsdGVybmF0aXZlIHZlcnNpb24gb2YgYGluZmxlY3Rpb25gIG1vZHVsZSB0byBiZSB1c2VkIGJ5IGBVdGlscy5wbHVyYWxpemVgIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gX2luZmxlY3Rpb24gLSBgaW5mbGVjdGlvbmAgbW9kdWxlXG4gKi9cblNlcXVlbGl6ZS51c2VJbmZsZWN0aW9uID0gVXRpbHMudXNlSW5mbGVjdGlvbjtcblxuLyoqXG4gKiBBbGxvdyBob29rcyB0byBiZSBkZWZpbmVkIG9uIFNlcXVlbGl6ZSArIG9uIHNlcXVlbGl6ZSBpbnN0YW5jZSBhcyB1bml2ZXJzYWwgaG9va3MgdG8gcnVuIG9uIGFsbCBtb2RlbHNcbiAqIGFuZCBvbiBTZXF1ZWxpemUvc2VxdWVsaXplIG1ldGhvZHMgZS5nLiBTZXF1ZWxpemUoKSwgU2VxdWVsaXplI2RlZmluZSgpXG4gKi9cbkhvb2tzLmFwcGx5VG8oU2VxdWVsaXplKTtcbkhvb2tzLmFwcGx5VG8oU2VxdWVsaXplLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRXhwb3NlIHZhcmlvdXMgZXJyb3JzIGF2YWlsYWJsZVxuICovXG5cbi8vIGV4cG9zZSBhbGlhcyB0byBCYXNlRXJyb3JcblNlcXVlbGl6ZS5FcnJvciA9IHNlcXVlbGl6ZUVycm9ycy5CYXNlRXJyb3I7XG5cbmZvciAoY29uc3QgZXJyb3Igb2YgT2JqZWN0LmtleXMoc2VxdWVsaXplRXJyb3JzKSkge1xuICBTZXF1ZWxpemVbZXJyb3JdID0gc2VxdWVsaXplRXJyb3JzW2Vycm9yXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZWxpemU7XG5tb2R1bGUuZXhwb3J0cy5TZXF1ZWxpemUgPSBTZXF1ZWxpemU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gU2VxdWVsaXplO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGEtdHlwZXMnKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCcuL3V0aWxzL2xvZ2dlcicpO1xuXG5mdW5jdGlvbiBhcnJheVRvTGlzdChhcnJheSwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChzcWwsIHZhbCwgaSkgPT4ge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBzcWwgKz0gJywgJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgc3FsICs9IGAoJHthcnJheVRvTGlzdCh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcWwgKz0gZXNjYXBlKHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH0sICcnKTtcbn1cbmV4cG9ydHMuYXJyYXlUb0xpc3QgPSBhcnJheVRvTGlzdDtcblxuZnVuY3Rpb24gZXNjYXBlKHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdCkge1xuICBsZXQgcHJlcGVuZE4gPSBmYWxzZTtcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnTlVMTCc7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgLy8gU1FMaXRlIGRvZXNuJ3QgaGF2ZSB0cnVlL2ZhbHNlIHN1cHBvcnQuIE15U1FMIGFsaWFzZXMgdHJ1ZS9mYWxzZSB0byAxLzBcbiAgICAvLyBmb3IgdXMuIFBvc3RncmVzIGFjdHVhbGx5IGhhcyBhIGJvb2xlYW4gdHlwZSB3aXRoIHRydWUvZmFsc2UgbGl0ZXJhbHMsXG4gICAgLy8gYnV0IHNlcXVlbGl6ZSBkb2Vzbid0IHVzZSBpdCB5ZXQuXG4gICAgICBpZiAoZGlhbGVjdCA9PT0gJ3NxbGl0ZScgfHwgZGlhbGVjdCA9PT0gJ21zc3FsJykge1xuICAgICAgICByZXR1cm4gKyEhdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICghIXZhbCkudG9TdHJpbmcoKTtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgLy8gSW4gbXNzcWwsIHByZXBlbmQgTiB0byBhbGwgcXVvdGVkIHZhbHMgd2hpY2ggYXJlIG9yaWdpbmFsbHkgYSBzdHJpbmcgKGZvclxuICAgIC8vIHVuaWNvZGUgY29tcGF0aWJpbGl0eSlcbiAgICAgIHByZXBlbmROID0gZGlhbGVjdCA9PT0gJ21zc3FsJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB2YWwgPSBkYXRhVHlwZXNbZGlhbGVjdF0uREFURS5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCwgeyB0aW1lem9uZTogdGltZVpvbmUgfSk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICBpZiAoZGF0YVR5cGVzW2RpYWxlY3RdLkJMT0IpIHtcbiAgICAgIHJldHVybiBkYXRhVHlwZXNbZGlhbGVjdF0uQkxPQi5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFUeXBlcy5CTE9CLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBwYXJ0aWFsRXNjYXBlID0gZXNjVmFsID0+IGVzY2FwZShlc2NWYWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQpO1xuICAgIGlmIChkaWFsZWN0ID09PSAncG9zdGdyZXMnICYmICFmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkYXRhVHlwZXMuQVJSQVkucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwsIHsgZXNjYXBlOiBwYXJ0aWFsRXNjYXBlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUb0xpc3QodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0KTtcbiAgfVxuXG4gIGlmICghdmFsLnJlcGxhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgJHtsb2dnZXIuaW5zcGVjdCh2YWwpfWApO1xuICB9XG5cbiAgaWYgKGRpYWxlY3QgPT09ICdwb3N0Z3JlcycgfHwgZGlhbGVjdCA9PT0gJ3NxbGl0ZScgfHwgZGlhbGVjdCA9PT0gJ21zc3FsJykge1xuICAgIC8vIGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy84LjIvc3RhdGljL3NxbC1zeW50YXgtbGV4aWNhbC5odG1sI1NRTC1TWU5UQVgtU1RSSU5HU1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzYwMzU3Mi8xMzA1OThcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvJy9nLCBcIicnXCIpO1xuXG4gICAgaWYgKGRpYWxlY3QgPT09ICdwb3N0Z3JlcycpIHtcbiAgICAgIC8vIG51bGwgY2hhcmFjdGVyIGlzIG5vdCBhbGxvd2VkIGluIFBvc3RncmVzXG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9bXFwwXFxuXFxyXFxiXFx0XFxcXCdcIlxceDFhXS9nLCBzID0+IHtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICdcXDAnOiByZXR1cm4gJ1xcXFwwJztcbiAgICAgICAgY2FzZSAnXFxuJzogcmV0dXJuICdcXFxcbic7XG4gICAgICAgIGNhc2UgJ1xccic6IHJldHVybiAnXFxcXHInO1xuICAgICAgICBjYXNlICdcXGInOiByZXR1cm4gJ1xcXFxiJztcbiAgICAgICAgY2FzZSAnXFx0JzogcmV0dXJuICdcXFxcdCc7XG4gICAgICAgIGNhc2UgJ1xceDFhJzogcmV0dXJuICdcXFxcWic7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBgXFxcXCR7c31gO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBgJHsocHJlcGVuZE4gPyBcIk4nXCIgOiBcIidcIikgKyB2YWx9J2A7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcblxuZnVuY3Rpb24gZm9ybWF0KHNxbCwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCkge1xuICB2YWx1ZXMgPSBbXS5jb25jYXQodmFsdWVzKTtcblxuICBpZiAodHlwZW9mIHNxbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgU1FMIHN0cmluZyBwcm92aWRlZDogJHtzcWx9YCk7XG4gIH1cblxuICByZXR1cm4gc3FsLnJlcGxhY2UoL1xcPy9nLCBtYXRjaCA9PiB7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSh2YWx1ZXMuc2hpZnQoKSwgdGltZVpvbmUsIGRpYWxlY3QsIHRydWUpO1xuICB9KTtcbn1cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuXG5mdW5jdGlvbiBmb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0KSB7XG4gIHJldHVybiBzcWwucmVwbGFjZSgvOisoPyFcXGQpKFxcdyspL2csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCdwb3N0Z3JlcycgPT09IGRpYWxlY3QgJiYgJzo6JyA9PT0gdmFsdWUuc2xpY2UoMCwgMikpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZSh2YWx1ZXNba2V5XSwgdGltZVpvbmUsIGRpYWxlY3QsIHRydWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVkIHBhcmFtZXRlciBcIiR7dmFsdWV9XCIgaGFzIG5vIHZhbHVlIGluIHRoZSBnaXZlbiBvYmplY3QuYCk7XG4gIH0pO1xufVxuZXhwb3J0cy5mb3JtYXROYW1lZFBhcmFtZXRlcnMgPSBmb3JtYXROYW1lZFBhcmFtZXRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gZW51bSBvZiB0YWJsZSBoaW50cyB0byBiZSB1c2VkIGluIG1zc3FsIGZvciBxdWVyeWluZyB3aXRoIHRhYmxlIGhpbnRzXG4gKlxuICogQHByb3BlcnR5IE5PTE9DS1xuICogQHByb3BlcnR5IFJFQURVTkNPTU1JVFRFRFxuICogQHByb3BlcnR5IFVQRExPQ0tcbiAqIEBwcm9wZXJ0eSBSRVBFQVRBQkxFUkVBRFxuICogQHByb3BlcnR5IFNFUklBTElaQUJMRVxuICogQHByb3BlcnR5IFJFQURDT01NSVRURURcbiAqIEBwcm9wZXJ0eSBUQUJMT0NLXG4gKiBAcHJvcGVydHkgVEFCTE9DS1hcbiAqIEBwcm9wZXJ0eSBQQUdMT0NLXG4gKiBAcHJvcGVydHkgUk9XTE9DS1xuICogQHByb3BlcnR5IE5PV0FJVFxuICogQHByb3BlcnR5IFJFQURQQVNUXG4gKiBAcHJvcGVydHkgWExPQ0tcbiAqIEBwcm9wZXJ0eSBTTkFQU0hPVFxuICogQHByb3BlcnR5IE5PRVhQQU5EXG4gKi9cbmNvbnN0IFRhYmxlSGludHMgPSBtb2R1bGUuZXhwb3J0cyA9IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBOT0xPQ0s6ICdOT0xPQ0snLFxuICBSRUFEVU5DT01NSVRURUQ6ICdSRUFEVU5DT01NSVRURUQnLFxuICBVUERMT0NLOiAnVVBETE9DSycsXG4gIFJFUEVBVEFCTEVSRUFEOiAnUkVQRUFUQUJMRVJFQUQnLFxuICBTRVJJQUxJWkFCTEU6ICdTRVJJQUxJWkFCTEUnLFxuICBSRUFEQ09NTUlUVEVEOiAnUkVBRENPTU1JVFRFRCcsXG4gIFRBQkxPQ0s6ICdUQUJMT0NLJyxcbiAgVEFCTE9DS1g6ICdUQUJMT0NLWCcsXG4gIFBBR0xPQ0s6ICdQQUdMT0NLJyxcbiAgUk9XTE9DSzogJ1JPV0xPQ0snLFxuICBOT1dBSVQ6ICdOT1dBSVQnLFxuICBSRUFEUEFTVDogJ1JFQURQQVNUJyxcbiAgWExPQ0s6ICdYTE9DSycsXG4gIFNOQVBTSE9UOiAnU05BUFNIT1QnLFxuICBOT0VYUEFORDogJ05PRVhQQU5EJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IGlzIHVzZWQgdG8gaWRlbnRpZnkgYSBydW5uaW5nIHRyYW5zYWN0aW9uLlxuICogSXQgaXMgY3JlYXRlZCBieSBjYWxsaW5nIGBTZXF1ZWxpemUudHJhbnNhY3Rpb24oKWAuXG4gKiBUbyBydW4gYSBxdWVyeSB1bmRlciBhIHRyYW5zYWN0aW9uLCB5b3Ugc2hvdWxkIHBhc3MgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqIEBzZWUge0BsaW5rIFNlcXVlbGl6ZS50cmFuc2FjdGlvbn1cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1NlcXVlbGl6ZX0gc2VxdWVsaXplIEEgY29uZmlndXJlZCBzZXF1ZWxpemUgSW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZV0gU2V0cyB0aGUgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24uIFNxbGl0ZSBvbmx5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pc29sYXRpb25MZXZlbF0gU2V0cyB0aGUgaXNvbGF0aW9uIGxldmVsIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmVycmFibGVdIFNldHMgdGhlIGNvbnN0cmFpbnRzIHRvIGJlIGRlZmVycmVkIG9yIGltbWVkaWF0ZWx5IGNoZWNrZWQuIFBvc3RncmVTUUwgb25seVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5zYXZlcG9pbnRzID0gW107XG4gICAgdGhpcy5fYWZ0ZXJDb21taXRIb29rcyA9IFtdO1xuXG4gICAgLy8gZ2V0IGRpYWxlY3Qgc3BlY2lmaWMgdHJhbnNhY3Rpb24gb3B0aW9uc1xuICAgIGNvbnN0IGdlbmVyYXRlVHJhbnNhY3Rpb25JZCA9IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuZ2VuZXJhdGVUcmFuc2FjdGlvbklkO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgdHlwZTogc2VxdWVsaXplLm9wdGlvbnMudHJhbnNhY3Rpb25UeXBlLFxuICAgICAgaXNvbGF0aW9uTGV2ZWw6IHNlcXVlbGl6ZS5vcHRpb25zLmlzb2xhdGlvbkxldmVsLFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICB0aGlzLnBhcmVudCA9IHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbjtcblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMucGFyZW50LmlkO1xuICAgICAgdGhpcy5wYXJlbnQuc2F2ZXBvaW50cy5wdXNoKHRoaXMpO1xuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5pZH0tc3AtJHt0aGlzLnBhcmVudC5zYXZlcG9pbnRzLmxlbmd0aH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5uYW1lID0gZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21taXQgdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgY29tbWl0KCkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNhbm5vdCBiZSBjb21taXR0ZWQgYmVjYXVzZSBpdCBoYXMgYmVlbiBmaW5pc2hlZCB3aXRoIHN0YXRlOiAke3RoaXMuZmluaXNoZWR9YCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLmNvbW1pdFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSAnY29tbWl0JztcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MpIHtcbiAgICAgICAgYXdhaXQgaG9vay5hcHBseSh0aGlzLCBbdGhpc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayAoYWJvcnQpIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJvbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNhbm5vdCBiZSByb2xsZWQgYmFjayBiZWNhdXNlIGl0IGhhcyBiZWVuIGZpbmlzaGVkIHdpdGggc3RhdGU6ICR7dGhpcy5maW5pc2hlZH1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcm9sbGVkIGJhY2sgYmVjYXVzZSBpdCBuZXZlciBzdGFydGVkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzXG4gICAgICAgIC5zZXF1ZWxpemVcbiAgICAgICAgLmdldFF1ZXJ5SW50ZXJmYWNlKClcbiAgICAgICAgLnJvbGxiYWNrVHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBhY3F1aXJlIGEgY29ubmVjdGlvbiB0byB1c2UgYW5kIHNldCB0aGUgY29ycmVjdCBvcHRpb25zIG9uIHRoZSBjb25uZWN0aW9uLlxuICAgKiBXZSBzaG91bGQgZW5zdXJlIGFsbCBvZiB0aGUgZW52aXJvbm1lbnQgdGhhdCdzIHNldCB1cCBpcyBjbGVhbmVkIHVwIGluIGBjbGVhbnVwKClgIGJlbG93LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUNMUyBEZWZhdWx0cyB0byB0cnVlOiBVc2UgQ0xTIChDb250aW51YXRpb24gTG9jYWwgU3RvcmFnZSkgd2l0aCBTZXF1ZWxpemUuIFdpdGggQ0xTLCBhbGwgcXVlcmllcyB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseSByZWNlaXZlIHRoZSB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZUVudmlyb25tZW50KHVzZUNMUykge1xuICAgIGxldCBjb25uZWN0aW9uUHJvbWlzZTtcblxuICAgIGlmICh1c2VDTFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQ0xTID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGNvbm5lY3Rpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMucGFyZW50LmNvbm5lY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhY3F1aXJlT3B0aW9ucyA9IHsgdXVpZDogdGhpcy5pZCB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICBhY3F1aXJlT3B0aW9ucy50eXBlID0gJ1NFTEVDVCc7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24oYWNxdWlyZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5jb25uZWN0aW9uLnV1aWQgPSB0aGlzLmlkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYmVnaW4oKTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2V0RGVmZXJyYWJsZSgpO1xuICAgIH0gY2F0Y2ggKHNldHVwRXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJvbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBzZXR1cEVycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1c2VDTFMgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5zZXQoJ3RyYW5zYWN0aW9uJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIHNldERlZmVycmFibGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWZlcnJhYmxlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpc1xuICAgICAgICAuc2VxdWVsaXplXG4gICAgICAgIC5nZXRRdWVyeUludGVyZmFjZSgpXG4gICAgICAgIC5kZWZlckNvbnN0cmFpbnRzKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYmVnaW4oKSB7XG4gICAgY29uc3QgcXVlcnlJbnRlcmZhY2UgPSB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpO1xuXG4gICAgaWYgKCB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnN1cHBvcnRzLnNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uICkge1xuICAgICAgYXdhaXQgcXVlcnlJbnRlcmZhY2Uuc3RhcnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHF1ZXJ5SW50ZXJmYWNlLnNldElzb2xhdGlvbkxldmVsKHRoaXMsIHRoaXMub3B0aW9ucy5pc29sYXRpb25MZXZlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBhd2FpdCBxdWVyeUludGVyZmFjZS5zZXRJc29sYXRpb25MZXZlbCh0aGlzLCB0aGlzLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsIHRoaXMub3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcXVlcnlJbnRlcmZhY2Uuc3RhcnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICAvLyBEb24ndCByZWxlYXNlIHRoZSBjb25uZWN0aW9uIGlmIHRoZXJlJ3MgYSBwYXJlbnQgdHJhbnNhY3Rpb24gb3JcbiAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IGNsZWFuZWQgdXBcbiAgICBpZiAodGhpcy5wYXJlbnQgfHwgdGhpcy5jb25uZWN0aW9uLnV1aWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fY2xlYXJDbHMoKTtcbiAgICBjb25zdCByZXMgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5yZWxlYXNlQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24pO1xuICAgIHRoaXMuY29ubmVjdGlvbi51dWlkID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBfY2xlYXJDbHMoKSB7XG4gICAgY29uc3QgY2xzID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2NscztcblxuICAgIGlmIChjbHMpIHtcbiAgICAgIGlmIChjbHMuZ2V0KCd0cmFuc2FjdGlvbicpID09PSB0aGlzKSB7XG4gICAgICAgIGNscy5zZXQoJ3RyYW5zYWN0aW9uJywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaG9vayB0aGF0IGlzIHJ1biBhZnRlciBhIHRyYW5zYWN0aW9uIGlzIGNvbW1pdHRlZFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCB0aGUgY29tbWl0dGVkIHRyYW5zYWN0aW9uXG4gICAqIEBuYW1lIGFmdGVyQ29tbWl0XG4gICAqIEBtZW1iZXJvZiBTZXF1ZWxpemUuVHJhbnNhY3Rpb25cbiAgICovXG4gIGFmdGVyQ29tbWl0KGZuKSB7XG4gICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJmblwiIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9hZnRlckNvbW1pdEhvb2tzLnB1c2goZm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFR5cGVzIGNhbiBiZSBzZXQgcGVyLXRyYW5zYWN0aW9uIGJ5IHBhc3NpbmcgYG9wdGlvbnMudHlwZWAgdG8gYHNlcXVlbGl6ZS50cmFuc2FjdGlvbmAuXG4gICAqIERlZmF1bHQgdG8gYERFRkVSUkVEYCBidXQgeW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCB0eXBlIGJ5IHBhc3NpbmcgYG9wdGlvbnMudHJhbnNhY3Rpb25UeXBlYCBpbiBgbmV3IFNlcXVlbGl6ZWAuXG4gICAqIFNxbGl0ZSBvbmx5LlxuICAgKlxuICAgKiBQYXNzIGluIHRoZSBkZXNpcmVkIGxldmVsIGFzIHRoZSBmaXJzdCBhcmd1bWVudDpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdHJ5IHtcbiAgICogICBhd2FpdCBzZXF1ZWxpemUudHJhbnNhY3Rpb24oeyB0eXBlOiBTZXF1ZWxpemUuVHJhbnNhY3Rpb24uVFlQRVMuRVhDTFVTSVZFIH0sIHRyYW5zYWN0aW9uID0+IHtcbiAgICogICAgICAvLyB5b3VyIHRyYW5zYWN0aW9uc1xuICAgKiAgIH0pO1xuICAgKiAgIC8vIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGNvbW1pdHRlZC4gRG8gc29tZXRoaW5nIGFmdGVyIHRoZSBjb21taXQgaWYgcmVxdWlyZWQuXG4gICAqIH0gY2F0Y2goZXJyKSB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGVyci5cbiAgICogfVxuICAgKlxuICAgKiBAcHJvcGVydHkgREVGRVJSRURcbiAgICogQHByb3BlcnR5IElNTUVESUFURVxuICAgKiBAcHJvcGVydHkgRVhDTFVTSVZFXG4gICAqL1xuICBzdGF0aWMgZ2V0IFRZUEVTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBERUZFUlJFRDogJ0RFRkVSUkVEJyxcbiAgICAgIElNTUVESUFURTogJ0lNTUVESUFURScsXG4gICAgICBFWENMVVNJVkU6ICdFWENMVVNJVkUnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJc29sYXRpb24gbGV2ZWxzIGNhbiBiZSBzZXQgcGVyLXRyYW5zYWN0aW9uIGJ5IHBhc3NpbmcgYG9wdGlvbnMuaXNvbGF0aW9uTGV2ZWxgIHRvIGBzZXF1ZWxpemUudHJhbnNhY3Rpb25gLlxuICAgKiBTZXF1ZWxpemUgdXNlcyB0aGUgZGVmYXVsdCBpc29sYXRpb24gbGV2ZWwgb2YgdGhlIGRhdGFiYXNlLCB5b3UgY2FuIG92ZXJyaWRlIHRoaXMgYnkgcGFzc2luZyBgb3B0aW9ucy5pc29sYXRpb25MZXZlbGAgaW4gU2VxdWVsaXplIGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAqXG4gICAqIFBhc3MgaW4gdGhlIGRlc2lyZWQgbGV2ZWwgYXMgdGhlIGZpcnN0IGFyZ3VtZW50OlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0cnkge1xuICAgKiAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbih7aXNvbGF0aW9uTGV2ZWw6IFNlcXVlbGl6ZS5UcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlNFUklBTElaQUJMRX0sIHRyYW5zYWN0aW9uID0+IHtcbiAgICogICAgIC8vIHlvdXIgdHJhbnNhY3Rpb25zXG4gICAqICAgfSk7XG4gICAqICAgLy8gdHJhbnNhY3Rpb24gaGFzIGJlZW4gY29tbWl0dGVkLiBEbyBzb21ldGhpbmcgYWZ0ZXIgdGhlIGNvbW1pdCBpZiByZXF1aXJlZC5cbiAgICogfSBjYXRjaChlcnIpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXJyLlxuICAgKiB9XG4gICAqXG4gICAqIEBwcm9wZXJ0eSBSRUFEX1VOQ09NTUlUVEVEXG4gICAqIEBwcm9wZXJ0eSBSRUFEX0NPTU1JVFRFRFxuICAgKiBAcHJvcGVydHkgUkVQRUFUQUJMRV9SRUFEXG4gICAqIEBwcm9wZXJ0eSBTRVJJQUxJWkFCTEVcbiAgICovXG4gIHN0YXRpYyBnZXQgSVNPTEFUSU9OX0xFVkVMUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUkVBRF9VTkNPTU1JVFRFRDogJ1JFQUQgVU5DT01NSVRURUQnLFxuICAgICAgUkVBRF9DT01NSVRURUQ6ICdSRUFEIENPTU1JVFRFRCcsXG4gICAgICBSRVBFQVRBQkxFX1JFQUQ6ICdSRVBFQVRBQkxFIFJFQUQnLFxuICAgICAgU0VSSUFMSVpBQkxFOiAnU0VSSUFMSVpBQkxFJ1xuICAgIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBvcHRpb25zIGZvciByb3cgbG9ja2luZy4gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBmaW5kYCBjYWxsczpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gdDEgaXMgYSB0cmFuc2FjdGlvblxuICAgKiBNb2RlbC5maW5kQWxsKHtcbiAgICogICB3aGVyZTogLi4uLFxuICAgKiAgIHRyYW5zYWN0aW9uOiB0MSxcbiAgICogICBsb2NrOiB0MS5MT0NLLi4uXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Qb3N0Z3JlcyBhbHNvIHN1cHBvcnRzIHNwZWNpZmljIGxvY2tzIHdoaWxlIGVhZ2VyIGxvYWRpbmcgYnkgdXNpbmcgT0Y6PC9jYXB0aW9uPlxuICAgKiBVc2VyTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IC4uLixcbiAgICogICBpbmNsdWRlOiBbVGFza01vZGVsLCAuLi5dLFxuICAgKiAgIHRyYW5zYWN0aW9uOiB0MSxcbiAgICogICBsb2NrOiB7XG4gICAqICAgICBsZXZlbDogdDEuTE9DSy4uLixcbiAgICogICAgIG9mOiBVc2VyTW9kZWxcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAjIFVzZXJNb2RlbCB3aWxsIGJlIGxvY2tlZCBidXQgVGFza01vZGVsIHdvbid0IVxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Zb3UgY2FuIGFsc28gc2tpcCBsb2NrZWQgcm93czo8L2NhcHRpb24+XG4gICAqIC8vIHQxIGlzIGEgdHJhbnNhY3Rpb25cbiAgICogTW9kZWwuZmluZEFsbCh7XG4gICAqICAgd2hlcmU6IC4uLixcbiAgICogICB0cmFuc2FjdGlvbjogdDEsXG4gICAqICAgbG9jazogdHJ1ZSxcbiAgICogICBza2lwTG9ja2VkOiB0cnVlXG4gICAqIH0pO1xuICAgKiAjIFRoZSBxdWVyeSB3aWxsIG5vdyByZXR1cm4gYW55IHJvd3MgdGhhdCBhcmVuJ3QgbG9ja2VkIGJ5IGFub3RoZXIgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICogQHByb3BlcnR5IFVQREFURVxuICAgKiBAcHJvcGVydHkgU0hBUkVcbiAgICogQHByb3BlcnR5IEtFWV9TSEFSRSBQb3N0Z3JlcyA5LjMrIG9ubHlcbiAgICogQHByb3BlcnR5IE5PX0tFWV9VUERBVEUgUG9zdGdyZXMgOS4zKyBvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IExPQ0soKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFVQREFURTogJ1VQREFURScsXG4gICAgICBTSEFSRTogJ1NIQVJFJyxcbiAgICAgIEtFWV9TSEFSRTogJ0tFWSBTSEFSRScsXG4gICAgICBOT19LRVlfVVBEQVRFOiAnTk8gS0VZIFVQREFURSdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBsZWFzZSBzZWUge0BsaW5rIFRyYW5zYWN0aW9uLkxPQ0t9XG4gICAqL1xuICBnZXQgTE9DSygpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTE9DSztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2FjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKCcuL3NxbC1zdHJpbmcnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC9fYmFzZUlzTmF0aXZlJyk7XG5jb25zdCB1dWlkdjEgPSByZXF1aXJlKCd1dWlkJykudjE7XG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5jb25zdCBvcGVyYXRvcnMgPSByZXF1aXJlKCcuL29wZXJhdG9ycycpO1xuY29uc3Qgb3BlcmF0b3JzU2V0ID0gbmV3IFNldChPYmplY3QudmFsdWVzKG9wZXJhdG9ycykpO1xuXG5sZXQgaW5mbGVjdGlvbiA9IHJlcXVpcmUoJ2luZmxlY3Rpb24nKTtcblxuZXhwb3J0cy5jbGFzc1RvSW52b2thYmxlID0gcmVxdWlyZSgnLi91dGlscy9jbGFzcy10by1pbnZva2FibGUnKS5jbGFzc1RvSW52b2thYmxlO1xuZXhwb3J0cy5qb2luU1FMRnJhZ21lbnRzID0gcmVxdWlyZSgnLi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMnKS5qb2luU1FMRnJhZ21lbnRzO1xuXG5mdW5jdGlvbiB1c2VJbmZsZWN0aW9uKF9pbmZsZWN0aW9uKSB7XG4gIGluZmxlY3Rpb24gPSBfaW5mbGVjdGlvbjtcbn1cbmV4cG9ydHMudXNlSW5mbGVjdGlvbiA9IHVzZUluZmxlY3Rpb247XG5cbmZ1bmN0aW9uIGNhbWVsaXplSWYoc3RyLCBjb25kaXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcblxuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmVzdWx0ID0gY2FtZWxpemUoc3RyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNhbWVsaXplSWYgPSBjYW1lbGl6ZUlmO1xuXG5mdW5jdGlvbiB1bmRlcnNjb3JlZElmKHN0ciwgY29uZGl0aW9uKSB7XG4gIGxldCByZXN1bHQgPSBzdHI7XG5cbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJlc3VsdCA9IHVuZGVyc2NvcmUoc3RyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVuZGVyc2NvcmVkSWYgPSB1bmRlcnNjb3JlZElmO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbi8vIFNhbWUgY29uY2VwdCBhcyBfLm1lcmdlLCBidXQgZG9uJ3Qgb3ZlcndyaXRlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhc3NpZ25lZFxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhhLCBiKSB7XG4gIHJldHVybiBfLm1lcmdlV2l0aChhLCBiLCAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSA9PiB7XG4gICAgLy8gSWYgaXQncyBhbiBvYmplY3QsIGxldCBfIGhhbmRsZSBpdCB0aGlzIHRpbWUsIHdlIHdpbGwgYmUgY2FsbGVkIGFnYWluIGZvciBlYWNoIHByb3BlcnR5XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob2JqZWN0VmFsdWUpICYmIG9iamVjdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIF8uaXNOYXRpdmUgaW5jbHVkZXMgYSBjaGVjayBmb3IgY29yZS1qcyBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHByZXNlbnQuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gX2Jhc2VJc05hdGl2ZSBieXBhc3NlcyB0aGUgY29yZS1qcyBjaGVjay5cbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqZWN0VmFsdWUpICYmIGJhc2VJc05hdGl2ZShvYmplY3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVZhbHVlIHx8IG9iamVjdFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLm1lcmdlRGVmYXVsdHMgPSBtZXJnZURlZmF1bHRzO1xuXG4vLyBBbiBhbHRlcm5hdGl2ZSB0byBfLm1lcmdlLCB3aGljaCBkb2Vzbid0IGNsb25lIGl0cyBhcmd1bWVudHNcbi8vIENsb25pbmcgaXMgYSBiYWQgaWRlYSBiZWNhdXNlIG9wdGlvbnMgYXJndW1lbnRzIG1heSBjb250YWluIHJlZmVyZW5jZXMgdG8gc2VxdWVsaXplXG4vLyBtb2RlbHMgLSB3aGljaCBhZ2FpbiByZWZlcmVuY2UgZGF0YWJhc2UgbGlicyB3aGljaCBkb24ndCBsaWtlIHRvIGJlIGNsb25lZCAoaW4gcGFydGljdWxhciBwZy1uYXRpdmUpXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgZm9yIChjb25zdCBvYmogb2YgYXJndW1lbnRzKSB7XG4gICAgXy5mb3JPd24ob2JqLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHRba2V5XSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS5jb25jYXQocmVzdWx0W2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5cbmZ1bmN0aW9uIHNwbGljZVN0cihzdHIsIGluZGV4LCBjb3VudCwgYWRkKSB7XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgaW5kZXgpICsgYWRkICsgc3RyLnNsaWNlKGluZGV4ICsgY291bnQpO1xufVxuZXhwb3J0cy5zcGxpY2VTdHIgPSBzcGxpY2VTdHI7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9bLV9cXHNdKyguKT8vZywgKG1hdGNoLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpO1xufVxuZXhwb3J0cy5jYW1lbGl6ZSA9IGNhbWVsaXplO1xuXG5mdW5jdGlvbiB1bmRlcnNjb3JlKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi51bmRlcnNjb3JlKHN0cik7XG59XG5leHBvcnRzLnVuZGVyc2NvcmUgPSB1bmRlcnNjb3JlO1xuXG5mdW5jdGlvbiBzaW5ndWxhcml6ZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoc3RyKTtcbn1cbmV4cG9ydHMuc2luZ3VsYXJpemUgPSBzaW5ndWxhcml6ZTtcblxuZnVuY3Rpb24gcGx1cmFsaXplKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi5wbHVyYWxpemUoc3RyKTtcbn1cbmV4cG9ydHMucGx1cmFsaXplID0gcGx1cmFsaXplO1xuXG5mdW5jdGlvbiBmb3JtYXQoYXJyLCBkaWFsZWN0KSB7XG4gIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBhcnJheSBiZWFjdXNlIGZvcm1hdCBtb2RpZmllcyB0aGUgcGFzc2VkIGFyZ3NcbiAgcmV0dXJuIFNxbFN0cmluZy5mb3JtYXQoYXJyWzBdLCBhcnIuc2xpY2UoMSksIHRpbWVab25lLCBkaWFsZWN0KTtcbn1cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuXG5mdW5jdGlvbiBmb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCBwYXJhbWV0ZXJzLCBkaWFsZWN0KSB7XG4gIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgcmV0dXJuIFNxbFN0cmluZy5mb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCBwYXJhbWV0ZXJzLCB0aW1lWm9uZSwgZGlhbGVjdCk7XG59XG5leHBvcnRzLmZvcm1hdE5hbWVkUGFyYW1ldGVycyA9IGZvcm1hdE5hbWVkUGFyYW1ldGVycztcblxuZnVuY3Rpb24gY2xvbmVEZWVwKG9iaiwgb25seVBsYWluKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgcmV0dXJuIF8uY2xvbmVEZWVwV2l0aChvYmosIGVsZW0gPT4ge1xuICAgIC8vIERvIG5vdCB0cnkgdG8gY3VzdG9taXplIGNsb25pbmcgb2YgYXJyYXlzIG9yIFBPSk9zXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbSkgfHwgXy5pc1BsYWluT2JqZWN0KGVsZW0pKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIElmIHdlIHNwZWNpZmllZCB0byBjbG9uZSBvbmx5IHBsYWluIG9iamVjdHMgJiBhcnJheXMsIHdlIGlnbm9yZSBldmVyeWhpbmcgZWxzZVxuICAgIC8vIEluIGFueSBjYXNlLCBkb24ndCBjbG9uZSBzdHVmZiB0aGF0J3MgYW4gb2JqZWN0LCBidXQgbm90IGEgcGxhaW4gb25lIC0gZnggZXhhbXBsZSBzZXF1ZWxpemUgbW9kZWxzIGFuZCBpbnN0YW5jZXNcbiAgICBpZiAob25seVBsYWluIHx8IHR5cGVvZiBlbGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgLy8gUHJlc2VydmUgc3BlY2lhbCBkYXRhLXR5cGVzIGxpa2UgYGZuYCBhY3Jvc3MgY2xvbmVzLiBfLmdldCgpIGlzIHVzZWQgZm9yIGNoZWNraW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICBpZiAoZWxlbSAmJiB0eXBlb2YgZWxlbS5jbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGVsZW0uY2xvbmUoKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG5cbi8qIEV4cGFuZCBhbmQgbm9ybWFsaXplIGZpbmRlciBvcHRpb25zICovXG5mdW5jdGlvbiBtYXBGaW5kZXJPcHRpb25zKG9wdGlvbnMsIE1vZGVsKSB7XG4gIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gTW9kZWwuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLmZpbHRlcih2ID0+ICFNb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKHYpKTtcbiAgfVxuXG4gIG1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgTW9kZWwpO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5tYXBGaW5kZXJPcHRpb25zID0gbWFwRmluZGVyT3B0aW9ucztcblxuLyogVXNlZCB0byBtYXAgZmllbGQgbmFtZXMgaW4gYXR0cmlidXRlcyBhbmQgd2hlcmUgY29uZGl0aW9ucyAqL1xuZnVuY3Rpb24gbWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCBNb2RlbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcChhdHRyID0+IHtcbiAgICAgIC8vIE9iamVjdCBsb29rdXBzIHdpbGwgZm9yY2UgYW55IHZhcmlhYmxlIHRvIHN0cmluZ3MsIHdlIGRvbid0IHdhbnQgdGhhdCBmb3Igc3BlY2lhbCBvYmplY3RzIGV0Y1xuICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSAnc3RyaW5nJykgcmV0dXJuIGF0dHI7XG4gICAgICAvLyBNYXAgYXR0cmlidXRlcyB0byBhbGlhc2VkIHN5bnRheCBhdHRyaWJ1dGVzXG4gICAgICBpZiAoTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSAmJiBhdHRyICE9PSBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkKSB7XG4gICAgICAgIHJldHVybiBbTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCwgYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLndoZXJlICYmIF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgIG9wdGlvbnMud2hlcmUgPSBtYXBXaGVyZUZpZWxkTmFtZXMob3B0aW9ucy53aGVyZSwgTW9kZWwpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLm1hcE9wdGlvbkZpZWxkTmFtZXMgPSBtYXBPcHRpb25GaWVsZE5hbWVzO1xuXG5mdW5jdGlvbiBtYXBXaGVyZUZpZWxkTmFtZXMoYXR0cmlidXRlcywgTW9kZWwpIHtcbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBnZXRDb21wbGV4S2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgICBjb25zdCByYXdBdHRyaWJ1dGUgPSBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG5cbiAgICAgIGlmIChyYXdBdHRyaWJ1dGUgJiYgcmF3QXR0cmlidXRlLmZpZWxkICE9PSByYXdBdHRyaWJ1dGUuZmllbGROYW1lKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbcmF3QXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pXG4gICAgICAgICYmICEocmF3QXR0cmlidXRlICYmIChcbiAgICAgICAgICByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5IU1RPUkVcbiAgICAgICAgICB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSkpIHsgLy8gUHJldmVudCByZW5hbWluZyBvZiBIU1RPUkUgJiBKU09OIGZpZWxkc1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBtYXBPcHRpb25GaWVsZE5hbWVzKHtcbiAgICAgICAgICB3aGVyZTogYXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICAgIH0sIE1vZGVsKS53aGVyZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlc1thdHRyaWJ1dGVdKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uZm9yRWFjaCgod2hlcmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh3aGVyZSkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXVtpbmRleF0gPSBtYXBXaGVyZUZpZWxkTmFtZXMod2hlcmUsIE1vZGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmV4cG9ydHMubWFwV2hlcmVGaWVsZE5hbWVzID0gbWFwV2hlcmVGaWVsZE5hbWVzO1xuXG4vKiBVc2VkIHRvIG1hcCBmaWVsZCBuYW1lcyBpbiB2YWx1ZXMgKi9cbmZ1bmN0aW9uIG1hcFZhbHVlRmllbGROYW1lcyhkYXRhVmFsdWVzLCBmaWVsZHMsIE1vZGVsKSB7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgYXR0ciBvZiBmaWVsZHMpIHtcbiAgICBpZiAoZGF0YVZhbHVlc1thdHRyXSAhPT0gdW5kZWZpbmVkICYmICFNb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGF0dHIpKSB7XG4gICAgICAvLyBGaWVsZCBuYW1lIG1hcHBpbmdcbiAgICAgIGlmIChNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmIE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiYgTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0cikge1xuICAgICAgICB2YWx1ZXNbTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gPSBkYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2F0dHJdID0gZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5tYXBWYWx1ZUZpZWxkTmFtZXMgPSBtYXBWYWx1ZUZpZWxkTmFtZXM7XG5cbmZ1bmN0aW9uIGlzQ29sU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnJCcgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICckJztcbn1cbmV4cG9ydHMuaXNDb2xTdHJpbmcgPSBpc0NvbFN0cmluZztcblxuZnVuY3Rpb24gY2FuVHJlYXRBcnJheUFzQW5kKGFycikge1xuICByZXR1cm4gYXJyLnNvbWUoYXJnID0+IF8uaXNQbGFpbk9iamVjdChhcmcpIHx8IGFyZyBpbnN0YW5jZW9mIFdoZXJlKTtcbn1cbmV4cG9ydHMuY2FuVHJlYXRBcnJheUFzQW5kID0gY2FuVHJlYXRBcnJheUFzQW5kO1xuXG5mdW5jdGlvbiBjb21iaW5lVGFibGVOYW1lcyh0YWJsZU5hbWUxLCB0YWJsZU5hbWUyKSB7XG4gIHJldHVybiB0YWJsZU5hbWUxLnRvTG93ZXJDYXNlKCkgPCB0YWJsZU5hbWUyLnRvTG93ZXJDYXNlKCkgPyB0YWJsZU5hbWUxICsgdGFibGVOYW1lMiA6IHRhYmxlTmFtZTIgKyB0YWJsZU5hbWUxO1xufVxuZXhwb3J0cy5jb21iaW5lVGFibGVOYW1lcyA9IGNvbWJpbmVUYWJsZU5hbWVzO1xuXG5mdW5jdGlvbiB0b0RlZmF1bHRWYWx1ZSh2YWx1ZSwgZGlhbGVjdCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdG1wID0gdmFsdWUoKTtcbiAgICBpZiAodG1wIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFCU1RSQUNUKSB7XG4gICAgICByZXR1cm4gdG1wLnRvU3FsKCk7XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWMSkge1xuICAgIHJldHVybiB1dWlkdjEoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFY0KSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5OT1cpIHtcbiAgICByZXR1cm4gbm93KGRpYWxlY3QpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHsgLi4udmFsdWUgfTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLnRvRGVmYXVsdFZhbHVlID0gdG9EZWZhdWx0VmFsdWU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIGV4aXN0cyBhbmQgY2FuIGJlIGRlc2NyaWJlZFxuICogaW4gYSBkYiBzY2hlbWEgdXNpbmcgdGhlIERFRkFVTFQgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSAgeyp9IHZhbHVlIEFueSBkZWZhdWx0IHZhbHVlLlxuICogQHJldHVybnMge2Jvb2xlYW59IHllcyAvIG5vLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFZhbHVlU2NoZW1hYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFRPRE8gdGhpcyB3aWxsIGJlIHNjaGVtYWJsZSB3aGVuIGFsbCBzdXBwb3J0ZWQgZGJcbiAgLy8gaGF2ZSBiZWVuIG5vcm1hbGl6ZWQgZm9yIHRoaXMgY2FzZVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuTk9XKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjEgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFY0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZSA9IGRlZmF1bHRWYWx1ZVNjaGVtYWJsZTtcblxuZnVuY3Rpb24gcmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGhhc2gsIG9taXROdWxsLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bHQgPSBoYXNoO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFsbG93TnVsbCA9IG9wdGlvbnMuYWxsb3dOdWxsIHx8IFtdO1xuXG4gIGlmIChvbWl0TnVsbCkge1xuICAgIGNvbnN0IF9oYXNoID0ge307XG5cbiAgICBfLmZvckluKGhhc2gsICh2YWwsIGtleSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dOdWxsLmluY2x1ZGVzKGtleSkgfHwga2V5LmVuZHNXaXRoKCdJZCcpIHx8IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfaGFzaFtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0ID0gX2hhc2g7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2ggPSByZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2g7XG5cbmNvbnN0IGRpYWxlY3RzID0gbmV3IFNldChbJ21hcmlhZGInLCAnbXlzcWwnLCAncG9zdGdyZXMnLCAnc3FsaXRlJywgJ21zc3FsJ10pO1xuXG5mdW5jdGlvbiBub3coZGlhbGVjdCkge1xuICBjb25zdCBkID0gbmV3IERhdGUoKTtcbiAgaWYgKCFkaWFsZWN0cy5oYXMoZGlhbGVjdCkpIHtcbiAgICBkLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICByZXR1cm4gZDtcbn1cbmV4cG9ydHMubm93ID0gbm93O1xuXG4vLyBOb3RlOiBVc2UgdGhlIGBxdW90ZUlkZW50aWZpZXIoKWAgYW5kIGBlc2NhcGUoKWAgbWV0aG9kcyBvbiB0aGVcbi8vIGBRdWVyeUludGVyZmFjZWAgaW5zdGVhZCBmb3IgbW9yZSBwb3J0YWJsZSBjb2RlLlxuXG5jb25zdCBUSUNLX0NIQVIgPSAnYCc7XG5leHBvcnRzLlRJQ0tfQ0hBUiA9IFRJQ0tfQ0hBUjtcblxuZnVuY3Rpb24gYWRkVGlja3MocywgdGlja0NoYXIpIHtcbiAgdGlja0NoYXIgPSB0aWNrQ2hhciB8fCBUSUNLX0NIQVI7XG4gIHJldHVybiB0aWNrQ2hhciArIHJlbW92ZVRpY2tzKHMsIHRpY2tDaGFyKSArIHRpY2tDaGFyO1xufVxuZXhwb3J0cy5hZGRUaWNrcyA9IGFkZFRpY2tzO1xuXG5mdW5jdGlvbiByZW1vdmVUaWNrcyhzLCB0aWNrQ2hhcikge1xuICB0aWNrQ2hhciA9IHRpY2tDaGFyIHx8IFRJQ0tfQ0hBUjtcbiAgcmV0dXJuIHMucmVwbGFjZShuZXcgUmVnRXhwKHRpY2tDaGFyLCAnZycpLCAnJyk7XG59XG5leHBvcnRzLnJlbW92ZVRpY2tzID0gcmVtb3ZlVGlja3M7XG5cbi8qKlxuICogUmVjZWl2ZXMgYSB0cmVlLWxpa2Ugb2JqZWN0IGFuZCByZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdoaWNoIGRlcHRoIGlzIDEuXG4gKlxuICogLSBJbnB1dDpcbiAqXG4gKiAge1xuICogICAgbmFtZTogJ0pvaG4nLFxuICogICAgYWRkcmVzczoge1xuICogICAgICBzdHJlZXQ6ICdGYWtlIFN0LiAxMjMnLFxuICogICAgICBjb29yZGluYXRlczoge1xuICogICAgICAgIGxvbmdpdHVkZTogNTUuNjc3OTYyNyxcbiAqICAgICAgICBsYXRpdHVkZTogMTIuNTk2NDMxM1xuICogICAgICB9XG4gKiAgICB9XG4gKiAgfVxuICpcbiAqIC0gT3V0cHV0OlxuICpcbiAqICB7XG4gKiAgICBuYW1lOiAnSm9obicsXG4gKiAgICBhZGRyZXNzLnN0cmVldDogJ0Zha2UgU3QuIDEyMycsXG4gKiAgICBhZGRyZXNzLmNvb3JkaW5hdGVzLmxhdGl0dWRlOiA1NS42Nzc5NjI3LFxuICogICAgYWRkcmVzcy5jb29yZGluYXRlcy5sb25naXR1ZGU6IDEyLjU5NjQzMTNcbiAqICB9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIGFuIE9iamVjdFxuICogQHJldHVybnMge29iamVjdH0gYSBmbGF0dGVuZWQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmbGF0dGVuT2JqZWN0RGVlcCh2YWx1ZSkge1xuICBpZiAoIV8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgY29uc3QgZmxhdHRlbmVkT2JqID0ge307XG5cbiAgZnVuY3Rpb24gZmxhdHRlbk9iamVjdChvYmosIHN1YlBhdGgpIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHBhdGhUb1Byb3BlcnR5ID0gc3ViUGF0aCA/IGAke3N1YlBhdGh9LiR7a2V5fWAgOiBrZXk7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JyAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBmbGF0dGVuT2JqZWN0KG9ialtrZXldLCBwYXRoVG9Qcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0dGVuZWRPYmpbcGF0aFRvUHJvcGVydHldID0gXy5nZXQob2JqLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmbGF0dGVuZWRPYmo7XG4gIH1cblxuICByZXR1cm4gZmxhdHRlbk9iamVjdCh2YWx1ZSwgdW5kZWZpbmVkKTtcbn1cbmV4cG9ydHMuZmxhdHRlbk9iamVjdERlZXAgPSBmbGF0dGVuT2JqZWN0RGVlcDtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcmVwcmVzZW50aW5nIFNRTCBmdW5jdGlvbnMsIGFuZCBjb2x1bW5zIHRoYXQgc2hvdWxkIGJlIGVzY2FwZWQuXG4gKiBQbGVhc2UgZG8gbm90IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHksIHVzZSBTZXF1ZWxpemUuZm4gYW5kIFNlcXVlbGl6ZS5jb2wgaW5zdGVhZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTZXF1ZWxpemVNZXRob2Qge31cbmV4cG9ydHMuU2VxdWVsaXplTWV0aG9kID0gU2VxdWVsaXplTWV0aG9kO1xuXG5jbGFzcyBGbiBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGZuLCBhcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEZuKHRoaXMuZm4sIHRoaXMuYXJncyk7XG4gIH1cbn1cbmV4cG9ydHMuRm4gPSBGbjtcblxuY2xhc3MgQ29sIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoY29sLCAuLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb2wgPSBhcmdzO1xuICAgIH1cbiAgICB0aGlzLmNvbCA9IGNvbDtcbiAgfVxufVxuZXhwb3J0cy5Db2wgPSBDb2w7XG5cbmNsYXNzIENhc3QgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcih2YWwsIHR5cGUsIGpzb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICAgIHRoaXMudHlwZSA9ICh0eXBlIHx8ICcnKS50cmltKCk7XG4gICAgdGhpcy5qc29uID0ganNvbiB8fCBmYWxzZTtcbiAgfVxufVxuZXhwb3J0cy5DYXN0ID0gQ2FzdDtcblxuY2xhc3MgTGl0ZXJhbCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH1cbn1cbmV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XG5cbmNsYXNzIEpzb24gZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKF8uaXNPYmplY3QoY29uZGl0aW9uc09yUGF0aCkpIHtcbiAgICAgIHRoaXMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnNPclBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF0aCA9IGNvbmRpdGlvbnNPclBhdGg7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5Kc29uID0gSnNvbjtcblxuY2xhc3MgV2hlcmUgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUsIGNvbXBhcmF0b3IsIGxvZ2ljKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAobG9naWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9naWMgPSBjb21wYXJhdG9yO1xuICAgICAgY29tcGFyYXRvciA9ICc9JztcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMubG9naWMgPSBsb2dpYztcbiAgfVxufVxuZXhwb3J0cy5XaGVyZSA9IFdoZXJlO1xuXG4vL0NvbGxlY3Rpb24gb2YgaGVscGVyIG1ldGhvZHMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIHN5bWJvbCBvcGVyYXRvcnNcblxuLyoqXG4gKiBnZXRPcGVyYXRvcnNcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5PHN5bWJvbD59IEFsbCBvcGVyYXRvcnMgcHJvcGVydGllcyBvZiBvYmpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE9wZXJhdG9ycyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKS5maWx0ZXIocyA9PiBvcGVyYXRvcnNTZXQuaGFzKHMpKTtcbn1cbmV4cG9ydHMuZ2V0T3BlcmF0b3JzID0gZ2V0T3BlcmF0b3JzO1xuXG4vKipcbiAqIGdldENvbXBsZXhLZXlzXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmd8c3ltYm9sPn0gQWxsIGtleXMgaW5jbHVkaW5nIG9wZXJhdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGxleEtleXMob2JqKSB7XG4gIHJldHVybiBnZXRPcGVyYXRvcnMob2JqKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSk7XG59XG5leHBvcnRzLmdldENvbXBsZXhLZXlzID0gZ2V0Q29tcGxleEtleXM7XG5cbi8qKlxuICogZ2V0Q29tcGxleFNpemVcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R8QXJyYXl9IG9ialxuICogQHJldHVybnMge251bWJlcn0gICAgICBMZW5ndGggb2Ygb2JqZWN0IHByb3BlcnRpZXMgaW5jbHVkaW5nIG9wZXJhdG9ycyBpZiBvYmogaXMgYXJyYXkgcmV0dXJucyBpdHMgbGVuZ3RoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRDb21wbGV4U2l6ZShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBnZXRDb21wbGV4S2V5cyhvYmopLmxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0Q29tcGxleFNpemUgPSBnZXRDb21wbGV4U2l6ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSB3aGVyZSBjbGF1c2UgaXMgZW1wdHksIGV2ZW4gd2l0aCBTeW1ib2xzXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNXaGVyZUVtcHR5KG9iaikge1xuICByZXR1cm4gISFvYmogJiYgXy5pc0VtcHR5KG9iaikgJiYgZ2V0T3BlcmF0b3JzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc1doZXJlRW1wdHkgPSBpc1doZXJlRW1wdHk7XG5cbi8qKlxuICogUmV0dXJucyBFTlVNIG5hbWUgYnkgam9pbmluZyB0YWJsZSBhbmQgY29sdW1uIG5hbWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRW51bU5hbWUodGFibGVOYW1lLCBjb2x1bW5OYW1lKSB7XG4gIHJldHVybiBgZW51bV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5OYW1lfWA7XG59XG5leHBvcnRzLmdlbmVyYXRlRW51bU5hbWUgPSBnZW5lcmF0ZUVudW1OYW1lO1xuXG4vKipcbiAqIFJldHVybnMgYW4gbmV3IE9iamVjdCB3aGljaCBrZXlzIGFyZSBjYW1lbGl6ZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVPYmplY3RLZXlzKG9iaikge1xuICBjb25zdCBuZXdPYmogPSBuZXcgT2JqZWN0KCk7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgIG5ld09ialtjYW1lbGl6ZShrZXkpXSA9IG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmV4cG9ydHMuY2FtZWxpemVPYmplY3RLZXlzID0gY2FtZWxpemVPYmplY3RLZXlzO1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcgYW5kIHN5bWJvbCBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzLzQuMTcuNCNkZWZhdWx0c1xuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4ub2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRzKG9iamVjdCwgLi4uc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBzb3VyY2UgPSBPYmplY3Qoc291cmNlKTtcblxuICAgICAgZ2V0Q29tcGxleEtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBfLmVxKHZhbHVlLCBPYmplY3QucHJvdG90eXBlW2tleV0pICYmXG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KVxuXG4gICAgICAgICkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5fSAgaW5kZXguZmllbGRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2luZGV4Lm5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRhYmxlTmFtZVxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuYW1lSW5kZXgoaW5kZXgsIHRhYmxlTmFtZSkge1xuICBpZiAodGFibGVOYW1lLnRhYmxlTmFtZSkgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmRleCwgJ25hbWUnKSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGluZGV4LmZpZWxkcy5tYXAoXG4gICAgICBmaWVsZCA9PiB0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnID8gZmllbGQgOiBmaWVsZC5uYW1lIHx8IGZpZWxkLmF0dHJpYnV0ZVxuICAgICk7XG4gICAgaW5kZXgubmFtZSA9IHVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2ZpZWxkcy5qb2luKCdfJyl9YCk7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnRzLm5hbWVJbmRleCA9IG5hbWVJbmRleDtcblxuLyoqXG4gKiBDaGVja3MgaWYgMiBhcnJheXMgaW50ZXJzZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycjFcbiAqIEBwYXJhbSB7QXJyYXl9IGFycjJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdHMoYXJyMSwgYXJyMikge1xuICByZXR1cm4gYXJyMS5zb21lKHYgPT4gYXJyMi5pbmNsdWRlcyh2KSk7XG59XG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgdG8gbm90IG5lZWQgdGhlIGBuZXdgIGtleXdvcmQgdXNpbmcgYSBwcm94eS5cbiAqIE9ubHkgdXNlZCBmb3IgZGF0YSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDbGFzcyBUaGUgY2xhc3MgaW5zdGFuY2UgdG8gd3JhcCBhcyBpbnZvY2FibGUuXG4gKiBAcmV0dXJucyB7UHJveHl9IFdyYXBwZWQgY2xhc3MgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGFzc1RvSW52b2thYmxlKENsYXNzKSB7XG4gIHJldHVybiBuZXcgUHJveHkoQ2xhc3MsIHtcbiAgICBhcHBseShUYXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgVGFyZ2V0KC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgY29uc3RydWN0KFRhcmdldCwgYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W3BdO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLmNsYXNzVG9JbnZva2FibGUgPSBjbGFzc1RvSW52b2thYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGRlcHJlY2F0ZSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmV4cG9ydHMubm9SYXdBdHRyaWJ1dGVzID0gZGVwcmVjYXRlKG5vb3AsICdVc2Ugc2VxdWVsaXplLmZuIC8gc2VxdWVsaXplLmxpdGVyYWwgdG8gY29uc3RydWN0IGF0dHJpYnV0ZXMnLCAnU0VRVUVMSVpFMDAwMScpO1xuZXhwb3J0cy5ub1RydWVMb2dnaW5nID0gZGVwcmVjYXRlKG5vb3AsICdUaGUgbG9nZ2luZy1vcHRpb24gc2hvdWxkIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGZhbHNlLiBEZWZhdWx0OiBjb25zb2xlLmxvZycsICdTRVFVRUxJWkUwMDAyJyk7XG5leHBvcnRzLm5vU3RyaW5nT3BlcmF0b3JzID0gZGVwcmVjYXRlKG5vb3AsICdTdHJpbmcgYmFzZWQgb3BlcmF0b3JzIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFN5bWJvbCBiYXNlZCBvcGVyYXRvcnMgZm9yIGJldHRlciBzZWN1cml0eSwgcmVhZCBtb3JlIGF0IGh0dHBzOi8vc2VxdWVsaXplLm9yZy9tYXN0ZXIvbWFudWFsL3F1ZXJ5aW5nLmh0bWwjb3BlcmF0b3JzJywgJ1NFUVVFTElaRTAwMDMnKTtcbmV4cG9ydHMubm9Cb29sT3BlcmF0b3JBbGlhc2VzID0gZGVwcmVjYXRlKG5vb3AsICdBIGJvb2xlYW4gdmFsdWUgd2FzIHBhc3NlZCB0byBvcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMuIFRoaXMgaXMgYSBuby1vcCB3aXRoIHY1IGFuZCBzaG91bGQgYmUgcmVtb3ZlZC4nLCAnU0VRVUVMSVpFMDAwNCcpO1xuZXhwb3J0cy5ub0RvdWJsZU5lc3RlZEdyb3VwID0gZGVwcmVjYXRlKG5vb3AsICdQYXNzaW5nIGEgZG91YmxlIG5lc3RlZCBuZXN0ZWQgYXJyYXkgdG8gYGdyb3VwYCBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY2LicsICdTRVFVRUxJWkUwMDA1Jyk7XG5leHBvcnRzLnVuc3VwcG9ydGVkRW5naW5lID0gZGVwcmVjYXRlKG5vb3AsICdUaGlzIGRhdGFiYXNlIGVuZ2luZSB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSB1cGRhdGUgeW91ciBkYXRhYmFzZSBzZXJ2ZXIuIE1vcmUgaW5mb3JtYXRpb24gaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvYmxvYi9tYWluL0VOR0lORS5tZCcsICdTRVFVRUxJWkUwMDA2Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRvZXNOb3RXYW50TGVhZGluZ1NwYWNlKHN0cikge1xuICByZXR1cm4gL15bOywpXS8udGVzdChzdHIpO1xufVxuZnVuY3Rpb24gZG9lc05vdFdhbnRUcmFpbGluZ1NwYWNlKHN0cikge1xuICByZXR1cm4gL1xcKCQvLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBKb2lucyBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggYSBzaW5nbGUgc3BhY2UgYmV0d2VlbiB0aGVtLFxuICogZXhjZXB0IGZvcjpcbiAqIFxuICogLSBTdHJpbmdzIHN0YXJ0aW5nIHdpdGggJzsnLCAnLCcgYW5kICcpJywgd2hpY2ggZG8gbm90IGdldCBhIGxlYWRpbmcgc3BhY2UuXG4gKiAtIFN0cmluZ3MgZW5kaW5nIHdpdGggJygnLCB3aGljaCBkbyBub3QgZ2V0IGEgdHJhaWxpbmcgc3BhY2UuXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhcnRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3BhY2VKb2luSGVscGVyKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5yZWR1Y2UoKHsgc2tpcE5leHRMZWFkaW5nU3BhY2UsIHJlc3VsdCB9LCBwYXJ0KSA9PiB7XG4gICAgaWYgKHNraXBOZXh0TGVhZGluZ1NwYWNlIHx8IGRvZXNOb3RXYW50TGVhZGluZ1NwYWNlKHBhcnQpKSB7XG4gICAgICByZXN1bHQgKz0gcGFydC50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBgICR7cGFydC50cmltKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNraXBOZXh0TGVhZGluZ1NwYWNlOiBkb2VzTm90V2FudFRyYWlsaW5nU3BhY2UocGFydCksXG4gICAgICByZXN1bHRcbiAgICB9O1xuICB9LCB7XG4gICAgc2tpcE5leHRMZWFkaW5nU3BhY2U6IHRydWUsXG4gICAgcmVzdWx0OiAnJ1xuICB9KS5yZXN1bHQ7XG59XG5cbi8qKlxuICogSm9pbnMgYW4gYXJyYXkgd2l0aCBhIHNpbmdsZSBzcGFjZSwgYXV0byB0cmltbWluZyB3aGVuIG5lZWRlZC5cbiAqIFxuICogQ2VydGFpbiBlbGVtZW50cyBkbyBub3QgZ2V0IGxlYWRpbmcvdHJhaWxpbmcgc3BhY2VzLlxuICogXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgam9pbmVkLiBGYWxzeSB2YWx1ZXMgYXJlIHNraXBwZWQuIElmIGFuXG4gKiBlbGVtZW50IGlzIGFub3RoZXIgYXJyYXksIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgb24gdGhhdCBhcnJheS5cbiAqIE90aGVyd2lzZSwgaWYgYSBub24tc3RyaW5nLCBub24tZmFsc3kgdmFsdWUgaXMgcHJlc2VudCwgYSBUeXBlRXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKiBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBqb2luZWQgc3RyaW5nLlxuICogXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBqb2luU1FMRnJhZ21lbnRzKGFycmF5KSB7XG4gIGlmIChhcnJheS5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICAvLyBTa2lwIGZhbHN5IGZyYWdtZW50c1xuICBhcnJheSA9IGFycmF5LmZpbHRlcih4ID0+IHgpO1xuXG4gIC8vIFJlc29sdmUgcmVjdXJzaXZlIGNhbGxzXG4gIGFycmF5ID0gYXJyYXkubWFwKGZyYWdtZW50ID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFnbWVudCkpIHtcbiAgICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKGZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9KTtcblxuICAvLyBFbnN1cmUgc3RyaW5nc1xuICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIGFycmF5KSB7XG4gICAgaWYgKGZyYWdtZW50ICYmIHR5cGVvZiBmcmFnbWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgVHJpZWQgdG8gY29uc3RydWN0IGEgU1FMIHN0cmluZyB3aXRoIGEgbm9uLXN0cmluZywgbm9uLWZhbHN5IGZyYWdtZW50ICgke2ZyYWdtZW50fSkuYCk7XG4gICAgICBlcnJvci5hcmdzID0gYXJyYXk7XG4gICAgICBlcnJvci5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpbSBmcmFnbWVudHNcbiAgYXJyYXkgPSBhcnJheS5tYXAoeCA9PiB4LnRyaW0oKSk7XG5cbiAgLy8gU2tpcCBmdWxsLXdoaXRlc3BhY2UgZnJhZ21lbnRzIChlbXB0eSBhZnRlciB0aGUgYWJvdmUgdHJpbSlcbiAgYXJyYXkgPSBhcnJheS5maWx0ZXIoeCA9PiB4ICE9PSAnJyk7XG5cbiAgcmV0dXJuIHNpbmdsZVNwYWNlSm9pbkhlbHBlcihhcnJheSk7XG59XG5leHBvcnRzLmpvaW5TUUxGcmFnbWVudHMgPSBqb2luU1FMRnJhZ21lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNlcXVlbGl6ZSBtb2R1bGUgZm9yIGRlYnVnIGFuZCBkZXByZWNhdGlvbiBtZXNzYWdlcy5cbiAqIEl0IHJlcXVpcmUgYSBgY29udGV4dGAgZm9yIHdoaWNoIG1lc3NhZ2VzIHdpbGwgYmUgcHJpbnRlZC5cbiAqXG4gKiBAbW9kdWxlIGxvZ2dpbmdcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGNvbnRleHQ6ICdzZXF1ZWxpemUnLFxuICAgICAgZGVidWc6IHRydWUsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG5cbiAgd2FybihtZXNzYWdlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oYCgke3RoaXMuY29uZmlnLmNvbnRleHR9KSBXYXJuaW5nOiAke21lc3NhZ2V9YCk7XG4gIH1cblxuICBpbnNwZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2YWx1ZSwgZmFsc2UsIDMpO1xuICB9XG5cbiAgZGVidWdDb250ZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gZGVidWcoYCR7dGhpcy5jb25maWcuY29udGV4dH06JHtuYW1lfWApO1xuICB9XG59XG5cbmV4cG9ydHMubG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgdmFsaWRhdG9yID0gXy5jbG9uZURlZXAocmVxdWlyZSgndmFsaWRhdG9yJykpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIGV4dGVuZChuYW1lLCBmbikge1xuICAgIHRoaXNbbmFtZV0gPSBmbjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBub3RFbXB0eShzdHIpIHtcbiAgICByZXR1cm4gIXN0ci5tYXRjaCgvXltcXHNcXHRcXHJcXG5dKiQvKTtcbiAgfSxcbiAgbGVuKHN0ciwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlbmd0aChzdHIsIG1pbiwgbWF4KTtcbiAgfSxcbiAgaXNVcmwoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNVUkwoc3RyKTtcbiAgfSxcbiAgaXNJUHY2KHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzSVAoc3RyLCA2KTtcbiAgfSxcbiAgaXNJUHY0KHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzSVAoc3RyLCA0KTtcbiAgfSxcbiAgbm90SW4oc3RyLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNJbihzdHIsIHZhbHVlcyk7XG4gIH0sXG4gIHJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgc3RyICs9ICcnO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF0dGVybikuc2xpY2UoOCwgLTEpICE9PSAnUmVnRXhwJykge1xuICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5tYXRjaChwYXR0ZXJuKTtcbiAgfSxcbiAgbm90UmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gIXRoaXMucmVnZXgoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9LFxuICBpc0RlY2ltYWwoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciAhPT0gJycgJiYgISFzdHIubWF0Y2goL14oPzotPyg/OlswLTldKykpPyg/OlxcLlswLTldKik/KD86W2VFXVsrLV0/KD86WzAtOV0rKSk/JC8pO1xuICB9LFxuICBtaW4oc3RyLCB2YWwpIHtcbiAgICBjb25zdCBudW1iZXIgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgcmV0dXJuIGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID49IHZhbDtcbiAgfSxcbiAgbWF4KHN0ciwgdmFsKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiBpc05hTihudW1iZXIpIHx8IG51bWJlciA8PSB2YWw7XG4gIH0sXG4gIG5vdChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiB0aGlzLm5vdFJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfSxcbiAgY29udGFpbnMoc3RyLCBlbGVtKSB7XG4gICAgcmV0dXJuICEhZWxlbSAmJiBzdHIuaW5jbHVkZXMoZWxlbSk7XG4gIH0sXG4gIG5vdENvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAgIHJldHVybiAhdGhpcy5jb250YWlucyhzdHIsIGVsZW0pO1xuICB9LFxuICBpcyhzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfVxufTtcbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cbi8vIGluc3RhbmNlIGJhc2VkIHZhbGlkYXRvcnNcbnZhbGlkYXRvci5pc0ltbXV0YWJsZSA9IGZ1bmN0aW9uKHZhbHVlLCB2YWxpZGF0b3JBcmdzLCBmaWVsZCwgbW9kZWxJbnN0YW5jZSkge1xuICByZXR1cm4gbW9kZWxJbnN0YW5jZS5pc05ld1JlY29yZCB8fCBtb2RlbEluc3RhbmNlLmRhdGFWYWx1ZXNbZmllbGRdID09PSBtb2RlbEluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbZmllbGRdO1xufTtcblxuLy8gZXh0cmEgdmFsaWRhdG9yc1xudmFsaWRhdG9yLm5vdE51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzL2Jsb2IvNi4yLjAvdmFsaWRhdG9yLmpzXG5fLmZvckVhY2goZXh0ZW5zaW9ucywgKGV4dGVuZCwga2V5KSA9PiB7XG4gIHZhbGlkYXRvcltrZXldID0gZXh0ZW5kO1xufSk7XG5cbi8vIG1hcCBpc051bGwgdG8gaXNFbXB0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvY29tbWl0L2UzM2QzOGEyNmVlMmY5NjY2YjMxOWFkYjY3YzdmYzBkM2RlYTcxMjVcbnZhbGlkYXRvci5pc051bGwgPSB2YWxpZGF0b3IuaXNFbXB0eTtcblxuLy8gaXNEYXRlIHJlbW92ZWQgaW4gNy4wLjBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzL2NvbW1pdC8wOTU1MDlmYzcwN2E0ZGMwZTk5Zjg1MTMxZGYxMTc2YWQ2Mzg5ZmM5XG52YWxpZGF0b3IuaXNEYXRlID0gZnVuY3Rpb24oZGF0ZVN0cmluZykge1xuICAvLyBhdm9pZCBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvXG4gIC8vIGJ5IGRvaW5nIGEgcHJlbGltaW5hcnkgY2hlY2sgb24gYGRhdGVTdHJpbmdgXG4gIGNvbnN0IHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cmluZyk7XG4gIGlmIChpc05hTihwYXJzZWQpKSB7XG4gICAgLy8gZmFpbCBpZiB3ZSBjYW4ndCBwYXJzZSBpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBvdGhlcndpc2UgY29udmVydCB0byBJU08gODYwMSBhcyBtb21lbnQgcHJlZmVyc1xuICAvLyBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy9cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHBhcnNlZCk7XG4gIHJldHVybiBtb21lbnQoZGF0ZS50b0lTT1N0cmluZygpKS5pc1ZhbGlkKCk7XG59O1xuXG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiIsIi8qKioqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgR3VzdGF2byBIZW5rZSBhbmQgQWFyb24gVHJlbnRcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqKioqL1xuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG4gICAgaWYoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIFwiVG9wb3NvcnRcIiwgW1wiZXhwb3J0c1wiLCBcIm1vZHVsZVwiXSwgZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiggdHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgZmFjdG9yeSggZXhwb3J0cywgbW9kdWxlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1vZCA9IHtcbiAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZhY3RvcnkoIG1vZC5leHBvcnRzLCBtb2QgKTtcbiAgICAgICAgZ2xvYmFsLlRvcG9zb3J0ID0gbW9kLmV4cG9ydHM7XG4gICAgfVxufSkoIHRoaXMsIGZ1bmN0aW9uKCBleHBvcnRzLCBtb2R1bGUgKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soIGluc3RhbmNlLCBDb25zdHJ1Y3RvciApIHtcbiAgICAgICAgaWYoICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCBcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgVG9wb3NvcnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRvcG9zb3J0KCkge1xuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKCB0aGlzLCBUb3Bvc29ydCApO1xuXG4gICAgICAgICAgICB0aGlzLmVkZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLlRvcG9zb3J0ID0gVG9wb3NvcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBkZXBlbmRlbmN5IGVkZ2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2luY2UgICAwLjEuMFxuICAgICAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSBpdGVtICAgICAgICAgICAgICAgQW4gZGVwZW5kZW50IG5hbWUuIE11c3QgYmUgYW4gc3RyaW5nIGFuZCBub3QgZW1wdHlcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ1tdfFN0cmluZ30gW2RlcHNdICAgIEFuIGRlcGVuZGVuY3kgb3IgYXJyYXkgb2YgZGVwZW5kZW5jaWVzXG4gICAgICAgICAqIEByZXR1cm5zIHtUb3Bvc29ydH0gICAgICAgICAgICAgICAgICBUaGUgVG9wb3NvcnQgaW5zdGFuY2VcbiAgICAgICAgICovXG5cbiAgICAgICAgVG9wb3NvcnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCggaXRlbSwgZGVwcyApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIiB8fCAhaXRlbSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCBcIkRlcGVuZGVudCBuYW1lIG11c3QgYmUgZ2l2ZW4gYXMgYSBub3QgZW1wdHkgc3RyaW5nXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVwcyA9IEFycmF5LmlzQXJyYXkoIGRlcHMgKSA/IGRlcHMgOiBbZGVwc107XG5cbiAgICAgICAgICAgIGlmKCBkZXBzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yID0gZGVwcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3IgKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIF9pc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pID49IF9pdGVyYXRvci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pLmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwID0gX3JlZjtcblxuICAgICAgICAgICAgICAgICAgICBpZiggdHlwZW9mIGRlcCAhPT0gXCJzdHJpbmdcIiB8fCAhZGVwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJEZXBlbmRlbmN5IG5hbWUgbXVzdCBiZSBnaXZlbiBhcyBhIG5vdCBlbXB0eSBzdHJpbmdcIiApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKCBbaXRlbSwgZGVwXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKCBbaXRlbV0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgdGhlIHRvcG9zb3J0aW5nIGFuZCByZXR1cm4gYW4gb3JkZXJlZCBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzaW5jZSAgIDAuMS4wXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gIFRoZSBsaXN0IG9mIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkLlxuICAgICAgICAgKi9cblxuICAgICAgICBUb3Bvc29ydC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgLy9hY2N1bXVsYXRlIHVuaXF1ZSBub2RlcyBpbnRvIGEgbGFyZ2UgbGlzdFxuICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuZWRnZXMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjIgKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgICAgICAgICAgaWYoIF9pc0FycmF5MiApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaTIuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gX3JlZjI7XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBfaXRlcmF0b3IzID0gZWRnZSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yMyApLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIF9pc0FycmF5MyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2kzLmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3JlZjM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIG5vZGVzLmluZGV4T2YoIG5vZGUgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKCBub2RlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgcGxhY2VtZW50IG9mIG5vZGVzIGludG8gdGhlIHNvcnRlZCBhcnJheSBhdCB0aGUgZW5kXG4gICAgICAgICAgICB2YXIgcGxhY2UgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgc29ydGVkIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSB1bmlxdWUgbm9kZXMgYXJyYXlcbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBuZXcgQXJyYXkoIG5vZGVzLmxlbmd0aCApO1xuXG4gICAgICAgICAgICAvL2RlZmluZSBhIHZpc2l0b3IgZnVuY3Rpb24gdGhhdCByZWN1cnNpdmVseSB0cmF2ZXJzZXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gdmlzaXQoIG5vZGUsIHByZWRlY2Vzc29ycyApIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGEgbm9kZSBpcyBkZXBlbmRlbnQgb2YgaXRzZWxmXG4gICAgICAgICAgICAgICAgaWYoIHByZWRlY2Vzc29ycy5sZW5ndGggIT09IDAgJiYgcHJlZGVjZXNzb3JzLmluZGV4T2YoIG5vZGUgKSAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJDeWNsaWMgZGVwZW5kZW5jeSBmb3VuZC4gXCIgKyBub2RlICsgXCIgaXMgZGVwZW5kZW50IG9mIGl0c2VsZi5cXG5EZXBlbmRlbmN5IGNoYWluOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgcHJlZGVjZXNzb3JzLmpvaW4oIFwiIC0+IFwiICkgKyBcIiA9PiBcIiArIG5vZGUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBub2Rlcy5pbmRleE9mKCBub2RlICk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBub2RlIHN0aWxsIGV4aXN0cywgdHJhdmVyc2UgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgIGlmKCBpbmRleCAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9tYXJrIHRoZSBub2RlIGFzIGZhbHNlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBmdXR1cmUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpbmRleF0gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgZWRnZXMgYW5kIGZvbGxvdyBkZXBlbmRlbmNpZXMgb2YgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBmb3IoIHZhciBfaXRlcmF0b3I0ID0gX3RoaXMuZWRnZXMsIF9pc0FycmF5NCA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjQgKSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNCA9IF9pdGVyYXRvcjQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTQuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF9yZWY0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggZWRnZVswXSA9PT0gbm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xhemlseSBjcmVhdGUgYSBjb3B5IG9mIHByZWRlY2Vzc29ycyB3aXRoIHRoZSBjdXJyZW50IG5vZGUgY29uY2F0ZW5hdGVkIG9udG8gaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gY29weSB8fCBwcmVkZWNlc3NvcnMuY29uY2F0KCBbbm9kZV0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVjdXJzZSB0byBub2RlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0KCBlZGdlWzFdLCBjb3B5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgbm9kZSB0byB0aGUgbmV4dCBwbGFjZSBpbiB0aGUgc29ydGVkIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFstLXBsYWNlXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy9pZ25vcmUgbm9kZXMgdGhhdCBoYXZlIGJlZW4gZXhjbHVkZWRcbiAgICAgICAgICAgICAgICBpZiggbm9kZSAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgbm9kZSBhcyBmYWxzZSB0byBleGNsdWRlIGl0IGZyb20gZnV0dXJlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgZWRnZXMgYW5kIGZvbGxvdyBkZXBlbmRlbmNpZXMgb2YgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBmb3IoIHZhciBfaXRlcmF0b3I1ID0gdGhpcy5lZGdlcywgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yNSApLCBfaTUgPSAwLCBfaXRlcmF0b3I1ID0gX2lzQXJyYXk1ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pNSA+PSBfaXRlcmF0b3I1Lmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yNVtfaTUrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNSA9IF9pdGVyYXRvcjUubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTUuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2k1LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF9yZWY1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggZWRnZVswXSA9PT0gbm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlY3Vyc2UgdG8gbm9kZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdCggZWRnZVsxXSwgW25vZGVdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgbm9kZSB0byB0aGUgbmV4dCBwbGFjZSBpbiB0aGUgc29ydGVkIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFstLXBsYWNlXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgZWRnZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHNpbmNlICAgMC40LjBcbiAgICAgICAgICogQHJldHVybnMge1RvcG9zb3J0fSAgICAgICAgICAgICAgICAgIFRoZSBUb3Bvc29ydCBpbnN0YW5jZVxuICAgICAgICAgKi9cblxuICAgICAgICBUb3Bvc29ydC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFRvcG9zb3J0O1xuICAgIH0pKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcG9zb3J0O1xufSApO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi9idWlsZC90b3Bvc29ydC5qcycgKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5pdCA9IGV4cG9ydHMuc2VxdWVsaXplID0gdm9pZCAwO1xudmFyIHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEgPSByZXF1aXJlKFwic2VxdWVsaXplLXR5cGVzY3JpcHRcIik7XG52YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuc2VxdWVsaXplID0gbmV3IHNlcXVlbGl6ZV90eXBlc2NyaXB0XzEuU2VxdWVsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiBbX19kaXJuYW1lICsgJy9kYXRhYmFzZS9tb2RlbHMvKiovKi5tb2RlbC50cyddLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE1hdGNoOiBmdW5jdGlvbiAoZmlsZW5hbWUsIG1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnN1YnN0cmluZygwLCBmaWxlbmFtZS5pbmRleE9mKCcubW9kZWwnKSkgPT09IG1lbWJlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBob3N0OiBcImxvY2FsaG9zdFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZTogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICBkaWFsZWN0OiAnbXlzcWwnLFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGV4cG9ydHMuc2VxdWVsaXplLmF1dGhlbnRpY2F0ZSgpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJEQiBDb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBjb25uZWN0IHRvIERCXCIsIGVfMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmluaXQgPSBpbml0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwb2xsb19zZXJ2ZXJfMSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyXCIpO1xudmFyIGluZGV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHlwZURlZnMvaW5kZXhcIikpO1xudmFyIGluZGV4XzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzb2x2ZXJzL2luZGV4XCIpKTtcbnZhciBzZXF1YWxpemVfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3Mvc2VxdWFsaXplXCIpO1xudmFyIHNlcnZlciA9IG5ldyBhcG9sbG9fc2VydmVyXzEuQXBvbGxvU2VydmVyKHsgdHlwZURlZnM6IGluZGV4XzEuZGVmYXVsdCwgcmVzb2x2ZXJzOiBpbmRleF8yLmRlZmF1bHQgfSk7XG5zZXJ2ZXIubGlzdGVuKClcbiAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZlciByZWFkeSBhdCBcIiArIHVybCArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBzZXF1YWxpemVfMS5pbml0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdG9EYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9EYXRlXCIpKTtcblxudmFyIF90b0Zsb2F0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9GbG9hdFwiKSk7XG5cbnZhciBfdG9JbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90b0ludFwiKSk7XG5cbnZhciBfdG9Cb29sZWFuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdG9Cb29sZWFuXCIpKTtcblxudmFyIF9lcXVhbHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9lcXVhbHNcIikpO1xuXG52YXIgX2NvbnRhaW5zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvY29udGFpbnNcIikpO1xuXG52YXIgX21hdGNoZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9tYXRjaGVzXCIpKTtcblxudmFyIF9pc0VtYWlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNFbWFpbFwiKSk7XG5cbnZhciBfaXNVUkwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1VSTFwiKSk7XG5cbnZhciBfaXNNQUNBZGRyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNQUNBZGRyZXNzXCIpKTtcblxudmFyIF9pc0lQID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJUFwiKSk7XG5cbnZhciBfaXNJUFJhbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJUFJhbmdlXCIpKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0ZRRE5cIikpO1xuXG52YXIgX2lzQm9vbGVhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQm9vbGVhblwiKSk7XG5cbnZhciBfaXNBbHBoYSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0FscGhhXCIpKTtcblxudmFyIF9pc0FscGhhbnVtZXJpYyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0FscGhhbnVtZXJpY1wiKSk7XG5cbnZhciBfaXNOdW1lcmljID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNOdW1lcmljXCIpKTtcblxudmFyIF9pc1BvcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1BvcnRcIikpO1xuXG52YXIgX2lzTG93ZXJjYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMb3dlcmNhc2VcIikpO1xuXG52YXIgX2lzVXBwZXJjYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNVcHBlcmNhc2VcIikpO1xuXG52YXIgX2lzQXNjaWkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0FzY2lpXCIpKTtcblxudmFyIF9pc0Z1bGxXaWR0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRnVsbFdpZHRoXCIpKTtcblxudmFyIF9pc0hhbGZXaWR0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSGFsZldpZHRoXCIpKTtcblxudmFyIF9pc1ZhcmlhYmxlV2lkdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1ZhcmlhYmxlV2lkdGhcIikpO1xuXG52YXIgX2lzTXVsdGlieXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNdWx0aWJ5dGVcIikpO1xuXG52YXIgX2lzU3Vycm9nYXRlUGFpciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzU3Vycm9nYXRlUGFpclwiKSk7XG5cbnZhciBfaXNJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0ludFwiKSk7XG5cbnZhciBfaXNGbG9hdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9pc0Zsb2F0XCIpKTtcblxudmFyIF9pc0RlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0RlY2ltYWxcIikpO1xuXG52YXIgX2lzSGV4YWRlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hleGFkZWNpbWFsXCIpKTtcblxudmFyIF9pc0RpdmlzaWJsZUJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNEaXZpc2libGVCeVwiKSk7XG5cbnZhciBfaXNIZXhDb2xvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSGV4Q29sb3JcIikpO1xuXG52YXIgX2lzSVNSQyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNSQ1wiKSk7XG5cbnZhciBfaXNNRCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTUQ1XCIpKTtcblxudmFyIF9pc0hhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0hhc2hcIikpO1xuXG52YXIgX2lzSldUID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNKV1RcIikpO1xuXG52YXIgX2lzSlNPTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSlNPTlwiKSk7XG5cbnZhciBfaXNFbXB0eSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzRW1wdHlcIikpO1xuXG52YXIgX2lzTGVuZ3RoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMZW5ndGhcIikpO1xuXG52YXIgX2lzQnl0ZUxlbmd0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQnl0ZUxlbmd0aFwiKSk7XG5cbnZhciBfaXNVVUlEID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNVVUlEXCIpKTtcblxudmFyIF9pc01vbmdvSWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc01vbmdvSWRcIikpO1xuXG52YXIgX2lzQWZ0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0FmdGVyXCIpKTtcblxudmFyIF9pc0JlZm9yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzQmVmb3JlXCIpKTtcblxudmFyIF9pc0luID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJblwiKSk7XG5cbnZhciBfaXNDcmVkaXRDYXJkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNDcmVkaXRDYXJkXCIpKTtcblxudmFyIF9pc0lkZW50aXR5Q2FyZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSWRlbnRpdHlDYXJkXCIpKTtcblxudmFyIF9pc0lTSU4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTSU5cIikpO1xuXG52YXIgX2lzSVNCTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNCTlwiKSk7XG5cbnZhciBfaXNJU1NOID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNJU1NOXCIpKTtcblxudmFyIF9pc01vYmlsZVBob25lID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbGliL2lzTW9iaWxlUGhvbmVcIikpO1xuXG52YXIgX2lzQ3VycmVuY3kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0N1cnJlbmN5XCIpKTtcblxudmFyIF9pc0lTTyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNPODYwMVwiKSk7XG5cbnZhciBfaXNSRkMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc1JGQzMzMzlcIikpO1xuXG52YXIgX2lzSVNPMzE2NjFBbHBoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzSVNPMzE2NjFBbHBoYTJcIikpO1xuXG52YXIgX2lzSVNPMzE2NjFBbHBoYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0lTTzMxNjYxQWxwaGEzXCIpKTtcblxudmFyIF9pc0Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9pc0Jhc2U2NFwiKSk7XG5cbnZhciBfaXNEYXRhVVJJID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNEYXRhVVJJXCIpKTtcblxudmFyIF9pc01hZ25ldFVSSSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzTWFnbmV0VVJJXCIpKTtcblxudmFyIF9pc01pbWVUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNNaW1lVHlwZVwiKSk7XG5cbnZhciBfaXNMYXRMb25nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvaXNMYXRMb25nXCIpKTtcblxudmFyIF9pc1Bvc3RhbENvZGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvaXNQb3N0YWxDb2RlXCIpKTtcblxudmFyIF9sdHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2x0cmltXCIpKTtcblxudmFyIF9ydHJpbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3J0cmltXCIpKTtcblxudmFyIF90cmltID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdHJpbVwiKSk7XG5cbnZhciBfZXNjYXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvZXNjYXBlXCIpKTtcblxudmFyIF91bmVzY2FwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3VuZXNjYXBlXCIpKTtcblxudmFyIF9zdHJpcExvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3N0cmlwTG93XCIpKTtcblxudmFyIF93aGl0ZWxpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93aGl0ZWxpc3RcIikpO1xuXG52YXIgX2JsYWNrbGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2JsYWNrbGlzdFwiKSk7XG5cbnZhciBfaXNXaGl0ZWxpc3RlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2lzV2hpdGVsaXN0ZWRcIikpO1xuXG52YXIgX25vcm1hbGl6ZUVtYWlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvbm9ybWFsaXplRW1haWxcIikpO1xuXG52YXIgX3RvU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdXRpbC90b1N0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZlcnNpb24gPSAnMTAuMTEuMCc7XG52YXIgdmFsaWRhdG9yID0ge1xuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB0b0RhdGU6IF90b0RhdGUuZGVmYXVsdCxcbiAgdG9GbG9hdDogX3RvRmxvYXQuZGVmYXVsdCxcbiAgdG9JbnQ6IF90b0ludC5kZWZhdWx0LFxuICB0b0Jvb2xlYW46IF90b0Jvb2xlYW4uZGVmYXVsdCxcbiAgZXF1YWxzOiBfZXF1YWxzLmRlZmF1bHQsXG4gIGNvbnRhaW5zOiBfY29udGFpbnMuZGVmYXVsdCxcbiAgbWF0Y2hlczogX21hdGNoZXMuZGVmYXVsdCxcbiAgaXNFbWFpbDogX2lzRW1haWwuZGVmYXVsdCxcbiAgaXNVUkw6IF9pc1VSTC5kZWZhdWx0LFxuICBpc01BQ0FkZHJlc3M6IF9pc01BQ0FkZHJlc3MuZGVmYXVsdCxcbiAgaXNJUDogX2lzSVAuZGVmYXVsdCxcbiAgaXNJUFJhbmdlOiBfaXNJUFJhbmdlLmRlZmF1bHQsXG4gIGlzRlFETjogX2lzRlFETi5kZWZhdWx0LFxuICBpc0Jvb2xlYW46IF9pc0Jvb2xlYW4uZGVmYXVsdCxcbiAgaXNBbHBoYTogX2lzQWxwaGEuZGVmYXVsdCxcbiAgaXNBbHBoYUxvY2FsZXM6IF9pc0FscGhhLmxvY2FsZXMsXG4gIGlzQWxwaGFudW1lcmljOiBfaXNBbHBoYW51bWVyaWMuZGVmYXVsdCxcbiAgaXNBbHBoYW51bWVyaWNMb2NhbGVzOiBfaXNBbHBoYW51bWVyaWMubG9jYWxlcyxcbiAgaXNOdW1lcmljOiBfaXNOdW1lcmljLmRlZmF1bHQsXG4gIGlzUG9ydDogX2lzUG9ydC5kZWZhdWx0LFxuICBpc0xvd2VyY2FzZTogX2lzTG93ZXJjYXNlLmRlZmF1bHQsXG4gIGlzVXBwZXJjYXNlOiBfaXNVcHBlcmNhc2UuZGVmYXVsdCxcbiAgaXNBc2NpaTogX2lzQXNjaWkuZGVmYXVsdCxcbiAgaXNGdWxsV2lkdGg6IF9pc0Z1bGxXaWR0aC5kZWZhdWx0LFxuICBpc0hhbGZXaWR0aDogX2lzSGFsZldpZHRoLmRlZmF1bHQsXG4gIGlzVmFyaWFibGVXaWR0aDogX2lzVmFyaWFibGVXaWR0aC5kZWZhdWx0LFxuICBpc011bHRpYnl0ZTogX2lzTXVsdGlieXRlLmRlZmF1bHQsXG4gIGlzU3Vycm9nYXRlUGFpcjogX2lzU3Vycm9nYXRlUGFpci5kZWZhdWx0LFxuICBpc0ludDogX2lzSW50LmRlZmF1bHQsXG4gIGlzRmxvYXQ6IF9pc0Zsb2F0LmRlZmF1bHQsXG4gIGlzRmxvYXRMb2NhbGVzOiBfaXNGbG9hdC5sb2NhbGVzLFxuICBpc0RlY2ltYWw6IF9pc0RlY2ltYWwuZGVmYXVsdCxcbiAgaXNIZXhhZGVjaW1hbDogX2lzSGV4YWRlY2ltYWwuZGVmYXVsdCxcbiAgaXNEaXZpc2libGVCeTogX2lzRGl2aXNpYmxlQnkuZGVmYXVsdCxcbiAgaXNIZXhDb2xvcjogX2lzSGV4Q29sb3IuZGVmYXVsdCxcbiAgaXNJU1JDOiBfaXNJU1JDLmRlZmF1bHQsXG4gIGlzTUQ1OiBfaXNNRC5kZWZhdWx0LFxuICBpc0hhc2g6IF9pc0hhc2guZGVmYXVsdCxcbiAgaXNKV1Q6IF9pc0pXVC5kZWZhdWx0LFxuICBpc0pTT046IF9pc0pTT04uZGVmYXVsdCxcbiAgaXNFbXB0eTogX2lzRW1wdHkuZGVmYXVsdCxcbiAgaXNMZW5ndGg6IF9pc0xlbmd0aC5kZWZhdWx0LFxuICBpc0J5dGVMZW5ndGg6IF9pc0J5dGVMZW5ndGguZGVmYXVsdCxcbiAgaXNVVUlEOiBfaXNVVUlELmRlZmF1bHQsXG4gIGlzTW9uZ29JZDogX2lzTW9uZ29JZC5kZWZhdWx0LFxuICBpc0FmdGVyOiBfaXNBZnRlci5kZWZhdWx0LFxuICBpc0JlZm9yZTogX2lzQmVmb3JlLmRlZmF1bHQsXG4gIGlzSW46IF9pc0luLmRlZmF1bHQsXG4gIGlzQ3JlZGl0Q2FyZDogX2lzQ3JlZGl0Q2FyZC5kZWZhdWx0LFxuICBpc0lkZW50aXR5Q2FyZDogX2lzSWRlbnRpdHlDYXJkLmRlZmF1bHQsXG4gIGlzSVNJTjogX2lzSVNJTi5kZWZhdWx0LFxuICBpc0lTQk46IF9pc0lTQk4uZGVmYXVsdCxcbiAgaXNJU1NOOiBfaXNJU1NOLmRlZmF1bHQsXG4gIGlzTW9iaWxlUGhvbmU6IF9pc01vYmlsZVBob25lLmRlZmF1bHQsXG4gIGlzTW9iaWxlUGhvbmVMb2NhbGVzOiBfaXNNb2JpbGVQaG9uZS5sb2NhbGVzLFxuICBpc1Bvc3RhbENvZGU6IF9pc1Bvc3RhbENvZGUuZGVmYXVsdCxcbiAgaXNQb3N0YWxDb2RlTG9jYWxlczogX2lzUG9zdGFsQ29kZS5sb2NhbGVzLFxuICBpc0N1cnJlbmN5OiBfaXNDdXJyZW5jeS5kZWZhdWx0LFxuICBpc0lTTzg2MDE6IF9pc0lTTy5kZWZhdWx0LFxuICBpc1JGQzMzMzk6IF9pc1JGQy5kZWZhdWx0LFxuICBpc0lTTzMxNjYxQWxwaGEyOiBfaXNJU08zMTY2MUFscGhhLmRlZmF1bHQsXG4gIGlzSVNPMzE2NjFBbHBoYTM6IF9pc0lTTzMxNjYxQWxwaGEyLmRlZmF1bHQsXG4gIGlzQmFzZTY0OiBfaXNCYXNlLmRlZmF1bHQsXG4gIGlzRGF0YVVSSTogX2lzRGF0YVVSSS5kZWZhdWx0LFxuICBpc01hZ25ldFVSSTogX2lzTWFnbmV0VVJJLmRlZmF1bHQsXG4gIGlzTWltZVR5cGU6IF9pc01pbWVUeXBlLmRlZmF1bHQsXG4gIGlzTGF0TG9uZzogX2lzTGF0TG9uZy5kZWZhdWx0LFxuICBsdHJpbTogX2x0cmltLmRlZmF1bHQsXG4gIHJ0cmltOiBfcnRyaW0uZGVmYXVsdCxcbiAgdHJpbTogX3RyaW0uZGVmYXVsdCxcbiAgZXNjYXBlOiBfZXNjYXBlLmRlZmF1bHQsXG4gIHVuZXNjYXBlOiBfdW5lc2NhcGUuZGVmYXVsdCxcbiAgc3RyaXBMb3c6IF9zdHJpcExvdy5kZWZhdWx0LFxuICB3aGl0ZWxpc3Q6IF93aGl0ZWxpc3QuZGVmYXVsdCxcbiAgYmxhY2tsaXN0OiBfYmxhY2tsaXN0LmRlZmF1bHQsXG4gIGlzV2hpdGVsaXN0ZWQ6IF9pc1doaXRlbGlzdGVkLmRlZmF1bHQsXG4gIG5vcm1hbGl6ZUVtYWlsOiBfbm9ybWFsaXplRW1haWwuZGVmYXVsdCxcbiAgdG9TdHJpbmc6IF90b1N0cmluZy5kZWZhdWx0XG59O1xudmFyIF9kZWZhdWx0ID0gdmFsaWRhdG9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbW1hRGVjaW1hbCA9IGV4cG9ydHMuZG90RGVjaW1hbCA9IGV4cG9ydHMuYXJhYmljTG9jYWxlcyA9IGV4cG9ydHMuZW5nbGlzaExvY2FsZXMgPSBleHBvcnRzLmRlY2ltYWwgPSBleHBvcnRzLmFscGhhbnVtZXJpYyA9IGV4cG9ydHMuYWxwaGEgPSB2b2lkIDA7XG52YXIgYWxwaGEgPSB7XG4gICdlbi1VUyc6IC9eW0EtWl0rJC9pLFxuICAnYmctQkcnOiAvXlvQkC3Qr10rJC9pLFxuICAnY3MtQ1onOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKyQvaSxcbiAgJ2RhLURLJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdkZS1ERSc6IC9eW0EtWsOEw5bDnMOfXSskL2ksXG4gICdlbC1HUic6IC9eW86RLc+JXSskL2ksXG4gICdlcy1FUyc6IC9eW0EtWsOBw4nDjcORw5PDmsOcXSskL2ksXG4gICdmci1GUic6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSskL2ksXG4gICdpdC1JVCc6IC9eW0EtWsOAw4nDiMOMw47Dk8OSw5ldKyQvaSxcbiAgJ25iLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdubC1OTCc6IC9eW0EtWsOBw4nDi8OPw5PDlsOcw5pdKyQvaSxcbiAgJ25uLU5PJzogL15bQS1aw4bDmMOFXSskL2ksXG4gICdodS1IVSc6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAncGwtUEwnOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xbldKyQvaSxcbiAgJ3B0LVBUJzogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKyQvaSxcbiAgJ3J1LVJVJzogL15b0JAt0K/QgV0rJC9pLFxuICAnc2wtU0knOiAvXltBLVrEjMSGxJDFoMW9XSskL2ksXG4gICdzay1TSyc6IC9eW0EtWsOBxIzEjsOJw43Fh8OTxaDFpMOaw53FvcS5xZTEvcOEw5RdKyQvaSxcbiAgJ3NyLVJTQGxhdGluJzogL15bQS1axIzEhsW9xaDEkF0rJC9pLFxuICAnc3ItUlMnOiAvXlvQkC3Qr9CC0IjQidCK0IvQj10rJC9pLFxuICAnc3YtU0UnOiAvXltBLVrDhcOEw5ZdKyQvaSxcbiAgJ3RyLVRSJzogL15bQS1aw4fEnsSwxLHDlsWew5xdKyQvaSxcbiAgJ3VrLVVBJzogL15b0JAt0KnQrNCu0K/QhEnQh9KQ0ZZdKyQvaSxcbiAgJ2t1LUlRJzogL15b2KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0rJC9cbn07XG5leHBvcnRzLmFscGhhID0gYWxwaGE7XG52YXIgYWxwaGFudW1lcmljID0ge1xuICAnZW4tVVMnOiAvXlswLTlBLVpdKyQvaSxcbiAgJ2JnLUJHJzogL15bMC050JAt0K9dKyQvaSxcbiAgJ2NzLUNaJzogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSskL2ksXG4gICdkYS1ESyc6IC9eWzAtOUEtWsOGw5jDhV0rJC9pLFxuICAnZGUtREUnOiAvXlswLTlBLVrDhMOWw5zDn10rJC9pLFxuICAnZWwtR1InOiAvXlswLTnOkS3PiV0rJC9pLFxuICAnZXMtRVMnOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF0rJC9pLFxuICAnZnItRlInOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0rJC9pLFxuICAnaXQtSVQnOiAvXlswLTlBLVrDgMOJw4jDjMOOw5PDksOZXSskL2ksXG4gICdodS1IVSc6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF0rJC9pLFxuICAnbmItTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ25sLU5MJzogL15bMC05QS1aw4HDicOLw4/Dk8OWw5zDml0rJC9pLFxuICAnbm4tTk8nOiAvXlswLTlBLVrDhsOYw4VdKyQvaSxcbiAgJ3BsLVBMJzogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSskL2ksXG4gICdwdC1QVCc6IC9eWzAtOUEtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSskL2ksXG4gICdydS1SVSc6IC9eWzAtOdCQLdCv0IFdKyQvaSxcbiAgJ3NsLVNJJzogL15bMC05QS1axIzEhsSQxaDFvV0rJC9pLFxuICAnc2stU0snOiAvXlswLTlBLVrDgcSMxI7DicONxYfDk8WgxaTDmsOdxb3EucWUxL3DhMOUXSskL2ksXG4gICdzci1SU0BsYXRpbic6IC9eWzAtOUEtWsSMxIbFvcWgxJBdKyQvaSxcbiAgJ3NyLVJTJzogL15bMC050JAt0K/QgtCI0InQitCL0I9dKyQvaSxcbiAgJ3N2LVNFJzogL15bMC05QS1aw4XDhMOWXSskL2ksXG4gICd0ci1UUic6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSskL2ksXG4gICd1ay1VQSc6IC9eWzAtOdCQLdCp0KzQrtCv0IRJ0IfSkNGWXSskL2ksXG4gICdrdS1JUSc6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KbYp9io2b7Yqtis2obYrdiu2K/YsdqV2LLamNiz2LTYudi62YHapNmC2qnar9mE2rXZhdmG2Yjbhtq+25XbjNuO2YrYt9ik2KvYotil2KPZg9i22LXYqdi42LBdKyQvaSxcbiAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSskL1xufTtcbmV4cG9ydHMuYWxwaGFudW1lcmljID0gYWxwaGFudW1lcmljO1xudmFyIGRlY2ltYWwgPSB7XG4gICdlbi1VUyc6ICcuJyxcbiAgYXI6ICfZqydcbn07XG5leHBvcnRzLmRlY2ltYWwgPSBkZWNpbWFsO1xudmFyIGVuZ2xpc2hMb2NhbGVzID0gWydBVScsICdHQicsICdISycsICdJTicsICdOWicsICdaQScsICdaTSddO1xuZXhwb3J0cy5lbmdsaXNoTG9jYWxlcyA9IGVuZ2xpc2hMb2NhbGVzO1xuXG5mb3IgKHZhciBsb2NhbGUsIGkgPSAwOyBpIDwgZW5nbGlzaExvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgbG9jYWxlID0gXCJlbi1cIi5jb25jYXQoZW5nbGlzaExvY2FsZXNbaV0pO1xuICBhbHBoYVtsb2NhbGVdID0gYWxwaGFbJ2VuLVVTJ107XG4gIGFscGhhbnVtZXJpY1tsb2NhbGVdID0gYWxwaGFudW1lcmljWydlbi1VUyddO1xuICBkZWNpbWFsW2xvY2FsZV0gPSBkZWNpbWFsWydlbi1VUyddO1xufSAvLyBTb3VyY2U6IGh0dHA6Ly93d3cubG9jYWxlcGxhbmV0LmNvbS9qYXZhL1xuXG5cbnZhciBhcmFiaWNMb2NhbGVzID0gWydBRScsICdCSCcsICdEWicsICdFRycsICdJUScsICdKTycsICdLVycsICdMQicsICdMWScsICdNQScsICdRTScsICdRQScsICdTQScsICdTRCcsICdTWScsICdUTicsICdZRSddO1xuZXhwb3J0cy5hcmFiaWNMb2NhbGVzID0gYXJhYmljTG9jYWxlcztcblxuZm9yICh2YXIgX2xvY2FsZSwgX2kgPSAwOyBfaSA8IGFyYWJpY0xvY2FsZXMubGVuZ3RoOyBfaSsrKSB7XG4gIF9sb2NhbGUgPSBcImFyLVwiLmNvbmNhdChhcmFiaWNMb2NhbGVzW19pXSk7XG4gIGFscGhhW19sb2NhbGVdID0gYWxwaGEuYXI7XG4gIGFscGhhbnVtZXJpY1tfbG9jYWxlXSA9IGFscGhhbnVtZXJpYy5hcjtcbiAgZGVjaW1hbFtfbG9jYWxlXSA9IGRlY2ltYWwuYXI7XG59IC8vIFNvdXJjZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVjaW1hbF9tYXJrXG5cblxudmFyIGRvdERlY2ltYWwgPSBbXTtcbmV4cG9ydHMuZG90RGVjaW1hbCA9IGRvdERlY2ltYWw7XG52YXIgY29tbWFEZWNpbWFsID0gWydiZy1CRycsICdjcy1DWicsICdkYS1ESycsICdkZS1ERScsICdlbC1HUicsICdlcy1FUycsICdmci1GUicsICdpdC1JVCcsICdrdS1JUScsICdodS1IVScsICduYi1OTycsICdubi1OTycsICdubC1OTCcsICdwbC1QTCcsICdwdC1QVCcsICdydS1SVScsICdzbC1TSScsICdzci1SU0BsYXRpbicsICdzci1SUycsICdzdi1TRScsICd0ci1UUicsICd1ay1VQSddO1xuZXhwb3J0cy5jb21tYURlY2ltYWwgPSBjb21tYURlY2ltYWw7XG5cbmZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGRvdERlY2ltYWwubGVuZ3RoOyBfaTIrKykge1xuICBkZWNpbWFsW2RvdERlY2ltYWxbX2kyXV0gPSBkZWNpbWFsWydlbi1VUyddO1xufVxuXG5mb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjb21tYURlY2ltYWwubGVuZ3RoOyBfaTMrKykge1xuICBkZWNpbWFsW2NvbW1hRGVjaW1hbFtfaTNdXSA9ICcsJztcbn1cblxuYWxwaGFbJ3B0LUJSJ10gPSBhbHBoYVsncHQtUFQnXTtcbmFscGhhbnVtZXJpY1sncHQtQlInXSA9IGFscGhhbnVtZXJpY1sncHQtUFQnXTtcbmRlY2ltYWxbJ3B0LUJSJ10gPSBkZWNpbWFsWydwdC1QVCddOyAvLyBzZWUgIzg2MlxuXG5hbHBoYVsncGwtUGwnXSA9IGFscGhhWydwbC1QTCddO1xuYWxwaGFudW1lcmljWydwbC1QbCddID0gYWxwaGFudW1lcmljWydwbC1QTCddO1xuZGVjaW1hbFsncGwtUGwnXSA9IGRlY2ltYWxbJ3BsLVBMJ107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBibGFja2xpc3Q7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJsYWNrbGlzdChzdHIsIGNoYXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiW1wiLmNvbmNhdChjaGFycywgXCJdK1wiKSwgJ2cnKSwgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb250YWlucztcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF90b1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC90b1N0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoKDAsIF90b1N0cmluZy5kZWZhdWx0KShlbGVtKSkgPj0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWxzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlcXVhbHMoc3RyLCBjb21wYXJpc29uKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIgPT09IGNvbXBhcmlzb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVzY2FwZTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjeDI3OycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFwvL2csICcmI3gyRjsnKS5yZXBsYWNlKC9cXFxcL2csICcmI3g1QzsnKS5yZXBsYWNlKC9gL2csICcmIzk2OycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FmdGVyO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvRGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9EYXRlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBZnRlcihzdHIpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFN0cmluZyhuZXcgRGF0ZSgpKTtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNvbXBhcmlzb24gPSAoMCwgX3RvRGF0ZS5kZWZhdWx0KShkYXRlKTtcbiAgdmFyIG9yaWdpbmFsID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICEhKG9yaWdpbmFsICYmIGNvbXBhcmlzb24gJiYgb3JpZ2luYWwgPiBjb21wYXJpc29uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYTtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9hbHBoYSA9IHJlcXVpcmUoXCIuL2FscGhhXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FscGhhKHN0cikge1xuICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZW4tVVMnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChsb2NhbGUgaW4gX2FscGhhLmFscGhhKSB7XG4gICAgcmV0dXJuIF9hbHBoYS5hbHBoYVtsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKF9hbHBoYS5hbHBoYSk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBbHBoYW51bWVyaWM7XG5leHBvcnRzLmxvY2FsZXMgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNBbHBoYW51bWVyaWMoc3RyKSB7XG4gIHZhciBsb2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdlbi1VUyc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBfYWxwaGEuYWxwaGFudW1lcmljKSB7XG4gICAgcmV0dXJuIF9hbHBoYS5hbHBoYW51bWVyaWNbbG9jYWxlXS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn1cblxudmFyIGxvY2FsZXMgPSBPYmplY3Qua2V5cyhfYWxwaGEuYWxwaGFudW1lcmljKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FzY2lpO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgYXNjaWkgPSAvXltcXHgwMC1cXHg3Rl0rJC87XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuZnVuY3Rpb24gaXNBc2NpaShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGFzY2lpLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCYXNlNjQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBub3RCYXNlNjQgPSAvW15BLVowLTkrXFwvPV0vaTtcblxuZnVuY3Rpb24gaXNCYXNlNjQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGlmICghbGVuIHx8IGxlbiAlIDQgIT09IDAgfHwgbm90QmFzZTY0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmaXJzdFBhZGRpbmdDaGFyID0gc3RyLmluZGV4T2YoJz0nKTtcbiAgcmV0dXJuIGZpcnN0UGFkZGluZ0NoYXIgPT09IC0xIHx8IGZpcnN0UGFkZGluZ0NoYXIgPT09IGxlbiAtIDEgfHwgZmlyc3RQYWRkaW5nQ2hhciA9PT0gbGVuIC0gMiAmJiBzdHJbbGVuIC0gMV0gPT09ICc9Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCZWZvcmU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfdG9EYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90b0RhdGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0JlZm9yZShzdHIpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFN0cmluZyhuZXcgRGF0ZSgpKTtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGNvbXBhcmlzb24gPSAoMCwgX3RvRGF0ZS5kZWZhdWx0KShkYXRlKTtcbiAgdmFyIG9yaWdpbmFsID0gKDAsIF90b0RhdGUuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICEhKG9yaWdpbmFsICYmIGNvbXBhcmlzb24gJiYgb3JpZ2luYWwgPCBjb21wYXJpc29uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCb29sZWFuO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBbJ3RydWUnLCAnZmFsc2UnLCAnMScsICcwJ10uaW5kZXhPZihzdHIpID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnl0ZUxlbmd0aDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5mdW5jdGlvbiBpc0J5dGVMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNCeXRlTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXG4gICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmNvZGVVUkkoc3RyKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGggLSAxO1xuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQ3JlZGl0Q2FyZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIGNyZWRpdENhcmQgPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoMjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfXw2WzI3XVswLTldezE0fSkkLztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBpc0NyZWRpdENhcmQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvWy0gXSsvZywgJycpO1xuXG4gIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3VtID0gMDtcbiAgdmFyIGRpZ2l0O1xuICB2YXIgdG1wTnVtO1xuICB2YXIgc2hvdWxkRG91YmxlO1xuXG4gIGZvciAodmFyIGkgPSBzYW5pdGl6ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkaWdpdCA9IHNhbml0aXplZC5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcblxuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICUgMTAgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IHRtcE51bTtcbiAgICB9XG5cbiAgICBzaG91bGREb3VibGUgPSAhc2hvdWxkRG91YmxlO1xuICB9XG5cbiAgcmV0dXJuICEhKHN1bSAlIDEwID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0N1cnJlbmN5O1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3VycmVuY3lSZWdleChvcHRpb25zKSB7XG4gIHZhciBkZWNpbWFsX2RpZ2l0cyA9IFwiXFxcXGR7XCIuY29uY2F0KG9wdGlvbnMuZGlnaXRzX2FmdGVyX2RlY2ltYWxbMF0sIFwifVwiKTtcbiAgb3B0aW9ucy5kaWdpdHNfYWZ0ZXJfZGVjaW1hbC5mb3JFYWNoKGZ1bmN0aW9uIChkaWdpdCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggIT09IDApIGRlY2ltYWxfZGlnaXRzID0gXCJcIi5jb25jYXQoZGVjaW1hbF9kaWdpdHMsIFwifFxcXFxke1wiKS5jb25jYXQoZGlnaXQsIFwifVwiKTtcbiAgfSk7XG4gIHZhciBzeW1ib2wgPSBcIihcXFxcXCIuY29uY2F0KG9wdGlvbnMuc3ltYm9sLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKSwgXCIpXCIpLmNvbmNhdChvcHRpb25zLnJlcXVpcmVfc3ltYm9sID8gJycgOiAnPycpLFxuICAgICAgbmVnYXRpdmUgPSAnLT8nLFxuICAgICAgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRob3V0X3NlcCA9ICdbMS05XVxcXFxkKicsXG4gICAgICB3aG9sZV9kb2xsYXJfYW1vdW50X3dpdGhfc2VwID0gXCJbMS05XVxcXFxkezAsMn0oXFxcXFwiLmNvbmNhdChvcHRpb25zLnRob3VzYW5kc19zZXBhcmF0b3IsIFwiXFxcXGR7M30pKlwiKSxcbiAgICAgIHZhbGlkX3dob2xlX2RvbGxhcl9hbW91bnRzID0gWycwJywgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRob3V0X3NlcCwgd2hvbGVfZG9sbGFyX2Ftb3VudF93aXRoX3NlcF0sXG4gICAgICB3aG9sZV9kb2xsYXJfYW1vdW50ID0gXCIoXCIuY29uY2F0KHZhbGlkX3dob2xlX2RvbGxhcl9hbW91bnRzLmpvaW4oJ3wnKSwgXCIpP1wiKSxcbiAgICAgIGRlY2ltYWxfYW1vdW50ID0gXCIoXFxcXFwiLmNvbmNhdChvcHRpb25zLmRlY2ltYWxfc2VwYXJhdG9yLCBcIihcIikuY29uY2F0KGRlY2ltYWxfZGlnaXRzLCBcIikpXCIpLmNvbmNhdChvcHRpb25zLnJlcXVpcmVfZGVjaW1hbCA/ICcnIDogJz8nKTtcbiAgdmFyIHBhdHRlcm4gPSB3aG9sZV9kb2xsYXJfYW1vdW50ICsgKG9wdGlvbnMuYWxsb3dfZGVjaW1hbCB8fCBvcHRpb25zLnJlcXVpcmVfZGVjaW1hbCA/IGRlY2ltYWxfYW1vdW50IDogJycpOyAvLyBkZWZhdWx0IGlzIG5lZ2F0aXZlIHNpZ24gYmVmb3JlIHN5bWJvbCwgYnV0IHRoZXJlIGFyZSB0d28gb3RoZXIgb3B0aW9ucyAoYmVzaWRlcyBwYXJlbnMpXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfbmVnYXRpdmVzICYmICFvcHRpb25zLnBhcmVuc19mb3JfbmVnYXRpdmVzKSB7XG4gICAgaWYgKG9wdGlvbnMubmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHMpIHtcbiAgICAgIHBhdHRlcm4gKz0gbmVnYXRpdmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5lZ2F0aXZlX3NpZ25fYmVmb3JlX2RpZ2l0cykge1xuICAgICAgcGF0dGVybiA9IG5lZ2F0aXZlICsgcGF0dGVybjtcbiAgICB9XG4gIH0gLy8gU291dGggQWZyaWNhbiBSYW5kLCBmb3IgZXhhbXBsZSwgdXNlcyBSIDEyMyAoc3BhY2UpIGFuZCBSLTEyMyAobm8gc3BhY2UpXG5cblxuICBpZiAob3B0aW9ucy5hbGxvd19uZWdhdGl2ZV9zaWduX3BsYWNlaG9sZGVyKSB7XG4gICAgcGF0dGVybiA9IFwiKCAoPyFcXFxcLSkpP1wiLmNvbmNhdChwYXR0ZXJuKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93X3NwYWNlX2FmdGVyX3N5bWJvbCkge1xuICAgIHBhdHRlcm4gPSBcIiA/XCIuY29uY2F0KHBhdHRlcm4pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dfc3BhY2VfYWZ0ZXJfZGlnaXRzKSB7XG4gICAgcGF0dGVybiArPSAnKCAoPyEkKSk/JztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnN5bWJvbF9hZnRlcl9kaWdpdHMpIHtcbiAgICBwYXR0ZXJuICs9IHN5bWJvbDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuID0gc3ltYm9sICsgcGF0dGVybjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93X25lZ2F0aXZlcykge1xuICAgIGlmIChvcHRpb25zLnBhcmVuc19mb3JfbmVnYXRpdmVzKSB7XG4gICAgICBwYXR0ZXJuID0gXCIoXFxcXChcIi5jb25jYXQocGF0dGVybiwgXCJcXFxcKXxcIikuY29uY2F0KHBhdHRlcm4sIFwiKVwiKTtcbiAgICB9IGVsc2UgaWYgKCEob3B0aW9ucy5uZWdhdGl2ZV9zaWduX2JlZm9yZV9kaWdpdHMgfHwgb3B0aW9ucy5uZWdhdGl2ZV9zaWduX2FmdGVyX2RpZ2l0cykpIHtcbiAgICAgIHBhdHRlcm4gPSBuZWdhdGl2ZSArIHBhdHRlcm47XG4gICAgfVxuICB9IC8vIGVuc3VyZSB0aGVyZSdzIGEgZG9sbGFyIGFuZC9vciBkZWNpbWFsIGFtb3VudCwgYW5kIHRoYXRcbiAgLy8gaXQgZG9lc24ndCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgYSBuZWdhdGl2ZSBzaWduIGZvbGxvd2VkIGJ5IGEgc3BhY2VcblxuXG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/IS0/ICkoPz0uKlxcXFxkKVwiLmNvbmNhdChwYXR0ZXJuLCBcIiRcIikpO1xufVxuXG52YXIgZGVmYXVsdF9jdXJyZW5jeV9vcHRpb25zID0ge1xuICBzeW1ib2w6ICckJyxcbiAgcmVxdWlyZV9zeW1ib2w6IGZhbHNlLFxuICBhbGxvd19zcGFjZV9hZnRlcl9zeW1ib2w6IGZhbHNlLFxuICBzeW1ib2xfYWZ0ZXJfZGlnaXRzOiBmYWxzZSxcbiAgYWxsb3dfbmVnYXRpdmVzOiB0cnVlLFxuICBwYXJlbnNfZm9yX25lZ2F0aXZlczogZmFsc2UsXG4gIG5lZ2F0aXZlX3NpZ25fYmVmb3JlX2RpZ2l0czogZmFsc2UsXG4gIG5lZ2F0aXZlX3NpZ25fYWZ0ZXJfZGlnaXRzOiBmYWxzZSxcbiAgYWxsb3dfbmVnYXRpdmVfc2lnbl9wbGFjZWhvbGRlcjogZmFsc2UsXG4gIHRob3VzYW5kc19zZXBhcmF0b3I6ICcsJyxcbiAgZGVjaW1hbF9zZXBhcmF0b3I6ICcuJyxcbiAgYWxsb3dfZGVjaW1hbDogdHJ1ZSxcbiAgcmVxdWlyZV9kZWNpbWFsOiBmYWxzZSxcbiAgZGlnaXRzX2FmdGVyX2RlY2ltYWw6IFsyXSxcbiAgYWxsb3dfc3BhY2VfYWZ0ZXJfZGlnaXRzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNDdXJyZW5jeShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9jdXJyZW5jeV9vcHRpb25zKTtcbiAgcmV0dXJuIGN1cnJlbmN5UmVnZXgob3B0aW9ucykudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0RhdGFVUkk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB2YWxpZE1lZGlhVHlwZSA9IC9eW2Etel0rXFwvW2EtejAtOVxcLVxcK10rJC9pO1xudmFyIHZhbGlkQXR0cmlidXRlID0gL15bYS16XFwtXSs9W2EtejAtOVxcLV0rJC9pO1xudmFyIHZhbGlkRGF0YSA9IC9eW2EtejAtOSFcXCQmJ1xcKFxcKVxcKlxcKyw7PVxcLVxcLl9+OkBcXC9cXD8lXFxzXSokL2k7XG5cbmZ1bmN0aW9uIGlzRGF0YVVSSShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGRhdGEgPSBzdHIuc3BsaXQoJywnKTtcblxuICBpZiAoZGF0YS5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBkYXRhLnNoaWZ0KCkudHJpbSgpLnNwbGl0KCc7Jyk7XG4gIHZhciBzY2hlbWVBbmRNZWRpYVR5cGUgPSBhdHRyaWJ1dGVzLnNoaWZ0KCk7XG5cbiAgaWYgKHNjaGVtZUFuZE1lZGlhVHlwZS5zdWJzdHIoMCwgNSkgIT09ICdkYXRhOicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWVkaWFUeXBlID0gc2NoZW1lQW5kTWVkaWFUeXBlLnN1YnN0cig1KTtcblxuICBpZiAobWVkaWFUeXBlICE9PSAnJyAmJiAhdmFsaWRNZWRpYVR5cGUudGVzdChtZWRpYVR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IGF0dHJpYnV0ZXMubGVuZ3RoIC0gMSAmJiBhdHRyaWJ1dGVzW2ldLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNlNjQnKSB7Ly8gb2tcbiAgICB9IGVsc2UgaWYgKCF2YWxpZEF0dHJpYnV0ZS50ZXN0KGF0dHJpYnV0ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKCF2YWxpZERhdGEudGVzdChkYXRhW19pXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEZWNpbWFsO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pbmNsdWRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9pbmNsdWRlc1wiKSk7XG5cbnZhciBfYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZGVjaW1hbFJlZ0V4cChvcHRpb25zKSB7XG4gIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlstK10/KFswLTldKyk/KFxcXFxcIi5jb25jYXQoX2FscGhhLmRlY2ltYWxbb3B0aW9ucy5sb2NhbGVdLCBcIlswLTlde1wiKS5jb25jYXQob3B0aW9ucy5kZWNpbWFsX2RpZ2l0cywgXCJ9KVwiKS5jb25jYXQob3B0aW9ucy5mb3JjZV9kZWNpbWFsID8gJycgOiAnPycsIFwiJFwiKSk7XG4gIHJldHVybiByZWdFeHA7XG59XG5cbnZhciBkZWZhdWx0X2RlY2ltYWxfb3B0aW9ucyA9IHtcbiAgZm9yY2VfZGVjaW1hbDogZmFsc2UsXG4gIGRlY2ltYWxfZGlnaXRzOiAnMSwnLFxuICBsb2NhbGU6ICdlbi1VUydcbn07XG52YXIgYmxhY2tsaXN0ID0gWycnLCAnLScsICcrJ107XG5cbmZ1bmN0aW9uIGlzRGVjaW1hbChzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9kZWNpbWFsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmxvY2FsZSBpbiBfYWxwaGEuZGVjaW1hbCkge1xuICAgIHJldHVybiAhKDAsIF9pbmNsdWRlcy5kZWZhdWx0KShibGFja2xpc3QsIHN0ci5yZXBsYWNlKC8gL2csICcnKSkgJiYgZGVjaW1hbFJlZ0V4cChvcHRpb25zKS50ZXN0KHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KG9wdGlvbnMubG9jYWxlLCBcIidcIikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0RpdmlzaWJsZUJ5O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX3RvRmxvYXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RvRmxvYXRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0RpdmlzaWJsZUJ5KHN0ciwgbnVtKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX3RvRmxvYXQuZGVmYXVsdCkoc3RyKSAlIHBhcnNlSW50KG51bSwgMTApID09PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxudmFyIF9pc0J5dGVMZW5ndGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzQnl0ZUxlbmd0aFwiKSk7XG5cbnZhciBfaXNGUUROID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0ZRRE5cIikpO1xuXG52YXIgX2lzSVAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSVBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9lbWFpbF9vcHRpb25zID0ge1xuICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICByZXF1aXJlX2Rpc3BsYXlfbmFtZTogZmFsc2UsXG4gIGFsbG93X3V0ZjhfbG9jYWxfcGFydDogdHJ1ZSxcbiAgcmVxdWlyZV90bGQ6IHRydWVcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxudmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xudmFyIGVtYWlsVXNlclBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl0rJC9pO1xudmFyIGdtYWlsVXNlclBhcnQgPSAvXlthLXpcXGRdKyQvO1xudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG52YXIgZW1haWxVc2VyVXRmOFBhcnQgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rJC9pO1xudmFyIHF1b3RlZEVtYWlsVXNlclV0ZjggPSAvXihbXFxzXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3ZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3ZVxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl18KFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkqJC9pO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc0VtYWlsKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gKDAsIF9tZXJnZS5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2VtYWlsX29wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lIHx8IG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuXG4gICAgaWYgKGRpc3BsYXlfZW1haWwpIHtcbiAgICAgIHN0ciA9IGRpc3BsYXlfZW1haWxbMV07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCdAJyk7XG4gIHZhciBkb21haW4gPSBwYXJ0cy5wb3AoKTtcbiAgdmFyIHVzZXIgPSBwYXJ0cy5qb2luKCdAJyk7XG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcblxuICBpZiAob3B0aW9ucy5kb21haW5fc3BlY2lmaWNfdmFsaWRhdGlvbiAmJiAobG93ZXJfZG9tYWluID09PSAnZ21haWwuY29tJyB8fCBsb3dlcl9kb21haW4gPT09ICdnb29nbGVtYWlsLmNvbScpKSB7XG4gICAgLypcbiAgICAgIFByZXZpb3VzbHkgd2UgcmVtb3ZlZCBkb3RzIGZvciBnbWFpbCBhZGRyZXNzZXMgYmVmb3JlIHZhbGlkYXRpbmcuXG4gICAgICBUaGlzIHdhcyByZW1vdmVkIGJlY2F1c2UgaXQgYWxsb3dzIGBtdWx0aXBsZS4uZG90c0BnbWFpbC5jb21gXG4gICAgICB0byBiZSByZXBvcnRlZCBhcyB2YWxpZCwgYnV0IGl0IGlzIG5vdC5cbiAgICAgIEdtYWlsIG9ubHkgbm9ybWFsaXplcyBzaW5nbGUgZG90cywgcmVtb3ZpbmcgdGhlbSBmcm9tIGhlcmUgaXMgcG9pbnRsZXNzLFxuICAgICAgc2hvdWxkIGJlIGRvbmUgaW4gbm9ybWFsaXplRW1haWxcbiAgICAqL1xuICAgIHVzZXIgPSB1c2VyLnRvTG93ZXJDYXNlKCk7IC8vIFJlbW92aW5nIHN1Yi1hZGRyZXNzIGZyb20gdXNlcm5hbWUgYmVmb3JlIGdtYWlsIHZhbGlkYXRpb25cblxuICAgIHZhciB1c2VybmFtZSA9IHVzZXIuc3BsaXQoJysnKVswXTsgLy8gRG90cyBhcmUgbm90IGluY2x1ZGVkIGluIGdtYWlsIGxlbmd0aCByZXN0cmljdGlvblxuXG4gICAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KSh1c2VybmFtZS5yZXBsYWNlKCcuJywgJycpLCB7XG4gICAgICBtaW46IDYsXG4gICAgICBtYXg6IDMwXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX3VzZXJfcGFydHMgPSB1c2VybmFtZS5zcGxpdCgnLicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdXNlcl9wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFnbWFpbFVzZXJQYXJ0LnRlc3QoX3VzZXJfcGFydHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoLmRlZmF1bHQpKHVzZXIsIHtcbiAgICBtYXg6IDY0XG4gIH0pIHx8ICEoMCwgX2lzQnl0ZUxlbmd0aC5kZWZhdWx0KShkb21haW4sIHtcbiAgICBtYXg6IDI1NFxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKDAsIF9pc0ZRRE4uZGVmYXVsdCkoZG9tYWluLCB7XG4gICAgcmVxdWlyZV90bGQ6IG9wdGlvbnMucmVxdWlyZV90bGRcbiAgfSkpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfaXBfZG9tYWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoMCwgX2lzSVAuZGVmYXVsdCkoZG9tYWluKSkge1xuICAgICAgaWYgKCFkb21haW4uc3RhcnRzV2l0aCgnWycpIHx8ICFkb21haW4uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0JyYWNrZXRkb21haW4gPSBkb21haW4uc3Vic3RyKDEsIGRvbWFpbi5sZW5ndGggLSAyKTtcblxuICAgICAgaWYgKG5vQnJhY2tldGRvbWFpbi5sZW5ndGggPT09IDAgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShub0JyYWNrZXRkb21haW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodXNlclswXSA9PT0gJ1wiJykge1xuICAgIHVzZXIgPSB1c2VyLnNsaWNlKDEsIHVzZXIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XG4gIH1cblxuICB2YXIgcGF0dGVybiA9IG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gZW1haWxVc2VyVXRmOFBhcnQgOiBlbWFpbFVzZXJQYXJ0O1xuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXNlcl9wYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBpZiAoIXBhdHRlcm4udGVzdCh1c2VyX3BhcnRzW19pXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbXB0eTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2lzX2VtcHR5X29wdGlvbnMgPSB7XG4gIGlnbm9yZV93aGl0ZXNwYWNlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNFbXB0eShzdHIsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9pc19lbXB0eV9vcHRpb25zKTtcbiAgcmV0dXJuIChvcHRpb25zLmlnbm9yZV93aGl0ZXNwYWNlID8gc3RyLnRyaW0oKS5sZW5ndGggOiBzdHIubGVuZ3RoKSA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGUUROO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL21lcmdlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRlZmF1bHRfZnFkbl9vcHRpb25zID0ge1xuICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlLFxuICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBpc0ZRRE4oc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcbiAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcuJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0c1tpXS5sZW5ndGggPiA2Mykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfdGxkKSB7XG4gICAgdmFyIHRsZCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXHUwMGExLVxcdWZmZmZdezIsfXx4blthLXowLTktXXsyLH0pJC9pLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZGlzYWxsb3cgc3BhY2VzXG5cblxuICAgIGlmICgvW1xcc1xcdTIwMDItXFx1MjAwQlxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZcXHVEQjQwXFx1REMyMF0vLnRlc3QodGxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHBhcnQsIF9pID0gMDsgX2kgPCBwYXJ0cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwYXJ0ID0gcGFydHNbX2ldO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dfdW5kZXJzY29yZXMpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xuICAgIH1cblxuICAgIGlmICghL15bYS16XFx1MDBhMS1cXHVmZmZmMC05LV0rJC9pLnRlc3QocGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcblxuXG4gICAgaWYgKC9bXFx1ZmYwMS1cXHVmZjVlXS8udGVzdChwYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJ0WzBdID09PSAnLScgfHwgcGFydFtwYXJ0Lmxlbmd0aCAtIDFdID09PSAnLScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNGbG9hdDtcbmV4cG9ydHMubG9jYWxlcyA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9hbHBoYSA9IHJlcXVpcmUoXCIuL2FscGhhXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0Zsb2F0KHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGZsb2F0ID0gbmV3IFJlZ0V4cChcIl4oPzpbLStdKT8oPzpbMC05XSspPyg/OlxcXFxcIi5jb25jYXQob3B0aW9ucy5sb2NhbGUgPyBfYWxwaGEuZGVjaW1hbFtvcHRpb25zLmxvY2FsZV0gOiAnLicsIFwiWzAtOV0qKT8oPzpbZUVdW1xcXFwrXFxcXC1dPyg/OlswLTldKykpPyRcIikpO1xuXG4gIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gJy4nIHx8IHN0ciA9PT0gJy0nIHx8IHN0ciA9PT0gJysnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgnLCcsICcuJykpO1xuICByZXR1cm4gZmxvYXQudGVzdChzdHIpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWluJykgfHwgdmFsdWUgPj0gb3B0aW9ucy5taW4pICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWF4JykgfHwgdmFsdWUgPD0gb3B0aW9ucy5tYXgpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbHQnKSB8fCB2YWx1ZSA8IG9wdGlvbnMubHQpICYmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZ3QnKSB8fCB2YWx1ZSA+IG9wdGlvbnMuZ3QpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKF9hbHBoYS5kZWNpbWFsKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Z1bGxXaWR0aDtcbmV4cG9ydHMuZnVsbFdpZHRoID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVsbFdpZHRoID0gL1teXFx1MDAyMC1cXHUwMDdFXFx1RkY2MS1cXHVGRjlGXFx1RkZBMC1cXHVGRkRDXFx1RkZFOC1cXHVGRkVFMC05YS16QS1aXS87XG5leHBvcnRzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblxuZnVuY3Rpb24gaXNGdWxsV2lkdGgoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBmdWxsV2lkdGgudGVzdChzdHIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNIYWxmV2lkdGg7XG5leHBvcnRzLmhhbGZXaWR0aCA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGhhbGZXaWR0aCA9IC9bXFx1MDAyMC1cXHUwMDdFXFx1RkY2MS1cXHVGRjlGXFx1RkZBMC1cXHVGRkRDXFx1RkZFOC1cXHVGRkVFMC05YS16QS1aXS87XG5leHBvcnRzLmhhbGZXaWR0aCA9IGhhbGZXaWR0aDtcblxuZnVuY3Rpb24gaXNIYWxmV2lkdGgoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBoYWxmV2lkdGgudGVzdChzdHIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNIYXNoO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbGVuZ3RocyA9IHtcbiAgbWQ1OiAzMixcbiAgbWQ0OiAzMixcbiAgc2hhMTogNDAsXG4gIHNoYTI1NjogNjQsXG4gIHNoYTM4NDogOTYsXG4gIHNoYTUxMjogMTI4LFxuICByaXBlbWQxMjg6IDMyLFxuICByaXBlbWQxNjA6IDQwLFxuICB0aWdlcjEyODogMzIsXG4gIHRpZ2VyMTYwOiA0MCxcbiAgdGlnZXIxOTI6IDQ4LFxuICBjcmMzMjogOCxcbiAgY3JjMzJiOiA4XG59O1xuXG5mdW5jdGlvbiBpc0hhc2goc3RyLCBhbGdvcml0aG0pIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIGhhc2ggPSBuZXcgUmVnRXhwKFwiXlthLWYwLTlde1wiLmNvbmNhdChsZW5ndGhzW2FsZ29yaXRobV0sIFwifSRcIikpO1xuICByZXR1cm4gaGFzaC50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSGV4Q29sb3I7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoZXhjb2xvciA9IC9eIz8oWzAtOUEtRl17M318WzAtOUEtRl17Nn0pJC9pO1xuXG5mdW5jdGlvbiBpc0hleENvbG9yKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gaGV4Y29sb3IudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0hleGFkZWNpbWFsO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaGV4YWRlY2ltYWwgPSAvXlswLTlBLUZdKyQvaTtcblxuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIGhleGFkZWNpbWFsLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlwdjRNYXliZSA9IC9eKFxcZHsxLDN9KVxcLihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KSQvO1xudmFyIGlwdjZCbG9jayA9IC9eWzAtOUEtRl17MSw0fSQvaTtcblxuZnVuY3Rpb24gaXNJUChzdHIpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuXG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBpc0lQKHN0ciwgNCkgfHwgaXNJUChzdHIsIDYpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc2Jykge1xuICAgIHZhciBibG9ja3MgPSBzdHIuc3BsaXQoJzonKTtcbiAgICB2YXIgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuICAgIC8vIEF0IGxlYXN0IHNvbWUgT1MgYWNjZXB0IHRoZSBsYXN0IDMyIGJpdHMgb2YgYW4gSVB2NiBhZGRyZXNzXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgIC8vIHRoYXQgJzo6ZmZmZjphLmIuYy5kJyBpcyB2YWxpZCBmb3IgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMsXG4gICAgLy8gYW5kICc6OmEuYi5jLmQnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBhbHNvIHZhbGlkLlxuXG4gICAgdmFyIGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA9IGlzSVAoYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXSwgNCk7XG4gICAgdmFyIGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgIGlmIChibG9ja3MubGVuZ3RoID4gZXhwZWN0ZWROdW1iZXJPZkJsb2Nrcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuXG5cbiAgICBpZiAoc3RyID09PSAnOjonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMikgPT09ICc6OicpIHtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHRlc3QgZm9yIGEgOjogd2hpY2ggY2FuIG5vdCBiZSBhdCB0aGUgc3RyaW5nIHN0YXJ0L2VuZFxuICAgICAgLy8gc2luY2UgdGhvc2UgY2FzZXMgaGF2ZSBiZWVuIGhhbmRsZWQgYWJvdmVcbiAgICAgIGlmIChibG9ja3NbaV0gPT09ICcnICYmIGkgPiAwICYmIGkgPCBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtdWx0aXBsZSA6OiBpbiBhZGRyZXNzXG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIHsvLyBpdCBoYXMgYmVlbiBjaGVja2VkIGJlZm9yZSB0aGF0IHRoZSBsYXN0XG4gICAgICAgIC8vIGJsb2NrIGlzIGEgdmFsaWQgSVB2NCBhZGRyZXNzXG4gICAgICB9IGVsc2UgaWYgKCFpcHY2QmxvY2sudGVzdChibG9ja3NbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja3MubGVuZ3RoID09PSBleHBlY3RlZE51bWJlck9mQmxvY2tzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lQUmFuZ2U7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNJUFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdWJuZXRNYXliZSA9IC9eXFxkezEsMn0kLztcblxuZnVuY3Rpb24gaXNJUFJhbmdlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTsgLy8gcGFydHNbMF0gLT4gaXAsIHBhcnRzWzFdIC0+IHN1Ym5ldFxuXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXN1Ym5ldE1heWJlLnRlc3QocGFydHNbMV0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIERpc2FsbG93IHByZWNlZGluZyAwIGkuZS4gMDEsIDAyLCAuLi5cblxuXG4gIGlmIChwYXJ0c1sxXS5sZW5ndGggPiAxICYmIHBhcnRzWzFdLnN0YXJ0c1dpdGgoJzAnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2lzSVAuZGVmYXVsdCkocGFydHNbMF0sIDQpICYmIHBhcnRzWzFdIDw9IDMyICYmIHBhcnRzWzFdID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNCTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzYm4xME1heWJlID0gL14oPzpbMC05XXs5fVh8WzAtOV17MTB9KSQvO1xudmFyIGlzYm4xM01heWJlID0gL14oPzpbMC05XXsxM30pJC87XG52YXIgZmFjdG9yID0gWzEsIDNdO1xuXG5mdW5jdGlvbiBpc0lTQk4oc3RyKSB7XG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcblxuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gaXNJU0JOKHN0ciwgMTApIHx8IGlzSVNCTihzdHIsIDEzKTtcbiAgfVxuXG4gIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvW1xccy1dKy9nLCAnJyk7XG4gIHZhciBjaGVja3N1bSA9IDA7XG4gIHZhciBpO1xuXG4gIGlmICh2ZXJzaW9uID09PSAnMTAnKSB7XG4gICAgaWYgKCFpc2JuMTBNYXliZS50ZXN0KHNhbml0aXplZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBjaGVja3N1bSArPSAoaSArIDEpICogc2FuaXRpemVkLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICBpZiAoc2FuaXRpemVkLmNoYXJBdCg5KSA9PT0gJ1gnKSB7XG4gICAgICBjaGVja3N1bSArPSAxMCAqIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja3N1bSArPSAxMCAqIHNhbml0aXplZC5jaGFyQXQoOSk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrc3VtICUgMTEgPT09IDApIHtcbiAgICAgIHJldHVybiAhIXNhbml0aXplZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzEzJykge1xuICAgIGlmICghaXNibjEzTWF5YmUudGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgIGNoZWNrc3VtICs9IGZhY3RvcltpICUgMl0gKiBzYW5pdGl6ZWQuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIGlmIChzYW5pdGl6ZWQuY2hhckF0KDEyKSAtICgxMCAtIGNoZWNrc3VtICUgMTApICUgMTAgPT09IDApIHtcbiAgICAgIHJldHVybiAhIXNhbml0aXplZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNJTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzaW4gPSAvXltBLVpdezJ9WzAtOUEtWl17OX1bMC05XSQvO1xuXG5mdW5jdGlvbiBpc0lTSU4oc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKCFpc2luLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGVja3N1bVN0ciA9IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNoYXJhY3RlciwgMzYpO1xuICB9KTtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciBkaWdpdDtcbiAgdmFyIHRtcE51bTtcbiAgdmFyIHNob3VsZERvdWJsZSA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IGNoZWNrc3VtU3RyLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGlnaXQgPSBjaGVja3N1bVN0ci5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICB0bXBOdW0gKj0gMjtcblxuICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICBzdW0gKz0gdG1wTnVtICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgfVxuXG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAxKSwgMTApID09PSAoMTAwMDAgLSBzdW0pICUgMTA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPMzE2NjFBbHBoYTI7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaW5jbHVkZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvaW5jbHVkZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTFfYWxwaGEtMlxudmFyIHZhbGlkSVNPMzE2NjFBbHBoYTJDb3VudHJpZXNDb2RlcyA9IFsnQUQnLCAnQUUnLCAnQUYnLCAnQUcnLCAnQUknLCAnQUwnLCAnQU0nLCAnQU8nLCAnQVEnLCAnQVInLCAnQVMnLCAnQVQnLCAnQVUnLCAnQVcnLCAnQVgnLCAnQVonLCAnQkEnLCAnQkInLCAnQkQnLCAnQkUnLCAnQkYnLCAnQkcnLCAnQkgnLCAnQkknLCAnQkonLCAnQkwnLCAnQk0nLCAnQk4nLCAnQk8nLCAnQlEnLCAnQlInLCAnQlMnLCAnQlQnLCAnQlYnLCAnQlcnLCAnQlknLCAnQlonLCAnQ0EnLCAnQ0MnLCAnQ0QnLCAnQ0YnLCAnQ0cnLCAnQ0gnLCAnQ0knLCAnQ0snLCAnQ0wnLCAnQ00nLCAnQ04nLCAnQ08nLCAnQ1InLCAnQ1UnLCAnQ1YnLCAnQ1cnLCAnQ1gnLCAnQ1knLCAnQ1onLCAnREUnLCAnREonLCAnREsnLCAnRE0nLCAnRE8nLCAnRFonLCAnRUMnLCAnRUUnLCAnRUcnLCAnRUgnLCAnRVInLCAnRVMnLCAnRVQnLCAnRkknLCAnRkonLCAnRksnLCAnRk0nLCAnRk8nLCAnRlInLCAnR0EnLCAnR0InLCAnR0QnLCAnR0UnLCAnR0YnLCAnR0cnLCAnR0gnLCAnR0knLCAnR0wnLCAnR00nLCAnR04nLCAnR1AnLCAnR1EnLCAnR1InLCAnR1MnLCAnR1QnLCAnR1UnLCAnR1cnLCAnR1knLCAnSEsnLCAnSE0nLCAnSE4nLCAnSFInLCAnSFQnLCAnSFUnLCAnSUQnLCAnSUUnLCAnSUwnLCAnSU0nLCAnSU4nLCAnSU8nLCAnSVEnLCAnSVInLCAnSVMnLCAnSVQnLCAnSkUnLCAnSk0nLCAnSk8nLCAnSlAnLCAnS0UnLCAnS0cnLCAnS0gnLCAnS0knLCAnS00nLCAnS04nLCAnS1AnLCAnS1InLCAnS1cnLCAnS1knLCAnS1onLCAnTEEnLCAnTEInLCAnTEMnLCAnTEknLCAnTEsnLCAnTFInLCAnTFMnLCAnTFQnLCAnTFUnLCAnTFYnLCAnTFknLCAnTUEnLCAnTUMnLCAnTUQnLCAnTUUnLCAnTUYnLCAnTUcnLCAnTUgnLCAnTUsnLCAnTUwnLCAnTU0nLCAnTU4nLCAnTU8nLCAnTVAnLCAnTVEnLCAnTVInLCAnTVMnLCAnTVQnLCAnTVUnLCAnTVYnLCAnTVcnLCAnTVgnLCAnTVknLCAnTVonLCAnTkEnLCAnTkMnLCAnTkUnLCAnTkYnLCAnTkcnLCAnTkknLCAnTkwnLCAnTk8nLCAnTlAnLCAnTlInLCAnTlUnLCAnTlonLCAnT00nLCAnUEEnLCAnUEUnLCAnUEYnLCAnUEcnLCAnUEgnLCAnUEsnLCAnUEwnLCAnUE0nLCAnUE4nLCAnUFInLCAnUFMnLCAnUFQnLCAnUFcnLCAnUFknLCAnUUEnLCAnUkUnLCAnUk8nLCAnUlMnLCAnUlUnLCAnUlcnLCAnU0EnLCAnU0InLCAnU0MnLCAnU0QnLCAnU0UnLCAnU0cnLCAnU0gnLCAnU0knLCAnU0onLCAnU0snLCAnU0wnLCAnU00nLCAnU04nLCAnU08nLCAnU1InLCAnU1MnLCAnU1QnLCAnU1YnLCAnU1gnLCAnU1knLCAnU1onLCAnVEMnLCAnVEQnLCAnVEYnLCAnVEcnLCAnVEgnLCAnVEonLCAnVEsnLCAnVEwnLCAnVE0nLCAnVE4nLCAnVE8nLCAnVFInLCAnVFQnLCAnVFYnLCAnVFcnLCAnVFonLCAnVUEnLCAnVUcnLCAnVU0nLCAnVVMnLCAnVVknLCAnVVonLCAnVkEnLCAnVkMnLCAnVkUnLCAnVkcnLCAnVkknLCAnVk4nLCAnVlUnLCAnV0YnLCAnV1MnLCAnWUUnLCAnWVQnLCAnWkEnLCAnWk0nLCAnWlcnXTtcblxuZnVuY3Rpb24gaXNJU08zMTY2MUFscGhhMihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICgwLCBfaW5jbHVkZXMuZGVmYXVsdCkodmFsaWRJU08zMTY2MUFscGhhMkNvdW50cmllc0NvZGVzLCBzdHIudG9VcHBlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPMzE2NjFBbHBoYTM7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfaW5jbHVkZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvaW5jbHVkZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTFfYWxwaGEtM1xudmFyIHZhbGlkSVNPMzE2NjFBbHBoYTNDb3VudHJpZXNDb2RlcyA9IFsnQUZHJywgJ0FMQScsICdBTEInLCAnRFpBJywgJ0FTTScsICdBTkQnLCAnQUdPJywgJ0FJQScsICdBVEEnLCAnQVRHJywgJ0FSRycsICdBUk0nLCAnQUJXJywgJ0FVUycsICdBVVQnLCAnQVpFJywgJ0JIUycsICdCSFInLCAnQkdEJywgJ0JSQicsICdCTFInLCAnQkVMJywgJ0JMWicsICdCRU4nLCAnQk1VJywgJ0JUTicsICdCT0wnLCAnQkVTJywgJ0JJSCcsICdCV0EnLCAnQlZUJywgJ0JSQScsICdJT1QnLCAnQlJOJywgJ0JHUicsICdCRkEnLCAnQkRJJywgJ0tITScsICdDTVInLCAnQ0FOJywgJ0NQVicsICdDWU0nLCAnQ0FGJywgJ1RDRCcsICdDSEwnLCAnQ0hOJywgJ0NYUicsICdDQ0snLCAnQ09MJywgJ0NPTScsICdDT0cnLCAnQ09EJywgJ0NPSycsICdDUkknLCAnQ0lWJywgJ0hSVicsICdDVUInLCAnQ1VXJywgJ0NZUCcsICdDWkUnLCAnRE5LJywgJ0RKSScsICdETUEnLCAnRE9NJywgJ0VDVScsICdFR1knLCAnU0xWJywgJ0dOUScsICdFUkknLCAnRVNUJywgJ0VUSCcsICdGTEsnLCAnRlJPJywgJ0ZKSScsICdGSU4nLCAnRlJBJywgJ0dVRicsICdQWUYnLCAnQVRGJywgJ0dBQicsICdHTUInLCAnR0VPJywgJ0RFVScsICdHSEEnLCAnR0lCJywgJ0dSQycsICdHUkwnLCAnR1JEJywgJ0dMUCcsICdHVU0nLCAnR1RNJywgJ0dHWScsICdHSU4nLCAnR05CJywgJ0dVWScsICdIVEknLCAnSE1EJywgJ1ZBVCcsICdITkQnLCAnSEtHJywgJ0hVTicsICdJU0wnLCAnSU5EJywgJ0lETicsICdJUk4nLCAnSVJRJywgJ0lSTCcsICdJTU4nLCAnSVNSJywgJ0lUQScsICdKQU0nLCAnSlBOJywgJ0pFWScsICdKT1InLCAnS0FaJywgJ0tFTicsICdLSVInLCAnUFJLJywgJ0tPUicsICdLV1QnLCAnS0daJywgJ0xBTycsICdMVkEnLCAnTEJOJywgJ0xTTycsICdMQlInLCAnTEJZJywgJ0xJRScsICdMVFUnLCAnTFVYJywgJ01BQycsICdNS0QnLCAnTURHJywgJ01XSScsICdNWVMnLCAnTURWJywgJ01MSScsICdNTFQnLCAnTUhMJywgJ01UUScsICdNUlQnLCAnTVVTJywgJ01ZVCcsICdNRVgnLCAnRlNNJywgJ01EQScsICdNQ08nLCAnTU5HJywgJ01ORScsICdNU1InLCAnTUFSJywgJ01PWicsICdNTVInLCAnTkFNJywgJ05SVScsICdOUEwnLCAnTkxEJywgJ05DTCcsICdOWkwnLCAnTklDJywgJ05FUicsICdOR0EnLCAnTklVJywgJ05GSycsICdNTlAnLCAnTk9SJywgJ09NTicsICdQQUsnLCAnUExXJywgJ1BTRScsICdQQU4nLCAnUE5HJywgJ1BSWScsICdQRVInLCAnUEhMJywgJ1BDTicsICdQT0wnLCAnUFJUJywgJ1BSSScsICdRQVQnLCAnUkVVJywgJ1JPVScsICdSVVMnLCAnUldBJywgJ0JMTScsICdTSE4nLCAnS05BJywgJ0xDQScsICdNQUYnLCAnU1BNJywgJ1ZDVCcsICdXU00nLCAnU01SJywgJ1NUUCcsICdTQVUnLCAnU0VOJywgJ1NSQicsICdTWUMnLCAnU0xFJywgJ1NHUCcsICdTWE0nLCAnU1ZLJywgJ1NWTicsICdTTEInLCAnU09NJywgJ1pBRicsICdTR1MnLCAnU1NEJywgJ0VTUCcsICdMS0EnLCAnU0ROJywgJ1NVUicsICdTSk0nLCAnU1daJywgJ1NXRScsICdDSEUnLCAnU1lSJywgJ1RXTicsICdUSksnLCAnVFpBJywgJ1RIQScsICdUTFMnLCAnVEdPJywgJ1RLTCcsICdUT04nLCAnVFRPJywgJ1RVTicsICdUVVInLCAnVEtNJywgJ1RDQScsICdUVVYnLCAnVUdBJywgJ1VLUicsICdBUkUnLCAnR0JSJywgJ1VTQScsICdVTUknLCAnVVJZJywgJ1VaQicsICdWVVQnLCAnVkVOJywgJ1ZOTScsICdWR0InLCAnVklSJywgJ1dMRicsICdFU0gnLCAnWUVNJywgJ1pNQicsICdaV0UnXTtcblxuZnVuY3Rpb24gaXNJU08zMTY2MUFscGhhMyhzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuICgwLCBfaW5jbHVkZXMuZGVmYXVsdCkodmFsaWRJU08zMTY2MUFscGhhM0NvdW50cmllc0NvZGVzLCBzdHIudG9VcHBlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNPODYwMTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLy8gZnJvbSBodHRwOi8vZ29vLmdsLzBlakhIV1xudmFyIGlzbzg2MDEgPSAvXihbXFwrLV0/XFxkezR9KD8hXFxkezJ9XFxiKSkoKC0/KSgoMFsxLTldfDFbMC0yXSkoXFwzKFsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoWzAtNF1cXGR8NVswLTNdKSgtP1sxLTddKT98KDAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18MyhbMC01XVxcZHw2WzEtNl0pKSkoW1RcXHNdKCgoWzAxXVxcZHwyWzAtM10pKCg6PylbMC01XVxcZCk/fDI0Oj8wMCkoW1xcLixdXFxkKyg/ITopKT8pPyhcXDE3WzAtNV1cXGQoW1xcLixdXFxkKyk/KT8oW3paXXwoW1xcKy1dKShbMDFdXFxkfDJbMC0zXSk6PyhbMC01XVxcZCk/KT8pPyk/JC87XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIGlzVmFsaWREYXRlID0gZnVuY3Rpb24gaXNWYWxpZERhdGUoc3RyKSB7XG4gIC8vIHN0ciBtdXN0IGhhdmUgcGFzc2VkIHRoZSBJU084NjAxIGNoZWNrXG4gIC8vIHRoaXMgY2hlY2sgaXMgbWVhbnQgdG8gY2F0Y2ggaW52YWxpZCBkYXRlc1xuICAvLyBsaWtlIDIwMDktMDItMzFcbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG9yZGluYWwgZGF0ZXNcbiAgdmFyIG9yZGluYWxNYXRjaCA9IHN0ci5tYXRjaCgvXihcXGR7NH0pLT8oXFxkezN9KShbIFRdezF9XFwuKnwkKS8pO1xuXG4gIGlmIChvcmRpbmFsTWF0Y2gpIHtcbiAgICB2YXIgb1llYXIgPSBOdW1iZXIob3JkaW5hbE1hdGNoWzFdKTtcbiAgICB2YXIgb0RheSA9IE51bWJlcihvcmRpbmFsTWF0Y2hbMl0pOyAvLyBpZiBpcyBsZWFwIHllYXJcblxuICAgIGlmIChvWWVhciAlIDQgPT09IDAgJiYgb1llYXIgJSAxMDAgIT09IDApIHJldHVybiBvRGF5IDw9IDM2NjtcbiAgICByZXR1cm4gb0RheSA8PSAzNjU7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goLyhcXGR7NH0pLT8oXFxkezAsMn0pLT8oXFxkKikvKS5tYXAoTnVtYmVyKTtcbiAgdmFyIHllYXIgPSBtYXRjaFsxXTtcbiAgdmFyIG1vbnRoID0gbWF0Y2hbMl07XG4gIHZhciBkYXkgPSBtYXRjaFszXTtcbiAgdmFyIG1vbnRoU3RyaW5nID0gbW9udGggPyBcIjBcIi5jb25jYXQobW9udGgpLnNsaWNlKC0yKSA6IG1vbnRoO1xuICB2YXIgZGF5U3RyaW5nID0gZGF5ID8gXCIwXCIuY29uY2F0KGRheSkuc2xpY2UoLTIpIDogZGF5OyAvLyBjcmVhdGUgYSBkYXRlIG9iamVjdCBhbmQgY29tcGFyZVxuXG4gIHZhciBkID0gbmV3IERhdGUoXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aFN0cmluZyB8fCAnMDEnLCBcIi1cIikuY29uY2F0KGRheVN0cmluZyB8fCAnMDEnKSk7XG4gIGlmIChpc05hTihkLmdldFVUQ0Z1bGxZZWFyKCkpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKG1vbnRoICYmIGRheSkge1xuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZC5nZXRVVENNb250aCgpICsgMSA9PT0gbW9udGggJiYgZC5nZXRVVENEYXRlKCkgPT09IGRheTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNJU084NjAxKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgY2hlY2sgPSBpc284NjAxLnRlc3Qoc3RyKTtcbiAgaWYgKCFvcHRpb25zKSByZXR1cm4gY2hlY2s7XG4gIGlmIChjaGVjayAmJiBvcHRpb25zLnN0cmljdCkgcmV0dXJuIGlzVmFsaWREYXRlKHN0cik7XG4gIHJldHVybiBjaGVjaztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJU1JDO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBzZWUgaHR0cDovL2lzcmMuaWZwaS5vcmcvZW4vaXNyYy1zdGFuZGFyZC9jb2RlLXN5bnRheFxudmFyIGlzcmMgPSAvXltBLVpdezJ9WzAtOUEtWl17M31cXGR7Mn1cXGR7NX0kLztcblxuZnVuY3Rpb24gaXNJU1JDKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gaXNyYy50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSVNTTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzc24gPSAnXlxcXFxkezR9LT9cXFxcZHszfVtcXFxcZFhdJCc7XG5cbmZ1bmN0aW9uIGlzSVNTTihzdHIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgdGVzdElzc24gPSBpc3NuO1xuICB0ZXN0SXNzbiA9IG9wdGlvbnMucmVxdWlyZV9oeXBoZW4gPyB0ZXN0SXNzbi5yZXBsYWNlKCc/JywgJycpIDogdGVzdElzc247XG4gIHRlc3RJc3NuID0gb3B0aW9ucy5jYXNlX3NlbnNpdGl2ZSA/IG5ldyBSZWdFeHAodGVzdElzc24pIDogbmV3IFJlZ0V4cCh0ZXN0SXNzbiwgJ2knKTtcblxuICBpZiAoIXRlc3RJc3NuLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkaWdpdHMgPSBzdHIucmVwbGFjZSgnLScsICcnKS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgY2hlY2tzdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgIGNoZWNrc3VtICs9IChkaWdpdCA9PT0gJ1gnID8gMTAgOiArZGlnaXQpICogKDggLSBpKTtcbiAgfVxuXG4gIHJldHVybiBjaGVja3N1bSAlIDExID09PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0lkZW50aXR5Q2FyZDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHZhbGlkYXRvcnMgPSB7XG4gIEVTOiBmdW5jdGlvbiBFUyhzdHIpIHtcbiAgICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICAgIHZhciBETkkgPSAvXlswLTlYLVpdWzAtOV17N31bVFJXQUdNWUZQRFhCTkpaU1FWSExDS0VdJC87XG4gICAgdmFyIGNoYXJzVmFsdWUgPSB7XG4gICAgICBYOiAwLFxuICAgICAgWTogMSxcbiAgICAgIFo6IDJcbiAgICB9O1xuICAgIHZhciBjb250cm9sRGlnaXRzID0gWydUJywgJ1InLCAnVycsICdBJywgJ0cnLCAnTScsICdZJywgJ0YnLCAnUCcsICdEJywgJ1gnLCAnQicsICdOJywgJ0onLCAnWicsICdTJywgJ1EnLCAnVicsICdIJywgJ0wnLCAnQycsICdLJywgJ0UnXTsgLy8gc2FuaXRpemUgdXNlciBpbnB1dFxuXG4gICAgdmFyIHNhbml0aXplZCA9IHN0ci50cmltKCkudG9VcHBlckNhc2UoKTsgLy8gdmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlXG5cbiAgICBpZiAoIUROSS50ZXN0KHNhbml0aXplZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHZhbGlkYXRlIHRoZSBjb250cm9sIGRpZ2l0XG5cblxuICAgIHZhciBudW1iZXIgPSBzYW5pdGl6ZWQuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL1tYLFksWl0vZywgZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgIHJldHVybiBjaGFyc1ZhbHVlW2NoYXJdO1xuICAgIH0pO1xuICAgIHJldHVybiBzYW5pdGl6ZWQuZW5kc1dpdGgoY29udHJvbERpZ2l0c1tudW1iZXIgJSAyM10pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc0lkZW50aXR5Q2FyZChzdHIpIHtcbiAgdmFyIGxvY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FueSc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiB2YWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnNbbG9jYWxlXShzdHIpO1xuICB9IGVsc2UgaWYgKGxvY2FsZSA9PT0gJ2FueScpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsaWRhdG9ycykge1xuICAgICAgaWYgKHZhbGlkYXRvcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gdmFsaWRhdG9yc1trZXldO1xuXG4gICAgICAgIGlmICh2YWxpZGF0b3Ioc3RyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2NhbGUgJ1wiLmNvbmNhdChsb2NhbGUsIFwiJ1wiKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW47XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfdG9TdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvdG9TdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc0luKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgaTtcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKGkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgYXJyYXlbaV0gPSAoMCwgX3RvU3RyaW5nLmRlZmF1bHQpKG9wdGlvbnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheS5pbmRleE9mKHN0cikgPj0gMDtcbiAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRpb25zLmhhc093blByb3BlcnR5KHN0cik7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaW5kZXhPZihzdHIpID49IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW50O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaW50ID0gL14oPzpbLStdPyg/OjB8WzEtOV1bMC05XSopKSQvO1xudmFyIGludExlYWRpbmdaZXJvZXMgPSAvXlstK10/WzAtOV0rJC87XG5cbmZ1bmN0aW9uIGlzSW50KHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gR2V0IHRoZSByZWdleCB0byB1c2UgZm9yIHRlc3RpbmcsIGJhc2VkIG9uIHdoZXRoZXJcbiAgLy8gbGVhZGluZyB6ZXJvZXMgYXJlIGFsbG93ZWQgb3Igbm90LlxuXG4gIHZhciByZWdleCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2FsbG93X2xlYWRpbmdfemVyb2VzJykgJiYgIW9wdGlvbnMuYWxsb3dfbGVhZGluZ196ZXJvZXMgPyBpbnQgOiBpbnRMZWFkaW5nWmVyb2VzOyAvLyBDaGVjayBtaW4vbWF4L2x0L2d0XG5cbiAgdmFyIG1pbkNoZWNrUGFzc2VkID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21pbicpIHx8IHN0ciA+PSBvcHRpb25zLm1pbjtcbiAgdmFyIG1heENoZWNrUGFzc2VkID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ21heCcpIHx8IHN0ciA8PSBvcHRpb25zLm1heDtcbiAgdmFyIGx0Q2hlY2tQYXNzZWQgPSAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbHQnKSB8fCBzdHIgPCBvcHRpb25zLmx0O1xuICB2YXIgZ3RDaGVja1Bhc3NlZCA9ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdndCcpIHx8IHN0ciA+IG9wdGlvbnMuZ3Q7XG4gIHJldHVybiByZWdleC50ZXN0KHN0cikgJiYgbWluQ2hlY2tQYXNzZWQgJiYgbWF4Q2hlY2tQYXNzZWQgJiYgbHRDaGVja1Bhc3NlZCAmJiBndENoZWNrUGFzc2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0pTT047XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGlzSlNPTihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICB0cnkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gICAgcmV0dXJuICEhb2JqICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBpZ25vcmUgKi9cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNKV1Q7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBqd3QgPSAvXihbQS1aYS16MC05XFwtX34rXFwvXStbPV17MCwyfSlcXC4oW0EtWmEtejAtOVxcLV9+K1xcL10rWz1dezAsMn0pKD86XFwuKFtBLVphLXowLTlcXC1ffitcXC9dK1s9XXswLDJ9KSk/JC87XG5cbmZ1bmN0aW9uIGlzSldUKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gand0LnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBsYXQgPSAvXlxcKD9bKy1dPyg5MChcXC4wKyk/fFsxLThdP1xcZChcXC5cXGQrKT8pJC87XG52YXIgbG9uZyA9IC9eXFxzP1srLV0/KDE4MChcXC4wKyk/fDFbMC03XVxcZChcXC5cXGQrKT98XFxkezEsMn0oXFwuXFxkKyk/KVxcKT8kLztcblxuZnVuY3Rpb24gX2RlZmF1bHQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIGlmICghc3RyLmluY2x1ZGVzKCcsJykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHBhaXIgPSBzdHIuc3BsaXQoJywnKTtcbiAgcmV0dXJuIGxhdC50ZXN0KHBhaXJbMF0pICYmIGxvbmcudGVzdChwYWlyWzFdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNMZW5ndGg7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuZnVuY3Rpb24gaXNMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNMZW5ndGgoc3RyLCBtaW4gWywgbWF4XSlcbiAgICBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgdmFyIHN1cnJvZ2F0ZVBhaXJzID0gc3RyLm1hdGNoKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2cpIHx8IFtdO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aCAtIHN1cnJvZ2F0ZVBhaXJzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbiA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IGxlbiA8PSBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0xvd2VyY2FzZTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNMb3dlcmNhc2Uoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiBzdHIgPT09IHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01BQ0FkZHJlc3M7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtYWNBZGRyZXNzID0gL14oWzAtOWEtZkEtRl1bMC05YS1mQS1GXTopezV9KFswLTlhLWZBLUZdWzAtOWEtZkEtRl0pJC87XG52YXIgbWFjQWRkcmVzc05vQ29sb25zID0gL14oWzAtOWEtZkEtRl0pezEyfSQvO1xuXG5mdW5jdGlvbiBpc01BQ0FkZHJlc3Moc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19jb2xvbnMpIHtcbiAgICByZXR1cm4gbWFjQWRkcmVzc05vQ29sb25zLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHJldHVybiBtYWNBZGRyZXNzLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNRDU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtZDUgPSAvXlthLWYwLTldezMyfSQvO1xuXG5mdW5jdGlvbiBpc01ENShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIG1kNS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTWFnbmV0VVJJO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbWFnbmV0VVJJID0gL15tYWduZXQ6XFw/eHQ9dXJuOlthLXowLTldKzpbYS16MC05XXszMiw0MH0mZG49LismdHI9LiskL2k7XG5cbmZ1bmN0aW9uIGlzTWFnbmV0VVJJKHVybCkge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KSh1cmwpO1xuICByZXR1cm4gbWFnbmV0VVJJLnRlc3QodXJsLnRyaW0oKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTWltZVR5cGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qXG4gIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgc3RyaW5nIG1hdGNoZXMgdG8gYSBjb3JyZWN0IE1lZGlhIHR5cGUgZm9ybWF0IChNSU1FIHR5cGUpXG5cbiAgVGhpcyBmdW5jdGlvbiBvbmx5IGNoZWNrcyBpcyB0aGUgc3RyaW5nIGZvcm1hdCBmb2xsb3dzIHRoZVxuICBldGFibGlzaGVkIHJ1bGVzIGJ5IHRoZSBhY2NvcmRpbmcgUkZDIHNwZWNpZmljYXRpb25zLlxuICBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzICdjaGFyc2V0JyBpbiB0ZXh0dWFsIG1lZGlhIHR5cGVzXG4gIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY1NykuXG5cbiAgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayBhZ2FpbnN0IGFsbCB0aGUgbWVkaWEgdHlwZXMgbGlzdGVkXG4gIGJ5IHRoZSBJQU5BIChodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9tZWRpYS10eXBlcy54aHRtbClcbiAgYmVjYXVzZSBvZiBsaWdodG5lc3MgcHVycG9zZXMgOiBpdCB3b3VsZCByZXF1aXJlIHRvIGluY2x1ZGVcbiAgYWxsIHRoZXNlIE1JTUUgdHlwZXMgaW4gdGhpcyBsaWJyYWlyeSwgd2hpY2ggd291bGQgd2VpZ2ggaXRcbiAgc2lnbmlmaWNhbnRseS4gVGhpcyBraW5kIG9mIGVmZm9ydCBtYXliZSBpcyBub3Qgd29ydGggZm9yIHRoZSB1c2UgdGhhdFxuICB0aGlzIGZ1bmN0aW9uIGhhcyBpbiB0aGlzIGVudGlyZSBsaWJyYWlyeS5cblxuICBNb3JlIGluZm9ybWF0aW9ucyBpbiB0aGUgUkZDIHNwZWNpZmljYXRpb25zIDpcbiAgLSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0NVxuICAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMDQ2XG4gIC0gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi0zLjEuMS4xXG4gIC0gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi0zLjEuMS41XG4qL1xuLy8gTWF0Y2ggc2ltcGxlIE1JTUUgdHlwZXNcbi8vIE5CIDpcbi8vICAgU3VidHlwZSBsZW5ndGggbXVzdCBub3QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLlxuLy8gICBUaGlzIHJ1bGUgZG9lcyBub3QgY29tcGx5IHRvIHRoZSBSRkMgc3BlY3MgKHdoYXQgaXMgdGhlIG1heCBsZW5ndGggPykuXG52YXIgbWltZVR5cGVTaW1wbGUgPSAvXihhcHBsaWNhdGlvbnxhdWRpb3xmb250fGltYWdlfG1lc3NhZ2V8bW9kZWx8bXVsdGlwYXJ0fHRleHR8dmlkZW8pXFwvW2EtekEtWjAtOVxcLlxcLVxcK117MSwxMDB9JC9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbi8vIEhhbmRsZSBcImNoYXJzZXRcIiBpbiBcInRleHQvKlwiXG5cbnZhciBtaW1lVHlwZVRleHQgPSAvXnRleHRcXC9bYS16QS1aMC05XFwuXFwtXFwrXXsxLDEwMH07XFxzP2NoYXJzZXQ9KFwiW2EtekEtWjAtOVxcLlxcLVxcK1xcc117MCw3MH1cInxbYS16QS1aMC05XFwuXFwtXFwrXXswLDcwfSkoXFxzP1xcKFthLXpBLVowLTlcXC5cXC1cXCtcXHNdezEsMjB9XFwpKT8kL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuLy8gSGFuZGxlIFwiYm91bmRhcnlcIiBpbiBcIm11bHRpcGFydC8qXCJcblxudmFyIG1pbWVUeXBlTXVsdGlwYXJ0ID0gL15tdWx0aXBhcnRcXC9bYS16QS1aMC05XFwuXFwtXFwrXXsxLDEwMH0oO1xccz8oYm91bmRhcnl8Y2hhcnNldCk9KFwiW2EtekEtWjAtOVxcLlxcLVxcK1xcc117MCw3MH1cInxbYS16QS1aMC05XFwuXFwtXFwrXXswLDcwfSkoXFxzP1xcKFthLXpBLVowLTlcXC5cXC1cXCtcXHNdezEsMjB9XFwpKT8pezAsMn0kL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXG5mdW5jdGlvbiBpc01pbWVUeXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gbWltZVR5cGVTaW1wbGUudGVzdChzdHIpIHx8IG1pbWVUeXBlVGV4dC50ZXN0KHN0cikgfHwgbWltZVR5cGVNdWx0aXBhcnQudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc01vYmlsZVBob25lO1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgcGhvbmVzID0ge1xuICAnYXItQUUnOiAvXigoXFwrPzk3MSl8MCk/NVswMjQ1NjhdXFxkezd9JC8sXG4gICdhci1EWic6IC9eKFxcKz8yMTN8MCkoNXw2fDcpXFxkezh9JC8sXG4gICdhci1FRyc6IC9eKChcXCs/MjApfDApPzFbMDEyXVxcZHs4fSQvLFxuICAnYXItSVEnOiAvXihcXCs/OTY0fDApPzdbMC05XVxcZHs4fSQvLFxuICAnYXItSk8nOiAvXihcXCs/OTYyfDApPzdbNzg5XVxcZHs3fSQvLFxuICAnYXItS1cnOiAvXihcXCs/OTY1KVs1NjldXFxkezd9JC8sXG4gICdhci1TQSc6IC9eKCE/KFxcKz85NjYpfDApPzVcXGR7OH0kLyxcbiAgJ2FyLVNZJzogL14oIT8oXFwrPzk2Myl8MCk/OVxcZHs4fSQvLFxuICAnYXItVE4nOiAvXihcXCs/MjE2KT9bMjQ1OV1cXGR7N30kLyxcbiAgJ2JlLUJZJzogL14oXFwrPzM3NSk/KDI0fDI1fDI5fDMzfDQ0KVxcZHs3fSQvLFxuICAnYmctQkcnOiAvXihcXCs/MzU5fDApPzhbNzg5XVxcZHs3fSQvLFxuICAnYm4tQkQnOiAvXFwrPyg4OCk/MD8xWzM1Njc4OV1bMC05XXs4fVxcYi8sXG4gICdjcy1DWic6IC9eKFxcKz80MjApPyA/WzEtOV1bMC05XXsyfSA/WzAtOV17M30gP1swLTldezN9JC8sXG4gICdkYS1ESyc6IC9eKFxcKz80NSk/XFxzP1xcZHsyfVxccz9cXGR7Mn1cXHM/XFxkezJ9XFxzP1xcZHsyfSQvLFxuICAnZGUtREUnOiAvXihcXCs0OSk/MD8xKDVbMC0yNS05XVxcZHw2KFsyM118MFxcZD8pfDcoWzAtNTctOV18NlxcZCkpXFxkezd9JC8sXG4gICdlbC1HUic6IC9eKFxcKz8zMHwwKT8oNjlcXGR7OH0pJC8sXG4gICdlbi1BVSc6IC9eKFxcKz82MXwwKTRcXGR7OH0kLyxcbiAgJ2VuLUdCJzogL14oXFwrPzQ0fDApN1xcZHs5fSQvLFxuICAnZW4tR0gnOiAvXihcXCsyMzN8MCkoMjB8NTB8MjR8NTR8Mjd8NTd8MjZ8NTZ8MjN8MjgpXFxkezd9JC8sXG4gICdlbi1ISyc6IC9eKFxcKz84NTJcXC0/KT9bNDU2Nzg5XVxcZHszfVxcLT9cXGR7NH0kLyxcbiAgJ2VuLUlFJzogL14oXFwrPzM1M3wwKThbMzU2Nzg5XVxcZHs3fSQvLFxuICAnZW4tSU4nOiAvXihcXCs/OTF8MCk/WzY3ODldXFxkezl9JC8sXG4gICdlbi1LRSc6IC9eKFxcKz8yNTR8MCk/WzddXFxkezh9JC8sXG4gICdlbi1NVSc6IC9eKFxcKz8yMzB8MCk/XFxkezh9JC8sXG4gICdlbi1ORyc6IC9eKFxcKz8yMzR8MCk/Wzc4OV1cXGR7OX0kLyxcbiAgJ2VuLU5aJzogL14oXFwrPzY0fDApWzI4XVxcZHs3LDl9JC8sXG4gICdlbi1QSyc6IC9eKChcXCs5Mil8KDAwOTIpKS17MCwxfVxcZHszfS17MCwxfVxcZHs3fSR8XlxcZHsxMX0kfF5cXGR7NH0tXFxkezd9JC8sXG4gICdlbi1SVyc6IC9eKFxcKz8yNTB8MCk/WzddXFxkezh9JC8sXG4gICdlbi1TRyc6IC9eKFxcKzY1KT9bODldXFxkezd9JC8sXG4gICdlbi1UWic6IC9eKFxcKz8yNTV8MCk/WzY3XVxcZHs4fSQvLFxuICAnZW4tVUcnOiAvXihcXCs/MjU2fDApP1s3XVxcZHs4fSQvLFxuICAnZW4tVVMnOiAvXigoXFwrMXwxKT8oIHwtKT8pPyhcXChbMi05XVswLTldezJ9XFwpfFsyLTldWzAtOV17Mn0pKCB8LSk/KFsyLTldWzAtOV17Mn0oIHwtKT9bMC05XXs0fSkkLyxcbiAgJ2VuLVpBJzogL14oXFwrPzI3fDApXFxkezl9JC8sXG4gICdlbi1aTSc6IC9eKFxcKz8yNik/MDlbNTY3XVxcZHs3fSQvLFxuICAnZXMtRVMnOiAvXihcXCs/MzQpPyg2XFxkezF9fDdbMTIzNF0pXFxkezd9JC8sXG4gICdlcy1NWCc6IC9eKFxcKz81Mik/KDF8MDEpP1xcZHsxMCwxMX0kLyxcbiAgJ2VzLVVZJzogL14oXFwrNTk4fDApOVsxLTldW1xcZF17Nn0kLyxcbiAgJ2V0LUVFJzogL14oXFwrPzM3Mik/XFxzPyg1fDhbMS00XSlcXHM/KFswLTldXFxzPyl7Niw3fSQvLFxuICAnZmEtSVInOiAvXihcXCs/OThbXFwtXFxzXT98MCk5WzAtMzldXFxkW1xcLVxcc10/XFxkezN9W1xcLVxcc10/XFxkezR9JC8sXG4gICdmaS1GSSc6IC9eKFxcKz8zNTh8MClcXHM/KDQoMHwxfDJ8NHw1fDYpP3w1MClcXHM/KFxcZFxccz8pezQsOH1cXGQkLyxcbiAgJ2ZvLUZPJzogL14oXFwrPzI5OCk/XFxzP1xcZHsyfVxccz9cXGR7Mn1cXHM/XFxkezJ9JC8sXG4gICdmci1GUic6IC9eKFxcKz8zM3wwKVs2N11cXGR7OH0kLyxcbiAgJ2hlLUlMJzogL14oXFwrOTcyfDApKFsyMzQ4OV18NVswMTIzNDU2ODldfDc3KVsxLTldXFxkezZ9JC8sXG4gICdodS1IVSc6IC9eKFxcKz8zNikoMjB8MzB8NzApXFxkezd9JC8sXG4gICdpZC1JRCc6IC9eKFxcKz82MnwwKTgoMVsxMjM0NTY3ODldfDJbMTIzOF18M1sxMjM4XXw1WzEyMzU2Nzg5XXw3Wzc4XXw5WzU2Nzg5XXw4WzEyMzQ1Njc4OV0pKFtcXHM/fFxcZF17NSwxMX0pJC8sXG4gICdpdC1JVCc6IC9eKFxcKz8zOSk/XFxzPzNcXGR7Mn0gP1xcZHs2LDd9JC8sXG4gICdqYS1KUCc6IC9eKFxcKz84MXwwKVs3ODldMFsgXFwtXT9bMS05XVxcZHsyfVsgXFwtXT9cXGR7NX0kLyxcbiAgJ2trLUtaJzogL14oXFwrPzd8OCk/N1xcZHs5fSQvLFxuICAna2wtR0wnOiAvXihcXCs/Mjk5KT9cXHM/XFxkezJ9XFxzP1xcZHsyfVxccz9cXGR7Mn0kLyxcbiAgJ2tvLUtSJzogL14oKFxcKz84MilbIFxcLV0/KT8wPzEoWzB8MXw2fDd8OHw5XXsxfSlbIFxcLV0/XFxkezMsNH1bIFxcLV0/XFxkezR9JC8sXG4gICdsdC1MVCc6IC9eKFxcKzM3MHw4KVxcZHs4fSQvLFxuICAnbXMtTVknOiAvXihcXCs/Nj8wMSl7MX0oKFswMTQ1XXsxfShcXC18XFxzKT9cXGR7Nyw4fSl8KFsyMzY3ODldezF9KFxcc3xcXC0pP1xcZHs3fSkpJC8sXG4gICduYi1OTyc6IC9eKFxcKz80Nyk/WzQ5XVxcZHs3fSQvLFxuICAnbmwtQkUnOiAvXihcXCs/MzJ8MCk0P1xcZHs4fSQvLFxuICAnbm4tTk8nOiAvXihcXCs/NDcpP1s0OV1cXGR7N30kLyxcbiAgJ3BsLVBMJzogL14oXFwrPzQ4KT8gP1s1LThdXFxkID9cXGR7M30gP1xcZHsyfSA/XFxkezJ9JC8sXG4gICdwdC1CUic6IC8oPz1eKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtP1xcZHs0fVxcLT9cXGR7NH0kKSheKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtP1s2LTldezF9XFxkezN9XFwtP1xcZHs0fSQpfCheKFxcKz81ezJ9XFwtP3wwKVsxLTldezJ9XFwtPzlbNi05XXsxfVxcZHszfVxcLT9cXGR7NH0kKS8sXG4gICdwdC1QVCc6IC9eKFxcKz8zNTEpPzlbMTIzNl1cXGR7N30kLyxcbiAgJ3JvLVJPJzogL14oXFwrPzQ/MClcXHM/N1xcZHsyfShcXC98XFxzfFxcLnxcXC0pP1xcZHszfShcXHN8XFwufFxcLSk/XFxkezN9JC8sXG4gICdydS1SVSc6IC9eKFxcKz83fDgpPzlcXGR7OX0kLyxcbiAgJ3NsLVNJJzogL14oXFwrMzg2XFxzP3wwKShcXGR7MX1cXHM/XFxkezN9XFxzP1xcZHsyfVxccz9cXGR7Mn18XFxkezJ9XFxzP1xcZHszfVxccz9cXGR7M30pJC8sXG4gICdzay1TSyc6IC9eKFxcKz80MjEpPyA/WzEtOV1bMC05XXsyfSA/WzAtOV17M30gP1swLTldezN9JC8sXG4gICdzci1SUyc6IC9eKFxcKzM4MTZ8MDYpWy0gXFxkXXs1LDl9JC8sXG4gICdzdi1TRSc6IC9eKFxcKz80NnwwKVtcXHNcXC1dPzdbXFxzXFwtXT9bMDIzNjldKFtcXHNcXC1dP1xcZCl7N30kLyxcbiAgJ3RoLVRIJzogL14oXFwrNjZ8NjZ8MClcXGR7OX0kLyxcbiAgJ3RyLVRSJzogL14oXFwrPzkwfDApPzVcXGR7OX0kLyxcbiAgJ3VrLVVBJzogL14oXFwrPzM4fDgpPzBcXGR7OX0kLyxcbiAgJ3ZpLVZOJzogL14oXFwrPzg0fDApKCgzKFsyLTldKSl8KDUoWzY4OV0pKXwoNyhbMHw2LTldKSl8KDgoWzEtNV0pKXwoOShbMC05XSkpKShbMC05XXs3fSkkLyxcbiAgJ3poLUNOJzogL14oKFxcK3wwMCk4Nik/MShbMzU4XVswLTldfDRbNTc5XXw2Nnw3WzAxMzU2NzhdfDlbODldKVswLTldezh9JC8sXG4gICd6aC1UVyc6IC9eKFxcKz84ODZcXC0/fDApPzlcXGR7OH0kL1xufTtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLy8gYWxpYXNlc1xuXG5waG9uZXNbJ2VuLUNBJ10gPSBwaG9uZXNbJ2VuLVVTJ107XG5waG9uZXNbJ2ZyLUJFJ10gPSBwaG9uZXNbJ25sLUJFJ107XG5waG9uZXNbJ3poLUhLJ10gPSBwaG9uZXNbJ2VuLUhLJ107XG5cbmZ1bmN0aW9uIGlzTW9iaWxlUGhvbmUoc3RyLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdE1vZGUgJiYgIXN0ci5zdGFydHNXaXRoKCcrJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbGUpKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChwaG9uZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgcGhvbmUgPSBwaG9uZXNba2V5XTtcblxuICAgICAgICBpZiAocGhvbmUudGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvY2FsZSBpbiBwaG9uZXMpIHtcbiAgICByZXR1cm4gcGhvbmVzW2xvY2FsZV0udGVzdChzdHIpOyAvLyBhbGlhcyBmYWxzZXkgbG9jYWxlIGFzICdhbnknXG4gIH0gZWxzZSBpZiAoIWxvY2FsZSB8fCBsb2NhbGUgPT09ICdhbnknKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHBob25lcykge1xuICAgICAgaWYgKHBob25lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBwaG9uZSA9IHBob25lc1trZXldO1xuXG4gICAgICAgIGlmIChwaG9uZS50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlICdcIi5jb25jYXQobG9jYWxlLCBcIidcIikpO1xufVxuXG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKHBob25lcyk7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNb25nb0lkO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG52YXIgX2lzSGV4YWRlY2ltYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzSGV4YWRlY2ltYWxcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc01vbmdvSWQoc3RyKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHJldHVybiAoMCwgX2lzSGV4YWRlY2ltYWwuZGVmYXVsdCkoc3RyKSAmJiBzdHIubGVuZ3RoID09PSAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNNdWx0aWJ5dGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbnZhciBtdWx0aWJ5dGUgPSAvW15cXHgwMC1cXHg3Rl0vO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmZ1bmN0aW9uIGlzTXVsdGlieXRlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gbXVsdGlieXRlLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOdW1lcmljO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbnVtZXJpYyA9IC9eWystXT8oWzAtOV0qWy5dKT9bMC05XSskLztcbnZhciBudW1lcmljTm9TeW1ib2xzID0gL15bMC05XSskLztcblxuZnVuY3Rpb24gaXNOdW1lcmljKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fc3ltYm9scykge1xuICAgIHJldHVybiBudW1lcmljTm9TeW1ib2xzLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHJldHVybiBudW1lcmljLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQb3J0O1xuXG52YXIgX2lzSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0ludFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzUG9ydChzdHIpIHtcbiAgcmV0dXJuICgwLCBfaXNJbnQuZGVmYXVsdCkoc3RyLCB7XG4gICAgbWluOiAwLFxuICAgIG1heDogNjU1MzVcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5sb2NhbGVzID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBjb21tb24gcGF0dGVybnNcbnZhciB0aHJlZURpZ2l0ID0gL15cXGR7M30kLztcbnZhciBmb3VyRGlnaXQgPSAvXlxcZHs0fSQvO1xudmFyIGZpdmVEaWdpdCA9IC9eXFxkezV9JC87XG52YXIgc2l4RGlnaXQgPSAvXlxcZHs2fSQvO1xudmFyIHBhdHRlcm5zID0ge1xuICBBRDogL15BRFxcZHszfSQvLFxuICBBVDogZm91ckRpZ2l0LFxuICBBVTogZm91ckRpZ2l0LFxuICBCRTogZm91ckRpZ2l0LFxuICBCRzogZm91ckRpZ2l0LFxuICBDQTogL15bQUJDRUdISktMTU5QUlNUVlhZXVxcZFtBQkNFR0hKLU5QUlNUVi1aXVtcXHNcXC1dP1xcZFtBQkNFR0hKLU5QUlNUVi1aXVxcZCQvaSxcbiAgQ0g6IGZvdXJEaWdpdCxcbiAgQ1o6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBERTogZml2ZURpZ2l0LFxuICBESzogZm91ckRpZ2l0LFxuICBEWjogZml2ZURpZ2l0LFxuICBFRTogZml2ZURpZ2l0LFxuICBFUzogZml2ZURpZ2l0LFxuICBGSTogZml2ZURpZ2l0LFxuICBGUjogL15cXGR7Mn1cXHM/XFxkezN9JC8sXG4gIEdCOiAvXihnaXJcXHM/MGFhfFthLXpdezEsMn1cXGRbXFxkYS16XT9cXHM/KFxcZFthLXpdezJ9KT8pJC9pLFxuICBHUjogL15cXGR7M31cXHM/XFxkezJ9JC8sXG4gIEhSOiAvXihbMS01XVxcZHs0fSQpLyxcbiAgSFU6IGZvdXJEaWdpdCxcbiAgSUw6IGZpdmVEaWdpdCxcbiAgSU46IHNpeERpZ2l0LFxuICBJUzogdGhyZWVEaWdpdCxcbiAgSVQ6IGZpdmVEaWdpdCxcbiAgSlA6IC9eXFxkezN9XFwtXFxkezR9JC8sXG4gIEtFOiBmaXZlRGlnaXQsXG4gIExJOiAvXig5NDhbNS05XXw5NDlbMC03XSkkLyxcbiAgTFQ6IC9eTFRcXC1cXGR7NX0kLyxcbiAgTFU6IGZvdXJEaWdpdCxcbiAgTFY6IC9eTFZcXC1cXGR7NH0kLyxcbiAgTVg6IGZpdmVEaWdpdCxcbiAgTkw6IC9eXFxkezR9XFxzP1thLXpdezJ9JC9pLFxuICBOTzogZm91ckRpZ2l0LFxuICBQTDogL15cXGR7Mn1cXC1cXGR7M30kLyxcbiAgUFQ6IC9eXFxkezR9XFwtXFxkezN9PyQvLFxuICBSTzogc2l4RGlnaXQsXG4gIFJVOiBzaXhEaWdpdCxcbiAgU0E6IGZpdmVEaWdpdCxcbiAgU0U6IC9eXFxkezN9XFxzP1xcZHsyfSQvLFxuICBTSTogZm91ckRpZ2l0LFxuICBTSzogL15cXGR7M31cXHM/XFxkezJ9JC8sXG4gIFROOiBmb3VyRGlnaXQsXG4gIFRXOiAvXlxcZHszfShcXGR7Mn0pPyQvLFxuICBVQTogZml2ZURpZ2l0LFxuICBVUzogL15cXGR7NX0oLVxcZHs0fSk/JC8sXG4gIFpBOiBmb3VyRGlnaXQsXG4gIFpNOiBmaXZlRGlnaXRcbn07XG52YXIgbG9jYWxlcyA9IE9iamVjdC5rZXlzKHBhdHRlcm5zKTtcbmV4cG9ydHMubG9jYWxlcyA9IGxvY2FsZXM7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHN0ciwgbG9jYWxlKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKGxvY2FsZSBpbiBwYXR0ZXJucykge1xuICAgIHJldHVybiBwYXR0ZXJuc1tsb2NhbGVdLnRlc3Qoc3RyKTtcbiAgfSBlbHNlIGlmIChsb2NhbGUgPT09ICdhbnknKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHBhdHRlcm5zKSB7XG4gICAgICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2tleV07XG5cbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvY2FsZSAnXCIuY29uY2F0KGxvY2FsZSwgXCInXCIpKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUkZDMzMzOTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogQmFzZWQgb24gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjYgKi9cbnZhciBkYXRlRnVsbFllYXIgPSAvWzAtOV17NH0vO1xudmFyIGRhdGVNb250aCA9IC8oMFsxLTldfDFbMC0yXSkvO1xudmFyIGRhdGVNRGF5ID0gLyhbMTJdXFxkfDBbMS05XXwzWzAxXSkvO1xudmFyIHRpbWVIb3VyID0gLyhbMDFdWzAtOV18MlswLTNdKS87XG52YXIgdGltZU1pbnV0ZSA9IC9bMC01XVswLTldLztcbnZhciB0aW1lU2Vjb25kID0gLyhbMC01XVswLTldfDYwKS87XG52YXIgdGltZVNlY0ZyYWMgPSAvKFxcLlswLTldKyk/LztcbnZhciB0aW1lTnVtT2Zmc2V0ID0gbmV3IFJlZ0V4cChcIlstK11cIi5jb25jYXQodGltZUhvdXIuc291cmNlLCBcIjpcIikuY29uY2F0KHRpbWVNaW51dGUuc291cmNlKSk7XG52YXIgdGltZU9mZnNldCA9IG5ldyBSZWdFeHAoXCIoW3paXXxcIi5jb25jYXQodGltZU51bU9mZnNldC5zb3VyY2UsIFwiKVwiKSk7XG52YXIgcGFydGlhbFRpbWUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHRpbWVIb3VyLnNvdXJjZSwgXCI6XCIpLmNvbmNhdCh0aW1lTWludXRlLnNvdXJjZSwgXCI6XCIpLmNvbmNhdCh0aW1lU2Vjb25kLnNvdXJjZSkuY29uY2F0KHRpbWVTZWNGcmFjLnNvdXJjZSkpO1xudmFyIGZ1bGxEYXRlID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChkYXRlRnVsbFllYXIuc291cmNlLCBcIi1cIikuY29uY2F0KGRhdGVNb250aC5zb3VyY2UsIFwiLVwiKS5jb25jYXQoZGF0ZU1EYXkuc291cmNlKSk7XG52YXIgZnVsbFRpbWUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHBhcnRpYWxUaW1lLnNvdXJjZSkuY29uY2F0KHRpbWVPZmZzZXQuc291cmNlKSk7XG52YXIgcmZjMzMzOSA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoZnVsbERhdGUuc291cmNlLCBcIlsgdFRdXCIpLmNvbmNhdChmdWxsVGltZS5zb3VyY2UpKTtcblxuZnVuY3Rpb24gaXNSRkMzMzM5KHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gcmZjMzMzOS50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzU3Vycm9nYXRlUGFpcjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cnJvZ2F0ZVBhaXIgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS87XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN1cnJvZ2F0ZVBhaXIudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VSTDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pc0ZRRE4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzRlFETlwiKSk7XG5cbnZhciBfaXNJUCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNJUFwiKSk7XG5cbnZhciBfbWVyZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWVyZ2VcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF91cmxfb3B0aW9ucyA9IHtcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJ10sXG4gIHJlcXVpcmVfdGxkOiB0cnVlLFxuICByZXF1aXJlX3Byb3RvY29sOiBmYWxzZSxcbiAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICByZXF1aXJlX3ZhbGlkX3Byb3RvY29sOiB0cnVlLFxuICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gIGFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHM6IGZhbHNlXG59O1xudmFyIHdyYXBwZWRfaXB2NiA9IC9eXFxbKFteXFxdXSspXFxdKD86OihbMC05XSspKT8kLztcblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG5cbiAgICBpZiAoaG9zdCA9PT0gbWF0Y2ggfHwgaXNSZWdFeHAobWF0Y2gpICYmIG1hdGNoLnRlc3QoaG9zdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVUkwodXJsLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHVybCk7XG5cbiAgaWYgKCF1cmwgfHwgdXJsLmxlbmd0aCA+PSAyMDgzIHx8IC9bXFxzPD5dLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodXJsLmluZGV4T2YoJ21haWx0bzonKSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG9wdGlvbnMgPSAoMCwgX21lcmdlLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfdXJsX29wdGlvbnMpO1xuICB2YXIgcHJvdG9jb2wsIGF1dGgsIGhvc3QsIGhvc3RuYW1lLCBwb3J0LCBwb3J0X3N0ciwgc3BsaXQsIGlwdjY7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCcjJyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc/Jyk7XG4gIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc6Ly8nKTtcblxuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIHByb3RvY29sID0gc3BsaXQuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZV92YWxpZF9wcm90b2NvbCAmJiBvcHRpb25zLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX3Byb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJscykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNwbGl0WzBdID0gdXJsLnN1YnN0cigyKTtcbiAgfVxuXG4gIHVybCA9IHNwbGl0LmpvaW4oJzovLycpO1xuXG4gIGlmICh1cmwgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcblxuICBpZiAodXJsID09PSAnJyAmJiAhb3B0aW9ucy5yZXF1aXJlX2hvc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCdAJyk7XG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhbGxvd19hdXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXV0aCA9IHNwbGl0LnNoaWZ0KCk7XG5cbiAgICBpZiAoYXV0aC5pbmRleE9mKCc6JykgPj0gMCAmJiBhdXRoLnNwbGl0KCc6JykubGVuZ3RoID4gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xuICBwb3J0X3N0ciA9IG51bGw7XG4gIGlwdjYgPSBudWxsO1xuICB2YXIgaXB2Nl9tYXRjaCA9IGhvc3RuYW1lLm1hdGNoKHdyYXBwZWRfaXB2Nik7XG5cbiAgaWYgKGlwdjZfbWF0Y2gpIHtcbiAgICBob3N0ID0gJyc7XG4gICAgaXB2NiA9IGlwdjZfbWF0Y2hbMV07XG4gICAgcG9ydF9zdHIgPSBpcHY2X21hdGNoWzJdIHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBob3N0bmFtZS5zcGxpdCgnOicpO1xuICAgIGhvc3QgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKHNwbGl0Lmxlbmd0aCkge1xuICAgICAgcG9ydF9zdHIgPSBzcGxpdC5qb2luKCc6Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcnRfc3RyICE9PSBudWxsKSB7XG4gICAgcG9ydCA9IHBhcnNlSW50KHBvcnRfc3RyLCAxMCk7XG5cbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChwb3J0X3N0cikgfHwgcG9ydCA8PSAwIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKDAsIF9pc0lQLmRlZmF1bHQpKGhvc3QpICYmICEoMCwgX2lzRlFETi5kZWZhdWx0KShob3N0LCBvcHRpb25zKSAmJiAoIWlwdjYgfHwgISgwLCBfaXNJUC5kZWZhdWx0KShpcHY2LCA2KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBob3N0ID0gaG9zdCB8fCBpcHY2O1xuXG4gIGlmIChvcHRpb25zLmhvc3Rfd2hpdGVsaXN0ICYmICFjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X3doaXRlbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ob3N0X2JsYWNrbGlzdCAmJiBjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X2JsYWNrbGlzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVVUlEO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXVpZCA9IHtcbiAgMzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS0zWzAtOUEtRl17M30tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pLFxuICA0OiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTRbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksXG4gIDU6IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNVswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSxcbiAgYWxsOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaVxufTtcblxuZnVuY3Rpb24gaXNVVUlEKHN0cikge1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FsbCc7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBwYXR0ZXJuID0gdXVpZFt2ZXJzaW9uXTtcbiAgcmV0dXJuIHBhdHRlcm4gJiYgcGF0dGVybi50ZXN0KHN0cik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVXBwZXJjYXNlO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1VwcGVyY2FzZShzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHN0ciA9PT0gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFyaWFibGVXaWR0aDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxudmFyIF9pc0Z1bGxXaWR0aCA9IHJlcXVpcmUoXCIuL2lzRnVsbFdpZHRoXCIpO1xuXG52YXIgX2lzSGFsZldpZHRoID0gcmVxdWlyZShcIi4vaXNIYWxmV2lkdGhcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVXaWR0aChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIF9pc0Z1bGxXaWR0aC5mdWxsV2lkdGgudGVzdChzdHIpICYmIF9pc0hhbGZXaWR0aC5oYWxmV2lkdGgudGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1doaXRlbGlzdGVkO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1doaXRlbGlzdGVkKHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGNoYXJzLmluZGV4T2Yoc3RyW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbHRyaW07XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGx0cmltKHN0ciwgY2hhcnMpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgdmFyIHBhdHRlcm4gPSBjaGFycyA/IG5ldyBSZWdFeHAoXCJeW1wiLmNvbmNhdChjaGFycywgXCJdK1wiKSwgJ2cnKSA6IC9eXFxzKy9nO1xuICByZXR1cm4gc3RyLnJlcGxhY2UocGF0dGVybiwgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaGVzO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBtYXRjaGVzKHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXR0ZXJuKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm4udGVzdChzdHIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBub3JtYWxpemVFbWFpbDtcblxudmFyIF9tZXJnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9tZXJnZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X25vcm1hbGl6ZV9lbWFpbF9vcHRpb25zID0ge1xuICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXBwbHkgdG8gYWxsIGVtYWlsIGFkZHJlc3Nlc1xuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzLlxuICAvLyBQbGVhc2Ugbm90ZSB0aGlzIG1heSB2aW9sYXRlIFJGQyA1MzIxIGFzIHBlciBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85ODA4MzMyLzE5MjAyNCkuXG4gIC8vIFRoZSBkb21haW4gaXMgYWx3YXlzIGxvd2VyY2FzZWQsIGFzIHBlciBSRkMgMTAzNVxuICBhbGxfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBUaGUgZm9sbG93aW5nIGNvbnZlcnNpb25zIGFyZSBzcGVjaWZpYyB0byBHTWFpbFxuICAvLyBMb3dlcmNhc2VzIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBHTWFpbCBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICBnbWFpbF9sb3dlcmNhc2U6IHRydWUsXG4gIC8vIFJlbW92ZXMgZG90cyBmcm9tIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzLCBhcyB0aGF0J3MgaWdub3JlZCBieSBHTWFpbFxuICBnbWFpbF9yZW1vdmVfZG90czogdHJ1ZSxcbiAgLy8gUmVtb3ZlcyB0aGUgc3ViYWRkcmVzcyAoZS5nLiBcIitmb29cIikgZnJvbSB0aGUgZW1haWwgYWRkcmVzc1xuICBnbWFpbF9yZW1vdmVfc3ViYWRkcmVzczogdHJ1ZSxcbiAgLy8gQ29udmVyc3RzIHRoZSBnb29nbGVtYWlsLmNvbSBkb21haW4gdG8gZ21haWwuY29tXG4gIGdtYWlsX2NvbnZlcnRfZ29vZ2xlbWFpbGRvdGNvbTogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gT3V0bG9vay5jb20gLyBXaW5kb3dzIExpdmUgLyBIb3RtYWlsXG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIE91dGxvb2suY29tIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIG91dGxvb2tkb3Rjb21fbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBSZW1vdmVzIHRoZSBzdWJhZGRyZXNzIChlLmcuIFwiK2Zvb1wiKSBmcm9tIHRoZSBlbWFpbCBhZGRyZXNzXG4gIG91dGxvb2tkb3Rjb21fcmVtb3ZlX3N1YmFkZHJlc3M6IHRydWUsXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29udmVyc2lvbnMgYXJlIHNwZWNpZmljIHRvIFlhaG9vXG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIFlhaG9vIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIHlhaG9vX2xvd2VyY2FzZTogdHJ1ZSxcbiAgLy8gUmVtb3ZlcyB0aGUgc3ViYWRkcmVzcyAoZS5nLiBcIi1mb29cIikgZnJvbSB0aGUgZW1haWwgYWRkcmVzc1xuICB5YWhvb19yZW1vdmVfc3ViYWRkcmVzczogdHJ1ZSxcbiAgLy8gVGhlIGZvbGxvd2luZyBjb252ZXJzaW9ucyBhcmUgc3BlY2lmaWMgdG8gWWFuZGV4XG4gIC8vIExvd2VyY2FzZXMgdGhlIGxvY2FsIHBhcnQgb2YgdGhlIFlhbmRleCBhZGRyZXNzIChrbm93biB0byBiZSBjYXNlLWluc2Vuc2l0aXZlKVxuICB5YW5kZXhfbG93ZXJjYXNlOiB0cnVlLFxuICAvLyBUaGUgZm9sbG93aW5nIGNvbnZlcnNpb25zIGFyZSBzcGVjaWZpYyB0byBpQ2xvdWRcbiAgLy8gTG93ZXJjYXNlcyB0aGUgbG9jYWwgcGFydCBvZiB0aGUgaUNsb3VkIGFkZHJlc3MgKGtub3duIHRvIGJlIGNhc2UtaW5zZW5zaXRpdmUpXG4gIGljbG91ZF9sb3dlcmNhc2U6IHRydWUsXG4gIC8vIFJlbW92ZXMgdGhlIHN1YmFkZHJlc3MgKGUuZy4gXCIrZm9vXCIpIGZyb20gdGhlIGVtYWlsIGFkZHJlc3NcbiAgaWNsb3VkX3JlbW92ZV9zdWJhZGRyZXNzOiB0cnVlXG59OyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBpQ2xvdWRcblxudmFyIGljbG91ZF9kb21haW5zID0gWydpY2xvdWQuY29tJywgJ21lLmNvbSddOyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBPdXRsb29rLmNvbSBhbmQgaXRzIHByZWRlY2Vzc29yc1xuLy8gVGhpcyBsaXN0IGlzIGxpa2VseSBpbmNvbXBsZXRlLlxuLy8gUGFydGlhbCByZWZlcmVuY2U6XG4vLyBodHRwczovL2Jsb2dzLm9mZmljZS5jb20vMjAxMy8wNC8xNy9vdXRsb29rLWNvbS1nZXRzLXR3by1zdGVwLXZlcmlmaWNhdGlvbi1zaWduLWluLWJ5LWFsaWFzLWFuZC1uZXctaW50ZXJuYXRpb25hbC1kb21haW5zL1xuXG52YXIgb3V0bG9va2RvdGNvbV9kb21haW5zID0gWydob3RtYWlsLmF0JywgJ2hvdG1haWwuYmUnLCAnaG90bWFpbC5jYScsICdob3RtYWlsLmNsJywgJ2hvdG1haWwuY28uaWwnLCAnaG90bWFpbC5jby5ueicsICdob3RtYWlsLmNvLnRoJywgJ2hvdG1haWwuY28udWsnLCAnaG90bWFpbC5jb20nLCAnaG90bWFpbC5jb20uYXInLCAnaG90bWFpbC5jb20uYXUnLCAnaG90bWFpbC5jb20uYnInLCAnaG90bWFpbC5jb20uZ3InLCAnaG90bWFpbC5jb20ubXgnLCAnaG90bWFpbC5jb20ucGUnLCAnaG90bWFpbC5jb20udHInLCAnaG90bWFpbC5jb20udm4nLCAnaG90bWFpbC5jeicsICdob3RtYWlsLmRlJywgJ2hvdG1haWwuZGsnLCAnaG90bWFpbC5lcycsICdob3RtYWlsLmZyJywgJ2hvdG1haWwuaHUnLCAnaG90bWFpbC5pZCcsICdob3RtYWlsLmllJywgJ2hvdG1haWwuaW4nLCAnaG90bWFpbC5pdCcsICdob3RtYWlsLmpwJywgJ2hvdG1haWwua3InLCAnaG90bWFpbC5sdicsICdob3RtYWlsLm15JywgJ2hvdG1haWwucGgnLCAnaG90bWFpbC5wdCcsICdob3RtYWlsLnNhJywgJ2hvdG1haWwuc2cnLCAnaG90bWFpbC5zaycsICdsaXZlLmJlJywgJ2xpdmUuY28udWsnLCAnbGl2ZS5jb20nLCAnbGl2ZS5jb20uYXInLCAnbGl2ZS5jb20ubXgnLCAnbGl2ZS5kZScsICdsaXZlLmVzJywgJ2xpdmUuZXUnLCAnbGl2ZS5mcicsICdsaXZlLml0JywgJ2xpdmUubmwnLCAnbXNuLmNvbScsICdvdXRsb29rLmF0JywgJ291dGxvb2suYmUnLCAnb3V0bG9vay5jbCcsICdvdXRsb29rLmNvLmlsJywgJ291dGxvb2suY28ubnonLCAnb3V0bG9vay5jby50aCcsICdvdXRsb29rLmNvbScsICdvdXRsb29rLmNvbS5hcicsICdvdXRsb29rLmNvbS5hdScsICdvdXRsb29rLmNvbS5icicsICdvdXRsb29rLmNvbS5ncicsICdvdXRsb29rLmNvbS5wZScsICdvdXRsb29rLmNvbS50cicsICdvdXRsb29rLmNvbS52bicsICdvdXRsb29rLmN6JywgJ291dGxvb2suZGUnLCAnb3V0bG9vay5kaycsICdvdXRsb29rLmVzJywgJ291dGxvb2suZnInLCAnb3V0bG9vay5odScsICdvdXRsb29rLmlkJywgJ291dGxvb2suaWUnLCAnb3V0bG9vay5pbicsICdvdXRsb29rLml0JywgJ291dGxvb2suanAnLCAnb3V0bG9vay5rcicsICdvdXRsb29rLmx2JywgJ291dGxvb2subXknLCAnb3V0bG9vay5waCcsICdvdXRsb29rLnB0JywgJ291dGxvb2suc2EnLCAnb3V0bG9vay5zZycsICdvdXRsb29rLnNrJywgJ3Bhc3Nwb3J0LmNvbSddOyAvLyBMaXN0IG9mIGRvbWFpbnMgdXNlZCBieSBZYWhvbyBNYWlsXG4vLyBUaGlzIGxpc3QgaXMgbGlrZWx5IGluY29tcGxldGVcblxudmFyIHlhaG9vX2RvbWFpbnMgPSBbJ3JvY2tldG1haWwuY29tJywgJ3lhaG9vLmNhJywgJ3lhaG9vLmNvLnVrJywgJ3lhaG9vLmNvbScsICd5YWhvby5kZScsICd5YWhvby5mcicsICd5YWhvby5pbicsICd5YWhvby5pdCcsICd5bWFpbC5jb20nXTsgLy8gTGlzdCBvZiBkb21haW5zIHVzZWQgYnkgeWFuZGV4LnJ1XG5cbnZhciB5YW5kZXhfZG9tYWlucyA9IFsneWFuZGV4LnJ1JywgJ3lhbmRleC51YScsICd5YW5kZXgua3onLCAneWFuZGV4LmNvbScsICd5YW5kZXguYnknLCAneWEucnUnXTsgLy8gcmVwbGFjZSBzaW5nbGUgZG90cywgYnV0IG5vdCBtdWx0aXBsZSBjb25zZWN1dGl2ZSBkb3RzXG5cbmZ1bmN0aW9uIGRvdHNSZXBsYWNlcihtYXRjaCkge1xuICBpZiAobWF0Y2gubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRW1haWwoZW1haWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF9ub3JtYWxpemVfZW1haWxfb3B0aW9ucyk7XG4gIHZhciByYXdfcGFydHMgPSBlbWFpbC5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcmF3X3BhcnRzLnBvcCgpO1xuICB2YXIgdXNlciA9IHJhd19wYXJ0cy5qb2luKCdAJyk7XG4gIHZhciBwYXJ0cyA9IFt1c2VyLCBkb21haW5dOyAvLyBUaGUgZG9tYWluIGlzIGFsd2F5cyBsb3dlcmNhc2VkLCBhcyBpdCdzIGNhc2UtaW5zZW5zaXRpdmUgcGVyIFJGQyAxMDM1XG5cbiAgcGFydHNbMV0gPSBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChwYXJ0c1sxXSA9PT0gJ2dtYWlsLmNvbScgfHwgcGFydHNbMV0gPT09ICdnb29nbGVtYWlsLmNvbScpIHtcbiAgICAvLyBBZGRyZXNzIGlzIEdNYWlsXG4gICAgaWYgKG9wdGlvbnMuZ21haWxfcmVtb3ZlX3N1YmFkZHJlc3MpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0uc3BsaXQoJysnKVswXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5nbWFpbF9yZW1vdmVfZG90cykge1xuICAgICAgLy8gdGhpcyBkb2VzIG5vdCByZXBsYWNlIGNvbnNlY3V0aXZlIGRvdHMgbGlrZSBleGFtcGxlLi5lbWFpbEBnbWFpbC5jb21cbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZSgvXFwuKy9nLCBkb3RzUmVwbGFjZXIpO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLmdtYWlsX2xvd2VyY2FzZSkge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHBhcnRzWzFdID0gb3B0aW9ucy5nbWFpbF9jb252ZXJ0X2dvb2dsZW1haWxkb3Rjb20gPyAnZ21haWwuY29tJyA6IHBhcnRzWzFdO1xuICB9IGVsc2UgaWYgKGljbG91ZF9kb21haW5zLmluZGV4T2YocGFydHNbMV0pID49IDApIHtcbiAgICAvLyBBZGRyZXNzIGlzIGlDbG91ZFxuICAgIGlmIChvcHRpb25zLmljbG91ZF9yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5zcGxpdCgnKycpWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLmljbG91ZF9sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3V0bG9va2RvdGNvbV9kb21haW5zLmluZGV4T2YocGFydHNbMV0pID49IDApIHtcbiAgICAvLyBBZGRyZXNzIGlzIE91dGxvb2suY29tXG4gICAgaWYgKG9wdGlvbnMub3V0bG9va2RvdGNvbV9yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5zcGxpdCgnKycpWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLm91dGxvb2tkb3Rjb21fbG93ZXJjYXNlKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHlhaG9vX2RvbWFpbnMuaW5kZXhPZihwYXJ0c1sxXSkgPj0gMCkge1xuICAgIC8vIEFkZHJlc3MgaXMgWWFob29cbiAgICBpZiAob3B0aW9ucy55YWhvb19yZW1vdmVfc3ViYWRkcmVzcykge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBwYXJ0c1swXS5zcGxpdCgnLScpO1xuICAgICAgcGFydHNbMF0gPSBjb21wb25lbnRzLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzLnNsaWNlKDAsIC0xKS5qb2luKCctJykgOiBjb21wb25lbnRzWzBdO1xuICAgIH1cblxuICAgIGlmICghcGFydHNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLnlhaG9vX2xvd2VyY2FzZSkge1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5YW5kZXhfZG9tYWlucy5pbmRleE9mKHBhcnRzWzFdKSA+PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuYWxsX2xvd2VyY2FzZSB8fCBvcHRpb25zLnlhbmRleF9sb3dlcmNhc2UpIHtcbiAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBwYXJ0c1sxXSA9ICd5YW5kZXgucnUnOyAvLyBhbGwgeWFuZGV4IGRvbWFpbnMgYXJlIGVxdWFsLCAxc3QgcHJlZmZlcmVkXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxfbG93ZXJjYXNlKSB7XG4gICAgLy8gQW55IG90aGVyIGFkZHJlc3NcbiAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignQCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBydHJpbTtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcnRyaW0oc3RyLCBjaGFycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICB2YXIgcGF0dGVybiA9IGNoYXJzID8gbmV3IFJlZ0V4cChcIltcIi5jb25jYXQoY2hhcnMsIFwiXVwiKSkgOiAvXFxzLztcbiAgdmFyIGlkeCA9IHN0ci5sZW5ndGggLSAxO1xuXG4gIGZvciAoOyBpZHggPj0gMCAmJiBwYXR0ZXJuLnRlc3Qoc3RyW2lkeF0pOyBpZHgtLSkge1xuICAgIDtcbiAgfVxuXG4gIHJldHVybiBpZHggPCBzdHIubGVuZ3RoID8gc3RyLnN1YnN0cigwLCBpZHggKyAxKSA6IHN0cjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaXBMb3c7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbnZhciBfYmxhY2tsaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ibGFja2xpc3RcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdHJpcExvdyhzdHIsIGtlZXBfbmV3X2xpbmVzKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKHN0cik7XG4gIHZhciBjaGFycyA9IGtlZXBfbmV3X2xpbmVzID8gJ1xcXFx4MDAtXFxcXHgwOVxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3RicgOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3Ric7XG4gIHJldHVybiAoMCwgX2JsYWNrbGlzdC5kZWZhdWx0KShzdHIsIGNoYXJzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9Cb29sZWFuO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0Jvb2xlYW4oc3RyLCBzdHJpY3QpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcblxuICBpZiAoc3RyaWN0KSB7XG4gICAgcmV0dXJuIHN0ciA9PT0gJzEnIHx8IHN0ciA9PT0gJ3RydWUnO1xuICB9XG5cbiAgcmV0dXJuIHN0ciAhPT0gJzAnICYmIHN0ciAhPT0gJ2ZhbHNlJyAmJiBzdHIgIT09ICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0RhdGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvRGF0ZShkYXRlKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nLmRlZmF1bHQpKGRhdGUpO1xuICBkYXRlID0gRGF0ZS5wYXJzZShkYXRlKTtcbiAgcmV0dXJuICFpc05hTihkYXRlKSA/IG5ldyBEYXRlKGRhdGUpIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9GbG9hdDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYXNzZXJ0U3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9GbG9hdChzdHIpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9JbnQ7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvSW50KHN0ciwgcmFkaXgpIHtcbiAgKDAsIF9hc3NlcnRTdHJpbmcuZGVmYXVsdCkoc3RyKTtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgcmFkaXggfHwgMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xuXG52YXIgX3J0cmltID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ydHJpbVwiKSk7XG5cbnZhciBfbHRyaW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2x0cmltXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdHJpbShzdHIsIGNoYXJzKSB7XG4gIHJldHVybiAoMCwgX3J0cmltLmRlZmF1bHQpKCgwLCBfbHRyaW0uZGVmYXVsdCkoc3RyLCBjaGFycyksIGNoYXJzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5lc2NhcGU7XG5cbnZhciBfYXNzZXJ0U3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2Fzc2VydFN0cmluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyZhbXA7L2csICcmJykucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpLnJlcGxhY2UoLyYjeDI3Oy9nLCBcIidcIikucmVwbGFjZSgvJmx0Oy9nLCAnPCcpLnJlcGxhY2UoLyZndDsvZywgJz4nKS5yZXBsYWNlKC8mI3gyRjsvZywgJy8nKS5yZXBsYWNlKC8mI3g1QzsvZywgJ1xcXFwnKS5yZXBsYWNlKC8mIzk2Oy9nLCAnYCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnRTdHJpbmc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICB2YXIgaW52YWxpZFR5cGU7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgIGludmFsaWRUeXBlID0gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhbGlkVHlwZSA9IF90eXBlb2YoaW5wdXQpO1xuXG4gICAgICBpZiAoaW52YWxpZFR5cGUgPT09ICdvYmplY3QnICYmIGlucHV0LmNvbnN0cnVjdG9yICYmIGlucHV0LmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCduYW1lJykpIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZFR5cGUgPSBcImEgXCIuY29uY2F0KGludmFsaWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCBcIi5jb25jYXQoaW52YWxpZFR5cGUsIFwiLlwiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGFyclZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IGFyclZhbDtcbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpbmNsdWRlcztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWVyZ2U7XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b1N0cmluZztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdG9TdHJpbmcoaW5wdXQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0JyAmJiBpbnB1dCAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCBpc05hTihpbnB1dCkgJiYgIWlucHV0Lmxlbmd0aCkge1xuICAgIGlucHV0ID0gJyc7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2hpdGVsaXN0O1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9hc3NlcnRTdHJpbmdcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB3aGl0ZWxpc3Qoc3RyLCBjaGFycykge1xuICAoMCwgX2Fzc2VydFN0cmluZy5kZWZhdWx0KShzdHIpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlteXCIuY29uY2F0KGNoYXJzLCBcIl0rXCIpLCAnZycpLCAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDsiLCJtb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVJlYWRlcjtcclxuXHJcbmZ1bmN0aW9uIEJpbmFyeVJlYWRlcihidWZmZXIsIGlzQmlnRW5kaWFuKSB7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5pc0JpZ0VuZGlhbiA9IGlzQmlnRW5kaWFuIHx8IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfcmVhZChyZWFkTEUsIHJlYWRCRSwgc2l6ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzQmlnRW5kaWFuKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHJlYWRCRS5jYWxsKHRoaXMuYnVmZmVyLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHZhbHVlID0gcmVhZExFLmNhbGwodGhpcy5idWZmZXIsIHRoaXMucG9zaXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHNpemU7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbn1cclxuXHJcbkJpbmFyeVJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDgsIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4LCAxKTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDE2ID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFLCAyKTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDMyID0gX3JlYWQoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFLCA0KTtcclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkSW50OCA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDgsIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDgsIDEpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRJbnQxNiA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUsIDIpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRJbnQzMiA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUsIDQpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWRGbG9hdCA9IF9yZWFkKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUsIEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUsIDQpO1xyXG5CaW5hcnlSZWFkZXIucHJvdG90eXBlLnJlYWREb3VibGUgPSBfcmVhZChCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSwgQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUsIDgpO1xyXG5cclxuQmluYXJ5UmVhZGVyLnByb3RvdHlwZS5yZWFkVmFySW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG5leHRCeXRlLFxyXG4gICAgICAgIHJlc3VsdCA9IDAsXHJcbiAgICAgICAgYnl0ZXNSZWFkID0gMDtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgbmV4dEJ5dGUgPSB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uICsgYnl0ZXNSZWFkXTtcclxuICAgICAgICByZXN1bHQgKz0gKG5leHRCeXRlICYgMHg3RikgPDwgKDcgKiBieXRlc1JlYWQpO1xyXG4gICAgICAgIGJ5dGVzUmVhZCsrO1xyXG4gICAgfSB3aGlsZSAobmV4dEJ5dGUgPj0gMHg4MCk7XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlXcml0ZXI7XHJcblxyXG5mdW5jdGlvbiBCaW5hcnlXcml0ZXIoc2l6ZSwgYWxsb3dSZXNpemUpIHtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlcihzaXplKTtcclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5hbGxvd1Jlc2l6ZSA9IGFsbG93UmVzaXplO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfd3JpdGUod3JpdGUsIHNpemUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKHNpemUpO1xyXG5cclxuICAgICAgICB3cml0ZS5jYWxsKHRoaXMuYnVmZmVyLCB2YWx1ZSwgdGhpcy5wb3NpdGlvbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZTtcclxuICAgIH07XHJcbn1cclxuXHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFLCAyKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSwgMik7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUludDggPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDgsIDEpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMik7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyKTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IF93cml0ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSwgNCk7XHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFLCA0KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUsIDQpO1xyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBfd3JpdGUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFLCA4KTtcclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gX3dyaXRlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCk7XHJcblxyXG5CaW5hcnlXcml0ZXIucHJvdG90eXBlLndyaXRlQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xyXG4gICAgdGhpcy5lbnN1cmVTaXplKGJ1ZmZlci5sZW5ndGgpO1xyXG5cclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuYnVmZmVyLCB0aGlzLnBvc2l0aW9uLCAwLCBidWZmZXIubGVuZ3RoKTtcclxuICAgIHRoaXMucG9zaXRpb24gKz0gYnVmZmVyLmxlbmd0aDtcclxufTtcclxuXHJcbkJpbmFyeVdyaXRlci5wcm90b3R5cGUud3JpdGVWYXJJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBsZW5ndGggPSAxO1xyXG5cclxuICAgIHdoaWxlICgodmFsdWUgJiAweEZGRkZGRjgwKSAhPT0gMCkge1xyXG4gICAgICAgIHRoaXMud3JpdGVVSW50OCgodmFsdWUgJiAweDdGKSB8IDB4ODApO1xyXG4gICAgICAgIHZhbHVlID4+Pj0gNztcclxuICAgICAgICBsZW5ndGgrKztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUgJiAweDdGKTtcclxuXHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG59O1xyXG5cclxuQmluYXJ5V3JpdGVyLnByb3RvdHlwZS5lbnN1cmVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCB0aGlzLnBvc2l0aW9uICsgc2l6ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzaXplKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLnBvc2l0aW9uICsgc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmNvcHkodGVtcEJ1ZmZlciwgMCwgMCwgdGhpcy5idWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0ZW1wQnVmZmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBHZW9tZXRyeTtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgTGluZVN0cmluZyA9IHJlcXVpcmUoJy4vbGluZXN0cmluZycpO1xyXG52YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4vcG9seWdvbicpO1xyXG52YXIgTXVsdGlQb2ludCA9IHJlcXVpcmUoJy4vbXVsdGlwb2ludCcpO1xyXG52YXIgTXVsdGlMaW5lU3RyaW5nID0gcmVxdWlyZSgnLi9tdWx0aWxpbmVzdHJpbmcnKTtcclxudmFyIE11bHRpUG9seWdvbiA9IHJlcXVpcmUoJy4vbXVsdGlwb2x5Z29uJyk7XHJcbnZhciBHZW9tZXRyeUNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2dlb21ldHJ5Y29sbGVjdGlvbicpO1xyXG52YXIgQmluYXJ5UmVhZGVyID0gcmVxdWlyZSgnLi9iaW5hcnlyZWFkZXInKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcbnZhciBXa3RQYXJzZXIgPSByZXF1aXJlKCcuL3drdHBhcnNlcicpO1xyXG52YXIgWmlnWmFnID0gcmVxdWlyZSgnLi96aWd6YWcuanMnKTtcclxuXHJcbmZ1bmN0aW9uIEdlb21ldHJ5KCkge1xyXG4gICAgdGhpcy5zcmlkID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5oYXNaID0gZmFsc2U7XHJcbiAgICB0aGlzLmhhc00gPSBmYWxzZTtcclxufVxyXG5cclxuR2VvbWV0cnkucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcblxyXG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBXa3RQYXJzZXIpXHJcbiAgICAgICAgcmV0dXJuIEdlb21ldHJ5Ll9wYXJzZVdrdCh2YWx1ZSk7XHJcbiAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5UmVhZGVyKVxyXG4gICAgICAgIHJldHVybiBHZW9tZXRyeS5fcGFyc2VXa2IodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBCdWZmZXInKTtcclxufTtcclxuXHJcbkdlb21ldHJ5Ll9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIHdrdFBhcnNlcixcclxuICAgICAgICBzcmlkO1xyXG5cclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFdrdFBhcnNlcilcclxuICAgICAgICB3a3RQYXJzZXIgPSB2YWx1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICB3a3RQYXJzZXIgPSBuZXcgV2t0UGFyc2VyKHZhbHVlKTtcclxuXHJcbiAgICB2YXIgbWF0Y2ggPSB3a3RQYXJzZXIubWF0Y2hSZWdleChbL15TUklEPShcXGQrKTsvXSk7XHJcbiAgICBpZiAobWF0Y2gpXHJcbiAgICAgICAgc3JpZCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHdrdFBhcnNlci5tYXRjaFR5cGUoKTtcclxuICAgIHZhciBkaW1lbnNpb24gPSB3a3RQYXJzZXIubWF0Y2hEaW1lbnNpb24oKTtcclxuXHJcbiAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICBzcmlkOiBzcmlkLFxyXG4gICAgICAgIGhhc1o6IGRpbWVuc2lvbi5oYXNaLFxyXG4gICAgICAgIGhhc006IGRpbWVuc2lvbi5oYXNNXHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5MaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTGluZVN0cmluZy5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5Qb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gUG9seWdvbi5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5NdWx0aVBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2ludC5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrdC5NdWx0aUxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aUxpbmVTdHJpbmcuX3BhcnNlV2t0KHdrdFBhcnNlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a3QuTXVsdGlQb2x5Z29uOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2x5Z29uLl9wYXJzZVdrdCh3a3RQYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2t0Lkdlb21ldHJ5Q29sbGVjdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VXa3Qod2t0UGFyc2VyLCBvcHRpb25zKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdlb21ldHJ5Ll9wYXJzZVdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgcGFyZW50T3B0aW9ucykge1xyXG4gICAgdmFyIGJpbmFyeVJlYWRlcixcclxuICAgICAgICB3a2JUeXBlLFxyXG4gICAgICAgIGdlb21ldHJ5VHlwZSxcclxuICAgICAgICBvcHRpb25zID0ge307XHJcblxyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5UmVhZGVyKVxyXG4gICAgICAgIGJpbmFyeVJlYWRlciA9IHZhbHVlO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGJpbmFyeVJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIodmFsdWUpO1xyXG5cclxuICAgIGJpbmFyeVJlYWRlci5pc0JpZ0VuZGlhbiA9ICFiaW5hcnlSZWFkZXIucmVhZEludDgoKTtcclxuXHJcbiAgICB3a2JUeXBlID0gYmluYXJ5UmVhZGVyLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBvcHRpb25zLmhhc1NyaWQgPSAod2tiVHlwZSAmIDB4MjAwMDAwMDApID09PSAweDIwMDAwMDAwO1xyXG4gICAgb3B0aW9ucy5pc0V3a2IgPSAod2tiVHlwZSAmIDB4MjAwMDAwMDApIHx8ICh3a2JUeXBlICYgMHg0MDAwMDAwMCkgfHwgKHdrYlR5cGUgJiAweDgwMDAwMDAwKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNTcmlkKVxyXG4gICAgICAgIG9wdGlvbnMuc3JpZCA9IGJpbmFyeVJlYWRlci5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgb3B0aW9ucy5oYXNaID0gZmFsc2U7XHJcbiAgICBvcHRpb25zLmhhc00gPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMuaXNFd2tiICYmICghcGFyZW50T3B0aW9ucyB8fCAhcGFyZW50T3B0aW9ucy5pc0V3a2IpKSB7XHJcbiAgICAgICAgaWYgKHdrYlR5cGUgPj0gMTAwMCAmJiB3a2JUeXBlIDwgMjAwMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmhhc1ogPSB0cnVlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSB3a2JUeXBlIC0gMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2tiVHlwZSA+PSAyMDAwICYmIHdrYlR5cGUgPCAzMDAwKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzTSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9IHdrYlR5cGUgLSAyMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3a2JUeXBlID49IDMwMDAgJiYgd2tiVHlwZSA8IDQwMDApIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNaID0gdHJ1ZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNNID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlID0gd2tiVHlwZSAtIDMwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSB3a2JUeXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh3a2JUeXBlICYgMHg4MDAwMDAwMClcclxuICAgICAgICAgICAgb3B0aW9ucy5oYXNaID0gdHJ1ZTtcclxuICAgICAgICBpZiAod2tiVHlwZSAmIDB4NDAwMDAwMDApXHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzTSA9IHRydWU7XHJcblxyXG4gICAgICAgIGdlb21ldHJ5VHlwZSA9IHdrYlR5cGUgJiAweEY7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChnZW9tZXRyeVR5cGUpIHtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5Qb2ludDpcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Ll9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLkxpbmVTdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lU3RyaW5nLl9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLlBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBQb2x5Z29uLl9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvaW50Ll9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLk11bHRpTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpTGluZVN0cmluZy5fcGFyc2VXa2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aVBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvbHlnb24uX3BhcnNlV2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuR2VvbWV0cnlDb2xsZWN0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2VvbWV0cnlUeXBlICcgKyBnZW9tZXRyeVR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdlb21ldHJ5LnBhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIGJpbmFyeVJlYWRlcixcclxuICAgICAgICBvcHRpb25zID0ge307XHJcblxyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5UmVhZGVyKVxyXG4gICAgICAgIGJpbmFyeVJlYWRlciA9IHZhbHVlO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGJpbmFyeVJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIodmFsdWUpO1xyXG5cclxuICAgIHZhciB0eXBlID0gYmluYXJ5UmVhZGVyLnJlYWRVSW50OCgpO1xyXG4gICAgdmFyIG1ldGFkYXRhSGVhZGVyID0gYmluYXJ5UmVhZGVyLnJlYWRVSW50OCgpO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSB0eXBlICYgMHgwRjtcclxuICAgIG9wdGlvbnMucHJlY2lzaW9uID0gWmlnWmFnLmRlY29kZSh0eXBlID4+IDQpO1xyXG4gICAgb3B0aW9ucy5wcmVjaXNpb25GYWN0b3IgPSBNYXRoLnBvdygxMCwgb3B0aW9ucy5wcmVjaXNpb24pO1xyXG5cclxuICAgIG9wdGlvbnMuaGFzQm91bmRpbmdCb3ggPSBtZXRhZGF0YUhlYWRlciA+PiAwICYgMTtcclxuICAgIG9wdGlvbnMuaGFzU2l6ZUF0dHJpYnV0ZSA9IG1ldGFkYXRhSGVhZGVyID4+IDEgJiAxO1xyXG4gICAgb3B0aW9ucy5oYXNJZExpc3QgPSBtZXRhZGF0YUhlYWRlciA+PiAyICYgMTtcclxuICAgIG9wdGlvbnMuaGFzRXh0ZW5kZWRQcmVjaXNpb24gPSBtZXRhZGF0YUhlYWRlciA+PiAzICYgMTtcclxuICAgIG9wdGlvbnMuaXNFbXB0eSA9IG1ldGFkYXRhSGVhZGVyID4+IDQgJiAxO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc0V4dGVuZGVkUHJlY2lzaW9uKSB7XHJcbiAgICAgICAgdmFyIGV4dGVuZGVkUHJlY2lzaW9uID0gYmluYXJ5UmVhZGVyLnJlYWRVSW50OCgpO1xyXG4gICAgICAgIG9wdGlvbnMuaGFzWiA9IChleHRlbmRlZFByZWNpc2lvbiAmIDB4MDEpID09PSAweDAxO1xyXG4gICAgICAgIG9wdGlvbnMuaGFzTSA9IChleHRlbmRlZFByZWNpc2lvbiAmIDB4MDIpID09PSAweDAyO1xyXG5cclxuICAgICAgICBvcHRpb25zLnpQcmVjaXNpb24gPSBaaWdaYWcuZGVjb2RlKChleHRlbmRlZFByZWNpc2lvbiAmIDB4MUMpID4+IDIpO1xyXG4gICAgICAgIG9wdGlvbnMuelByZWNpc2lvbkZhY3RvciA9IE1hdGgucG93KDEwLCBvcHRpb25zLnpQcmVjaXNpb24pO1xyXG5cclxuICAgICAgICBvcHRpb25zLm1QcmVjaXNpb24gPSBaaWdaYWcuZGVjb2RlKChleHRlbmRlZFByZWNpc2lvbiAmIDB4RTApID4+IDUpO1xyXG4gICAgICAgIG9wdGlvbnMubVByZWNpc2lvbkZhY3RvciA9IE1hdGgucG93KDEwLCBvcHRpb25zLm1QcmVjaXNpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy5oYXNaID0gZmFsc2U7XHJcbiAgICAgICAgb3B0aW9ucy5oYXNNID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzU2l6ZUF0dHJpYnV0ZSlcclxuICAgICAgICBiaW5hcnlSZWFkZXIucmVhZFZhckludCgpO1xyXG4gICAgaWYgKG9wdGlvbnMuaGFzQm91bmRpbmdCb3gpIHtcclxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IDI7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc1opXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnMrKztcclxuICAgICAgICBpZiAob3B0aW9ucy5oYXNNKVxyXG4gICAgICAgICAgICBkaW1lbnNpb25zKys7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJpbmFyeVJlYWRlci5yZWFkVmFySW50KCk7XHJcbiAgICAgICAgICAgIGJpbmFyeVJlYWRlci5yZWFkVmFySW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuUG9pbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTGluZVN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIExpbmVTdHJpbmcuX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLlBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBQb2x5Z29uLl9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aVBvaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlQb2ludC5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSBUeXBlcy53a2IuTXVsdGlMaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlMaW5lU3RyaW5nLl9wYXJzZVR3a2IoYmluYXJ5UmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIFR5cGVzLndrYi5NdWx0aVBvbHlnb246XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aVBvbHlnb24uX3BhcnNlVHdrYihiaW5hcnlSZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNhc2UgVHlwZXMud2tiLkdlb21ldHJ5Q29sbGVjdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbi5fcGFyc2VUd2tiKGJpbmFyeVJlYWRlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW9tZXRyeVR5cGUgJyArIGdlb21ldHJ5VHlwZSArICcgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR2VvbWV0cnkucGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gR2VvbWV0cnkuX3BhcnNlR2VvSlNPTih2YWx1ZSk7XHJcbn07XHJcblxyXG5HZW9tZXRyeS5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlLCBpc1N1Ykdlb21ldHJ5KSB7XHJcbiAgICB2YXIgZ2VvbWV0cnk7XHJcblxyXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLlBvaW50OlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IFBvaW50Ll9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uTGluZVN0cmluZzpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBMaW5lU3RyaW5nLl9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uUG9seWdvbjpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBQb2x5Z29uLl9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uTXVsdGlQb2ludDpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBNdWx0aVBvaW50Ll9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBjYXNlIFR5cGVzLmdlb0pTT04uTXVsdGlMaW5lU3RyaW5nOlxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IE11bHRpTGluZVN0cmluZy5fcGFyc2VHZW9KU09OKHZhbHVlKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUeXBlcy5nZW9KU09OLk11bHRpUG9seWdvbjpcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBNdWx0aVBvbHlnb24uX3BhcnNlR2VvSlNPTih2YWx1ZSk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHlwZXMuZ2VvSlNPTi5HZW9tZXRyeUNvbGxlY3Rpb246XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZUdlb0pTT04odmFsdWUpOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5VHlwZSAnICsgdmFsdWUudHlwZSArICcgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZS5jcnMgJiYgdmFsdWUuY3JzLnR5cGUgJiYgdmFsdWUuY3JzLnR5cGUgPT09ICduYW1lJyAmJiB2YWx1ZS5jcnMucHJvcGVydGllcyAmJiB2YWx1ZS5jcnMucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgdmFyIGNycyA9IHZhbHVlLmNycy5wcm9wZXJ0aWVzLm5hbWU7XHJcblxyXG4gICAgICAgIGlmIChjcnMuaW5kZXhPZignRVBTRzonKSA9PT0gMClcclxuICAgICAgICAgICAgZ2VvbWV0cnkuc3JpZCA9IHBhcnNlSW50KGNycy5zdWJzdHJpbmcoNSkpO1xyXG4gICAgICAgIGVsc2UgaWYgKGNycy5pbmRleE9mKCd1cm46b2djOmRlZjpjcnM6RVBTRzo6JykgPT09IDApXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnNyaWQgPSBwYXJzZUludChjcnMuc3Vic3RyaW5nKDIyKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNyczogJyArIGNycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNTdWJHZW9tZXRyeSkge1xyXG4gICAgICAgIGdlb21ldHJ5LnNyaWQgPSA0MzI2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeTtcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS50b0V3a3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJ1NSSUQ9JyArIHRoaXMuc3JpZCArICc7JyArIHRoaXMudG9Xa3QoKTtcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS50b0V3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpICsgNCk7XHJcbiAgICB2YXIgd2tiID0gdGhpcy50b1drYigpO1xyXG5cclxuICAgIGV3a2Iud3JpdGVJbnQ4KDEpO1xyXG4gICAgZXdrYi53cml0ZVVJbnQzMkxFKCh3a2Iuc2xpY2UoMSwgNSkucmVhZFVJbnQzMkxFKDApIHwgMHgyMDAwMDAwMCkgPj4+IDAsIHRydWUpO1xyXG4gICAgZXdrYi53cml0ZVVJbnQzMkxFKHRoaXMuc3JpZCk7XHJcblxyXG4gICAgZXdrYi53cml0ZUJ1ZmZlcih3a2Iuc2xpY2UoNSkpO1xyXG5cclxuICAgIHJldHVybiBld2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS5fZ2V0V2t0VHlwZSA9IGZ1bmN0aW9uICh3a3RUeXBlLCBpc0VtcHR5KSB7XHJcbiAgICB2YXIgd2t0ID0gd2t0VHlwZTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaICYmIHRoaXMuaGFzTSlcclxuICAgICAgICB3a3QgKz0gJyBaTSAnO1xyXG4gICAgZWxzZSBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIHdrdCArPSAnIFogJztcclxuICAgIGVsc2UgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICB3a3QgKz0gJyBNICc7XHJcblxyXG4gICAgaWYgKGlzRW1wdHkgJiYgIXRoaXMuaGFzWiAmJiAhdGhpcy5oYXNNKVxyXG4gICAgICAgIHdrdCArPSAnICc7XHJcblxyXG4gICAgaWYgKGlzRW1wdHkpXHJcbiAgICAgICAgd2t0ICs9ICdFTVBUWSc7XHJcblxyXG4gICAgcmV0dXJuIHdrdDtcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS5fZ2V0V2t0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gcG9pbnQueCArICcgJyArIHBvaW50Lnk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICBjb29yZGluYXRlcyArPSAnICcgKyBwb2ludC56O1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICBjb29yZGluYXRlcyArPSAnICcgKyBwb2ludC5tO1xyXG5cclxuICAgIHJldHVybiBjb29yZGluYXRlcztcclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS5fd3JpdGVXa2JUeXBlID0gZnVuY3Rpb24gKHdrYiwgZ2VvbWV0cnlUeXBlLCBwYXJlbnRPcHRpb25zKSB7XHJcbiAgICB2YXIgZGltZW5zaW9uVHlwZSA9IDA7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNyaWQgPT09ICd1bmRlZmluZWQnICYmICghcGFyZW50T3B0aW9ucyB8fCB0eXBlb2YgcGFyZW50T3B0aW9ucy5zcmlkID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNaICYmIHRoaXMuaGFzTSlcclxuICAgICAgICAgICAgZGltZW5zaW9uVHlwZSArPSAzMDAwO1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgZGltZW5zaW9uVHlwZSArPSAxMDAwO1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICAgICAgZGltZW5zaW9uVHlwZSArPSAyMDAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgZGltZW5zaW9uVHlwZSB8PSAweDgwMDAwMDAwO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgICAgIGRpbWVuc2lvblR5cGUgfD0gMHg0MDAwMDAwMDtcclxuICAgIH1cclxuXHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSgoZGltZW5zaW9uVHlwZSArIGdlb21ldHJ5VHlwZSkgPj4+IDAsIHRydWUpO1xyXG59O1xyXG5cclxuR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbiA9IGZ1bmN0aW9uICh4eVByZWNpc2lvbiwgelByZWNpc2lvbiwgbVByZWNpc2lvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4eTogeHlQcmVjaXNpb24sXHJcbiAgICAgICAgejogelByZWNpc2lvbixcclxuICAgICAgICBtOiBtUHJlY2lzaW9uLFxyXG4gICAgICAgIHh5RmFjdG9yOiBNYXRoLnBvdygxMCwgeHlQcmVjaXNpb24pLFxyXG4gICAgICAgIHpGYWN0b3I6IE1hdGgucG93KDEwLCB6UHJlY2lzaW9uKSxcclxuICAgICAgICBtRmFjdG9yOiBNYXRoLnBvdygxMCwgbVByZWNpc2lvbilcclxuICAgIH07XHJcbn07XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUuX3dyaXRlVHdrYkhlYWRlciA9IGZ1bmN0aW9uICh0d2tiLCBnZW9tZXRyeVR5cGUsIHByZWNpc2lvbiwgaXNFbXB0eSkge1xyXG4gICAgdmFyIHR5cGUgPSAoWmlnWmFnLmVuY29kZShwcmVjaXNpb24ueHkpIDw8IDQpICsgZ2VvbWV0cnlUeXBlO1xyXG4gICAgdmFyIG1ldGFkYXRhSGVhZGVyID0gKHRoaXMuaGFzWiB8fCB0aGlzLmhhc00pIDw8IDM7XHJcbiAgICBtZXRhZGF0YUhlYWRlciArPSBpc0VtcHR5IDw8IDQ7XHJcblxyXG4gICAgdHdrYi53cml0ZVVJbnQ4KHR5cGUpO1xyXG4gICAgdHdrYi53cml0ZVVJbnQ4KG1ldGFkYXRhSGVhZGVyKTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaIHx8IHRoaXMuaGFzTSkge1xyXG4gICAgICAgIHZhciBleHRlbmRlZFByZWNpc2lvbiA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgZXh0ZW5kZWRQcmVjaXNpb24gfD0gMHgxO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgICAgIGV4dGVuZGVkUHJlY2lzaW9uIHw9IDB4MjtcclxuXHJcbiAgICAgICAgdHdrYi53cml0ZVVJbnQ4KGV4dGVuZGVkUHJlY2lzaW9uKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSB7fTtcclxuXHJcbiAgICBpZiAodGhpcy5zcmlkKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvcnRDcnMpIHtcclxuICAgICAgICAgICAgICAgIGdlb0pTT04uY3JzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICduYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdFUFNHOicgKyB0aGlzLnNyaWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubG9uZ0Nycykge1xyXG4gICAgICAgICAgICAgICAgZ2VvSlNPTi5jcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25hbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjonICsgdGhpcy5zcmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBHZW9tZXRyeUNvbGxlY3Rpb247XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXMgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLmdlb21ldHJpZXNbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLmdlb21ldHJpZXNbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhHZW9tZXRyeUNvbGxlY3Rpb24sIEdlb21ldHJ5KTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5aID0gZnVuY3Rpb24gKGdlb21ldHJpZXMsIHNyaWQpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHNyaWQpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc1ogPSB0cnVlO1xyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5NID0gZnVuY3Rpb24gKGdlb21ldHJpZXMsIHNyaWQpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHNyaWQpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5aTSA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzLCBzcmlkKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBzcmlkKTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNaID0gdHJ1ZTtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbigpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLnB1c2goR2VvbWV0cnkucGFyc2UodmFsdWUpKTtcclxuICAgIH0gd2hpbGUgKHZhbHVlLmlzTWF0Y2goWycsJ10pKTtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbigpO1xyXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciBnZW9tZXRyeUNvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnlDb3VudDsgaSsrKVxyXG4gICAgICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLnB1c2goR2VvbWV0cnkucGFyc2UodmFsdWUsIG9wdGlvbnMpKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvbWV0cnlDb2xsZWN0aW9uO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLl9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKCk7XHJcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmlzRW1wdHkpXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnlDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Q291bnQ7IGkrKylcclxuICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5wdXNoKEdlb21ldHJ5LnBhcnNlVHdrYih2YWx1ZSkpO1xyXG5cclxuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24uX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMucHVzaChHZW9tZXRyeS5fcGFyc2VHZW9KU09OKHZhbHVlLmdlb21ldHJpZXNbaV0sIHRydWUpKTtcclxuXHJcbiAgICBpZiAoZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoID4gMClcclxuICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uaGFzWiA9IGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzWzBdLmhhc1o7XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuR2VvbWV0cnlDb2xsZWN0aW9uLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgd2t0ID0gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuR2VvbWV0cnlDb2xsZWN0aW9uLCBmYWxzZSkgKyAnKCc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2t0ICs9IHRoaXMuZ2VvbWV0cmllc1tpXS50b1drdCgpICsgJywnO1xyXG5cclxuICAgIHdrdCA9IHdrdC5zbGljZSgwLCAtMSk7XHJcbiAgICB3a3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiB3a3Q7XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5HZW9tZXRyeUNvbGxlY3Rpb24pO1xyXG4gICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2tiLndyaXRlQnVmZmVyKHRoaXMuZ2VvbWV0cmllc1tpXS50b1drYih7IHNyaWQ6IHRoaXMuc3JpZCB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5HZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICB0aGlzLl93cml0ZVR3a2JIZWFkZXIodHdrYiwgVHlwZXMud2tiLkdlb21ldHJ5Q29sbGVjdGlvbiwgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdHdrYi53cml0ZUJ1ZmZlcih0aGlzLmdlb21ldHJpZXNbaV0udG9Ud2tiKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbkdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2l6ZSA9IDEgKyA0ICsgNDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBzaXplICs9IHRoaXMuZ2VvbWV0cmllc1tpXS5fZ2V0V2tiU2l6ZSgpO1xyXG5cclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLkdlb21ldHJ5Q29sbGVjdGlvbjtcclxuICAgIGdlb0pTT04uZ2VvbWV0cmllcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdlb0pTT04uZ2VvbWV0cmllcy5wdXNoKHRoaXMuZ2VvbWV0cmllc1tpXS50b0dlb0pTT04oKSk7XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gTGluZVN0cmluZztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxudmFyIEJpbmFyeVdyaXRlciA9IHJlcXVpcmUoJy4vYmluYXJ5d3JpdGVyJyk7XHJcblxyXG5mdW5jdGlvbiBMaW5lU3RyaW5nKHBvaW50cywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5wb2ludHNbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLnBvaW50c1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKExpbmVTdHJpbmcsIEdlb21ldHJ5KTtcclxuXHJcbkxpbmVTdHJpbmcuWiA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcocG9pbnRzLCBzcmlkKTtcclxuICAgIGxpbmVTdHJpbmcuaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuTSA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcocG9pbnRzLCBzcmlkKTtcclxuICAgIGxpbmVTdHJpbmcuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuWk0gPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKHBvaW50cywgc3JpZCk7XHJcbiAgICBsaW5lU3RyaW5nLmhhc1ogPSB0cnVlO1xyXG4gICAgbGluZVN0cmluZy5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoKTtcclxuICAgIGxpbmVTdHJpbmcuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIGxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgIGxpbmVTdHJpbmcucG9pbnRzLnB1c2guYXBwbHkobGluZVN0cmluZy5wb2ludHMsIHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcuX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKCk7XHJcbiAgICBsaW5lU3RyaW5nLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBsaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBsaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIHBvaW50Q291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspXHJcbiAgICAgICAgbGluZVN0cmluZy5wb2ludHMucHVzaChQb2ludC5fcmVhZFdrYlBvaW50KHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLl9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoKTtcclxuICAgIGxpbmVTdHJpbmcuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIGxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG5cclxuICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIG9wdGlvbnMuaGFzWiA/IDAgOiB1bmRlZmluZWQsIG9wdGlvbnMuaGFzTSA/IDAgOiB1bmRlZmluZWQpO1xyXG4gICAgdmFyIHBvaW50Q291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspXHJcbiAgICAgICAgbGluZVN0cmluZy5wb2ludHMucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgIHJldHVybiBsaW5lU3RyaW5nO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgbGluZVN0cmluZy5oYXNaID0gdmFsdWUuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGxpbmVTdHJpbmcucG9pbnRzLnB1c2goUG9pbnQuX3JlYWRHZW9KU09OUG9pbnQodmFsdWUuY29vcmRpbmF0ZXNbaV0pKTtcclxuXHJcbiAgICByZXR1cm4gbGluZVN0cmluZztcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTGluZVN0cmluZywgdHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LkxpbmVTdHJpbmcsIGZhbHNlKSArIHRoaXMuX3RvSW5uZXJXa3QoKTtcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLl90b0lubmVyV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGlubmVyV2t0ID0gJygnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgaW5uZXJXa3QgKz0gdGhpcy5fZ2V0V2t0Q29vcmRpbmF0ZSh0aGlzLnBvaW50c1tpXSkgKyAnLCc7XHJcblxyXG4gICAgaW5uZXJXa3QgPSBpbm5lcldrdC5zbGljZSgwLCAtMSk7XHJcbiAgICBpbm5lcldrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIGlubmVyV2t0O1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAocGFyZW50T3B0aW9ucykge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5MaW5lU3RyaW5nLCBwYXJlbnRPcHRpb25zKTtcclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMucG9pbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0aGlzLnBvaW50c1tpXS5fd3JpdGVXa2JQb2ludCh3a2IpO1xyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTGluZVN0cmluZy5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLnBvaW50cy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5MaW5lU3RyaW5nLCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLnBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLnBvaW50c1tpXS5fd3JpdGVUd2tiUG9pbnQodHdrYiwgcHJlY2lzaW9uLCBwcmV2aW91c1BvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb29yZGluYXRlU2l6ZSA9IDE2O1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuXHJcbiAgICByZXR1cm4gMSArIDQgKyA0ICsgKHRoaXMucG9pbnRzLmxlbmd0aCAqIGNvb3JkaW5hdGVTaXplKTtcclxufTtcclxuXHJcbkxpbmVTdHJpbmcucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uTGluZVN0cmluZztcclxuICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKFt0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55LCB0aGlzLnBvaW50c1tpXS56XSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2goW3RoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aUxpbmVTdHJpbmc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBMaW5lU3RyaW5nID0gcmVxdWlyZSgnLi9saW5lc3RyaW5nJyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCBzcmlkKSB7XHJcbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubGluZVN0cmluZ3MgPSBsaW5lU3RyaW5ncyB8fCBbXTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIGlmICh0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLmxpbmVTdHJpbmdzWzBdLmhhc1o7XHJcbiAgICAgICAgdGhpcy5oYXNNID0gdGhpcy5saW5lU3RyaW5nc1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKE11bHRpTGluZVN0cmluZywgR2VvbWV0cnkpO1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLlogPSBmdW5jdGlvbiAobGluZVN0cmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCBzcmlkKTtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuTSA9IGZ1bmN0aW9uIChsaW5lU3RyaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHNyaWQpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5aTSA9IGZ1bmN0aW9uIChsaW5lU3RyaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHNyaWQpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSB0cnVlO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKHZhbHVlLmlzTWF0Y2goWydFTVBUWSddKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG4gICAgICAgIG11bHRpTGluZVN0cmluZy5saW5lU3RyaW5ncy5wdXNoKG5ldyBMaW5lU3RyaW5nKHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpKTtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG4gICAgfSB3aGlsZSAodmFsdWUuaXNNYXRjaChbJywnXSkpO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKCk7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIGxpbmVTdHJpbmdDb3VudCA9IHZhbHVlLnJlYWRVSW50MzIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTdHJpbmdDb3VudDsgaSsrKVxyXG4gICAgICAgIG11bHRpTGluZVN0cmluZy5saW5lU3RyaW5ncy5wdXNoKEdlb21ldHJ5LnBhcnNlKHZhbHVlLCBvcHRpb25zKSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZygpO1xyXG4gICAgbXVsdGlMaW5lU3RyaW5nLmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aUxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgb3B0aW9ucy5oYXNaID8gMCA6IHVuZGVmaW5lZCwgb3B0aW9ucy5oYXNNID8gMCA6IHVuZGVmaW5lZCk7XHJcbiAgICB2YXIgbGluZVN0cmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVN0cmluZ0NvdW50OyBpKyspIHtcclxuICAgICAgICB2YXIgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKCk7XHJcbiAgICAgICAgbGluZVN0cmluZy5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgICAgIGxpbmVTdHJpbmcuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICAgICAgdmFyIHBvaW50Q291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRDb3VudDsgaisrKVxyXG4gICAgICAgICAgICBsaW5lU3RyaW5nLnBvaW50cy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgICAgIG11bHRpTGluZVN0cmluZy5saW5lU3RyaW5ncy5wdXNoKGxpbmVTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcuX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIG11bHRpTGluZVN0cmluZyA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoKTtcclxuXHJcbiAgICBpZiAodmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoID4gMCAmJiB2YWx1ZS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAwKVxyXG4gICAgICAgIG11bHRpTGluZVN0cmluZy5oYXNaID0gdmFsdWUuY29vcmRpbmF0ZXNbMF1bMF0ubGVuZ3RoID4gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIG11bHRpTGluZVN0cmluZy5saW5lU3RyaW5ncy5wdXNoKExpbmVTdHJpbmcuX3BhcnNlR2VvSlNPTih7IGNvb3JkaW5hdGVzOiB2YWx1ZS5jb29yZGluYXRlc1tpXSB9KSk7XHJcblxyXG4gICAgcmV0dXJuIG11bHRpTGluZVN0cmluZztcclxufTtcclxuXHJcbk11bHRpTGluZVN0cmluZy5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5saW5lU3RyaW5ncy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpTGluZVN0cmluZywgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHdrdCA9IHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0Lk11bHRpTGluZVN0cmluZywgZmFsc2UpICsgJygnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lU3RyaW5ncy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a3QgKz0gdGhpcy5saW5lU3RyaW5nc1tpXS5fdG9Jbm5lcldrdCgpICsgJywnO1xyXG5cclxuICAgIHdrdCA9IHdrdC5zbGljZSgwLCAtMSk7XHJcbiAgICB3a3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiB3a3Q7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnRvV2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5NdWx0aUxpbmVTdHJpbmcpO1xyXG4gICAgd2tiLndyaXRlVUludDMyTEUodGhpcy5saW5lU3RyaW5ncy5sZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lU3RyaW5ncy5sZW5ndGg7IGkrKylcclxuICAgICAgICB3a2Iud3JpdGVCdWZmZXIodGhpcy5saW5lU3RyaW5nc1tpXS50b1drYih7IHNyaWQ6IHRoaXMuc3JpZCB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5saW5lU3RyaW5ncy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5NdWx0aUxpbmVTdHJpbmcsIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKHRoaXMubGluZVN0cmluZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5saW5lU3RyaW5ncy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLmxpbmVTdHJpbmdzW2ldLnBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxpbmVTdHJpbmdzW2ldLnBvaW50cy5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0cmluZ3NbaV0ucG9pbnRzW2pdLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5NdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLl9nZXRXa2JTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNpemUgPSAxICsgNCArIDQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHNpemUgKz0gdGhpcy5saW5lU3RyaW5nc1tpXS5fZ2V0V2tiU2l6ZSgpO1xyXG5cclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLk11bHRpTGluZVN0cmluZztcclxuICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZVN0cmluZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKHRoaXMubGluZVN0cmluZ3NbaV0udG9HZW9KU09OKCkuY29vcmRpbmF0ZXMpO1xyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IE11bHRpUG9pbnQ7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlQb2ludChwb2ludHMsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHRcclxuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5wb2ludHNbMF0uaGFzWjtcclxuICAgICAgICB0aGlzLmhhc00gPSB0aGlzLnBvaW50c1swXS5oYXNNO1xyXG4gICAgfVxyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKE11bHRpUG9pbnQsIEdlb21ldHJ5KTtcclxuXHJcbk11bHRpUG9pbnQuWiA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQocG9pbnRzLCBzcmlkKTtcclxuICAgIG11bHRpUG9pbnQuaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuTSA9IGZ1bmN0aW9uIChwb2ludHMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQocG9pbnRzLCBzcmlkKTtcclxuICAgIG11bHRpUG9pbnQuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuWk0gPSBmdW5jdGlvbiAocG9pbnRzLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHBvaW50cywgc3JpZCk7XHJcbiAgICBtdWx0aVBvaW50Lmhhc1ogPSB0cnVlO1xyXG4gICAgbXVsdGlQb2ludC5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQoKTtcclxuICAgIG11bHRpUG9pbnQuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIG11bHRpUG9pbnQuaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9pbnQuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAodmFsdWUuaXNNYXRjaChbJ0VNUFRZJ10pKVxyXG4gICAgICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgIG11bHRpUG9pbnQucG9pbnRzLnB1c2guYXBwbHkobXVsdGlQb2ludC5wb2ludHMsIHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KCk7XHJcbiAgICBtdWx0aVBvaW50LnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aVBvaW50Lmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvaW50Lmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgdmFyIHBvaW50Q291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspXHJcbiAgICAgICAgbXVsdGlQb2ludC5wb2ludHMucHVzaChHZW9tZXRyeS5wYXJzZSh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5fcGFyc2VUd2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KCk7XHJcbiAgICBtdWx0aVBvaW50Lmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBtdWx0aVBvaW50Lmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gbXVsdGlQb2ludDtcclxuXHJcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwLCBvcHRpb25zLmhhc1ogPyAwIDogdW5kZWZpbmVkLCBvcHRpb25zLmhhc00gPyAwIDogdW5kZWZpbmVkKTtcclxuICAgIHZhciBwb2ludENvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKVxyXG4gICAgICAgIG11bHRpUG9pbnQucG9pbnRzLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcclxufTtcclxuXHJcbk11bHRpUG9pbnQuX3BhcnNlR2VvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludCgpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgIG11bHRpUG9pbnQuaGFzWiA9IHZhbHVlLmNvb3JkaW5hdGVzWzBdLmxlbmd0aCA+IDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBtdWx0aVBvaW50LnBvaW50cy5wdXNoKFBvaW50Ll9wYXJzZUdlb0pTT04oeyBjb29yZGluYXRlczogdmFsdWUuY29vcmRpbmF0ZXNbaV0gfSkpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvaW50O1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aVBvaW50LCB0cnVlKTtcclxuXHJcbiAgICB2YXIgd2t0ID0gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuTXVsdGlQb2ludCwgZmFsc2UpICsgJygnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2t0ICs9IHRoaXMuX2dldFdrdENvb3JkaW5hdGUodGhpcy5wb2ludHNbaV0pICsgJywnO1xyXG5cclxuICAgIHdrdCA9IHdrdC5zbGljZSgwLCAtMSk7XHJcbiAgICB3a3QgKz0gJyknO1xyXG5cclxuICAgIHJldHVybiB3a3Q7XHJcbn07XHJcblxyXG5NdWx0aVBvaW50LnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuTXVsdGlQb2ludCk7XHJcbiAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLnBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2tiLndyaXRlQnVmZmVyKHRoaXMucG9pbnRzW2ldLnRvV2tiKHsgc3JpZDogdGhpcy5zcmlkIH0pKTtcclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcbk11bHRpUG9pbnQucHJvdG90eXBlLnRvVHdrYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0d2tiID0gbmV3IEJpbmFyeVdyaXRlcigwLCB0cnVlKTtcclxuXHJcbiAgICB2YXIgcHJlY2lzaW9uID0gR2VvbWV0cnkuZ2V0VHdrYlByZWNpc2lvbig1LCAwLCAwKTtcclxuICAgIHZhciBpc0VtcHR5ID0gdGhpcy5wb2ludHMubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuTXVsdGlQb2ludCwgcHJlY2lzaW9uLCBpc0VtcHR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5wb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlQb2ludC5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZVNpemUgPSAxNjtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNaKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIGNvb3JkaW5hdGVTaXplICs9IDg7XHJcblxyXG4gICAgY29vcmRpbmF0ZVNpemUgKz0gNTtcclxuXHJcbiAgICByZXR1cm4gMSArIDQgKyA0ICsgKHRoaXMucG9pbnRzLmxlbmd0aCAqIGNvb3JkaW5hdGVTaXplKTtcclxufTtcclxuXHJcbk11bHRpUG9pbnQucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZ2VvSlNPTiA9IEdlb21ldHJ5LnByb3RvdHlwZS50b0dlb0pTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIGdlb0pTT04udHlwZSA9IFR5cGVzLmdlb0pTT04uTXVsdGlQb2ludDtcclxuICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaCh0aGlzLnBvaW50c1tpXS50b0dlb0pTT04oKS5jb29yZGluYXRlcyk7XHJcblxyXG4gICAgcmV0dXJuIGdlb0pTT047XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gTXVsdGlQb2x5Z29uO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xyXG52YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4vcG9seWdvbicpO1xyXG52YXIgQmluYXJ5V3JpdGVyID0gcmVxdWlyZSgnLi9iaW5hcnl3cml0ZXInKTtcclxuXHJcbmZ1bmN0aW9uIE11bHRpUG9seWdvbihwb2x5Z29ucywgc3JpZCkge1xyXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBvbHlnb25zID0gcG9seWdvbnMgfHwgW107XHJcblx0dGhpcy5zcmlkID0gc3JpZDtcclxuXHJcbiAgICBpZiAodGhpcy5wb2x5Z29ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5oYXNaID0gdGhpcy5wb2x5Z29uc1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMucG9seWdvbnNbMF0uaGFzTTtcclxuICAgIH1cclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhNdWx0aVBvbHlnb24sIEdlb21ldHJ5KTtcclxuXHJcbk11bHRpUG9seWdvbi5aID0gZnVuY3Rpb24gKHBvbHlnb25zLCBzcmlkKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgc3JpZCk7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzWiA9IHRydWU7XHJcbiAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLk0gPSBmdW5jdGlvbiAocG9seWdvbnMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25zLCBzcmlkKTtcclxuICAgIG11bHRpUG9seWdvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uWk0gPSBmdW5jdGlvbiAocG9seWdvbnMsIHNyaWQpIHtcclxuICAgIHZhciBtdWx0aVBvbHlnb24gPSBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25zLCBzcmlkKTtcclxuICAgIG11bHRpUG9seWdvbi5oYXNaID0gdHJ1ZTtcclxuICAgIG11bHRpUG9seWdvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uX3BhcnNlV2t0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbigpO1xyXG4gICAgbXVsdGlQb2x5Z29uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICAgICAgdmFyIGV4dGVyaW9yUmluZyA9IFtdO1xyXG4gICAgICAgIHZhciBpbnRlcmlvclJpbmdzID0gW107XHJcblxyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgICAgICBleHRlcmlvclJpbmcucHVzaC5hcHBseShleHRlcmlvclJpbmcsIHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgICAgIHdoaWxlICh2YWx1ZS5pc01hdGNoKFsnLCddKSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICAgICAgICAgIGludGVyaW9yUmluZ3MucHVzaCh2YWx1ZS5tYXRjaENvb3JkaW5hdGVzKG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG11bHRpUG9seWdvbi5wb2x5Z29ucy5wdXNoKG5ldyBQb2x5Z29uKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncykpO1xyXG5cclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIH0gd2hpbGUgKHZhbHVlLmlzTWF0Y2goWycsJ10pKTtcclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbigpO1xyXG4gICAgbXVsdGlQb2x5Z29uLnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICBtdWx0aVBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIG11bHRpUG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIHZhciBwb2x5Z29uQ291bnQgPSB2YWx1ZS5yZWFkVUludDMyKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQ291bnQ7IGkrKylcclxuICAgICAgICBtdWx0aVBvbHlnb24ucG9seWdvbnMucHVzaChHZW9tZXRyeS5wYXJzZSh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24uX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24oKTtcclxuICAgIG11bHRpUG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgbXVsdGlQb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaXNFbXB0eSlcclxuICAgICAgICByZXR1cm4gbXVsdGlQb2x5Z29uO1xyXG5cclxuICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIG9wdGlvbnMuaGFzWiA/IDAgOiB1bmRlZmluZWQsIG9wdGlvbnMuaGFzTSA/IDAgOiB1bmRlZmluZWQpO1xyXG4gICAgdmFyIHBvbHlnb25Db3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbigpO1xyXG4gICAgICAgIHBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgICAgICBwb2x5Z29uLmhhc00gPSBvcHRpb25zLmhhc007XHJcblxyXG4gICAgICAgIHZhciByaW5nQ291bnQgPSB2YWx1ZS5yZWFkVmFySW50KCk7XHJcbiAgICAgICAgdmFyIGV4dGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4dGVyaW9yUmluZ0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHBvbHlnb24uZXh0ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRUd2tiUG9pbnQodmFsdWUsIG9wdGlvbnMsIHByZXZpb3VzUG9pbnQpKTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IHJpbmdDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcmlvclJpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW50ZXJpb3JSaW5nQ291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgIGludGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgICAgICAgICBwb2x5Z29uLmludGVyaW9yUmluZ3MucHVzaChpbnRlcmlvclJpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbXVsdGlQb2x5Z29uLnBvbHlnb25zLnB1c2gocG9seWdvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG11bHRpUG9seWdvbjtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgbXVsdGlQb2x5Z29uID0gbmV3IE11bHRpUG9seWdvbigpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGggPiAwICYmIHZhbHVlLmNvb3JkaW5hdGVzWzBdLmxlbmd0aCA+IDAgJiYgdmFsdWUuY29vcmRpbmF0ZXNbMF1bMF0ubGVuZ3RoID4gMClcclxuICAgICAgICBtdWx0aVBvbHlnb24uaGFzWiA9IHZhbHVlLmNvb3JkaW5hdGVzWzBdWzBdWzBdLmxlbmd0aCA+IDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBtdWx0aVBvbHlnb24ucG9seWdvbnMucHVzaChQb2x5Z29uLl9wYXJzZUdlb0pTT04oeyBjb29yZGluYXRlczogdmFsdWUuY29vcmRpbmF0ZXNbaV0gfSkpO1xyXG5cclxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XHJcbn07XHJcblxyXG5NdWx0aVBvbHlnb24ucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMucG9seWdvbnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aVBvbHlnb24sIHRydWUpO1xyXG5cclxuICAgIHZhciB3a3QgPSB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5NdWx0aVBvbHlnb24sIGZhbHNlKSArICcoJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2t0ICs9IHRoaXMucG9seWdvbnNbaV0uX3RvSW5uZXJXa3QoKSArICcsJztcclxuXHJcbiAgICB3a3QgPSB3a3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgd2t0ICs9ICcpJztcclxuXHJcbiAgICByZXR1cm4gd2t0O1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLnByb3RvdHlwZS50b1drYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKHRoaXMuX2dldFdrYlNpemUoKSk7XHJcblxyXG4gICAgd2tiLndyaXRlSW50OCgxKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZVdrYlR5cGUod2tiLCBUeXBlcy53a2IuTXVsdGlQb2x5Z29uKTtcclxuICAgIHdrYi53cml0ZVVJbnQzMkxFKHRoaXMucG9seWdvbnMubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgd2tiLndyaXRlQnVmZmVyKHRoaXMucG9seWdvbnNbaV0udG9Xa2IoeyBzcmlkOiB0aGlzLnNyaWQgfSkpO1xyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHRoaXMucG9seWdvbnMubGVuZ3RoID09PSAwO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuTXVsdGlQb2x5Z29uLCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLnBvbHlnb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KHRoaXMucG9seWdvbnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHR3a2Iud3JpdGVWYXJJbnQoMSArIHRoaXMucG9seWdvbnNbaV0uaW50ZXJpb3JSaW5ncy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLnBvbHlnb25zW2ldLmV4dGVyaW9yUmluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnBvbHlnb25zW2ldLmV4dGVyaW9yUmluZy5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbnNbaV0uZXh0ZXJpb3JSaW5nW2pdLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucG9seWdvbnNbaV0uaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLnBvbHlnb25zW2ldLmludGVyaW9yUmluZ3Nbal0ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMucG9seWdvbnNbaV0uaW50ZXJpb3JSaW5nc1tqXS5sZW5ndGg7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25zW2ldLmludGVyaW9yUmluZ3Nbal1ba10uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzaXplID0gMSArIDQgKyA0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2x5Z29ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICBzaXplICs9IHRoaXMucG9seWdvbnNbaV0uX2dldFdrYlNpemUoKTtcclxuXHJcbiAgICByZXR1cm4gc2l6ZTtcclxufTtcclxuXHJcbk11bHRpUG9seWdvbi5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5NdWx0aVBvbHlnb247XHJcbiAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvbHlnb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMucHVzaCh0aGlzLnBvbHlnb25zW2ldLnRvR2VvSlNPTigpLmNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG52YXIgWmlnWmFnID0gcmVxdWlyZSgnLi96aWd6YWcuanMnKTtcclxuXHJcbmZ1bmN0aW9uIFBvaW50KHgsIHksIHosIG0sIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLnogPSB6O1xyXG4gICAgdGhpcy5tID0gbTtcclxuXHR0aGlzLnNyaWQgPSBzcmlkO1xyXG5cclxuICAgIHRoaXMuaGFzWiA9IHR5cGVvZiB0aGlzLnogIT09ICd1bmRlZmluZWQnO1xyXG4gICAgdGhpcy5oYXNNID0gdHlwZW9mIHRoaXMubSAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoUG9pbnQsIEdlb21ldHJ5KTtcclxuXHJcblBvaW50LlogPSBmdW5jdGlvbiAoeCwgeSwgeiwgc3JpZCkge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHksIHosIHVuZGVmaW5lZCwgc3JpZCk7XHJcbiAgICBwb2ludC5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50Lk0gPSBmdW5jdGlvbiAoeCwgeSwgbSwgc3JpZCkge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHksIHVuZGVmaW5lZCwgbSwgc3JpZCk7XHJcbiAgICBwb2ludC5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcblBvaW50LlpNID0gZnVuY3Rpb24gKHgsIHksIHosIG0sIHNyaWQpIHtcclxuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5LCB6LCBtLCBzcmlkKTtcclxuICAgIHBvaW50Lmhhc1ogPSB0cnVlO1xyXG4gICAgcG9pbnQuaGFzTSA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5fcGFyc2VXa3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgpO1xyXG4gICAgcG9pbnQuc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIHBvaW50Lmhhc1ogPSBvcHRpb25zLmhhc1o7XHJcbiAgICBwb2ludC5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuXHJcbiAgICB2YXIgY29vcmRpbmF0ZSA9IHZhbHVlLm1hdGNoQ29vcmRpbmF0ZShvcHRpb25zKTtcclxuXHJcbiAgICBwb2ludC54ID0gY29vcmRpbmF0ZS54O1xyXG4gICAgcG9pbnQueSA9IGNvb3JkaW5hdGUueTtcclxuICAgIHBvaW50LnogPSBjb29yZGluYXRlLno7XHJcbiAgICBwb2ludC5tID0gY29vcmRpbmF0ZS5tO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwRW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxuUG9pbnQuX3BhcnNlV2tiID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcG9pbnQgPSBQb2ludC5fcmVhZFdrYlBvaW50KHZhbHVlLCBvcHRpb25zKTtcclxuICAgIHBvaW50LnNyaWQgPSBvcHRpb25zLnNyaWQ7XHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5fcmVhZFdrYlBvaW50ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHZhbHVlLnJlYWREb3VibGUoKSwgdmFsdWUucmVhZERvdWJsZSgpLFxyXG4gICAgICAgIG9wdGlvbnMuaGFzWiA/IHZhbHVlLnJlYWREb3VibGUoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICBvcHRpb25zLmhhc00gPyB2YWx1ZS5yZWFkRG91YmxlKCkgOiB1bmRlZmluZWQpO1xyXG59O1xyXG5cclxuUG9pbnQuX3BhcnNlVHdrYiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KCk7XHJcbiAgICBwb2ludC5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgcG9pbnQuaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuXHJcbiAgICBwb2ludC54ID0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5wcmVjaXNpb25GYWN0b3I7XHJcbiAgICBwb2ludC55ID0gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy5wcmVjaXNpb25GYWN0b3I7XHJcbiAgICBwb2ludC56ID0gb3B0aW9ucy5oYXNaID8gWmlnWmFnLmRlY29kZSh2YWx1ZS5yZWFkVmFySW50KCkpIC8gb3B0aW9ucy56UHJlY2lzaW9uRmFjdG9yIDogdW5kZWZpbmVkO1xyXG4gICAgcG9pbnQubSA9IG9wdGlvbnMuaGFzTSA/IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMubVByZWNpc2lvbkZhY3RvciA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5Qb2ludC5fcmVhZFR3a2JQb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkge1xyXG4gICAgcHJldmlvdXNQb2ludC54ICs9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMucHJlY2lzaW9uRmFjdG9yO1xyXG4gICAgcHJldmlvdXNQb2ludC55ICs9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMucHJlY2lzaW9uRmFjdG9yO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmhhc1opXHJcbiAgICAgICAgcHJldmlvdXNQb2ludC56ICs9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMuelByZWNpc2lvbkZhY3RvcjtcclxuICAgIGlmIChvcHRpb25zLmhhc00pXHJcbiAgICAgICAgcHJldmlvdXNQb2ludC5tICs9IFppZ1phZy5kZWNvZGUodmFsdWUucmVhZFZhckludCgpKSAvIG9wdGlvbnMubVByZWNpc2lvbkZhY3RvcjtcclxuXHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHByZXZpb3VzUG9pbnQueCwgcHJldmlvdXNQb2ludC55LCBwcmV2aW91c1BvaW50LnosIHByZXZpb3VzUG9pbnQubSk7XHJcbn07XHJcblxyXG5Qb2ludC5fcGFyc2VHZW9KU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gUG9pbnQuX3JlYWRHZW9KU09OUG9pbnQodmFsdWUuY29vcmRpbmF0ZXMpO1xyXG59O1xyXG5cclxuUG9pbnQuX3JlYWRHZW9KU09OUG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcclxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgpO1xyXG5cclxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAyKVxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdLCBjb29yZGluYXRlc1syXSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQb2ludChjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0pO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLnRvV2t0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIHRoaXMueiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMubSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdrdFR5cGUoVHlwZXMud2t0LlBvaW50LCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuUG9pbnQsIGZhbHNlKSArICcoJyArIHRoaXMuX2dldFdrdENvb3JkaW5hdGUodGhpcykgKyAnKSc7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAocGFyZW50T3B0aW9ucykge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG4gICAgdGhpcy5fd3JpdGVXa2JUeXBlKHdrYiwgVHlwZXMud2tiLlBvaW50LCBwYXJlbnRPcHRpb25zKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMueSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3a2Iud3JpdGVEb3VibGVMRShOYU4pO1xyXG4gICAgICAgIHdrYi53cml0ZURvdWJsZUxFKE5hTik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgIHdrYi53cml0ZURvdWJsZUxFKE5hTik7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICAgICAgd2tiLndyaXRlRG91YmxlTEUoTmFOKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV2tiUG9pbnQod2tiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gd2tiLmJ1ZmZlcjtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5fd3JpdGVXa2JQb2ludCA9IGZ1bmN0aW9uICh3a2IpIHtcclxuICAgIHdrYi53cml0ZURvdWJsZUxFKHRoaXMueCk7XHJcbiAgICB3a2Iud3JpdGVEb3VibGVMRSh0aGlzLnkpO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgd2tiLndyaXRlRG91YmxlTEUodGhpcy56KTtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgd2tiLndyaXRlRG91YmxlTEUodGhpcy5tKTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS50b1R3a2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIoMCwgdHJ1ZSk7XHJcblxyXG4gICAgdmFyIHByZWNpc2lvbiA9IEdlb21ldHJ5LmdldFR3a2JQcmVjaXNpb24oNSwgMCwgMCk7XHJcbiAgICB2YXIgaXNFbXB0eSA9IHR5cGVvZiB0aGlzLnggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlVHdrYkhlYWRlcih0d2tiLCBUeXBlcy53a2IuUG9pbnQsIHByZWNpc2lvbiwgaXNFbXB0eSk7XHJcblxyXG4gICAgaWYgKCFpc0VtcHR5KVxyXG4gICAgICAgIHRoaXMuX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgbmV3IFBvaW50KDAsIDAsIDAsIDApKTtcclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuX3dyaXRlVHdrYlBvaW50ID0gZnVuY3Rpb24gKHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCkge1xyXG4gICAgdmFyIHggPSB0aGlzLnggKiBwcmVjaXNpb24ueHlGYWN0b3I7XHJcbiAgICB2YXIgeSA9IHRoaXMueSAqIHByZWNpc2lvbi54eUZhY3RvcjtcclxuICAgIHZhciB6ID0gdGhpcy56ICogcHJlY2lzaW9uLnpGYWN0b3I7XHJcbiAgICB2YXIgbSA9IHRoaXMubSAqIHByZWNpc2lvbi5tRmFjdG9yO1xyXG5cclxuICAgIHR3a2Iud3JpdGVWYXJJbnQoWmlnWmFnLmVuY29kZSh4IC0gcHJldmlvdXNQb2ludC54KSk7XHJcbiAgICB0d2tiLndyaXRlVmFySW50KFppZ1phZy5lbmNvZGUoeSAtIHByZXZpb3VzUG9pbnQueSkpO1xyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KFppZ1phZy5lbmNvZGUoeiAtIHByZXZpb3VzUG9pbnQueikpO1xyXG4gICAgaWYgKHRoaXMuaGFzTSlcclxuICAgICAgICB0d2tiLndyaXRlVmFySW50KFppZ1phZy5lbmNvZGUobSAtIHByZXZpb3VzUG9pbnQubSkpO1xyXG5cclxuICAgIHByZXZpb3VzUG9pbnQueCA9IHg7XHJcbiAgICBwcmV2aW91c1BvaW50LnkgPSB5O1xyXG4gICAgcHJldmlvdXNQb2ludC56ID0gejtcclxuICAgIHByZXZpb3VzUG9pbnQubSA9IG07XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuX2dldFdrYlNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2l6ZSA9IDEgKyA0ICsgOCArIDg7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzWilcclxuICAgICAgICBzaXplICs9IDg7XHJcbiAgICBpZiAodGhpcy5oYXNNKVxyXG4gICAgICAgIHNpemUgKz0gODtcclxuXHJcbiAgICByZXR1cm4gc2l6ZTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGdlb0pTT04gPSBHZW9tZXRyeS5wcm90b3R5cGUudG9HZW9KU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBnZW9KU09OLnR5cGUgPSBUeXBlcy5nZW9KU09OLlBvaW50O1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy54ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy55ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW107XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy56ICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzID0gW3RoaXMueCwgdGhpcy55LCB0aGlzLnpdO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGdlb0pTT04uY29vcmRpbmF0ZXMgPSBbdGhpcy54LCB0aGlzLnldO1xyXG5cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcbnZhciBCaW5hcnlXcml0ZXIgPSByZXF1aXJlKCcuL2JpbmFyeXdyaXRlcicpO1xyXG5cclxuZnVuY3Rpb24gUG9seWdvbihleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpIHtcclxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5leHRlcmlvclJpbmcgPSBleHRlcmlvclJpbmcgfHwgW107XHJcbiAgICB0aGlzLmludGVyaW9yUmluZ3MgPSBpbnRlcmlvclJpbmdzIHx8IFtdO1xyXG5cdHRoaXMuc3JpZCA9IHNyaWQ7XHJcblxyXG4gICAgaWYgKHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhc1ogPSB0aGlzLmV4dGVyaW9yUmluZ1swXS5oYXNaO1xyXG4gICAgICAgIHRoaXMuaGFzTSA9IHRoaXMuZXh0ZXJpb3JSaW5nWzBdLmhhc007XHJcbiAgICB9XHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoUG9seWdvbiwgR2VvbWV0cnkpO1xyXG5cclxuUG9seWdvbi5aID0gZnVuY3Rpb24gKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbihleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpO1xyXG4gICAgcG9seWdvbi5oYXNaID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5NID0gZnVuY3Rpb24gKGV4dGVyaW9yUmluZywgaW50ZXJpb3JSaW5ncywgc3JpZCkge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbihleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpO1xyXG4gICAgcG9seWdvbi5oYXNNID0gdHJ1ZTtcclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5aTSA9IGZ1bmN0aW9uIChleHRlcmlvclJpbmcsIGludGVyaW9yUmluZ3MsIHNyaWQpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZXh0ZXJpb3JSaW5nLCBpbnRlcmlvclJpbmdzLCBzcmlkKTtcclxuICAgIHBvbHlnb24uaGFzWiA9IHRydWU7XHJcbiAgICBwb2x5Z29uLmhhc00gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLl9wYXJzZVdrdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbigpO1xyXG4gICAgcG9seWdvbi5zcmlkID0gb3B0aW9ucy5zcmlkO1xyXG4gICAgcG9seWdvbi5oYXNaID0gb3B0aW9ucy5oYXNaO1xyXG4gICAgcG9seWdvbi5oYXNNID0gb3B0aW9ucy5oYXNNO1xyXG5cclxuICAgIGlmICh2YWx1ZS5pc01hdGNoKFsnRU1QVFknXSkpXHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcblxyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBTdGFydCgpO1xyXG5cclxuICAgIHZhbHVlLmV4cGVjdEdyb3VwU3RhcnQoKTtcclxuICAgIHBvbHlnb24uZXh0ZXJpb3JSaW5nLnB1c2guYXBwbHkocG9seWdvbi5leHRlcmlvclJpbmcsIHZhbHVlLm1hdGNoQ29vcmRpbmF0ZXMob3B0aW9ucykpO1xyXG4gICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuXHJcbiAgICB3aGlsZSAodmFsdWUuaXNNYXRjaChbJywnXSkpIHtcclxuICAgICAgICB2YWx1ZS5leHBlY3RHcm91cFN0YXJ0KCk7XHJcbiAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzLnB1c2godmFsdWUubWF0Y2hDb29yZGluYXRlcyhvcHRpb25zKSk7XHJcbiAgICAgICAgdmFsdWUuZXhwZWN0R3JvdXBFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZS5leHBlY3RHcm91cEVuZCgpO1xyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5fcGFyc2VXa2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oKTtcclxuICAgIHBvbHlnb24uc3JpZCA9IG9wdGlvbnMuc3JpZDtcclxuICAgIHBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIHBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICB2YXIgcmluZ0NvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgIGlmIChyaW5nQ291bnQgPiAwKSB7XHJcbiAgICAgICAgdmFyIGV4dGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVyaW9yUmluZ0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHBvbHlnb24uZXh0ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRXa2JQb2ludCh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmluZ0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGludGVyaW9yUmluZyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFVJbnQzMigpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnRlcmlvclJpbmdDb3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgaW50ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRXa2JQb2ludCh2YWx1ZSwgb3B0aW9ucykpO1xyXG5cclxuICAgICAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzLnB1c2goaW50ZXJpb3JSaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLl9wYXJzZVR3a2IgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oKTtcclxuICAgIHBvbHlnb24uaGFzWiA9IG9wdGlvbnMuaGFzWjtcclxuICAgIHBvbHlnb24uaGFzTSA9IG9wdGlvbnMuaGFzTTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc0VtcHR5KVxyXG4gICAgICAgIHJldHVybiBwb2x5Z29uO1xyXG5cclxuICAgIHZhciBwcmV2aW91c1BvaW50ID0gbmV3IFBvaW50KDAsIDAsIG9wdGlvbnMuaGFzWiA/IDAgOiB1bmRlZmluZWQsIG9wdGlvbnMuaGFzTSA/IDAgOiB1bmRlZmluZWQpO1xyXG4gICAgdmFyIHJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuICAgIHZhciBleHRlcmlvclJpbmdDb3VudCA9IHZhbHVlLnJlYWRWYXJJbnQoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVyaW9yUmluZ0NvdW50OyBpKyspXHJcbiAgICAgICAgcG9seWdvbi5leHRlcmlvclJpbmcucHVzaChQb2ludC5fcmVhZFR3a2JQb2ludCh2YWx1ZSwgb3B0aW9ucywgcHJldmlvdXNQb2ludCkpO1xyXG5cclxuICAgIGZvciAoaSA9IDE7IGkgPCByaW5nQ291bnQ7IGkrKykge1xyXG4gICAgICAgIHZhciBpbnRlcmlvclJpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVyaW9yUmluZ0NvdW50ID0gdmFsdWUucmVhZFZhckludCgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGludGVyaW9yUmluZ0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgIGludGVyaW9yUmluZy5wdXNoKFBvaW50Ll9yZWFkVHdrYlBvaW50KHZhbHVlLCBvcHRpb25zLCBwcmV2aW91c1BvaW50KSk7XHJcblxyXG4gICAgICAgIHBvbHlnb24uaW50ZXJpb3JSaW5ncy5wdXNoKGludGVyaW9yUmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb247XHJcbn07XHJcblxyXG5Qb2x5Z29uLl9wYXJzZUdlb0pTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oKTtcclxuXHJcbiAgICBpZiAodmFsdWUuY29vcmRpbmF0ZXMubGVuZ3RoID4gMCAmJiB2YWx1ZS5jb29yZGluYXRlc1swXS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHBvbHlnb24uaGFzWiA9IHZhbHVlLmNvb3JkaW5hdGVzWzBdWzBdLmxlbmd0aCA+IDI7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpID4gMClcclxuICAgICAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzLnB1c2goW10pO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAgPCB2YWx1ZS5jb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMClcclxuICAgICAgICAgICAgICAgIHBvbHlnb24uZXh0ZXJpb3JSaW5nLnB1c2goUG9pbnQuX3JlYWRHZW9KU09OUG9pbnQodmFsdWUuY29vcmRpbmF0ZXNbaV1bal0pKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5pbnRlcmlvclJpbmdzW2kgLSAxXS5wdXNoKFBvaW50Ll9yZWFkR2VvSlNPTlBvaW50KHZhbHVlLmNvb3JkaW5hdGVzW2ldW2pdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUudG9Xa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRXa3RUeXBlKFR5cGVzLndrdC5Qb2x5Z29uLCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0V2t0VHlwZShUeXBlcy53a3QuUG9seWdvbiwgZmFsc2UpICsgdGhpcy5fdG9Jbm5lcldrdCgpO1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUuX3RvSW5uZXJXa3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaW5uZXJXa3QgPSAnKCgnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRlcmlvclJpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgaW5uZXJXa3QgKz0gdGhpcy5fZ2V0V2t0Q29vcmRpbmF0ZSh0aGlzLmV4dGVyaW9yUmluZ1tpXSkgKyAnLCc7XHJcblxyXG4gICAgaW5uZXJXa3QgPSBpbm5lcldrdC5zbGljZSgwLCAtMSk7XHJcbiAgICBpbm5lcldrdCArPSAnKSc7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlubmVyV2t0ICs9ICcsKCc7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlubmVyV2t0ICs9IHRoaXMuX2dldFdrdENvb3JkaW5hdGUodGhpcy5pbnRlcmlvclJpbmdzW2ldW2pdKSArICcsJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlubmVyV2t0ID0gaW5uZXJXa3Quc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgIGlubmVyV2t0ICs9ICcpJztcclxuICAgIH1cclxuXHJcbiAgICBpbm5lcldrdCArPSAnKSc7XHJcblxyXG4gICAgcmV0dXJuIGlubmVyV2t0O1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUudG9Xa2IgPSBmdW5jdGlvbiAocGFyZW50T3B0aW9ucykge1xyXG4gICAgdmFyIHdrYiA9IG5ldyBCaW5hcnlXcml0ZXIodGhpcy5fZ2V0V2tiU2l6ZSgpKTtcclxuXHJcbiAgICB3a2Iud3JpdGVJbnQ4KDEpO1xyXG5cclxuICAgIHRoaXMuX3dyaXRlV2tiVHlwZSh3a2IsIFR5cGVzLndrYi5Qb2x5Z29uLCBwYXJlbnRPcHRpb25zKTtcclxuXHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHdrYi53cml0ZVVJbnQzMkxFKDEgKyB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoKTtcclxuICAgICAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2tiLndyaXRlVUludDMyTEUoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0aGlzLmV4dGVyaW9yUmluZ1tpXS5fd3JpdGVXa2JQb2ludCh3a2IpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB3a2Iud3JpdGVVSW50MzJMRSh0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJpb3JSaW5nc1tpXVtqXS5fd3JpdGVXa2JQb2ludCh3a2IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB3a2IuYnVmZmVyO1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUudG9Ud2tiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHR3a2IgPSBuZXcgQmluYXJ5V3JpdGVyKDAsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcmVjaXNpb24gPSBHZW9tZXRyeS5nZXRUd2tiUHJlY2lzaW9uKDUsIDAsIDApO1xyXG4gICAgdmFyIGlzRW1wdHkgPSB0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgdGhpcy5fd3JpdGVUd2tiSGVhZGVyKHR3a2IsIFR5cGVzLndrYi5Qb2x5Z29uLCBwcmVjaXNpb24sIGlzRW1wdHkpO1xyXG5cclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdHdrYi53cml0ZVZhckludCgxICsgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHR3a2Iud3JpdGVWYXJJbnQodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5leHRlcmlvclJpbmdbaV0uX3dyaXRlVHdrYlBvaW50KHR3a2IsIHByZWNpc2lvbiwgcHJldmlvdXNQb2ludCk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHdrYi53cml0ZVZhckludCh0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnRlcmlvclJpbmdzW2ldLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmlvclJpbmdzW2ldW2pdLl93cml0ZVR3a2JQb2ludCh0d2tiLCBwcmVjaXNpb24sIHByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHdrYi5idWZmZXI7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZS5fZ2V0V2tiU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb29yZGluYXRlU2l6ZSA9IDE2O1xyXG5cclxuICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuICAgIGlmICh0aGlzLmhhc00pXHJcbiAgICAgICAgY29vcmRpbmF0ZVNpemUgKz0gODtcclxuXHJcbiAgICB2YXIgc2l6ZSA9IDEgKyA0ICsgNDtcclxuXHJcbiAgICBpZiAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoID4gMClcclxuICAgICAgICBzaXplICs9IDQgKyAodGhpcy5leHRlcmlvclJpbmcubGVuZ3RoICogY29vcmRpbmF0ZVNpemUpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHNpemUgKz0gNCArICh0aGlzLmludGVyaW9yUmluZ3NbaV0ubGVuZ3RoICogY29vcmRpbmF0ZVNpemUpO1xyXG5cclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBnZW9KU09OID0gR2VvbWV0cnkucHJvdG90eXBlLnRvR2VvSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgZ2VvSlNPTi50eXBlID0gVHlwZXMuZ2VvSlNPTi5Qb2x5Z29uO1xyXG4gICAgZ2VvSlNPTi5jb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGlmICh0aGlzLmV4dGVyaW9yUmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGV4dGVyaW9yUmluZyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0ZXJpb3JSaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgICAgICBleHRlcmlvclJpbmcucHVzaChbdGhpcy5leHRlcmlvclJpbmdbaV0ueCwgdGhpcy5leHRlcmlvclJpbmdbaV0ueSwgdGhpcy5leHRlcmlvclJpbmdbaV0uel0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBleHRlcmlvclJpbmcucHVzaChbdGhpcy5leHRlcmlvclJpbmdbaV0ueCwgdGhpcy5leHRlcmlvclJpbmdbaV0ueV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvSlNPTi5jb29yZGluYXRlcy5wdXNoKGV4dGVyaW9yUmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB2YXIgaW50ZXJpb3JSaW5nID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5pbnRlcmlvclJpbmdzW2pdLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1opXHJcbiAgICAgICAgICAgICAgICBpbnRlcmlvclJpbmcucHVzaChbdGhpcy5pbnRlcmlvclJpbmdzW2pdW2tdLngsIHRoaXMuaW50ZXJpb3JSaW5nc1tqXVtrXS55LCB0aGlzLmludGVyaW9yUmluZ3Nbal1ba10uel0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBpbnRlcmlvclJpbmcucHVzaChbdGhpcy5pbnRlcmlvclJpbmdzW2pdW2tdLngsIHRoaXMuaW50ZXJpb3JSaW5nc1tqXVtrXS55XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZW9KU09OLmNvb3JkaW5hdGVzLnB1c2goaW50ZXJpb3JSaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VvSlNPTjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB3a3Q6IHtcclxuICAgICAgICBQb2ludDogJ1BPSU5UJyxcclxuICAgICAgICBMaW5lU3RyaW5nOiAnTElORVNUUklORycsXHJcbiAgICAgICAgUG9seWdvbjogJ1BPTFlHT04nLFxyXG4gICAgICAgIE11bHRpUG9pbnQ6ICdNVUxUSVBPSU5UJyxcclxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6ICdNVUxUSUxJTkVTVFJJTkcnLFxyXG4gICAgICAgIE11bHRpUG9seWdvbjogJ01VTFRJUE9MWUdPTicsXHJcbiAgICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiAnR0VPTUVUUllDT0xMRUNUSU9OJ1xyXG4gICAgfSxcclxuICAgIHdrYjoge1xyXG4gICAgICAgIFBvaW50OiAxLFxyXG4gICAgICAgIExpbmVTdHJpbmc6IDIsXHJcbiAgICAgICAgUG9seWdvbjogMyxcclxuICAgICAgICBNdWx0aVBvaW50OiA0LFxyXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogNSxcclxuICAgICAgICBNdWx0aVBvbHlnb246IDYsXHJcbiAgICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiA3XHJcbiAgICB9LFxyXG4gICAgZ2VvSlNPTjoge1xyXG4gICAgICAgIFBvaW50OiAnUG9pbnQnLFxyXG4gICAgICAgIExpbmVTdHJpbmc6ICdMaW5lU3RyaW5nJyxcclxuICAgICAgICBQb2x5Z29uOiAnUG9seWdvbicsXHJcbiAgICAgICAgTXVsdGlQb2ludDogJ011bHRpUG9pbnQnLFxyXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogJ011bHRpTGluZVN0cmluZycsXHJcbiAgICAgICAgTXVsdGlQb2x5Z29uOiAnTXVsdGlQb2x5Z29uJyxcclxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcbiAgICB9XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gV2t0UGFyc2VyO1xyXG5cclxudmFyIFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XHJcblxyXG5mdW5jdGlvbiBXa3RQYXJzZXIodmFsdWUpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG59XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgdGhpcy5za2lwV2hpdGVzcGFjZXMoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlLnN1YnN0cmluZyh0aGlzLnBvc2l0aW9uKS5pbmRleE9mKHRva2Vuc1tpXSkgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSB0b2tlbnNbaV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2hSZWdleCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgIHRoaXMuc2tpcFdoaXRlc3BhY2VzKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLnZhbHVlLnN1YnN0cmluZyh0aGlzLnBvc2l0aW9uKS5tYXRjaCh0b2tlbnNbaV0pO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLmlzTWF0Y2ggPSBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICB0aGlzLnNraXBXaGl0ZXNwYWNlcygpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuc3Vic3RyaW5nKHRoaXMucG9zaXRpb24pLmluZGV4T2YodG9rZW5zW2ldKSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHRva2Vuc1tpXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLm1hdGNoVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSB0aGlzLm1hdGNoKFtUeXBlcy53a3QuUG9pbnQsIFR5cGVzLndrdC5MaW5lU3RyaW5nLCBUeXBlcy53a3QuUG9seWdvbiwgVHlwZXMud2t0Lk11bHRpUG9pbnQsXHJcbiAgICBUeXBlcy53a3QuTXVsdGlMaW5lU3RyaW5nLCBUeXBlcy53a3QuTXVsdGlQb2x5Z29uLCBUeXBlcy53a3QuR2VvbWV0cnlDb2xsZWN0aW9uXSk7XHJcblxyXG4gICAgaWYgKCFnZW9tZXRyeVR5cGUpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBnZW9tZXRyeSB0eXBlJyk7XHJcblxyXG4gICAgcmV0dXJuIGdlb21ldHJ5VHlwZTtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2hEaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5tYXRjaChbJ1pNJywgJ1onLCAnTSddKTtcclxuXHJcbiAgICBzd2l0Y2ggKGRpbWVuc2lvbikge1xyXG4gICAgICAgIGNhc2UgJ1pNJzogcmV0dXJuIHsgaGFzWjogdHJ1ZSwgaGFzTTogdHJ1ZSB9O1xyXG4gICAgICAgIGNhc2UgJ1onOiByZXR1cm4geyBoYXNaOiB0cnVlLCBoYXNNOiBmYWxzZSB9O1xyXG4gICAgICAgIGNhc2UgJ00nOiByZXR1cm4geyBoYXNaOiBmYWxzZSwgaGFzTTogdHJ1ZSB9O1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB7IGhhc1o6IGZhbHNlLCBoYXNNOiBmYWxzZSB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5leHBlY3RHcm91cFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzTWF0Y2goWycoJ10pKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZ3JvdXAgc3RhcnQnKTtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUuZXhwZWN0R3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNNYXRjaChbJyknXSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBncm91cCBlbmQnKTtcclxufTtcclxuXHJcbldrdFBhcnNlci5wcm90b3R5cGUubWF0Y2hDb29yZGluYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBtYXRjaDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNaICYmIG9wdGlvbnMuaGFzTSlcclxuICAgICAgICBtYXRjaCA9IHRoaXMubWF0Y2hSZWdleChbL14oXFxTKilcXHMrKFxcUyopXFxzKyhcXFMqKVxccysoW15cXHMsKV0qKS9dKTtcclxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaGFzWiB8fCBvcHRpb25zLmhhc00pXHJcbiAgICAgICAgbWF0Y2ggPSB0aGlzLm1hdGNoUmVnZXgoWy9eKFxcUyopXFxzKyhcXFMqKVxccysoW15cXHMsKV0qKS9dKTtcclxuICAgIGVsc2VcclxuICAgICAgICBtYXRjaCA9IHRoaXMubWF0Y2hSZWdleChbL14oXFxTKilcXHMrKFteXFxzLCldKikvXSk7XHJcblxyXG4gICAgaWYgKCFtYXRjaClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvb3JkaW5hdGVzJyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzWiAmJiBvcHRpb25zLmhhc00pXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwYXJzZUZsb2F0KG1hdGNoWzFdKSwgcGFyc2VGbG9hdChtYXRjaFsyXSksIHBhcnNlRmxvYXQobWF0Y2hbM10pLCBwYXJzZUZsb2F0KG1hdGNoWzRdKSk7XHJcbiAgICBlbHNlIGlmIChvcHRpb25zLmhhc1opXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwYXJzZUZsb2F0KG1hdGNoWzFdKSwgcGFyc2VGbG9hdChtYXRjaFsyXSksIHBhcnNlRmxvYXQobWF0Y2hbM10pKTtcclxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaGFzTSlcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBhcnNlRmxvYXQobWF0Y2hbMV0pLCBwYXJzZUZsb2F0KG1hdGNoWzJdKSwgdW5kZWZpbmVkLCBwYXJzZUZsb2F0KG1hdGNoWzNdKSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwYXJzZUZsb2F0KG1hdGNoWzFdKSwgcGFyc2VGbG9hdChtYXRjaFsyXSkpO1xyXG59O1xyXG5cclxuV2t0UGFyc2VyLnByb3RvdHlwZS5tYXRjaENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICB2YXIgc3RhcnRzV2l0aEJyYWNrZXQgPSB0aGlzLmlzTWF0Y2goWycoJ10pO1xyXG5cclxuICAgICAgICBjb29yZGluYXRlcy5wdXNoKHRoaXMubWF0Y2hDb29yZGluYXRlKG9wdGlvbnMpKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGhCcmFja2V0KVxyXG4gICAgICAgICAgICB0aGlzLmV4cGVjdEdyb3VwRW5kKCk7XHJcbiAgICB9IHdoaWxlICh0aGlzLmlzTWF0Y2goWycsJ10pKTtcclxuXHJcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XHJcbn07XHJcblxyXG5Xa3RQYXJzZXIucHJvdG90eXBlLnNraXBXaGl0ZXNwYWNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy52YWx1ZS5sZW5ndGggJiYgdGhpcy52YWx1ZVt0aGlzLnBvc2l0aW9uXSA9PT0gJyAnKVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcclxufTtcclxuIiwiZXhwb3J0cy5UeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcclxuZXhwb3J0cy5HZW9tZXRyeSA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxuZXhwb3J0cy5Qb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcclxuZXhwb3J0cy5MaW5lU3RyaW5nID0gcmVxdWlyZSgnLi9saW5lc3RyaW5nJyk7XHJcbmV4cG9ydHMuUG9seWdvbiA9IHJlcXVpcmUoJy4vcG9seWdvbicpO1xyXG5leHBvcnRzLk11bHRpUG9pbnQgPSByZXF1aXJlKCcuL211bHRpcG9pbnQnKTtcclxuZXhwb3J0cy5NdWx0aUxpbmVTdHJpbmcgPSByZXF1aXJlKCcuL211bHRpbGluZXN0cmluZycpO1xyXG5leHBvcnRzLk11bHRpUG9seWdvbiA9IHJlcXVpcmUoJy4vbXVsdGlwb2x5Z29uJyk7XHJcbmV4cG9ydHMuR2VvbWV0cnlDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9nZW9tZXRyeWNvbGxlY3Rpb24nKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGVuY29kZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA8PCAxKSBeICh2YWx1ZSA+PiAzMSk7XHJcbiAgICB9LFxyXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlID4+IDEpIF4gKC0odmFsdWUgJiAxKSk7XHJcbiAgICB9XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdsb2JcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxvZGFzaC9fYmFzZUlzTmF0aXZlXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1vbWVudFwiKTs7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV1aWRcIik7OyIsIl9fd2VicGFja19yZXF1aXJlX18uaCA9ICgpID0+IChcImY2MGE2OWRjODFiYjUxNjQ4YmI4XCIpIl0sInNvdXJjZVJvb3QiOiIifQ==